{"buggy_code": ["import base64\nimport copy\nimport datetime\nimport json\nimport os\nimport re\nimport secrets\nimport time\nimport urllib\nfrom contextlib import contextmanager\nfrom typing import Any, Callable, Dict, Iterator, List, Mapping, Optional, Sequence, Tuple, Type\nfrom unittest import mock\nfrom urllib.parse import urlencode\n\nimport jwt\nimport ldap\nimport orjson\nimport requests\nimport responses\nfrom bs4 import BeautifulSoup\nfrom bs4.element import Tag\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate\nfrom django.core import mail\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import override_settings\nfrom django.test.client import RequestFactory\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\nfrom django_auth_ldap.backend import LDAPSearch, _LDAPUser\nfrom jwt.exceptions import PyJWTError\nfrom onelogin.saml2.auth import OneLogin_Saml2_Auth\nfrom onelogin.saml2.logout_request import OneLogin_Saml2_Logout_Request\nfrom onelogin.saml2.response import OneLogin_Saml2_Response\nfrom onelogin.saml2.utils import OneLogin_Saml2_Utils\nfrom social_core.exceptions import AuthFailed, AuthStateForbidden\nfrom social_django.storage import BaseDjangoStorage\nfrom social_django.strategy import DjangoStrategy\n\nfrom confirmation.models import Confirmation, create_confirmation_link\nfrom zerver.lib.actions import (\n    change_user_is_active,\n    do_create_realm,\n    do_create_user,\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_invite_users,\n    do_reactivate_realm,\n    do_reactivate_user,\n    do_set_realm_property,\n    ensure_stream,\n)\nfrom zerver.lib.avatar import avatar_url\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.dev_ldap_directory import generate_dev_ldap_dir\nfrom zerver.lib.email_validation import (\n    get_existing_user_errors,\n    get_realm_email_validator,\n    validate_email_is_valid,\n)\nfrom zerver.lib.exceptions import JsonableError, RateLimited\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import otp_decrypt_api_key\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.storage import static_path\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    create_s3_buckets,\n    load_subdomain_token,\n    read_test_image_file,\n    use_s3_backend,\n)\nfrom zerver.lib.types import Validator\nfrom zerver.lib.upload import DEFAULT_AVATAR_SIZE, MEDIUM_AVATAR_SIZE, resize_avatar\nfrom zerver.lib.users import get_all_api_keys\nfrom zerver.lib.validator import (\n    check_bool,\n    check_dict_only,\n    check_int,\n    check_list,\n    check_none_or,\n    check_string,\n    validate_login_email,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    MultiuseInvite,\n    PasswordTooWeakError,\n    PreregistrationUser,\n    Realm,\n    RealmDomain,\n    UserProfile,\n    clear_supported_auth_backends_cache,\n    email_to_username,\n    get_realm,\n    get_user_by_delivery_email,\n)\nfrom zerver.signals import JUST_CREATED_THRESHOLD\nfrom zerver.views.auth import log_into_subdomain, maybe_send_to_registration\nfrom zproject.backends import (\n    AUTH_BACKEND_NAME_MAP,\n    AppleAuthBackend,\n    AzureADAuthBackend,\n    DevAuthBackend,\n    EmailAuthBackend,\n    ExternalAuthDataDict,\n    ExternalAuthResult,\n    GenericOpenIdConnectBackend,\n    GitHubAuthBackend,\n    GitLabAuthBackend,\n    GoogleAuthBackend,\n    PopulateUserLDAPError,\n    RateLimitedAuthenticationByUsername,\n    SAMLAuthBackend,\n    SAMLDocument,\n    SocialAuthMixin,\n    ZulipAuthMixin,\n    ZulipDummyBackend,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPConfigurationError,\n    ZulipLDAPException,\n    ZulipLDAPExceptionNoMatchingLDAPUser,\n    ZulipLDAPExceptionOutsideDomain,\n    ZulipLDAPUser,\n    ZulipLDAPUserPopulator,\n    ZulipRemoteUserBackend,\n    apple_auth_enabled,\n    check_password_strength,\n    dev_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    github_auth_enabled,\n    gitlab_auth_enabled,\n    google_auth_enabled,\n    password_auth_enabled,\n    query_ldap,\n    require_email_format_usernames,\n    saml_auth_enabled,\n    sync_user_from_ldap,\n)\n\n\nclass AuthBackendTest(ZulipTestCase):\n    def get_username(self, email_to_username: Optional[Callable[[str], str]] = None) -> str:\n        username = self.example_email(\"hamlet\")\n        if email_to_username is not None:\n            username = email_to_username(self.example_email(\"hamlet\"))\n\n        return username\n\n    def verify_backend(\n        self,\n        backend: Any,\n        *,\n        good_kwargs: Dict[str, Any],\n        bad_kwargs: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        clear_supported_auth_backends_cache()\n        user_profile = self.example_user(\"hamlet\")\n\n        # If bad_kwargs was specified, verify auth fails in that case\n        if bad_kwargs is not None:\n            self.assertIsNone(backend.authenticate(**bad_kwargs))\n\n        # Verify auth works\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated user\n        do_deactivate_user(user_profile, acting_user=None)\n        result = backend.authenticate(**good_kwargs)\n        if isinstance(backend, SocialAuthMixin):\n            # Returns a redirect to login page with an error.\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result.url,\n                f\"{user_profile.realm.uri}/login/?\"\n                + urlencode({\"is_deactivated\": user_profile.delivery_email}),\n            )\n        else:\n            # Just takes you back to the login page treating as\n            # invalid auth; this is correct because the form will\n            # provide the appropriate validation error for deactivated\n            # account.\n            self.assertIsNone(result)\n\n        # Reactivate the user and verify auth works again\n        do_reactivate_user(user_profile, acting_user=None)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated realm\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n        result = backend.authenticate(**good_kwargs)\n        if isinstance(backend, SocialAuthMixin):\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, user_profile.realm.uri + \"/login/\")\n        else:\n            self.assertIsNone(result)\n\n        # Verify auth works again after reactivating the realm\n        do_reactivate_realm(user_profile.realm)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # ZulipDummyBackend isn't a real backend so the remainder\n        # doesn't make sense for it\n        if isinstance(backend, ZulipDummyBackend):\n            return\n\n        # Verify auth fails if the auth backend is disabled on server\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipDummyBackend\",)):\n            clear_supported_auth_backends_cache()\n            result = backend.authenticate(**good_kwargs)\n            if isinstance(backend, SocialAuthMixin):\n                self.assertEqual(result.status_code, 302)\n                self.assertEqual(result.url, user_profile.realm.uri + \"/login/\")\n            else:\n                self.assertIsNone(result)\n        clear_supported_auth_backends_cache()\n\n        # Verify auth fails if the auth backend is disabled for the realm\n        for backend_name in AUTH_BACKEND_NAME_MAP.keys():\n            if isinstance(backend, AUTH_BACKEND_NAME_MAP[backend_name]):\n                break\n\n        index = getattr(user_profile.realm.authentication_methods, backend_name).number\n        user_profile.realm.authentication_methods.set_bit(index, False)\n        user_profile.realm.save()\n        if \"realm\" in good_kwargs:\n            # Because this test is a little unfaithful to the ordering\n            # (i.e. we fetched the realm object before this function\n            # was called, when in fact it should be fetched after we\n            # changed the allowed authentication methods), we need to\n            # propagate the changes we just made to the actual realm\n            # object in good_kwargs.\n            good_kwargs[\"realm\"] = user_profile.realm\n\n        if isinstance(backend, SocialAuthMixin):\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, user_profile.realm.uri + \"/login/\")\n        else:\n            self.assertIsNone(result)\n        user_profile.realm.authentication_methods.set_bit(index, True)\n        user_profile.realm.save()\n\n    def test_dummy_backend(self) -> None:\n        realm = get_realm(\"zulip\")\n        username = self.get_username()\n        self.verify_backend(\n            ZulipDummyBackend(),\n            good_kwargs=dict(username=username, realm=realm, use_dummy_backend=True),\n            bad_kwargs=dict(username=username, realm=realm, use_dummy_backend=False),\n        )\n\n    def setup_subdomain(self, user_profile: UserProfile) -> None:\n        realm = user_profile.realm\n        realm.string_id = \"zulip\"\n        realm.save()\n\n    def test_email_auth_backend(self) -> None:\n        username = self.get_username()\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        with mock.patch(\"zproject.backends.email_auth_enabled\", return_value=False), mock.patch(\n            \"zproject.backends.password_auth_enabled\", return_value=True\n        ):\n            return_data: Dict[str, bool] = {}\n            user = EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=user_profile.delivery_email,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data=return_data,\n            )\n            self.assertEqual(user, None)\n            self.assertTrue(return_data[\"email_auth_disabled\"])\n\n        self.verify_backend(\n            EmailAuthBackend(),\n            good_kwargs=dict(\n                request=mock.MagicMock(),\n                password=password,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                return_data={},\n            ),\n            bad_kwargs=dict(\n                request=mock.MagicMock(),\n                password=password,\n                username=username,\n                realm=get_realm(\"zephyr\"),\n                return_data={},\n            ),\n        )\n\n    def test_email_auth_backend_empty_password(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        # First, verify authentication works with a nonempty\n        # password so we know we've set up the test correctly.\n        self.assertIsNotNone(\n            EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=password,\n                realm=get_realm(\"zulip\"),\n            )\n        )\n\n        # Now do the same test with the empty string as the password.\n        password = \"\"\n        with self.assertRaises(PasswordTooWeakError):\n            # UserProfile.set_password protects against setting an empty password.\n            user_profile.set_password(password)\n        # We do want to force an empty password for this test, so we bypass the protection\n        # by using Django's version of this method.\n        super(UserProfile, user_profile).set_password(password)\n        user_profile.save()\n        self.assertIsNone(\n            EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=password,\n                realm=get_realm(\"zulip\"),\n            )\n        )\n\n    def test_email_auth_backend_disabled_password_auth(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n        # Verify if a realm has password auth disabled, correct password is rejected\n        with mock.patch(\"zproject.backends.password_auth_enabled\", return_value=False):\n            self.assertIsNone(\n                EmailAuthBackend().authenticate(\n                    request=mock.MagicMock(),\n                    username=self.example_email(\"hamlet\"),\n                    password=password,\n                    realm=get_realm(\"zulip\"),\n                )\n            )\n\n    def test_email_auth_backend_password_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"), self.assertRaises(JsonableError) as m:\n            EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=password,\n                realm=get_realm(\"zulip\"),\n            )\n        self.assertEqual(str(m.exception), \"You need to reset your password.\")\n\n    def test_login_preview(self) -> None:\n        # Test preview=true displays organization login page\n        # instead of redirecting to app\n        self.login(\"iago\")\n        realm = get_realm(\"zulip\")\n        result = self.client_get(\"/login/\", {\"preview\": \"true\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(realm.description, result)\n        assert realm.name is not None\n        self.assert_in_response(realm.name, result)\n        self.assert_in_response(\"Log in to Zulip\", result)\n\n        data = dict(\n            description=orjson.dumps(\"New realm description\").decode(),\n            name=orjson.dumps(\"New Zulip\").decode(),\n        )\n        result = self.client_patch(\"/json/realm\", data)\n        self.assert_json_success(result)\n\n        result = self.client_get(\"/login/\", {\"preview\": \"true\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"New realm description\", result)\n        self.assert_in_response(\"New Zulip\", result)\n\n        result = self.client_get(\"/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zulip.testserver\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipDummyBackend\",))\n    def test_no_backend_enabled(self) -> None:\n        result = self.client_get(\"/login/\")\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n        result = self.client_get(\"/register/\")\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GoogleAuthBackend\",))\n    def test_any_backend_enabled(self) -> None:\n\n        # testing to avoid false error messages.\n        result = self.client_get(\"/login/\")\n        self.assert_not_in_success_response([\"No authentication backends are enabled\"], result)\n\n        result = self.client_get(\"/register/\")\n        self.assert_not_in_success_response([\"No authentication backends are enabled\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",), LDAP_EMAIL_ATTR=\"mail\"\n    )\n    def test_ldap_backend(self) -> None:\n        self.init_default_ldap_database()\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        password = self.ldap_password(\"hamlet\")\n        self.setup_subdomain(user_profile)\n\n        username = self.get_username()\n        backend = ZulipLDAPAuthBackend()\n\n        # Test LDAP auth fails when LDAP server rejects password\n        self.assertIsNone(\n            backend.authenticate(\n                request=mock.MagicMock(),\n                username=email,\n                password=\"wrongpass\",\n                realm=get_realm(\"zulip\"),\n            )\n        )\n\n        self.verify_backend(\n            backend,\n            bad_kwargs=dict(\n                request=mock.MagicMock(),\n                username=username,\n                password=password,\n                realm=get_realm(\"zephyr\"),\n            ),\n            good_kwargs=dict(\n                request=mock.MagicMock(),\n                username=username,\n                password=password,\n                realm=get_realm(\"zulip\"),\n            ),\n        )\n\n    def test_devauth_backend(self) -> None:\n        self.verify_backend(\n            DevAuthBackend(),\n            good_kwargs=dict(dev_auth_username=self.get_username(), realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(dev_auth_username=self.get_username(), realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_remote_user_backend(self) -> None:\n        username = self.get_username()\n        self.verify_backend(\n            ZulipRemoteUserBackend(),\n            good_kwargs=dict(remote_user=username, realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(remote_user=username, realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_remote_user_backend_invalid_realm(self) -> None:\n        username = self.get_username()\n        self.verify_backend(\n            ZulipRemoteUserBackend(),\n            good_kwargs=dict(remote_user=username, realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(remote_user=username, realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    @override_settings(SSO_APPEND_DOMAIN=\"zulip.com\")\n    def test_remote_user_backend_sso_append_domain(self) -> None:\n        username = self.get_username(email_to_username)\n        self.verify_backend(\n            ZulipRemoteUserBackend(),\n            good_kwargs=dict(remote_user=username, realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(remote_user=username, realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.GitHubAuthBackend\",\n            \"zproject.backends.GoogleAuthBackend\",\n        )\n    )\n    def test_social_auth_backends(self) -> None:\n        user = self.example_user(\"hamlet\")\n        token_data_dict = {\n            \"access_token\": \"foobar\",\n            \"token_type\": \"bearer\",\n        }\n        github_email_data = [\n            dict(email=user.delivery_email, verified=True, primary=True),\n            dict(email=\"nonprimary@zulip.com\", verified=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        google_email_data = dict(\n            email=user.delivery_email, name=user.full_name, email_verified=True\n        )\n        backends_to_test: Dict[str, Any] = {\n            \"google\": {\n                \"urls\": [\n                    # The limited process that we test here doesn't require mocking any urls.\n                ],\n                \"backend\": GoogleAuthBackend,\n            },\n            \"github\": {\n                \"urls\": [\n                    {\n                        \"url\": \"https://api.github.com/user/emails\",\n                        \"method\": responses.GET,\n                        \"status\": 200,\n                        \"body\": json.dumps(github_email_data),\n                    },\n                ],\n                \"backend\": GitHubAuthBackend,\n            },\n        }\n\n        def patched_authenticate(\n            request: Optional[HttpResponse] = None,\n            **kwargs: Any,\n        ) -> Any:\n            # This is how we pass the subdomain to the authentication\n            # backend in production code, so we need to do this setup\n            # here.\n            if \"subdomain\" in kwargs:\n                backend.strategy.session_set(\"subdomain\", kwargs[\"subdomain\"])\n                del kwargs[\"subdomain\"]\n\n            # Because we're not simulating the full python-social-auth\n            # pipeline here, we need to provide the user's choice of\n            # which email to select in the partial phase of the\n            # pipeline when we display an email picker for the GitHub\n            # authentication backend.  We do that here.\n            def return_email() -> Dict[str, str]:\n                return {\"email\": user.delivery_email}\n\n            backend.strategy.request_data = return_email\n\n            if request is None:\n                request = mock.MagicMock()\n                request.META = dict(REMOTE_ADDR=\"127.0.0.1\")\n            backend.strategy.request = request\n\n            result = orig_authenticate(backend, request, **kwargs)\n            return result\n\n        def patched_get_verified_emails(*args: Any, **kwargs: Any) -> Any:\n            return google_email_data[\"email\"]\n\n        for backend_name in backends_to_test:\n            with responses.RequestsMock(assert_all_requests_are_fired=True) as requests_mock:\n                urls: List[Dict[str, Any]] = backends_to_test[backend_name][\"urls\"]\n                for details in urls:\n                    requests_mock.add(\n                        details[\"method\"],\n                        details[\"url\"],\n                        status=details[\"status\"],\n                        body=details[\"body\"],\n                    )\n                backend_class = backends_to_test[backend_name][\"backend\"]\n\n                # We're creating a new class instance here, so the\n                # monkey-patching of the instance that we're about to\n                # do will be discarded at the end of this test.\n                backend = backend_class()\n                backend.strategy = DjangoStrategy(storage=BaseDjangoStorage())\n\n                orig_authenticate = backend_class.authenticate\n                backend.authenticate = patched_authenticate\n                if backend_name == \"google\":\n                    backend.get_verified_emails = patched_get_verified_emails\n\n                good_kwargs = dict(\n                    backend=backend,\n                    strategy=backend.strategy,\n                    storage=backend.strategy.storage,\n                    response=token_data_dict,\n                    subdomain=\"zulip\",\n                )\n                bad_kwargs = dict(subdomain=\"acme\")\n                logger_name = f\"zulip.auth.{backend.name}\"\n\n                with mock.patch(\n                    \"zerver.views.auth.redirect_and_log_into_subdomain\", return_value=user\n                ), self.assertLogs(logger_name, level=\"INFO\") as info_log:\n                    self.verify_backend(backend, good_kwargs=good_kwargs, bad_kwargs=bad_kwargs)\n                    bad_kwargs[\"subdomain\"] = \"zephyr\"\n                    self.verify_backend(backend, good_kwargs=good_kwargs, bad_kwargs=bad_kwargs)\n                # Verify logging for deactivated users\n                self.assertEqual(\n                    # Filter out noisy logs:\n                    [\n                        output\n                        for output in info_log.output\n                        if \"Authentication attempt from 127.0.0.1\" not in output\n                    ],\n                    [\n                        f\"INFO:{logger_name}:Failed login attempt for deactivated account: {user.id}@{user.realm.string_id}\",\n                        f\"INFO:{logger_name}:Failed login attempt for deactivated account: {user.id}@{user.realm.string_id}\",\n                    ],\n                )\n\n\nclass RateLimitAuthenticationTests(ZulipTestCase):\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def do_test_auth_rate_limiting(\n        self,\n        attempt_authentication_func: Callable[[HttpRequest, str, str], Optional[UserProfile]],\n        username: str,\n        correct_password: str,\n        wrong_password: str,\n        expected_user_profile: UserProfile,\n    ) -> None:\n        # We have to mock RateLimitedAuthenticationByUsername.key to avoid key collisions\n        # if tests run in parallel.\n        original_key_method = RateLimitedAuthenticationByUsername.key\n        salt = secrets.token_hex(16)\n\n        def _mock_key(self: RateLimitedAuthenticationByUsername) -> str:\n            return f\"{salt}:{original_key_method(self)}\"\n\n        def attempt_authentication(username: str, password: str) -> Optional[UserProfile]:\n            request = HttpRequest()\n            request.session = mock.MagicMock()\n            return attempt_authentication_func(request, username, password)\n\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n        with mock.patch.object(RateLimitedAuthenticationByUsername, \"key\", new=_mock_key):\n            try:\n                start_time = time.time()\n                with mock.patch(\"time.time\", return_value=start_time):\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    # 2 failed attempts is the limit, so the next ones should get blocked,\n                    # even with the correct password.\n                    with self.assertRaises(RateLimited):\n                        attempt_authentication(username, correct_password)\n                    with self.assertRaises(RateLimited):\n                        attempt_authentication(username, wrong_password)\n\n                # After enough time passes, more authentication attempts can be made:\n                with mock.patch(\"time.time\", return_value=start_time + 11.0):\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n\n                    # Correct password\n                    self.assertEqual(\n                        attempt_authentication(username, correct_password), expected_user_profile\n                    )\n                    # A correct login attempt should reset the rate limits for this user profile,\n                    # so the next two attempts shouldn't get limited:\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    # But the third attempt goes over the limit:\n                    with self.assertRaises(RateLimited):\n                        attempt_authentication(username, wrong_password)\n            finally:\n                # Clean up to avoid affecting other tests.\n                RateLimitedAuthenticationByUsername(username).clear_history()\n                remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_email_auth_backend_user_based_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        def attempt_authentication(\n            request: HttpRequest, username: str, password: str\n        ) -> Optional[UserProfile]:\n            return EmailAuthBackend().authenticate(\n                request=request,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data={},\n            )\n\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            password,\n            \"wrong_password\",\n            user_profile,\n        )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",), LDAP_EMAIL_ATTR=\"mail\"\n    )\n    def test_ldap_backend_user_based_rate_limiting(self) -> None:\n        self.init_default_ldap_database()\n        user_profile = self.example_user(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        def attempt_authentication(\n            request: HttpRequest, username: str, password: str\n        ) -> Optional[UserProfile]:\n            return ZulipLDAPAuthBackend().authenticate(\n                request=request,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data={},\n            )\n\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            password,\n            \"wrong_password\",\n            user_profile,\n        )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n        ),\n        LDAP_EMAIL_ATTR=\"mail\",\n    )\n    def test_email_and_ldap_backends_user_based_rate_limiting(self) -> None:\n        self.init_default_ldap_database()\n        user_profile = self.example_user(\"hamlet\")\n        ldap_password = self.ldap_password(\"hamlet\")\n\n        email_password = \"email_password\"\n        user_profile.set_password(email_password)\n        user_profile.save()\n\n        def attempt_authentication(\n            request: HttpRequest, username: str, password: str\n        ) -> Optional[UserProfile]:\n            return authenticate(\n                request=request,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data={},\n            )\n\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            email_password,\n            \"wrong_password\",\n            user_profile,\n        )\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            ldap_password,\n            \"wrong_password\",\n            user_profile,\n        )\n\n\nclass CheckPasswordStrengthTest(ZulipTestCase):\n    def test_check_password_strength(self) -> None:\n        with self.settings(PASSWORD_MIN_LENGTH=0, PASSWORD_MIN_GUESSES=0):\n            # Never allow empty password.\n            self.assertFalse(check_password_strength(\"\"))\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            self.assertFalse(check_password_strength(\"\"))\n            self.assertFalse(check_password_strength(\"short\"))\n            # Long enough, but too easy:\n            self.assertFalse(check_password_strength(\"longer\"))\n            # Good password:\n            self.assertTrue(check_password_strength(\"f657gdGGk9\"))\n\n\nclass DesktopFlowTestingLib(ZulipTestCase):\n    def verify_desktop_flow_app_page(self, response: HttpResponse) -> None:\n        self.assertEqual(response.status_code, 200)\n        self.assertIn(b\"<h1>Finish desktop login</h1>\", response.content)\n\n    def verify_desktop_flow_end_page(\n        self, response: HttpResponse, email: str, desktop_flow_otp: str\n    ) -> None:\n        self.assertEqual(response.status_code, 200)\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        input = soup.find(\"input\", value=True)\n        assert isinstance(input, Tag)\n        desktop_data = input[\"value\"]\n        assert isinstance(desktop_data, str)\n        a = soup.find(\"a\", href=True)\n        assert isinstance(a, Tag)\n        browser_url = a[\"href\"]\n\n        self.assertEqual(browser_url, \"/login/\")\n        decrypted_key = self.verify_desktop_data_and_return_key(desktop_data, desktop_flow_otp)\n\n        result = self.client_get(\n            f\"http://zulip.testserver/accounts/login/subdomain/{decrypted_key}\"\n        )\n        self.assertEqual(result.status_code, 302)\n        realm = get_realm(\"zulip\")\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def verify_desktop_data_and_return_key(self, desktop_data: str, desktop_flow_otp: str) -> str:\n        key = bytes.fromhex(desktop_flow_otp)\n        data = bytes.fromhex(desktop_data)\n        iv = data[:12]\n        ciphertext = data[12:]\n        return AESGCM(key).decrypt(iv, ciphertext, b\"\").decode()\n\n\nclass SocialAuthBase(DesktopFlowTestingLib, ZulipTestCase):\n    \"\"\"This is a base class for testing social-auth backends. These\n    methods are often overridden by subclasses:\n\n        register_extra_endpoints() - If the backend being tested calls some extra\n                                     endpoints then they can be added here.\n\n        get_account_data_dict() - Return the data returned by the user info endpoint\n                                  according to the respective backend.\n    \"\"\"\n\n    # Don't run base class tests, make sure to set it to False\n    # in subclass otherwise its tests will not run.\n    __unittest_skip__ = True\n\n    BACKEND_CLASS: \"Type[SocialAuthMixin]\"\n    LOGIN_URL: str\n    SIGNUP_URL: str\n    AUTHORIZATION_URL: str\n    AUTH_FINISH_URL: str\n    ACCESS_TOKEN_URL: str\n    USER_INFO_URL: str\n    CLIENT_KEY_SETTING: str\n    CLIENT_SECRET_SETTING: str\n\n    # Functions that subclasses must implement.\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        ...\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.email = self.user_profile.delivery_email\n        self.name = self.user_profile.full_name\n        self.backend = self.BACKEND_CLASS\n        self.backend.strategy = DjangoStrategy(storage=BaseDjangoStorage())\n        self.user_profile.backend = self.backend\n        self.logger_string = f\"zulip.auth.{self.backend.name}\"\n\n        # This is a workaround for the fact that Python social auth\n        # caches the set of authentication backends that are enabled\n        # the first time that `social_django.utils` is imported.  See\n        # https://github.com/python-social-auth/social-app-django/pull/162\n        # for details.\n        from social_core.backends.utils import load_backends\n\n        load_backends(settings.AUTHENTICATION_BACKENDS, force_load=True)\n\n    def logger_output(self, output_string: str, type: str) -> str:\n        return f\"{type.upper()}:zulip.auth.{self.backend.name}:{output_string}\"\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        pass\n\n    def prepare_login_url_and_headers(\n        self,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        alternative_start_url: Optional[str] = None,\n        *,\n        user_agent: Optional[str] = None,\n    ) -> Tuple[str, Dict[str, Any]]:\n        url = self.LOGIN_URL\n        if alternative_start_url is not None:\n            url = alternative_start_url\n\n        params = {}\n        headers = {}\n        if subdomain == \"\":\n            # \"testserver\" may trip up some libraries' URL validation,\n            # so let's use the equivalent www. version.\n            headers[\"HTTP_HOST\"] = \"www.testserver\"\n        else:\n            headers[\"HTTP_HOST\"] = subdomain + \".testserver\"\n        if mobile_flow_otp is not None:\n            params[\"mobile_flow_otp\"] = mobile_flow_otp\n            headers[\"HTTP_USER_AGENT\"] = \"ZulipAndroid\"\n        if desktop_flow_otp is not None:\n            params[\"desktop_flow_otp\"] = desktop_flow_otp\n        if is_signup:\n            url = self.SIGNUP_URL\n        params[\"next\"] = next\n        params[\"multiuse_object_key\"] = multiuse_object_key\n        if len(params) > 0:\n            url += f\"?{urlencode(params)}\"\n        if user_agent is not None:\n            headers[\"HTTP_USER_AGENT\"] = user_agent\n\n        return url, headers\n\n    def social_auth_test_finish(\n        self,\n        result: HttpResponse,\n        account_data_dict: Dict[str, str],\n        expect_choose_email_screen: bool,\n        headers: Any,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        parsed_url = urllib.parse.urlparse(result.url)\n        csrf_state = urllib.parse.parse_qs(parsed_url.query)[\"state\"]\n        result = self.client_get(self.AUTH_FINISH_URL, dict(state=csrf_state), **headers)\n        return result\n\n    def generate_access_token_url_payload(self, account_data_dict: Dict[str, str]) -> str:\n        return json.dumps(\n            {\n                \"access_token\": \"foobar\",\n                \"token_type\": \"bearer\",\n            }\n        )\n\n    def social_auth_test(\n        self,\n        account_data_dict: Dict[str, str],\n        *,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        expect_choose_email_screen: bool = False,\n        alternative_start_url: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        \"\"\"Main entry point for all social authentication tests.\n\n        * account_data_dict: Dictionary containing the name/email data\n          that should be returned by the social auth backend.\n        * subdomain: Which organization's login page is being accessed.\n        * desktop_flow_otp / mobile_flow_otp: Token to be used for\n          mobile or desktop authentication flow testing.\n        * is_signup: Whether we're testing the social flow for\n          /register (True) or /login (False).  This is important\n          because we need to verify behavior like the\n          \"Continue to registration\" if you try to log in using an\n          account that doesn't exist but is allowed to sign up.\n        * next: Parameter passed through in production authentication\n          to redirect the user to (e.g.) the specific page in the web app\n          that they clicked a link to before being presented with the login\n          page.\n        * expect_choose_email_screen: Some social auth backends, like\n          GitHub, simultaneously authenticate for multiple email addresses.\n          Set this to True if we expect to show the \"Choose Email\" screen\n          in this test should the backend have that feature.\n        * multiuse_object_key: Used when the user has clicked a multi-use\n          reusable invitation link.\n        * alternative_start_url: Used to test legacy mobile app behavior.\n        * user_agent: What user-agent to use for the HTTP requests.\n        \"\"\"\n\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            alternative_start_url,\n            user_agent=user_agent,\n        )\n\n        result = self.client_get(url, **headers)\n\n        expected_result_url_prefix = f\"http://testserver/login/{self.backend.name}/\"\n        if settings.SOCIAL_AUTH_SUBDOMAIN is not None:\n            expected_result_url_prefix = (\n                f\"http://{settings.SOCIAL_AUTH_SUBDOMAIN}.testserver/login/{self.backend.name}/\"\n            )\n\n        if result.status_code != 302 or not result.url.startswith(expected_result_url_prefix):\n            return result\n\n        result = self.client_get(result.url, **headers)\n        self.assertEqual(result.status_code, 302)\n        assert self.AUTHORIZATION_URL in result.url\n\n        self.client.cookies = result.cookies\n\n        # Next, the browser requests result[\"Location\"], and gets\n        # redirected back to the registered redirect uri.\n\n        # We register callbacks for the key URLs on Identity Provider that\n        # auth completion URL will call\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as requests_mock:\n            requests_mock.add(\n                requests_mock.POST,\n                self.ACCESS_TOKEN_URL,\n                status=200,\n                body=self.generate_access_token_url_payload(account_data_dict),\n            )\n            requests_mock.add(\n                requests_mock.GET,\n                self.USER_INFO_URL,\n                status=200,\n                body=json.dumps(account_data_dict),\n            )\n            self.register_extra_endpoints(requests_mock, account_data_dict, **extra_data)\n\n            result = self.social_auth_test_finish(\n                result, account_data_dict, expect_choose_email_screen, headers=headers, **extra_data\n            )\n        return result\n\n    def test_social_auth_no_key(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.settings(**{self.CLIENT_KEY_SETTING: None}):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\"], result)\n\n    def test_config_error_development(self) -> None:\n        if hasattr(self, \"CLIENT_KEY_SETTING\") and hasattr(self, \"CLIENT_SECRET_SETTING\"):\n            with self.settings(**{self.CLIENT_KEY_SETTING: None}):\n                result = self.client_get(self.LOGIN_URL)\n                self.assert_in_success_response([\"Configuration error\"], result)\n                self.assert_in_success_response([self.CLIENT_KEY_SETTING.lower()], result)\n                self.assert_in_success_response([self.CLIENT_SECRET_SETTING.lower()], result)\n                self.assert_in_success_response([\"zproject/dev-secrets.conf\"], result)\n                self.assert_not_in_success_response([self.CLIENT_KEY_SETTING], result)\n                self.assert_not_in_success_response([\"zproject/dev_settings.py\"], result)\n                self.assert_not_in_success_response([\"/etc/zulip/settings.py\"], result)\n                self.assert_not_in_success_response([\"/etc/zulip/zulip-secrets.conf\"], result)\n\n    @override_settings(DEVELOPMENT=False)\n    def test_config_error_production(self) -> None:\n        if hasattr(self, \"CLIENT_KEY_SETTING\") and hasattr(self, \"CLIENT_SECRET_SETTING\"):\n            with self.settings(**{self.CLIENT_KEY_SETTING: None}):\n                result = self.client_get(self.LOGIN_URL)\n                self.assert_in_success_response([\"Configuration error\"], result)\n                self.assert_in_success_response([self.CLIENT_KEY_SETTING], result)\n                self.assert_in_success_response([\"/etc/zulip/settings.py\"], result)\n                self.assert_in_success_response([self.CLIENT_SECRET_SETTING.lower()], result)\n                self.assert_in_success_response([\"/etc/zulip/zulip-secrets.conf\"], result)\n                self.assert_not_in_success_response([self.CLIENT_KEY_SETTING.lower()], result)\n                self.assert_not_in_success_response([\"zproject/dev_settings.py\"], result)\n                self.assert_not_in_success_response([\"zproject/dev-secrets.conf\"], result)\n\n    def test_social_auth_success(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=False,\n                subdomain=\"zulip\",\n                next=\"/user_uploads/image\",\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.assertIn(\n            f\"INFO:{self.logger_string}:Authentication attempt from 127.0.0.1: subdomain=zulip;username=hamlet@zulip.com;outcome=success\",\n            m.output[0],\n        )\n\n    @override_settings(SOCIAL_AUTH_SUBDOMAIN=None)\n    def test_when_social_auth_subdomain_is_not_set(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_social_auth_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        # We expect to go through the \"choose email\" screen here,\n        # because there won't be an existing user account we can\n        # auto-select for the user.\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.social_auth_test(\n                account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\"\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result.url,\n                f\"{user_profile.realm.uri}/login/?\"\n                + urlencode({\"is_deactivated\": user_profile.delivery_email}),\n            )\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    f\"Failed login attempt for deactivated account: {user_profile.id}@zulip\", \"info\"\n                )\n            ],\n        )\n\n        result = self.client_get(result.url)\n        self.assert_in_success_response(\n            [f\"Your account {user_profile.delivery_email} has been deactivated.\"], result\n        )\n\n    def test_social_auth_invalid_realm(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with mock.patch(\"zerver.middleware.get_realm\", return_value=get_realm(\"zulip\")):\n            # This mock.patch case somewhat hackishly arranges it so\n            # that we switch realms halfway through the test\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"invalid\", next=\"/user_uploads/image\"\n            )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/\")\n\n    def test_social_auth_invalid_email(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=\"invalid\", name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                next=\"/user_uploads/image\",\n            )\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    f\"{self.backend.auth_backend_name} got invalid email argument.\",\n                    \"warning\",\n                )\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, realm.uri + \"/register/\")\n\n    def test_user_cannot_log_into_nonexisting_realm(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(account_data_dict, subdomain=\"nonexistent\")\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assertEqual(result.status_code, 404)\n\n    def test_user_cannot_log_into_wrong_subdomain(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zephyr\"\n        )\n        self.assertTrue(result.url.startswith(\"http://zephyr.testserver/accounts/login/subdomain/\"))\n        result = self.client_get(\n            result.url.replace(\"http://zephyr.testserver\", \"\"), subdomain=\"zephyr\"\n        )\n        self.assert_in_success_response(\n            [\n                \"Your email address, hamlet@zulip.com, is not in one of the domains \",\n                \"that are allowed to register for accounts in this organization.\",\n            ],\n            result,\n        )\n\n    def test_social_auth_mobile_success(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        hamlet = self.example_user(\"hamlet\")\n        account_data_dict = self.get_account_data_dict(\n            email=hamlet.delivery_email, name=\"Full Name\"\n        )\n        self.assert_length(mail.outbox, 0)\n        self.user_profile.date_joined = timezone_now() - datetime.timedelta(\n            seconds=JUST_CREATED_THRESHOLD + 1\n        )\n        self.user_profile.save()\n\n        with self.settings(SEND_LOGIN_EMAILS=True):\n            # Verify that the right thing happens with an invalid-format OTP\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", mobile_flow_otp=\"1234\"\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", mobile_flow_otp=\"invalido\" * 8\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n\n            # Now do it correctly\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=False,\n                mobile_flow_otp=mobile_flow_otp,\n            )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [hamlet.delivery_email])\n        self.assertEqual(query_params[\"user_id\"], [str(hamlet.id)])\n\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    def test_social_auth_desktop_success(self) -> None:\n        desktop_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.social_auth_test(\n            account_data_dict, subdomain=\"zulip\", desktop_flow_otp=\"1234\"\n        )\n        self.assert_json_error(result, \"Invalid OTP\")\n        result = self.social_auth_test(\n            account_data_dict, subdomain=\"zulip\", desktop_flow_otp=\"invalido\" * 8\n        )\n        self.assert_json_error(result, \"Invalid OTP\")\n\n        # Now do it correctly\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            desktop_flow_otp=desktop_flow_otp,\n            user_agent=\"ZulipElectron/5.0.0\",\n        )\n        self.verify_desktop_flow_app_page(result)\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            desktop_flow_otp=desktop_flow_otp,\n        )\n        self.verify_desktop_flow_end_page(result, self.email, desktop_flow_otp)\n\n    def test_social_auth_session_fields_cleared_correctly(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n\n        def initiate_auth(mobile_flow_otp: Optional[str] = None) -> None:\n            url, headers = self.prepare_login_url_and_headers(\n                subdomain=\"zulip\", mobile_flow_otp=mobile_flow_otp\n            )\n            result = self.client_get(url, **headers)\n            self.assertEqual(result.status_code, 302)\n\n            result = self.client_get(result.url, **headers)\n            self.assertEqual(result.status_code, 302)\n\n        # Start social auth with mobile_flow_otp param. It should get saved into the session\n        # on SOCIAL_AUTH_SUBDOMAIN.\n        initiate_auth(mobile_flow_otp)\n        self.assertEqual(self.client.session[\"mobile_flow_otp\"], mobile_flow_otp)\n\n        # Make a request without mobile_flow_otp param and verify the field doesn't persist\n        # in the session from the previous request.\n        initiate_auth()\n        self.assertEqual(self.client.session.get(\"mobile_flow_otp\"), None)\n\n    def test_social_auth_mobile_and_desktop_flow_in_one_request_error(self) -> None:\n        otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            desktop_flow_otp=otp,\n            mobile_flow_otp=otp,\n        )\n        self.assert_json_error(\n            result, \"Can't use both mobile_flow_otp and desktop_flow_otp together.\"\n        )\n\n    def test_social_auth_registration_existing_account(self) -> None:\n        \"\"\"If the user already exists, signup flow just logs them in\"\"\"\n        email = \"hamlet@zulip.com\"\n        name = \"Full Name\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\", is_signup=True\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        # Verify data has the full_name consistent with the user we're logging in as.\n        self.assertEqual(data[\"full_name\"], self.example_user(\"hamlet\").full_name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n        hamlet = self.example_user(\"hamlet\")\n        # Name wasn't changed at all\n        self.assertEqual(hamlet.full_name, \"King Hamlet\")\n\n    def stage_two_of_registration(\n        self,\n        result: HttpResponse,\n        realm: Realm,\n        subdomain: str,\n        email: str,\n        name: str,\n        expected_final_name: str,\n        skip_registration_form: bool,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        expect_confirm_registration_page: bool = False,\n        expect_full_name_prepopulated: bool = True,\n    ) -> None:\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], email)\n        self.assertEqual(data[\"full_name\"], name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        result = self.client_get(result.url)\n\n        if expect_confirm_registration_page:\n            self.assertEqual(result.status_code, 200)\n        else:\n            self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().last()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        if expect_confirm_registration_page:\n            self.assert_in_success_response([\"do_confirm/\" + confirmation_key], result)\n            do_confirm_url = \"/accounts/do_confirm/\" + confirmation_key\n        else:\n            self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n            do_confirm_url = result.url\n        result = self.client_get(do_confirm_url, name=name)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        confirmation_data = {\"from_confirmation\": \"1\", \"key\": confirmation_key}\n        result = self.client_post(\"/accounts/register/\", confirmation_data)\n        if not skip_registration_form:\n            self.assert_in_response(\"We just need you to do one last thing\", result)\n\n            # Verify that the user is asked for name but not password\n            self.assert_not_in_success_response([\"id_password\"], result)\n            self.assert_in_success_response([\"id_full_name\"], result)\n            if expect_full_name_prepopulated:\n                # Verify the name field gets correctly pre-populated:\n                self.assert_in_success_response([expected_final_name], result)\n\n            # Click confirm registration button.\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\"full_name\": expected_final_name, \"key\": confirmation_key, \"terms\": True},\n            )\n\n        # Mobile and desktop flow have additional steps:\n        if mobile_flow_otp:\n            self.assertEqual(result.status_code, 302)\n            redirect_url = result[\"Location\"]\n            parsed_url = urllib.parse.urlparse(redirect_url)\n            query_params = urllib.parse.parse_qs(parsed_url.query)\n            self.assertEqual(parsed_url.scheme, \"zulip\")\n            self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n            self.assertEqual(query_params[\"email\"], [email])\n            encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n            user_api_keys = get_all_api_keys(get_user_by_delivery_email(email, realm))\n            self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), user_api_keys)\n            return\n        elif desktop_flow_otp:\n            self.verify_desktop_flow_end_page(result, email, desktop_flow_otp)\n            # Now the desktop app is logged in, continue with the logged in check.\n        else:\n            self.assertEqual(result.status_code, 302)\n\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertEqual(user_profile.full_name, expected_final_name)\n\n        self.assertFalse(user_profile.has_usable_password())\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration(self) -> None:\n        \"\"\"If the user doesn't exist yet, social auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_mobile_registration(self) -> None:\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            is_signup=True,\n            mobile_flow_otp=mobile_flow_otp,\n        )\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            name,\n            name,\n            self.BACKEND_CLASS.full_name_validated,\n            mobile_flow_otp=mobile_flow_otp,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_desktop_registration(self) -> None:\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        desktop_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            is_signup=True,\n            desktop_flow_otp=desktop_flow_otp,\n        )\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            name,\n            name,\n            self.BACKEND_CLASS.full_name_validated,\n            desktop_flow_otp=desktop_flow_otp,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_invitation_exists(self) -> None:\n        \"\"\"\n        This tests the registration flow in the case where an invitation for the user\n        was generated.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n\n        iago = self.example_user(\"iago\")\n        do_invite_users(iago, [email], [], invite_expires_in_days=2)\n\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_with_invalid_multiuse_invite(self) -> None:\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n\n        multiuse_object_key = \"invalid\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=subdomain,\n            is_signup=True,\n            expect_choose_email_screen=True,\n            multiuse_object_key=multiuse_object_key,\n        )\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result.url)\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_using_multiuse_invite(self) -> None:\n        \"\"\"If the user doesn't exist yet, social auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        stream_names = [\"new_stream_1\", \"new_stream_2\"]\n        streams = []\n        for stream_name in set(stream_names):\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        referrer = self.example_user(\"hamlet\")\n        multiuse_obj = MultiuseInvite.objects.create(realm=realm, referred_by=referrer)\n        multiuse_obj.streams.set(streams)\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_obj, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        multiuse_confirmation = Confirmation.objects.all().last()\n        assert multiuse_confirmation is not None\n        multiuse_object_key = multiuse_confirmation.confirmation_key\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        # First, try to sign up for closed realm without using an invitation\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        result = self.client_get(result.url)\n        # Verify that we're unable to sign up, since this is a closed realm\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Sign up\"], result)\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=subdomain,\n            is_signup=True,\n            expect_choose_email_screen=True,\n            multiuse_object_key=multiuse_object_key,\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    def test_social_auth_registration_without_is_signup(self) -> None:\n        \"\"\"If `is_signup` is not set then a new account isn't created\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], email)\n        self.assertEqual(data[\"full_name\"], name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        result = self.client_get(result.url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"No account found for newuser@zulip.com.\", result)\n\n    def test_social_auth_registration_without_is_signup_closed_realm(self) -> None:\n        \"\"\"If the user doesn't exist yet in closed realm, give an error\"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n        email = \"nonexisting@phantom.com\"\n        name = \"Full Name\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], email)\n        self.assertEqual(data[\"full_name\"], name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        result = self.client_get(result.url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response('action=\"/register/\"', result)\n        self.assert_in_response(\n            \"Your email address, {}, is not \"\n            \"in one of the domains that are allowed to register \"\n            \"for accounts in this organization.\".format(email),\n            result,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_with_ldap_populate_registration_from_confirmation(self) -> None:\n        self.init_default_ldap_database()\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        realm = get_realm(\"zulip\")\n        subdomain = \"zulip\"\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        backend_path = f\"zproject.backends.{self.BACKEND_CLASS.__name__}\"\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\n                backend_path,\n                \"zproject.backends.ZulipLDAPUserPopulator\",\n                \"zproject.backends.ZulipDummyBackend\",\n            ),\n        ), self.assertLogs(level=\"WARNING\") as log_warn:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=True,\n            )\n            # Full name should get populated from LDAP:\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                \"New LDAP fullname\",\n                skip_registration_form=True,\n            )\n\n            # Now try a user that doesn't exist in LDAP:\n            email = self.nonreg_email(\"alice\")\n            name = \"Alice Social\"\n            account_data_dict = self.get_account_data_dict(email=email, name=name)\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=True,\n            )\n            # Full name should get populated as provided by the social backend, because\n            # this user isn't in the LDAP dictionary:\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                skip_registration_form=self.BACKEND_CLASS.full_name_validated,\n            )\n        self.assertEqual(\n            log_warn.output, [f\"WARNING:root:New account email {email} could not be found in LDAP\"]\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_with_ldap_auth_registration_from_confirmation(self) -> None:\n        \"\"\"\n        This test checks that in configurations that use the LDAP authentication backend\n        and a social backend, it is possible to create non-LDAP users via the social backend.\n        \"\"\"\n        self.init_default_ldap_database()\n        email = self.nonreg_email(\"alice\")\n        name = \"Alice Social\"\n        realm = get_realm(\"zulip\")\n        subdomain = \"zulip\"\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        backend_path = f\"zproject.backends.{self.BACKEND_CLASS.__name__}\"\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\n                backend_path,\n                \"zproject.backends.ZulipLDAPAuthBackend\",\n                \"zproject.backends.ZulipDummyBackend\",\n            ),\n        ), self.assertLogs(\"zulip.ldap\", level=\"DEBUG\") as log_debug, self.assertLogs(\n            level=\"WARNING\"\n        ) as log_warn:\n            account_data_dict = self.get_account_data_dict(email=email, name=name)\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=True,\n            )\n            # Full name should get populated as provided by the social backend, because\n            # this user isn't in the LDAP dictionary:\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                skip_registration_form=self.BACKEND_CLASS.full_name_validated,\n            )\n        self.assertEqual(\n            log_warn.output, [f\"WARNING:root:New account email {email} could not be found in LDAP\"]\n        )\n        self.assertEqual(\n            log_debug.output,\n            [\n                f\"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: {email}. Input username: {email}\"\n            ],\n        )\n\n    def test_social_auth_complete(self) -> None:\n        with mock.patch(\n            \"social_core.backends.oauth.BaseOAuth2.process_error\",\n            side_effect=AuthFailed(\"Not found\"),\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(reverse(\"social:complete\", args=[self.backend.name]))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\"AuthFailed: Authentication failed: \", \"info\"),\n            ],\n        )\n\n        with mock.patch(\n            \"social_core.backends.oauth.BaseOAuth2.auth_complete\",\n            side_effect=requests.exceptions.HTTPError,\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(reverse(\"social:complete\", args=[self.backend.name]))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\"HTTPError: \", \"info\"),\n            ],\n        )\n\n    def test_social_auth_complete_when_base_exc_is_raised(self) -> None:\n        with mock.patch(\n            \"social_core.backends.oauth.BaseOAuth2.auth_complete\",\n            side_effect=AuthStateForbidden(\"State forbidden\"),\n        ), self.assertLogs(self.logger_string, level=\"WARNING\"):\n            result = self.client_get(reverse(\"social:complete\", args=[self.backend.name]))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_invited_as_admin_but_expired(self) -> None:\n        iago = self.example_user(\"iago\")\n        email = self.nonreg_email(\"alice\")\n        name = \"Alice Jones\"\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            iago,\n            [email],\n            [],\n            invite_expires_in_days=invite_expires_in_days,\n            invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"],\n        )\n        now = timezone_now() + datetime.timedelta(days=invite_expires_in_days + 1)\n\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        with mock.patch(\"zerver.models.timezone_now\", return_value=now):\n            self.stage_two_of_registration(\n                result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n            )\n\n        # The invitation is expired, so the user should be created as normal member only.\n        created_user = get_user_by_delivery_email(email, realm)\n        self.assertEqual(created_user.role, UserProfile.ROLE_MEMBER)\n\n\nclass SAMLAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = SAMLAuthBackend\n    LOGIN_URL = \"/accounts/login/social/saml/test_idp\"\n    SIGNUP_URL = \"/accounts/register/social/saml/test_idp\"\n    AUTHORIZATION_URL = \"https://idp.testshib.org/idp/profile/SAML2/Redirect/SSO\"\n    AUTH_FINISH_URL = \"/complete/saml/\"\n\n    # We have to define our own social_auth_test as the flow of SAML authentication\n    # is different from the other social backends.\n    def social_auth_test(\n        self,\n        account_data_dict: Dict[str, str],\n        *,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        user_agent: Optional[str] = None,\n        extra_attributes: Mapping[str, List[str]] = {},\n        **extra_data: Any,\n    ) -> HttpResponse:\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            user_agent=user_agent,\n        )\n\n        result = self.client_get(url, **headers)\n\n        expected_result_url_prefix = f\"http://testserver/login/{self.backend.name}/\"\n        if settings.SOCIAL_AUTH_SUBDOMAIN is not None:\n            expected_result_url_prefix = (\n                f\"http://{settings.SOCIAL_AUTH_SUBDOMAIN}.testserver/login/{self.backend.name}/\"\n            )\n\n        if result.status_code != 302 or not result.url.startswith(expected_result_url_prefix):\n            return result\n\n        result = self.client_get(result.url, **headers)\n\n        self.assertEqual(result.status_code, 302)\n        assert self.AUTHORIZATION_URL in result.url\n        assert \"samlrequest\" in result.url.lower()\n\n        self.client.cookies = result.cookies\n        parsed_url = urllib.parse.urlparse(result.url)\n        relay_state = urllib.parse.parse_qs(parsed_url.query)[\"RelayState\"][0]\n        # Make sure params are getting encoded into RelayState:\n        data = SAMLAuthBackend.get_data_from_redis(orjson.loads(relay_state)[\"state_token\"])\n        assert data is not None\n        if next:\n            self.assertEqual(data[\"next\"], next)\n        if is_signup:\n            self.assertEqual(data[\"is_signup\"], \"1\")\n\n        saml_response = self.generate_saml_response(\n            email=account_data_dict[\"email\"],\n            name=account_data_dict[\"name\"],\n            extra_attributes=extra_attributes,\n        )\n        post_params = {\"SAMLResponse\": saml_response, \"RelayState\": relay_state}\n        # The mock below is necessary, so that python3-saml accepts our SAMLResponse,\n        # and doesn't verify the cryptographic signatures etc., since generating\n        # a perfectly valid SAMLResponse for the purpose of these tests would be too complex,\n        # and we simply use one loaded from a fixture file.\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We are simulating a cross-domain POST request here. Session is a Lax cookie, meaning\n            # it won't be sent by the browser in this request. To simulate that effect with the django\n            # test client, we flush the session before the request.\n            self.client.session.flush()\n            result = self.client_post(self.AUTH_FINISH_URL, post_params, **headers)\n\n        return result\n\n    def generate_saml_response(\n        self, email: str, name: str, extra_attributes: Mapping[str, List[str]] = {}\n    ) -> str:\n        \"\"\"\n        The samlresponse.txt fixture has a pre-generated SAMLResponse,\n        with {email}, {first_name}, {last_name} placeholders, that can\n        be filled out with the data we want.\n        \"\"\"\n        if name:\n            name_parts = name.split(\" \")\n            first_name = name_parts[0]\n            last_name = name_parts[1]\n        else:\n            first_name = \"\"\n            last_name = \"\"\n\n        extra_attrs = \"\"\n        for extra_attr_name, extra_attr_values in extra_attributes.items():\n            values = \"\".join(\n                '<saml2:AttributeValue xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" '\n                + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"xs:string\">'\n                + f\"{value}</saml2:AttributeValue>\"\n                for value in extra_attr_values\n            )\n            extra_attrs += (\n                f'<saml2:Attribute Name=\"{extra_attr_name}\" '\n                + 'NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\">'\n                + f\"{values}</saml2:Attribute>\"\n            )\n\n        unencoded_saml_response = self.fixture_data(\"samlresponse.txt\", type=\"saml\").format(\n            email=email,\n            first_name=first_name,\n            last_name=last_name,\n            extra_attrs=extra_attrs,\n        )\n        # SAMLResponse needs to be base64-encoded.\n        saml_response: str = base64.b64encode(unencoded_saml_response.encode()).decode()\n\n        return saml_response\n\n    def generate_saml_logout_request_from_idp(self, email: str) -> str:\n        \"\"\"\n        The logoutrequest.txt fixture has a pre-generated LogoutRequest,\n        with {email} placeholder, that can\n        be filled out with the data we want.\n        \"\"\"\n        unencoded_logout_request = self.fixture_data(\"logoutrequest.txt\", type=\"saml\").format(\n            email=email,\n        )\n        logout_request: str = base64.b64encode(unencoded_logout_request.encode()).decode()\n\n        return logout_request\n\n    def make_idp_initiated_logout_request(\n        self, email: str, make_validity_checks_pass: bool = True\n    ) -> HttpResponse:\n        samlrequest = self.generate_saml_logout_request_from_idp(email)\n        parameters = {\"SAMLRequest\": samlrequest}\n\n        if make_validity_checks_pass:\n            # It's hard to create fully-correct LogoutRequests with signatures in tests,\n            # so we rely on mocking the validating functions instead.\n            with mock.patch.object(\n                OneLogin_Saml2_Logout_Request, \"is_valid\", return_value=True\n            ), mock.patch.object(\n                OneLogin_Saml2_Auth,\n                \"validate_request_signature\",\n                return_value=True,\n            ):\n                result = self.client_get(\"http://zulip.testserver/complete/saml/\", parameters)\n        else:\n            result = self.client_get(\"http://zulip.testserver/complete/saml/\", parameters)\n        return result\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        return dict(email=email, name=name)\n\n    def test_saml_idp_initiated_logout_success(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        old_api_key = hamlet.api_key\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        result = self.make_idp_initiated_logout_request(hamlet.delivery_email)\n        self.assert_logged_in_user_id(None)\n\n        # The expected response is a redirect to the IdP's slo_url endpoint\n        # with a SAMLResponse announcing success.\n        self.assertEqual(result.status_code, 302)\n        redirect_to = result[\"Location\"]\n        self.assertIn(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS[\"test_idp\"][\"slo_url\"], redirect_to)\n\n        parsed = urllib.parse.urlparse(redirect_to)\n        query_dict = urllib.parse.parse_qs(parsed.query)\n\n        self.assertIn(\"SAMLResponse\", query_dict)\n        # Do some very basic parsing of the SAMLResponse to verify it's a success response.\n        saml_response_encoded = query_dict[\"SAMLResponse\"][0]\n        saml_response = OneLogin_Saml2_Utils.decode_base64_and_inflate(\n            saml_response_encoded\n        ).decode()\n        self.assertIn(\n            '<samlp:StatusCode Value=\"urn:oasis:names:tc:SAML:2.0:status:Success\" />', saml_response\n        )\n\n        hamlet.refresh_from_db()\n        # Ensure that the user's api_key was rotated:\n        self.assertNotEqual(hamlet.api_key, old_api_key)\n\n    def test_saml_idp_initiated_logout_request_for_different_user(self) -> None:\n        \"\"\"\n        This test verifies that sessions are revoked based on the NameID\n        in the LogoutRequest rather than just the logged in session cookie.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        cordelia_old_api_key = cordelia.api_key\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        # We're logged in as hamlet, but deliver a LogoutRequest for cordelia.\n        # This means our session should not be affected.\n        self.make_idp_initiated_logout_request(cordelia.delivery_email)\n        self.assert_logged_in_user_id(hamlet.id)\n\n        cordelia.refresh_from_db()\n        # Cordelia's api_key should have been rotated:\n        self.assertNotEqual(cordelia.api_key, cordelia_old_api_key)\n\n    def test_saml_idp_initiated_logout_invalid_nameid_format(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            # LogoutRequests need to have the email address in NameID\n            # so putting \"hamlet\" there is invalid.\n            result = self.make_idp_initiated_logout_request(\"hamlet\")\n        self.assert_logged_in_user_id(hamlet.id)\n\n        self.assertEqual(\n            mock_logger.output,\n            [\n                \"INFO:zulip.auth.saml:/complete/saml/: LogoutRequest failed: NameID is not a valid email address: hamlet\"\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/\")\n\n    def test_saml_idp_initiated_logout_user_not_in_realm(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            result = self.make_idp_initiated_logout_request(\"nonexistent@zulip.com\")\n        self.assert_logged_in_user_id(hamlet.id)\n\n        self.assertEqual(\n            mock_logger.output,\n            [\n                \"INFO:zulip.auth.saml:/complete/saml/: LogoutRequest failed: No user with email specified in NameID found in realm 2. return_data={}\"\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/\")\n\n    def test_saml_idp_initiated_logout_invalid_signature(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            # LogoutRequests  we generate in tests don't have signatures. We can use\n            # the make_validity_checks_pass argument to disable mocking of python3-saml\n            # internal validation functions to make validation of our LogoutRequest fail\n            # and test our error-handling of that.\n            result = self.make_idp_initiated_logout_request(\n                hamlet.delivery_email, make_validity_checks_pass=False\n            )\n        self.assert_logged_in_user_id(hamlet.id)\n\n        self.assertEqual(\n            mock_logger.output,\n            [\n                \"INFO:zulip.auth.saml:/complete/saml/: LogoutRequest failed: ['invalid_logout_request_signature', 'Signature validation failed. Logout Request rejected']\"\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/\")\n\n    def test_saml_idp_initiate_logout_invalid_logout_response(self) -> None:\n        parameters = {\"SAMLRequest\": \"this is not a valid SAMLRequest string.\"}\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            result = self.client_get(\"http://zulip.testserver/complete/saml/\", parameters)\n\n        self.assertIn(\n            \"ERROR:zulip.auth.saml:Error parsing SAMLRequest: Start tag expected, '<' not found\",\n            mock_logger.output[0],\n        )\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/login/\")\n\n    def test_auth_registration_with_no_name_provided(self) -> None:\n        \"\"\"\n        The SAMLResponse may not actually provide name values, which is considered\n        unexpected behavior for most social backends, but SAML is an exception. The\n        signup flow should proceed normally, without pre-filling the name in the\n        registration form.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=\"\")\n        result = self.social_auth_test(account_data_dict, subdomain=subdomain, is_signup=True)\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            \"\",\n            \"Full Name\",\n            skip_registration_form=False,\n            expect_full_name_prepopulated=False,\n        )\n\n    def test_social_auth_no_key(self) -> None:\n        \"\"\"\n        Since in the case of SAML there isn't a direct equivalent of CLIENT_KEY_SETTING,\n        we override this test, to test for the case where the obligatory\n        SOCIAL_AUTH_SAML_ENABLED_IDPS isn't configured.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=None):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n            # Test the signup path too:\n            result = self.social_auth_test(\n                account_data_dict, is_signup=True, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n    def test_config_error_page(self) -> None:\n        with self.assertLogs(level=\"INFO\") as info_log:\n            result = self.client_get(\"/accounts/login/social/saml\")\n        self.assertEqual(\n            info_log.output,\n            [\"INFO:root:Attempted to initiate SAML authentication with wrong idp argument: None\"],\n        )\n        self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n    def test_saml_auth_works_without_private_public_keys(self) -> None:\n        with self.settings(SOCIAL_AUTH_SAML_SP_PUBLIC_CERT=\"\", SOCIAL_AUTH_SAML_SP_PRIVATE_KEY=\"\"):\n            self.test_social_auth_success()\n\n    def test_saml_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.SAMLAuthBackend\",)):\n            self.assertTrue(saml_auth_enabled())\n            result = self.client_get(\"/saml/metadata.xml\")\n            self.assert_in_success_response(\n                [f'entityID=\"{settings.SOCIAL_AUTH_SAML_SP_ENTITY_ID}\"'],\n                result,\n            )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_auto_signup(self) -> None:\n        \"\"\"\n        Verify that with SAML auto signup enabled, a user coming from the /login page\n        (so without the is_signup param) will be taken straight to registration, without\n        having to go through the step of having to confirm that they do want to sign up.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"auto_signup\"] = True\n\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=False,\n            )\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                self.BACKEND_CLASS.full_name_validated,\n                expect_confirm_registration_page=False,\n            )\n\n    def test_social_auth_complete(self) -> None:\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            with mock.patch.object(\n                OneLogin_Saml2_Auth, \"is_authenticated\", return_value=False\n            ), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                # This mock causes AuthFailed to be raised.\n                saml_response = self.generate_saml_response(self.email, self.name)\n                relay_state = orjson.dumps(\n                    dict(\n                        state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                    )\n                ).decode()\n                post_params = {\"SAMLResponse\": saml_response, \"RelayState\": relay_state}\n                result = self.client_post(\"/complete/saml/\", post_params)\n                self.assertEqual(result.status_code, 302)\n                self.assertIn(\"login\", result.url)\n            self.assertEqual(\n                m.output,\n                [\n                    self.logger_output(\n                        \"AuthFailed: Authentication failed: SAML login failed: [] (None)\", \"info\"\n                    )\n                ],\n            )\n\n    def test_social_auth_complete_when_base_exc_is_raised(self) -> None:\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            with mock.patch(\n                \"social_core.backends.saml.SAMLAuth.auth_complete\",\n                side_effect=AuthStateForbidden(\"State forbidden\"),\n            ), self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n                saml_response = self.generate_saml_response(self.email, self.name)\n                relay_state = orjson.dumps(\n                    dict(\n                        state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                    )\n                ).decode()\n                post_params = {\"SAMLResponse\": saml_response, \"RelayState\": relay_state}\n                result = self.client_post(\"/complete/saml/\", post_params)\n                self.assertEqual(result.status_code, 302)\n                self.assertIn(\"login\", result.url)\n            self.assertEqual(\n                m.output, [self.logger_output(\"Wrong state parameter given.\", \"warning\")]\n            )\n\n    def test_social_auth_complete_bad_params(self) -> None:\n        # Simple GET for /complete/saml without the required parameters.\n        # This tests the auth_complete wrapped in our SAMLAuthBackend,\n        # ensuring it prevents this requests from causing an internal server error.\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(\"/complete/saml/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: No SAMLResponse or SAMLRequest in request.\", \"info\"\n                )\n            ],\n        )\n\n        # Check that POSTing the RelayState, but with missing SAMLResponse,\n        # doesn't cause errors either:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\"RelayState\": relay_state}\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: No SAMLResponse or SAMLRequest in request.\", \"info\"\n                )\n            ],\n        )\n\n        # Now test bad SAMLResponses.\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\"RelayState\": relay_state, \"SAMLResponse\": \"\"}\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertTrue(m.output != \"\")\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\"RelayState\": relay_state, \"SAMLResponse\": \"b\"}\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertTrue(m.output != \"\")\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\n                \"RelayState\": relay_state,\n                \"SAMLResponse\": base64.b64encode(b\"test\").decode(),\n            }\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertTrue(m.output != \"\")\n\n    def test_social_auth_complete_no_subdomain(self) -> None:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            post_params = {\n                \"RelayState\": \"\",\n                \"SAMLResponse\": self.generate_saml_response(\n                    email=self.example_email(\"hamlet\"), name=\"King Hamlet\"\n                ),\n            }\n            with mock.patch.object(SAMLAuthBackend, \"choose_subdomain\", return_value=None):\n                result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: Can't figure out subdomain for this SAMLResponse. relayed_params: {}\".format(\n                        \"{}\"\n                    ),\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_complete_wrong_issuing_idp(self) -> None:\n        relay_state = orjson.dumps(\n            dict(\n                state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n            )\n        ).decode()\n        saml_response = self.generate_saml_response(\n            email=self.example_email(\"hamlet\"), name=\"King Hamlet\"\n        )\n\n        # We change the entity_id of the configured test IdP, which means it won't match\n        # the Entity ID in the SAMLResponse generated above.\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"entity_id\"] = \"https://different.idp.example.com/\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                post_params = {\"RelayState\": relay_state, \"SAMLResponse\": saml_response}\n                result = self.client_post(\"/complete/saml/\", post_params)\n                self.assertEqual(result.status_code, 302)\n                self.assertEqual(\"/login/\", result.url)\n            self.assertEqual(\n                m.output,\n                [\n                    self.logger_output(\n                        \"/complete/saml/: No valid IdP as issuer of the SAMLResponse.\", \"info\"\n                    )\n                ],\n            )\n\n    def test_social_auth_complete_valid_get_idp_bad_samlresponse(self) -> None:\n        \"\"\"\n        This tests for a hypothetical scenario where our basic parsing of the SAMLResponse\n        successfully returns the issuing IdP, but it fails further down the line, during proper\n        validation in the underlying libraries.\n        \"\"\"\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m, mock.patch.object(\n            SAMLDocument, \"get_issuing_idp\", return_value=\"test_idp\"\n        ):\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\n                \"RelayState\": relay_state,\n                \"SAMLResponse\": base64.b64encode(b\"test\").decode(),\n            }\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n\n        self.assertTrue(m.output != \"\")\n\n    def test_social_auth_saml_bad_idp_param_on_login_page(self) -> None:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(\"/login/saml/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/login/saml/ : Bad idp param: KeyError: {}.\".format(\"'idp'\"), \"info\"\n                )\n            ],\n        )\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(\"/login/saml/\", {\"idp\": \"bad_idp\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/login/saml/ : Bad idp param: KeyError: {}.\".format(\"'bad_idp'\"), \"info\"\n                )\n            ],\n        )\n\n    def test_social_auth_invalid_email(self) -> None:\n        \"\"\"\n        This test needs an override from the original class. For security reasons,\n        the 'next' and 'mobile_flow_otp' params don't get passed on in the session\n        if the authentication attempt failed. See SAMLAuthBackend.auth_complete for details.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=\"invalid\", name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, \"WARNING\") as warn_log:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                next=\"/user_uploads/image\",\n            )\n        self.assertEqual(\n            warn_log.output, [self.logger_output(\"SAML got invalid email argument.\", \"warning\")]\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, realm.uri + \"/register/\")\n\n    def test_social_auth_saml_multiple_idps_configured(self) -> None:\n        # Set up a new SOCIAL_AUTH_SAML_ENABLED_IDPS dict with two idps.\n        # We deepcopy() dictionaries around for the sake of brevity,\n        # to avoid having to spell them out explicitly here.\n        # The second idp's configuration is a copy of the first one,\n        # with name test_idp2 and altered url. It is also configured to be\n        # limited to the zulip realm, so that we get to test both types\n        # of configs here.\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp2\"] = copy.deepcopy(idps_dict[\"test_idp\"])\n        idps_dict[\"test_idp2\"][\"url\"] = \"https://idp2.example.com/idp/profile/SAML2/Redirect/SSO\"\n        idps_dict[\"test_idp2\"][\"display_name\"] = \"Second Test IdP\"\n        idps_dict[\"test_idp2\"][\"limit_to_subdomains\"] = [\"zulip\"]\n\n        # Run tests with multiple idps configured:\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            # Go to the login page and check that buttons to log in show up for both IdPs:\n            result = self.client_get(\"/accounts/login/\")\n            self.assert_in_success_response([\"Log in with Test IdP\"], result)\n            self.assert_in_success_response([\"/accounts/login/social/saml/test_idp\"], result)\n            self.assert_in_success_response([\"Log in with Second Test IdP\"], result)\n            self.assert_in_success_response([\"/accounts/login/social/saml/test_idp2\"], result)\n\n            # Try successful authentication with the regular idp from all previous tests:\n            self.test_social_auth_success()\n\n            # Now test with the second idp:\n            original_LOGIN_URL = self.LOGIN_URL\n            original_SIGNUP_URL = self.SIGNUP_URL\n            original_AUTHORIZATION_URL = self.AUTHORIZATION_URL\n            self.LOGIN_URL = \"/accounts/login/social/saml/test_idp2\"\n            self.SIGNUP_URL = \"/accounts/register/social/saml/test_idp2\"\n            self.AUTHORIZATION_URL = idps_dict[\"test_idp2\"][\"url\"]\n\n            try:\n                self.test_social_auth_success()\n            finally:\n                # Restore original values at the end, regardless of what happens\n                # in the block above, to avoid affecting other tests in unpredictable\n                # ways.\n                self.LOGIN_URL = original_LOGIN_URL\n                self.SIGNUP_URL = original_SIGNUP_URL\n                self.AUTHORIZATION_URL = original_AUTHORIZATION_URL\n\n    def test_social_auth_saml_idp_limited_to_subdomains_success(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"limit_to_subdomains\"] = [\"zulip\"]\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            self.test_social_auth_success()\n\n    def test_social_auth_saml_idp_limited_to_subdomains_attempt_wrong_realm(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"limit_to_subdomains\"] = [\"zulip\"]\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                result = self.social_auth_test(account_data_dict, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: Authentication request with IdP test_idp but this provider is not enabled \"\n                    \"for this subdomain zephyr.\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_saml_login_bad_idp_arg(self) -> None:\n        for action in [\"login\", \"register\"]:\n            with self.assertLogs(level=\"INFO\") as info_log:\n                result = self.client_get(f\"/accounts/{action}/social/saml\")\n            # Missing idp argument.\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n            self.assertEqual(\n                info_log.output,\n                [\n                    \"INFO:root:Attempted to initiate SAML authentication with wrong idp argument: None\"\n                ],\n            )\n\n            with self.assertLogs(level=\"INFO\") as info_log:\n                result = self.client_get(f\"/accounts/{action}/social/saml/nonexistent_idp\")\n            # No such IdP is configured.\n            self.assertEqual(\n                info_log.output,\n                [\n                    \"INFO:root:Attempted to initiate SAML authentication with wrong idp argument: nonexistent_idp\"\n                ],\n            )\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n            result = self.client_get(f\"/accounts/{action}/social/saml/\")\n            # No matching URL pattern.\n            self.assertEqual(result.status_code, 404)\n\n    def test_social_auth_saml_require_limit_to_subdomains(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp2\"] = copy.deepcopy(idps_dict[\"test_idp\"])\n        idps_dict[\"test_idp2\"][\"url\"] = \"https://idp2.example.com/idp/profile/SAML2/Redirect/SSO\"\n        idps_dict[\"test_idp2\"][\"display_name\"] = \"Second Test IdP\"\n        idps_dict[\"test_idp2\"][\"limit_to_subdomains\"] = [\"zulip\"]\n\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict, SAML_REQUIRE_LIMIT_TO_SUBDOMAINS=True\n        ):\n            with self.assertLogs(self.logger_string, level=\"ERROR\") as m:\n                # Initialization of the backend should validate the configured IdPs\n                # with respect to the SAML_REQUIRE_LIMIT_TO_SUBDOMAINS setting and remove\n                # the non-compliant ones.\n                SAMLAuthBackend()\n            self.assertEqual(list(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS.keys()), [\"test_idp2\"])\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"SAML_REQUIRE_LIMIT_TO_SUBDOMAINS is enabled and the following \"\n                    \"IdPs don't have limit_to_subdomains specified and will be ignored: \"\n                    \"['test_idp']\",\n                    \"error\",\n                )\n            ],\n        )\n\n    def test_idp_initiated_signin_subdomain_specified(self) -> None:\n        post_params = {\n            \"RelayState\": '{\"subdomain\": \"zulip\"}',\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"/complete/saml/\", post_params)\n\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.client_get(uri)\n        self.assert_logged_in_user_id(self.example_user(\"hamlet\").id)\n\n    def test_choose_subdomain_invalid_subdomain_specified(self) -> None:\n        post_params = {\n            \"RelayState\": '{\"subdomain\": \"invalid\"}',\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"/complete/saml/\", post_params)\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/\")\n\n    def test_idp_initiated_signin_subdomain_implicit(self) -> None:\n        post_params = {\n            \"RelayState\": \"\",\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"http://zulip.testserver/complete/saml/\", post_params)\n\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.client_get(uri)\n        self.assert_logged_in_user_id(self.example_user(\"hamlet\").id)\n\n    def test_idp_initiated_signin_subdomain_implicit_no_relaystate_param(self) -> None:\n        post_params = {\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"http://zulip.testserver/complete/saml/\", post_params)\n\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.client_get(uri)\n        self.assert_logged_in_user_id(self.example_user(\"hamlet\").id)\n\n    def test_idp_initiated_signin_subdomain_implicit_invalid(self) -> None:\n        post_params = {\n            \"RelayState\": \"\",\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            with mock.patch(\"zproject.backends.get_subdomain\", return_value=\"invalid\"):\n                # Due to the quirks of our test setup, get_subdomain on all these `some_subdomain.testserver`\n                # requests returns 'zulip', so we need to mock it here.\n                result = self.client_post(\"http://invalid.testserver/complete/saml/\", post_params)\n\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: Can't figure out subdomain for this SAMLResponse. relayed_params: {}\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_saml_idp_org_membership_success(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"attr_org_membership\"] = \"member\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=False,\n                extra_attributes=dict(member=[\"zulip\"]),\n            )\n            data = load_subdomain_token(result)\n            self.assertEqual(data[\"email\"], self.email)\n            self.assertEqual(data[\"full_name\"], self.name)\n            self.assertEqual(data[\"subdomain\"], \"zulip\")\n            self.assertEqual(result.status_code, 302)\n\n    def test_social_auth_saml_idp_org_membership_root_subdomain(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.string_id = \"\"\n        realm.save()\n\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"attr_org_membership\"] = \"member\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            # Having one of the settings.ROOT_SUBDOMAIN_ALIASES in the membership attributes\n            # authorizes the user to access the root subdomain.\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"\",\n                expect_choose_email_screen=False,\n                extra_attributes=dict(member=[\"www\"]),\n            )\n            data = load_subdomain_token(result)\n            self.assertEqual(data[\"email\"], self.email)\n            self.assertEqual(data[\"full_name\"], self.name)\n            self.assertEqual(data[\"subdomain\"], \"\")\n            self.assertEqual(result.status_code, 302)\n\n            # Failure, the user doesn't have entitlements for the root subdomain.\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                result = self.social_auth_test(\n                    account_data_dict,\n                    subdomain=\"\",\n                    expect_choose_email_screen=False,\n                    extra_attributes=dict(member=[\"zephyr\"]),\n                )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                m.output,\n                [\n                    self.logger_output(\n                        \"AuthFailed: Authentication failed: SAML user from IdP test_idp rejected due to \"\n                        + \"missing entitlement for subdomain ''. User entitlements: ['zephyr'].\",\n                        \"info\",\n                    )\n                ],\n            )\n\n    def test_social_auth_saml_idp_org_membership_failed(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"attr_org_membership\"] = \"member\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                result = self.social_auth_test(\n                    account_data_dict,\n                    subdomain=\"zulip\",\n                    extra_attributes=dict(member=[\"zephyr\", \"othersubdomain\"]),\n                )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"AuthFailed: Authentication failed: SAML user from IdP test_idp rejected due to \"\n                    + \"missing entitlement for subdomain 'zulip'. User entitlements: ['zephyr', 'othersubdomain'].\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_custom_profile_field_sync(self) -> None:\n        birthday_field = CustomProfileField.objects.get(\n            realm=self.user_profile.realm, name=\"Birthday\"\n        )\n        old_birthday_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=self.user_profile, field=birthday_field\n        ).value\n\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"extra_attrs\"] = [\"mobilePhone\"]\n\n        sync_custom_attrs_dict = {\n            \"zulip\": {\n                \"saml\": {\n                    \"phone_number\": \"mobilePhone\",\n                }\n            }\n        }\n\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict,\n            SOCIAL_AUTH_SYNC_CUSTOM_ATTRS_DICT=sync_custom_attrs_dict,\n        ):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                extra_attributes=dict(mobilePhone=[\"123412341234\"], birthday=[\"2021-01-01\"]),\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.email)\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n\n        phone_field = CustomProfileField.objects.get(\n            realm=self.user_profile.realm, name=\"Phone number\"\n        )\n        phone_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=self.user_profile, field=phone_field\n        ).value\n        self.assertEqual(phone_field_value, \"123412341234\")\n\n        # Verify the Birthday field doesn't get synced - because it isn't configured for syncing.\n        new_birthday_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=self.user_profile, field=birthday_field\n        ).value\n        self.assertEqual(new_birthday_field_value, old_birthday_field_value)\n\n    def test_social_auth_custom_profile_field_sync_custom_field_not_existing(self) -> None:\n        sync_custom_attrs_dict = {\n            \"zulip\": {\n                \"saml\": {\n                    \"title\": \"title\",\n                    \"phone_number\": \"mobilePhone\",\n                }\n            }\n        }\n        self.assertFalse(\n            CustomProfileField.objects.filter(\n                realm=self.user_profile.realm, name__iexact=\"title\"\n            ).exists()\n        )\n\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"extra_attrs\"] = [\"mobilePhone\", \"title\"]\n\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict,\n            SOCIAL_AUTH_SYNC_CUSTOM_ATTRS_DICT=sync_custom_attrs_dict,\n        ):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n                result = self.social_auth_test(\n                    account_data_dict,\n                    subdomain=\"zulip\",\n                    extra_attributes=dict(mobilePhone=[\"123412341234\"], birthday=[\"2021-01-01\"]),\n                )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.email)\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Exception while syncing custom profile fields for \"\n                    + f\"user {self.user_profile.id}: Custom profile field with name title not found.\",\n                    \"warning\",\n                )\n            ],\n        )\n\n\nclass AppleAuthMixin:\n    BACKEND_CLASS = AppleAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_APPLE_KEY\"\n    AUTHORIZATION_URL = \"https://appleid.apple.com/auth/authorize\"\n    ACCESS_TOKEN_URL = \"https://appleid.apple.com/auth/token\"\n    AUTH_FINISH_URL = \"/complete/apple/\"\n\n    def generate_id_token(\n        self, account_data_dict: Dict[str, str], audience: Optional[str] = None\n    ) -> str:\n        payload = dict(email=account_data_dict[\"email\"])\n\n        # This setup is important because python-social-auth decodes `id_token`\n        # with `SOCIAL_AUTH_APPLE_CLIENT` as the `audience`\n        payload[\"aud\"] = settings.SOCIAL_AUTH_APPLE_CLIENT\n\n        if audience is not None:\n            payload[\"aud\"] = audience\n\n        headers = {\"kid\": \"SOMEKID\"}\n        private_key = settings.APPLE_ID_TOKEN_GENERATION_KEY\n\n        id_token = jwt.encode(payload, private_key, algorithm=\"RS256\", headers=headers)\n\n        return id_token\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        name_parts = name.split(\" \")\n        first_name = name_parts[0]\n        last_name = \"\"\n        if len(name_parts) > 0:\n            last_name = name_parts[-1]\n        name_dict = {\"firstName\": first_name, \"lastName\": last_name}\n        return dict(email=email, name=name_dict, email_verified=True)\n\n\nclass AppleIdAuthBackendTest(AppleAuthMixin, SocialAuthBase):\n    __unittest_skip__ = False\n\n    LOGIN_URL = \"/accounts/login/social/apple\"\n    SIGNUP_URL = \"/accounts/register/social/apple\"\n\n    # This URL isn't used in the Apple auth flow, so we just set a\n    # dummy value to keep SocialAuthBase common code happy.\n    USER_INFO_URL = \"/invalid-unused-url\"\n\n    def social_auth_test_finish(\n        self,\n        result: HttpResponse,\n        account_data_dict: Dict[str, str],\n        expect_choose_email_screen: bool,\n        headers: Any,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        parsed_url = urllib.parse.urlparse(result.url)\n        state = urllib.parse.parse_qs(parsed_url.query)[\"state\"]\n        user_param = json.dumps(account_data_dict)\n        self.client.session.flush()\n        result = self.client_post(\n            self.AUTH_FINISH_URL, dict(state=state, user=user_param), **headers\n        )\n        return result\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        # This is an URL of an endpoint on Apple servers that returns\n        # the public keys to be used for verifying the signature\n        # on the JWT id_token.\n        requests_mock.add(\n            requests_mock.GET,\n            self.BACKEND_CLASS.JWK_URL,\n            status=200,\n            json=json.loads(settings.EXAMPLE_JWK),\n        )\n\n    def generate_access_token_url_payload(self, account_data_dict: Dict[str, str]) -> str:\n        # The ACCESS_TOKEN_URL endpoint works a bit different than in standard Oauth2,\n        # and here, similarly to OIDC, id_token is also returned in the response.\n        # In Apple auth, all the user information is carried in the id_token.\n        return json.dumps(\n            {\n                \"access_token\": \"foobar\",\n                \"expires_in\": time.time() + 60 * 5,\n                \"id_token\": self.generate_id_token(account_data_dict),\n                \"token_type\": \"bearer\",\n            }\n        )\n\n    def test_apple_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.AppleAuthBackend\",)):\n            self.assertTrue(apple_auth_enabled())\n\n    def test_auth_registration_with_no_name_sent_from_apple(self) -> None:\n        \"\"\"\n        Apple doesn't send the name in consecutive attempts if user registration\n        fails the first time. This tests verifies that the social pipeline is able\n        to handle the case of the backend not providing this information.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=\"\")\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            \"\",\n            \"Full Name\",\n            skip_registration_form=False,\n            expect_full_name_prepopulated=False,\n        )\n\n    def test_id_token_verification_failure(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            with mock.patch(\"jwt.decode\", side_effect=PyJWTError):\n                result = self.social_auth_test(\n                    account_data_dict,\n                    expect_choose_email_screen=True,\n                    subdomain=\"zulip\",\n                    is_signup=True,\n                )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"AuthFailed: Authentication failed: Token validation failed by \", \"info\"\n                ),\n            ],\n        )\n\n    def test_validate_state(self) -> None:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n\n            # (1) check if auth fails if no state value is sent.\n            result = self.client_post(\"/complete/apple/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n\n            # (2) Check if auth fails when a state sent has no valid data stored in Redis.\n            fake_state = \"fa42e4ccdb630f0070c1daab70ad198d8786d4b639cd7a1b4db4d5a13c623060\"\n            result = self.client_post(\"/complete/apple/\", {\"state\": fake_state})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Sign in with Apple failed: missing state parameter.\", \"info\"\n                ),  # (1)\n                self.logger_output(\"Missing needed parameter state\", \"warning\"),\n                self.logger_output(\"Sign in with Apple failed: bad state token.\", \"info\"),  # (2)\n                self.logger_output(\"Wrong state parameter given.\", \"warning\"),\n            ],\n        )\n\n\nclass AppleAuthBackendNativeFlowTest(AppleAuthMixin, SocialAuthBase):\n    __unittest_skip__ = False\n\n    SIGNUP_URL = \"/complete/apple/\"\n    LOGIN_URL = \"/complete/apple/\"\n\n    def prepare_login_url_and_headers(\n        self,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        alternative_start_url: Optional[str] = None,\n        id_token: Optional[str] = None,\n        account_data_dict: Dict[str, str] = {},\n        *,\n        user_agent: Optional[str] = None,\n    ) -> Tuple[str, Dict[str, Any]]:\n        url, headers = super().prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            alternative_start_url=alternative_start_url,\n            user_agent=user_agent,\n        )\n\n        params = {\"native_flow\": \"true\"}\n\n        if id_token is not None:\n            params[\"id_token\"] = id_token\n\n        if is_signup:\n            params[\"is_signup\"] = \"1\"\n\n        if subdomain:\n            params[\"subdomain\"] = subdomain\n\n        params[\"user\"] = json.dumps(account_data_dict)\n\n        url += f\"&{urlencode(params)}\"\n        return url, headers\n\n    def social_auth_test(\n        self,\n        account_data_dict: Dict[str, str],\n        *,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        alternative_start_url: Optional[str] = None,\n        skip_id_token: bool = False,\n        user_agent: Optional[str] = None,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        \"\"\"In Apple's native authentication flow, the client app authenticates\n        with Apple and receives the JWT id_token, before contacting\n        the Zulip server.  The app sends an appropriate request with\n        it to /complete/apple/ to get logged in.  See the backend\n        class for details.\n\n        As a result, we need a custom social_auth_test function that\n        effectively just does the second half of the flow (i.e. the\n        part after the redirect from this third-party authentication\n        provider) with a properly generated id_token.\n        \"\"\"\n\n        if not skip_id_token:\n            id_token: Optional[str] = self.generate_id_token(\n                account_data_dict, settings.SOCIAL_AUTH_APPLE_APP_ID\n            )\n        else:\n            id_token = None\n\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            alternative_start_url=self.AUTH_FINISH_URL,\n            user_agent=user_agent,\n            id_token=id_token,\n            account_data_dict=account_data_dict,\n        )\n\n        with self.apple_jwk_url_mock():\n            result = self.client_get(url, **headers)\n\n        return result\n\n    @contextmanager\n    def apple_jwk_url_mock(self) -> Iterator[None]:\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as requests_mock:\n            # The server fetches public keys for validating the id_token\n            # from Apple servers. We need to mock that URL to return our key,\n            # created for these tests.\n            requests_mock.add(\n                requests_mock.GET,\n                self.BACKEND_CLASS.JWK_URL,\n                status=200,\n                json=json.loads(settings.EXAMPLE_JWK),\n            )\n            yield\n\n    def test_no_id_token_sent(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(\n            account_data_dict,\n            expect_choose_email_screen=False,\n            subdomain=\"zulip\",\n            next=\"/user_uploads/image\",\n            skip_id_token=True,\n        )\n        self.assert_json_error(result, \"Missing id_token parameter\")\n\n    def test_social_auth_session_fields_cleared_correctly(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n\n        def initiate_auth(mobile_flow_otp: Optional[str] = None) -> None:\n            url, headers = self.prepare_login_url_and_headers(\n                subdomain=\"zulip\",\n                id_token=\"invalid\",\n                mobile_flow_otp=mobile_flow_otp,\n                account_data_dict=account_data_dict,\n            )\n            result = self.client_get(url, **headers)\n            self.assertEqual(result.status_code, 302)\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as info_log:\n            # Start Apple auth with mobile_flow_otp param. It should get saved into the session\n            # on SOCIAL_AUTH_SUBDOMAIN.\n            initiate_auth(mobile_flow_otp)\n\n        self.assertEqual(self.client.session[\"mobile_flow_otp\"], mobile_flow_otp)\n        self.assertEqual(\n            info_log.output,\n            [\n                self.logger_output(\n                    \"/complete/apple/: Authentication failed: Token validation failed by Not enough segments\",\n                    \"info\",\n                )\n            ],\n        )\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as info_log:\n            # Make a request without mobile_flow_otp param and verify the field doesn't persist\n            # in the session from the previous request.\n            initiate_auth()\n\n        self.assertEqual(self.client.session.get(\"mobile_flow_otp\"), None)\n        self.assertEqual(\n            info_log.output,\n            [\n                self.logger_output(\n                    \"/complete/apple/: Authentication failed: Token validation failed by Not enough segments\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_id_token_with_invalid_aud_sent(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain=\"zulip\",\n            alternative_start_url=self.AUTH_FINISH_URL,\n            id_token=self.generate_id_token(account_data_dict, audience=\"com.different.app\"),\n            account_data_dict=account_data_dict,\n        )\n\n        with self.apple_jwk_url_mock(), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(url, **headers)\n\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/apple/: Authentication failed: Token validation failed by Invalid audience\",\n                    \"info\",\n                )\n            ],\n        )\n        return result\n\n    def test_social_auth_desktop_success(self) -> None:\n        \"\"\"\n        The desktop app doesn't use the native flow currently and the desktop app flow in its\n        current form happens in the browser, thus only the web flow is viable there.\n        \"\"\"\n        pass\n\n    def test_social_auth_no_key(self) -> None:\n        \"\"\"\n        The basic validation of server configuration is handled on the\n        /login/social/apple/ endpoint which isn't even a part of the native flow.\n        \"\"\"\n        pass\n\n\nclass GenericOpenIdConnectTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GenericOpenIdConnectBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_TESTOIDC_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_TESTOIDC_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/oidc\"\n    SIGNUP_URL = \"/accounts/register/social/oidc\"\n\n    BASE_OIDC_URL = \"https://example.com/api/openid\"\n    AUTHORIZATION_URL = f\"{BASE_OIDC_URL}/authorize\"\n    ACCESS_TOKEN_URL = f\"{BASE_OIDC_URL}/token\"\n    JWKS_URL = f\"{BASE_OIDC_URL}/jwks\"\n    USER_INFO_URL = f\"{BASE_OIDC_URL}/userinfo\"\n    AUTH_FINISH_URL = \"/complete/oidc/\"\n\n    def social_auth_test(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -> HttpResponse:\n        # Example payload of the discovery endpoint (with appropriate values filled\n        # in to match our test setup).\n        # All the attributes below are REQUIRED per OIDC specification:\n        # https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n        # or at least required for the `code` flow with userinfo - that this implementation uses.\n        # Other flows are not supported right now.\n        idp_discovery_endpoint_payload_dict = {\n            \"issuer\": self.BASE_OIDC_URL,\n            \"authorization_endpoint\": self.AUTHORIZATION_URL,\n            \"token_endpoint\": self.ACCESS_TOKEN_URL,\n            \"userinfo_endpoint\": self.USER_INFO_URL,\n            \"response_types_supported\": [\n                \"code\",\n                \"id_token\",\n                \"id_token token\",\n                \"code token\",\n                \"code id_token\",\n                \"code id_token token\",\n            ],\n            \"jwks_uri\": self.JWKS_URL,\n            \"id_token_signing_alg_values_supported\": [\"HS256\", \"RS256\"],\n            \"subject_types_supported\": [\"public\"],\n        }\n\n        # We need to run the social_auth_test procedure with a mock response set up for the\n        # OIDC discovery endpoint as that's the first thing requested by the server when a user\n        # starts trying to authenticate.\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as requests_mock:\n            requests_mock.add(\n                requests_mock.GET,\n                f\"{self.BASE_OIDC_URL}/.well-known/openid-configuration\",\n                status=200,\n                body=json.dumps(idp_discovery_endpoint_payload_dict),\n            )\n            result = super().social_auth_test(*args, **kwargs)\n\n        return result\n\n    def social_auth_test_finish(self, *args: Any, **kwargs: Any) -> HttpResponse:\n        # Trying to generate a (access_token, id_token) pair here in tests that would\n        # successfully pass validation by validate_and_return_id_token is impractical\n        # and unnecessary (see python-social-auth implementation of the method for\n        # how the validation works).\n        # We can simply mock the method to make it succeed and return an empty dict, because\n        # the return value is not used for anything.\n        with mock.patch.object(\n            GenericOpenIdConnectBackend, \"validate_and_return_id_token\", return_value={}\n        ):\n            return super().social_auth_test_finish(*args, **kwargs)\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        requests_mock.add(\n            requests_mock.GET,\n            self.JWKS_URL,\n            status=200,\n            json=json.loads(settings.EXAMPLE_JWK),\n        )\n\n    def generate_access_token_url_payload(self, account_data_dict: Dict[str, str]) -> str:\n        return json.dumps(\n            {\n                \"access_token\": \"foobar\",\n                \"expires_in\": time.time() + 60 * 5,\n                \"id_token\": \"abcd1234\",\n                \"token_type\": \"bearer\",\n            }\n        )\n\n    def get_account_data_dict(self, email: str, name: Optional[str]) -> Dict[str, Any]:\n        if name is not None:\n            name_parts = name.split(\" \")\n            given_name = name_parts[0]\n            family_name = name_parts[1]\n        else:\n            given_name = None\n            family_name = None\n\n        return dict(\n            email=email,\n            name=name,\n            nickname=\"somenickname\",\n            given_name=given_name,\n            family_name=family_name,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_auto_signup(self) -> None:\n        \"\"\"\n        The analogue of the auto_signup test for SAML.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        oidc_setting_dict = copy.deepcopy(settings.SOCIAL_AUTH_OIDC_ENABLED_IDPS)\n        idp_settings_dict = list(oidc_setting_dict.values())[0]\n        idp_settings_dict[\"auto_signup\"] = True\n        with mock.patch.object(GenericOpenIdConnectBackend, \"settings_dict\", new=idp_settings_dict):\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=False,\n            )\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                self.BACKEND_CLASS.full_name_validated,\n                expect_confirm_registration_page=False,\n            )\n\n    def test_auth_registration_with_no_name_provided(self) -> None:\n        \"\"\"\n        The OIDC IdP may not send the name information. The\n        signup flow should proceed normally, without pre-filling the name in the\n        registration form.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=None)\n        result = self.social_auth_test(account_data_dict, subdomain=subdomain, is_signup=True)\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            \"\",\n            \"Full Name\",\n            skip_registration_form=False,\n            expect_full_name_prepopulated=False,\n        )\n\n    def test_social_auth_no_key(self) -> None:\n        \"\"\"\n        Requires overriding because client key/secret are configured\n        in a different way than default for social auth backends.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n\n        mock_oidc_setting_dict = copy.deepcopy(settings.SOCIAL_AUTH_OIDC_ENABLED_IDPS)\n        idp_config_dict = list(mock_oidc_setting_dict.values())[0]\n        del idp_config_dict[\"client_id\"]\n        with self.settings(SOCIAL_AUTH_OIDC_ENABLED_IDPS=mock_oidc_setting_dict):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"OpenID Connect\"], result)\n\n    def test_too_many_idps(self) -> None:\n        \"\"\"\n        Only one IdP is supported for now.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n\n        mock_oidc_setting_dict = copy.deepcopy(settings.SOCIAL_AUTH_OIDC_ENABLED_IDPS)\n        idp_config_dict = list(mock_oidc_setting_dict.values())[0]\n        mock_oidc_setting_dict[\"secondprovider\"] = idp_config_dict\n        with self.settings(SOCIAL_AUTH_OIDC_ENABLED_IDPS=mock_oidc_setting_dict):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"OpenID Connect\"], result)\n\n    def test_config_error_development(self) -> None:\n        \"\"\"\n        This test is redundant for now, as test_social_auth_no_key already\n        tests this basic case, since this backend doesn't yet have more\n        comprehensive config_error pages.\n        \"\"\"\n        return\n\n    def test_config_error_production(self) -> None:\n        \"\"\"\n        This test is redundant for now, as test_social_auth_no_key already\n        tests this basic case, since this backend doesn't yet have more\n        comprehensive config_error pages.\n        \"\"\"\n        return\n\n\nclass GitHubAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GitHubAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_GITHUB_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_GITHUB_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/github\"\n    SIGNUP_URL = \"/accounts/register/social/github\"\n    AUTHORIZATION_URL = \"https://github.com/login/oauth/authorize\"\n    ACCESS_TOKEN_URL = \"https://github.com/login/oauth/access_token\"\n    USER_INFO_URL = \"https://api.github.com/user\"\n    AUTH_FINISH_URL = \"/complete/github/\"\n    email_data: List[Dict[str, Any]] = []\n\n    def social_auth_test_finish(\n        self,\n        result: HttpResponse,\n        account_data_dict: Dict[str, str],\n        expect_choose_email_screen: bool,\n        headers: Any,\n        expect_noreply_email_allowed: bool = False,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        parsed_url = urllib.parse.urlparse(result.url)\n        csrf_state = urllib.parse.parse_qs(parsed_url.query)[\"state\"]\n        result = self.client_get(self.AUTH_FINISH_URL, dict(state=csrf_state), **headers)\n\n        if expect_choose_email_screen:\n            # As GitHub authenticates multiple email addresses,\n            # we'll have an additional screen where the user selects\n            # which email address to log in using (this screen is a\n            # \"partial\" state of the python-social-auth pipeline).\n            #\n            # TODO: Generalize this testing code for use with other\n            # authentication backends when a new authentication backend\n            # that requires \"choose email\" screen;\n            self.assert_in_success_response([\"Select account\"], result)\n            # Verify that all the emails returned by GitHub auth\n            # Are in the \"choose email\" screen.\n            all_emails_verified = True\n            for email_data_dict in self.email_data:\n                email = email_data_dict[\"email\"]\n                if email.endswith(\"@users.noreply.github.com\") and not expect_noreply_email_allowed:\n                    self.assert_not_in_success_response([email], result)\n                elif email_data_dict.get(\"verified\"):\n                    self.assert_in_success_response([email], result)\n                else:\n                    # We may change this if we provide a way to see\n                    # the list of emails the user had.\n                    self.assert_not_in_success_response([email], result)\n                    all_emails_verified = False\n\n            if all_emails_verified:\n                self.assert_not_in_success_response([\"also has unverified email\"], result)\n            else:\n                self.assert_in_success_response([\"also has unverified email\"], result)\n            result = self.client_get(\n                self.AUTH_FINISH_URL,\n                dict(state=csrf_state, email=account_data_dict[\"email\"]),\n                **headers,\n            )\n\n        return result\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        # Keeping a verified email before the primary email makes sure\n        # get_verified_emails puts the primary email at the start of the\n        # email list returned as social_associate_user_helper assumes the\n        # first email as the primary email.\n        email_data = [\n            dict(email=\"notprimary@example.com\", verified=True),\n            dict(email=account_data_dict[\"email\"], verified=True, primary=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        email_data = extra_data.get(\"email_data\", email_data)\n\n        requests_mock.add(\n            requests_mock.GET,\n            \"https://api.github.com/user/emails\",\n            status=200,\n            body=json.dumps(email_data),\n        )\n\n        requests_mock.add(\n            requests_mock.GET,\n            \"https://api.github.com/teams/zulip-webapp/members/None\",\n            status=200,\n            body=json.dumps(email_data),\n        )\n\n        self.email_data = email_data\n\n    def get_account_data_dict(\n        self, email: str, name: str, user_avatar_url: str = \"\"\n    ) -> Dict[str, Any]:\n        return dict(email=email, name=name, user_avatar_url=user_avatar_url)\n\n    def test_social_auth_email_not_verified(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=False, primary=True),\n        ]\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict, subdomain=subdomain, email_data=email_data\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth ({}) failed because user has no verified emails\".format(\"GitHub\"),\n                    \"warning\",\n                )\n            ],\n        )\n\n    @override_settings(SOCIAL_AUTH_GITHUB_TEAM_ID=\"zulip-webapp\")\n    def test_social_auth_github_team_not_member_failed(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with mock.patch(\n            \"social_core.backends.github.GithubTeamOAuth2.user_data\",\n            side_effect=AuthFailed(\"Not found\"),\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as mock_info:\n            result = self.social_auth_test(account_data_dict, subdomain=subdomain)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            mock_info.output,\n            [\n                self.logger_output(\n                    \"GitHub user is not member of required team\",\n                    \"info\",\n                )\n            ],\n        )\n\n    @override_settings(SOCIAL_AUTH_GITHUB_TEAM_ID=\"zulip-webapp\")\n    def test_social_auth_github_team_member_success(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with mock.patch(\n            \"social_core.backends.github.GithubTeamOAuth2.user_data\", return_value=account_data_dict\n        ):\n            result = self.social_auth_test(\n                account_data_dict, expect_choose_email_screen=False, subdomain=\"zulip\"\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n\n    @override_settings(SOCIAL_AUTH_GITHUB_ORG_NAME=\"Zulip\")\n    def test_social_auth_github_organization_not_member_failed(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with mock.patch(\n            \"social_core.backends.github.GithubOrganizationOAuth2.user_data\",\n            side_effect=AuthFailed(\"Not found\"),\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as mock_info:\n            result = self.social_auth_test(account_data_dict, subdomain=subdomain)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            mock_info.output,\n            [\n                self.logger_output(\n                    \"GitHub user is not member of required organization\",\n                    \"info\",\n                )\n            ],\n        )\n\n    @override_settings(SOCIAL_AUTH_GITHUB_ORG_NAME=\"Zulip\")\n    def test_social_auth_github_organization_member_success(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with mock.patch(\n            \"social_core.backends.github.GithubOrganizationOAuth2.user_data\",\n            return_value=account_data_dict,\n        ):\n            result = self.social_auth_test(\n                account_data_dict, expect_choose_email_screen=False, subdomain=\"zulip\"\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n\n    def test_github_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GitHubAuthBackend\",)):\n            self.assertTrue(github_auth_enabled())\n\n    def test_github_oauth2_success_non_primary(self) -> None:\n        account_data_dict = self.get_account_data_dict(\n            email=\"nonprimary@zulip.com\", name=\"Non Primary\"\n        )\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=True,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], \"nonprimary@zulip.com\")\n        self.assertEqual(data[\"full_name\"], \"Non Primary\")\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_success_single_email(self) -> None:\n        # If the user has a single email associated with its GitHub account,\n        # the choose email screen should not be shown and the first email\n        # should be used for user's signup/login.\n        account_data_dict = self.get_account_data_dict(email=\"not-hamlet@zulip.com\", name=self.name)\n        email_data = [\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=False,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_login_only_one_account_exists(self) -> None:\n        # In a login flow, if only one of the user's verified emails\n        # is associated with an existing account, the user should be\n        # just logged in (skipping the \"choose email screen\").  We\n        # only want that screen if the user were instead trying to\n        # register a new account, which they're not.\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=False,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], account_data_dict[\"email\"])\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_login_multiple_accounts_exist(self) -> None:\n        # In the login flow, if multiple of the user's verified emails\n        # are associated with existing accounts, we expect the choose\n        # email screen to select which account to use.\n        hamlet = self.example_user(\"hamlet\")\n        account_data_dict = self.get_account_data_dict(email=\"hamlet@zulip.com\", name=\"Hamlet\")\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=True,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], \"hamlet@zulip.com\")\n        self.assertEqual(data[\"full_name\"], hamlet.full_name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_login_no_account_exists(self) -> None:\n        # In the login flow, if the user has multiple verified emails,\n        # none of which are associated with an existing account, the\n        # choose email screen should be shown (which will lead to a\n        # \"continue to registration\" choice).\n        account_data_dict = self.get_account_data_dict(\n            email=\"not-hamlet@zulip.com\", name=\"Not Hamlet\"\n        )\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=True,\n        )\n        email = account_data_dict[\"email\"]\n        name = account_data_dict[\"name\"]\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            name,\n            name,\n            expect_confirm_registration_page=True,\n            skip_registration_form=False,\n        )\n\n    def test_github_oauth2_signup_choose_existing_account(self) -> None:\n        # In the sign up flow, if the user has chosen an email of an\n        # existing account, the user will be logged in.\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            email_data=email_data,\n            is_signup=True,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], account_data_dict[\"email\"])\n        self.assertEqual(data[\"full_name\"], account_data_dict[\"name\"])\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_signup_choose_new_email_to_register(self) -> None:\n        # In the sign up flow, if the user has multiple verified\n        # emails, we show the \"choose email\" screen, even if the user\n        # has another verified email with an existing account,\n        # allowing the user to register a second account associated\n        # with the second email.\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        email_data = [\n            dict(email=\"hamlet@zulip.com\", verified=True),\n            dict(email=email, verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            email_data=email_data,\n            expect_choose_email_screen=True,\n            subdomain=subdomain,\n            is_signup=True,\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    def test_github_oauth2_email_no_reply_dot_github_dot_com(self) -> None:\n        # As emails ending with `noreply.github.com` are excluded from\n        # verified_emails unless an account with that email already exists,\n        # choosing it as an email should raise a `email not associated` warning.\n        noreply_email = \"hamlet@users.noreply.github.com\"\n        account_data_dict = self.get_account_data_dict(email=noreply_email, name=self.name)\n        email_data = [\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n            dict(email=account_data_dict[\"email\"], verified=True),\n        ]\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=subdomain,\n                expect_choose_email_screen=True,\n                email_data=email_data,\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth (GitHub) failed because user has no verified\"\n                    \" emails associated with the account\",\n                    \"warning\",\n                )\n            ],\n        )\n\n        # Now we create the user account with the noreply email and verify that it's\n        # possible to sign in to it.\n        realm = get_realm(\"zulip\")\n        do_create_user(\n            noreply_email, \"password\", realm, account_data_dict[\"name\"], acting_user=None\n        )\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            expect_noreply_email_allowed=True,\n            email_data=email_data,\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], account_data_dict[\"email\"])\n        self.assertEqual(data[\"full_name\"], account_data_dict[\"name\"])\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_email_not_associated(self) -> None:\n        account_data_dict = self.get_account_data_dict(\n            email=\"not-associated@zulip.com\", name=self.name\n        )\n        email_data = [\n            dict(email=\"nonprimary@zulip.com\", verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n        ]\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=subdomain,\n                expect_choose_email_screen=True,\n                email_data=email_data,\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth (GitHub) failed because user has no verified\"\n                    \" emails associated with the account\",\n                    \"warning\",\n                )\n            ],\n        )\n\n    def test_github_unverified_email_with_existing_account(self) -> None:\n        # check if a user is denied to log in if the user manages to\n        # send an unverified email that has an existing account in\n        # organization through `email` GET parameter.\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        account_data_dict = dict(email=\"hamlet@zulip.com\", name=self.name)\n        email_data = [\n            dict(email=\"iago@zulip.com\", verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=False),\n            dict(email=\"aaron@zulip.com\", verified=True, primary=True),\n        ]\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=subdomain,\n                expect_choose_email_screen=True,\n                email_data=email_data,\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth ({}) failed because user has no verified emails associated with the account\".format(\n                        \"GitHub\"\n                    ),\n                    \"warning\",\n                )\n            ],\n        )\n\n\nclass GitLabAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GitLabAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_GITLAB_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_GITLAB_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/gitlab\"\n    SIGNUP_URL = \"/accounts/register/social/gitlab\"\n    AUTHORIZATION_URL = \"https://gitlab.com/oauth/authorize\"\n    ACCESS_TOKEN_URL = \"https://gitlab.com/oauth/token\"\n    USER_INFO_URL = \"https://gitlab.com/api/v4/user\"\n    AUTH_FINISH_URL = \"/complete/gitlab/\"\n\n    def test_gitlab_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GitLabAuthBackend\",)):\n            self.assertTrue(gitlab_auth_enabled())\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        return dict(email=email, name=name, email_verified=True)\n\n\nclass GoogleAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GoogleAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_GOOGLE_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_GOOGLE_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/google\"\n    SIGNUP_URL = \"/accounts/register/social/google\"\n    AUTHORIZATION_URL = \"https://accounts.google.com/o/oauth2/auth\"\n    ACCESS_TOKEN_URL = \"https://accounts.google.com/o/oauth2/token\"\n    USER_INFO_URL = \"https://www.googleapis.com/oauth2/v3/userinfo\"\n    AUTH_FINISH_URL = \"/complete/google/\"\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        return dict(email=email, name=name, email_verified=True)\n\n    def test_social_auth_email_not_verified(self) -> None:\n        account_data_dict = dict(email=self.email, name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(account_data_dict, subdomain=subdomain)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth ({}) failed because user has no verified emails\".format(\"Google\"),\n                    \"warning\",\n                )\n            ],\n        )\n\n    def test_social_auth_mobile_realm_uri(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n\n        with self.settings(\n            REALM_MOBILE_REMAP_URIS={\"http://zulip.testserver\": \"http://zulip-mobile.testserver\"}\n        ):\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=True,\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=mobile_flow_otp,\n            )\n\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip-mobile.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n\n    def test_social_auth_mobile_success_legacy_url(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n        self.assert_length(mail.outbox, 0)\n        self.user_profile.date_joined = timezone_now() - datetime.timedelta(\n            seconds=JUST_CREATED_THRESHOLD + 1\n        )\n        self.user_profile.save()\n\n        with self.settings(SEND_LOGIN_EMAILS=True):\n            # Verify that the right thing happens with an invalid-format OTP\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=\"1234\",\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=\"invalido\" * 8,\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n\n            # Now do it correctly\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=True,\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=mobile_flow_otp,\n            )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    def test_google_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GoogleAuthBackend\",)):\n            self.assertTrue(google_auth_enabled())\n\n    def get_log_into_subdomain(\n        self,\n        data: ExternalAuthDataDict,\n        *,\n        subdomain: str = \"zulip\",\n        force_token: Optional[str] = None,\n    ) -> HttpResponse:\n        if force_token is None:\n            token = ExternalAuthResult(data_dict=data).store_data()\n        else:\n            token = force_token\n        url_path = reverse(log_into_subdomain, args=[token])\n        return self.client_get(url_path, subdomain=subdomain)\n\n    def test_redirect_to_next_url_for_log_into_subdomain(self) -> None:\n        def test_redirect_to_next_url(next: str = \"\") -> HttpResponse:\n            data: ExternalAuthDataDict = {\n                \"full_name\": \"Hamlet\",\n                \"email\": self.example_email(\"hamlet\"),\n                \"subdomain\": \"zulip\",\n                \"is_signup\": False,\n                \"redirect_to\": next,\n            }\n            user_profile = self.example_user(\"hamlet\")\n            with mock.patch(\"zerver.views.auth.authenticate\", return_value=user_profile):\n                with mock.patch(\"zerver.views.auth.do_login\"):\n                    result = self.get_log_into_subdomain(data)\n            return result\n\n        res = test_redirect_to_next_url()\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver\")\n        res = test_redirect_to_next_url(\"/user_uploads/path_to_image\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/user_uploads/path_to_image\")\n\n        res = test_redirect_to_next_url(\"/#narrow/stream/7-test-here\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/#narrow/stream/7-test-here\")\n\n    def test_log_into_subdomain_when_token_is_malformed(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": self.example_email(\"hamlet\"),\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n        with self.assertLogs(level=\"WARNING\") as m:\n            result = self.get_log_into_subdomain(data, force_token=\"nonsense\")\n        self.assertEqual(\n            m.output,\n            [\"WARNING:root:log_into_subdomain: Malformed token given: {}\".format(\"nonsense\")],\n        )\n        self.assertEqual(result.status_code, 400)\n\n    def test_log_into_subdomain_when_token_not_found(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": self.example_email(\"hamlet\"),\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n        with self.assertLogs(level=\"WARNING\") as m:\n            token = secrets.token_hex(ExternalAuthResult.LOGIN_TOKEN_LENGTH // 2)\n            result = self.get_log_into_subdomain(data, force_token=token)\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Invalid or expired login session.\", result)\n        self.assertEqual(\n            m.output, [f\"WARNING:root:log_into_subdomain: Invalid token given: {token}\"]\n        )\n\n    def test_prevent_duplicate_signups(self) -> None:\n        existing_user = self.example_user(\"hamlet\")\n        existing_user.delivery_email = \"existing@zulip.com\"\n        existing_user.email = \"whatever@zulip.com\"\n        existing_user.save()\n\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": \"existing@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": True,\n            \"redirect_to\": \"\",\n        }\n        result = self.get_log_into_subdomain(data)\n\n        # Should simply get logged into the existing account:\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(existing_user.id)\n\n    def test_log_into_subdomain_when_is_signup_is_true_and_new_user(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"New User Name\",\n            \"email\": \"new@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": True,\n            \"redirect_to\": \"\",\n        }\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().first()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        confirmation_data = {\n            \"from_confirmation\": \"1\",\n            \"full_name\": data[\"full_name\"],\n            \"key\": confirmation_key,\n        }\n        result = self.client_post(\"/accounts/register/\", confirmation_data, subdomain=\"zulip\")\n        self.assert_in_response(\"We just need you to do one last thing\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response([\"id_password\"], result)\n        self.assert_in_success_response([\"id_full_name\"], result)\n\n    def test_log_into_subdomain_when_is_signup_is_false_and_new_user(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"New User Name\",\n            \"email\": \"new@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"No account found for\", result)\n        self.assert_in_response(\"new@zulip.com.\", result)\n        self.assert_in_response('action=\"http://zulip.testserver/accounts/do_confirm/', result)\n\n        url = re.findall(\n            'action=\"(http://zulip.testserver/accounts/do_confirm[^\"]*)\"',\n            result.content.decode(),\n        )[0]\n        confirmation = Confirmation.objects.all().first()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn(\"do_confirm/\" + confirmation_key, url)\n        result = self.client_get(url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        confirmation_data = {\n            \"from_confirmation\": \"1\",\n            \"full_name\": data[\"full_name\"],\n            \"key\": confirmation_key,\n        }\n        result = self.client_post(\"/accounts/register/\", confirmation_data, subdomain=\"zulip\")\n        self.assert_in_response(\"We just need you to do one last thing\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response([\"id_password\"], result)\n        self.assert_in_success_response([\"id_full_name\"], result)\n\n    def test_log_into_subdomain_when_using_invite_link(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"New User Name\",\n            \"email\": \"new@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": True,\n            \"redirect_to\": \"\",\n        }\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        stream_names = [\"new_stream_1\", \"new_stream_2\"]\n        streams = []\n        for stream_name in set(stream_names):\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        # Without the invite link, we can't create an account due to invite_required\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Sign up for Zulip\"], result)\n\n        # Now confirm an invitation link works\n        referrer = self.example_user(\"hamlet\")\n        multiuse_obj = MultiuseInvite.objects.create(realm=realm, referred_by=referrer)\n        multiuse_obj.streams.set(streams)\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_obj, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        multiuse_confirmation = Confirmation.objects.all().last()\n        assert multiuse_confirmation is not None\n        multiuse_object_key = multiuse_confirmation.confirmation_key\n\n        data[\"multiuse_object_key\"] = multiuse_object_key\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 302)\n\n        confirmation = Confirmation.objects.all().last()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data2 = {\"from_confirmation\": \"1\", \"full_name\": data[\"full_name\"], \"key\": confirmation_key}\n        result = self.client_post(\"/accounts/register/\", data2, subdomain=\"zulip\")\n        self.assert_in_response(\"We just need you to do one last thing\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response([\"id_password\"], result)\n        self.assert_in_success_response([\"id_full_name\"], result)\n\n        # Click confirm registration button.\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"full_name\": \"New User Name\", \"key\": confirmation_key, \"terms\": True},\n        )\n        self.assertEqual(result.status_code, 302)\n        new_user = get_user_by_delivery_email(\"new@zulip.com\", realm)\n        new_streams = self.get_streams(new_user)\n        self.assertEqual(sorted(new_streams), stream_names)\n\n    def test_log_into_subdomain_when_email_is_none(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n\n        with self.assertLogs(level=\"WARNING\") as m:\n            token = secrets.token_hex(ExternalAuthResult.LOGIN_TOKEN_LENGTH // 2)\n            result = self.get_log_into_subdomain(data, force_token=token)\n            self.assertEqual(result.status_code, 400)\n        self.assertEqual(\n            m.output, [f\"WARNING:root:log_into_subdomain: Invalid token given: {token}\"]\n        )\n\n    def test_user_cannot_log_into_wrong_subdomain(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": self.example_email(\"hamlet\"),\n            \"subdomain\": \"zephyr\",\n        }\n        result = self.get_log_into_subdomain(data)\n        self.assert_json_error(result, \"Invalid subdomain\")\n\n\nclass JSONFetchAPIKeyTest(ZulipTestCase):\n    def test_success(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.client_post(\n            \"/json/fetch_api_key\", dict(password=initial_password(user.delivery_email))\n        )\n        self.assert_json_success(result)\n\n    def test_not_loggedin(self) -> None:\n        user = self.example_user(\"hamlet\")\n        result = self.client_post(\n            \"/json/fetch_api_key\", dict(password=initial_password(user.delivery_email))\n        )\n        self.assert_json_error(\n            result, \"Not logged in: API authentication or user session required\", 401\n        )\n\n    def test_wrong_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.client_post(\"/json/fetch_api_key\", dict(password=\"wrong\"))\n        self.assert_json_error(result, \"Password is incorrect.\", 400)\n\n    def test_invalid_subdomain(self) -> None:\n        username = \"hamlet\"\n        user = self.example_user(username)\n        self.login_user(user)\n        with mock.patch(\"zerver.views.auth.get_realm_from_request\", return_value=None):\n            result = self.client_post(\n                \"/json/fetch_api_key\",\n                dict(username=username, password=initial_password(user.delivery_email)),\n            )\n        self.assert_json_error(result, \"Invalid subdomain\", 400)\n\n\nclass FetchAPIKeyTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.email = self.user_profile.delivery_email\n\n    def test_success(self) -> None:\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=self.email, password=initial_password(self.email)),\n        )\n        self.assert_json_success(result)\n\n    def test_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\", dict(username=\"hamlet\", password=initial_password(self.email))\n        )\n        self.assert_json_error(result, \"Enter a valid email address.\", 400)\n\n    def test_wrong_password(self) -> None:\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\", dict(username=self.email, password=\"wrong\")\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n    def test_invalid_subdomain(self) -> None:\n        with mock.patch(\"zerver.views.auth.get_realm_from_request\", return_value=None):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=\"hamlet\", password=initial_password(self.email)),\n            )\n        self.assert_json_error(result, \"Invalid subdomain\", 404)\n\n    def test_password_auth_disabled(self) -> None:\n        with mock.patch(\"zproject.backends.password_auth_enabled\", return_value=False):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=self.email, password=initial_password(self.email)),\n            )\n            self.assert_json_error_contains(\n                result, \"Password authentication is disabled in this organization\", 401\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auth_email_auth_disabled_success(self) -> None:\n        self.init_default_ldap_database()\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=self.example_email(\"hamlet\"), password=self.ldap_password(\"hamlet\")),\n            )\n        self.assert_json_success(result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n        LDAP_APPEND_DOMAIN=\"zulip.com\",\n        AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"org_membership\": \"department\"},\n    )\n    def test_ldap_auth_email_auth_organization_restriction(self) -> None:\n        self.init_default_ldap_database()\n        # We do test two combinations here:\n        # The first user has no (department) attribute set\n        # The second user has one set, but to a different value\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"testWrongRealm\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"zulip\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n        LDAP_APPEND_DOMAIN=\"zulip.com\",\n        AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"org_membership\": \"department\"},\n        AUTH_LDAP_ADVANCED_REALM_ACCESS_CONTROL={\n            \"zulip\": [{\"test1\": \"test\", \"test2\": \"testing\"}, {\"test1\": \"test2\"}],\n            \"anotherRealm\": [{\"test2\": \"test2\"}],\n        },\n    )\n    def test_ldap_auth_email_auth_advanced_organization_restriction(self) -> None:\n        self.init_default_ldap_database()\n\n        # The first user has no attribute set\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"test2\", \"testing\")\n        # Check with only one set\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"test1\", \"test\")\n        # Setting org_membership to not cause django_ldap_auth to warn, when synchronising\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"wrongDepartment\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n        self.remove_ldap_user_attr(\"hamlet\", \"test2\")\n        self.remove_ldap_user_attr(\"hamlet\", \"test1\")\n\n        # Using the OR value\n        self.change_ldap_user_attr(\"hamlet\", \"test1\", \"test2\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n\n        # Testing without org_membership\n        with override_settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\"}):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n            )\n            self.assert_json_success(result)\n\n        # Setting test1 to wrong value\n        self.change_ldap_user_attr(\"hamlet\", \"test1\", \"invalid\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        # Override access with `org_membership`\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"zulip\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n        self.remove_ldap_user_attr(\"hamlet\", \"department\")\n\n        # Test wrong configuration\n        with override_settings(\n            AUTH_LDAP_ADVANCED_REALM_ACCESS_CONTROL={\"not_zulip\": [{\"department\": \"zulip\"}]}\n        ):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n            )\n            self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n    def test_inactive_user(self) -> None:\n        do_deactivate_user(self.user_profile, acting_user=None)\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=self.email, password=initial_password(self.email)),\n        )\n        self.assert_json_error_contains(result, \"Account is deactivated\", 401)\n\n    def test_deactivated_realm(self) -> None:\n        do_deactivate_realm(self.user_profile.realm, acting_user=None)\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=self.email, password=initial_password(self.email)),\n        )\n        self.assert_json_error_contains(result, \"This organization has been deactivated\", 401)\n\n    def test_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=self.email, password=password),\n            )\n            self.assert_json_error(\n                result, \"Your password has been disabled and needs to be reset\", 401\n            )\n\n\nclass DevFetchAPIKeyTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.email = self.user_profile.delivery_email\n\n    def test_success(self) -> None:\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n        self.assert_json_success(result)\n        data = result.json()\n        self.assertEqual(data[\"email\"], self.email)\n        user_api_keys = get_all_api_keys(self.user_profile)\n        self.assertIn(data[\"api_key\"], user_api_keys)\n\n    def test_invalid_email(self) -> None:\n        email = \"hamlet\"\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=email))\n        self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_unregistered_user(self) -> None:\n        email = \"foo@zulip.com\"\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=email))\n        self.assert_json_error_contains(result, \"Your username or password is incorrect\", 401)\n\n    def test_inactive_user(self) -> None:\n        do_deactivate_user(self.user_profile, acting_user=None)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n        self.assert_json_error_contains(result, \"Account is deactivated\", 401)\n\n    def test_deactivated_realm(self) -> None:\n        do_deactivate_realm(self.user_profile.realm, acting_user=None)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n        self.assert_json_error_contains(result, \"This organization has been deactivated\", 401)\n\n    def test_dev_auth_disabled(self) -> None:\n        with mock.patch(\"zerver.views.development.dev_login.dev_auth_enabled\", return_value=False):\n            result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n            self.assert_json_error_contains(result, \"DevAuthBackend not enabled.\", 400)\n\n    def test_invalid_subdomain(self) -> None:\n        with mock.patch(\n            \"zerver.views.development.dev_login.get_realm_from_request\", return_value=None\n        ):\n            result = self.client_post(\n                \"/api/v1/dev_fetch_api_key\",\n                dict(username=self.email, password=initial_password(self.email)),\n            )\n            self.assert_json_error_contains(result, \"Invalid subdomain\", 404)\n\n\nclass DevGetEmailsTest(ZulipTestCase):\n    def test_success(self) -> None:\n        result = self.client_get(\"/api/v1/dev_list_users\")\n        self.assert_json_success(result)\n        self.assert_in_response(\"direct_admins\", result)\n        self.assert_in_response(\"direct_users\", result)\n\n    def test_dev_auth_disabled(self) -> None:\n        with mock.patch(\"zerver.views.development.dev_login.dev_auth_enabled\", return_value=False):\n            result = self.client_get(\"/api/v1/dev_list_users\")\n            self.assert_json_error_contains(result, \"DevAuthBackend not enabled.\", 400)\n\n        with override_settings(PRODUCTION=True):\n            result = self.client_get(\"/api/v1/dev_list_users\")\n            self.assert_json_error_contains(result, \"Endpoint not available in production.\", 400)\n\n\nclass ExternalMethodDictsTests(ZulipTestCase):\n    def get_configured_saml_backend_idp_names(self) -> List[str]:\n        return settings.SOCIAL_AUTH_SAML_ENABLED_IDPS.keys()\n\n    def test_get_external_method_dicts_correctly_sorted(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.GitHubAuthBackend\",\n                \"zproject.backends.GoogleAuthBackend\",\n                \"zproject.backends.ZulipRemoteUserBackend\",\n                \"zproject.backends.SAMLAuthBackend\",\n                \"zproject.backends.AzureADAuthBackend\",\n            ),\n        ):\n            external_auth_methods = get_external_method_dicts()\n            # First backends in the list should be SAML:\n            self.assertIn(\"saml:\", external_auth_methods[0][\"name\"])\n            self.assertEqual(\n                [social_backend[\"name\"] for social_backend in external_auth_methods[1:]],\n                [\n                    social_backend.name\n                    for social_backend in sorted(\n                        [\n                            ZulipRemoteUserBackend,\n                            GitHubAuthBackend,\n                            AzureADAuthBackend,\n                            GoogleAuthBackend,\n                        ],\n                        key=lambda x: x.sort_order,\n                        reverse=True,\n                    )\n                ],\n            )\n\n    def test_get_external_method_buttons(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.GitHubAuthBackend\",\n                \"zproject.backends.GoogleAuthBackend\",\n                \"zproject.backends.SAMLAuthBackend\",\n            ),\n        ):\n            saml_idp_names = self.get_configured_saml_backend_idp_names()\n            expected_button_id_strings = [\n                'id=\"{}_auth_button_github\"',\n                'id=\"{}_auth_button_google\"',\n            ]\n            for name in saml_idp_names:\n                expected_button_id_strings.append(f'id=\"{{}}_auth_button_saml:{name}\"')\n\n            result = self.client_get(\"/login/\")\n            self.assert_in_success_response(\n                [string.format(\"login\") for string in expected_button_id_strings], result\n            )\n\n            result = self.client_get(\"/register/\")\n            self.assert_in_success_response(\n                [string.format(\"register\") for string in expected_button_id_strings], result\n            )\n\n    def test_get_external_method_dicts_multiple_saml_idps(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        # Create another IdP config, by copying the original one and changing some details.idps_dict['test_idp'])\n        idps_dict[\"test_idp2\"] = copy.deepcopy(idps_dict[\"test_idp\"])\n        idps_dict[\"test_idp2\"][\"url\"] = \"https://idp2.example.com/idp/profile/SAML2/Redirect/SSO\"\n        idps_dict[\"test_idp2\"][\"display_name\"] = \"Second Test IdP\"\n        idps_dict[\"test_idp2\"][\"limit_to_subdomains\"] = [\"zephyr\"]\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict,\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.GitHubAuthBackend\",\n                \"zproject.backends.SAMLAuthBackend\",\n            ),\n        ):\n            # Calling get_external_method_dicts without a realm returns all methods configured on the server:\n            external_auth_methods = get_external_method_dicts()\n            # 1 IdP enabled for all realms + a dict for GitHub auth\n            self.assert_length(external_auth_methods, 2)\n            self.assertEqual(\n                [external_auth_methods[0][\"name\"], external_auth_methods[1][\"name\"]],\n                [\"saml:test_idp\", \"github\"],\n            )\n\n            external_auth_methods = get_external_method_dicts(get_realm(\"zulip\"))\n            # Only test_idp enabled for the zulip realm, + GitHub auth.\n            self.assert_length(external_auth_methods, 2)\n            self.assertEqual(\n                [external_auth_methods[0][\"name\"], external_auth_methods[1][\"name\"]],\n                [\"saml:test_idp\", \"github\"],\n            )\n\n            external_auth_methods = get_external_method_dicts(get_realm(\"zephyr\"))\n            # Both idps enabled for the zephyr realm, + GitHub auth.\n            self.assert_length(external_auth_methods, 3)\n            self.assertEqual(\n                {external_auth_methods[0][\"name\"], external_auth_methods[1][\"name\"]},\n                {\"saml:test_idp\", \"saml:test_idp2\"},\n            )\n\n\nclass FetchAuthBackends(ZulipTestCase):\n    def test_get_server_settings(self) -> None:\n        def check_result(\n            result: HttpResponse, extra_fields: Sequence[Tuple[str, Validator[object]]] = []\n        ) -> None:\n            authentication_methods_list = [\n                (\"password\", check_bool),\n            ]\n            for backend_name_with_case in AUTH_BACKEND_NAME_MAP:\n                authentication_methods_list.append((backend_name_with_case.lower(), check_bool))\n            external_auth_methods = get_external_method_dicts()\n\n            self.assert_json_success(result)\n            checker = check_dict_only(\n                [\n                    (\"authentication_methods\", check_dict_only(authentication_methods_list)),\n                    (\n                        \"external_authentication_methods\",\n                        check_list(\n                            check_dict_only(\n                                [\n                                    (\"display_icon\", check_none_or(check_string)),\n                                    (\"display_name\", check_string),\n                                    (\"login_url\", check_string),\n                                    (\"name\", check_string),\n                                    (\"signup_url\", check_string),\n                                ]\n                            ),\n                            length=len(external_auth_methods),\n                        ),\n                    ),\n                    (\"email_auth_enabled\", check_bool),\n                    (\"is_incompatible\", check_bool),\n                    (\"require_email_format_usernames\", check_bool),\n                    (\"realm_uri\", check_string),\n                    (\"zulip_version\", check_string),\n                    (\"zulip_merge_base\", check_string),\n                    (\"zulip_feature_level\", check_int),\n                    (\"push_notifications_enabled\", check_bool),\n                    (\"realm_web_public_access_enabled\", check_bool),\n                    (\"msg\", check_string),\n                    (\"result\", check_string),\n                    *extra_fields,\n                ]\n            )\n            checker(\"data\", result.json())\n\n        result = self.client_get(\"/api/v1/server_settings\", subdomain=\"\", HTTP_USER_AGENT=\"\")\n        check_result(result)\n        self.assertEqual(\n            result.json()[\"external_authentication_methods\"], get_external_method_dicts()\n        )\n\n        result = self.client_get(\n            \"/api/v1/server_settings\", subdomain=\"\", HTTP_USER_AGENT=\"ZulipInvalid\"\n        )\n        self.assertTrue(result.json()[\"is_incompatible\"])\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\"/api/v1/server_settings\", subdomain=\"\", HTTP_USER_AGENT=\"\")\n        check_result(result)\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\n                \"/api/v1/server_settings\", subdomain=\"zulip\", HTTP_USER_AGENT=\"\"\n            )\n        check_result(\n            result,\n            [\n                (\"realm_name\", check_string),\n                (\"realm_description\", check_string),\n                (\"realm_icon\", check_string),\n            ],\n        )\n\n        # Verify invalid subdomain\n        result = self.client_get(\"/api/v1/server_settings\", subdomain=\"invalid\")\n        self.assert_json_error_contains(result, \"Invalid subdomain\", 400)\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            # With ROOT_DOMAIN_LANDING_PAGE, homepage fails\n            result = self.client_get(\"/api/v1/server_settings\", subdomain=\"\")\n            self.assert_json_error_contains(result, \"Subdomain required\", 400)\n\n\nclass TestTwoFactor(ZulipTestCase):\n    def test_direct_dev_login_with_2fa(self) -> None:\n        email = self.example_email(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        with self.settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True):\n            data = {\"direct_email\": email}\n            result = self.client_post(\"/accounts/login/local/\", data)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n            # User logs in but when otp device doesn't exist.\n            self.assertNotIn(\"otp_device_id\", self.client.session.keys())\n\n            self.create_default_device(user_profile)\n\n            data = {\"direct_email\": email}\n            result = self.client_post(\"/accounts/login/local/\", data)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n            # User logs in when otp device exists.\n            self.assertIn(\"otp_device_id\", self.client.session.keys())\n\n    @mock.patch(\"two_factor.models.totp\")\n    def test_two_factor_login_with_ldap(self, mock_totp: mock.MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        # Set up LDAP\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_log:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                info_log.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to `realm.uri` if user is\n            # already logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass TestDevAuthBackend(ZulipTestCase):\n    def test_login_success(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        data = {\"direct_email\": email}\n        result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_spectator(self) -> None:\n        data = {\"prefers_web_public_view\": \"Anonymous login\"}\n        result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zulip.testserver/\")\n\n    def test_login_success_with_2fa(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        email = user_profile.delivery_email\n        data = {\"direct_email\": email}\n        with self.settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True):\n            result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertIn(\"otp_device_id\", list(self.client.session.keys()))\n\n    def test_redirect_to_next_url(self) -> None:\n        def do_local_login(formaction: str) -> HttpResponse:\n            user_email = self.example_email(\"hamlet\")\n            data = {\"direct_email\": user_email}\n            return self.client_post(formaction, data)\n\n        res = do_local_login(\"/accounts/login/local/\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/\")\n\n        res = do_local_login(\"/accounts/login/local/?next=/user_uploads/path_to_image\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/user_uploads/path_to_image\")\n\n        # In local Email based authentication we never make browser send the hash\n        # to the backend. Rather we depend upon the browser's behaviour of persisting\n        # hash anchors in between redirect requests. See below stackoverflow conversation\n        # https://stackoverflow.com/questions/5283395/url-hash-is-persisting-between-redirects\n        res = do_local_login(\"/accounts/login/local/?next=#narrow/stream/7-test-here\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver\")\n\n    def test_login_with_subdomain(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        data = {\"direct_email\": email}\n\n        result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_choose_realm(self) -> None:\n        result = self.client_post(\"/devlogin/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n        result = self.client_post(\"/devlogin/\", subdomain=\"\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Click on a user to log in!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n\n        result = self.client_post(\"/devlogin/\", {\"new_realm\": \"all_realms\"}, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n        self.assert_in_success_response([\"Click on a user to log in!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n        data = {\"new_realm\": \"zephyr\"}\n        result = self.client_post(\"/devlogin/\", data, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zephyr.testserver\")\n\n        result = self.client_get(\"/devlogin/\", subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n        self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n        self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n    def test_choose_realm_with_subdomains_enabled(self) -> None:\n        with mock.patch(\"zerver.views.auth.is_subdomain_root_or_alias\", return_value=False):\n            with mock.patch(\n                \"zerver.views.auth.get_realm_from_request\", return_value=get_realm(\"zulip\")\n            ):\n                result = self.client_get(\"http://zulip.testserver/devlogin/\")\n                self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_not_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n\n            with mock.patch(\n                \"zerver.views.auth.get_realm_from_request\", return_value=get_realm(\"zephyr\")\n            ):\n                result = self.client_post(\n                    \"http://zulip.testserver/devlogin/\", {\"new_realm\": \"zephyr\"}\n                )\n                self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n                result = self.client_get(\"http://zephyr.testserver/devlogin/\")\n                self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n\n    def test_login_failure(self) -> None:\n        email = self.example_email(\"hamlet\")\n        data = {\"direct_email\": email}\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",)):\n            response = self.client_post(\"/accounts/login/local/\", data)\n        self.assert_in_success_response([\"Configuration error\", \"DevAuthBackend\"], response)\n\n    def test_dev_direct_production_config_error(self) -> None:\n        result = self.client_get(\"/config-error/dev\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"DevAuthBackend\"], result)\n\n    def test_login_failure_due_to_nonexistent_user(self) -> None:\n        email = \"nonexisting@zulip.com\"\n        data = {\"direct_email\": email}\n\n        response = self.client_post(\"/accounts/login/local/\", data)\n        self.assert_in_success_response([\"Configuration error\", \"DevAuthBackend\"], response)\n\n\nclass TestZulipRemoteUserBackend(DesktopFlowTestingLib, ZulipTestCase):\n    def test_start_remote_user_sso(self) -> None:\n        result = self.client_get(\n            \"/accounts/login/start/sso/\", {\"param1\": \"value1\", \"params\": \"value2\"}\n        )\n        self.assertEqual(result.status_code, 302)\n\n        url = result.url\n        parsed_url = urllib.parse.urlparse(url)\n        self.assertEqual(parsed_url.path, \"/accounts/login/sso/\")\n        self.assertEqual(parsed_url.query, \"param1=value1&params=value2\")\n\n    def test_start_remote_user_sso_with_desktop_app(self) -> None:\n        headers = dict(HTTP_USER_AGENT=\"ZulipElectron/5.0.0\")\n        result = self.client_get(\"/accounts/login/start/sso/\", {}, **headers)\n        self.verify_desktop_flow_app_page(result)\n\n    def test_login_success(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_success_with_sso_append_domain(self) -> None:\n        username = \"hamlet\"\n        user_profile = self.example_user(\"hamlet\")\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",),\n            SSO_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=username)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_case_insensitive(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email_upper = user_profile.delivery_email.upper()\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email_upper)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_failure(self) -> None:\n        email = self.example_email(\"hamlet\")\n        result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n        self.assert_in_success_response(\n            [\"Configuration error\", \"Authentication via the REMOTE_USER header is\"], result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_failure_due_to_nonexisting_user(self) -> None:\n        email = \"nonexisting@zulip.com\"\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n            self.assertEqual(result.status_code, 200)\n            self.assert_logged_in_user_id(None)\n            self.assert_in_response(\"No account found for\", result)\n\n    def test_login_failure_due_to_invalid_email(self) -> None:\n        email = \"hamlet\"\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n            self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_login_failure_due_to_missing_field(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\")\n            self.assert_in_success_response(\n                [\"Configuration error\", \"The REMOTE_USER header is not set.\"], result\n            )\n\n    def test_login_failure_due_to_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"acme\"):\n                result = self.client_get(\n                    \"http://testserver:9080/accounts/login/sso/\", REMOTE_USER=email\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assert_logged_in_user_id(None)\n                self.assert_in_response(\"You need an invitation to join this organization.\", result)\n\n    def test_login_failure_due_to_empty_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"\"):\n                result = self.client_get(\n                    \"http://testserver:9080/accounts/login/sso/\", REMOTE_USER=email\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assert_logged_in_user_id(None)\n                self.assert_in_response(\"You need an invitation to join this organization.\", result)\n\n    def test_login_success_under_subdomains(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"zulip\"):\n            with self.settings(\n                AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)\n            ):\n                result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n                self.assertEqual(result.status_code, 302)\n                self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_login_mobile_flow_otp_success_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        mobile_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"1234\"),\n            REMOTE_USER=email,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"invalido\" * 8),\n            REMOTE_USER=email,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=mobile_flow_otp),\n            REMOTE_USER=email,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(SSO_APPEND_DOMAIN=\"zulip.com\")\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_login_mobile_flow_otp_success_username(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        remote_user = email_to_username(email)\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        mobile_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"1234\"),\n            REMOTE_USER=remote_user,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"invalido\" * 8),\n            REMOTE_USER=remote_user,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=mobile_flow_otp),\n            REMOTE_USER=remote_user,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipRemoteUserBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_login_desktop_flow_otp_success_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        desktop_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"1234\"), REMOTE_USER=email\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"invalido\" * 8), REMOTE_USER=email\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=desktop_flow_otp), REMOTE_USER=email\n        )\n        self.verify_desktop_flow_end_page(result, email, desktop_flow_otp)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(SSO_APPEND_DOMAIN=\"zulip.com\")\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipRemoteUserBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_login_desktop_flow_otp_success_username(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        remote_user = email_to_username(email)\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        desktop_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"1234\"), REMOTE_USER=remote_user\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"invalido\" * 8), REMOTE_USER=remote_user\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=desktop_flow_otp), REMOTE_USER=remote_user\n        )\n        self.verify_desktop_flow_end_page(result, email, desktop_flow_otp)\n\n    def test_redirect_to(self) -> None:\n        \"\"\"This test verifies the behavior of the redirect_to logic in\n        login_or_register_remote_user.\"\"\"\n\n        def test_with_redirect_to_param_set_as_next(next: str = \"\") -> HttpResponse:\n            user_profile = self.example_user(\"hamlet\")\n            email = user_profile.delivery_email\n            with self.settings(\n                AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)\n            ):\n                result = self.client_get(\"/accounts/login/sso/\", {\"next\": next}, REMOTE_USER=email)\n            return result\n\n        res = test_with_redirect_to_param_set_as_next()\n        self.assertEqual(\"http://zulip.testserver\", res.url)\n        res = test_with_redirect_to_param_set_as_next(\"/user_uploads/image_path\")\n        self.assertEqual(\"http://zulip.testserver/user_uploads/image_path\", res.url)\n\n        # Third-party domains are rejected and just send you to root domain\n        res = test_with_redirect_to_param_set_as_next(\"https://rogue.zulip-like.server/login\")\n        self.assertEqual(\"http://zulip.testserver\", res.url)\n\n\nclass TestJWTLogin(ZulipTestCase):\n    \"\"\"\n    JWT uses ZulipDummyBackend.\n    \"\"\"\n\n    def test_login_success(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            email = self.example_email(\"hamlet\")\n            realm = get_realm(\"zulip\")\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n\n            user_profile = get_user_by_delivery_email(email, realm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_failure_when_user_is_missing(self) -> None:\n        payload = {\"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assert_json_error_contains(\n                result, \"No user specified in JSON web token claims\", 400\n            )\n\n    def test_login_failure_when_realm_is_missing(self) -> None:\n        payload = {\"user\": \"hamlet\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assert_json_error_contains(\n                result, \"No organization specified in JSON web token claims\", 400\n            )\n\n    def test_login_failure_when_key_does_not_exist(self) -> None:\n        data = {\"json_web_token\": \"not relevant\"}\n        result = self.client_post(\"/accounts/login/jwt/\", data)\n        self.assert_json_error_contains(result, \"Auth key for this subdomain not found.\", 400)\n\n    def test_login_failure_when_key_is_missing(self) -> None:\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            result = self.client_post(\"/accounts/login/jwt/\")\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n\n    def test_login_failure_when_bad_token_is_passed(self) -> None:\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            result = self.client_post(\"/accounts/login/jwt/\")\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n            data = {\"json_web_token\": \"bad token\"}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assert_json_error_contains(result, \"Bad JSON web token\", 400)\n\n    def test_login_failure_when_user_does_not_exist(self) -> None:\n        payload = {\"user\": \"nonexisting\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n            self.assert_logged_in_user_id(None)\n\n    def test_login_failure_due_to_wrong_subdomain(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"acme\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"acme\"):\n                key = settings.JWT_AUTH_KEYS[\"acme\"][\"key\"]\n                [algorithm] = settings.JWT_AUTH_KEYS[\"acme\"][\"algorithms\"]\n                web_token = jwt.encode(payload, key, algorithm)\n\n                data = {\"json_web_token\": web_token}\n                result = self.client_post(\"/accounts/login/jwt/\", data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assert_logged_in_user_id(None)\n\n    def test_login_failure_due_to_empty_subdomain(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"\"):\n                key = settings.JWT_AUTH_KEYS[\"\"][\"key\"]\n                [algorithm] = settings.JWT_AUTH_KEYS[\"\"][\"algorithms\"]\n                web_token = jwt.encode(payload, key, algorithm)\n\n                data = {\"json_web_token\": web_token}\n                result = self.client_post(\"/accounts/login/jwt/\", data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assert_logged_in_user_id(None)\n\n    def test_login_success_under_subdomains(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"zulip\"):\n                key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n                [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n                web_token = jwt.encode(payload, key, algorithm)\n\n                data = {\"json_web_token\": web_token}\n                result = self.client_post(\"/accounts/login/jwt/\", data)\n                self.assertEqual(result.status_code, 302)\n                user_profile = self.example_user(\"hamlet\")\n                self.assert_logged_in_user_id(user_profile.id)\n\n\nclass DjangoToLDAPUsernameTests(ZulipTestCase):\n    def setUp(self) -> None:\n        self.init_default_ldap_database()\n        self.backend = ZulipLDAPAuthBackend()\n\n    def test_django_to_ldap_username_with_append_domain(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            self.assertEqual(self.backend.django_to_ldap_username(\"hamlet\"), \"hamlet\")\n            self.assertEqual(self.backend.django_to_ldap_username(\"hamlet@zulip.com\"), \"hamlet\")\n            with self.assertRaisesRegex(\n                ZulipLDAPExceptionOutsideDomain,\n                \"Email hamlet@example.com does not match LDAP domain zulip.com.\",\n            ):\n                self.backend.django_to_ldap_username(\"hamlet@example.com\")\n\n            self.mock_ldap.directory['uid=\"hamlet@test\",ou=users,dc=zulip,dc=com'] = {\n                \"cn\": [\"King Hamlet\"],\n                \"uid\": ['\"hamlet@test\"'],\n            }\n            username = self.backend.django_to_ldap_username('\"hamlet@test\"@zulip.com')\n            self.assertEqual(username, '\"hamlet@test\"')\n\n            self.mock_ldap.directory['uid=\"hamlet@test\"@zulip,ou=users,dc=zulip,dc=com'] = {\n                \"cn\": [\"King Hamlet\"],\n                \"uid\": ['\"hamlet@test\"@zulip'],\n            }\n            username = self.backend.django_to_ldap_username('\"hamlet@test\"@zulip')\n            self.assertEqual(username, '\"hamlet@test\"@zulip')\n\n    def test_django_to_ldap_username_with_email_search(self) -> None:\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"hamlet\"), self.ldap_username(\"hamlet\")\n        )\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"hamlet@zulip.com\"), self.ldap_username(\"hamlet\")\n        )\n        # If there are no matches through the email search, raise exception:\n        with self.assertRaises(ZulipLDAPExceptionNoMatchingLDAPUser):\n            self.backend.django_to_ldap_username(\"no_such_email@example.com\")\n\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"aaron@zulip.com\"), self.ldap_username(\"aaron\")\n        )\n\n        with self.assertLogs(level=\"WARNING\") as m:\n            with self.assertRaises(ZulipLDAPExceptionNoMatchingLDAPUser):\n                self.backend.django_to_ldap_username(\"shared_email@zulip.com\")\n        self.assertEqual(\n            m.output,\n            [\n                \"WARNING:root:Multiple users with email {} found in LDAP.\".format(\n                    \"shared_email@zulip.com\"\n                )\n            ],\n        )\n\n        # Test on a weird case of a user whose uid is an email and his actual \"mail\"\n        # attribute is a different email address:\n        self.mock_ldap.directory[\"uid=some_user@organization_a.com,ou=users,dc=zulip,dc=com\"] = {\n            \"cn\": [\"Some User\"],\n            \"uid\": [\"some_user@organization_a.com\"],\n            \"mail\": [\"some_user@contactaddress.com\"],\n        }\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"some_user@contactaddress.com\"),\n            \"some_user@organization_a.com\",\n        )\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"some_user@organization_a.com\"),\n            \"some_user@organization_a.com\",\n        )\n\n        # Configure email search for emails in the uid attribute:\n        with self.settings(\n            AUTH_LDAP_REVERSE_EMAIL_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(uid=%(email)s)\"\n            )\n        ):\n            self.assertEqual(\n                self.backend.django_to_ldap_username(\"newuser_email_as_uid@zulip.com\"),\n                \"newuser_email_as_uid@zulip.com\",\n            )\n\n            self.mock_ldap.directory['uid=\"hamlet@test\"@zulip.com\",ou=users,dc=zulip,dc=com'] = {\n                \"cn\": [\"King Hamlet\"],\n                \"uid\": ['\"hamlet@test\"@zulip.com'],\n            }\n            username = self.backend.django_to_ldap_username('\"hamlet@test\"@zulip.com')\n            self.assertEqual(username, '\"hamlet@test\"@zulip.com')\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n        )\n    )\n    def test_authenticate_to_ldap_via_email(self) -> None:\n        \"\"\"\n        With AUTH_LDAP_REVERSE_EMAIL_SEARCH configured, django_to_ldap_username\n        should be able to translate an email to LDAP username,\n        and thus it should be possible to authenticate through user_profile.delivery_email.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.assertEqual(\n                authenticate(\n                    request=mock.MagicMock(),\n                    username=user_profile.delivery_email,\n                    password=self.ldap_password(\"hamlet\"),\n                    realm=realm,\n                ),\n                user_profile,\n            )\n\n    @override_settings(LDAP_EMAIL_ATTR=\"mail\", LDAP_DEACTIVATE_NON_MATCHING_USERS=True)\n    def test_sync_user_from_ldap_with_email_attr(self) -> None:\n        \"\"\"In LDAP configurations with LDAP_EMAIL_ATTR configured and\n        LDAP_DEACTIVATE_NON_MATCHING_USERS set, a possible failure\n        mode if django_to_ldap_username isn't configured correctly is\n        all LDAP users having their accounts deactivated.  Before the\n        introduction of AUTH_LDAP_REVERSE_EMAIL_SEARCH, this would happen\n        even in valid LDAP configurations using LDAP_EMAIL_ATTR.\n\n        This test confirms that such a failure mode doesn't happen with\n        a valid LDAP configuration.\n        \"\"\"\n\n        user_profile = self.example_user(\"hamlet\")\n        with self.settings():\n            sync_user_from_ldap(user_profile, mock.Mock())\n            # Syncing didn't deactivate the user:\n            self.assertTrue(user_profile.is_active)\n\n\nclass ZulipLDAPTestCase(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.init_default_ldap_database()\n\n        user_profile = self.example_user(\"hamlet\")\n        self.setup_subdomain(user_profile)\n        self.backend = ZulipLDAPAuthBackend()\n\n        # Internally `_realm` and `_prereg_user` attributes are automatically set\n        # by the `authenticate()` method. But for testing the `get_or_build_user()`\n        # method separately, we need to set them manually.\n        self.backend._realm = get_realm(\"zulip\")\n        self.backend._prereg_user = None\n\n    def setup_subdomain(self, user_profile: UserProfile) -> None:\n        realm = user_profile.realm\n        realm.string_id = \"zulip\"\n        realm.save()\n\n\nclass TestLDAP(ZulipLDAPTestCase):\n    def test_generate_dev_ldap_dir(self) -> None:\n        ldap_dir = generate_dev_ldap_dir(\"A\", 10)\n        self.assert_length(ldap_dir, 10)\n        regex = re.compile(\n            r\"(uid\\=)+[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+(\\,ou\\=users\\,dc\\=zulip\\,dc\\=com)\"\n        )\n        common_attrs = [\"cn\", \"userPassword\", \"phoneNumber\", \"birthDate\"]\n        for key, value in ldap_dir.items():\n            self.assertTrue(regex.match(key))\n            self.assertCountEqual(\n                list(value.keys()), [*common_attrs, \"uid\", \"thumbnailPhoto\", \"userAccountControl\"]\n            )\n\n        ldap_dir = generate_dev_ldap_dir(\"b\", 9)\n        self.assert_length(ldap_dir, 9)\n        regex = re.compile(r\"(uid\\=)+[a-zA-Z0-9_.+-]+(\\,ou\\=users\\,dc\\=zulip\\,dc\\=com)\")\n        for key, value in ldap_dir.items():\n            self.assertTrue(regex.match(key))\n            self.assertCountEqual(list(value.keys()), [*common_attrs, \"uid\", \"jpegPhoto\"])\n\n        ldap_dir = generate_dev_ldap_dir(\"c\", 8)\n        self.assert_length(ldap_dir, 8)\n        regex = re.compile(r\"(uid\\=)+[a-zA-Z0-9_.+-]+(\\,ou\\=users\\,dc\\=zulip\\,dc\\=com)\")\n        for key, value in ldap_dir.items():\n            self.assertTrue(regex.match(key))\n            self.assertCountEqual(list(value.keys()), [*common_attrs, \"uid\", \"email\"])\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_dev_ldap_fail_login(self) -> None:\n        # Tests that login with a substring of password fails. We had a bug in\n        # dev LDAP environment that allowed login via password substrings.\n        self.mock_ldap.directory = generate_dev_ldap_dir(\"B\", 8)\n        with self.settings(\n            AUTH_LDAP_USER_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(uid=%(user)s)\"\n            ),\n            AUTH_LDAP_REVERSE_EMAIL_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(email=%(email)s)\"\n            ),\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"ldapuser1\",\n                password=\"dapu\",\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is None\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_username(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"hamlet\",\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is not None\n            self.assertEqual(user_profile, self.example_user(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_email_attr(self) -> None:\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            username = self.ldap_username(\"aaron\")\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=username,\n                password=self.ldap_password(username),\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is not None\n            self.assertEqual(user_profile, self.example_user(\"aaron\"))\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n        )\n    )\n    def test_email_and_ldap_backends_together(self) -> None:\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_REVERSE_EMAIL_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(mail=%(email)s)\"\n            ),\n            AUTH_LDAP_USERNAME_ATTR=\"uid\",\n        ):\n            realm = get_realm(\"zulip\")\n            self.assertEqual(email_belongs_to_ldap(realm, self.example_email(\"aaron\")), True)\n            username = self.ldap_username(\"aaron\")\n            user_profile = ZulipLDAPAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=username,\n                password=self.ldap_password(username),\n                realm=realm,\n            )\n            self.assertEqual(user_profile, self.example_user(\"aaron\"))\n\n            othello = self.example_user(\"othello\")\n            password = \"testpassword\"\n            othello.set_password(password)\n            othello.save()\n\n            self.assertEqual(email_belongs_to_ldap(realm, othello.delivery_email), False)\n            user_profile = EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=othello.delivery_email,\n                password=password,\n                realm=realm,\n            )\n            self.assertEqual(user_profile, othello)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_due_to_wrong_password(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=\"wrong\",\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_due_to_nonexistent_user(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"), self.assertLogs(\n            \"zulip.ldap\", level=\"DEBUG\"\n        ) as log_debug:\n            user = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"nonexistent@zulip.com\",\n                password=\"doesnt_matter\",\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertEqual(\n                log_debug.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_permissions(self) -> None:\n        backend = self.backend\n        self.assertFalse(backend.has_perm(None, None))\n        self.assertFalse(backend.has_module_perms(None, None))\n        self.assertTrue(backend.get_all_permissions(None, None) == set())\n        self.assertTrue(backend.get_group_permissions(None, None) == set())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_user_email_from_ldapuser_with_append_domain(self) -> None:\n        backend = self.backend\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            username = backend.user_email_from_ldapuser(\n                \"this_argument_is_ignored\", _LDAPUser(self.backend, username='\"hamlet@test\"')\n            )\n            self.assertEqual(username, '\"hamlet@test\"@zulip.com')\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_user_exists(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"], \"sn\": [\"Short Name\"]}\n\n        backend = self.backend\n        email = self.example_email(\"hamlet\")\n        user_profile, created = backend.get_or_build_user(str(email), _LDAPUser())\n        self.assertFalse(created)\n        self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_user_does_not_exist(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = \"newuser@zulip.com\"\n            user_profile, created = backend.get_or_build_user(email, _LDAPUser())\n            self.assertTrue(created)\n            self.assertEqual(user_profile.delivery_email, email)\n            self.assertEqual(user_profile.full_name, \"Full Name\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_user_has_invalid_name(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"<invalid name>\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            with self.assertRaisesRegex(Exception, \"Invalid characters in name!\"):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_realm_is_deactivated(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            do_deactivate_realm(backend._realm, acting_user=None)\n            with self.assertRaisesRegex(Exception, \"Realm has been deactivated\"):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_ldap_has_no_email_attr(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"], \"sn\": [\"Short Name\"]}\n\n        nonexisting_attr = \"email\"\n        with self.settings(LDAP_EMAIL_ATTR=nonexisting_attr):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            with self.assertRaisesRegex(\n                Exception, \"LDAP user doesn't have the needed email attribute\"\n            ):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_email(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Test User\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            realm = self.backend._realm\n            realm.emails_restricted_to_domains = False\n            realm.disallow_disposable_email_addresses = True\n            realm.save()\n\n            email = \"spam@mailnator.com\"\n            with self.assertRaisesRegex(ZulipLDAPException, \"Email validation failed.\"):\n                self.backend.get_or_build_user(email, _LDAPUser())\n\n            realm.emails_restricted_to_domains = True\n            realm.save(update_fields=[\"emails_restricted_to_domains\"])\n\n            email = \"spam+spam@mailnator.com\"\n            with self.assertRaisesRegex(ZulipLDAPException, \"Email validation failed.\"):\n                self.backend.get_or_build_user(email, _LDAPUser())\n\n            email = \"spam@acme.com\"\n            with self.assertRaisesRegex(\n                ZulipLDAPException, \"This email domain isn't allowed in this organization.\"\n            ):\n                self.backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_ldap_has_no_full_name_mapping(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"], \"sn\": [\"Short Name\"]}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={}):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            with self.assertRaisesRegex(Exception, \"Missing required mapping for user's full name\"):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_when_domain_does_not_match(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"acme.com\"), self.assertLogs(\n            \"zulip.ldap\", \"DEBUG\"\n        ) as debug_log:\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertIs(user_profile, None)\n        self.assertEqual(\n            debug_log.output,\n            [\n                \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email hamlet@zulip.com does not match LDAP domain acme.com.\"\n            ],\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_different_subdomain(self) -> None:\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        do_create_realm(string_id=\"acme\", name=\"acme\")\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"zulip.com\", AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map\n        ):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"acme\"),\n            )\n            self.assertEqual(user_profile.delivery_email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_valid_subdomain(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_due_to_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    @override_settings(\n        AUTH_LDAP_USER_ATTR_MAP={\n            \"full_name\": \"cn\",\n            \"avatar\": \"jpegPhoto\",\n        }\n    )\n    def test_login_success_when_user_does_not_exist_with_valid_subdomain(self) -> None:\n        RealmDomain.objects.create(realm=self.backend._realm, domain=\"acme.com\")\n        with self.settings(LDAP_APPEND_DOMAIN=\"acme.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"newuser@acme.com\",\n                password=self.ldap_password(\"newuser\"),\n                realm=get_realm(\"zulip\"),\n            )\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, \"newuser@acme.com\")\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n            self.assertEqual(user_profile.realm.string_id, \"zulip\")\n\n            # Verify avatar gets created\n            self.assertEqual(user_profile.avatar_source, UserProfile.AVATAR_FROM_USER)\n            url = avatar_url(user_profile)\n            assert url is not None\n            response = self.client_get(url)\n            self.assertEqual(response.status_code, 200)\n            with open(os.path.join(settings.DEPLOY_ROOT, \"static/images/team/tim.png\"), \"rb\") as f:\n                tim = f.read()\n            self.assert_streaming_content(response, resize_avatar(tim, DEFAULT_AVATAR_SIZE))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_when_user_does_not_exist_with_split_full_name_mapping(self) -> None:\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP={\"first_name\": \"sn\", \"last_name\": \"cn\"},\n        ):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"newuser_splitname@zulip.com\",\n                password=self.ldap_password(\"newuser_splitname\"),\n                realm=get_realm(\"zulip\"),\n            )\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, \"newuser_splitname@zulip.com\")\n            self.assertEqual(user_profile.full_name, \"First Last\")\n            self.assertEqual(user_profile.realm.string_id, \"zulip\")\n\n\nclass TestZulipLDAPUserPopulator(ZulipLDAPTestCase):\n    def test_authenticate(self) -> None:\n        backend = ZulipLDAPUserPopulator()\n        result = backend.authenticate(\n            username=self.example_email(\"hamlet\"),\n            password=self.ldap_password(\"hamlet\"),\n            realm=get_realm(\"zulip\"),\n        )\n        self.assertIs(result, None)\n\n    def perform_ldap_sync(self, user_profile: UserProfile) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            result = sync_user_from_ldap(user_profile, mock.Mock())\n            self.assertTrue(result)\n\n    @mock.patch(\"zproject.backends.do_deactivate_user\")\n    def test_ldaperror_doesnt_deactivate_user(self, mock_deactivate: mock.MagicMock) -> None:\n        \"\"\"\n        This is a test for a bug where failure to connect to LDAP in sync_user_from_ldap\n        (e.g. due to invalid credentials) would cause the user to be deactivated if\n        LDAP_DEACTIVATE_NON_MATCHING_USERS was True.\n        Details: https://github.com/zulip/zulip/issues/13130\n        \"\"\"\n        with self.settings(\n            LDAP_DEACTIVATE_NON_MATCHING_USERS=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"wrongpass\",\n        ):\n            with self.assertRaises(ldap.INVALID_CREDENTIALS):\n                sync_user_from_ldap(self.example_user(\"hamlet\"), mock.Mock())\n            mock_deactivate.assert_not_called()\n\n        # Make sure other types of LDAPError won't cause deactivation either:\n        with mock.patch.object(_LDAPUser, \"_get_or_create_user\", side_effect=ldap.LDAPError):\n            with self.assertRaises(PopulateUserLDAPError):\n                sync_user_from_ldap(self.example_user(\"hamlet\"), mock.Mock())\n            mock_deactivate.assert_not_called()\n\n    @override_settings(LDAP_EMAIL_ATTR=\"mail\")\n    def test_populate_user_returns_none(self) -> None:\n        with mock.patch.object(ZulipLDAPUser, \"populate_user\", return_value=None):\n            with self.assertRaises(PopulateUserLDAPError):\n                sync_user_from_ldap(self.example_user(\"hamlet\"), mock.Mock())\n\n    def test_update_full_name(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"New Name\")\n\n        self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.full_name, \"New Name\")\n\n    def test_update_with_hidden_emails(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm,\n            \"email_address_visibility\",\n            Realm.EMAIL_ADDRESS_VISIBILITY_ADMINS,\n            acting_user=None,\n        )\n        hamlet.refresh_from_db()\n\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"New Name\")\n        self.perform_ldap_sync(hamlet)\n\n        hamlet.refresh_from_db()\n        self.assertEqual(hamlet.full_name, \"New Name\")\n\n    def test_update_split_full_name(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"Name\")\n        self.change_ldap_user_attr(\"hamlet\", \"sn\", \"Full\")\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"first_name\": \"sn\", \"last_name\": \"cn\"}):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.full_name, \"Full Name\")\n\n    def test_same_full_name(self) -> None:\n        with mock.patch(\"zerver.lib.actions.do_change_full_name\") as fn:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_not_called()\n\n    def test_too_short_name(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"a\")\n\n        with self.assertRaises(ZulipLDAPException), self.assertLogs(\n            \"django_auth_ldap\", \"WARNING\"\n        ) as warn_log:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        self.assertEqual(\n            warn_log.output,\n            [\"WARNING:django_auth_ldap:Name too short! while authenticating hamlet\"],\n        )\n\n    def test_deactivate_user_with_useraccountcontrol_attr(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"userAccountControl\", \"2\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"userAccountControl\": \"userAccountControl\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertFalse(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Deactivating user hamlet@zulip.com because they are disabled in LDAP.\"\n            ],\n        )\n\n    def test_deactivate_reactivate_user_with_deactivated_attr(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"someCustomAttr\", \"TRUE\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"deactivated\": \"someCustomAttr\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertFalse(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Deactivating user hamlet@zulip.com because they are disabled in LDAP.\"\n            ],\n        )\n\n        self.change_ldap_user_attr(\"hamlet\", \"someCustomAttr\", \"FALSE\")\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"deactivated\": \"someCustomAttr\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet.refresh_from_db()\n        self.assertTrue(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Reactivating user hamlet@zulip.com because they are not disabled in LDAP.\"\n            ],\n        )\n\n        self.change_ldap_user_attr(\"hamlet\", \"someCustomAttr\", \"YESSS\")\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"deactivated\": \"someCustomAttr\"}\n        ), self.assertLogs(\"django_auth_ldap\") as ldap_logs, self.assertRaises(AssertionError):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet.refresh_from_db()\n        self.assertTrue(hamlet.is_active)\n        self.assertEqual(\n            ldap_logs.output,\n            [\n                \"WARNING:django_auth_ldap:Invalid value 'YESSS' in the LDAP attribute mapped to deactivated while authenticating hamlet\"\n            ],\n        )\n\n    @mock.patch(\"zproject.backends.ZulipLDAPAuthBackendBase.sync_full_name_from_ldap\")\n    def test_dont_sync_disabled_ldap_user(self, fake_sync: mock.MagicMock) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"userAccountControl\", \"2\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"userAccountControl\": \"userAccountControl\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fake_sync.assert_not_called()\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Deactivating user hamlet@zulip.com because they are disabled in LDAP.\"\n            ],\n        )\n\n    def test_reactivate_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"userAccountControl\": \"userAccountControl\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertTrue(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Reactivating user hamlet@zulip.com because they are not disabled in LDAP.\"\n            ],\n        )\n\n    def test_user_in_multiple_realms(self) -> None:\n        test_realm = do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n        hamlet = self.example_user(\"hamlet\")\n        email = hamlet.delivery_email\n        hamlet2 = do_create_user(email, None, test_realm, hamlet.full_name, acting_user=None)\n\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"Second Hamlet\")\n        expected_call_args = [hamlet2, \"Second Hamlet\", None]\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\"}):\n            with mock.patch(\"zerver.lib.actions.do_change_full_name\") as f:\n                self.perform_ldap_sync(hamlet2)\n                f.assert_called_once_with(*expected_call_args)\n\n                # Get the updated model and make sure the full name is changed correctly:\n                hamlet2 = get_user_by_delivery_email(email, test_realm)\n                self.assertEqual(hamlet2.full_name, \"Second Hamlet\")\n                # Now get the original hamlet and make he still has his name unchanged:\n                hamlet = self.example_user(\"hamlet\")\n                self.assertEqual(hamlet.full_name, \"King Hamlet\")\n\n    def test_user_not_found_in_ldap(self) -> None:\n        with self.settings(\n            LDAP_DEACTIVATE_NON_MATCHING_USERS=False, LDAP_APPEND_DOMAIN=\"zulip.com\"\n        ):\n            othello = self.example_user(\"othello\")  # othello isn't in our test directory\n            mock_logger = mock.MagicMock()\n            result = sync_user_from_ldap(othello, mock_logger)\n            mock_logger.warning.assert_called_once_with(\n                \"Did not find %s in LDAP.\", othello.delivery_email\n            )\n            self.assertFalse(result)\n\n            do_deactivate_user(othello, acting_user=None)\n            mock_logger = mock.MagicMock()\n            result = sync_user_from_ldap(othello, mock_logger)\n            # In this case the logger shouldn't be used.\n            self.assertEqual(mock_logger.method_calls, [])\n            self.assertFalse(result)\n\n    def test_update_user_avatar(self) -> None:\n        # Hamlet has jpegPhoto set in our test directory by default.\n        with mock.patch(\"zerver.lib.upload.upload_avatar_image\") as fn, self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_called_once()\n            hamlet = self.example_user(\"hamlet\")\n            self.assertEqual(hamlet.avatar_source, UserProfile.AVATAR_FROM_USER)\n\n            # Verify that the next time we do an LDAP sync, we don't\n            # end up updating this user's avatar again if the LDAP\n            # data hasn't changed.\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_called_once()\n\n        # Now verify that if we do change the jpegPhoto image, we\n        # will upload a new avatar.\n        self.change_ldap_user_attr(\n            \"hamlet\", \"jpegPhoto\", static_path(\"images/logo/zulip-icon-512x512.png\"), binary=True\n        )\n        with mock.patch(\"zerver.lib.upload.upload_avatar_image\") as fn, self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_called_once()\n            hamlet = self.example_user(\"hamlet\")\n            self.assertEqual(hamlet.avatar_source, UserProfile.AVATAR_FROM_USER)\n\n    @use_s3_backend\n    def test_update_user_avatar_for_s3(self) -> None:\n        bucket = create_s3_buckets(settings.S3_AVATAR_BUCKET)[0]\n        test_image_data = read_test_image_file(\"img.png\")\n        self.change_ldap_user_attr(\"hamlet\", \"jpegPhoto\", test_image_data)\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n\n        hamlet = self.example_user(\"hamlet\")\n        path_id = user_avatar_path(hamlet)\n        original_image_path_id = path_id + \".original\"\n        medium_path_id = path_id + \"-medium.png\"\n\n        original_image_key = bucket.Object(original_image_path_id)\n        medium_image_key = bucket.Object(medium_path_id)\n\n        image_data = original_image_key.get()[\"Body\"].read()\n        self.assertEqual(image_data, test_image_data)\n\n        test_medium_image_data = resize_avatar(test_image_data, MEDIUM_AVATAR_SIZE)\n        medium_image_data = medium_image_key.get()[\"Body\"].read()\n        self.assertEqual(medium_image_data, test_medium_image_data)\n\n        # Try to use invalid data as the image:\n        self.change_ldap_user_attr(\"hamlet\", \"jpegPhoto\", b\"00\" + test_image_data)\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}):\n            with self.assertLogs(level=\"WARNING\") as m:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            self.assertEqual(\n                m.output,\n                [\n                    \"WARNING:root:Could not parse {} field for user {}\".format(\n                        \"jpegPhoto\", hamlet.id\n                    )\n                ],\n            )\n\n    def test_deactivate_non_matching_users(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\", LDAP_DEACTIVATE_NON_MATCHING_USERS=True):\n            # othello isn't in our test directory\n            result = sync_user_from_ldap(self.example_user(\"othello\"), mock.Mock())\n\n            self.assertTrue(result)\n            othello = self.example_user(\"othello\")\n            self.assertFalse(othello.is_active)\n\n    def test_update_custom_profile_field(self) -> None:\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__phone_number\": \"homePhone\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n            }\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        test_data = [\n            {\n                \"field_name\": \"Phone number\",\n                \"expected_value\": \"123456789\",\n            },\n            {\n                \"field_name\": \"Birthday\",\n                \"expected_value\": \"1900-09-08\",\n            },\n        ]\n        for test_case in test_data:\n            field = CustomProfileField.objects.get(realm=hamlet.realm, name=test_case[\"field_name\"])\n            field_value = CustomProfileFieldValue.objects.get(\n                user_profile=hamlet, field=field\n            ).value\n            self.assertEqual(field_value, test_case[\"expected_value\"])\n\n    def test_update_non_existent_profile_field(self) -> None:\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__non_existent\": \"homePhone\",\n            }\n        ):\n            with self.assertRaisesRegex(\n                ZulipLDAPException, \"Custom profile field with name non_existent not found\"\n            ), self.assertLogs(\"django_auth_ldap\", \"WARNING\") as warn_log:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            self.assertEqual(\n                warn_log.output,\n                [\n                    \"WARNING:django_auth_ldap:Custom profile field with name non_existent not found. while authenticating hamlet\"\n                ],\n            )\n\n    def test_update_custom_profile_field_invalid_data(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"birthDate\", \"9999\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n            }\n        ):\n            with self.assertRaisesRegex(\n                ZulipLDAPException, \"Invalid data for birthday field\"\n            ), self.assertLogs(\"django_auth_ldap\", \"WARNING\") as warn_log:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            self.assertEqual(\n                warn_log.output,\n                [\n                    \"WARNING:django_auth_ldap:Invalid data for birthday field: Birthday is not a date while authenticating hamlet\"\n                ],\n            )\n\n    def test_update_custom_profile_field_no_mapping(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        no_op_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Phone number\")\n        expected_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n            }\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n\n        actual_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n        self.assertEqual(actual_value, expected_value)\n\n    def test_update_custom_profile_field_no_update(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        phone_number_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Phone number\")\n        birthday_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Birthday\")\n        phone_number_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=phone_number_field\n        )\n        phone_number_field_value.value = \"123456789\"\n        phone_number_field_value.save(update_fields=[\"value\"])\n        expected_call_args = [\n            hamlet,\n            [\n                {\n                    \"id\": birthday_field.id,\n                    \"value\": \"1900-09-08\",\n                },\n            ],\n        ]\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n                \"custom_profile_field__phone_number\": \"homePhone\",\n            }\n        ):\n            with mock.patch(\"zproject.backends.do_update_user_custom_profile_data_if_changed\") as f:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n                f.assert_called_once_with(*expected_call_args)\n\n    def test_update_custom_profile_field_not_present_in_ldap(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        no_op_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Birthday\")\n        expected_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"nonExistentAttr\",\n            }\n        ), self.assertLogs(\"django_auth_ldap\", \"WARNING\") as warn_log:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n\n        actual_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n        self.assertEqual(actual_value, expected_value)\n        self.assertEqual(\n            warn_log.output,\n            [\n                \"WARNING:django_auth_ldap:uid=hamlet,ou=users,dc=zulip,dc=com does not have a value for the attribute nonExistentAttr\"\n            ],\n        )\n\n\nclass TestQueryLDAP(ZulipLDAPTestCase):\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",))\n    def test_ldap_not_configured(self) -> None:\n        values = query_ldap(self.example_email(\"hamlet\"))\n        self.assertEqual(values, [\"LDAP backend not configured on this server.\"])\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_user_not_present(self) -> None:\n        # othello doesn't have an entry in our test directory\n        values = query_ldap(self.example_email(\"othello\"))\n        self.assert_length(values, 1)\n        self.assertIn(\"No such user found\", values[0])\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_normal_query(self) -> None:\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"avatar\": \"jpegPhoto\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n                \"custom_profile_field__phone_number\": \"nonExistentAttr\",\n            }\n        ):\n            values = query_ldap(self.example_email(\"hamlet\"))\n        self.assert_length(values, 4)\n        self.assertIn(\"full_name: King Hamlet\", values)\n        self.assertIn(\"avatar: (An avatar image file)\", values)\n        self.assertIn(\"custom_profile_field__birthday: 1900-09-08\", values)\n        self.assertIn(\"custom_profile_field__phone_number: LDAP field not present\", values)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_query_email_attr(self) -> None:\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\"}, LDAP_EMAIL_ATTR=\"mail\"):\n            # This will look up the user by email in our test dictionary,\n            # should successfully find hamlet's LDAP entry.\n            values = query_ldap(self.example_email(\"hamlet\"))\n        self.assert_length(values, 2)\n        self.assertIn(\"full_name: King Hamlet\", values)\n        self.assertIn(\"email: hamlet@zulip.com\", values)\n\n\nclass TestZulipAuthMixin(ZulipTestCase):\n    def test_get_user(self) -> None:\n        backend = ZulipAuthMixin()\n        result = backend.get_user(11111)\n        self.assertIs(result, None)\n\n\nclass TestPasswordAuthEnabled(ZulipTestCase):\n    def test_password_auth_enabled_for_ldap(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",)):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertTrue(password_auth_enabled(realm))\n\n\nclass TestRequireEmailFormatUsernames(ZulipTestCase):\n    def test_require_email_format_usernames_for_ldap_with_append_domain(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_ldap_with_email_attr(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            LDAP_EMAIL_ATTR=\"email\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_only(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",)):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertTrue(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_email_attr(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.ZulipLDAPAuthBackend\",\n            ),\n            LDAP_EMAIL_ATTR=\"email\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_append_email(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.ZulipLDAPAuthBackend\",\n            ),\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n\nclass TestMaybeSendToRegistration(ZulipTestCase):\n    def test_sso_only_when_preregistration_user_does_not_exist(self) -> None:\n        rf = RequestFactory()\n        request = rf.get(\"/\")\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_homepage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form:\n            def is_valid(self) -> bool:\n                return True\n\n        with mock.patch(\"zerver.views.auth.HomepageForm\", return_value=Form()):\n            self.assertEqual(PreregistrationUser.objects.all().count(), 0)\n            result = maybe_send_to_registration(\n                request, self.example_email(\"hamlet\"), is_signup=True\n            )\n            self.assertEqual(result.status_code, 302)\n            confirmation = Confirmation.objects.all().first()\n            assert confirmation is not None\n            confirmation_key = confirmation.confirmation_key\n            self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n            self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        self.assert_in_response(f'value=\"{confirmation_key}\" name=\"key\"', result)\n\n    def test_sso_only_when_preregistration_user_exists(self) -> None:\n        rf = RequestFactory()\n        request = rf.get(\"/\")\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_homepage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form:\n            def is_valid(self) -> bool:\n                return True\n\n        email = self.example_email(\"hamlet\")\n        user = PreregistrationUser(email=email)\n        user.save()\n        create_confirmation_link(user, Confirmation.USER_REGISTRATION)\n\n        with mock.patch(\"zerver.views.auth.HomepageForm\", return_value=Form()):\n            self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n            result = maybe_send_to_registration(request, email, is_signup=True)\n            self.assertEqual(result.status_code, 302)\n            confirmation = Confirmation.objects.all().last()\n            assert confirmation is not None\n            confirmation_key = confirmation.confirmation_key\n            self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n            self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\n\nclass TestAdminSetBackends(ZulipTestCase):\n    def test_change_enabled_backends(self) -> None:\n        # Log in as admin\n        self.login(\"iago\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"authentication_methods\": orjson.dumps({\"Email\": False, \"Dev\": True}).decode()},\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"authentication_methods\": orjson.dumps({\"Email\": False, \"Dev\": True}).decode()},\n        )\n        self.assert_json_success(result)\n        realm = get_realm(\"zulip\")\n        self.assertFalse(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_disable_all_backends(self) -> None:\n        # Log in as admin\n        self.login(\"desdemona\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"authentication_methods\": orjson.dumps({\"Email\": False, \"Dev\": False}).decode()},\n        )\n        self.assert_json_error(result, \"At least one authentication method must be enabled.\")\n        realm = get_realm(\"zulip\")\n        self.assertTrue(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_supported_backends_only_updated(self) -> None:\n        # Log in as admin\n        self.login(\"desdemona\")\n        # Set some supported and unsupported backends\n        result = self.client_patch(\n            \"/json/realm\",\n            {\n                \"authentication_methods\": orjson.dumps(\n                    {\"Email\": False, \"Dev\": True, \"GitHub\": False}\n                ).decode()\n            },\n        )\n        self.assert_json_success(result)\n        realm = get_realm(\"zulip\")\n        # Check that unsupported backend is not enabled\n        self.assertFalse(github_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n        self.assertFalse(password_auth_enabled(realm))\n\n\nclass EmailValidatorTestCase(ZulipTestCase):\n    def test_valid_email(self) -> None:\n        validate_login_email(self.example_email(\"hamlet\"))\n\n    def test_invalid_email(self) -> None:\n        with self.assertRaises(JsonableError):\n            validate_login_email(\"hamlet\")\n\n    def test_validate_email(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n\n        realm = inviter.realm\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n        inviter.realm.refresh_from_db()\n        error = validate_email_is_valid(\n            \"fred+5555@zulip.com\",\n            get_realm_email_validator(realm),\n        )\n        self.assertIn(\"containing + are not allowed\", error)\n\n        cordelia_email = cordelia.delivery_email\n        errors = get_existing_user_errors(realm, {cordelia_email})\n        error, is_deactivated = errors[cordelia_email]\n        self.assertEqual(False, is_deactivated)\n        self.assertEqual(error, \"Already has an account.\")\n\n        change_user_is_active(cordelia, False)\n\n        errors = get_existing_user_errors(realm, {cordelia_email})\n        error, is_deactivated = errors[cordelia_email]\n        self.assertEqual(True, is_deactivated)\n        self.assertEqual(error, \"Account has been deactivated.\")\n\n        errors = get_existing_user_errors(realm, {\"fred-is-fine@zulip.com\"})\n        self.assertEqual(errors, {})\n\n\nclass LDAPBackendTest(ZulipTestCase):\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_non_existing_realm(self) -> None:\n        self.init_default_ldap_database()\n        user = self.example_user(\"hamlet\")\n\n        data = dict(\n            username=user.delivery_email,\n            password=initial_password(user.delivery_email),\n        )\n        error_type = ZulipLDAPAuthBackend.REALM_IS_NONE_ERROR\n        error = ZulipLDAPConfigurationError(\"Realm is None\", error_type)\n        with mock.patch(\n            \"zproject.backends.ZulipLDAPAuthBackend.get_or_build_user\", side_effect=error\n        ), mock.patch(\"django_auth_ldap.backend._LDAPUser._authenticate_user_dn\"), self.assertLogs(\n            \"django_auth_ldap\", \"WARNING\"\n        ) as warn_log:\n            response = self.client_post(\"/login/\", data)\n            self.assert_in_success_response(\n                [\"Configuration error\", \"You are trying to log in using LDAP without creating an\"],\n                response,\n            )\n        self.assertEqual(\n            warn_log.output,\n            [\"WARNING:django_auth_ldap:('Realm is None', 1) while authenticating hamlet\"],\n        )\n", "import datetime\nimport re\nimport time\nimport urllib\nfrom typing import Any, Dict, List, Optional, Sequence, Union\nfrom unittest.mock import MagicMock, patch\nfrom urllib.parse import urlencode\n\nimport orjson\nfrom django.conf import settings\nfrom django.contrib.auth.views import PasswordResetConfirmView\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse\nfrom django.test import Client, override_settings\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    create_confirmation_link,\n    get_object_from_key,\n    one_click_unsubscribe_link,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.context_processors import common_context\nfrom zerver.decorator import do_two_factor_login\nfrom zerver.forms import HomepageForm, check_subdomain_available\nfrom zerver.lib.actions import (\n    add_new_user_history,\n    change_user_is_active,\n    do_add_default_stream,\n    do_change_full_name,\n    do_change_realm_subdomain,\n    do_change_user_role,\n    do_create_default_stream_group,\n    do_create_multiuse_invite_link,\n    do_create_realm,\n    do_create_user,\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_set_realm_property,\n    do_set_realm_user_default_setting,\n    get_default_streams_for_realm,\n)\nfrom zerver.lib.email_notifications import enqueue_welcome_emails, followup_day2_email_delay\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import (\n    ascii_to_hex,\n    hex_to_ascii,\n    is_valid_otp,\n    otp_decrypt_api_key,\n    otp_encrypt_api_key,\n    xor_hex_strings,\n)\nfrom zerver.lib.name_restrictions import is_disposable_domain\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.send_email import (\n    EmailNotDeliveredException,\n    FromAddress,\n    deliver_scheduled_emails,\n    send_future_email,\n)\nfrom zerver.lib.stream_subscription import get_stream_subscriptions_for_user\nfrom zerver.lib.streams import create_stream_if_needed\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    avatar_disk_path,\n    cache_tries_captured,\n    find_key_by_email,\n    get_test_image_file,\n    load_subdomain_token,\n    message_stream_count,\n    most_recent_message,\n    most_recent_usermessage,\n    queries_captured,\n    reset_emails_in_zulip_realm,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    RealmAuditLog,\n    RealmUserDefault,\n    Recipient,\n    ScheduledEmail,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    flush_per_request_caches,\n    get_realm,\n    get_stream,\n    get_system_bot,\n    get_user,\n    get_user_by_delivery_email,\n)\nfrom zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\nfrom zerver.views.development.registration import confirmation_key\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zproject.backends import ExternalAuthDataDict, ExternalAuthResult\n\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_data(self) -> None:\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        name = user_profile.full_name\n        email = user_profile.delivery_email\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(user_profile=user_profile))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\"full_name\": name, \"email\": email, \"subdomain\": realm.subdomain, \"is_signup\": False},\n        )\n\n        data_dict = ExternalAuthDataDict(is_signup=True, multiuse_object_key=\"key\")\n        response = redirect_and_log_into_subdomain(\n            ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n        )\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": name,\n                \"email\": email,\n                \"subdomain\": realm.subdomain,\n                # the email has an account at the subdomain,\n                # so is_signup get overridden to False:\n                \"is_signup\": False,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n        data_dict = ExternalAuthDataDict(\n            email=self.nonreg_email(\"alice\"),\n            full_name=\"Alice\",\n            subdomain=realm.subdomain,\n            is_signup=True,\n            full_name_validated=True,\n            multiuse_object_key=\"key\",\n        )\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(data_dict=data_dict))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": \"Alice\",\n                \"email\": self.nonreg_email(\"alice\"),\n                \"full_name_validated\": True,\n                \"subdomain\": realm.subdomain,\n                \"is_signup\": True,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"deactivated\", result.url)\n\n    def test_redirection_for_active_realm(self) -> None:\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self) -> None:\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result.url)\n\n    def test_deactivation_notice_when_deactivated(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n        self.assertNotIn(\"It has moved to\", result.content.decode())\n\n    def test_deactivation_notice_when_deactivated_and_deactivated_redirect_is_set(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.deactivated_redirect = \"http://example.zulipchat.com\"\n        realm.save(update_fields=[\"deactivated\", \"deactivated_redirect\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://example.zulipchat.com\">http://example.zulipchat.com</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivation_notice_when_realm_subdomain_is_changed(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-subdomain-name\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-subdomain-name.testserver\">http://new-subdomain-name.testserver</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivated_redirect_field_of_placeholder_realms_are_modified_on_changing_subdomain_multiple_times(\n        self,\n    ) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name-1\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-1.testserver\">http://new-name-1.testserver</a>.',\n            result.content.decode(),\n        )\n\n        realm = get_realm(\"new-name-1\")\n        do_change_realm_subdomain(realm, \"new-name-2\", acting_user=None)\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-2.testserver\">http://new-name-2.testserver</a>.',\n            result.content.decode(),\n        )\n\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self) -> None:\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        realm = get_realm(\"zulip\")\n        stream = Stream.objects.get(realm=realm, name=\"Denmark\")\n        DefaultStream.objects.create(stream=stream, realm=realm)\n        # Make sure at least 3 messages are sent to Denmark and it's a default stream.\n        message_id = self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 1\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 2\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 3\")\n\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        )\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n\n        # Sent a message afterwards to trigger a race between message\n        # sending and `add_new_user_history`.\n        race_message_id = self.send_stream_message(\n            self.example_user(\"hamlet\"), streams[0].name, \"test\"\n        )\n\n        # Overwrite ONBOARDING_UNREAD_MESSAGES to 2\n        ONBOARDING_UNREAD_MESSAGES = 2\n        with patch(\"zerver.lib.actions.ONBOARDING_UNREAD_MESSAGES\", ONBOARDING_UNREAD_MESSAGES):\n            add_new_user_history(user_profile, streams)\n\n        # Our first message is in the user's history\n        self.assertTrue(\n            UserMessage.objects.filter(user_profile=user_profile, message_id=message_id).exists()\n        )\n        # The race message is in the user's history and marked unread.\n        self.assertTrue(\n            UserMessage.objects.filter(\n                user_profile=user_profile, message_id=race_message_id\n            ).exists()\n        )\n        self.assertFalse(\n            UserMessage.objects.get(\n                user_profile=user_profile, message_id=race_message_id\n            ).flags.read.is_set\n        )\n\n        # Verify that the ONBOARDING_UNREAD_MESSAGES latest messages\n        # that weren't the race message are marked as unread.\n        latest_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[0:ONBOARDING_UNREAD_MESSAGES]\n        )\n        self.assert_length(latest_messages, 2)\n        for msg in latest_messages:\n            self.assertFalse(msg.flags.read.is_set)\n\n        # Verify that older messages are correctly marked as read.\n        older_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[ONBOARDING_UNREAD_MESSAGES : ONBOARDING_UNREAD_MESSAGES + 1]\n        )\n        self.assertGreater(len(older_messages), 0)\n        for msg in older_messages:\n            self.assertTrue(msg.flags.read.is_set)\n\n    def test_auto_subbed_to_personals(self) -> None:\n        \"\"\"\n        Newly created users are auto-subbed to the ability to receive\n        personals.\n        \"\"\"\n        test_email = self.nonreg_email(\"test\")\n        self.register(test_email, \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        old_messages_count = message_stream_count(user_profile)\n        self.send_personal_message(user_profile, user_profile)\n        new_messages_count = message_stream_count(user_profile)\n        self.assertEqual(new_messages_count, old_messages_count + 1)\n\n        recipient = Recipient.objects.get(type_id=user_profile.id, type=Recipient.PERSONAL)\n        message = most_recent_message(user_profile)\n        self.assertEqual(message.recipient, recipient)\n\n        with patch(\"zerver.models.get_display_recipient\", return_value=\"recip\"):\n            self.assertEqual(\n                str(message),\n                \"<Message: recip /  / \"\n                \"<UserProfile: {} {}>>\".format(user_profile.email, user_profile.realm),\n            )\n\n            user_message = most_recent_usermessage(user_profile)\n            self.assertEqual(\n                str(user_message),\n                f\"<UserMessage: recip / {user_profile.email} ([])>\",\n            )\n\n\nclass InitialPasswordTest(ZulipTestCase):\n    def test_none_initial_password_salt(self) -> None:\n        with self.settings(INITIAL_PASSWORD_SALT=None):\n            self.assertIsNone(initial_password(\"test@test.com\"))\n\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def get_reset_mail_body(self, subdomain: str = \"zulip\") -> str:\n        from django.core.mail import outbox\n\n        [message] = outbox\n        self.assertEqual(self.email_envelope_from(message), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(message),\n            rf\"^Zulip Account Security <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\",\n        )\n        self.assertIn(f\"{subdomain}.testserver\", message.extra_headers[\"List-Id\"])\n\n        return message.body\n\n    def test_password_reset(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.delivery_email\n        old_password = initial_password(email)\n        assert old_password is not None\n\n        self.login_user(user)\n\n        # test password reset template\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assert_in_response(\"Reset your password\", result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(\n            email, url_pattern=settings.EXTERNAL_HOST + r\"(\\S\\S+)\"\n        )\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.endswith(f\"/{PasswordResetConfirmView.reset_url_token}/\"))\n\n        final_reset_url = result.url\n        result = self.client_get(final_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            # Verify weak passwords don't work.\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"easy\", \"new_password2\": \"easy\"}\n            )\n            self.assert_in_response(\"The password is too weak.\", result)\n\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"f657gdGGk9\", \"new_password2\": \"f657gdGGk9\"}\n            )\n            # password reset succeeded\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n            # log back in with new password\n            self.login_by_email(email, password=\"f657gdGGk9\")\n            user_profile = self.example_user(\"hamlet\")\n            self.assert_logged_in_user_id(user_profile.id)\n\n            # make sure old password no longer works\n            self.assert_login_failure(email, password=old_password)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_alias_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True, ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_domain_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_alias_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_domain_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(EXTERNAL_HOST=\"www.testserver.com\", ROOT_SUBDOMAIN_ALIASES=[]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_always_for_subdomains(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"lear.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    def test_password_reset_for_non_existent_user(self) -> None:\n        email = \"nonexisting@mars.com\"\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_password_reset_for_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_user(user_profile, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"has been deactivated\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"not have an account\", body)\n\n    def test_password_reset_with_deactivated_realm(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(m.output, [\"INFO:root:Realm is deactivated\"])\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(RATE_LIMITING=True)\n    def test_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        from django.core.mail import outbox\n\n        add_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 2)\n\n            # Too many password reset emails sent to the address, we won't send more.\n            with self.assertLogs(level=\"INFO\") as info_logs:\n                self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                info_logs.output,\n                [\n                    \"INFO:root:Too many password reset attempts for email hamlet@zulip.com from 127.0.0.1\"\n                ],\n            )\n            self.assert_length(outbox, 2)\n\n            # Resetting for a different address works though.\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 3)\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 4)\n\n        # After time, password reset emails can be sent again.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 6)\n\n        remove_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n\n    def test_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        body = self.get_reset_mail_body(\"zephyr\")\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\n            \"active accounts in the following organization(s).\\nhttp://zulip.testserver\", body\n        )\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_invalid_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\n            \"/accounts/password/reset/\", {\"email\": email}, subdomain=\"invalid\"\n        )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auth_only(self) -> None:\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                m.output,\n                [\n                    \"INFO:root:Password reset attempted for hamlet@zulip.com even though password auth is disabled.\"\n                ],\n            )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_and_email_auth(self) -> None:\n        \"\"\"If both email and LDAP auth backends are enabled, limit password\n        reset to users outside the LDAP domain\"\"\"\n        # If the domain matches, we don't generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            email = self.example_email(\"hamlet\")\n            with self.assertLogs(level=\"INFO\") as m:\n                result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n                self.assertEqual(\n                    m.output, [\"INFO:root:Password reset not allowed for user in LDAP domain\"]\n                )\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # If the domain doesn't match, we do generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"example.com\"):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n            result = self.client_get(result[\"Location\"])\n\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n    def test_redirect_endpoints(self) -> None:\n        \"\"\"\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        \"\"\"\n        result = self.client_get(\"/accounts/password/reset/done/\")\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get(\"/accounts/password/done/\")\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get(\"/accounts/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/accounts/home/\"], result)\n\n        result = self.client_get(\"/accounts/new/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/new/\"], result)\n\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        result = self.login_with_return(user_profile.delivery_email, \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_bad_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        password: Optional[str] = \"wrongpassword\"\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assert_in_success_response([user.delivery_email], result)\n        self.assert_logged_in_user_id(None)\n\n        # Parallel test to confirm that the right password works using the\n        # same login code, which verifies our failing test isn't broken\n        # for some other reason.\n        password = initial_password(user.delivery_email)\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user.id)\n\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def test_login_bad_password_rate_limiter(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n\n            # We're over the allowed limit, so the next attempt, even with the correct\n            # password, will get blocked.\n            result = self.login_with_return(email)\n            self.assert_in_success_response([\"Try again in 10 seconds\"], result)\n\n        # After time passes, we should be able to log in.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.login_with_return(email)\n            self.assert_logged_in_user_id(user_profile.id)\n\n        remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_login_with_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.login_with_return(self.example_email(\"hamlet\"), password)\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\n                \"Your password has been disabled because it is too weak.\", result\n            )\n            self.assert_logged_in_user_id(None)\n\n    def test_login_nonexistent_user(self) -> None:\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_wrong_subdomain(self) -> None:\n        email = self.mit_email(\"sipbtest\")\n        with self.assertLogs(level=\"WARNING\") as m:\n            result = self.login_with_return(email, \"xxx\")\n            self.assertEqual(\n                m.output,\n                [\n                    \"WARNING:root:User sipbtest@mit.edu attempted password login to wrong subdomain zulip\"\n                ],\n            )\n        self.assertEqual(result.status_code, 200)\n        expected_error = (\n            f\"Your Zulip account {email} is not a member of the \"\n            + \"organization associated with this subdomain.\"\n        )\n        self.assert_in_response(expected_error, result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_invalid_subdomain(self) -> None:\n        result = self.login_with_return(self.example_email(\"hamlet\"), \"xxx\", subdomain=\"invalid\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_register(self) -> None:\n        reset_emails_in_zulip_realm()\n\n        realm = get_realm(\"zulip\")\n        hamlet = self.example_user(\"hamlet\")\n        stream_names = [f\"stream_{i}\" for i in range(40)]\n        for stream_name in stream_names:\n            stream = self.make_stream(stream_name, realm=realm)\n            DefaultStream.objects.create(stream=stream, realm=realm)\n\n        # Make sure there's at least one recent message to be mark\n        # unread.  This prevents a bug where this test would start\n        # failing the test database was generated more than\n        # ONBOARDING_RECENT_TIMEDELTA ago.\n        self.subscribe(hamlet, \"stream_0\")\n        self.send_stream_message(\n            hamlet,\n            \"stream_0\",\n            topic_name=\"test topic\",\n            content=\"test message\",\n        )\n\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n\n        with queries_captured() as queries, cache_tries_captured() as cache_tries:\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 90)\n\n        # We can probably avoid a couple cache hits here, but there doesn't\n        # seem to be any O(N) behavior.  Some of the cache hits are related\n        # to sending messages, such as getting the welcome bot, looking up\n        # the alert words for a realm, etc.\n        self.assert_length(cache_tries, 21)\n\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post(\n            \"/accounts/home/\", {\"email\": self.nonreg_email(\"test\")}, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_register_with_invalid_email(self) -> None:\n        \"\"\"\n        If you try to register with invalid email, you get an invalid email\n        page\n        \"\"\"\n        invalid_email = \"foo\\x00bar\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": invalid_email}, subdomain=\"zulip\")\n\n        self.assertEqual(result.status_code, 200)\n        self.assertContains(result, \"Enter a valid email address\")\n\n    def test_register_deactivated_partway_through(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertNotIn(\"deactivated\", result.url)\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_login_deactivated_realm(self) -> None:\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n    def test_logout(self) -> None:\n        self.login(\"hamlet\")\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post(\"/accounts/logout/\")\n        self.assert_logged_in_user_id(None)\n\n    def test_non_ascii_login(self) -> None:\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        password = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.logout()\n        self.assert_logged_in_user_id(None)\n\n        # Logging in succeeds.\n        self.logout()\n        self.login_by_email(email, password)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=False)\n    def test_login_page_redirects_logged_in_user(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(\"cordelia\")\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_options_request_to_login_page(self) -> None:\n        response = self.client_options(\"/login/\")\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True)\n    def test_login_page_redirects_logged_in_user_under_2fa(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        self.create_default_device(user_profile)\n\n        self.login(\"cordelia\")\n        self.login_2fa(user_profile)\n\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_start_two_factor_auth(self) -> None:\n        request = MagicMock(POST={})\n        with patch(\"zerver.views.auth.TwoFactorLoginView\") as mock_view:\n            mock_view.as_view.return_value = lambda *a, **k: HttpResponse()\n            response = start_two_factor_auth(request)\n            self.assertTrue(isinstance(response, HttpResponse))\n\n    def test_do_two_factor_login(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        request = MagicMock()\n        with patch(\"zerver.decorator.django_otp.login\") as mock_login:\n            do_two_factor_login(request, user_profile)\n            mock_login.assert_called_once()\n\n    def test_zulip_default_context_does_not_load_inline_previews(self) -> None:\n        realm = get_realm(\"zulip\")\n        description = \"https://www.google.com/images/srpr/logo4w.png\"\n        realm.description = description\n        realm.save(update_fields=[\"description\"])\n        response = self.client_get(\"/login/\")\n        expected_response = \"\"\"<p><a href=\"https://www.google.com/images/srpr/logo4w.png\">\\\nhttps://www.google.com/images/srpr/logo4w.png</a></p>\"\"\"\n        self.assertEqual(response.context_data[\"realm_description\"], expected_response)\n        self.assertEqual(response.status_code, 200)\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str]) -> None:\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(outbox[0]), rf\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_days: Optional[int] = settings.INVITATION_LINK_VALIDITY_DAYS,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ) -> HttpResponse:\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = []\n        for stream_name in stream_names:\n            stream_ids.append(self.get_stream_id(stream_name))\n\n        invite_expires_in: Union[str, Optional[int]] = invite_expires_in_days\n        if invite_expires_in is None:\n            invite_expires_in = orjson.dumps(None).decode()\n\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_days\": invite_expires_in,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - datetime.timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        stream_name = \"Denmark\"\n\n        # These constants only need to be in descending order\n        # for this test to trigger an InvitationError based\n        # on max daily counts.\n        site_max = 50\n        realm_max = 40\n        num_invitees = 30\n        max_daily_count = 20\n\n        daily_counts = [(1, max_daily_count)]\n\n        invite_emails = [f\"foo-{i:02}@zulip.com\" for i in range(num_invitees)]\n        invitees = \",\".join(invite_emails)\n\n        self.login_user(user_profile)\n\n        realm.max_invites = realm_max\n        realm.date_created = timezone_now()\n        realm.save()\n\n        def try_invite() -> HttpResponse:\n            with self.settings(\n                OPEN_REALM_CREATION=True,\n                INVITES_DEFAULT_REALM_DAILY_MAX=site_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=daily_counts,\n            ):\n                result = self.invite(invitees, [stream_name])\n                return result\n\n        result = try_invite()\n        self.assert_json_error_contains(result, \"reached the limit\")\n\n        # Next show that aggregate limits expire once the realm is old\n        # enough.\n\n        realm.date_created = timezone_now() - datetime.timedelta(days=8)\n        realm.save()\n\n        with queries_captured() as queries:\n            with cache_tries_captured() as cache_tries:\n                result = try_invite()\n\n        self.assert_json_success(result)\n\n        # TODO: Fix large query count here.\n        #\n        # TODO: There is some test OTHER than this one\n        #       that is leaking some kind of state change\n        #       that throws off the query count here.  It\n        #       is hard to investigate currently (due to\n        #       the large number of queries), so I just\n        #       use an approximate equality check.\n        actual_count = len(queries)\n        expected_count = 251\n        if abs(actual_count - expected_count) > 1:\n            raise AssertionError(\n                f\"\"\"\n                Unexpected number of queries:\n\n                expected query count: {expected_count}\n                actual: {actual_count}\n                \"\"\"\n            )\n\n        # Almost all of these cache hits are to re-fetch each one of the\n        # invitees.  These happen inside our queue processor for sending\n        # confirmation emails, so they are somewhat difficult to avoid.\n        #\n        # TODO: Mock the call to queue_json_publish, so we can measure the\n        # queue impact separately from the user-perceived impact.\n        self.assert_length(cache_tries, 32)\n\n        # Next get line coverage on bumping a realm's max_invites.\n        realm.date_created = timezone_now()\n        realm.max_invites = site_max + 10\n        realm.save()\n\n        result = try_invite()\n        self.assert_json_success(result)\n\n        # Finally get coverage on the case that OPEN_REALM_CREATION is False.\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            result = self.invite(invitees, [stream_name])\n\n        self.assert_json_success(result)\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = \",\".join([cross_realm_bot_email, legit_new_email])\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            \"Some of those addresses are already using Zulip,\"\n            + \" so we didn't send them an invitation.\"\n            + \" We did send invitations to everyone else!\",\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_invite_from_now_deactivated_user(self) -> None:\n        \"\"\"\n        While accepting an invitation from a user,\n        processing for a new user account will only\n        be completed if the inviter is not deactivated\n        after sending the invite.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n        invitee = self.nonreg_email(\"alice\")\n\n        result = self.invite(invitee, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        change_user_is_active(inviter, False)\n        do_create_user(\n            invitee,\n            \"password\",\n            inviter.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Must be invited as an valid type of user\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_invite_others_to_realm()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        from django.core import mail\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - datetime.timedelta(\n            days=(realm.waiting_period_threshold - 1)\n        )\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"alice_zulip.com <`{invitee_profile.email}`> accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_invite_too_many_users(self) -> None:\n        # Only a light test of this pathway; e.g. doesn't test that\n        # the limit gets reset after 24 hours\n        self.login(\"iago\")\n        invitee_emails = \"1@zulip.com, 2@zulip.com\"\n        self.invite(invitee_emails, [\"Denmark\"])\n        invitee_emails = \", \".join(str(i) for i in range(get_realm(\"zulip\").max_invites - 1))\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"To protect users, Zulip limits the number of invitations you can send in one day. Because you have reached the limit, no invitations were sent.\",\n        )\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n        invitee_emails = \"foo@zulip.com\"\n        self.assert_json_error(\n            self.invite(invitee_emails, []),\n            \"You must specify at least one stream for invitees to join.\",\n        )\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        from django.core.mail import outbox\n\n        body = self.normalize_string(outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color:#5f5ec7; text-decoration:underline\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                lambda: PreregistrationUser.objects.get(email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = PreregistrationUser.objects.get(email=\"foo-test@zulip.com\")\n        self.assertEqual(prereg_user.email, \"foo-test@zulip.com\")\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with email addresses\", result)\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please sign up using a real email address.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"Zulip Dev, does not allow signups using emails\\n        that contains +\", result\n        )\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self) -> None:\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_days = 2\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_days=validity_in_days\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_days=4)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_days=3)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyException) as cm:\n            get_object_from_key(registration_key, [Confirmation.INVITATION])\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyException.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - datetime.timedelta(weeks=3)\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_never_expire_confirmation_obejct(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        activation_url = create_confirmation_link(\n            prereg_user, Confirmation.INVITATION, validity_in_days=None\n        )\n        confirmation = Confirmation.objects.last()\n        assert confirmation is not None\n        self.assertEqual(confirmation.expiry_date, None)\n        activation_key = activation_url.split(\"/\")[-1]\n        response = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": activation_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"},\n        )\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, self.user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_days=invite_expires_in_days\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_ACTIVE\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the link_expired page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], response)\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.url,\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response.url, \"http://zulip.testserver/\")\n\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"New members cannot join this organization because all Zulip licenses are\"], response\n        )\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_invites_controlled_by_user(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            hamlet, [\"TestThree@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            othello, [\"TestFour@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n        self.assert_length(do_get_invites_controlled_by_user(user_profile), 5)\n        self.assert_length(do_get_invites_controlled_by_user(hamlet), 1)\n        self.assert_length(do_get_invites_controlled_by_user(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_ACTIVE\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=invite_expires_in_days + 1),\n        ):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_days=invite_expires_in_days,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three, Confirmation.INVITATION, validity_in_days=invite_expires_in_days\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_get_never_expiring_invitations(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=1000),\n        ):\n            # Testing the invitation with expiry date set to \"None\" exists\n            # after a large amount of days.\n            do_invite_users(\n                user_profile,\n                [\"TestOne@zulip.com\"],\n                streams,\n                invite_expires_in_days=None,\n            )\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_days=100,\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], None\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], 100\n            )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        # We only get invitations that will never expire because we have mocked time such\n        # that the other invitations are created in the deep past.\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertEqual(invites[0][\"expiry_date\"], None)\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], user_profile.id)\n        self.assertEqual(invites[1][\"expiry_date\"], None)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        # Test deleting owner mutiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite_in_mit, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_resend_never_expiring_invitation(self) -> None:\n        self.login(\"iago\")\n        invitee = \"resend@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], None))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_ACTIVE)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime.datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_days = 2\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        validity_in_days = 2\n        date_sent = timezone_now() - datetime.timedelta(days=validity_in_days - 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - datetime.timedelta(\n            days=settings.INVITATION_LINK_VALIDITY_DAYS + 1\n        )\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps(stream_ids).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n    def test_only_admin_can_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n        # Only admins should be able to create multiuse invites even if\n        # invite_to_realm_policy is set to Realm.POLICY_MEMBERS_ONLY.\n        self.realm.invite_to_realm_policy = Realm.POLICY_MEMBERS_ONLY\n        self.realm.save()\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps([54321]).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_error(result, \"Invalid stream id 54321. No invites were sent.\")\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self) -> None:\n\n        # An invalid unsubscribe token \"test123\" produces an error.\n        result = self.client_get(\"/accounts/unsubscribe/missed_messages/test123\")\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user(\"hamlet\")\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n    def test_message_notification_emails_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in message notification emails\n        that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_digest_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {\n            \"name\": \"\",\n            \"realm_uri\": \"\",\n            \"unread_pms\": [],\n            \"hot_conversations\": [],\n            \"new_users\": [],\n            \"new_streams\": {\"plain\": []},\n            \"unsubscribe_link\": \"\",\n        }\n        send_future_email(\n            \"zerver/emails/digest\",\n            user_profile.realm,\n            to_user_ids=[user_profile.id],\n            context=context,\n        )\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_login_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in login\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_login_emails = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"login\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_login_emails)\n\n    def test_marketing_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in marketing e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n    def test_marketing_unsubscribe_post(self) -> None:\n        \"\"\"\n        The List-Unsubscribe-Post header lets email clients trigger an\n        automatic unsubscription request via POST (see RFC 8058), so\n        test that too.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        client = Client(enforce_csrf_checks=True)\n        result = client.post(\n            urllib.parse.urlparse(unsubscribe_link).path, {\"List-Unsubscribe\": \"One-Click\"}\n        )\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n\nclass RealmCreationTest(ZulipTestCase):\n    @override_settings(OPEN_REALM_CREATION=True)\n    def check_able_to_create_realm(self, email: str, password: str = \"test\") -> None:\n        internal_realm = get_realm(settings.SYSTEM_BOT_REALM)\n        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, internal_realm.id)\n        signups_stream, _ = create_stream_if_needed(notification_bot.realm, \"signups\")\n\n        string_id = \"zuliptest\"\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Check confirmation email has the correct subject and body, extract\n        # confirmation link and visit it\n        confirmation_url = self.get_confirmation_url_from_outbox(\n            email,\n            email_subject_contains=\"Create your Zulip organization\",\n            email_body_contains=\"You have requested a new Zulip organization\",\n        )\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://zuliptest.testserver/accounts/login/subdomain/\")\n        )\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n\n        # Check that user is the owner.\n        self.assertEqual(user.role, UserProfile.ROLE_REALM_OWNER)\n\n        # Check defaults\n        self.assertEqual(realm.org_type, Realm.ORG_TYPES[\"business\"][\"id\"])\n        self.assertEqual(realm.emails_restricted_to_domains, False)\n        self.assertEqual(realm.invite_required, True)\n\n        # Check welcome messages\n        for stream_name, text, message_count in [\n            (Realm.DEFAULT_NOTIFICATION_STREAM_NAME, \"with the topic\", 3),\n            (Realm.INITIAL_PRIVATE_STREAM_NAME, \"private stream\", 1),\n        ]:\n            stream = get_stream(stream_name, realm)\n            recipient = stream.recipient\n            messages = Message.objects.filter(recipient=recipient).order_by(\"date_sent\")\n            self.assert_length(messages, message_count)\n            self.assertIn(text, messages[0].content)\n\n        # Check signup messages\n        recipient = signups_stream.recipient\n        messages = Message.objects.filter(recipient=recipient).order_by(\"id\")\n        self.assert_length(messages, 2)\n        self.assertIn(\"Signups enabled\", messages[0].content)\n        self.assertIn(\"signed up\", messages[1].content)\n        self.assertEqual(\"zuliptest\", messages[1].topic_name())\n\n        realm_creation_audit_log = RealmAuditLog.objects.get(\n            realm=realm, event_type=RealmAuditLog.REALM_CREATED\n        )\n        self.assertEqual(realm_creation_audit_log.acting_user, user)\n        self.assertEqual(realm_creation_audit_log.event_time, realm.date_created)\n\n        # Piggyback a little check for how we handle\n        # empty string_ids.\n        realm.string_id = \"\"\n        self.assertEqual(realm.display_subdomain, \".\")\n\n    def test_create_realm_non_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"user1@test.com\")\n\n    def test_create_realm_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"hamlet@zulip.com\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_create_realm_ldap_email(self) -> None:\n        self.init_default_ldap_database()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.check_able_to_create_realm(\n                \"newuser_email@zulip.com\", self.ldap_password(\"newuser_with_email\")\n            )\n\n    def test_create_realm_as_system_bot(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"notification-bot@zulip.com\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"notification-bot@zulip.com is reserved for system bots\", result)\n\n    def test_create_realm_no_creation_key(self) -> None:\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post(\"/new/\", {\"email\": email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"New organization creation disabled\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_enabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertTrue(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True, CORPORATE_ENABLED=False)\n    def test_create_realm_without_prompting_for_marketing_emails(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Simulate the initial POST that is made by confirm-preregistration.js\n        # by triggering submit on confirm_preregistration.html.\n        payload = {\n            \"full_name\": \"\",\n            \"key\": find_key_by_email(email),\n            \"from_confirmation\": \"1\",\n        }\n        result = self.client_post(\"/accounts/register/\", payload)\n        # Assert that the form did not prompt the user for enabling\n        # marketing emails.\n        self.assert_not_in_success_response(['input id=\"id_enable_marketing_emails\"'], result)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_disabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_regular_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_demo_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n            is_demo_organization=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True, FREE_TRIAL_DAYS=30)\n    def test_create_realm_during_free_trial(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.url, \"http://zuliptest.testserver/upgrade/?onboarding=true\")\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assert_in_success_response([\"Not ready to start your trial?\"], result)\n\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_two_realms(self) -> None:\n        \"\"\"\n        Verify correct behavior and PreregistrationUser handling when using\n        two pre-generated realm creation links to create two different realms.\n        \"\"\"\n        password = \"test\"\n        first_string_id = \"zuliptest\"\n        second_string_id = \"zuliptest2\"\n        email = \"user1@test.com\"\n        first_realm_name = \"Test\"\n        second_realm_name = \"Test\"\n\n        # Make sure the realms do not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(first_string_id)\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(second_string_id)\n\n        # Now we pre-generate two realm creation links\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Get a second realm creation link.\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 2)\n\n        # Create and verify the first realm\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=first_string_id,\n            realm_name=first_realm_name,\n            key=first_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(first_string_id)\n        self.assertEqual(realm.string_id, first_string_id)\n        self.assertEqual(realm.name, first_realm_name)\n\n        # One of the PreregistrationUsers should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Create and verify the second realm\n        result = self.client_get(second_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=second_string_id,\n            realm_name=second_realm_name,\n            key=second_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(second_string_id)\n        self.assertEqual(realm.string_id, second_string_id)\n        self.assertEqual(realm.name, second_realm_name)\n\n        # The remaining PreregistrationUser should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 0)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"hi@mailinator.com\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {\n            \"id\": \"length 3 or greater\",\n            \"-id\": \"cannot start or end with a\",\n            \"string-ID\": \"lowercase letters\",\n            \"string_id\": \"lowercase letters\",\n            \"stream\": \"unavailable\",\n            \"streams\": \"unavailable\",\n            \"about\": \"unavailable\",\n            \"abouts\": \"unavailable\",\n            \"zephyr\": \"unavailable\",\n        }\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=string_id, realm_name=realm_name\n            )\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"a-0\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://a-0.testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_using_old_subdomain_of_a_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name\", acting_user=None)\n\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"zulip\", realm_name=realm_name\n        )\n        self.assert_in_response(\"Subdomain unavailable. Please choose a different one.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=\"\", realm_name=realm_name\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_subdomain=\"abcdef\",\n                realm_in_root_domain=\"true\",\n                realm_name=realm_name,\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=\"abcdef\",\n            realm_in_root_domain=\"true\",\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    def test_is_root_domain_available(self) -> None:\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\n    def test_subdomain_check_api(self) -> None:\n        result = self.client_get(\"/json/realm/subdomain/zulip\")\n        self.assert_in_success_response(\n            [\"Subdomain unavailable. Please choose a different one.\"], result\n        )\n\n        result = self.client_get(\"/json/realm/subdomain/zu_lip\")\n        self.assert_in_success_response(\n            [\"Subdomain can only have lowercase letters, numbers, and '-'s.\"], result\n        )\n\n        with self.settings(SOCIAL_AUTH_SUBDOMAIN=\"zulipauth\"):\n            result = self.client_get(\"/json/realm/subdomain/zulipauth\")\n            self.assert_in_success_response(\n                [\"Subdomain unavailable. Please choose a different one.\"], result\n            )\n\n        result = self.client_get(\"/json/realm/subdomain/hufflepuff\")\n        self.assert_in_success_response([\"available\"], result)\n        self.assert_not_in_success_response([\"unavailable\"], result)\n\n    def test_subdomain_check_management_command(self) -> None:\n        # Short names should not work, even with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\", allow_reserved_subdomain=True)\n\n        # Malformed names should never work\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\", allow_reserved_subdomain=True)\n\n        with patch(\"zerver.lib.name_restrictions.is_reserved_subdomain\", return_value=False):\n            # Existing realms should never work even if they are not reserved keywords\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\")\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\", allow_reserved_subdomain=True)\n\n        # Reserved ones should only work with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"stream\")\n        check_subdomain_available(\"stream\", allow_reserved_subdomain=True)\n\n\nclass UserSignUpTest(InviteUserBase):\n    def _assert_redirected_to(self, result: HttpResponse, url: str) -> None:\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"LOCATION\"], url)\n\n    def verify_signup(\n        self,\n        *,\n        email: str = \"newguy@zulip.com\",\n        password: Optional[str] = \"newpassword\",\n        full_name: str = \"New user's name\",\n        realm: Optional[Realm] = None,\n        subdomain: Optional[str] = None,\n    ) -> Union[UserProfile, HttpResponse]:\n        \"\"\"Common test function for signup tests.  It is a goal to use this\n        common function for all signup tests to avoid code duplication; doing\n        so will likely require adding new parameters.\"\"\"\n\n        if realm is None:  # nocoverage\n            realm = get_realm(\"zulip\")\n\n        client_kwargs: Dict[str, Any] = {}\n        if subdomain:\n            client_kwargs[\"subdomain\"] = subdomain\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, **client_kwargs)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], **client_kwargs)\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, **client_kwargs)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS. This should create our\n        # account, log us in, and redirect to the app.\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=full_name, **client_kwargs\n        )\n\n        if result.status_code == 200:\n            # This usually indicated an error returned when submitting the form.\n            # Return the result for the caller to deal with reacting to this, since\n            # in many tests this is expected and the caller wants to assert the content\n            # of the error.\n            return result\n\n        # Verify that we were served a redirect to the app.\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"{realm.uri}/\")\n\n        # Verify that we successfully logged in.\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        return user_profile\n\n    def test_bad_email_configuration_for_accounts_home(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/accounts/home/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in accounts_home\"])\n\n    def test_bad_email_configuration_for_create_realm(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/new/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in create_realm\"])\n\n    def test_user_default_language_and_timezone(self) -> None:\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        timezone = \"America/Denver\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_twenty_four_hour_time(self) -> None:\n        \"\"\"\n        Check if the default twenty_four_hour_time setting of new user\n        is the default twenty_four_hour_time of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        do_set_realm_user_default_setting(\n            realm_user_default, \"twenty_four_hour_time\", True, acting_user=None\n        )\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        self.assertEqual(\n            user_profile.twenty_four_hour_time, realm_user_default.twenty_four_hour_time\n        )\n\n    def test_signup_already_active(self) -> None:\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_system_bot(self) -> None:\n        email = \"notification-bot@zulip.com\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"lear\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n\n        # This is not really the right error message, but at least it's an error.\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_existing_email(self) -> None:\n        \"\"\"\n        Check if signing up with an email used in another realm succeeds.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        self.verify_signup(email=email, realm=get_realm(\"lear\"), subdomain=\"lear\")\n        self.assertEqual(UserProfile.objects.filter(delivery_email=email).count(), 2)\n\n    def test_signup_invalid_name(self) -> None:\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n\n        result = self.verify_signup(full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_without_password(self) -> None:\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n        email = self.nonreg_email(\"newuser\")\n        with patch(\"zerver.views.registration.password_auth_enabled\", return_value=False):\n            user_profile = self.verify_signup(email=email, password=None)\n\n        assert isinstance(user_profile, UserProfile)\n        # User should now be logged in.\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_signup_without_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n        result = self.verify_signup(email=email, password=password, full_name=\"\")\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_email_message_contains_org_header(self) -> None:\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        from django.core.mail import outbox\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def test_signup_with_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n    def test_signup_with_weak_password(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\n                    \"password\": \"easy\",\n                    \"key\": find_key_by_email(email),\n                    \"terms\": True,\n                    \"full_name\": \"New Guy\",\n                    \"from_confirmation\": \"1\",\n                },\n            )\n            self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n            result = self.submit_reg_form_for_user(email, \"easy\", full_name=\"New Guy\")\n            self.assert_in_success_response([\"The password is too weak.\"], result)\n            with self.assertRaises(UserProfile.DoesNotExist):\n                # Account wasn't created.\n                get_user(email, get_realm(\"zulip\"))\n\n    def test_signup_with_default_stream_group(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream group as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        default_streams = []\n\n        existing_default_streams = DefaultStream.objects.filter(realm=realm)\n        self.assert_length(existing_default_streams, 1)\n        self.assertEqual(existing_default_streams[0].stream.name, \"Verona\")\n        default_streams.append(existing_default_streams[0].stream)\n\n        for stream_name in [\"venice\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        result = self.submit_reg_form_for_user(email, password, default_stream_groups=[\"group 1\"])\n        self.check_user_subscribed_only_to_streams(\"newguy\", default_streams + group1_streams)\n\n    def test_signup_two_confirmation_links(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        first_confirmation_key = find_key_by_email(email)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        # Sanity check:\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n\n        # Register the account (this will use the second confirmation url):\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=\"New Guy\", from_confirmation=\"1\"\n        )\n        self.assert_in_success_response(\n            [\"We just need you to do one last thing.\", \"New Guy\", email], result\n        )\n        result = self.submit_reg_form_for_user(email, password, full_name=\"New Guy\")\n        user_profile = UserProfile.objects.get(delivery_email=email)\n        self.assertEqual(user_profile.delivery_email, email)\n\n        # Now try to to register using the first confirmation url:\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 404)\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": first_confirmation_key,\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        # Error page should be displayed\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_signup_with_multiple_default_stream_groups(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream groups as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        DefaultStream.objects.filter(realm=realm).delete()\n        default_streams = []\n        for stream_name in [\"venice\", \"verona\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        group2_streams = []\n        for stream_name in [\"scotland\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            group2_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 2\", \"group 2 description\", group2_streams)\n\n        result = self.submit_reg_form_for_user(\n            email, password, default_stream_groups=[\"group 1\", \"group 2\"]\n        )\n        self.check_user_subscribed_only_to_streams(\n            \"newguy\", list(set(default_streams + group1_streams + group2_streams))\n        )\n\n    def test_signup_without_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        realm = get_realm(\"lear\")\n\n        # Make an account in the Zulip realm, but we're not copying from there.\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email, password, source_realm_id=\"\", HTTP_HOST=subdomain + \".testserver\"\n        )\n\n        hamlet = get_user(self.example_email(\"hamlet\"), realm)\n        self.assertEqual(hamlet.left_side_userlist, False)\n        self.assertEqual(hamlet.default_language, \"en\")\n        self.assertEqual(hamlet.emojiset, \"google\")\n        self.assertEqual(hamlet.high_contrast_mode, False)\n        self.assertEqual(hamlet.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet.enter_sends, False)\n        self.assertEqual(hamlet.tutorial_status, UserProfile.TUTORIAL_WAITING)\n\n    def test_signup_with_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        lear_realm = get_realm(\"lear\")\n\n        self.login(\"hamlet\")\n        with get_test_image_file(\"img.png\") as image_file:\n            self.client_post(\"/json/users/me/avatar\", {\"file\": image_file})\n        hamlet_in_zulip.refresh_from_db()\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"password\": password, \"key\": find_key_by_email(email), \"from_confirmation\": \"1\"},\n            subdomain=subdomain,\n        )\n        self.assert_in_success_response(\n            [\n                \"Import settings from existing Zulip account\",\n                \"selected >\\n                            Zulip Dev\",\n                \"We just need you to do one last thing.\",\n            ],\n            result,\n        )\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            source_realm_id=str(hamlet_in_zulip.realm.id),\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n\n        hamlet_in_lear = get_user(email, lear_realm)\n        self.assertEqual(hamlet_in_lear.left_side_userlist, True)\n        self.assertEqual(hamlet_in_lear.default_language, \"de\")\n        self.assertEqual(hamlet_in_lear.emojiset, \"twitter\")\n        self.assertEqual(hamlet_in_lear.high_contrast_mode, True)\n        self.assertEqual(hamlet_in_lear.enter_sends, True)\n        self.assertEqual(hamlet_in_lear.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet_in_lear.tutorial_status, UserProfile.TUTORIAL_FINISHED)\n\n        zulip_path_id = avatar_disk_path(hamlet_in_zulip)\n        lear_path_id = avatar_disk_path(hamlet_in_lear)\n        with open(zulip_path_id, \"rb\") as f:\n            zulip_avatar_bits = f.read()\n        with open(lear_path_id, \"rb\") as f:\n            lear_avatar_bits = f.read()\n\n        self.assertGreater(len(zulip_avatar_bits), 500)\n        self.assertEqual(zulip_avatar_bits, lear_avatar_bits)\n\n    def test_signup_invalid_subdomain(self) -> None:\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs: Any) -> Any:\n            return_data = kwargs.get(\"return_data\", {})\n            return_data[\"invalid_subdomain\"] = True\n\n        with patch(\"zerver.views.registration.authenticate\", side_effect=invalid_subdomain):\n            with self.assertLogs(level=\"ERROR\") as m:\n                result = self.client_post(\n                    \"/accounts/register/\",\n                    {\n                        \"password\": password,\n                        \"full_name\": \"New User\",\n                        \"key\": find_key_by_email(email),\n                        \"terms\": True,\n                    },\n                )\n                self.assertEqual(\n                    m.output,\n                    [\"ERROR:root:Subdomain mismatch in registration zulip: newuser@zulip.com\"],\n                )\n        self.assertEqual(result.status_code, 302)\n\n    def test_signup_using_invalid_subdomain_preserves_state_of_form(self) -> None:\n        \"\"\"\n        Check that when we give invalid subdomain and submit the registration form\n        all the values in the form are preserved.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n\n        password = \"test\"\n        email = self.example_email(\"iago\")\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Subdomain is already used, by construction.\n            realm_subdomain=realm.string_id,\n            realm_name=realm_name,\n            source_realm_id=str(realm.id),\n        )\n        self.assert_in_success_response(\n            [\n                \"Subdomain unavailable. Please choose a different one.\",\n                \"Zulip Dev\\n\",\n                'value=\"test\"',\n                'name=\"realm_name\"',\n            ],\n            result,\n        )\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post(\"/accounts/home/\", {\"email\": email})\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": \"password\",\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New User\",\n                \"from_confirmation\": \"1\",\n            },\n            subdomain=\"zephyr\",\n        )\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link\", result)\n\n    def test_signup_to_realm_on_manual_license_plan(self) -> None:\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        realm.signup_notifications_stream = denmark_stream\n        realm.save(update_fields=[\"signup_notifications_stream\"])\n\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n            last_message = Message.objects.last()\n            assert last_message is not None\n            self.assertIn(\n                f\"A new member ({self.nonreg_email('test')}) was unable to join your organization because all Zulip\",\n                last_message.content,\n            )\n            self.assertEqual(last_message.recipient.type_id, denmark_stream.id)\n\n        ledger.licenses_at_next_renewal = 50\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n\n        ledger.licenses = 50\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertEqual(form.errors, {})\n\n    def test_failed_signup_due_to_restricted_domain(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"invite_required\", False, acting_user=None)\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            f\"Your email address, {email}, is not in one of the domains\", form.errors[\"email\"][0]\n        )\n\n    def test_failed_signup_due_to_disposable_email(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = False\n        realm.disallow_disposable_email_addresses = True\n        realm.save()\n\n        email = \"abc@mailnator.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\"Please use your real email address\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_email_containing_plus(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = True\n        realm.save()\n\n        email = \"iago+label@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            \"Email addresses containing + are not allowed in this organization.\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_failed_signup_due_to_invite_required(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n        email = \"user@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(f\"Please request an invite for {email} from\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self) -> None:\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=None)\n        self.assertIn(\n            f\"organization you are trying to join using {email} does not exist\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_access_signup_page_in_root_domain_without_realm(self) -> None:\n        result = self.client_get(\"/register\", subdomain=\"\", follow=True)\n        self.assert_in_success_response([\"Find your Zulip accounts\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is asked for its LDAP/Active Directory password.\n            self.assert_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            self.assert_not_in_success_response([\"id_password\"], result)\n\n            # Test the TypeError exception handler\n            with patch(\n                \"zproject.backends.ZulipLDAPAuthBackendBase.get_mapped_name\", side_effect=TypeError\n            ):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPUserPopulator\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_populate_only_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTH_LDAP_USER_DN_TEMPLATE=\"uid=%(user)s,ou=users,dc=zulip,dc=com\",\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is NOT asked for its LDAP/Active Directory password.\n            # LDAP is not configured for authentication in this test.\n            self.assert_not_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            # If we were using e.g. the SAML auth backend, there\n            # shouldn't be a password prompt, but since it uses the\n            # EmailAuthBackend, there should be password field here.\n            self.assert_in_success_response([\"id_password\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_end_to_end(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", full_name, \"newuser@zulip.com\"], result\n            )\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"wrongpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the correct password.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_split_full_name_mapping(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"first_name\": \"sn\", \"last_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser_splitname@zulip.com\"\n        password = self.ldap_password(\"newuser_splitname\")\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Test split name mapping.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, \"First Last\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auto_registration_on_login(self) -> None:\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n            \"custom_profile_field__phone_number\": \"homePhone\",\n        }\n        full_name = \"New LDAP fullname\"\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n            # Test custom profile fields are properly synced.\n            phone_number_field = CustomProfileField.objects.get(\n                realm=user_profile.realm, name=\"Phone number\"\n            )\n            phone_number_field_value = CustomProfileFieldValue.objects.get(\n                user_profile=user_profile, field=phone_number_field\n            )\n            self.assertEqual(phone_number_field_value.value, \"a-new-number\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auto_registration_on_login_invalid_email_in_directory(self) -> None:\n        password = self.ldap_password(\"newuser_with_email\")\n        username = \"newuser_with_email\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n\n        self.change_ldap_user_attr(\"newuser_with_email\", \"mail\", \"thisisnotavalidemail\")\n\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n        ), self.assertLogs(\"zulip.auth.ldap\", \"WARNING\") as mock_log:\n            original_user_count = UserProfile.objects.count()\n            self.login_with_return(username, password, HTTP_HOST=subdomain + \".testserver\")\n            # Verify that the process failed as intended - no UserProfile is created.\n            self.assertEqual(UserProfile.objects.count(), original_user_count)\n            self.assertEqual(\n                mock_log.output,\n                [\"WARNING:zulip.auth.ldap:thisisnotavalidemail is not a valid email address.\"],\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_registration_multiple_realms(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n        }\n        do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            subdomain = \"zulip\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"zulip\"))\n            self.logout()\n\n            # Test registration in another realm works.\n            subdomain = \"test\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"test\"))\n            self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_when_names_changes_are_disabled(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_append_domain(self) -> None:\n        password = \"nonldappassword\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # For the rest of the test we delete the user from ldap.\n        del self.mock_ldap.directory[\"uid=newuser,ou=users,dc=zulip,dc=com\"]\n\n        # If the user's email is not in the LDAP directory, but fits LDAP_APPEND_DOMAIN,\n        # we refuse to create the account.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because emails matching LDAP_APPEND_DOMAIN,\n            # aren't allowed to create non-LDAP accounts.\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: newuser. Input username: newuser@zulip.com\"\n                ],\n            )\n\n        # If the email is outside of LDAP_APPEND_DOMAIN, we successfully create a non-LDAP account,\n        # with the password managed in the Zulip database.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"example.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                m.output,\n                [\"WARNING:root:New account email newuser@zulip.com could not be found in LDAP\"],\n            )\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email newuser@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_email_search(self) -> None:\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        password = \"nonldappassword\"\n        email = \"newuser_email@zulip.com\"  # belongs to user uid=newuser_with_email in the test directory\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser_email%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # If the user's email is not in the LDAP directory , though, we\n        # successfully create an account with a password in the Zulip\n        # database.\n        password = \"nonldappassword\"\n        email = \"nonexistent@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assertEqual(\n                    m.output,\n                    [\n                        \"WARNING:root:New account email nonexistent@zulip.com could not be found in LDAP\"\n                    ],\n                )\n\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent@zulip.com. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    def ldap_invite_and_signup_as(\n        self, invite_as: int, streams: Sequence[str] = [\"Denmark\"]\n    ) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser@zulip.com\"\n        password = self.ldap_password(\"newuser\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                # Invite user.\n                self.login(\"iago\")\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: iago. Input username: iago@zulip.com\"\n                ],\n            )\n            response = self.invite(\n                invitee_emails=\"newuser@zulip.com\", stream_names=streams, invite_as=invite_as\n            )\n            self.assert_json_success(response)\n            self.logout()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_admin(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_guest(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_guest)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_streams(self) -> None:\n        stream_name = \"Rome\"\n        realm = get_realm(\"zulip\")\n        stream = get_stream(stream_name, realm)\n        default_streams = get_default_streams_for_realm(realm.id)\n        default_streams_name = [stream.name for stream in default_streams]\n        self.assertNotIn(stream_name, default_streams_name)\n\n        # Invite user.\n        self.ldap_invite_and_signup_as(\n            PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"], streams=[stream_name]\n        )\n\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n        sub = get_stream_subscriptions_for_user(user_profile).filter(recipient__type_id=stream.id)\n        self.assert_length(sub, 1)\n\n    def test_registration_when_name_changes_are_disabled(self) -> None:\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"New Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New Name\")\n\n    def test_realm_creation_through_ldap(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TERMS_OF_SERVICE_VERSION=1.0,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email)\n            confirmation = Confirmation.objects.get(confirmation_key=key)\n            prereg_user = confirmation.content_object\n            assert prereg_user is not None\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_name=realm_name,\n                realm_subdomain=subdomain,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_mirror_dummy_user(self, ignored: Any) -> None:\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, False)\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to\n        # submit the registration form should raise an AssertionError\n        # (this is an invalid state, so it's a bug we got here):\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /accounts/register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n        change_user_is_active(user_profile, False)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            from_confirmation=\"1\",\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_active_mirror_dummy_user(self, ignored: Any) -> None:\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should\n        raise an AssertionError.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration(self) -> None:\n        \"\"\"Verify that /devtools/register_user creates a new user, logs them\n        in, and redirects to the logged-in app.\"\"\"\n        count = UserProfile.objects.count()\n        email = f\"user-{count}@zulip.com\"\n\n        result = self.client_post(\"/devtools/register_user/\")\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(user_profile.delivery_email, email)\n        self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_realm(self) -> None:\n        count = UserProfile.objects.count()\n        string_id = f\"realm-{count}\"\n\n        result = self.client_post(\"/devtools/register_realm/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(f\"http://{string_id}.testserver/accounts/login/subdomain\")\n        )\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_demo_realm(self) -> None:\n        result = self.client_post(\"/devtools/register_demo_realm/\")\n        self.assertEqual(result.status_code, 302)\n\n        realm = Realm.objects.latest(\"date_created\")\n        self.assertTrue(\n            result[\"Location\"].startswith(\n                f\"http://{realm.string_id}.testserver/accounts/login/subdomain\"\n            )\n        )\n        result = self.client_get(result[\"Location\"], subdomain=realm.string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{realm.string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n        expected_deletion_date = realm.date_created + datetime.timedelta(\n            days=settings.DEMO_ORG_DEADLINE_DAYS\n        )\n        self.assertEqual(realm.demo_organization_scheduled_deletion_date, expected_deletion_date)\n\n\nclass DeactivateUserTest(ZulipTestCase):\n    def test_deactivate_user(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n        password = initial_password(email)\n        assert password is not None\n        self.assert_login_failure(email, password=password)\n\n    def test_do_not_deactivate_final_owner(self) -> None:\n        user = self.example_user(\"desdemona\")\n        user_2 = self.example_user(\"iago\")\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only organization owner.\")\n        user = self.example_user(\"desdemona\")\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_owner)\n        do_change_user_role(user_2, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        self.assertTrue(user_2.is_realm_owner)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        do_change_user_role(user, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n\n    def test_do_not_deactivate_final_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        for user_profile in UserProfile.objects.filter(realm=realm).exclude(\n            role=UserProfile.ROLE_REALM_OWNER\n        ):\n            do_deactivate_user(user_profile, acting_user=None)\n        user = self.example_user(\"desdemona\")\n        self.login_user(user)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only user.\")\n\n\nclass TestLoginPage(ZulipTestCase):\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_alias(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_domain(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n            ROOT_SUBDOMAIN_ALIASES=[\"test\"],\n        ):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_works_without_subdomains(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n    def test_login_page_registration_hint(self) -> None:\n        response = self.client_get(\"/login/\")\n        self.assert_not_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save(update_fields=[\"invite_required\"])\n        response = self.client_get(\"/login/\")\n        self.assert_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n    @patch(\"django.http.HttpRequest.get_host\", return_value=\"auth.testserver\")\n    def test_social_auth_subdomain_login_page(self, mock_get_host: MagicMock) -> None:\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n        zulip_realm = get_realm(\"zulip\")\n        session = self.client.session\n        session[\"subdomain\"] = \"zulip\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, zulip_realm.uri)\n\n        session = self.client.session\n        session[\"subdomain\"] = \"invalid\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n    def test_login_page_is_deactivated_validation(self) -> None:\n        with patch(\"zerver.views.auth.logging.info\") as mock_info:\n            result = self.client_get(\"/login/?is_deactivated=invalid_email\")\n            mock_info.assert_called_once()\n            self.assert_not_in_success_response([\"invalid_email\"], result)\n\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self) -> None:\n        result = self.client_get(\"/accounts/find/\")\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode())\n\n    def test_result(self) -> None:\n        # We capitalize a letter in cordelia's email to test that the search is case-insensitive.\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,cordeliA@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2CcordeliA%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(\"iago@zulip.com\", content)\n        self.assertIn(\"cordeliA@zulip.com\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 2)\n        iago_message = outbox[1]\n        cordelia_message = outbox[0]\n        self.assertIn(\"Zulip Dev\", iago_message.body)\n        self.assertNotIn(\"Lear & Co\", iago_message.body)\n        self.assertIn(\"Zulip Dev\", cordelia_message.body)\n        self.assertIn(\"Lear & Co\", cordelia_message.body)\n\n    def test_find_team_ignore_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,invalid_email@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_reject_invalid_email(self) -> None:\n        result = self.client_post(\"/accounts/find/\", dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get(\"/accounts/find/\", {\"emails\": \"invalid\"})\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self) -> None:\n        data = {\"emails\": \"\"}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertIn(\"This field is required\", result.content.decode())\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_one_email(self) -> None:\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_deactivated_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_deactivated_realm(self) -> None:\n        do_deactivate_realm(get_realm(\"zulip\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_bot_email(self) -> None:\n        data = {\"emails\": self.example_email(\"webhook_bot\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=webhook-bot%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_more_than_ten_emails(self) -> None:\n        data = {\"emails\": \",\".join(f\"hamlet-{i}@zulip.com\" for i in range(11))}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode())\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self) -> None:\n        request = MagicMock()\n        request.session = {\n            \"confirmation_key\": {\"confirmation_key\": \"xyzzy\"},\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response(\"xyzzy\", result)\n\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self) -> None:\n        self.assertEqual(xor_hex_strings(\"1237c81ab\", \"18989fd12\"), \"0aaf57cb9\")\n        with self.assertRaises(AssertionError):\n            xor_hex_strings(\"1\", \"31\")\n\n    def test_is_valid_otp(self) -> None:\n        self.assertEqual(is_valid_otp(\"1234\"), False)\n        self.assertEqual(is_valid_otp(\"1234abcd\" * 8), True)\n        self.assertEqual(is_valid_otp(\"1234abcZ\" * 8), False)\n\n    def test_ascii_to_hex(self) -> None:\n        self.assertEqual(ascii_to_hex(\"ZcdR1234\"), \"5a63645231323334\")\n        self.assertEqual(hex_to_ascii(\"5a63645231323334\"), \"ZcdR1234\")\n\n    def test_otp_encrypt_api_key(self) -> None:\n        api_key = \"12ac\" * 8\n        otp = \"7be38894\" * 8\n        result = otp_encrypt_api_key(api_key, otp)\n        self.assertEqual(result, \"4ad1e9f7\" * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, api_key)\n\n\nclass FollowupEmailTest(ZulipTestCase):\n    def test_followup_day2_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        # Test date_joined == Sunday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 7, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Tuesday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 2, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Thursday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 4, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n        # Test date_joined == Friday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=3, hours=-1)\n        )\n\n        # Time offset of America/Phoenix is -07:00\n        user_profile.timezone = \"America/Phoenix\"\n        # Test date_joined == Friday in UTC, but Thursday in the user's time zone\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n\n\nclass NoReplyEmailTest(ZulipTestCase):\n    def test_noreply_email_address(self) -> None:\n        self.assertTrue(\n            re.search(self.TOKENIZED_NOREPLY_REGEX, FromAddress.tokenized_no_reply_address())\n        )\n\n        with self.settings(ADD_TOKENS_TO_NOREPLY_ADDRESS=False):\n            self.assertEqual(FromAddress.tokenized_no_reply_address(), \"noreply@testserver\")\n\n\nclass TwoFactorAuthTest(ZulipTestCase):\n    @patch(\"two_factor.models.totp\")\n    def test_two_factor_login(self, mock_totp: MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n        ):\n\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_logs:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(\n                info_logs.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n            self.assertEqual(result.status_code, 200)\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to '/' if user is already\n            # logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass NameRestrictionsTest(ZulipTestCase):\n    def test_whitelisted_disposable_domains(self) -> None:\n        self.assertFalse(is_disposable_domain(\"OPayQ.com\"))\n\n\nclass RealmRedirectTest(ZulipTestCase):\n    def test_realm_redirect_without_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\")\n        self.assert_in_success_response([\"Enter your organization's Zulip URL\"], result)\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"zephyr\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"invalid\"})\n        self.assert_in_success_response([\"We couldn&#39;t find that Zulip organization.\"], result)\n\n    def test_realm_redirect_with_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\", {\"next\": \"billing\"})\n        self.assert_in_success_response(\n            [\"Enter your organization's Zulip URL\", 'action=\"/accounts/go/?next=billing\"'], result\n        )\n\n        result = self.client_post(\"/accounts/go/?next=billing\", {\"subdomain\": \"lear\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://lear.testserver/billing\")\n", "import logging\nimport secrets\nimport urllib\nfrom functools import wraps\nfrom typing import Any, Dict, List, Mapping, Optional, cast\nfrom urllib.parse import urlencode\n\nimport jwt\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth.views import LoginView as DjangoLoginView\nfrom django.contrib.auth.views import PasswordResetView as DjangoPasswordResetView\nfrom django.contrib.auth.views import logout_then_login as django_logout_then_login\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import validate_email\nfrom django.forms import Form\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect, HttpResponseServerError\nfrom django.shortcuts import redirect, render\nfrom django.template.response import SimpleTemplateResponse\nfrom django.urls import reverse\nfrom django.utils.html import escape\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.translation import gettext as _\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.http import require_safe\nfrom markupsafe import Markup as mark_safe\nfrom social_django.utils import load_backend, load_strategy\nfrom two_factor.forms import BackupTokenForm\nfrom two_factor.views import LoginView as BaseTwoFactorLoginView\n\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n)\nfrom version import API_FEATURE_LEVEL, ZULIP_MERGE_BASE, ZULIP_VERSION\nfrom zerver.context_processors import get_realm_from_request, login_context, zulip_default_context\nfrom zerver.decorator import do_login, log_view_func, process_client, require_post\nfrom zerver.forms import (\n    DEACTIVATED_ACCOUNT_ERROR,\n    AuthenticationTokenForm,\n    HomepageForm,\n    OurAuthenticationForm,\n    ZulipPasswordResetForm,\n)\nfrom zerver.lib.exceptions import (\n    AuthenticationFailedError,\n    InvalidSubdomainError,\n    JsonableError,\n    PasswordAuthDisabledError,\n    PasswordResetRequiredError,\n    RateLimited,\n    RealmDeactivatedError,\n    UserDeactivatedError,\n)\nfrom zerver.lib.mobile_auth_otp import otp_encrypt_api_key\nfrom zerver.lib.push_notifications import push_notifications_enabled\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.realm_icon import realm_icon_url\nfrom zerver.lib.request import REQ, RequestNotes, has_request_variables\nfrom zerver.lib.response import json_success\nfrom zerver.lib.sessions import set_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_subdomain_root_or_alias\nfrom zerver.lib.types import ViewFuncT\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.user_agent import parse_user_agent\nfrom zerver.lib.users import get_api_key\nfrom zerver.lib.utils import has_api_key_format\nfrom zerver.lib.validator import validate_login_email\nfrom zerver.models import (\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    UserProfile,\n    filter_to_valid_prereg_users,\n    get_realm,\n    remote_user_to_email,\n)\nfrom zerver.signals import email_on_new_login\nfrom zproject.backends import (\n    AUTH_BACKEND_NAME_MAP,\n    AppleAuthBackend,\n    ExternalAuthDataDict,\n    ExternalAuthResult,\n    GenericOpenIdConnectBackend,\n    SAMLAuthBackend,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPConfigurationError,\n    ZulipRemoteUserBackend,\n    auth_enabled_helper,\n    dev_auth_enabled,\n    ldap_auth_enabled,\n    password_auth_enabled,\n    saml_auth_enabled,\n    validate_otp_params,\n)\n\nExtraContext = Optional[Dict[str, Any]]\n\n\ndef get_safe_redirect_to(url: str, redirect_host: str) -> str:\n    is_url_safe = url_has_allowed_host_and_scheme(url=url, allowed_hosts=None)\n    if is_url_safe:\n        # Mark as safe to prevent Pysa from surfacing false positives for\n        # open redirects. In this branch, we have already checked that the URL\n        # points to the specified 'redirect_host', or is relative.\n        return urllib.parse.urljoin(redirect_host, mark_sanitized(url))\n    else:\n        return redirect_host\n\n\ndef create_preregistration_user(\n    email: str,\n    request: HttpRequest,\n    realm_creation: bool = False,\n    password_required: bool = True,\n    full_name: Optional[str] = None,\n    full_name_validated: bool = False,\n) -> PreregistrationUser:\n    realm = None\n    if not realm_creation:\n        try:\n            realm = get_realm(get_subdomain(request))\n        except Realm.DoesNotExist:\n            pass\n    return PreregistrationUser.objects.create(\n        email=email,\n        realm_creation=realm_creation,\n        password_required=password_required,\n        realm=realm,\n        full_name=full_name,\n        full_name_validated=full_name_validated,\n    )\n\n\ndef maybe_send_to_registration(\n    request: HttpRequest,\n    email: str,\n    full_name: str = \"\",\n    mobile_flow_otp: Optional[str] = None,\n    desktop_flow_otp: Optional[str] = None,\n    is_signup: bool = False,\n    password_required: bool = True,\n    multiuse_object_key: str = \"\",\n    full_name_validated: bool = False,\n) -> HttpResponse:\n    \"\"\"Given a successful authentication for an email address (i.e. we've\n    confirmed the user controls the email address) that does not\n    currently have a Zulip account in the target realm, send them to\n    the registration flow or the \"continue to registration\" flow,\n    depending on is_signup, whether the email address can join the\n    organization (checked in HomepageForm), and similar details.\n    \"\"\"\n\n    # In the desktop and mobile registration flows, the sign up\n    # happens in the browser so the user can use their\n    # already-logged-in social accounts.  Then at the end, with the\n    # user account created, we pass the appropriate data to the app\n    # via e.g. a `zulip://` redirect.  We store the OTP keys for the\n    # mobile/desktop flow in the session with 1-hour expiry, because\n    # we want this configuration of having a successful authentication\n    # result in being logged into the app to persist if the user makes\n    # mistakes while trying to authenticate (E.g. clicks the wrong\n    # Google account, hits back, etc.) during a given browser session,\n    # rather than just logging into the web app in the target browser.\n    #\n    # We can't use our usual pre-account-creation state storage\n    # approach of putting something in PreregistrationUser, because\n    # that would apply to future registration attempts on other\n    # devices, e.g. just creating an account on the web on their laptop.\n    assert not (mobile_flow_otp and desktop_flow_otp)\n    if mobile_flow_otp:\n        set_expirable_session_var(\n            request.session, \"registration_mobile_flow_otp\", mobile_flow_otp, expiry_seconds=3600\n        )\n    elif desktop_flow_otp:\n        set_expirable_session_var(\n            request.session, \"registration_desktop_flow_otp\", desktop_flow_otp, expiry_seconds=3600\n        )\n\n    multiuse_obj: Optional[MultiuseInvite] = None\n    realm: Optional[Realm] = None\n    from_multiuse_invite = False\n    if multiuse_object_key:\n        from_multiuse_invite = True\n        try:\n            multiuse_obj = get_object_from_key(multiuse_object_key, [Confirmation.MULTIUSE_INVITE])\n        except ConfirmationKeyException as exception:\n            return render_confirmation_key_error(request, exception)\n\n        assert multiuse_obj is not None\n        realm = multiuse_obj.realm\n        invited_as = multiuse_obj.invited_as\n    else:\n        try:\n            realm = get_realm(get_subdomain(request))\n        except Realm.DoesNotExist:\n            pass\n        invited_as = PreregistrationUser.INVITE_AS[\"MEMBER\"]\n\n    form = HomepageForm({\"email\": email}, realm=realm, from_multiuse_invite=from_multiuse_invite)\n    if form.is_valid():\n        # If the email address is allowed to sign up for an account in\n        # this organization, construct a PreregistrationUser and\n        # Confirmation objects, and then send the user to account\n        # creation or confirm-continue-registration depending on\n        # is_signup.\n        try:\n            prereg_user = filter_to_valid_prereg_users(\n                PreregistrationUser.objects.filter(email__iexact=email, realm=realm)\n            ).latest(\"invited_at\")\n\n            # password_required and full_name data passed here as argument should take precedence\n            # over the defaults with which the existing PreregistrationUser that we've just fetched\n            # was created.\n            prereg_user.password_required = password_required\n            update_fields = [\"password_required\"]\n            if full_name:\n                prereg_user.full_name = full_name\n                prereg_user.full_name_validated = full_name_validated\n                update_fields.extend([\"full_name\", \"full_name_validated\"])\n            prereg_user.save(update_fields=update_fields)\n        except PreregistrationUser.DoesNotExist:\n            prereg_user = create_preregistration_user(\n                email,\n                request,\n                password_required=password_required,\n                full_name=full_name,\n                full_name_validated=full_name_validated,\n            )\n\n        if multiuse_obj is not None:\n            request.session.modified = True\n            streams_to_subscribe = list(multiuse_obj.streams.all())\n            prereg_user.streams.set(streams_to_subscribe)\n            prereg_user.invited_as = invited_as\n            prereg_user.save()\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        if is_signup:\n            return redirect(confirmation_link)\n\n        context = {\"email\": email, \"continue_link\": confirmation_link, \"full_name\": full_name}\n        return render(request, \"zerver/confirm_continue_registration.html\", context=context)\n\n    # This email address it not allowed to join this organization, so\n    # just send the user back to the registration page.\n    url = reverse(\"register\")\n    context = login_context(request)\n    extra_context: Mapping[str, Any] = {\n        \"form\": form,\n        \"current_url\": lambda: url,\n        \"from_multiuse_invite\": from_multiuse_invite,\n        \"multiuse_object_key\": multiuse_object_key,\n        \"mobile_flow_otp\": mobile_flow_otp,\n        \"desktop_flow_otp\": desktop_flow_otp,\n    }\n    context.update(extra_context)\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef register_remote_user(request: HttpRequest, result: ExternalAuthResult) -> HttpResponse:\n    # We have verified the user controls an email address, but\n    # there's no associated Zulip user account.  Consider sending\n    # the request to registration.\n    kwargs: Dict[str, Any] = dict(result.data_dict)\n    # maybe_send_to_registration doesn't take these arguments, so delete them.\n    kwargs.pop(\"subdomain\", None)\n    kwargs.pop(\"redirect_to\", None)\n    kwargs.pop(\"is_realm_creation\", None)\n\n    kwargs[\"password_required\"] = False\n    return maybe_send_to_registration(request, **kwargs)\n\n\ndef login_or_register_remote_user(request: HttpRequest, result: ExternalAuthResult) -> HttpResponse:\n    \"\"\"Given a successful authentication showing the user controls given\n    email address (email) and potentially a UserProfile\n    object (if the user already has a Zulip account), redirect the\n    browser to the appropriate place:\n\n    * The logged-in app if the user already has a Zulip account and is\n      trying to log in, potentially to an initial narrow or page that had been\n      saved in the `redirect_to` parameter.\n    * The registration form if is_signup was set (i.e. the user is\n      trying to create a Zulip account)\n    * A special `confirm_continue_registration.html` \"do you want to\n      register or try another account\" if the user doesn't have a\n      Zulip account but is_signup is False (i.e. the user tried to log in\n      and then did social authentication selecting an email address that does\n      not have a Zulip account in this organization).\n    * A zulip:// URL to send control back to the mobile or desktop apps if they\n      are doing authentication using the mobile_flow_otp or desktop_flow_otp flow.\n    \"\"\"\n    user_profile = result.user_profile\n    if user_profile is None or user_profile.is_mirror_dummy:\n        return register_remote_user(request, result)\n    # Otherwise, the user has successfully authenticated to an\n    # account, and we need to do the right thing depending whether\n    # or not they're using the mobile OTP flow or want a browser session.\n    is_realm_creation = result.data_dict.get(\"is_realm_creation\")\n    mobile_flow_otp = result.data_dict.get(\"mobile_flow_otp\")\n    desktop_flow_otp = result.data_dict.get(\"desktop_flow_otp\")\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n\n    redirect_to = result.data_dict.get(\"redirect_to\", \"\")\n    if is_realm_creation is not None and settings.BILLING_ENABLED:\n        from corporate.lib.stripe import is_free_trial_offer_enabled\n\n        if is_free_trial_offer_enabled():\n            redirect_to = \"{}?onboarding=true\".format(reverse(\"initial_upgrade\"))\n\n    redirect_to = get_safe_redirect_to(redirect_to, user_profile.realm.uri)\n    return HttpResponseRedirect(redirect_to)\n\n\ndef finish_desktop_flow(request: HttpRequest, user_profile: UserProfile, otp: str) -> HttpResponse:\n    \"\"\"\n    The desktop otp flow returns to the app (through the clipboard)\n    a token that allows obtaining (through log_into_subdomain) a logged in session\n    for the user account we authenticated in this flow.\n    The token can only be used once and within ExternalAuthResult.LOGIN_KEY_EXPIRATION_SECONDS\n    of being created, as nothing more powerful is needed for the desktop flow\n    and this ensures the key can only be used for completing this authentication attempt.\n    \"\"\"\n    result = ExternalAuthResult(user_profile=user_profile)\n    token = result.store_data()\n    key = bytes.fromhex(otp)\n    iv = secrets.token_bytes(12)\n    desktop_data = (iv + AESGCM(key).encrypt(iv, token.encode(), b\"\")).hex()\n    context = {\n        \"desktop_data\": desktop_data,\n        \"browser_url\": reverse(\"login_page\", kwargs={\"template_name\": \"zerver/login.html\"}),\n        \"realm_icon_url\": realm_icon_url(user_profile.realm),\n    }\n    return render(request, \"zerver/desktop_redirect.html\", context=context)\n\n\ndef finish_mobile_flow(request: HttpRequest, user_profile: UserProfile, otp: str) -> HttpResponse:\n    # For the mobile OAuth flow, we send the API key and other\n    # necessary details in a redirect to a zulip:// URI scheme.\n    api_key = get_api_key(user_profile)\n    response = create_response_for_otp_flow(\n        api_key, otp, user_profile, encrypted_key_field_name=\"otp_encrypted_api_key\"\n    )\n\n    # Since we are returning an API key instead of going through\n    # the Django login() function (which creates a browser\n    # session, etc.), the \"new login\" signal handler (which\n    # triggers an email notification new logins) will not run\n    # automatically.  So we call it manually here.\n    #\n    # Arguably, sending a fake 'user_logged_in' signal would be a better approach:\n    #   user_logged_in.send(sender=user_profile.__class__, request=request, user=user_profile)\n    email_on_new_login(sender=user_profile.__class__, request=request, user=user_profile)\n\n    # Mark this request as having a logged-in user for our server logs.\n    process_client(request, user_profile)\n    RequestNotes.get_notes(request).requestor_for_logs = user_profile.format_requestor_for_logs()\n\n    return response\n\n\ndef create_response_for_otp_flow(\n    key: str, otp: str, user_profile: UserProfile, encrypted_key_field_name: str\n) -> HttpResponse:\n    realm_uri = user_profile.realm.uri\n\n    # Check if the mobile URI is overridden in settings, if so, replace it\n    # This block should only apply to the mobile flow, so we if add others, this\n    # needs to be conditional.\n    if realm_uri in settings.REALM_MOBILE_REMAP_URIS:\n        realm_uri = settings.REALM_MOBILE_REMAP_URIS[realm_uri]\n\n    params = {\n        encrypted_key_field_name: otp_encrypt_api_key(key, otp),\n        \"email\": user_profile.delivery_email,\n        \"user_id\": user_profile.id,\n        \"realm\": realm_uri,\n    }\n    # We can't use HttpResponseRedirect, since it only allows HTTP(S) URLs\n    response = HttpResponse(status=302)\n    response[\"Location\"] = append_url_query_string(\"zulip://login\", urllib.parse.urlencode(params))\n\n    return response\n\n\n@log_view_func\n@has_request_variables\ndef remote_user_sso(\n    request: HttpRequest,\n    mobile_flow_otp: Optional[str] = REQ(default=None),\n    desktop_flow_otp: Optional[str] = REQ(default=None),\n    next: str = REQ(default=\"/\"),\n) -> HttpResponse:\n    subdomain = get_subdomain(request)\n    try:\n        realm: Optional[Realm] = get_realm(subdomain)\n    except Realm.DoesNotExist:\n        realm = None\n\n    if not auth_enabled_helper([ZulipRemoteUserBackend.auth_backend_name], realm):\n        return config_error(request, \"remote_user_backend_disabled\")\n\n    try:\n        remote_user = request.META[\"REMOTE_USER\"]\n    except KeyError:\n        return config_error(request, \"remote_user_header_missing\")\n\n    # Django invokes authenticate methods by matching arguments, and this\n    # authentication flow will not invoke LDAP authentication because of\n    # this condition of Django so no need to check if LDAP backend is\n    # enabled.\n    validate_login_email(remote_user_to_email(remote_user))\n\n    # Here we support the mobile and desktop flow for REMOTE_USER_BACKEND; we\n    # validate the data format and then pass it through to\n    # login_or_register_remote_user if appropriate.\n    validate_otp_params(mobile_flow_otp, desktop_flow_otp)\n\n    if realm is None:\n        user_profile = None\n    else:\n        user_profile = authenticate(remote_user=remote_user, realm=realm)\n\n    email = remote_user_to_email(remote_user)\n    data_dict = ExternalAuthDataDict(\n        email=email,\n        mobile_flow_otp=mobile_flow_otp,\n        desktop_flow_otp=desktop_flow_otp,\n        redirect_to=next,\n    )\n    if realm:\n        data_dict[\"subdomain\"] = realm.subdomain\n    else:\n        data_dict[\"subdomain\"] = \"\"  # realm creation happens on root subdomain\n    result = ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n    return login_or_register_remote_user(request, result)\n\n\n@csrf_exempt\n@log_view_func\ndef remote_user_jwt(request: HttpRequest) -> HttpResponse:\n    subdomain = get_subdomain(request)\n    try:\n        key = settings.JWT_AUTH_KEYS[subdomain][\"key\"]\n        algorithms = settings.JWT_AUTH_KEYS[subdomain][\"algorithms\"]\n    except KeyError:\n        raise JsonableError(_(\"Auth key for this subdomain not found.\"))\n\n    try:\n        json_web_token = request.POST[\"json_web_token\"]\n        options = {\"verify_signature\": True}\n        payload = jwt.decode(json_web_token, key, algorithms=algorithms, options=options)\n    except KeyError:\n        raise JsonableError(_(\"No JSON web token passed in request\"))\n    except jwt.InvalidTokenError:\n        raise JsonableError(_(\"Bad JSON web token\"))\n\n    remote_user = payload.get(\"user\", None)\n    if remote_user is None:\n        raise JsonableError(_(\"No user specified in JSON web token claims\"))\n    email_domain = payload.get(\"realm\", None)\n    if email_domain is None:\n        raise JsonableError(_(\"No organization specified in JSON web token claims\"))\n\n    email = f\"{remote_user}@{email_domain}\"\n\n    try:\n        realm = get_realm(subdomain)\n    except Realm.DoesNotExist:\n        raise JsonableError(_(\"Wrong subdomain\"))\n\n    user_profile = authenticate(username=email, realm=realm, use_dummy_backend=True)\n    if user_profile is None:\n        result = ExternalAuthResult(\n            data_dict={\"email\": email, \"full_name\": remote_user, \"subdomain\": realm.subdomain}\n        )\n    else:\n        result = ExternalAuthResult(user_profile=user_profile)\n\n    return login_or_register_remote_user(request, result)\n\n\n@has_request_variables\ndef oauth_redirect_to_root(\n    request: HttpRequest,\n    url: str,\n    sso_type: str,\n    is_signup: bool = False,\n    extra_url_params: Dict[str, str] = {},\n    next: Optional[str] = REQ(default=None),\n    multiuse_object_key: str = REQ(default=\"\"),\n    mobile_flow_otp: Optional[str] = REQ(default=None),\n    desktop_flow_otp: Optional[str] = REQ(default=None),\n) -> HttpResponse:\n    main_site_uri = settings.ROOT_DOMAIN_URI + url\n    if settings.SOCIAL_AUTH_SUBDOMAIN is not None and sso_type == \"social\":\n        main_site_uri = (\n            settings.EXTERNAL_URI_SCHEME\n            + settings.SOCIAL_AUTH_SUBDOMAIN\n            + \".\"\n            + settings.EXTERNAL_HOST\n        ) + url\n\n    params = {\n        \"subdomain\": get_subdomain(request),\n        \"is_signup\": \"1\" if is_signup else \"0\",\n    }\n\n    params[\"multiuse_object_key\"] = multiuse_object_key\n\n    # mobile_flow_otp is a one-time pad provided by the app that we\n    # can use to encrypt the API key when passing back to the app.\n    validate_otp_params(mobile_flow_otp, desktop_flow_otp)\n    if mobile_flow_otp is not None:\n        params[\"mobile_flow_otp\"] = mobile_flow_otp\n    if desktop_flow_otp is not None:\n        params[\"desktop_flow_otp\"] = desktop_flow_otp\n\n    if next:\n        params[\"next\"] = next\n\n    params = {**params, **extra_url_params}\n\n    return redirect(append_url_query_string(main_site_uri, urllib.parse.urlencode(params)))\n\n\ndef handle_desktop_flow(func: ViewFuncT) -> ViewFuncT:\n    @wraps(func)\n    def wrapper(request: HttpRequest, *args: object, **kwargs: object) -> HttpResponse:\n        user_agent = parse_user_agent(request.META.get(\"HTTP_USER_AGENT\", \"Missing User-Agent\"))\n        if user_agent[\"name\"] == \"ZulipElectron\":\n            return render(request, \"zerver/desktop_login.html\")\n\n        return func(request, *args, **kwargs)\n\n    return cast(ViewFuncT, wrapper)  # https://github.com/python/mypy/issues/1927\n\n\n@handle_desktop_flow\ndef start_remote_user_sso(request: HttpRequest) -> HttpResponse:\n    \"\"\"\n    The purpose of this endpoint is to provide an initial step in the flow\n    on which we can handle the special behavior for the desktop app.\n    /accounts/login/sso may have Apache intercepting requests to it\n    to do authentication, so we need this additional endpoint.\n    \"\"\"\n    query = request.META[\"QUERY_STRING\"]\n    return redirect(append_url_query_string(reverse(remote_user_sso), query))\n\n\n@handle_desktop_flow\ndef start_social_login(\n    request: HttpRequest,\n    backend: str,\n    extra_arg: Optional[str] = None,\n) -> HttpResponse:\n    backend_url = reverse(\"social:begin\", args=[backend])\n    extra_url_params: Dict[str, str] = {}\n    if backend == \"saml\":\n        if not SAMLAuthBackend.check_config():\n            return config_error(request, \"saml\")\n\n        # This backend requires the name of the IdP (from the list of configured ones)\n        # to be passed as the parameter.\n        if not extra_arg or extra_arg not in settings.SOCIAL_AUTH_SAML_ENABLED_IDPS:\n            logging.info(\n                \"Attempted to initiate SAML authentication with wrong idp argument: %s\", extra_arg\n            )\n            return config_error(request, \"saml\")\n        extra_url_params = {\"idp\": extra_arg}\n\n    if backend == \"apple\" and not AppleAuthBackend.check_config():\n        return config_error(request, \"apple\")\n    if backend == \"oidc\" and not GenericOpenIdConnectBackend.check_config():\n        return config_error(request, \"oidc\")\n\n    # TODO: Add AzureAD also.\n    if backend in [\"github\", \"google\", \"gitlab\"]:\n        key_setting = \"SOCIAL_AUTH_\" + backend.upper() + \"_KEY\"\n        secret_setting = \"SOCIAL_AUTH_\" + backend.upper() + \"_SECRET\"\n        if not (getattr(settings, key_setting) and getattr(settings, secret_setting)):\n            return config_error(request, backend)\n\n    return oauth_redirect_to_root(request, backend_url, \"social\", extra_url_params=extra_url_params)\n\n\n@handle_desktop_flow\ndef start_social_signup(\n    request: HttpRequest,\n    backend: str,\n    extra_arg: Optional[str] = None,\n) -> HttpResponse:\n    backend_url = reverse(\"social:begin\", args=[backend])\n    extra_url_params: Dict[str, str] = {}\n    if backend == \"saml\":\n        if not SAMLAuthBackend.check_config():\n            return config_error(request, \"saml\")\n\n        if not extra_arg or extra_arg not in settings.SOCIAL_AUTH_SAML_ENABLED_IDPS:\n            logging.info(\n                \"Attempted to initiate SAML authentication with wrong idp argument: %s\", extra_arg\n            )\n            return config_error(request, \"saml\")\n        extra_url_params = {\"idp\": extra_arg}\n    return oauth_redirect_to_root(\n        request, backend_url, \"social\", is_signup=True, extra_url_params=extra_url_params\n    )\n\n\n_subdomain_token_salt = \"zerver.views.auth.log_into_subdomain\"\n\n\n@log_view_func\ndef log_into_subdomain(request: HttpRequest, token: str) -> HttpResponse:\n    \"\"\"Given a valid authentication token (generated by\n    redirect_and_log_into_subdomain called on auth.zulip.example.com),\n    call login_or_register_remote_user, passing all the authentication\n    result data that has been stored in Redis, associated with this token.\n    \"\"\"\n    # The tokens are intended to have the same format as API keys.\n    if not has_api_key_format(token):\n        logging.warning(\"log_into_subdomain: Malformed token given: %s\", token)\n        return HttpResponse(status=400)\n\n    try:\n        result = ExternalAuthResult(login_token=token)\n    except ExternalAuthResult.InvalidTokenError:\n        logging.warning(\"log_into_subdomain: Invalid token given: %s\", token)\n        return render(request, \"zerver/log_into_subdomain_token_invalid.html\", status=400)\n\n    subdomain = get_subdomain(request)\n    if result.data_dict[\"subdomain\"] != subdomain:\n        raise JsonableError(_(\"Invalid subdomain\"))\n\n    return login_or_register_remote_user(request, result)\n\n\ndef redirect_and_log_into_subdomain(result: ExternalAuthResult) -> HttpResponse:\n    token = result.store_data()\n    realm = get_realm(result.data_dict[\"subdomain\"])\n    subdomain_login_uri = realm.uri + reverse(log_into_subdomain, args=[token])\n    return redirect(subdomain_login_uri)\n\n\ndef redirect_to_misconfigured_ldap_notice(request: HttpRequest, error_type: int) -> HttpResponse:\n    if error_type == ZulipLDAPAuthBackend.REALM_IS_NONE_ERROR:\n        return config_error(request, \"ldap\")\n    else:\n        raise AssertionError(\"Invalid error type\")\n\n\ndef show_deactivation_notice(request: HttpRequest) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    if realm and realm.deactivated:\n        context = {\"deactivated_domain_name\": realm.name}\n        if realm.deactivated_redirect is not None:\n            context[\"deactivated_redirect\"] = realm.deactivated_redirect\n        return render(request, \"zerver/deactivated.html\", context=context)\n\n    return HttpResponseRedirect(reverse(\"login_page\"))\n\n\ndef redirect_to_deactivation_notice() -> HttpResponse:\n    return HttpResponseRedirect(reverse(show_deactivation_notice))\n\n\ndef update_login_page_context(request: HttpRequest, context: Dict[str, Any]) -> None:\n    for key in (\"email\", \"already_registered\"):\n        try:\n            context[key] = request.GET[key]\n        except KeyError:\n            pass\n\n    deactivated_email = request.GET.get(\"is_deactivated\")\n    if deactivated_email is None:\n        return\n    try:\n        validate_email(deactivated_email)\n        context[\"deactivated_account_error\"] = mark_safe(\n            DEACTIVATED_ACCOUNT_ERROR.format(username=escape(deactivated_email))\n        )\n    except ValidationError:\n        logging.info(\"Invalid email in is_deactivated param to login page: %s\", deactivated_email)\n\n\nclass TwoFactorLoginView(BaseTwoFactorLoginView):\n    extra_context: ExtraContext = None\n    form_list = (\n        (\"auth\", OurAuthenticationForm),\n        (\"token\", AuthenticationTokenForm),\n        (\"backup\", BackupTokenForm),\n    )\n\n    def __init__(self, extra_context: ExtraContext = None, *args: Any, **kwargs: Any) -> None:\n        self.extra_context = extra_context\n        super().__init__(*args, **kwargs)\n\n    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:\n        context = super().get_context_data(**kwargs)\n        if self.extra_context is not None:\n            context.update(self.extra_context)\n        update_login_page_context(self.request, context)\n\n        realm = get_realm_from_request(self.request)\n        redirect_to = realm.uri if realm else \"/\"\n        context[\"next\"] = self.request.POST.get(\n            \"next\",\n            self.request.GET.get(\"next\", redirect_to),\n        )\n        return context\n\n    def done(self, form_list: List[Form], **kwargs: Any) -> HttpResponse:\n        \"\"\"\n        Log in the user and redirect to the desired page.\n\n        We need to override this function so that we can redirect to\n        realm.uri instead of '/'.\n        \"\"\"\n        realm_uri = self.get_user().realm.uri\n        # This mock.patch business is an unpleasant hack that we'd\n        # ideally like to remove by instead patching the upstream\n        # module to support better configurability of the\n        # LOGIN_REDIRECT_URL setting.  But until then, it works.  We\n        # import mock.patch here because mock has an expensive import\n        # process involving pbr -> pkgresources (which is really slow).\n        from unittest.mock import patch\n\n        with patch.object(settings, \"LOGIN_REDIRECT_URL\", realm_uri):\n            return super().done(form_list, **kwargs)\n\n\n@has_request_variables\ndef login_page(\n    request: HttpRequest,\n    next: str = REQ(default=\"/\"),\n    **kwargs: Any,\n) -> HttpResponse:\n    if settings.SOCIAL_AUTH_SUBDOMAIN == get_subdomain(request):\n        return social_auth_subdomain_login_page(request)\n\n    # To support previewing the Zulip login pages, we have a special option\n    # that disables the default behavior of redirecting logged-in users to the\n    # logged-in app.\n    is_preview = \"preview\" in request.GET\n    if settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n        if request.user and request.user.is_verified():\n            return HttpResponseRedirect(request.user.realm.uri)\n    elif request.user.is_authenticated and not is_preview:\n        return HttpResponseRedirect(request.user.realm.uri)\n    if is_subdomain_root_or_alias(request) and settings.ROOT_DOMAIN_LANDING_PAGE:\n        redirect_url = reverse(\"realm_redirect\")\n        if request.GET:\n            redirect_url = append_url_query_string(redirect_url, request.GET.urlencode())\n        return HttpResponseRedirect(redirect_url)\n\n    realm = get_realm_from_request(request)\n    if realm and realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    extra_context = kwargs.pop(\"extra_context\", {})\n    extra_context[\"next\"] = next\n    if dev_auth_enabled() and kwargs.get(\"template_name\") == \"zerver/development/dev_login.html\":\n        from zerver.views.development.dev_login import add_dev_login_context\n\n        if \"new_realm\" in request.POST:\n            try:\n                realm = get_realm(request.POST[\"new_realm\"])\n            except Realm.DoesNotExist:\n                realm = None\n\n        add_dev_login_context(realm, extra_context)\n        if realm and \"new_realm\" in request.POST:\n            # If we're switching realms, redirect to that realm, but\n            # only if it actually exists.\n            return HttpResponseRedirect(realm.uri)\n\n    if \"username\" in request.POST:\n        extra_context[\"email\"] = request.POST[\"username\"]\n    extra_context.update(login_context(request))\n\n    if settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n        return start_two_factor_auth(request, extra_context=extra_context, **kwargs)\n\n    try:\n        template_response = DjangoLoginView.as_view(\n            authentication_form=OurAuthenticationForm, extra_context=extra_context, **kwargs\n        )(request)\n    except ZulipLDAPConfigurationError as e:\n        assert len(e.args) > 1\n        return redirect_to_misconfigured_ldap_notice(request, e.args[1])\n\n    if isinstance(template_response, SimpleTemplateResponse):\n        # Only those responses that are rendered using a template have\n        # context_data attribute. This attribute doesn't exist otherwise. It is\n        # added in SimpleTemplateResponse class, which is a derived class of\n        # HttpResponse. See django.template.response.SimpleTemplateResponse,\n        # https://github.com/django/django/blob/2.0/django/template/response.py#L19\n        update_login_page_context(request, template_response.context_data)\n\n    assert isinstance(template_response, HttpResponse)\n    return template_response\n\n\ndef social_auth_subdomain_login_page(request: HttpRequest) -> HttpResponse:\n    origin_subdomain = request.session.get(\"subdomain\")\n    if origin_subdomain is not None:\n        try:\n            origin_realm = get_realm(origin_subdomain)\n            return HttpResponseRedirect(origin_realm.uri)\n        except Realm.DoesNotExist:\n            pass\n\n    return render(request, \"zerver/auth_subdomain.html\", status=400)\n\n\ndef start_two_factor_auth(\n    request: HttpRequest, extra_context: ExtraContext = None, **kwargs: Any\n) -> HttpResponse:\n    two_fa_form_field = \"two_factor_login_view-current_step\"\n    if two_fa_form_field not in request.POST:\n        # Here we inject the 2FA step in the request context if it's missing to\n        # force the user to go to the first step of 2FA authentication process.\n        # This seems a bit hackish but simplifies things from testing point of\n        # view. I don't think this can result in anything bad because all the\n        # authentication logic runs after the auth step.\n        #\n        # If we don't do this, we will have to modify a lot of auth tests to\n        # insert this variable in the request.\n        request.POST = request.POST.copy()\n        request.POST.update({two_fa_form_field: \"auth\"})\n\n    \"\"\"\n    This is how Django implements as_view(), so extra_context will be passed\n    to the __init__ method of TwoFactorLoginView.\n\n    def as_view(cls, **initkwargs):\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            ...\n\n        return view\n    \"\"\"\n    two_fa_view = TwoFactorLoginView.as_view(extra_context=extra_context, **kwargs)\n    return two_fa_view(request, **kwargs)\n\n\n@csrf_exempt\n@require_post\n@has_request_variables\ndef api_fetch_api_key(\n    request: HttpRequest, username: str = REQ(), password: str = REQ()\n) -> HttpResponse:\n    return_data: Dict[str, bool] = {}\n\n    realm = get_realm_from_request(request)\n    if realm is None:\n        raise InvalidSubdomainError()\n\n    if not ldap_auth_enabled(realm=realm):\n        # In case we don't authenticate against LDAP, check for a valid\n        # email. LDAP backend can authenticate against a non-email.\n        validate_login_email(username)\n    user_profile = authenticate(\n        request=request, username=username, password=password, realm=realm, return_data=return_data\n    )\n    if return_data.get(\"inactive_user\"):\n        raise UserDeactivatedError()\n    if return_data.get(\"inactive_realm\"):\n        raise RealmDeactivatedError()\n    if return_data.get(\"password_auth_disabled\"):\n        raise PasswordAuthDisabledError()\n    if return_data.get(\"password_reset_needed\"):\n        raise PasswordResetRequiredError()\n    if user_profile is None:\n        raise AuthenticationFailedError()\n\n    assert user_profile.is_authenticated\n\n    # Maybe sending 'user_logged_in' signal is the better approach:\n    #   user_logged_in.send(sender=user_profile.__class__, request=request, user=user_profile)\n    # Not doing this only because over here we don't add the user information\n    # in the session. If the signal receiver assumes that we do then that\n    # would cause problems.\n    email_on_new_login(sender=user_profile.__class__, request=request, user=user_profile)\n\n    # Mark this request as having a logged-in user for our server logs.\n    process_client(request, user_profile)\n    RequestNotes.get_notes(request).requestor_for_logs = user_profile.format_requestor_for_logs()\n\n    api_key = get_api_key(user_profile)\n    return json_success(request, data={\"api_key\": api_key, \"email\": user_profile.delivery_email})\n\n\ndef get_auth_backends_data(request: HttpRequest) -> Dict[str, Any]:\n    \"\"\"Returns which authentication methods are enabled on the server\"\"\"\n    subdomain = get_subdomain(request)\n    try:\n        realm = Realm.objects.get(string_id=subdomain)\n    except Realm.DoesNotExist:\n        # If not the root subdomain, this is an error\n        if subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN:\n            raise JsonableError(_(\"Invalid subdomain\"))\n        # With the root subdomain, it's an error or not depending\n        # whether ROOT_DOMAIN_LANDING_PAGE (which indicates whether\n        # there are some realms without subdomains on this server)\n        # is set.\n        if settings.ROOT_DOMAIN_LANDING_PAGE:\n            raise JsonableError(_(\"Subdomain required\"))\n        else:\n            realm = None\n    result = {\n        \"password\": password_auth_enabled(realm),\n    }\n    for auth_backend_name in AUTH_BACKEND_NAME_MAP:\n        key = auth_backend_name.lower()\n        result[key] = auth_enabled_helper([auth_backend_name], realm)\n    return result\n\n\ndef check_server_incompatibility(request: HttpRequest) -> bool:\n    user_agent = parse_user_agent(request.META.get(\"HTTP_USER_AGENT\", \"Missing User-Agent\"))\n    return user_agent[\"name\"] == \"ZulipInvalid\"\n\n\n@require_safe\n@csrf_exempt\ndef api_get_server_settings(request: HttpRequest) -> HttpResponse:\n    # Log which client is making this request.\n    process_client(request, request.user, skip_update_user_activity=True)\n    result = dict(\n        authentication_methods=get_auth_backends_data(request),\n        zulip_version=ZULIP_VERSION,\n        zulip_merge_base=ZULIP_MERGE_BASE,\n        zulip_feature_level=API_FEATURE_LEVEL,\n        push_notifications_enabled=push_notifications_enabled(),\n        is_incompatible=check_server_incompatibility(request),\n    )\n    context = zulip_default_context(request)\n    context.update(login_context(request))\n    # IMPORTANT NOTE:\n    # realm_name, realm_icon, etc. are not guaranteed to appear in the response.\n    # * If they do, that means the server URL has only one realm on it\n    # * If they don't, the server has multiple realms, and it's not clear which is\n    #   the requested realm, so we can't send back these data.\n    for settings_item in [\n        \"email_auth_enabled\",\n        \"require_email_format_usernames\",\n        \"realm_uri\",\n        \"realm_name\",\n        \"realm_icon\",\n        \"realm_description\",\n        \"realm_web_public_access_enabled\",\n        \"external_authentication_methods\",\n    ]:\n        if context[settings_item] is not None:\n            result[settings_item] = context[settings_item]\n    return json_success(request, data=result)\n\n\n@has_request_variables\ndef json_fetch_api_key(\n    request: HttpRequest, user_profile: UserProfile, password: str = REQ(default=\"\")\n) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    if realm is None:\n        raise JsonableError(_(\"Invalid subdomain\"))\n    if password_auth_enabled(user_profile.realm):\n        if not authenticate(\n            request=request, username=user_profile.delivery_email, password=password, realm=realm\n        ):\n            raise JsonableError(_(\"Password is incorrect.\"))\n\n    api_key = get_api_key(user_profile)\n    return json_success(request, data={\"api_key\": api_key, \"email\": user_profile.delivery_email})\n\n\nlogout_then_login = require_post(django_logout_then_login)\n\n\ndef password_reset(request: HttpRequest) -> HttpResponse:\n    if is_subdomain_root_or_alias(request) and settings.ROOT_DOMAIN_LANDING_PAGE:\n        redirect_url = append_url_query_string(\n            reverse(\"realm_redirect\"), urlencode({\"next\": reverse(\"password_reset\")})\n        )\n        return HttpResponseRedirect(redirect_url)\n\n    try:\n        response = DjangoPasswordResetView.as_view(\n            template_name=\"zerver/reset.html\",\n            form_class=ZulipPasswordResetForm,\n            success_url=\"/accounts/password/reset/done/\",\n        )(request)\n    except RateLimited as e:\n        assert e.secs_to_freedom is not None\n        return render(\n            request,\n            \"zerver/rate_limit_exceeded.html\",\n            context={\"retry_after\": int(e.secs_to_freedom)},\n            status=429,\n        )\n    assert isinstance(response, HttpResponse)\n    return response\n\n\n@csrf_exempt\ndef saml_sp_metadata(request: HttpRequest) -> HttpResponse:  # nocoverage\n    \"\"\"\n    This is the view function for generating our SP metadata\n    for SAML authentication. It's meant for helping check the correctness\n    of the configuration when setting up SAML, or for obtaining the XML metadata\n    if the IdP requires it.\n    Taken from https://python-social-auth.readthedocs.io/en/latest/backends/saml.html\n    \"\"\"\n    if not saml_auth_enabled():\n        return config_error(request, \"saml\")\n\n    complete_url = reverse(\"social:complete\", args=(\"saml\",))\n    saml_backend = load_backend(load_strategy(request), \"saml\", complete_url)\n    metadata, errors = saml_backend.generate_metadata_xml()\n    if not errors:\n        return HttpResponse(content=metadata, content_type=\"text/xml\")\n\n    return HttpResponseServerError(content=\", \".join(errors))\n\n\ndef config_error(request: HttpRequest, error_category_name: str) -> HttpResponse:\n    contexts = {\n        \"apple\": {\"social_backend_name\": \"apple\", \"has_markdown_file\": True},\n        \"google\": {\"social_backend_name\": \"google\", \"has_markdown_file\": True},\n        \"github\": {\"social_backend_name\": \"github\", \"has_markdown_file\": True},\n        \"gitlab\": {\"social_backend_name\": \"gitlab\", \"has_markdown_file\": True},\n        \"ldap\": {\"error_name\": \"ldap_error_realm_is_none\"},\n        \"dev\": {\"error_name\": \"dev_not_supported_error\"},\n        \"saml\": {\"social_backend_name\": \"saml\"},\n        \"smtp\": {\"error_name\": \"smtp_error\"},\n        \"remote_user_backend_disabled\": {\"error_name\": \"remoteuser_error_backend_disabled\"},\n        \"remote_user_header_missing\": {\"error_name\": \"remoteuser_error_remote_user_header_missing\"},\n        # TODO: Improve the config error page for OIDC.\n        \"oidc\": {\"error_name\": \"oidc_error\"},\n    }\n\n    return render(request, \"zerver/config_error.html\", contexts[error_category_name])\n", "import logging\nimport urllib\nfrom typing import Any, Dict, List, Optional\nfrom urllib.parse import urlencode\n\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.core import validators\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    RealmCreationKey,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n    validate_key,\n)\nfrom zerver.context_processors import get_realm_from_request, login_context\nfrom zerver.decorator import do_login, rate_limit_request_by_ip, require_post\nfrom zerver.forms import (\n    FindMyTeamForm,\n    HomepageForm,\n    RealmCreationForm,\n    RealmRedirectForm,\n    RegistrationForm,\n)\nfrom zerver.lib.actions import (\n    bulk_add_subscriptions,\n    do_activate_mirror_dummy_user,\n    do_change_full_name,\n    do_change_password,\n    do_change_user_setting,\n    do_create_realm,\n    do_create_user,\n    lookup_default_stream_groups,\n)\nfrom zerver.lib.email_validation import email_allowed_for_realm, validate_email_not_already_in_realm\nfrom zerver.lib.exceptions import RateLimited\nfrom zerver.lib.onboarding import send_initial_realm_messages, setup_realm_internal_bots\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.send_email import EmailNotDeliveredException, FromAddress, send_email\nfrom zerver.lib.sessions import get_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import get_accounts_for_email\nfrom zerver.lib.validator import to_converted_or_fallback, to_non_negative_int, to_timezone_or_empty\nfrom zerver.lib.zephyr import compute_mit_user_fullname\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    Stream,\n    UserProfile,\n    get_default_stream_groups,\n    get_realm,\n    get_source_profile,\n    get_user_by_delivery_email,\n    name_changes_disabled,\n)\nfrom zerver.views.auth import (\n    create_preregistration_user,\n    finish_desktop_flow,\n    finish_mobile_flow,\n    get_safe_redirect_to,\n    redirect_and_log_into_subdomain,\n    redirect_to_deactivation_notice,\n)\nfrom zproject.backends import (\n    ExternalAuthResult,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPExceptionNoMatchingLDAPUser,\n    email_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    ldap_auth_enabled,\n    password_auth_enabled,\n)\n\nif settings.BILLING_ENABLED:\n    from corporate.lib.registration import check_spare_licenses_available_for_registering_new_user\n    from corporate.lib.stripe import LicenseLimitError\n\n\n@has_request_variables\ndef get_prereg_key_and_redirect(\n    request: HttpRequest, confirmation_key: str, full_name: Optional[str] = REQ(default=None)\n) -> HttpResponse:\n    \"\"\"\n    The purpose of this little endpoint is primarily to take a GET\n    request to a long URL containing a confirmation key, and render\n    a page that will via JavaScript immediately do a POST request to\n    /accounts/register, so that the user can create their account on\n    a page with a cleaner URL (and with the browser security and UX\n    benefits of an HTTP POST having generated the page).\n\n    The only thing it does before rendering that page is to check\n    the validity of the confirmation link. This is redundant with a\n    similar check in accounts_register, but it provides a slightly nicer\n    user-facing error handling experience if the URL you visited is\n    displayed in the browser. (E.g. you can debug that you\n    accidentally adding an extra character after pasting).\n    \"\"\"\n    try:\n        check_prereg_key(request, confirmation_key)\n    except ConfirmationKeyException as e:\n        return render_confirmation_key_error(request, e)\n\n    return render(\n        request,\n        \"confirmation/confirm_preregistrationuser.html\",\n        context={\"key\": confirmation_key, \"full_name\": full_name},\n    )\n\n\ndef check_prereg_key(request: HttpRequest, confirmation_key: str) -> PreregistrationUser:\n    \"\"\"\n    Checks if the Confirmation key is valid, returning the PreregistrationUser object in case of success\n    and raising an appropriate ConfirmationKeyException otherwise.\n    \"\"\"\n    confirmation_types = [\n        Confirmation.USER_REGISTRATION,\n        Confirmation.INVITATION,\n        Confirmation.REALM_CREATION,\n    ]\n\n    prereg_user = get_object_from_key(confirmation_key, confirmation_types, activate_object=False)\n\n    if prereg_user.status == confirmation_settings.STATUS_REVOKED:\n        raise ConfirmationKeyException(ConfirmationKeyException.EXPIRED)\n\n    return prereg_user\n\n\n@require_post\n@has_request_variables\ndef accounts_register(\n    request: HttpRequest,\n    key: str = REQ(default=\"\"),\n    timezone: str = REQ(default=\"\", converter=to_timezone_or_empty),\n    from_confirmation: Optional[str] = REQ(default=None),\n    form_full_name: Optional[str] = REQ(\"full_name\", default=None),\n    source_realm_id: Optional[int] = REQ(\n        default=None, converter=to_converted_or_fallback(to_non_negative_int, None)\n    ),\n) -> HttpResponse:\n    try:\n        prereg_user = check_prereg_key(request, key)\n    except ConfirmationKeyException as e:\n        return render_confirmation_key_error(request, e)\n\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    role = prereg_user.invited_as\n    if realm_creation:\n        role = UserProfile.ROLE_REALM_OWNER\n\n    try:\n        validators.validate_email(email)\n    except ValidationError:\n        return render(request, \"zerver/invalid_email.html\", context={\"invalid_email\": True})\n\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        assert prereg_user.realm is not None\n        if get_subdomain(request) != prereg_user.realm.string_id:\n            return render_confirmation_key_error(\n                request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n            )\n        realm = prereg_user.realm\n        try:\n            email_allowed_for_realm(email, realm)\n        except DomainNotAllowedForRealmError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"closed_domain\": True},\n            )\n        except DisposableEmailError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"disposable_emails_not_allowed\": True},\n            )\n        except EmailContainsPlusError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"email_contains_plus\": True},\n            )\n\n        if realm.deactivated:\n            # The user is trying to register for a deactivated realm. Advise them to\n            # contact support.\n            return redirect_to_deactivation_notice()\n\n        try:\n            validate_email_not_already_in_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n\n        if settings.BILLING_ENABLED:\n            try:\n                check_spare_licenses_available_for_registering_new_user(realm, email)\n            except LicenseLimitError:\n                return render(request, \"zerver/no_spare_licenses.html\")\n\n    name_validated = False\n    require_ldap_password = False\n\n    if from_confirmation:\n        try:\n            del request.session[\"authenticated_full_name\"]\n        except KeyError:\n            pass\n\n        ldap_full_name = None\n        if settings.POPULATE_PROFILE_VIA_LDAP:\n            # If the user can be found in LDAP, we'll take the full name from the directory,\n            # and further down create a form pre-filled with it.\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    try:\n                        ldap_username = backend.django_to_ldap_username(email)\n                    except ZulipLDAPExceptionNoMatchingLDAPUser:\n                        logging.warning(\"New account email %s could not be found in LDAP\", email)\n                        break\n\n                    # Note that this `ldap_user` object is not a\n                    # `ZulipLDAPUser` with a `Realm` attached, so\n                    # calling `.populate_user()` on it will crash.\n                    # This is OK, since we're just accessing this user\n                    # to extract its name.\n                    #\n                    # TODO: We should potentially be accessing this\n                    # user to sync its initial avatar and custom\n                    # profile fields as well, if we indeed end up\n                    # creating a user account through this flow,\n                    # rather than waiting until `manage.py\n                    # sync_ldap_user_data` runs to populate it.\n                    ldap_user = _LDAPUser(backend, ldap_username)\n\n                    try:\n                        ldap_full_name = backend.get_mapped_name(ldap_user)\n                    except TypeError:\n                        break\n\n                    # Check whether this is ZulipLDAPAuthBackend,\n                    # which is responsible for authentication and\n                    # requires that LDAP accounts enter their LDAP\n                    # password to register, or ZulipLDAPUserPopulator,\n                    # which just populates UserProfile fields (no auth).\n                    require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)\n                    break\n\n        if ldap_full_name:\n            # We don't use initial= here, because if the form is\n            # complete (that is, no additional fields need to be\n            # filled out by the user) we want the form to validate,\n            # so they can be directly registered without having to\n            # go through this interstitial.\n            form = RegistrationForm({\"full_name\": ldap_full_name}, realm_creation=realm_creation)\n            request.session[\"authenticated_full_name\"] = ldap_full_name\n            name_validated = True\n        elif realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={\"full_name\": hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation,\n            )\n            name_validated = True\n        elif prereg_user.full_name:\n            if prereg_user.full_name_validated:\n                request.session[\"authenticated_full_name\"] = prereg_user.full_name\n                name_validated = True\n                form = RegistrationForm(\n                    {\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n            else:\n                form = RegistrationForm(\n                    initial={\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n        elif form_full_name is not None:\n            form = RegistrationForm(\n                initial={\"full_name\": form_full_name},\n                realm_creation=realm_creation,\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update(full_name=request.session[\"authenticated_full_name\"])\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n\n    if not (password_auth_enabled(realm) and password_required):\n        form[\"password\"].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm) and form[\"password\"].field.required:\n            password = form.cleaned_data[\"password\"]\n        else:\n            # If the user wasn't prompted for a password when\n            # completing the authentication form (because they're\n            # signing up with SSO and no password is required), set\n            # the password field to `None` (Which causes Django to\n            # create an unusable password).\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data[\"realm_subdomain\"]\n            realm_name = form.cleaned_data[\"realm_name\"]\n            realm_type = form.cleaned_data[\"realm_type\"]\n            is_demo_org = form.cleaned_data[\"is_demo_organization\"]\n            realm = do_create_realm(\n                string_id, realm_name, org_type=realm_type, is_demo_organization=is_demo_org\n            )\n            setup_realm_internal_bots(realm)\n        assert realm is not None\n\n        full_name = form.cleaned_data[\"full_name\"]\n        enable_marketing_emails = form.cleaned_data[\"enable_marketing_emails\"]\n        default_stream_group_names = request.POST.getlist(\"default_stream_group\")\n        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)\n\n        if source_realm_id is not None:\n            # Non-integer realm_id values like \"string\" are treated\n            # like the \"Do not import\" value of \"\".\n            source_profile: Optional[UserProfile] = get_source_profile(email, source_realm_id)\n        else:\n            source_profile = None\n\n        if not realm_creation:\n            try:\n                existing_user_profile: Optional[UserProfile] = get_user_by_delivery_email(\n                    email, realm\n                )\n            except UserProfile.DoesNotExist:\n                existing_user_profile = None\n        else:\n            existing_user_profile = None\n\n        user_profile: Optional[UserProfile] = None\n        return_data: Dict[str, bool] = {}\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            # prereg_user.realm_creation carries the information about whether\n            # we're in realm creation mode, and the ldap flow will handle\n            # that and create the user with the appropriate parameters.\n            user_profile = authenticate(\n                request=request,\n                username=email,\n                password=password,\n                realm=realm,\n                prereg_user=prereg_user,\n                return_data=return_data,\n            )\n            if user_profile is None:\n                can_use_different_backend = email_auth_enabled(realm) or (\n                    len(get_external_method_dicts(realm)) > 0\n                )\n                if settings.LDAP_APPEND_DOMAIN:\n                    # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account\n                    # if the email matches the ldap domain.\n                    can_use_different_backend = can_use_different_backend and (\n                        not email_belongs_to_ldap(realm, email)\n                    )\n                if return_data.get(\"no_matching_ldap_user\") and can_use_different_backend:\n                    # If both the LDAP and Email or Social auth backends are\n                    # enabled, and there's no matching user in the LDAP\n                    # directory then the intent is to create a user in the\n                    # realm with their email outside the LDAP organization\n                    # (with e.g. a password stored in the Zulip database,\n                    # not LDAP).  So we fall through and create the new\n                    # account.\n                    pass\n                else:\n                    # TODO: This probably isn't going to give a\n                    # user-friendly error message, but it doesn't\n                    # particularly matter, because the registration form\n                    # is hidden for most users.\n                    view_url = reverse(\"login\")\n                    query = urlencode({\"email\": email})\n                    redirect_url = append_url_query_string(view_url, query)\n                    return HttpResponseRedirect(redirect_url)\n            elif not realm_creation:\n                # Since we'll have created a user, we now just log them in.\n                return login_and_go_to_home(request, user_profile)\n            else:\n                # With realm_creation=True, we're going to return further down,\n                # after finishing up the creation process.\n                pass\n\n        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_mirror_dummy_user(user_profile, acting_user=user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_change_user_setting(user_profile, \"timezone\", timezone, acting_user=user_profile)\n            # TODO: When we clean up the `do_activate_mirror_dummy_user` code path,\n            # make it respect invited_as_admin / is_realm_admin.\n\n        if user_profile is None:\n            user_profile = do_create_user(\n                email,\n                password,\n                realm,\n                full_name,\n                prereg_user=prereg_user,\n                role=role,\n                tos_version=settings.TERMS_OF_SERVICE_VERSION,\n                timezone=timezone,\n                default_stream_groups=default_stream_groups,\n                source_profile=source_profile,\n                realm_creation=realm_creation,\n                acting_user=None,\n                enable_marketing_emails=enable_marketing_emails,\n            )\n\n        if realm_creation:\n            assert realm.signup_notifications_stream is not None\n            bulk_add_subscriptions(\n                realm, [realm.signup_notifications_stream], [user_profile], acting_user=None\n            )\n            send_initial_realm_messages(realm)\n\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(\n                ExternalAuthResult(user_profile=user_profile, data_dict={\"is_realm_creation\": True})\n            )\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(\n            username=user_profile.delivery_email,\n            realm=realm,\n            return_data=return_data,\n            use_dummy_backend=True,\n        )\n        if return_data.get(\"invalid_subdomain\"):\n            # By construction, this should never happen.\n            logging.error(\n                \"Subdomain mismatch in registration %s: %s\",\n                realm.subdomain,\n                user_profile.delivery_email,\n            )\n            return redirect(\"/\")\n\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        \"zerver/register.html\",\n        context={\n            \"form\": form,\n            \"email\": email,\n            \"key\": key,\n            \"full_name\": request.session.get(\"authenticated_full_name\", None),\n            \"lock_name\": name_validated and name_changes_disabled(realm),\n            # password_auth_enabled is normally set via our context processor,\n            # but for the registration form, there is no logged in user yet, so\n            # we have to set it here.\n            \"creating_new_team\": realm_creation,\n            \"password_required\": password_auth_enabled(realm) and password_required,\n            \"require_ldap_password\": require_ldap_password,\n            \"password_auth_enabled\": password_auth_enabled(realm),\n            \"root_domain_available\": is_root_domain_available(),\n            \"default_stream_groups\": [] if realm is None else get_default_stream_groups(realm),\n            \"accounts\": get_accounts_for_email(email),\n            \"MAX_REALM_NAME_LENGTH\": str(Realm.MAX_REALM_NAME_LENGTH),\n            \"MAX_NAME_LENGTH\": str(UserProfile.MAX_NAME_LENGTH),\n            \"MAX_PASSWORD_LENGTH\": str(form.MAX_PASSWORD_LENGTH),\n            \"MAX_REALM_SUBDOMAIN_LENGTH\": str(Realm.MAX_REALM_SUBDOMAIN_LENGTH),\n            \"corporate_enabled\": settings.CORPORATE_ENABLED,\n            \"sorted_realm_types\": sorted(\n                Realm.ORG_TYPES.values(), key=lambda d: d[\"display_order\"]\n            ),\n        },\n    )\n\n\ndef login_and_go_to_home(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    mobile_flow_otp = get_expirable_session_var(\n        request.session, \"registration_mobile_flow_otp\", delete=True\n    )\n    desktop_flow_otp = get_expirable_session_var(\n        request.session, \"registration_desktop_flow_otp\", delete=True\n    )\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n    # Using 'mark_sanitized' to work around false positive where Pysa thinks\n    # that 'user_profile' is user-controlled\n    return HttpResponseRedirect(mark_sanitized(user_profile.realm.uri) + reverse(\"home\"))\n\n\ndef prepare_activation_url(\n    email: str,\n    request: HttpRequest,\n    realm_creation: bool = False,\n    streams: Optional[List[Stream]] = None,\n    invited_as: Optional[int] = None,\n) -> str:\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(email, request, realm_creation)\n\n    if streams is not None:\n        prereg_user.streams.set(streams)\n\n    if invited_as is not None:\n        prereg_user.invited_as = invited_as\n        prereg_user.save()\n\n    confirmation_type = Confirmation.USER_REGISTRATION\n    if realm_creation:\n        confirmation_type = Confirmation.REALM_CREATION\n\n    activation_url = create_confirmation_link(prereg_user, confirmation_type)\n    if settings.DEVELOPMENT and realm_creation:\n        request.session[\"confirmation_key\"] = {\"confirmation_key\": activation_url.split(\"/\")[-1]}\n    return activation_url\n\n\ndef send_confirm_registration_email(\n    email: str,\n    activation_url: str,\n    *,\n    realm: Optional[Realm] = None,\n    request: Optional[HttpRequest] = None,\n) -> None:\n    send_email(\n        \"zerver/emails/confirm_registration\",\n        to_emails=[email],\n        from_address=FromAddress.tokenized_no_reply_address(),\n        language=request.LANGUAGE_CODE if request is not None else None,\n        context={\n            \"create_realm\": (realm is None),\n            \"activate_url\": activation_url,\n        },\n        realm=realm,\n        request=request,\n    )\n\n\ndef redirect_to_email_login_url(email: str) -> HttpResponseRedirect:\n    login_url = reverse(\"login\")\n    redirect_url = append_url_query_string(\n        login_url, urlencode({\"email\": email, \"already_registered\": 1})\n    )\n    return HttpResponseRedirect(redirect_url)\n\n\ndef create_realm(request: HttpRequest, creation_key: Optional[str] = None) -> HttpResponse:\n    try:\n        key_record = validate_key(creation_key)\n    except RealmCreationKey.Invalid:\n        return render(\n            request,\n            \"zerver/realm_creation_failed.html\",\n            context={\n                \"message\": _(\"The organization creation link has expired\" \" or is not valid.\")\n            },\n        )\n    if not settings.OPEN_REALM_CREATION:\n        if key_record is None:\n            return render(\n                request,\n                \"zerver/realm_creation_failed.html\",\n                context={\"message\": _(\"New organization creation disabled\")},\n            )\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # with a few restrictions on their email address.\n    if request.method == \"POST\":\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n            activation_url = prepare_activation_url(email, request, realm_creation=True)\n            if key_record is not None and key_record.presume_email_valid:\n                # The user has a token created from the server command line;\n                # skip confirming the email is theirs, taking their word for it.\n                # This is essential on first install if the admin hasn't stopped\n                # to configure outbound email up front, or it isn't working yet.\n                key_record.delete()\n                return HttpResponseRedirect(activation_url)\n\n            try:\n                send_confirm_registration_email(email, activation_url, request=request)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in create_realm\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if key_record is not None:\n                key_record.delete()\n            return HttpResponseRedirect(reverse(\"new_realm_send_confirm\", kwargs={\"email\": email}))\n    else:\n        form = RealmCreationForm()\n    return render(\n        request,\n        \"zerver/create_realm.html\",\n        context={\"form\": form, \"current_url\": request.get_full_path},\n    )\n\n\ndef accounts_home(\n    request: HttpRequest,\n    multiuse_object_key: str = \"\",\n    multiuse_object: Optional[MultiuseInvite] = None,\n) -> HttpResponse:\n    try:\n        realm = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        return HttpResponseRedirect(reverse(find_account))\n    if realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n    invited_as = None\n\n    if multiuse_object:\n        realm = multiuse_object.realm\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n        invited_as = multiuse_object.invited_as\n\n    if request.method == \"POST\":\n        form = HomepageForm(request.POST, realm=realm, from_multiuse_invite=from_multiuse_invite)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n\n            try:\n                validate_email_not_already_in_realm(realm, email)\n            except ValidationError:\n                return redirect_to_email_login_url(email)\n\n            activation_url = prepare_activation_url(\n                email, request, streams=streams_to_subscribe, invited_as=invited_as\n            )\n            try:\n                send_confirm_registration_email(email, activation_url, request=request, realm=realm)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in accounts_home\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse(\"signup_send_confirm\", kwargs={\"email\": email}))\n\n    else:\n        form = HomepageForm(realm=realm)\n    context = login_context(request)\n    context.update(\n        form=form,\n        current_url=request.get_full_path,\n        multiuse_object_key=multiuse_object_key,\n        from_multiuse_invite=from_multiuse_invite,\n    )\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n    multiuse_object = None\n    try:\n        multiuse_object = get_object_from_key(confirmation_key, [Confirmation.MULTIUSE_INVITE])\n        # Required for OAuth 2\n    except ConfirmationKeyException as exception:\n        realm = get_realm_from_request(request)\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(\n        request, multiuse_object_key=confirmation_key, multiuse_object=multiuse_object\n    )\n\n\n@has_request_variables\ndef find_account(\n    request: HttpRequest, raw_emails: Optional[str] = REQ(\"emails\", default=None)\n) -> HttpResponse:\n    url = reverse(\"find_account\")\n\n    emails: List[str] = []\n    if request.method == \"POST\":\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data[\"emails\"]\n            for i in range(len(emails)):\n                try:\n                    rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n                except RateLimited as e:\n                    assert e.secs_to_freedom is not None\n                    return render(\n                        request,\n                        \"zerver/rate_limit_exceeded.html\",\n                        context={\"retry_after\": int(e.secs_to_freedom)},\n                        status=429,\n                    )\n\n            # Django doesn't support __iexact__in lookup with EmailField, so we have\n            # to use Qs to get around that without needing to do multiple queries.\n            emails_q = Q()\n            for email in emails:\n                emails_q |= Q(delivery_email__iexact=email)\n\n            user_profiles = UserProfile.objects.filter(\n                emails_q, is_active=True, is_bot=False, realm__deactivated=False\n            )\n\n            # We organize the data in preparation for sending exactly\n            # one outgoing email per provided email address, with each\n            # email listing all of the accounts that email address has\n            # with the current Zulip server.\n            context: Dict[str, Dict[str, Any]] = {}\n            for user in user_profiles:\n                key = user.delivery_email.lower()\n                context.setdefault(key, {})\n                context[key].setdefault(\"realms\", [])\n                context[key][\"realms\"].append(user.realm)\n                context[key][\"external_host\"] = settings.EXTERNAL_HOST\n                # This value will end up being the last user ID among\n                # matching accounts; since it's only used for minor\n                # details like language, that arbitrary choice is OK.\n                context[key][\"to_user_id\"] = user.id\n\n            for delivery_email, realm_context in context.items():\n                realm_context[\"email\"] = delivery_email\n                send_email(\n                    \"zerver/emails/find_team\",\n                    to_user_ids=[realm_context[\"to_user_id\"]],\n                    context=realm_context,\n                    from_address=FromAddress.SUPPORT,\n                    request=request,\n                )\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({\"emails\": \",\".join(emails)})\n            return redirect(append_url_query_string(url, data))\n    else:\n        form = FindMyTeamForm()\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if raw_emails:\n            for email in raw_emails.split(\",\"):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(\n        request,\n        \"zerver/find_account.html\",\n        context={\"form\": form, \"current_url\": lambda: url, \"emails\": emails},\n    )\n\n\n@has_request_variables\ndef realm_redirect(request: HttpRequest, next: str = REQ(default=\"\")) -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = get_safe_redirect_to(next, realm.uri)\n            return HttpResponseRedirect(redirect_to)\n    else:\n        form = RealmRedirectForm()\n\n    return render(request, \"zerver/realm_redirect.html\", context={\"form\": form})\n"], "fixing_code": ["import base64\nimport copy\nimport datetime\nimport json\nimport os\nimport re\nimport secrets\nimport time\nimport urllib\nfrom contextlib import contextmanager\nfrom typing import Any, Callable, Dict, Iterator, List, Mapping, Optional, Sequence, Tuple, Type\nfrom unittest import mock\nfrom urllib.parse import urlencode\n\nimport jwt\nimport ldap\nimport orjson\nimport requests\nimport responses\nfrom bs4 import BeautifulSoup\nfrom bs4.element import Tag\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate\nfrom django.core import mail\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import override_settings\nfrom django.test.client import RequestFactory\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\nfrom django_auth_ldap.backend import LDAPSearch, _LDAPUser\nfrom jwt.exceptions import PyJWTError\nfrom onelogin.saml2.auth import OneLogin_Saml2_Auth\nfrom onelogin.saml2.logout_request import OneLogin_Saml2_Logout_Request\nfrom onelogin.saml2.response import OneLogin_Saml2_Response\nfrom onelogin.saml2.utils import OneLogin_Saml2_Utils\nfrom social_core.exceptions import AuthFailed, AuthStateForbidden\nfrom social_django.storage import BaseDjangoStorage\nfrom social_django.strategy import DjangoStrategy\n\nfrom confirmation.models import Confirmation, create_confirmation_link\nfrom zerver.lib.actions import (\n    change_user_is_active,\n    do_create_realm,\n    do_create_user,\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_invite_users,\n    do_reactivate_realm,\n    do_reactivate_user,\n    do_set_realm_property,\n    ensure_stream,\n)\nfrom zerver.lib.avatar import avatar_url\nfrom zerver.lib.avatar_hash import user_avatar_path\nfrom zerver.lib.dev_ldap_directory import generate_dev_ldap_dir\nfrom zerver.lib.email_validation import (\n    get_existing_user_errors,\n    get_realm_email_validator,\n    validate_email_is_valid,\n)\nfrom zerver.lib.exceptions import JsonableError, RateLimited\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import otp_decrypt_api_key\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.storage import static_path\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    create_s3_buckets,\n    load_subdomain_token,\n    read_test_image_file,\n    use_s3_backend,\n)\nfrom zerver.lib.types import Validator\nfrom zerver.lib.upload import DEFAULT_AVATAR_SIZE, MEDIUM_AVATAR_SIZE, resize_avatar\nfrom zerver.lib.users import get_all_api_keys\nfrom zerver.lib.validator import (\n    check_bool,\n    check_dict_only,\n    check_int,\n    check_list,\n    check_none_or,\n    check_string,\n    validate_login_email,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    MultiuseInvite,\n    PasswordTooWeakError,\n    PreregistrationUser,\n    Realm,\n    RealmDomain,\n    Stream,\n    UserProfile,\n    clear_supported_auth_backends_cache,\n    email_to_username,\n    get_realm,\n    get_user_by_delivery_email,\n)\nfrom zerver.signals import JUST_CREATED_THRESHOLD\nfrom zerver.views.auth import log_into_subdomain, maybe_send_to_registration\nfrom zproject.backends import (\n    AUTH_BACKEND_NAME_MAP,\n    AppleAuthBackend,\n    AzureADAuthBackend,\n    DevAuthBackend,\n    EmailAuthBackend,\n    ExternalAuthDataDict,\n    ExternalAuthResult,\n    GenericOpenIdConnectBackend,\n    GitHubAuthBackend,\n    GitLabAuthBackend,\n    GoogleAuthBackend,\n    PopulateUserLDAPError,\n    RateLimitedAuthenticationByUsername,\n    SAMLAuthBackend,\n    SAMLDocument,\n    SocialAuthMixin,\n    ZulipAuthMixin,\n    ZulipDummyBackend,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPConfigurationError,\n    ZulipLDAPException,\n    ZulipLDAPExceptionNoMatchingLDAPUser,\n    ZulipLDAPExceptionOutsideDomain,\n    ZulipLDAPUser,\n    ZulipLDAPUserPopulator,\n    ZulipRemoteUserBackend,\n    apple_auth_enabled,\n    check_password_strength,\n    dev_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    github_auth_enabled,\n    gitlab_auth_enabled,\n    google_auth_enabled,\n    password_auth_enabled,\n    query_ldap,\n    require_email_format_usernames,\n    saml_auth_enabled,\n    sync_user_from_ldap,\n)\n\n\nclass AuthBackendTest(ZulipTestCase):\n    def get_username(self, email_to_username: Optional[Callable[[str], str]] = None) -> str:\n        username = self.example_email(\"hamlet\")\n        if email_to_username is not None:\n            username = email_to_username(self.example_email(\"hamlet\"))\n\n        return username\n\n    def verify_backend(\n        self,\n        backend: Any,\n        *,\n        good_kwargs: Dict[str, Any],\n        bad_kwargs: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        clear_supported_auth_backends_cache()\n        user_profile = self.example_user(\"hamlet\")\n\n        # If bad_kwargs was specified, verify auth fails in that case\n        if bad_kwargs is not None:\n            self.assertIsNone(backend.authenticate(**bad_kwargs))\n\n        # Verify auth works\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated user\n        do_deactivate_user(user_profile, acting_user=None)\n        result = backend.authenticate(**good_kwargs)\n        if isinstance(backend, SocialAuthMixin):\n            # Returns a redirect to login page with an error.\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result.url,\n                f\"{user_profile.realm.uri}/login/?\"\n                + urlencode({\"is_deactivated\": user_profile.delivery_email}),\n            )\n        else:\n            # Just takes you back to the login page treating as\n            # invalid auth; this is correct because the form will\n            # provide the appropriate validation error for deactivated\n            # account.\n            self.assertIsNone(result)\n\n        # Reactivate the user and verify auth works again\n        do_reactivate_user(user_profile, acting_user=None)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated realm\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n        result = backend.authenticate(**good_kwargs)\n        if isinstance(backend, SocialAuthMixin):\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, user_profile.realm.uri + \"/login/\")\n        else:\n            self.assertIsNone(result)\n\n        # Verify auth works again after reactivating the realm\n        do_reactivate_realm(user_profile.realm)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # ZulipDummyBackend isn't a real backend so the remainder\n        # doesn't make sense for it\n        if isinstance(backend, ZulipDummyBackend):\n            return\n\n        # Verify auth fails if the auth backend is disabled on server\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipDummyBackend\",)):\n            clear_supported_auth_backends_cache()\n            result = backend.authenticate(**good_kwargs)\n            if isinstance(backend, SocialAuthMixin):\n                self.assertEqual(result.status_code, 302)\n                self.assertEqual(result.url, user_profile.realm.uri + \"/login/\")\n            else:\n                self.assertIsNone(result)\n        clear_supported_auth_backends_cache()\n\n        # Verify auth fails if the auth backend is disabled for the realm\n        for backend_name in AUTH_BACKEND_NAME_MAP.keys():\n            if isinstance(backend, AUTH_BACKEND_NAME_MAP[backend_name]):\n                break\n\n        index = getattr(user_profile.realm.authentication_methods, backend_name).number\n        user_profile.realm.authentication_methods.set_bit(index, False)\n        user_profile.realm.save()\n        if \"realm\" in good_kwargs:\n            # Because this test is a little unfaithful to the ordering\n            # (i.e. we fetched the realm object before this function\n            # was called, when in fact it should be fetched after we\n            # changed the allowed authentication methods), we need to\n            # propagate the changes we just made to the actual realm\n            # object in good_kwargs.\n            good_kwargs[\"realm\"] = user_profile.realm\n\n        if isinstance(backend, SocialAuthMixin):\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, user_profile.realm.uri + \"/login/\")\n        else:\n            self.assertIsNone(result)\n        user_profile.realm.authentication_methods.set_bit(index, True)\n        user_profile.realm.save()\n\n    def test_dummy_backend(self) -> None:\n        realm = get_realm(\"zulip\")\n        username = self.get_username()\n        self.verify_backend(\n            ZulipDummyBackend(),\n            good_kwargs=dict(username=username, realm=realm, use_dummy_backend=True),\n            bad_kwargs=dict(username=username, realm=realm, use_dummy_backend=False),\n        )\n\n    def setup_subdomain(self, user_profile: UserProfile) -> None:\n        realm = user_profile.realm\n        realm.string_id = \"zulip\"\n        realm.save()\n\n    def test_email_auth_backend(self) -> None:\n        username = self.get_username()\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        with mock.patch(\"zproject.backends.email_auth_enabled\", return_value=False), mock.patch(\n            \"zproject.backends.password_auth_enabled\", return_value=True\n        ):\n            return_data: Dict[str, bool] = {}\n            user = EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=user_profile.delivery_email,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data=return_data,\n            )\n            self.assertEqual(user, None)\n            self.assertTrue(return_data[\"email_auth_disabled\"])\n\n        self.verify_backend(\n            EmailAuthBackend(),\n            good_kwargs=dict(\n                request=mock.MagicMock(),\n                password=password,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                return_data={},\n            ),\n            bad_kwargs=dict(\n                request=mock.MagicMock(),\n                password=password,\n                username=username,\n                realm=get_realm(\"zephyr\"),\n                return_data={},\n            ),\n        )\n\n    def test_email_auth_backend_empty_password(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        # First, verify authentication works with a nonempty\n        # password so we know we've set up the test correctly.\n        self.assertIsNotNone(\n            EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=password,\n                realm=get_realm(\"zulip\"),\n            )\n        )\n\n        # Now do the same test with the empty string as the password.\n        password = \"\"\n        with self.assertRaises(PasswordTooWeakError):\n            # UserProfile.set_password protects against setting an empty password.\n            user_profile.set_password(password)\n        # We do want to force an empty password for this test, so we bypass the protection\n        # by using Django's version of this method.\n        super(UserProfile, user_profile).set_password(password)\n        user_profile.save()\n        self.assertIsNone(\n            EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=password,\n                realm=get_realm(\"zulip\"),\n            )\n        )\n\n    def test_email_auth_backend_disabled_password_auth(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n        # Verify if a realm has password auth disabled, correct password is rejected\n        with mock.patch(\"zproject.backends.password_auth_enabled\", return_value=False):\n            self.assertIsNone(\n                EmailAuthBackend().authenticate(\n                    request=mock.MagicMock(),\n                    username=self.example_email(\"hamlet\"),\n                    password=password,\n                    realm=get_realm(\"zulip\"),\n                )\n            )\n\n    def test_email_auth_backend_password_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"), self.assertRaises(JsonableError) as m:\n            EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=password,\n                realm=get_realm(\"zulip\"),\n            )\n        self.assertEqual(str(m.exception), \"You need to reset your password.\")\n\n    def test_login_preview(self) -> None:\n        # Test preview=true displays organization login page\n        # instead of redirecting to app\n        self.login(\"iago\")\n        realm = get_realm(\"zulip\")\n        result = self.client_get(\"/login/\", {\"preview\": \"true\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(realm.description, result)\n        assert realm.name is not None\n        self.assert_in_response(realm.name, result)\n        self.assert_in_response(\"Log in to Zulip\", result)\n\n        data = dict(\n            description=orjson.dumps(\"New realm description\").decode(),\n            name=orjson.dumps(\"New Zulip\").decode(),\n        )\n        result = self.client_patch(\"/json/realm\", data)\n        self.assert_json_success(result)\n\n        result = self.client_get(\"/login/\", {\"preview\": \"true\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"New realm description\", result)\n        self.assert_in_response(\"New Zulip\", result)\n\n        result = self.client_get(\"/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zulip.testserver\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipDummyBackend\",))\n    def test_no_backend_enabled(self) -> None:\n        result = self.client_get(\"/login/\")\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n        result = self.client_get(\"/register/\")\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GoogleAuthBackend\",))\n    def test_any_backend_enabled(self) -> None:\n\n        # testing to avoid false error messages.\n        result = self.client_get(\"/login/\")\n        self.assert_not_in_success_response([\"No authentication backends are enabled\"], result)\n\n        result = self.client_get(\"/register/\")\n        self.assert_not_in_success_response([\"No authentication backends are enabled\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",), LDAP_EMAIL_ATTR=\"mail\"\n    )\n    def test_ldap_backend(self) -> None:\n        self.init_default_ldap_database()\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        password = self.ldap_password(\"hamlet\")\n        self.setup_subdomain(user_profile)\n\n        username = self.get_username()\n        backend = ZulipLDAPAuthBackend()\n\n        # Test LDAP auth fails when LDAP server rejects password\n        self.assertIsNone(\n            backend.authenticate(\n                request=mock.MagicMock(),\n                username=email,\n                password=\"wrongpass\",\n                realm=get_realm(\"zulip\"),\n            )\n        )\n\n        self.verify_backend(\n            backend,\n            bad_kwargs=dict(\n                request=mock.MagicMock(),\n                username=username,\n                password=password,\n                realm=get_realm(\"zephyr\"),\n            ),\n            good_kwargs=dict(\n                request=mock.MagicMock(),\n                username=username,\n                password=password,\n                realm=get_realm(\"zulip\"),\n            ),\n        )\n\n    def test_devauth_backend(self) -> None:\n        self.verify_backend(\n            DevAuthBackend(),\n            good_kwargs=dict(dev_auth_username=self.get_username(), realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(dev_auth_username=self.get_username(), realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_remote_user_backend(self) -> None:\n        username = self.get_username()\n        self.verify_backend(\n            ZulipRemoteUserBackend(),\n            good_kwargs=dict(remote_user=username, realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(remote_user=username, realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_remote_user_backend_invalid_realm(self) -> None:\n        username = self.get_username()\n        self.verify_backend(\n            ZulipRemoteUserBackend(),\n            good_kwargs=dict(remote_user=username, realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(remote_user=username, realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    @override_settings(SSO_APPEND_DOMAIN=\"zulip.com\")\n    def test_remote_user_backend_sso_append_domain(self) -> None:\n        username = self.get_username(email_to_username)\n        self.verify_backend(\n            ZulipRemoteUserBackend(),\n            good_kwargs=dict(remote_user=username, realm=get_realm(\"zulip\")),\n            bad_kwargs=dict(remote_user=username, realm=get_realm(\"zephyr\")),\n        )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.GitHubAuthBackend\",\n            \"zproject.backends.GoogleAuthBackend\",\n        )\n    )\n    def test_social_auth_backends(self) -> None:\n        user = self.example_user(\"hamlet\")\n        token_data_dict = {\n            \"access_token\": \"foobar\",\n            \"token_type\": \"bearer\",\n        }\n        github_email_data = [\n            dict(email=user.delivery_email, verified=True, primary=True),\n            dict(email=\"nonprimary@zulip.com\", verified=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        google_email_data = dict(\n            email=user.delivery_email, name=user.full_name, email_verified=True\n        )\n        backends_to_test: Dict[str, Any] = {\n            \"google\": {\n                \"urls\": [\n                    # The limited process that we test here doesn't require mocking any urls.\n                ],\n                \"backend\": GoogleAuthBackend,\n            },\n            \"github\": {\n                \"urls\": [\n                    {\n                        \"url\": \"https://api.github.com/user/emails\",\n                        \"method\": responses.GET,\n                        \"status\": 200,\n                        \"body\": json.dumps(github_email_data),\n                    },\n                ],\n                \"backend\": GitHubAuthBackend,\n            },\n        }\n\n        def patched_authenticate(\n            request: Optional[HttpResponse] = None,\n            **kwargs: Any,\n        ) -> Any:\n            # This is how we pass the subdomain to the authentication\n            # backend in production code, so we need to do this setup\n            # here.\n            if \"subdomain\" in kwargs:\n                backend.strategy.session_set(\"subdomain\", kwargs[\"subdomain\"])\n                del kwargs[\"subdomain\"]\n\n            # Because we're not simulating the full python-social-auth\n            # pipeline here, we need to provide the user's choice of\n            # which email to select in the partial phase of the\n            # pipeline when we display an email picker for the GitHub\n            # authentication backend.  We do that here.\n            def return_email() -> Dict[str, str]:\n                return {\"email\": user.delivery_email}\n\n            backend.strategy.request_data = return_email\n\n            if request is None:\n                request = mock.MagicMock()\n                request.META = dict(REMOTE_ADDR=\"127.0.0.1\")\n            backend.strategy.request = request\n\n            result = orig_authenticate(backend, request, **kwargs)\n            return result\n\n        def patched_get_verified_emails(*args: Any, **kwargs: Any) -> Any:\n            return google_email_data[\"email\"]\n\n        for backend_name in backends_to_test:\n            with responses.RequestsMock(assert_all_requests_are_fired=True) as requests_mock:\n                urls: List[Dict[str, Any]] = backends_to_test[backend_name][\"urls\"]\n                for details in urls:\n                    requests_mock.add(\n                        details[\"method\"],\n                        details[\"url\"],\n                        status=details[\"status\"],\n                        body=details[\"body\"],\n                    )\n                backend_class = backends_to_test[backend_name][\"backend\"]\n\n                # We're creating a new class instance here, so the\n                # monkey-patching of the instance that we're about to\n                # do will be discarded at the end of this test.\n                backend = backend_class()\n                backend.strategy = DjangoStrategy(storage=BaseDjangoStorage())\n\n                orig_authenticate = backend_class.authenticate\n                backend.authenticate = patched_authenticate\n                if backend_name == \"google\":\n                    backend.get_verified_emails = patched_get_verified_emails\n\n                good_kwargs = dict(\n                    backend=backend,\n                    strategy=backend.strategy,\n                    storage=backend.strategy.storage,\n                    response=token_data_dict,\n                    subdomain=\"zulip\",\n                )\n                bad_kwargs = dict(subdomain=\"acme\")\n                logger_name = f\"zulip.auth.{backend.name}\"\n\n                with mock.patch(\n                    \"zerver.views.auth.redirect_and_log_into_subdomain\", return_value=user\n                ), self.assertLogs(logger_name, level=\"INFO\") as info_log:\n                    self.verify_backend(backend, good_kwargs=good_kwargs, bad_kwargs=bad_kwargs)\n                    bad_kwargs[\"subdomain\"] = \"zephyr\"\n                    self.verify_backend(backend, good_kwargs=good_kwargs, bad_kwargs=bad_kwargs)\n                # Verify logging for deactivated users\n                self.assertEqual(\n                    # Filter out noisy logs:\n                    [\n                        output\n                        for output in info_log.output\n                        if \"Authentication attempt from 127.0.0.1\" not in output\n                    ],\n                    [\n                        f\"INFO:{logger_name}:Failed login attempt for deactivated account: {user.id}@{user.realm.string_id}\",\n                        f\"INFO:{logger_name}:Failed login attempt for deactivated account: {user.id}@{user.realm.string_id}\",\n                    ],\n                )\n\n\nclass RateLimitAuthenticationTests(ZulipTestCase):\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def do_test_auth_rate_limiting(\n        self,\n        attempt_authentication_func: Callable[[HttpRequest, str, str], Optional[UserProfile]],\n        username: str,\n        correct_password: str,\n        wrong_password: str,\n        expected_user_profile: UserProfile,\n    ) -> None:\n        # We have to mock RateLimitedAuthenticationByUsername.key to avoid key collisions\n        # if tests run in parallel.\n        original_key_method = RateLimitedAuthenticationByUsername.key\n        salt = secrets.token_hex(16)\n\n        def _mock_key(self: RateLimitedAuthenticationByUsername) -> str:\n            return f\"{salt}:{original_key_method(self)}\"\n\n        def attempt_authentication(username: str, password: str) -> Optional[UserProfile]:\n            request = HttpRequest()\n            request.session = mock.MagicMock()\n            return attempt_authentication_func(request, username, password)\n\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n        with mock.patch.object(RateLimitedAuthenticationByUsername, \"key\", new=_mock_key):\n            try:\n                start_time = time.time()\n                with mock.patch(\"time.time\", return_value=start_time):\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    # 2 failed attempts is the limit, so the next ones should get blocked,\n                    # even with the correct password.\n                    with self.assertRaises(RateLimited):\n                        attempt_authentication(username, correct_password)\n                    with self.assertRaises(RateLimited):\n                        attempt_authentication(username, wrong_password)\n\n                # After enough time passes, more authentication attempts can be made:\n                with mock.patch(\"time.time\", return_value=start_time + 11.0):\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n\n                    # Correct password\n                    self.assertEqual(\n                        attempt_authentication(username, correct_password), expected_user_profile\n                    )\n                    # A correct login attempt should reset the rate limits for this user profile,\n                    # so the next two attempts shouldn't get limited:\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    self.assertIsNone(attempt_authentication(username, wrong_password))\n                    # But the third attempt goes over the limit:\n                    with self.assertRaises(RateLimited):\n                        attempt_authentication(username, wrong_password)\n            finally:\n                # Clean up to avoid affecting other tests.\n                RateLimitedAuthenticationByUsername(username).clear_history()\n                remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_email_auth_backend_user_based_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        def attempt_authentication(\n            request: HttpRequest, username: str, password: str\n        ) -> Optional[UserProfile]:\n            return EmailAuthBackend().authenticate(\n                request=request,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data={},\n            )\n\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            password,\n            \"wrong_password\",\n            user_profile,\n        )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",), LDAP_EMAIL_ATTR=\"mail\"\n    )\n    def test_ldap_backend_user_based_rate_limiting(self) -> None:\n        self.init_default_ldap_database()\n        user_profile = self.example_user(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        def attempt_authentication(\n            request: HttpRequest, username: str, password: str\n        ) -> Optional[UserProfile]:\n            return ZulipLDAPAuthBackend().authenticate(\n                request=request,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data={},\n            )\n\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            password,\n            \"wrong_password\",\n            user_profile,\n        )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n        ),\n        LDAP_EMAIL_ATTR=\"mail\",\n    )\n    def test_email_and_ldap_backends_user_based_rate_limiting(self) -> None:\n        self.init_default_ldap_database()\n        user_profile = self.example_user(\"hamlet\")\n        ldap_password = self.ldap_password(\"hamlet\")\n\n        email_password = \"email_password\"\n        user_profile.set_password(email_password)\n        user_profile.save()\n\n        def attempt_authentication(\n            request: HttpRequest, username: str, password: str\n        ) -> Optional[UserProfile]:\n            return authenticate(\n                request=request,\n                username=username,\n                realm=get_realm(\"zulip\"),\n                password=password,\n                return_data={},\n            )\n\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            email_password,\n            \"wrong_password\",\n            user_profile,\n        )\n        self.do_test_auth_rate_limiting(\n            attempt_authentication,\n            user_profile.delivery_email,\n            ldap_password,\n            \"wrong_password\",\n            user_profile,\n        )\n\n\nclass CheckPasswordStrengthTest(ZulipTestCase):\n    def test_check_password_strength(self) -> None:\n        with self.settings(PASSWORD_MIN_LENGTH=0, PASSWORD_MIN_GUESSES=0):\n            # Never allow empty password.\n            self.assertFalse(check_password_strength(\"\"))\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            self.assertFalse(check_password_strength(\"\"))\n            self.assertFalse(check_password_strength(\"short\"))\n            # Long enough, but too easy:\n            self.assertFalse(check_password_strength(\"longer\"))\n            # Good password:\n            self.assertTrue(check_password_strength(\"f657gdGGk9\"))\n\n\nclass DesktopFlowTestingLib(ZulipTestCase):\n    def verify_desktop_flow_app_page(self, response: HttpResponse) -> None:\n        self.assertEqual(response.status_code, 200)\n        self.assertIn(b\"<h1>Finish desktop login</h1>\", response.content)\n\n    def verify_desktop_flow_end_page(\n        self, response: HttpResponse, email: str, desktop_flow_otp: str\n    ) -> None:\n        self.assertEqual(response.status_code, 200)\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        input = soup.find(\"input\", value=True)\n        assert isinstance(input, Tag)\n        desktop_data = input[\"value\"]\n        assert isinstance(desktop_data, str)\n        a = soup.find(\"a\", href=True)\n        assert isinstance(a, Tag)\n        browser_url = a[\"href\"]\n\n        self.assertEqual(browser_url, \"/login/\")\n        decrypted_key = self.verify_desktop_data_and_return_key(desktop_data, desktop_flow_otp)\n\n        result = self.client_get(\n            f\"http://zulip.testserver/accounts/login/subdomain/{decrypted_key}\"\n        )\n        self.assertEqual(result.status_code, 302)\n        realm = get_realm(\"zulip\")\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def verify_desktop_data_and_return_key(self, desktop_data: str, desktop_flow_otp: str) -> str:\n        key = bytes.fromhex(desktop_flow_otp)\n        data = bytes.fromhex(desktop_data)\n        iv = data[:12]\n        ciphertext = data[12:]\n        return AESGCM(key).decrypt(iv, ciphertext, b\"\").decode()\n\n\nclass SocialAuthBase(DesktopFlowTestingLib, ZulipTestCase):\n    \"\"\"This is a base class for testing social-auth backends. These\n    methods are often overridden by subclasses:\n\n        register_extra_endpoints() - If the backend being tested calls some extra\n                                     endpoints then they can be added here.\n\n        get_account_data_dict() - Return the data returned by the user info endpoint\n                                  according to the respective backend.\n    \"\"\"\n\n    # Don't run base class tests, make sure to set it to False\n    # in subclass otherwise its tests will not run.\n    __unittest_skip__ = True\n\n    BACKEND_CLASS: \"Type[SocialAuthMixin]\"\n    LOGIN_URL: str\n    SIGNUP_URL: str\n    AUTHORIZATION_URL: str\n    AUTH_FINISH_URL: str\n    ACCESS_TOKEN_URL: str\n    USER_INFO_URL: str\n    CLIENT_KEY_SETTING: str\n    CLIENT_SECRET_SETTING: str\n\n    # Functions that subclasses must implement.\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        ...\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.email = self.user_profile.delivery_email\n        self.name = self.user_profile.full_name\n        self.backend = self.BACKEND_CLASS\n        self.backend.strategy = DjangoStrategy(storage=BaseDjangoStorage())\n        self.user_profile.backend = self.backend\n        self.logger_string = f\"zulip.auth.{self.backend.name}\"\n\n        # This is a workaround for the fact that Python social auth\n        # caches the set of authentication backends that are enabled\n        # the first time that `social_django.utils` is imported.  See\n        # https://github.com/python-social-auth/social-app-django/pull/162\n        # for details.\n        from social_core.backends.utils import load_backends\n\n        load_backends(settings.AUTHENTICATION_BACKENDS, force_load=True)\n\n    def logger_output(self, output_string: str, type: str) -> str:\n        return f\"{type.upper()}:zulip.auth.{self.backend.name}:{output_string}\"\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        pass\n\n    def prepare_login_url_and_headers(\n        self,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        alternative_start_url: Optional[str] = None,\n        *,\n        user_agent: Optional[str] = None,\n    ) -> Tuple[str, Dict[str, Any]]:\n        url = self.LOGIN_URL\n        if alternative_start_url is not None:\n            url = alternative_start_url\n\n        params = {}\n        headers = {}\n        if subdomain == \"\":\n            # \"testserver\" may trip up some libraries' URL validation,\n            # so let's use the equivalent www. version.\n            headers[\"HTTP_HOST\"] = \"www.testserver\"\n        else:\n            headers[\"HTTP_HOST\"] = subdomain + \".testserver\"\n        if mobile_flow_otp is not None:\n            params[\"mobile_flow_otp\"] = mobile_flow_otp\n            headers[\"HTTP_USER_AGENT\"] = \"ZulipAndroid\"\n        if desktop_flow_otp is not None:\n            params[\"desktop_flow_otp\"] = desktop_flow_otp\n        if is_signup:\n            url = self.SIGNUP_URL\n        params[\"next\"] = next\n        params[\"multiuse_object_key\"] = multiuse_object_key\n        if len(params) > 0:\n            url += f\"?{urlencode(params)}\"\n        if user_agent is not None:\n            headers[\"HTTP_USER_AGENT\"] = user_agent\n\n        return url, headers\n\n    def social_auth_test_finish(\n        self,\n        result: HttpResponse,\n        account_data_dict: Dict[str, str],\n        expect_choose_email_screen: bool,\n        headers: Any,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        parsed_url = urllib.parse.urlparse(result.url)\n        csrf_state = urllib.parse.parse_qs(parsed_url.query)[\"state\"]\n        result = self.client_get(self.AUTH_FINISH_URL, dict(state=csrf_state), **headers)\n        return result\n\n    def generate_access_token_url_payload(self, account_data_dict: Dict[str, str]) -> str:\n        return json.dumps(\n            {\n                \"access_token\": \"foobar\",\n                \"token_type\": \"bearer\",\n            }\n        )\n\n    def social_auth_test(\n        self,\n        account_data_dict: Dict[str, str],\n        *,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        expect_choose_email_screen: bool = False,\n        alternative_start_url: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        \"\"\"Main entry point for all social authentication tests.\n\n        * account_data_dict: Dictionary containing the name/email data\n          that should be returned by the social auth backend.\n        * subdomain: Which organization's login page is being accessed.\n        * desktop_flow_otp / mobile_flow_otp: Token to be used for\n          mobile or desktop authentication flow testing.\n        * is_signup: Whether we're testing the social flow for\n          /register (True) or /login (False).  This is important\n          because we need to verify behavior like the\n          \"Continue to registration\" if you try to log in using an\n          account that doesn't exist but is allowed to sign up.\n        * next: Parameter passed through in production authentication\n          to redirect the user to (e.g.) the specific page in the web app\n          that they clicked a link to before being presented with the login\n          page.\n        * expect_choose_email_screen: Some social auth backends, like\n          GitHub, simultaneously authenticate for multiple email addresses.\n          Set this to True if we expect to show the \"Choose Email\" screen\n          in this test should the backend have that feature.\n        * multiuse_object_key: Used when the user has clicked a multi-use\n          reusable invitation link.\n        * alternative_start_url: Used to test legacy mobile app behavior.\n        * user_agent: What user-agent to use for the HTTP requests.\n        \"\"\"\n\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            alternative_start_url,\n            user_agent=user_agent,\n        )\n\n        result = self.client_get(url, **headers)\n\n        expected_result_url_prefix = f\"http://testserver/login/{self.backend.name}/\"\n        if settings.SOCIAL_AUTH_SUBDOMAIN is not None:\n            expected_result_url_prefix = (\n                f\"http://{settings.SOCIAL_AUTH_SUBDOMAIN}.testserver/login/{self.backend.name}/\"\n            )\n\n        if result.status_code != 302 or not result.url.startswith(expected_result_url_prefix):\n            return result\n\n        result = self.client_get(result.url, **headers)\n        self.assertEqual(result.status_code, 302)\n        assert self.AUTHORIZATION_URL in result.url\n\n        self.client.cookies = result.cookies\n\n        # Next, the browser requests result[\"Location\"], and gets\n        # redirected back to the registered redirect uri.\n\n        # We register callbacks for the key URLs on Identity Provider that\n        # auth completion URL will call\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as requests_mock:\n            requests_mock.add(\n                requests_mock.POST,\n                self.ACCESS_TOKEN_URL,\n                status=200,\n                body=self.generate_access_token_url_payload(account_data_dict),\n            )\n            requests_mock.add(\n                requests_mock.GET,\n                self.USER_INFO_URL,\n                status=200,\n                body=json.dumps(account_data_dict),\n            )\n            self.register_extra_endpoints(requests_mock, account_data_dict, **extra_data)\n\n            result = self.social_auth_test_finish(\n                result, account_data_dict, expect_choose_email_screen, headers=headers, **extra_data\n            )\n        return result\n\n    def test_social_auth_no_key(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.settings(**{self.CLIENT_KEY_SETTING: None}):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\"], result)\n\n    def test_config_error_development(self) -> None:\n        if hasattr(self, \"CLIENT_KEY_SETTING\") and hasattr(self, \"CLIENT_SECRET_SETTING\"):\n            with self.settings(**{self.CLIENT_KEY_SETTING: None}):\n                result = self.client_get(self.LOGIN_URL)\n                self.assert_in_success_response([\"Configuration error\"], result)\n                self.assert_in_success_response([self.CLIENT_KEY_SETTING.lower()], result)\n                self.assert_in_success_response([self.CLIENT_SECRET_SETTING.lower()], result)\n                self.assert_in_success_response([\"zproject/dev-secrets.conf\"], result)\n                self.assert_not_in_success_response([self.CLIENT_KEY_SETTING], result)\n                self.assert_not_in_success_response([\"zproject/dev_settings.py\"], result)\n                self.assert_not_in_success_response([\"/etc/zulip/settings.py\"], result)\n                self.assert_not_in_success_response([\"/etc/zulip/zulip-secrets.conf\"], result)\n\n    @override_settings(DEVELOPMENT=False)\n    def test_config_error_production(self) -> None:\n        if hasattr(self, \"CLIENT_KEY_SETTING\") and hasattr(self, \"CLIENT_SECRET_SETTING\"):\n            with self.settings(**{self.CLIENT_KEY_SETTING: None}):\n                result = self.client_get(self.LOGIN_URL)\n                self.assert_in_success_response([\"Configuration error\"], result)\n                self.assert_in_success_response([self.CLIENT_KEY_SETTING], result)\n                self.assert_in_success_response([\"/etc/zulip/settings.py\"], result)\n                self.assert_in_success_response([self.CLIENT_SECRET_SETTING.lower()], result)\n                self.assert_in_success_response([\"/etc/zulip/zulip-secrets.conf\"], result)\n                self.assert_not_in_success_response([self.CLIENT_KEY_SETTING.lower()], result)\n                self.assert_not_in_success_response([\"zproject/dev_settings.py\"], result)\n                self.assert_not_in_success_response([\"zproject/dev-secrets.conf\"], result)\n\n    def test_social_auth_success(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=False,\n                subdomain=\"zulip\",\n                next=\"/user_uploads/image\",\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.assertIn(\n            f\"INFO:{self.logger_string}:Authentication attempt from 127.0.0.1: subdomain=zulip;username=hamlet@zulip.com;outcome=success\",\n            m.output[0],\n        )\n\n    @override_settings(SOCIAL_AUTH_SUBDOMAIN=None)\n    def test_when_social_auth_subdomain_is_not_set(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_social_auth_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        # We expect to go through the \"choose email\" screen here,\n        # because there won't be an existing user account we can\n        # auto-select for the user.\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.social_auth_test(\n                account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\"\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result.url,\n                f\"{user_profile.realm.uri}/login/?\"\n                + urlencode({\"is_deactivated\": user_profile.delivery_email}),\n            )\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    f\"Failed login attempt for deactivated account: {user_profile.id}@zulip\", \"info\"\n                )\n            ],\n        )\n\n        result = self.client_get(result.url)\n        self.assert_in_success_response(\n            [f\"Your account {user_profile.delivery_email} has been deactivated.\"], result\n        )\n\n    def test_social_auth_invalid_realm(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with mock.patch(\"zerver.middleware.get_realm\", return_value=get_realm(\"zulip\")):\n            # This mock.patch case somewhat hackishly arranges it so\n            # that we switch realms halfway through the test\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"invalid\", next=\"/user_uploads/image\"\n            )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/\")\n\n    def test_social_auth_invalid_email(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=\"invalid\", name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                next=\"/user_uploads/image\",\n            )\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    f\"{self.backend.auth_backend_name} got invalid email argument.\",\n                    \"warning\",\n                )\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, realm.uri + \"/register/\")\n\n    def test_user_cannot_log_into_nonexisting_realm(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(account_data_dict, subdomain=\"nonexistent\")\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assertEqual(result.status_code, 404)\n\n    def test_user_cannot_log_into_wrong_subdomain(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zephyr\"\n        )\n        self.assertTrue(result.url.startswith(\"http://zephyr.testserver/accounts/login/subdomain/\"))\n        result = self.client_get(\n            result.url.replace(\"http://zephyr.testserver\", \"\"), subdomain=\"zephyr\"\n        )\n        self.assert_in_success_response(\n            [\n                \"Your email address, hamlet@zulip.com, is not in one of the domains \",\n                \"that are allowed to register for accounts in this organization.\",\n            ],\n            result,\n        )\n\n    def test_social_auth_mobile_success(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        hamlet = self.example_user(\"hamlet\")\n        account_data_dict = self.get_account_data_dict(\n            email=hamlet.delivery_email, name=\"Full Name\"\n        )\n        self.assert_length(mail.outbox, 0)\n        self.user_profile.date_joined = timezone_now() - datetime.timedelta(\n            seconds=JUST_CREATED_THRESHOLD + 1\n        )\n        self.user_profile.save()\n\n        with self.settings(SEND_LOGIN_EMAILS=True):\n            # Verify that the right thing happens with an invalid-format OTP\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", mobile_flow_otp=\"1234\"\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", mobile_flow_otp=\"invalido\" * 8\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n\n            # Now do it correctly\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=False,\n                mobile_flow_otp=mobile_flow_otp,\n            )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [hamlet.delivery_email])\n        self.assertEqual(query_params[\"user_id\"], [str(hamlet.id)])\n\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    def test_social_auth_desktop_success(self) -> None:\n        desktop_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.social_auth_test(\n            account_data_dict, subdomain=\"zulip\", desktop_flow_otp=\"1234\"\n        )\n        self.assert_json_error(result, \"Invalid OTP\")\n        result = self.social_auth_test(\n            account_data_dict, subdomain=\"zulip\", desktop_flow_otp=\"invalido\" * 8\n        )\n        self.assert_json_error(result, \"Invalid OTP\")\n\n        # Now do it correctly\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            desktop_flow_otp=desktop_flow_otp,\n            user_agent=\"ZulipElectron/5.0.0\",\n        )\n        self.verify_desktop_flow_app_page(result)\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            desktop_flow_otp=desktop_flow_otp,\n        )\n        self.verify_desktop_flow_end_page(result, self.email, desktop_flow_otp)\n\n    def test_social_auth_session_fields_cleared_correctly(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n\n        def initiate_auth(mobile_flow_otp: Optional[str] = None) -> None:\n            url, headers = self.prepare_login_url_and_headers(\n                subdomain=\"zulip\", mobile_flow_otp=mobile_flow_otp\n            )\n            result = self.client_get(url, **headers)\n            self.assertEqual(result.status_code, 302)\n\n            result = self.client_get(result.url, **headers)\n            self.assertEqual(result.status_code, 302)\n\n        # Start social auth with mobile_flow_otp param. It should get saved into the session\n        # on SOCIAL_AUTH_SUBDOMAIN.\n        initiate_auth(mobile_flow_otp)\n        self.assertEqual(self.client.session[\"mobile_flow_otp\"], mobile_flow_otp)\n\n        # Make a request without mobile_flow_otp param and verify the field doesn't persist\n        # in the session from the previous request.\n        initiate_auth()\n        self.assertEqual(self.client.session.get(\"mobile_flow_otp\"), None)\n\n    def test_social_auth_mobile_and_desktop_flow_in_one_request_error(self) -> None:\n        otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=False,\n            desktop_flow_otp=otp,\n            mobile_flow_otp=otp,\n        )\n        self.assert_json_error(\n            result, \"Can't use both mobile_flow_otp and desktop_flow_otp together.\"\n        )\n\n    def test_social_auth_registration_existing_account(self) -> None:\n        \"\"\"If the user already exists, signup flow just logs them in\"\"\"\n        email = \"hamlet@zulip.com\"\n        name = \"Full Name\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\", is_signup=True\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        # Verify data has the full_name consistent with the user we're logging in as.\n        self.assertEqual(data[\"full_name\"], self.example_user(\"hamlet\").full_name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n        hamlet = self.example_user(\"hamlet\")\n        # Name wasn't changed at all\n        self.assertEqual(hamlet.full_name, \"King Hamlet\")\n\n    def stage_two_of_registration(\n        self,\n        result: HttpResponse,\n        realm: Realm,\n        subdomain: str,\n        email: str,\n        name: str,\n        expected_final_name: str,\n        skip_registration_form: bool,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        expect_confirm_registration_page: bool = False,\n        expect_full_name_prepopulated: bool = True,\n    ) -> None:\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], email)\n        self.assertEqual(data[\"full_name\"], name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        result = self.client_get(result.url)\n\n        if expect_confirm_registration_page:\n            self.assertEqual(result.status_code, 200)\n        else:\n            self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().last()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        if expect_confirm_registration_page:\n            self.assert_in_success_response([\"do_confirm/\" + confirmation_key], result)\n            do_confirm_url = \"/accounts/do_confirm/\" + confirmation_key\n        else:\n            self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n            do_confirm_url = result.url\n        result = self.client_get(do_confirm_url, name=name)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        confirmation_data = {\"from_confirmation\": \"1\", \"key\": confirmation_key}\n        result = self.client_post(\"/accounts/register/\", confirmation_data)\n        if not skip_registration_form:\n            self.assert_in_response(\"We just need you to do one last thing\", result)\n\n            # Verify that the user is asked for name but not password\n            self.assert_not_in_success_response([\"id_password\"], result)\n            self.assert_in_success_response([\"id_full_name\"], result)\n            if expect_full_name_prepopulated:\n                # Verify the name field gets correctly pre-populated:\n                self.assert_in_success_response([expected_final_name], result)\n\n            # Click confirm registration button.\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\"full_name\": expected_final_name, \"key\": confirmation_key, \"terms\": True},\n            )\n\n        # Mobile and desktop flow have additional steps:\n        if mobile_flow_otp:\n            self.assertEqual(result.status_code, 302)\n            redirect_url = result[\"Location\"]\n            parsed_url = urllib.parse.urlparse(redirect_url)\n            query_params = urllib.parse.parse_qs(parsed_url.query)\n            self.assertEqual(parsed_url.scheme, \"zulip\")\n            self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n            self.assertEqual(query_params[\"email\"], [email])\n            encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n            user_api_keys = get_all_api_keys(get_user_by_delivery_email(email, realm))\n            self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), user_api_keys)\n            return\n        elif desktop_flow_otp:\n            self.verify_desktop_flow_end_page(result, email, desktop_flow_otp)\n            # Now the desktop app is logged in, continue with the logged in check.\n        else:\n            self.assertEqual(result.status_code, 302)\n\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertEqual(user_profile.full_name, expected_final_name)\n\n        self.assertFalse(user_profile.has_usable_password())\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration(self) -> None:\n        \"\"\"If the user doesn't exist yet, social auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_mobile_registration(self) -> None:\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            is_signup=True,\n            mobile_flow_otp=mobile_flow_otp,\n        )\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            name,\n            name,\n            self.BACKEND_CLASS.full_name_validated,\n            mobile_flow_otp=mobile_flow_otp,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_desktop_registration(self) -> None:\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        desktop_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            is_signup=True,\n            desktop_flow_otp=desktop_flow_otp,\n        )\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            name,\n            name,\n            self.BACKEND_CLASS.full_name_validated,\n            desktop_flow_otp=desktop_flow_otp,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_invitation_exists(self) -> None:\n        \"\"\"\n        This tests the registration flow in the case where an invitation for the user\n        was generated.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n\n        iago = self.example_user(\"iago\")\n        do_invite_users(iago, [email], [], invite_expires_in_days=2)\n\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_with_invalid_multiuse_invite(self) -> None:\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n\n        multiuse_object_key = \"invalid\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=subdomain,\n            is_signup=True,\n            expect_choose_email_screen=True,\n            multiuse_object_key=multiuse_object_key,\n        )\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result.url)\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_using_multiuse_invite(self) -> None:\n        \"\"\"If the user doesn't exist yet, social auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        stream_names = [\"new_stream_1\", \"new_stream_2\"]\n        streams = []\n        for stream_name in set(stream_names):\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        referrer = self.example_user(\"hamlet\")\n        multiuse_obj = MultiuseInvite.objects.create(realm=realm, referred_by=referrer)\n        multiuse_obj.streams.set(streams)\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_obj, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        multiuse_confirmation = Confirmation.objects.all().last()\n        assert multiuse_confirmation is not None\n        multiuse_object_key = multiuse_confirmation.confirmation_key\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        # First, try to sign up for closed realm without using an invitation\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        result = self.client_get(result.url)\n        # Verify that we're unable to sign up, since this is a closed realm\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Sign up\"], result)\n\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=subdomain,\n            is_signup=True,\n            expect_choose_email_screen=True,\n            multiuse_object_key=multiuse_object_key,\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_using_multiuse_invite_realm_validation(self) -> None:\n        \"\"\"If the user doesn't exist yet, social auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        streams: List[Stream] = []\n\n        # Generate an invitation for a different realm than the one we'll attempt to join:\n        lear_realm = get_realm(\"lear\")\n        multiuse_obj = MultiuseInvite.objects.create(\n            realm=lear_realm, referred_by=UserProfile.objects.filter(realm=lear_realm).first()\n        )\n        multiuse_obj.streams.set(streams)\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_obj, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        multiuse_confirmation = Confirmation.objects.all().last()\n        assert multiuse_confirmation is not None\n        multiuse_object_key = multiuse_confirmation.confirmation_key\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        # Now we try to use the invitation for the lear realm to join the zulip realm,\n        # which should fail.\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=subdomain,\n            is_signup=True,\n            expect_choose_email_screen=True,\n            multiuse_object_key=multiuse_object_key,\n        )\n\n        result = self.client_get(result.url)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_social_auth_registration_without_is_signup(self) -> None:\n        \"\"\"If `is_signup` is not set then a new account isn't created\"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], email)\n        self.assertEqual(data[\"full_name\"], name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        result = self.client_get(result.url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"No account found for newuser@zulip.com.\", result)\n\n    def test_social_auth_registration_without_is_signup_closed_realm(self) -> None:\n        \"\"\"If the user doesn't exist yet in closed realm, give an error\"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n        email = \"nonexisting@phantom.com\"\n        name = \"Full Name\"\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], email)\n        self.assertEqual(data[\"full_name\"], name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        result = self.client_get(result.url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response('action=\"/register/\"', result)\n        self.assert_in_response(\n            \"Your email address, {}, is not \"\n            \"in one of the domains that are allowed to register \"\n            \"for accounts in this organization.\".format(email),\n            result,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_with_ldap_populate_registration_from_confirmation(self) -> None:\n        self.init_default_ldap_database()\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        realm = get_realm(\"zulip\")\n        subdomain = \"zulip\"\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        backend_path = f\"zproject.backends.{self.BACKEND_CLASS.__name__}\"\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\n                backend_path,\n                \"zproject.backends.ZulipLDAPUserPopulator\",\n                \"zproject.backends.ZulipDummyBackend\",\n            ),\n        ), self.assertLogs(level=\"WARNING\") as log_warn:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=True,\n            )\n            # Full name should get populated from LDAP:\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                \"New LDAP fullname\",\n                skip_registration_form=True,\n            )\n\n            # Now try a user that doesn't exist in LDAP:\n            email = self.nonreg_email(\"alice\")\n            name = \"Alice Social\"\n            account_data_dict = self.get_account_data_dict(email=email, name=name)\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=True,\n            )\n            # Full name should get populated as provided by the social backend, because\n            # this user isn't in the LDAP dictionary:\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                skip_registration_form=self.BACKEND_CLASS.full_name_validated,\n            )\n        self.assertEqual(\n            log_warn.output, [f\"WARNING:root:New account email {email} could not be found in LDAP\"]\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_with_ldap_auth_registration_from_confirmation(self) -> None:\n        \"\"\"\n        This test checks that in configurations that use the LDAP authentication backend\n        and a social backend, it is possible to create non-LDAP users via the social backend.\n        \"\"\"\n        self.init_default_ldap_database()\n        email = self.nonreg_email(\"alice\")\n        name = \"Alice Social\"\n        realm = get_realm(\"zulip\")\n        subdomain = \"zulip\"\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        backend_path = f\"zproject.backends.{self.BACKEND_CLASS.__name__}\"\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\n                backend_path,\n                \"zproject.backends.ZulipLDAPAuthBackend\",\n                \"zproject.backends.ZulipDummyBackend\",\n            ),\n        ), self.assertLogs(\"zulip.ldap\", level=\"DEBUG\") as log_debug, self.assertLogs(\n            level=\"WARNING\"\n        ) as log_warn:\n            account_data_dict = self.get_account_data_dict(email=email, name=name)\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=True,\n            )\n            # Full name should get populated as provided by the social backend, because\n            # this user isn't in the LDAP dictionary:\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                skip_registration_form=self.BACKEND_CLASS.full_name_validated,\n            )\n        self.assertEqual(\n            log_warn.output, [f\"WARNING:root:New account email {email} could not be found in LDAP\"]\n        )\n        self.assertEqual(\n            log_debug.output,\n            [\n                f\"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: {email}. Input username: {email}\"\n            ],\n        )\n\n    def test_social_auth_complete(self) -> None:\n        with mock.patch(\n            \"social_core.backends.oauth.BaseOAuth2.process_error\",\n            side_effect=AuthFailed(\"Not found\"),\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(reverse(\"social:complete\", args=[self.backend.name]))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\"AuthFailed: Authentication failed: \", \"info\"),\n            ],\n        )\n\n        with mock.patch(\n            \"social_core.backends.oauth.BaseOAuth2.auth_complete\",\n            side_effect=requests.exceptions.HTTPError,\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(reverse(\"social:complete\", args=[self.backend.name]))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\"HTTPError: \", \"info\"),\n            ],\n        )\n\n    def test_social_auth_complete_when_base_exc_is_raised(self) -> None:\n        with mock.patch(\n            \"social_core.backends.oauth.BaseOAuth2.auth_complete\",\n            side_effect=AuthStateForbidden(\"State forbidden\"),\n        ), self.assertLogs(self.logger_string, level=\"WARNING\"):\n            result = self.client_get(reverse(\"social:complete\", args=[self.backend.name]))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_invited_as_admin_but_expired(self) -> None:\n        iago = self.example_user(\"iago\")\n        email = self.nonreg_email(\"alice\")\n        name = \"Alice Jones\"\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            iago,\n            [email],\n            [],\n            invite_expires_in_days=invite_expires_in_days,\n            invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"],\n        )\n        now = timezone_now() + datetime.timedelta(days=invite_expires_in_days + 1)\n\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        with mock.patch(\"zerver.models.timezone_now\", return_value=now):\n            self.stage_two_of_registration(\n                result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n            )\n\n        # The invitation is expired, so the user should be created as normal member only.\n        created_user = get_user_by_delivery_email(email, realm)\n        self.assertEqual(created_user.role, UserProfile.ROLE_MEMBER)\n\n\nclass SAMLAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = SAMLAuthBackend\n    LOGIN_URL = \"/accounts/login/social/saml/test_idp\"\n    SIGNUP_URL = \"/accounts/register/social/saml/test_idp\"\n    AUTHORIZATION_URL = \"https://idp.testshib.org/idp/profile/SAML2/Redirect/SSO\"\n    AUTH_FINISH_URL = \"/complete/saml/\"\n\n    # We have to define our own social_auth_test as the flow of SAML authentication\n    # is different from the other social backends.\n    def social_auth_test(\n        self,\n        account_data_dict: Dict[str, str],\n        *,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        user_agent: Optional[str] = None,\n        extra_attributes: Mapping[str, List[str]] = {},\n        **extra_data: Any,\n    ) -> HttpResponse:\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            user_agent=user_agent,\n        )\n\n        result = self.client_get(url, **headers)\n\n        expected_result_url_prefix = f\"http://testserver/login/{self.backend.name}/\"\n        if settings.SOCIAL_AUTH_SUBDOMAIN is not None:\n            expected_result_url_prefix = (\n                f\"http://{settings.SOCIAL_AUTH_SUBDOMAIN}.testserver/login/{self.backend.name}/\"\n            )\n\n        if result.status_code != 302 or not result.url.startswith(expected_result_url_prefix):\n            return result\n\n        result = self.client_get(result.url, **headers)\n\n        self.assertEqual(result.status_code, 302)\n        assert self.AUTHORIZATION_URL in result.url\n        assert \"samlrequest\" in result.url.lower()\n\n        self.client.cookies = result.cookies\n        parsed_url = urllib.parse.urlparse(result.url)\n        relay_state = urllib.parse.parse_qs(parsed_url.query)[\"RelayState\"][0]\n        # Make sure params are getting encoded into RelayState:\n        data = SAMLAuthBackend.get_data_from_redis(orjson.loads(relay_state)[\"state_token\"])\n        assert data is not None\n        if next:\n            self.assertEqual(data[\"next\"], next)\n        if is_signup:\n            self.assertEqual(data[\"is_signup\"], \"1\")\n\n        saml_response = self.generate_saml_response(\n            email=account_data_dict[\"email\"],\n            name=account_data_dict[\"name\"],\n            extra_attributes=extra_attributes,\n        )\n        post_params = {\"SAMLResponse\": saml_response, \"RelayState\": relay_state}\n        # The mock below is necessary, so that python3-saml accepts our SAMLResponse,\n        # and doesn't verify the cryptographic signatures etc., since generating\n        # a perfectly valid SAMLResponse for the purpose of these tests would be too complex,\n        # and we simply use one loaded from a fixture file.\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We are simulating a cross-domain POST request here. Session is a Lax cookie, meaning\n            # it won't be sent by the browser in this request. To simulate that effect with the django\n            # test client, we flush the session before the request.\n            self.client.session.flush()\n            result = self.client_post(self.AUTH_FINISH_URL, post_params, **headers)\n\n        return result\n\n    def generate_saml_response(\n        self, email: str, name: str, extra_attributes: Mapping[str, List[str]] = {}\n    ) -> str:\n        \"\"\"\n        The samlresponse.txt fixture has a pre-generated SAMLResponse,\n        with {email}, {first_name}, {last_name} placeholders, that can\n        be filled out with the data we want.\n        \"\"\"\n        if name:\n            name_parts = name.split(\" \")\n            first_name = name_parts[0]\n            last_name = name_parts[1]\n        else:\n            first_name = \"\"\n            last_name = \"\"\n\n        extra_attrs = \"\"\n        for extra_attr_name, extra_attr_values in extra_attributes.items():\n            values = \"\".join(\n                '<saml2:AttributeValue xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" '\n                + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"xs:string\">'\n                + f\"{value}</saml2:AttributeValue>\"\n                for value in extra_attr_values\n            )\n            extra_attrs += (\n                f'<saml2:Attribute Name=\"{extra_attr_name}\" '\n                + 'NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\">'\n                + f\"{values}</saml2:Attribute>\"\n            )\n\n        unencoded_saml_response = self.fixture_data(\"samlresponse.txt\", type=\"saml\").format(\n            email=email,\n            first_name=first_name,\n            last_name=last_name,\n            extra_attrs=extra_attrs,\n        )\n        # SAMLResponse needs to be base64-encoded.\n        saml_response: str = base64.b64encode(unencoded_saml_response.encode()).decode()\n\n        return saml_response\n\n    def generate_saml_logout_request_from_idp(self, email: str) -> str:\n        \"\"\"\n        The logoutrequest.txt fixture has a pre-generated LogoutRequest,\n        with {email} placeholder, that can\n        be filled out with the data we want.\n        \"\"\"\n        unencoded_logout_request = self.fixture_data(\"logoutrequest.txt\", type=\"saml\").format(\n            email=email,\n        )\n        logout_request: str = base64.b64encode(unencoded_logout_request.encode()).decode()\n\n        return logout_request\n\n    def make_idp_initiated_logout_request(\n        self, email: str, make_validity_checks_pass: bool = True\n    ) -> HttpResponse:\n        samlrequest = self.generate_saml_logout_request_from_idp(email)\n        parameters = {\"SAMLRequest\": samlrequest}\n\n        if make_validity_checks_pass:\n            # It's hard to create fully-correct LogoutRequests with signatures in tests,\n            # so we rely on mocking the validating functions instead.\n            with mock.patch.object(\n                OneLogin_Saml2_Logout_Request, \"is_valid\", return_value=True\n            ), mock.patch.object(\n                OneLogin_Saml2_Auth,\n                \"validate_request_signature\",\n                return_value=True,\n            ):\n                result = self.client_get(\"http://zulip.testserver/complete/saml/\", parameters)\n        else:\n            result = self.client_get(\"http://zulip.testserver/complete/saml/\", parameters)\n        return result\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        return dict(email=email, name=name)\n\n    def test_saml_idp_initiated_logout_success(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        old_api_key = hamlet.api_key\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        result = self.make_idp_initiated_logout_request(hamlet.delivery_email)\n        self.assert_logged_in_user_id(None)\n\n        # The expected response is a redirect to the IdP's slo_url endpoint\n        # with a SAMLResponse announcing success.\n        self.assertEqual(result.status_code, 302)\n        redirect_to = result[\"Location\"]\n        self.assertIn(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS[\"test_idp\"][\"slo_url\"], redirect_to)\n\n        parsed = urllib.parse.urlparse(redirect_to)\n        query_dict = urllib.parse.parse_qs(parsed.query)\n\n        self.assertIn(\"SAMLResponse\", query_dict)\n        # Do some very basic parsing of the SAMLResponse to verify it's a success response.\n        saml_response_encoded = query_dict[\"SAMLResponse\"][0]\n        saml_response = OneLogin_Saml2_Utils.decode_base64_and_inflate(\n            saml_response_encoded\n        ).decode()\n        self.assertIn(\n            '<samlp:StatusCode Value=\"urn:oasis:names:tc:SAML:2.0:status:Success\" />', saml_response\n        )\n\n        hamlet.refresh_from_db()\n        # Ensure that the user's api_key was rotated:\n        self.assertNotEqual(hamlet.api_key, old_api_key)\n\n    def test_saml_idp_initiated_logout_request_for_different_user(self) -> None:\n        \"\"\"\n        This test verifies that sessions are revoked based on the NameID\n        in the LogoutRequest rather than just the logged in session cookie.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n        cordelia_old_api_key = cordelia.api_key\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        # We're logged in as hamlet, but deliver a LogoutRequest for cordelia.\n        # This means our session should not be affected.\n        self.make_idp_initiated_logout_request(cordelia.delivery_email)\n        self.assert_logged_in_user_id(hamlet.id)\n\n        cordelia.refresh_from_db()\n        # Cordelia's api_key should have been rotated:\n        self.assertNotEqual(cordelia.api_key, cordelia_old_api_key)\n\n    def test_saml_idp_initiated_logout_invalid_nameid_format(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            # LogoutRequests need to have the email address in NameID\n            # so putting \"hamlet\" there is invalid.\n            result = self.make_idp_initiated_logout_request(\"hamlet\")\n        self.assert_logged_in_user_id(hamlet.id)\n\n        self.assertEqual(\n            mock_logger.output,\n            [\n                \"INFO:zulip.auth.saml:/complete/saml/: LogoutRequest failed: NameID is not a valid email address: hamlet\"\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/\")\n\n    def test_saml_idp_initiated_logout_user_not_in_realm(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            result = self.make_idp_initiated_logout_request(\"nonexistent@zulip.com\")\n        self.assert_logged_in_user_id(hamlet.id)\n\n        self.assertEqual(\n            mock_logger.output,\n            [\n                \"INFO:zulip.auth.saml:/complete/saml/: LogoutRequest failed: No user with email specified in NameID found in realm 2. return_data={}\"\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/\")\n\n    def test_saml_idp_initiated_logout_invalid_signature(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        self.login(\"hamlet\")\n\n        self.assert_logged_in_user_id(hamlet.id)\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            # LogoutRequests  we generate in tests don't have signatures. We can use\n            # the make_validity_checks_pass argument to disable mocking of python3-saml\n            # internal validation functions to make validation of our LogoutRequest fail\n            # and test our error-handling of that.\n            result = self.make_idp_initiated_logout_request(\n                hamlet.delivery_email, make_validity_checks_pass=False\n            )\n        self.assert_logged_in_user_id(hamlet.id)\n\n        self.assertEqual(\n            mock_logger.output,\n            [\n                \"INFO:zulip.auth.saml:/complete/saml/: LogoutRequest failed: ['invalid_logout_request_signature', 'Signature validation failed. Logout Request rejected']\"\n            ],\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/\")\n\n    def test_saml_idp_initiate_logout_invalid_logout_response(self) -> None:\n        parameters = {\"SAMLRequest\": \"this is not a valid SAMLRequest string.\"}\n        with self.assertLogs(\"zulip.auth.saml\") as mock_logger:\n            result = self.client_get(\"http://zulip.testserver/complete/saml/\", parameters)\n\n        self.assertIn(\n            \"ERROR:zulip.auth.saml:Error parsing SAMLRequest: Start tag expected, '<' not found\",\n            mock_logger.output[0],\n        )\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/login/\")\n\n    def test_auth_registration_with_no_name_provided(self) -> None:\n        \"\"\"\n        The SAMLResponse may not actually provide name values, which is considered\n        unexpected behavior for most social backends, but SAML is an exception. The\n        signup flow should proceed normally, without pre-filling the name in the\n        registration form.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=\"\")\n        result = self.social_auth_test(account_data_dict, subdomain=subdomain, is_signup=True)\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            \"\",\n            \"Full Name\",\n            skip_registration_form=False,\n            expect_full_name_prepopulated=False,\n        )\n\n    def test_social_auth_no_key(self) -> None:\n        \"\"\"\n        Since in the case of SAML there isn't a direct equivalent of CLIENT_KEY_SETTING,\n        we override this test, to test for the case where the obligatory\n        SOCIAL_AUTH_SAML_ENABLED_IDPS isn't configured.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=None):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n            # Test the signup path too:\n            result = self.social_auth_test(\n                account_data_dict, is_signup=True, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n    def test_config_error_page(self) -> None:\n        with self.assertLogs(level=\"INFO\") as info_log:\n            result = self.client_get(\"/accounts/login/social/saml\")\n        self.assertEqual(\n            info_log.output,\n            [\"INFO:root:Attempted to initiate SAML authentication with wrong idp argument: None\"],\n        )\n        self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n    def test_saml_auth_works_without_private_public_keys(self) -> None:\n        with self.settings(SOCIAL_AUTH_SAML_SP_PUBLIC_CERT=\"\", SOCIAL_AUTH_SAML_SP_PRIVATE_KEY=\"\"):\n            self.test_social_auth_success()\n\n    def test_saml_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.SAMLAuthBackend\",)):\n            self.assertTrue(saml_auth_enabled())\n            result = self.client_get(\"/saml/metadata.xml\")\n            self.assert_in_success_response(\n                [f'entityID=\"{settings.SOCIAL_AUTH_SAML_SP_ENTITY_ID}\"'],\n                result,\n            )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_auto_signup(self) -> None:\n        \"\"\"\n        Verify that with SAML auto signup enabled, a user coming from the /login page\n        (so without the is_signup param) will be taken straight to registration, without\n        having to go through the step of having to confirm that they do want to sign up.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"auto_signup\"] = True\n\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=False,\n            )\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                self.BACKEND_CLASS.full_name_validated,\n                expect_confirm_registration_page=False,\n            )\n\n    def test_social_auth_complete(self) -> None:\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            with mock.patch.object(\n                OneLogin_Saml2_Auth, \"is_authenticated\", return_value=False\n            ), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                # This mock causes AuthFailed to be raised.\n                saml_response = self.generate_saml_response(self.email, self.name)\n                relay_state = orjson.dumps(\n                    dict(\n                        state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                    )\n                ).decode()\n                post_params = {\"SAMLResponse\": saml_response, \"RelayState\": relay_state}\n                result = self.client_post(\"/complete/saml/\", post_params)\n                self.assertEqual(result.status_code, 302)\n                self.assertIn(\"login\", result.url)\n            self.assertEqual(\n                m.output,\n                [\n                    self.logger_output(\n                        \"AuthFailed: Authentication failed: SAML login failed: [] (None)\", \"info\"\n                    )\n                ],\n            )\n\n    def test_social_auth_complete_when_base_exc_is_raised(self) -> None:\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            with mock.patch(\n                \"social_core.backends.saml.SAMLAuth.auth_complete\",\n                side_effect=AuthStateForbidden(\"State forbidden\"),\n            ), self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n                saml_response = self.generate_saml_response(self.email, self.name)\n                relay_state = orjson.dumps(\n                    dict(\n                        state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                    )\n                ).decode()\n                post_params = {\"SAMLResponse\": saml_response, \"RelayState\": relay_state}\n                result = self.client_post(\"/complete/saml/\", post_params)\n                self.assertEqual(result.status_code, 302)\n                self.assertIn(\"login\", result.url)\n            self.assertEqual(\n                m.output, [self.logger_output(\"Wrong state parameter given.\", \"warning\")]\n            )\n\n    def test_social_auth_complete_bad_params(self) -> None:\n        # Simple GET for /complete/saml without the required parameters.\n        # This tests the auth_complete wrapped in our SAMLAuthBackend,\n        # ensuring it prevents this requests from causing an internal server error.\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(\"/complete/saml/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: No SAMLResponse or SAMLRequest in request.\", \"info\"\n                )\n            ],\n        )\n\n        # Check that POSTing the RelayState, but with missing SAMLResponse,\n        # doesn't cause errors either:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\"RelayState\": relay_state}\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: No SAMLResponse or SAMLRequest in request.\", \"info\"\n                )\n            ],\n        )\n\n        # Now test bad SAMLResponses.\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\"RelayState\": relay_state, \"SAMLResponse\": \"\"}\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertTrue(m.output != \"\")\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\"RelayState\": relay_state, \"SAMLResponse\": \"b\"}\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertTrue(m.output != \"\")\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\n                \"RelayState\": relay_state,\n                \"SAMLResponse\": base64.b64encode(b\"test\").decode(),\n            }\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertTrue(m.output != \"\")\n\n    def test_social_auth_complete_no_subdomain(self) -> None:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            post_params = {\n                \"RelayState\": \"\",\n                \"SAMLResponse\": self.generate_saml_response(\n                    email=self.example_email(\"hamlet\"), name=\"King Hamlet\"\n                ),\n            }\n            with mock.patch.object(SAMLAuthBackend, \"choose_subdomain\", return_value=None):\n                result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: Can't figure out subdomain for this SAMLResponse. relayed_params: {}\".format(\n                        \"{}\"\n                    ),\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_complete_wrong_issuing_idp(self) -> None:\n        relay_state = orjson.dumps(\n            dict(\n                state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n            )\n        ).decode()\n        saml_response = self.generate_saml_response(\n            email=self.example_email(\"hamlet\"), name=\"King Hamlet\"\n        )\n\n        # We change the entity_id of the configured test IdP, which means it won't match\n        # the Entity ID in the SAMLResponse generated above.\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"entity_id\"] = \"https://different.idp.example.com/\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                post_params = {\"RelayState\": relay_state, \"SAMLResponse\": saml_response}\n                result = self.client_post(\"/complete/saml/\", post_params)\n                self.assertEqual(result.status_code, 302)\n                self.assertEqual(\"/login/\", result.url)\n            self.assertEqual(\n                m.output,\n                [\n                    self.logger_output(\n                        \"/complete/saml/: No valid IdP as issuer of the SAMLResponse.\", \"info\"\n                    )\n                ],\n            )\n\n    def test_social_auth_complete_valid_get_idp_bad_samlresponse(self) -> None:\n        \"\"\"\n        This tests for a hypothetical scenario where our basic parsing of the SAMLResponse\n        successfully returns the issuing IdP, but it fails further down the line, during proper\n        validation in the underlying libraries.\n        \"\"\"\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m, mock.patch.object(\n            SAMLDocument, \"get_issuing_idp\", return_value=\"test_idp\"\n        ):\n            relay_state = orjson.dumps(\n                dict(\n                    state_token=SAMLAuthBackend.put_data_in_redis({\"subdomain\": \"zulip\"}),\n                )\n            ).decode()\n            post_params = {\n                \"RelayState\": relay_state,\n                \"SAMLResponse\": base64.b64encode(b\"test\").decode(),\n            }\n            result = self.client_post(\"/complete/saml/\", post_params)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n\n        self.assertTrue(m.output != \"\")\n\n    def test_social_auth_saml_bad_idp_param_on_login_page(self) -> None:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(\"/login/saml/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/login/saml/ : Bad idp param: KeyError: {}.\".format(\"'idp'\"), \"info\"\n                )\n            ],\n        )\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(\"/login/saml/\", {\"idp\": \"bad_idp\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/login/saml/ : Bad idp param: KeyError: {}.\".format(\"'bad_idp'\"), \"info\"\n                )\n            ],\n        )\n\n    def test_social_auth_invalid_email(self) -> None:\n        \"\"\"\n        This test needs an override from the original class. For security reasons,\n        the 'next' and 'mobile_flow_otp' params don't get passed on in the session\n        if the authentication attempt failed. See SAMLAuthBackend.auth_complete for details.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=\"invalid\", name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, \"WARNING\") as warn_log:\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                next=\"/user_uploads/image\",\n            )\n        self.assertEqual(\n            warn_log.output, [self.logger_output(\"SAML got invalid email argument.\", \"warning\")]\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, realm.uri + \"/register/\")\n\n    def test_social_auth_saml_multiple_idps_configured(self) -> None:\n        # Set up a new SOCIAL_AUTH_SAML_ENABLED_IDPS dict with two idps.\n        # We deepcopy() dictionaries around for the sake of brevity,\n        # to avoid having to spell them out explicitly here.\n        # The second idp's configuration is a copy of the first one,\n        # with name test_idp2 and altered url. It is also configured to be\n        # limited to the zulip realm, so that we get to test both types\n        # of configs here.\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp2\"] = copy.deepcopy(idps_dict[\"test_idp\"])\n        idps_dict[\"test_idp2\"][\"url\"] = \"https://idp2.example.com/idp/profile/SAML2/Redirect/SSO\"\n        idps_dict[\"test_idp2\"][\"display_name\"] = \"Second Test IdP\"\n        idps_dict[\"test_idp2\"][\"limit_to_subdomains\"] = [\"zulip\"]\n\n        # Run tests with multiple idps configured:\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            # Go to the login page and check that buttons to log in show up for both IdPs:\n            result = self.client_get(\"/accounts/login/\")\n            self.assert_in_success_response([\"Log in with Test IdP\"], result)\n            self.assert_in_success_response([\"/accounts/login/social/saml/test_idp\"], result)\n            self.assert_in_success_response([\"Log in with Second Test IdP\"], result)\n            self.assert_in_success_response([\"/accounts/login/social/saml/test_idp2\"], result)\n\n            # Try successful authentication with the regular idp from all previous tests:\n            self.test_social_auth_success()\n\n            # Now test with the second idp:\n            original_LOGIN_URL = self.LOGIN_URL\n            original_SIGNUP_URL = self.SIGNUP_URL\n            original_AUTHORIZATION_URL = self.AUTHORIZATION_URL\n            self.LOGIN_URL = \"/accounts/login/social/saml/test_idp2\"\n            self.SIGNUP_URL = \"/accounts/register/social/saml/test_idp2\"\n            self.AUTHORIZATION_URL = idps_dict[\"test_idp2\"][\"url\"]\n\n            try:\n                self.test_social_auth_success()\n            finally:\n                # Restore original values at the end, regardless of what happens\n                # in the block above, to avoid affecting other tests in unpredictable\n                # ways.\n                self.LOGIN_URL = original_LOGIN_URL\n                self.SIGNUP_URL = original_SIGNUP_URL\n                self.AUTHORIZATION_URL = original_AUTHORIZATION_URL\n\n    def test_social_auth_saml_idp_limited_to_subdomains_success(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"limit_to_subdomains\"] = [\"zulip\"]\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            self.test_social_auth_success()\n\n    def test_social_auth_saml_idp_limited_to_subdomains_attempt_wrong_realm(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"limit_to_subdomains\"] = [\"zulip\"]\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                result = self.social_auth_test(account_data_dict, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: Authentication request with IdP test_idp but this provider is not enabled \"\n                    \"for this subdomain zephyr.\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_saml_login_bad_idp_arg(self) -> None:\n        for action in [\"login\", \"register\"]:\n            with self.assertLogs(level=\"INFO\") as info_log:\n                result = self.client_get(f\"/accounts/{action}/social/saml\")\n            # Missing idp argument.\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n            self.assertEqual(\n                info_log.output,\n                [\n                    \"INFO:root:Attempted to initiate SAML authentication with wrong idp argument: None\"\n                ],\n            )\n\n            with self.assertLogs(level=\"INFO\") as info_log:\n                result = self.client_get(f\"/accounts/{action}/social/saml/nonexistent_idp\")\n            # No such IdP is configured.\n            self.assertEqual(\n                info_log.output,\n                [\n                    \"INFO:root:Attempted to initiate SAML authentication with wrong idp argument: nonexistent_idp\"\n                ],\n            )\n            self.assert_in_success_response([\"Configuration error\", \"SAML authentication\"], result)\n\n            result = self.client_get(f\"/accounts/{action}/social/saml/\")\n            # No matching URL pattern.\n            self.assertEqual(result.status_code, 404)\n\n    def test_social_auth_saml_require_limit_to_subdomains(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp2\"] = copy.deepcopy(idps_dict[\"test_idp\"])\n        idps_dict[\"test_idp2\"][\"url\"] = \"https://idp2.example.com/idp/profile/SAML2/Redirect/SSO\"\n        idps_dict[\"test_idp2\"][\"display_name\"] = \"Second Test IdP\"\n        idps_dict[\"test_idp2\"][\"limit_to_subdomains\"] = [\"zulip\"]\n\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict, SAML_REQUIRE_LIMIT_TO_SUBDOMAINS=True\n        ):\n            with self.assertLogs(self.logger_string, level=\"ERROR\") as m:\n                # Initialization of the backend should validate the configured IdPs\n                # with respect to the SAML_REQUIRE_LIMIT_TO_SUBDOMAINS setting and remove\n                # the non-compliant ones.\n                SAMLAuthBackend()\n            self.assertEqual(list(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS.keys()), [\"test_idp2\"])\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"SAML_REQUIRE_LIMIT_TO_SUBDOMAINS is enabled and the following \"\n                    \"IdPs don't have limit_to_subdomains specified and will be ignored: \"\n                    \"['test_idp']\",\n                    \"error\",\n                )\n            ],\n        )\n\n    def test_idp_initiated_signin_subdomain_specified(self) -> None:\n        post_params = {\n            \"RelayState\": '{\"subdomain\": \"zulip\"}',\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"/complete/saml/\", post_params)\n\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.client_get(uri)\n        self.assert_logged_in_user_id(self.example_user(\"hamlet\").id)\n\n    def test_choose_subdomain_invalid_subdomain_specified(self) -> None:\n        post_params = {\n            \"RelayState\": '{\"subdomain\": \"invalid\"}',\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"/complete/saml/\", post_params)\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/\")\n\n    def test_idp_initiated_signin_subdomain_implicit(self) -> None:\n        post_params = {\n            \"RelayState\": \"\",\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"http://zulip.testserver/complete/saml/\", post_params)\n\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.client_get(uri)\n        self.assert_logged_in_user_id(self.example_user(\"hamlet\").id)\n\n    def test_idp_initiated_signin_subdomain_implicit_no_relaystate_param(self) -> None:\n        post_params = {\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with mock.patch.object(OneLogin_Saml2_Response, \"is_valid\", return_value=True):\n            # We're not able to generate valid signatures in tests, so we need the mock.\n            result = self.client_post(\"http://zulip.testserver/complete/saml/\", post_params)\n\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n        self.client_get(uri)\n        self.assert_logged_in_user_id(self.example_user(\"hamlet\").id)\n\n    def test_idp_initiated_signin_subdomain_implicit_invalid(self) -> None:\n        post_params = {\n            \"RelayState\": \"\",\n            \"SAMLResponse\": self.generate_saml_response(email=self.email, name=self.name),\n        }\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            with mock.patch(\"zproject.backends.get_subdomain\", return_value=\"invalid\"):\n                # Due to the quirks of our test setup, get_subdomain on all these `some_subdomain.testserver`\n                # requests returns 'zulip', so we need to mock it here.\n                result = self.client_post(\"http://invalid.testserver/complete/saml/\", post_params)\n\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/saml/: Can't figure out subdomain for this SAMLResponse. relayed_params: {}\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_saml_idp_org_membership_success(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"attr_org_membership\"] = \"member\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=False,\n                extra_attributes=dict(member=[\"zulip\"]),\n            )\n            data = load_subdomain_token(result)\n            self.assertEqual(data[\"email\"], self.email)\n            self.assertEqual(data[\"full_name\"], self.name)\n            self.assertEqual(data[\"subdomain\"], \"zulip\")\n            self.assertEqual(result.status_code, 302)\n\n    def test_social_auth_saml_idp_org_membership_root_subdomain(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.string_id = \"\"\n        realm.save()\n\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"attr_org_membership\"] = \"member\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            # Having one of the settings.ROOT_SUBDOMAIN_ALIASES in the membership attributes\n            # authorizes the user to access the root subdomain.\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"\",\n                expect_choose_email_screen=False,\n                extra_attributes=dict(member=[\"www\"]),\n            )\n            data = load_subdomain_token(result)\n            self.assertEqual(data[\"email\"], self.email)\n            self.assertEqual(data[\"full_name\"], self.name)\n            self.assertEqual(data[\"subdomain\"], \"\")\n            self.assertEqual(result.status_code, 302)\n\n            # Failure, the user doesn't have entitlements for the root subdomain.\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                result = self.social_auth_test(\n                    account_data_dict,\n                    subdomain=\"\",\n                    expect_choose_email_screen=False,\n                    extra_attributes=dict(member=[\"zephyr\"]),\n                )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                m.output,\n                [\n                    self.logger_output(\n                        \"AuthFailed: Authentication failed: SAML user from IdP test_idp rejected due to \"\n                        + \"missing entitlement for subdomain ''. User entitlements: ['zephyr'].\",\n                        \"info\",\n                    )\n                ],\n            )\n\n    def test_social_auth_saml_idp_org_membership_failed(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"attr_org_membership\"] = \"member\"\n        with self.settings(SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n                result = self.social_auth_test(\n                    account_data_dict,\n                    subdomain=\"zulip\",\n                    extra_attributes=dict(member=[\"zephyr\", \"othersubdomain\"]),\n                )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/login/\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"AuthFailed: Authentication failed: SAML user from IdP test_idp rejected due to \"\n                    + \"missing entitlement for subdomain 'zulip'. User entitlements: ['zephyr', 'othersubdomain'].\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_social_auth_custom_profile_field_sync(self) -> None:\n        birthday_field = CustomProfileField.objects.get(\n            realm=self.user_profile.realm, name=\"Birthday\"\n        )\n        old_birthday_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=self.user_profile, field=birthday_field\n        ).value\n\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"extra_attrs\"] = [\"mobilePhone\"]\n\n        sync_custom_attrs_dict = {\n            \"zulip\": {\n                \"saml\": {\n                    \"phone_number\": \"mobilePhone\",\n                }\n            }\n        }\n\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict,\n            SOCIAL_AUTH_SYNC_CUSTOM_ATTRS_DICT=sync_custom_attrs_dict,\n        ):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                extra_attributes=dict(mobilePhone=[\"123412341234\"], birthday=[\"2021-01-01\"]),\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.email)\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n\n        phone_field = CustomProfileField.objects.get(\n            realm=self.user_profile.realm, name=\"Phone number\"\n        )\n        phone_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=self.user_profile, field=phone_field\n        ).value\n        self.assertEqual(phone_field_value, \"123412341234\")\n\n        # Verify the Birthday field doesn't get synced - because it isn't configured for syncing.\n        new_birthday_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=self.user_profile, field=birthday_field\n        ).value\n        self.assertEqual(new_birthday_field_value, old_birthday_field_value)\n\n    def test_social_auth_custom_profile_field_sync_custom_field_not_existing(self) -> None:\n        sync_custom_attrs_dict = {\n            \"zulip\": {\n                \"saml\": {\n                    \"title\": \"title\",\n                    \"phone_number\": \"mobilePhone\",\n                }\n            }\n        }\n        self.assertFalse(\n            CustomProfileField.objects.filter(\n                realm=self.user_profile.realm, name__iexact=\"title\"\n            ).exists()\n        )\n\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        idps_dict[\"test_idp\"][\"extra_attrs\"] = [\"mobilePhone\", \"title\"]\n\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict,\n            SOCIAL_AUTH_SYNC_CUSTOM_ATTRS_DICT=sync_custom_attrs_dict,\n        ):\n            account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n            with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n                result = self.social_auth_test(\n                    account_data_dict,\n                    subdomain=\"zulip\",\n                    extra_attributes=dict(mobilePhone=[\"123412341234\"], birthday=[\"2021-01-01\"]),\n                )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.email)\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Exception while syncing custom profile fields for \"\n                    + f\"user {self.user_profile.id}: Custom profile field with name title not found.\",\n                    \"warning\",\n                )\n            ],\n        )\n\n\nclass AppleAuthMixin:\n    BACKEND_CLASS = AppleAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_APPLE_KEY\"\n    AUTHORIZATION_URL = \"https://appleid.apple.com/auth/authorize\"\n    ACCESS_TOKEN_URL = \"https://appleid.apple.com/auth/token\"\n    AUTH_FINISH_URL = \"/complete/apple/\"\n\n    def generate_id_token(\n        self, account_data_dict: Dict[str, str], audience: Optional[str] = None\n    ) -> str:\n        payload = dict(email=account_data_dict[\"email\"])\n\n        # This setup is important because python-social-auth decodes `id_token`\n        # with `SOCIAL_AUTH_APPLE_CLIENT` as the `audience`\n        payload[\"aud\"] = settings.SOCIAL_AUTH_APPLE_CLIENT\n\n        if audience is not None:\n            payload[\"aud\"] = audience\n\n        headers = {\"kid\": \"SOMEKID\"}\n        private_key = settings.APPLE_ID_TOKEN_GENERATION_KEY\n\n        id_token = jwt.encode(payload, private_key, algorithm=\"RS256\", headers=headers)\n\n        return id_token\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        name_parts = name.split(\" \")\n        first_name = name_parts[0]\n        last_name = \"\"\n        if len(name_parts) > 0:\n            last_name = name_parts[-1]\n        name_dict = {\"firstName\": first_name, \"lastName\": last_name}\n        return dict(email=email, name=name_dict, email_verified=True)\n\n\nclass AppleIdAuthBackendTest(AppleAuthMixin, SocialAuthBase):\n    __unittest_skip__ = False\n\n    LOGIN_URL = \"/accounts/login/social/apple\"\n    SIGNUP_URL = \"/accounts/register/social/apple\"\n\n    # This URL isn't used in the Apple auth flow, so we just set a\n    # dummy value to keep SocialAuthBase common code happy.\n    USER_INFO_URL = \"/invalid-unused-url\"\n\n    def social_auth_test_finish(\n        self,\n        result: HttpResponse,\n        account_data_dict: Dict[str, str],\n        expect_choose_email_screen: bool,\n        headers: Any,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        parsed_url = urllib.parse.urlparse(result.url)\n        state = urllib.parse.parse_qs(parsed_url.query)[\"state\"]\n        user_param = json.dumps(account_data_dict)\n        self.client.session.flush()\n        result = self.client_post(\n            self.AUTH_FINISH_URL, dict(state=state, user=user_param), **headers\n        )\n        return result\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        # This is an URL of an endpoint on Apple servers that returns\n        # the public keys to be used for verifying the signature\n        # on the JWT id_token.\n        requests_mock.add(\n            requests_mock.GET,\n            self.BACKEND_CLASS.JWK_URL,\n            status=200,\n            json=json.loads(settings.EXAMPLE_JWK),\n        )\n\n    def generate_access_token_url_payload(self, account_data_dict: Dict[str, str]) -> str:\n        # The ACCESS_TOKEN_URL endpoint works a bit different than in standard Oauth2,\n        # and here, similarly to OIDC, id_token is also returned in the response.\n        # In Apple auth, all the user information is carried in the id_token.\n        return json.dumps(\n            {\n                \"access_token\": \"foobar\",\n                \"expires_in\": time.time() + 60 * 5,\n                \"id_token\": self.generate_id_token(account_data_dict),\n                \"token_type\": \"bearer\",\n            }\n        )\n\n    def test_apple_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.AppleAuthBackend\",)):\n            self.assertTrue(apple_auth_enabled())\n\n    def test_auth_registration_with_no_name_sent_from_apple(self) -> None:\n        \"\"\"\n        Apple doesn't send the name in consecutive attempts if user registration\n        fails the first time. This tests verifies that the social pipeline is able\n        to handle the case of the backend not providing this information.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=\"\")\n        result = self.social_auth_test(\n            account_data_dict, expect_choose_email_screen=True, subdomain=subdomain, is_signup=True\n        )\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            \"\",\n            \"Full Name\",\n            skip_registration_form=False,\n            expect_full_name_prepopulated=False,\n        )\n\n    def test_id_token_verification_failure(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            with mock.patch(\"jwt.decode\", side_effect=PyJWTError):\n                result = self.social_auth_test(\n                    account_data_dict,\n                    expect_choose_email_screen=True,\n                    subdomain=\"zulip\",\n                    is_signup=True,\n                )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"AuthFailed: Authentication failed: Token validation failed by \", \"info\"\n                ),\n            ],\n        )\n\n    def test_validate_state(self) -> None:\n        with self.assertLogs(self.logger_string, level=\"INFO\") as m:\n\n            # (1) check if auth fails if no state value is sent.\n            result = self.client_post(\"/complete/apple/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n\n            # (2) Check if auth fails when a state sent has no valid data stored in Redis.\n            fake_state = \"fa42e4ccdb630f0070c1daab70ad198d8786d4b639cd7a1b4db4d5a13c623060\"\n            result = self.client_post(\"/complete/apple/\", {\"state\": fake_state})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"login\", result.url)\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Sign in with Apple failed: missing state parameter.\", \"info\"\n                ),  # (1)\n                self.logger_output(\"Missing needed parameter state\", \"warning\"),\n                self.logger_output(\"Sign in with Apple failed: bad state token.\", \"info\"),  # (2)\n                self.logger_output(\"Wrong state parameter given.\", \"warning\"),\n            ],\n        )\n\n\nclass AppleAuthBackendNativeFlowTest(AppleAuthMixin, SocialAuthBase):\n    __unittest_skip__ = False\n\n    SIGNUP_URL = \"/complete/apple/\"\n    LOGIN_URL = \"/complete/apple/\"\n\n    def prepare_login_url_and_headers(\n        self,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        alternative_start_url: Optional[str] = None,\n        id_token: Optional[str] = None,\n        account_data_dict: Dict[str, str] = {},\n        *,\n        user_agent: Optional[str] = None,\n    ) -> Tuple[str, Dict[str, Any]]:\n        url, headers = super().prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            alternative_start_url=alternative_start_url,\n            user_agent=user_agent,\n        )\n\n        params = {\"native_flow\": \"true\"}\n\n        if id_token is not None:\n            params[\"id_token\"] = id_token\n\n        if is_signup:\n            params[\"is_signup\"] = \"1\"\n\n        if subdomain:\n            params[\"subdomain\"] = subdomain\n\n        params[\"user\"] = json.dumps(account_data_dict)\n\n        url += f\"&{urlencode(params)}\"\n        return url, headers\n\n    def social_auth_test(\n        self,\n        account_data_dict: Dict[str, str],\n        *,\n        subdomain: str,\n        mobile_flow_otp: Optional[str] = None,\n        desktop_flow_otp: Optional[str] = None,\n        is_signup: bool = False,\n        next: str = \"\",\n        multiuse_object_key: str = \"\",\n        alternative_start_url: Optional[str] = None,\n        skip_id_token: bool = False,\n        user_agent: Optional[str] = None,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        \"\"\"In Apple's native authentication flow, the client app authenticates\n        with Apple and receives the JWT id_token, before contacting\n        the Zulip server.  The app sends an appropriate request with\n        it to /complete/apple/ to get logged in.  See the backend\n        class for details.\n\n        As a result, we need a custom social_auth_test function that\n        effectively just does the second half of the flow (i.e. the\n        part after the redirect from this third-party authentication\n        provider) with a properly generated id_token.\n        \"\"\"\n\n        if not skip_id_token:\n            id_token: Optional[str] = self.generate_id_token(\n                account_data_dict, settings.SOCIAL_AUTH_APPLE_APP_ID\n            )\n        else:\n            id_token = None\n\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain,\n            mobile_flow_otp,\n            desktop_flow_otp,\n            is_signup,\n            next,\n            multiuse_object_key,\n            alternative_start_url=self.AUTH_FINISH_URL,\n            user_agent=user_agent,\n            id_token=id_token,\n            account_data_dict=account_data_dict,\n        )\n\n        with self.apple_jwk_url_mock():\n            result = self.client_get(url, **headers)\n\n        return result\n\n    @contextmanager\n    def apple_jwk_url_mock(self) -> Iterator[None]:\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as requests_mock:\n            # The server fetches public keys for validating the id_token\n            # from Apple servers. We need to mock that URL to return our key,\n            # created for these tests.\n            requests_mock.add(\n                requests_mock.GET,\n                self.BACKEND_CLASS.JWK_URL,\n                status=200,\n                json=json.loads(settings.EXAMPLE_JWK),\n            )\n            yield\n\n    def test_no_id_token_sent(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        result = self.social_auth_test(\n            account_data_dict,\n            expect_choose_email_screen=False,\n            subdomain=\"zulip\",\n            next=\"/user_uploads/image\",\n            skip_id_token=True,\n        )\n        self.assert_json_error(result, \"Missing id_token parameter\")\n\n    def test_social_auth_session_fields_cleared_correctly(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n\n        def initiate_auth(mobile_flow_otp: Optional[str] = None) -> None:\n            url, headers = self.prepare_login_url_and_headers(\n                subdomain=\"zulip\",\n                id_token=\"invalid\",\n                mobile_flow_otp=mobile_flow_otp,\n                account_data_dict=account_data_dict,\n            )\n            result = self.client_get(url, **headers)\n            self.assertEqual(result.status_code, 302)\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as info_log:\n            # Start Apple auth with mobile_flow_otp param. It should get saved into the session\n            # on SOCIAL_AUTH_SUBDOMAIN.\n            initiate_auth(mobile_flow_otp)\n\n        self.assertEqual(self.client.session[\"mobile_flow_otp\"], mobile_flow_otp)\n        self.assertEqual(\n            info_log.output,\n            [\n                self.logger_output(\n                    \"/complete/apple/: Authentication failed: Token validation failed by Not enough segments\",\n                    \"info\",\n                )\n            ],\n        )\n\n        with self.assertLogs(self.logger_string, level=\"INFO\") as info_log:\n            # Make a request without mobile_flow_otp param and verify the field doesn't persist\n            # in the session from the previous request.\n            initiate_auth()\n\n        self.assertEqual(self.client.session.get(\"mobile_flow_otp\"), None)\n        self.assertEqual(\n            info_log.output,\n            [\n                self.logger_output(\n                    \"/complete/apple/: Authentication failed: Token validation failed by Not enough segments\",\n                    \"info\",\n                )\n            ],\n        )\n\n    def test_id_token_with_invalid_aud_sent(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        url, headers = self.prepare_login_url_and_headers(\n            subdomain=\"zulip\",\n            alternative_start_url=self.AUTH_FINISH_URL,\n            id_token=self.generate_id_token(account_data_dict, audience=\"com.different.app\"),\n            account_data_dict=account_data_dict,\n        )\n\n        with self.apple_jwk_url_mock(), self.assertLogs(self.logger_string, level=\"INFO\") as m:\n            result = self.client_get(url, **headers)\n\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"/complete/apple/: Authentication failed: Token validation failed by Invalid audience\",\n                    \"info\",\n                )\n            ],\n        )\n        return result\n\n    def test_social_auth_desktop_success(self) -> None:\n        \"\"\"\n        The desktop app doesn't use the native flow currently and the desktop app flow in its\n        current form happens in the browser, thus only the web flow is viable there.\n        \"\"\"\n        pass\n\n    def test_social_auth_no_key(self) -> None:\n        \"\"\"\n        The basic validation of server configuration is handled on the\n        /login/social/apple/ endpoint which isn't even a part of the native flow.\n        \"\"\"\n        pass\n\n\nclass GenericOpenIdConnectTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GenericOpenIdConnectBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_TESTOIDC_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_TESTOIDC_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/oidc\"\n    SIGNUP_URL = \"/accounts/register/social/oidc\"\n\n    BASE_OIDC_URL = \"https://example.com/api/openid\"\n    AUTHORIZATION_URL = f\"{BASE_OIDC_URL}/authorize\"\n    ACCESS_TOKEN_URL = f\"{BASE_OIDC_URL}/token\"\n    JWKS_URL = f\"{BASE_OIDC_URL}/jwks\"\n    USER_INFO_URL = f\"{BASE_OIDC_URL}/userinfo\"\n    AUTH_FINISH_URL = \"/complete/oidc/\"\n\n    def social_auth_test(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -> HttpResponse:\n        # Example payload of the discovery endpoint (with appropriate values filled\n        # in to match our test setup).\n        # All the attributes below are REQUIRED per OIDC specification:\n        # https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n        # or at least required for the `code` flow with userinfo - that this implementation uses.\n        # Other flows are not supported right now.\n        idp_discovery_endpoint_payload_dict = {\n            \"issuer\": self.BASE_OIDC_URL,\n            \"authorization_endpoint\": self.AUTHORIZATION_URL,\n            \"token_endpoint\": self.ACCESS_TOKEN_URL,\n            \"userinfo_endpoint\": self.USER_INFO_URL,\n            \"response_types_supported\": [\n                \"code\",\n                \"id_token\",\n                \"id_token token\",\n                \"code token\",\n                \"code id_token\",\n                \"code id_token token\",\n            ],\n            \"jwks_uri\": self.JWKS_URL,\n            \"id_token_signing_alg_values_supported\": [\"HS256\", \"RS256\"],\n            \"subject_types_supported\": [\"public\"],\n        }\n\n        # We need to run the social_auth_test procedure with a mock response set up for the\n        # OIDC discovery endpoint as that's the first thing requested by the server when a user\n        # starts trying to authenticate.\n        with responses.RequestsMock(assert_all_requests_are_fired=False) as requests_mock:\n            requests_mock.add(\n                requests_mock.GET,\n                f\"{self.BASE_OIDC_URL}/.well-known/openid-configuration\",\n                status=200,\n                body=json.dumps(idp_discovery_endpoint_payload_dict),\n            )\n            result = super().social_auth_test(*args, **kwargs)\n\n        return result\n\n    def social_auth_test_finish(self, *args: Any, **kwargs: Any) -> HttpResponse:\n        # Trying to generate a (access_token, id_token) pair here in tests that would\n        # successfully pass validation by validate_and_return_id_token is impractical\n        # and unnecessary (see python-social-auth implementation of the method for\n        # how the validation works).\n        # We can simply mock the method to make it succeed and return an empty dict, because\n        # the return value is not used for anything.\n        with mock.patch.object(\n            GenericOpenIdConnectBackend, \"validate_and_return_id_token\", return_value={}\n        ):\n            return super().social_auth_test_finish(*args, **kwargs)\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        requests_mock.add(\n            requests_mock.GET,\n            self.JWKS_URL,\n            status=200,\n            json=json.loads(settings.EXAMPLE_JWK),\n        )\n\n    def generate_access_token_url_payload(self, account_data_dict: Dict[str, str]) -> str:\n        return json.dumps(\n            {\n                \"access_token\": \"foobar\",\n                \"expires_in\": time.time() + 60 * 5,\n                \"id_token\": \"abcd1234\",\n                \"token_type\": \"bearer\",\n            }\n        )\n\n    def get_account_data_dict(self, email: str, name: Optional[str]) -> Dict[str, Any]:\n        if name is not None:\n            name_parts = name.split(\" \")\n            given_name = name_parts[0]\n            family_name = name_parts[1]\n        else:\n            given_name = None\n            family_name = None\n\n        return dict(\n            email=email,\n            name=name,\n            nickname=\"somenickname\",\n            given_name=given_name,\n            family_name=family_name,\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_social_auth_registration_auto_signup(self) -> None:\n        \"\"\"\n        The analogue of the auto_signup test for SAML.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n\n        oidc_setting_dict = copy.deepcopy(settings.SOCIAL_AUTH_OIDC_ENABLED_IDPS)\n        idp_settings_dict = list(oidc_setting_dict.values())[0]\n        idp_settings_dict[\"auto_signup\"] = True\n        with mock.patch.object(GenericOpenIdConnectBackend, \"settings_dict\", new=idp_settings_dict):\n            result = self.social_auth_test(\n                account_data_dict,\n                expect_choose_email_screen=True,\n                subdomain=subdomain,\n                is_signup=False,\n            )\n            self.stage_two_of_registration(\n                result,\n                realm,\n                subdomain,\n                email,\n                name,\n                name,\n                self.BACKEND_CLASS.full_name_validated,\n                expect_confirm_registration_page=False,\n            )\n\n    def test_auth_registration_with_no_name_provided(self) -> None:\n        \"\"\"\n        The OIDC IdP may not send the name information. The\n        signup flow should proceed normally, without pre-filling the name in the\n        registration form.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=None)\n        result = self.social_auth_test(account_data_dict, subdomain=subdomain, is_signup=True)\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            \"\",\n            \"Full Name\",\n            skip_registration_form=False,\n            expect_full_name_prepopulated=False,\n        )\n\n    def test_social_auth_no_key(self) -> None:\n        \"\"\"\n        Requires overriding because client key/secret are configured\n        in a different way than default for social auth backends.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n\n        mock_oidc_setting_dict = copy.deepcopy(settings.SOCIAL_AUTH_OIDC_ENABLED_IDPS)\n        idp_config_dict = list(mock_oidc_setting_dict.values())[0]\n        del idp_config_dict[\"client_id\"]\n        with self.settings(SOCIAL_AUTH_OIDC_ENABLED_IDPS=mock_oidc_setting_dict):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"OpenID Connect\"], result)\n\n    def test_too_many_idps(self) -> None:\n        \"\"\"\n        Only one IdP is supported for now.\n        \"\"\"\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n\n        mock_oidc_setting_dict = copy.deepcopy(settings.SOCIAL_AUTH_OIDC_ENABLED_IDPS)\n        idp_config_dict = list(mock_oidc_setting_dict.values())[0]\n        mock_oidc_setting_dict[\"secondprovider\"] = idp_config_dict\n        with self.settings(SOCIAL_AUTH_OIDC_ENABLED_IDPS=mock_oidc_setting_dict):\n            result = self.social_auth_test(\n                account_data_dict, subdomain=\"zulip\", next=\"/user_uploads/image\"\n            )\n            self.assert_in_success_response([\"Configuration error\", \"OpenID Connect\"], result)\n\n    def test_config_error_development(self) -> None:\n        \"\"\"\n        This test is redundant for now, as test_social_auth_no_key already\n        tests this basic case, since this backend doesn't yet have more\n        comprehensive config_error pages.\n        \"\"\"\n        return\n\n    def test_config_error_production(self) -> None:\n        \"\"\"\n        This test is redundant for now, as test_social_auth_no_key already\n        tests this basic case, since this backend doesn't yet have more\n        comprehensive config_error pages.\n        \"\"\"\n        return\n\n\nclass GitHubAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GitHubAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_GITHUB_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_GITHUB_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/github\"\n    SIGNUP_URL = \"/accounts/register/social/github\"\n    AUTHORIZATION_URL = \"https://github.com/login/oauth/authorize\"\n    ACCESS_TOKEN_URL = \"https://github.com/login/oauth/access_token\"\n    USER_INFO_URL = \"https://api.github.com/user\"\n    AUTH_FINISH_URL = \"/complete/github/\"\n    email_data: List[Dict[str, Any]] = []\n\n    def social_auth_test_finish(\n        self,\n        result: HttpResponse,\n        account_data_dict: Dict[str, str],\n        expect_choose_email_screen: bool,\n        headers: Any,\n        expect_noreply_email_allowed: bool = False,\n        **extra_data: Any,\n    ) -> HttpResponse:\n        parsed_url = urllib.parse.urlparse(result.url)\n        csrf_state = urllib.parse.parse_qs(parsed_url.query)[\"state\"]\n        result = self.client_get(self.AUTH_FINISH_URL, dict(state=csrf_state), **headers)\n\n        if expect_choose_email_screen:\n            # As GitHub authenticates multiple email addresses,\n            # we'll have an additional screen where the user selects\n            # which email address to log in using (this screen is a\n            # \"partial\" state of the python-social-auth pipeline).\n            #\n            # TODO: Generalize this testing code for use with other\n            # authentication backends when a new authentication backend\n            # that requires \"choose email\" screen;\n            self.assert_in_success_response([\"Select account\"], result)\n            # Verify that all the emails returned by GitHub auth\n            # Are in the \"choose email\" screen.\n            all_emails_verified = True\n            for email_data_dict in self.email_data:\n                email = email_data_dict[\"email\"]\n                if email.endswith(\"@users.noreply.github.com\") and not expect_noreply_email_allowed:\n                    self.assert_not_in_success_response([email], result)\n                elif email_data_dict.get(\"verified\"):\n                    self.assert_in_success_response([email], result)\n                else:\n                    # We may change this if we provide a way to see\n                    # the list of emails the user had.\n                    self.assert_not_in_success_response([email], result)\n                    all_emails_verified = False\n\n            if all_emails_verified:\n                self.assert_not_in_success_response([\"also has unverified email\"], result)\n            else:\n                self.assert_in_success_response([\"also has unverified email\"], result)\n            result = self.client_get(\n                self.AUTH_FINISH_URL,\n                dict(state=csrf_state, email=account_data_dict[\"email\"]),\n                **headers,\n            )\n\n        return result\n\n    def register_extra_endpoints(\n        self,\n        requests_mock: responses.RequestsMock,\n        account_data_dict: Dict[str, str],\n        **extra_data: Any,\n    ) -> None:\n        # Keeping a verified email before the primary email makes sure\n        # get_verified_emails puts the primary email at the start of the\n        # email list returned as social_associate_user_helper assumes the\n        # first email as the primary email.\n        email_data = [\n            dict(email=\"notprimary@example.com\", verified=True),\n            dict(email=account_data_dict[\"email\"], verified=True, primary=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        email_data = extra_data.get(\"email_data\", email_data)\n\n        requests_mock.add(\n            requests_mock.GET,\n            \"https://api.github.com/user/emails\",\n            status=200,\n            body=json.dumps(email_data),\n        )\n\n        requests_mock.add(\n            requests_mock.GET,\n            \"https://api.github.com/teams/zulip-webapp/members/None\",\n            status=200,\n            body=json.dumps(email_data),\n        )\n\n        self.email_data = email_data\n\n    def get_account_data_dict(\n        self, email: str, name: str, user_avatar_url: str = \"\"\n    ) -> Dict[str, Any]:\n        return dict(email=email, name=name, user_avatar_url=user_avatar_url)\n\n    def test_social_auth_email_not_verified(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=False, primary=True),\n        ]\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict, subdomain=subdomain, email_data=email_data\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth ({}) failed because user has no verified emails\".format(\"GitHub\"),\n                    \"warning\",\n                )\n            ],\n        )\n\n    @override_settings(SOCIAL_AUTH_GITHUB_TEAM_ID=\"zulip-webapp\")\n    def test_social_auth_github_team_not_member_failed(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with mock.patch(\n            \"social_core.backends.github.GithubTeamOAuth2.user_data\",\n            side_effect=AuthFailed(\"Not found\"),\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as mock_info:\n            result = self.social_auth_test(account_data_dict, subdomain=subdomain)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            mock_info.output,\n            [\n                self.logger_output(\n                    \"GitHub user is not member of required team\",\n                    \"info\",\n                )\n            ],\n        )\n\n    @override_settings(SOCIAL_AUTH_GITHUB_TEAM_ID=\"zulip-webapp\")\n    def test_social_auth_github_team_member_success(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with mock.patch(\n            \"social_core.backends.github.GithubTeamOAuth2.user_data\", return_value=account_data_dict\n        ):\n            result = self.social_auth_test(\n                account_data_dict, expect_choose_email_screen=False, subdomain=\"zulip\"\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n\n    @override_settings(SOCIAL_AUTH_GITHUB_ORG_NAME=\"Zulip\")\n    def test_social_auth_github_organization_not_member_failed(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with mock.patch(\n            \"social_core.backends.github.GithubOrganizationOAuth2.user_data\",\n            side_effect=AuthFailed(\"Not found\"),\n        ), self.assertLogs(self.logger_string, level=\"INFO\") as mock_info:\n            result = self.social_auth_test(account_data_dict, subdomain=subdomain)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            mock_info.output,\n            [\n                self.logger_output(\n                    \"GitHub user is not member of required organization\",\n                    \"info\",\n                )\n            ],\n        )\n\n    @override_settings(SOCIAL_AUTH_GITHUB_ORG_NAME=\"Zulip\")\n    def test_social_auth_github_organization_member_success(self) -> None:\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        with mock.patch(\n            \"social_core.backends.github.GithubOrganizationOAuth2.user_data\",\n            return_value=account_data_dict,\n        ):\n            result = self.social_auth_test(\n                account_data_dict, expect_choose_email_screen=False, subdomain=\"zulip\"\n            )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n\n    def test_github_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GitHubAuthBackend\",)):\n            self.assertTrue(github_auth_enabled())\n\n    def test_github_oauth2_success_non_primary(self) -> None:\n        account_data_dict = self.get_account_data_dict(\n            email=\"nonprimary@zulip.com\", name=\"Non Primary\"\n        )\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=True,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], \"nonprimary@zulip.com\")\n        self.assertEqual(data[\"full_name\"], \"Non Primary\")\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_success_single_email(self) -> None:\n        # If the user has a single email associated with its GitHub account,\n        # the choose email screen should not be shown and the first email\n        # should be used for user's signup/login.\n        account_data_dict = self.get_account_data_dict(email=\"not-hamlet@zulip.com\", name=self.name)\n        email_data = [\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=False,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], self.example_email(\"hamlet\"))\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_login_only_one_account_exists(self) -> None:\n        # In a login flow, if only one of the user's verified emails\n        # is associated with an existing account, the user should be\n        # just logged in (skipping the \"choose email screen\").  We\n        # only want that screen if the user were instead trying to\n        # register a new account, which they're not.\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=False,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], account_data_dict[\"email\"])\n        self.assertEqual(data[\"full_name\"], self.name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_login_multiple_accounts_exist(self) -> None:\n        # In the login flow, if multiple of the user's verified emails\n        # are associated with existing accounts, we expect the choose\n        # email screen to select which account to use.\n        hamlet = self.example_user(\"hamlet\")\n        account_data_dict = self.get_account_data_dict(email=\"hamlet@zulip.com\", name=\"Hamlet\")\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n            dict(email=\"ignored@example.com\", verified=False),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=True,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], \"hamlet@zulip.com\")\n        self.assertEqual(data[\"full_name\"], hamlet.full_name)\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_login_no_account_exists(self) -> None:\n        # In the login flow, if the user has multiple verified emails,\n        # none of which are associated with an existing account, the\n        # choose email screen should be shown (which will lead to a\n        # \"continue to registration\" choice).\n        account_data_dict = self.get_account_data_dict(\n            email=\"not-hamlet@zulip.com\", name=\"Not Hamlet\"\n        )\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            email_data=email_data,\n            expect_choose_email_screen=True,\n        )\n        email = account_data_dict[\"email\"]\n        name = account_data_dict[\"name\"]\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        self.stage_two_of_registration(\n            result,\n            realm,\n            subdomain,\n            email,\n            name,\n            name,\n            expect_confirm_registration_page=True,\n            skip_registration_form=False,\n        )\n\n    def test_github_oauth2_signup_choose_existing_account(self) -> None:\n        # In the sign up flow, if the user has chosen an email of an\n        # existing account, the user will be logged in.\n        account_data_dict = self.get_account_data_dict(email=self.email, name=self.name)\n        email_data = [\n            dict(email=account_data_dict[\"email\"], verified=True),\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            email_data=email_data,\n            is_signup=True,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            next=\"/user_uploads/image\",\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], account_data_dict[\"email\"])\n        self.assertEqual(data[\"full_name\"], account_data_dict[\"name\"])\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(data[\"redirect_to\"], \"/user_uploads/image\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_signup_choose_new_email_to_register(self) -> None:\n        # In the sign up flow, if the user has multiple verified\n        # emails, we show the \"choose email\" screen, even if the user\n        # has another verified email with an existing account,\n        # allowing the user to register a second account associated\n        # with the second email.\n        email = \"newuser@zulip.com\"\n        name = \"Full Name\"\n        subdomain = \"zulip\"\n        realm = get_realm(\"zulip\")\n        account_data_dict = self.get_account_data_dict(email=email, name=name)\n        email_data = [\n            dict(email=\"hamlet@zulip.com\", verified=True),\n            dict(email=email, verified=True),\n            dict(email=\"verifiedemail@zulip.com\", verified=True),\n        ]\n        result = self.social_auth_test(\n            account_data_dict,\n            email_data=email_data,\n            expect_choose_email_screen=True,\n            subdomain=subdomain,\n            is_signup=True,\n        )\n        self.stage_two_of_registration(\n            result, realm, subdomain, email, name, name, self.BACKEND_CLASS.full_name_validated\n        )\n\n    def test_github_oauth2_email_no_reply_dot_github_dot_com(self) -> None:\n        # As emails ending with `noreply.github.com` are excluded from\n        # verified_emails unless an account with that email already exists,\n        # choosing it as an email should raise a `email not associated` warning.\n        noreply_email = \"hamlet@users.noreply.github.com\"\n        account_data_dict = self.get_account_data_dict(email=noreply_email, name=self.name)\n        email_data = [\n            dict(email=\"notprimary@zulip.com\", verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n            dict(email=account_data_dict[\"email\"], verified=True),\n        ]\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=subdomain,\n                expect_choose_email_screen=True,\n                email_data=email_data,\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth (GitHub) failed because user has no verified\"\n                    \" emails associated with the account\",\n                    \"warning\",\n                )\n            ],\n        )\n\n        # Now we create the user account with the noreply email and verify that it's\n        # possible to sign in to it.\n        realm = get_realm(\"zulip\")\n        do_create_user(\n            noreply_email, \"password\", realm, account_data_dict[\"name\"], acting_user=None\n        )\n        result = self.social_auth_test(\n            account_data_dict,\n            subdomain=\"zulip\",\n            expect_choose_email_screen=True,\n            expect_noreply_email_allowed=True,\n            email_data=email_data,\n        )\n        data = load_subdomain_token(result)\n        self.assertEqual(data[\"email\"], account_data_dict[\"email\"])\n        self.assertEqual(data[\"full_name\"], account_data_dict[\"name\"])\n        self.assertEqual(data[\"subdomain\"], \"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = f\"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}\"\n        self.assertTrue(uri.startswith(\"http://zulip.testserver/accounts/login/subdomain/\"))\n\n    def test_github_oauth2_email_not_associated(self) -> None:\n        account_data_dict = self.get_account_data_dict(\n            email=\"not-associated@zulip.com\", name=self.name\n        )\n        email_data = [\n            dict(email=\"nonprimary@zulip.com\", verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=True, primary=True),\n            dict(email=\"aaron@zulip.com\", verified=True),\n        ]\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=subdomain,\n                expect_choose_email_screen=True,\n                email_data=email_data,\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth (GitHub) failed because user has no verified\"\n                    \" emails associated with the account\",\n                    \"warning\",\n                )\n            ],\n        )\n\n    def test_github_unverified_email_with_existing_account(self) -> None:\n        # check if a user is denied to log in if the user manages to\n        # send an unverified email that has an existing account in\n        # organization through `email` GET parameter.\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        account_data_dict = dict(email=\"hamlet@zulip.com\", name=self.name)\n        email_data = [\n            dict(email=\"iago@zulip.com\", verified=True),\n            dict(email=\"hamlet@zulip.com\", verified=False),\n            dict(email=\"aaron@zulip.com\", verified=True, primary=True),\n        ]\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=subdomain,\n                expect_choose_email_screen=True,\n                email_data=email_data,\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth ({}) failed because user has no verified emails associated with the account\".format(\n                        \"GitHub\"\n                    ),\n                    \"warning\",\n                )\n            ],\n        )\n\n\nclass GitLabAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GitLabAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_GITLAB_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_GITLAB_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/gitlab\"\n    SIGNUP_URL = \"/accounts/register/social/gitlab\"\n    AUTHORIZATION_URL = \"https://gitlab.com/oauth/authorize\"\n    ACCESS_TOKEN_URL = \"https://gitlab.com/oauth/token\"\n    USER_INFO_URL = \"https://gitlab.com/api/v4/user\"\n    AUTH_FINISH_URL = \"/complete/gitlab/\"\n\n    def test_gitlab_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GitLabAuthBackend\",)):\n            self.assertTrue(gitlab_auth_enabled())\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        return dict(email=email, name=name, email_verified=True)\n\n\nclass GoogleAuthBackendTest(SocialAuthBase):\n    __unittest_skip__ = False\n\n    BACKEND_CLASS = GoogleAuthBackend\n    CLIENT_KEY_SETTING = \"SOCIAL_AUTH_GOOGLE_KEY\"\n    CLIENT_SECRET_SETTING = \"SOCIAL_AUTH_GOOGLE_SECRET\"\n    LOGIN_URL = \"/accounts/login/social/google\"\n    SIGNUP_URL = \"/accounts/register/social/google\"\n    AUTHORIZATION_URL = \"https://accounts.google.com/o/oauth2/auth\"\n    ACCESS_TOKEN_URL = \"https://accounts.google.com/o/oauth2/token\"\n    USER_INFO_URL = \"https://www.googleapis.com/oauth2/v3/userinfo\"\n    AUTH_FINISH_URL = \"/complete/google/\"\n\n    def get_account_data_dict(self, email: str, name: str) -> Dict[str, Any]:\n        return dict(email=email, name=name, email_verified=True)\n\n    def test_social_auth_email_not_verified(self) -> None:\n        account_data_dict = dict(email=self.email, name=self.name)\n        subdomain = \"zulip\"\n        realm = get_realm(subdomain)\n        with self.assertLogs(self.logger_string, level=\"WARNING\") as m:\n            result = self.social_auth_test(account_data_dict, subdomain=subdomain)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, realm.uri + \"/login/\")\n        self.assertEqual(\n            m.output,\n            [\n                self.logger_output(\n                    \"Social auth ({}) failed because user has no verified emails\".format(\"Google\"),\n                    \"warning\",\n                )\n            ],\n        )\n\n    def test_social_auth_mobile_realm_uri(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n\n        with self.settings(\n            REALM_MOBILE_REMAP_URIS={\"http://zulip.testserver\": \"http://zulip-mobile.testserver\"}\n        ):\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=True,\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=mobile_flow_otp,\n            )\n\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip-mobile.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n\n    def test_social_auth_mobile_success_legacy_url(self) -> None:\n        mobile_flow_otp = \"1234abcd\" * 8\n        account_data_dict = self.get_account_data_dict(email=self.email, name=\"Full Name\")\n        self.assert_length(mail.outbox, 0)\n        self.user_profile.date_joined = timezone_now() - datetime.timedelta(\n            seconds=JUST_CREATED_THRESHOLD + 1\n        )\n        self.user_profile.save()\n\n        with self.settings(SEND_LOGIN_EMAILS=True):\n            # Verify that the right thing happens with an invalid-format OTP\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=\"1234\",\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=\"invalido\" * 8,\n            )\n            self.assert_json_error(result, \"Invalid OTP\")\n\n            # Now do it correctly\n            result = self.social_auth_test(\n                account_data_dict,\n                subdomain=\"zulip\",\n                expect_choose_email_screen=True,\n                alternative_start_url=\"/accounts/login/google/\",\n                mobile_flow_otp=mobile_flow_otp,\n            )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    def test_google_auth_enabled(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.GoogleAuthBackend\",)):\n            self.assertTrue(google_auth_enabled())\n\n    def get_log_into_subdomain(\n        self,\n        data: ExternalAuthDataDict,\n        *,\n        subdomain: str = \"zulip\",\n        force_token: Optional[str] = None,\n    ) -> HttpResponse:\n        if force_token is None:\n            token = ExternalAuthResult(data_dict=data).store_data()\n        else:\n            token = force_token\n        url_path = reverse(log_into_subdomain, args=[token])\n        return self.client_get(url_path, subdomain=subdomain)\n\n    def test_redirect_to_next_url_for_log_into_subdomain(self) -> None:\n        def test_redirect_to_next_url(next: str = \"\") -> HttpResponse:\n            data: ExternalAuthDataDict = {\n                \"full_name\": \"Hamlet\",\n                \"email\": self.example_email(\"hamlet\"),\n                \"subdomain\": \"zulip\",\n                \"is_signup\": False,\n                \"redirect_to\": next,\n            }\n            user_profile = self.example_user(\"hamlet\")\n            with mock.patch(\"zerver.views.auth.authenticate\", return_value=user_profile):\n                with mock.patch(\"zerver.views.auth.do_login\"):\n                    result = self.get_log_into_subdomain(data)\n            return result\n\n        res = test_redirect_to_next_url()\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver\")\n        res = test_redirect_to_next_url(\"/user_uploads/path_to_image\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/user_uploads/path_to_image\")\n\n        res = test_redirect_to_next_url(\"/#narrow/stream/7-test-here\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/#narrow/stream/7-test-here\")\n\n    def test_log_into_subdomain_when_token_is_malformed(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": self.example_email(\"hamlet\"),\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n        with self.assertLogs(level=\"WARNING\") as m:\n            result = self.get_log_into_subdomain(data, force_token=\"nonsense\")\n        self.assertEqual(\n            m.output,\n            [\"WARNING:root:log_into_subdomain: Malformed token given: {}\".format(\"nonsense\")],\n        )\n        self.assertEqual(result.status_code, 400)\n\n    def test_log_into_subdomain_when_token_not_found(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": self.example_email(\"hamlet\"),\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n        with self.assertLogs(level=\"WARNING\") as m:\n            token = secrets.token_hex(ExternalAuthResult.LOGIN_TOKEN_LENGTH // 2)\n            result = self.get_log_into_subdomain(data, force_token=token)\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Invalid or expired login session.\", result)\n        self.assertEqual(\n            m.output, [f\"WARNING:root:log_into_subdomain: Invalid token given: {token}\"]\n        )\n\n    def test_prevent_duplicate_signups(self) -> None:\n        existing_user = self.example_user(\"hamlet\")\n        existing_user.delivery_email = \"existing@zulip.com\"\n        existing_user.email = \"whatever@zulip.com\"\n        existing_user.save()\n\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": \"existing@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": True,\n            \"redirect_to\": \"\",\n        }\n        result = self.get_log_into_subdomain(data)\n\n        # Should simply get logged into the existing account:\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(existing_user.id)\n\n    def test_log_into_subdomain_when_is_signup_is_true_and_new_user(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"New User Name\",\n            \"email\": \"new@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": True,\n            \"redirect_to\": \"\",\n        }\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().first()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        confirmation_data = {\n            \"from_confirmation\": \"1\",\n            \"full_name\": data[\"full_name\"],\n            \"key\": confirmation_key,\n        }\n        result = self.client_post(\"/accounts/register/\", confirmation_data, subdomain=\"zulip\")\n        self.assert_in_response(\"We just need you to do one last thing\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response([\"id_password\"], result)\n        self.assert_in_success_response([\"id_full_name\"], result)\n\n    def test_log_into_subdomain_when_is_signup_is_false_and_new_user(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"New User Name\",\n            \"email\": \"new@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"No account found for\", result)\n        self.assert_in_response(\"new@zulip.com.\", result)\n        self.assert_in_response('action=\"http://zulip.testserver/accounts/do_confirm/', result)\n\n        url = re.findall(\n            'action=\"(http://zulip.testserver/accounts/do_confirm[^\"]*)\"',\n            result.content.decode(),\n        )[0]\n        confirmation = Confirmation.objects.all().first()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn(\"do_confirm/\" + confirmation_key, url)\n        result = self.client_get(url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        confirmation_data = {\n            \"from_confirmation\": \"1\",\n            \"full_name\": data[\"full_name\"],\n            \"key\": confirmation_key,\n        }\n        result = self.client_post(\"/accounts/register/\", confirmation_data, subdomain=\"zulip\")\n        self.assert_in_response(\"We just need you to do one last thing\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response([\"id_password\"], result)\n        self.assert_in_success_response([\"id_full_name\"], result)\n\n    def test_log_into_subdomain_when_using_invite_link(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"New User Name\",\n            \"email\": \"new@zulip.com\",\n            \"subdomain\": \"zulip\",\n            \"is_signup\": True,\n            \"redirect_to\": \"\",\n        }\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        stream_names = [\"new_stream_1\", \"new_stream_2\"]\n        streams = []\n        for stream_name in set(stream_names):\n            stream = ensure_stream(realm, stream_name, acting_user=None)\n            streams.append(stream)\n\n        # Without the invite link, we can't create an account due to invite_required\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Sign up for Zulip\"], result)\n\n        # Now confirm an invitation link works\n        referrer = self.example_user(\"hamlet\")\n        multiuse_obj = MultiuseInvite.objects.create(realm=realm, referred_by=referrer)\n        multiuse_obj.streams.set(streams)\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_obj, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        multiuse_confirmation = Confirmation.objects.all().last()\n        assert multiuse_confirmation is not None\n        multiuse_object_key = multiuse_confirmation.confirmation_key\n\n        data[\"multiuse_object_key\"] = multiuse_object_key\n        result = self.get_log_into_subdomain(data)\n        self.assertEqual(result.status_code, 302)\n\n        confirmation = Confirmation.objects.all().last()\n        assert confirmation is not None\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data2 = {\"from_confirmation\": \"1\", \"full_name\": data[\"full_name\"], \"key\": confirmation_key}\n        result = self.client_post(\"/accounts/register/\", data2, subdomain=\"zulip\")\n        self.assert_in_response(\"We just need you to do one last thing\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response([\"id_password\"], result)\n        self.assert_in_success_response([\"id_full_name\"], result)\n\n        # Click confirm registration button.\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"full_name\": \"New User Name\", \"key\": confirmation_key, \"terms\": True},\n        )\n        self.assertEqual(result.status_code, 302)\n        new_user = get_user_by_delivery_email(\"new@zulip.com\", realm)\n        new_streams = self.get_streams(new_user)\n        self.assertEqual(sorted(new_streams), stream_names)\n\n    def test_log_into_subdomain_when_email_is_none(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"subdomain\": \"zulip\",\n            \"is_signup\": False,\n            \"redirect_to\": \"\",\n        }\n\n        with self.assertLogs(level=\"WARNING\") as m:\n            token = secrets.token_hex(ExternalAuthResult.LOGIN_TOKEN_LENGTH // 2)\n            result = self.get_log_into_subdomain(data, force_token=token)\n            self.assertEqual(result.status_code, 400)\n        self.assertEqual(\n            m.output, [f\"WARNING:root:log_into_subdomain: Invalid token given: {token}\"]\n        )\n\n    def test_user_cannot_log_into_wrong_subdomain(self) -> None:\n        data: ExternalAuthDataDict = {\n            \"full_name\": \"Full Name\",\n            \"email\": self.example_email(\"hamlet\"),\n            \"subdomain\": \"zephyr\",\n        }\n        result = self.get_log_into_subdomain(data)\n        self.assert_json_error(result, \"Invalid subdomain\")\n\n\nclass JSONFetchAPIKeyTest(ZulipTestCase):\n    def test_success(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.client_post(\n            \"/json/fetch_api_key\", dict(password=initial_password(user.delivery_email))\n        )\n        self.assert_json_success(result)\n\n    def test_not_loggedin(self) -> None:\n        user = self.example_user(\"hamlet\")\n        result = self.client_post(\n            \"/json/fetch_api_key\", dict(password=initial_password(user.delivery_email))\n        )\n        self.assert_json_error(\n            result, \"Not logged in: API authentication or user session required\", 401\n        )\n\n    def test_wrong_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        result = self.client_post(\"/json/fetch_api_key\", dict(password=\"wrong\"))\n        self.assert_json_error(result, \"Password is incorrect.\", 400)\n\n    def test_invalid_subdomain(self) -> None:\n        username = \"hamlet\"\n        user = self.example_user(username)\n        self.login_user(user)\n        with mock.patch(\"zerver.views.auth.get_realm_from_request\", return_value=None):\n            result = self.client_post(\n                \"/json/fetch_api_key\",\n                dict(username=username, password=initial_password(user.delivery_email)),\n            )\n        self.assert_json_error(result, \"Invalid subdomain\", 400)\n\n\nclass FetchAPIKeyTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.email = self.user_profile.delivery_email\n\n    def test_success(self) -> None:\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=self.email, password=initial_password(self.email)),\n        )\n        self.assert_json_success(result)\n\n    def test_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\", dict(username=\"hamlet\", password=initial_password(self.email))\n        )\n        self.assert_json_error(result, \"Enter a valid email address.\", 400)\n\n    def test_wrong_password(self) -> None:\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\", dict(username=self.email, password=\"wrong\")\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n    def test_invalid_subdomain(self) -> None:\n        with mock.patch(\"zerver.views.auth.get_realm_from_request\", return_value=None):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=\"hamlet\", password=initial_password(self.email)),\n            )\n        self.assert_json_error(result, \"Invalid subdomain\", 404)\n\n    def test_password_auth_disabled(self) -> None:\n        with mock.patch(\"zproject.backends.password_auth_enabled\", return_value=False):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=self.email, password=initial_password(self.email)),\n            )\n            self.assert_json_error_contains(\n                result, \"Password authentication is disabled in this organization\", 401\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auth_email_auth_disabled_success(self) -> None:\n        self.init_default_ldap_database()\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=self.example_email(\"hamlet\"), password=self.ldap_password(\"hamlet\")),\n            )\n        self.assert_json_success(result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n        LDAP_APPEND_DOMAIN=\"zulip.com\",\n        AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"org_membership\": \"department\"},\n    )\n    def test_ldap_auth_email_auth_organization_restriction(self) -> None:\n        self.init_default_ldap_database()\n        # We do test two combinations here:\n        # The first user has no (department) attribute set\n        # The second user has one set, but to a different value\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"testWrongRealm\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"zulip\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n        LDAP_APPEND_DOMAIN=\"zulip.com\",\n        AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"org_membership\": \"department\"},\n        AUTH_LDAP_ADVANCED_REALM_ACCESS_CONTROL={\n            \"zulip\": [{\"test1\": \"test\", \"test2\": \"testing\"}, {\"test1\": \"test2\"}],\n            \"anotherRealm\": [{\"test2\": \"test2\"}],\n        },\n    )\n    def test_ldap_auth_email_auth_advanced_organization_restriction(self) -> None:\n        self.init_default_ldap_database()\n\n        # The first user has no attribute set\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"test2\", \"testing\")\n        # Check with only one set\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        self.change_ldap_user_attr(\"hamlet\", \"test1\", \"test\")\n        # Setting org_membership to not cause django_ldap_auth to warn, when synchronising\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"wrongDepartment\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n        self.remove_ldap_user_attr(\"hamlet\", \"test2\")\n        self.remove_ldap_user_attr(\"hamlet\", \"test1\")\n\n        # Using the OR value\n        self.change_ldap_user_attr(\"hamlet\", \"test1\", \"test2\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n\n        # Testing without org_membership\n        with override_settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\"}):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n            )\n            self.assert_json_success(result)\n\n        # Setting test1 to wrong value\n        self.change_ldap_user_attr(\"hamlet\", \"test1\", \"invalid\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n        # Override access with `org_membership`\n        self.change_ldap_user_attr(\"hamlet\", \"department\", \"zulip\")\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n        )\n        self.assert_json_success(result)\n        self.remove_ldap_user_attr(\"hamlet\", \"department\")\n\n        # Test wrong configuration\n        with override_settings(\n            AUTH_LDAP_ADVANCED_REALM_ACCESS_CONTROL={\"not_zulip\": [{\"department\": \"zulip\"}]}\n        ):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=\"hamlet\", password=self.ldap_password(\"hamlet\")),\n            )\n            self.assert_json_error(result, \"Your username or password is incorrect\", 401)\n\n    def test_inactive_user(self) -> None:\n        do_deactivate_user(self.user_profile, acting_user=None)\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=self.email, password=initial_password(self.email)),\n        )\n        self.assert_json_error_contains(result, \"Account is deactivated\", 401)\n\n    def test_deactivated_realm(self) -> None:\n        do_deactivate_realm(self.user_profile.realm, acting_user=None)\n        result = self.client_post(\n            \"/api/v1/fetch_api_key\",\n            dict(username=self.email, password=initial_password(self.email)),\n        )\n        self.assert_json_error_contains(result, \"This organization has been deactivated\", 401)\n\n    def test_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.client_post(\n                \"/api/v1/fetch_api_key\",\n                dict(username=self.email, password=password),\n            )\n            self.assert_json_error(\n                result, \"Your password has been disabled and needs to be reset\", 401\n            )\n\n\nclass DevFetchAPIKeyTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.user_profile = self.example_user(\"hamlet\")\n        self.email = self.user_profile.delivery_email\n\n    def test_success(self) -> None:\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n        self.assert_json_success(result)\n        data = result.json()\n        self.assertEqual(data[\"email\"], self.email)\n        user_api_keys = get_all_api_keys(self.user_profile)\n        self.assertIn(data[\"api_key\"], user_api_keys)\n\n    def test_invalid_email(self) -> None:\n        email = \"hamlet\"\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=email))\n        self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_unregistered_user(self) -> None:\n        email = \"foo@zulip.com\"\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=email))\n        self.assert_json_error_contains(result, \"Your username or password is incorrect\", 401)\n\n    def test_inactive_user(self) -> None:\n        do_deactivate_user(self.user_profile, acting_user=None)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n        self.assert_json_error_contains(result, \"Account is deactivated\", 401)\n\n    def test_deactivated_realm(self) -> None:\n        do_deactivate_realm(self.user_profile.realm, acting_user=None)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n        self.assert_json_error_contains(result, \"This organization has been deactivated\", 401)\n\n    def test_dev_auth_disabled(self) -> None:\n        with mock.patch(\"zerver.views.development.dev_login.dev_auth_enabled\", return_value=False):\n            result = self.client_post(\"/api/v1/dev_fetch_api_key\", dict(username=self.email))\n            self.assert_json_error_contains(result, \"DevAuthBackend not enabled.\", 400)\n\n    def test_invalid_subdomain(self) -> None:\n        with mock.patch(\n            \"zerver.views.development.dev_login.get_realm_from_request\", return_value=None\n        ):\n            result = self.client_post(\n                \"/api/v1/dev_fetch_api_key\",\n                dict(username=self.email, password=initial_password(self.email)),\n            )\n            self.assert_json_error_contains(result, \"Invalid subdomain\", 404)\n\n\nclass DevGetEmailsTest(ZulipTestCase):\n    def test_success(self) -> None:\n        result = self.client_get(\"/api/v1/dev_list_users\")\n        self.assert_json_success(result)\n        self.assert_in_response(\"direct_admins\", result)\n        self.assert_in_response(\"direct_users\", result)\n\n    def test_dev_auth_disabled(self) -> None:\n        with mock.patch(\"zerver.views.development.dev_login.dev_auth_enabled\", return_value=False):\n            result = self.client_get(\"/api/v1/dev_list_users\")\n            self.assert_json_error_contains(result, \"DevAuthBackend not enabled.\", 400)\n\n        with override_settings(PRODUCTION=True):\n            result = self.client_get(\"/api/v1/dev_list_users\")\n            self.assert_json_error_contains(result, \"Endpoint not available in production.\", 400)\n\n\nclass ExternalMethodDictsTests(ZulipTestCase):\n    def get_configured_saml_backend_idp_names(self) -> List[str]:\n        return settings.SOCIAL_AUTH_SAML_ENABLED_IDPS.keys()\n\n    def test_get_external_method_dicts_correctly_sorted(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.GitHubAuthBackend\",\n                \"zproject.backends.GoogleAuthBackend\",\n                \"zproject.backends.ZulipRemoteUserBackend\",\n                \"zproject.backends.SAMLAuthBackend\",\n                \"zproject.backends.AzureADAuthBackend\",\n            ),\n        ):\n            external_auth_methods = get_external_method_dicts()\n            # First backends in the list should be SAML:\n            self.assertIn(\"saml:\", external_auth_methods[0][\"name\"])\n            self.assertEqual(\n                [social_backend[\"name\"] for social_backend in external_auth_methods[1:]],\n                [\n                    social_backend.name\n                    for social_backend in sorted(\n                        [\n                            ZulipRemoteUserBackend,\n                            GitHubAuthBackend,\n                            AzureADAuthBackend,\n                            GoogleAuthBackend,\n                        ],\n                        key=lambda x: x.sort_order,\n                        reverse=True,\n                    )\n                ],\n            )\n\n    def test_get_external_method_buttons(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.GitHubAuthBackend\",\n                \"zproject.backends.GoogleAuthBackend\",\n                \"zproject.backends.SAMLAuthBackend\",\n            ),\n        ):\n            saml_idp_names = self.get_configured_saml_backend_idp_names()\n            expected_button_id_strings = [\n                'id=\"{}_auth_button_github\"',\n                'id=\"{}_auth_button_google\"',\n            ]\n            for name in saml_idp_names:\n                expected_button_id_strings.append(f'id=\"{{}}_auth_button_saml:{name}\"')\n\n            result = self.client_get(\"/login/\")\n            self.assert_in_success_response(\n                [string.format(\"login\") for string in expected_button_id_strings], result\n            )\n\n            result = self.client_get(\"/register/\")\n            self.assert_in_success_response(\n                [string.format(\"register\") for string in expected_button_id_strings], result\n            )\n\n    def test_get_external_method_dicts_multiple_saml_idps(self) -> None:\n        idps_dict = copy.deepcopy(settings.SOCIAL_AUTH_SAML_ENABLED_IDPS)\n        # Create another IdP config, by copying the original one and changing some details.idps_dict['test_idp'])\n        idps_dict[\"test_idp2\"] = copy.deepcopy(idps_dict[\"test_idp\"])\n        idps_dict[\"test_idp2\"][\"url\"] = \"https://idp2.example.com/idp/profile/SAML2/Redirect/SSO\"\n        idps_dict[\"test_idp2\"][\"display_name\"] = \"Second Test IdP\"\n        idps_dict[\"test_idp2\"][\"limit_to_subdomains\"] = [\"zephyr\"]\n        with self.settings(\n            SOCIAL_AUTH_SAML_ENABLED_IDPS=idps_dict,\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.GitHubAuthBackend\",\n                \"zproject.backends.SAMLAuthBackend\",\n            ),\n        ):\n            # Calling get_external_method_dicts without a realm returns all methods configured on the server:\n            external_auth_methods = get_external_method_dicts()\n            # 1 IdP enabled for all realms + a dict for GitHub auth\n            self.assert_length(external_auth_methods, 2)\n            self.assertEqual(\n                [external_auth_methods[0][\"name\"], external_auth_methods[1][\"name\"]],\n                [\"saml:test_idp\", \"github\"],\n            )\n\n            external_auth_methods = get_external_method_dicts(get_realm(\"zulip\"))\n            # Only test_idp enabled for the zulip realm, + GitHub auth.\n            self.assert_length(external_auth_methods, 2)\n            self.assertEqual(\n                [external_auth_methods[0][\"name\"], external_auth_methods[1][\"name\"]],\n                [\"saml:test_idp\", \"github\"],\n            )\n\n            external_auth_methods = get_external_method_dicts(get_realm(\"zephyr\"))\n            # Both idps enabled for the zephyr realm, + GitHub auth.\n            self.assert_length(external_auth_methods, 3)\n            self.assertEqual(\n                {external_auth_methods[0][\"name\"], external_auth_methods[1][\"name\"]},\n                {\"saml:test_idp\", \"saml:test_idp2\"},\n            )\n\n\nclass FetchAuthBackends(ZulipTestCase):\n    def test_get_server_settings(self) -> None:\n        def check_result(\n            result: HttpResponse, extra_fields: Sequence[Tuple[str, Validator[object]]] = []\n        ) -> None:\n            authentication_methods_list = [\n                (\"password\", check_bool),\n            ]\n            for backend_name_with_case in AUTH_BACKEND_NAME_MAP:\n                authentication_methods_list.append((backend_name_with_case.lower(), check_bool))\n            external_auth_methods = get_external_method_dicts()\n\n            self.assert_json_success(result)\n            checker = check_dict_only(\n                [\n                    (\"authentication_methods\", check_dict_only(authentication_methods_list)),\n                    (\n                        \"external_authentication_methods\",\n                        check_list(\n                            check_dict_only(\n                                [\n                                    (\"display_icon\", check_none_or(check_string)),\n                                    (\"display_name\", check_string),\n                                    (\"login_url\", check_string),\n                                    (\"name\", check_string),\n                                    (\"signup_url\", check_string),\n                                ]\n                            ),\n                            length=len(external_auth_methods),\n                        ),\n                    ),\n                    (\"email_auth_enabled\", check_bool),\n                    (\"is_incompatible\", check_bool),\n                    (\"require_email_format_usernames\", check_bool),\n                    (\"realm_uri\", check_string),\n                    (\"zulip_version\", check_string),\n                    (\"zulip_merge_base\", check_string),\n                    (\"zulip_feature_level\", check_int),\n                    (\"push_notifications_enabled\", check_bool),\n                    (\"realm_web_public_access_enabled\", check_bool),\n                    (\"msg\", check_string),\n                    (\"result\", check_string),\n                    *extra_fields,\n                ]\n            )\n            checker(\"data\", result.json())\n\n        result = self.client_get(\"/api/v1/server_settings\", subdomain=\"\", HTTP_USER_AGENT=\"\")\n        check_result(result)\n        self.assertEqual(\n            result.json()[\"external_authentication_methods\"], get_external_method_dicts()\n        )\n\n        result = self.client_get(\n            \"/api/v1/server_settings\", subdomain=\"\", HTTP_USER_AGENT=\"ZulipInvalid\"\n        )\n        self.assertTrue(result.json()[\"is_incompatible\"])\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\"/api/v1/server_settings\", subdomain=\"\", HTTP_USER_AGENT=\"\")\n        check_result(result)\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\n                \"/api/v1/server_settings\", subdomain=\"zulip\", HTTP_USER_AGENT=\"\"\n            )\n        check_result(\n            result,\n            [\n                (\"realm_name\", check_string),\n                (\"realm_description\", check_string),\n                (\"realm_icon\", check_string),\n            ],\n        )\n\n        # Verify invalid subdomain\n        result = self.client_get(\"/api/v1/server_settings\", subdomain=\"invalid\")\n        self.assert_json_error_contains(result, \"Invalid subdomain\", 400)\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            # With ROOT_DOMAIN_LANDING_PAGE, homepage fails\n            result = self.client_get(\"/api/v1/server_settings\", subdomain=\"\")\n            self.assert_json_error_contains(result, \"Subdomain required\", 400)\n\n\nclass TestTwoFactor(ZulipTestCase):\n    def test_direct_dev_login_with_2fa(self) -> None:\n        email = self.example_email(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        with self.settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True):\n            data = {\"direct_email\": email}\n            result = self.client_post(\"/accounts/login/local/\", data)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n            # User logs in but when otp device doesn't exist.\n            self.assertNotIn(\"otp_device_id\", self.client.session.keys())\n\n            self.create_default_device(user_profile)\n\n            data = {\"direct_email\": email}\n            result = self.client_post(\"/accounts/login/local/\", data)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n            # User logs in when otp device exists.\n            self.assertIn(\"otp_device_id\", self.client.session.keys())\n\n    @mock.patch(\"two_factor.models.totp\")\n    def test_two_factor_login_with_ldap(self, mock_totp: mock.MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        # Set up LDAP\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_log:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                info_log.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to `realm.uri` if user is\n            # already logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass TestDevAuthBackend(ZulipTestCase):\n    def test_login_success(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        data = {\"direct_email\": email}\n        result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_spectator(self) -> None:\n        data = {\"prefers_web_public_view\": \"Anonymous login\"}\n        result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zulip.testserver/\")\n\n    def test_login_success_with_2fa(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        email = user_profile.delivery_email\n        data = {\"direct_email\": email}\n        with self.settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True):\n            result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertIn(\"otp_device_id\", list(self.client.session.keys()))\n\n    def test_redirect_to_next_url(self) -> None:\n        def do_local_login(formaction: str) -> HttpResponse:\n            user_email = self.example_email(\"hamlet\")\n            data = {\"direct_email\": user_email}\n            return self.client_post(formaction, data)\n\n        res = do_local_login(\"/accounts/login/local/\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/\")\n\n        res = do_local_login(\"/accounts/login/local/?next=/user_uploads/path_to_image\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver/user_uploads/path_to_image\")\n\n        # In local Email based authentication we never make browser send the hash\n        # to the backend. Rather we depend upon the browser's behaviour of persisting\n        # hash anchors in between redirect requests. See below stackoverflow conversation\n        # https://stackoverflow.com/questions/5283395/url-hash-is-persisting-between-redirects\n        res = do_local_login(\"/accounts/login/local/?next=#narrow/stream/7-test-here\")\n        self.assertEqual(res.status_code, 302)\n        self.assertEqual(res.url, \"http://zulip.testserver\")\n\n    def test_login_with_subdomain(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        data = {\"direct_email\": email}\n\n        result = self.client_post(\"/accounts/login/local/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_choose_realm(self) -> None:\n        result = self.client_post(\"/devlogin/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n        result = self.client_post(\"/devlogin/\", subdomain=\"\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"Click on a user to log in!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n\n        result = self.client_post(\"/devlogin/\", {\"new_realm\": \"all_realms\"}, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n        self.assert_in_success_response([\"Click on a user to log in!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n        data = {\"new_realm\": \"zephyr\"}\n        result = self.client_post(\"/devlogin/\", data, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zephyr.testserver\")\n\n        result = self.client_get(\"/devlogin/\", subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n        self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n        self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n    def test_choose_realm_with_subdomains_enabled(self) -> None:\n        with mock.patch(\"zerver.views.auth.is_subdomain_root_or_alias\", return_value=False):\n            with mock.patch(\n                \"zerver.views.auth.get_realm_from_request\", return_value=get_realm(\"zulip\")\n            ):\n                result = self.client_get(\"http://zulip.testserver/devlogin/\")\n                self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_not_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n\n            with mock.patch(\n                \"zerver.views.auth.get_realm_from_request\", return_value=get_realm(\"zephyr\")\n            ):\n                result = self.client_post(\n                    \"http://zulip.testserver/devlogin/\", {\"new_realm\": \"zephyr\"}\n                )\n                self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n                result = self.client_get(\"http://zephyr.testserver/devlogin/\")\n                self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n\n    def test_login_failure(self) -> None:\n        email = self.example_email(\"hamlet\")\n        data = {\"direct_email\": email}\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",)):\n            response = self.client_post(\"/accounts/login/local/\", data)\n        self.assert_in_success_response([\"Configuration error\", \"DevAuthBackend\"], response)\n\n    def test_dev_direct_production_config_error(self) -> None:\n        result = self.client_get(\"/config-error/dev\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response([\"DevAuthBackend\"], result)\n\n    def test_login_failure_due_to_nonexistent_user(self) -> None:\n        email = \"nonexisting@zulip.com\"\n        data = {\"direct_email\": email}\n\n        response = self.client_post(\"/accounts/login/local/\", data)\n        self.assert_in_success_response([\"Configuration error\", \"DevAuthBackend\"], response)\n\n\nclass TestZulipRemoteUserBackend(DesktopFlowTestingLib, ZulipTestCase):\n    def test_start_remote_user_sso(self) -> None:\n        result = self.client_get(\n            \"/accounts/login/start/sso/\", {\"param1\": \"value1\", \"params\": \"value2\"}\n        )\n        self.assertEqual(result.status_code, 302)\n\n        url = result.url\n        parsed_url = urllib.parse.urlparse(url)\n        self.assertEqual(parsed_url.path, \"/accounts/login/sso/\")\n        self.assertEqual(parsed_url.query, \"param1=value1&params=value2\")\n\n    def test_start_remote_user_sso_with_desktop_app(self) -> None:\n        headers = dict(HTTP_USER_AGENT=\"ZulipElectron/5.0.0\")\n        result = self.client_get(\"/accounts/login/start/sso/\", {}, **headers)\n        self.verify_desktop_flow_app_page(result)\n\n    def test_login_success(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_success_with_sso_append_domain(self) -> None:\n        username = \"hamlet\"\n        user_profile = self.example_user(\"hamlet\")\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",),\n            SSO_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=username)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_case_insensitive(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email_upper = user_profile.delivery_email.upper()\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email_upper)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_failure(self) -> None:\n        email = self.example_email(\"hamlet\")\n        result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n        self.assert_in_success_response(\n            [\"Configuration error\", \"Authentication via the REMOTE_USER header is\"], result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_failure_due_to_nonexisting_user(self) -> None:\n        email = \"nonexisting@zulip.com\"\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n            self.assertEqual(result.status_code, 200)\n            self.assert_logged_in_user_id(None)\n            self.assert_in_response(\"No account found for\", result)\n\n    def test_login_failure_due_to_invalid_email(self) -> None:\n        email = \"hamlet\"\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n            self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_login_failure_due_to_missing_field(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            result = self.client_get(\"/accounts/login/sso/\")\n            self.assert_in_success_response(\n                [\"Configuration error\", \"The REMOTE_USER header is not set.\"], result\n            )\n\n    def test_login_failure_due_to_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"acme\"):\n                result = self.client_get(\n                    \"http://testserver:9080/accounts/login/sso/\", REMOTE_USER=email\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assert_logged_in_user_id(None)\n                self.assert_in_response(\"You need an invitation to join this organization.\", result)\n\n    def test_login_failure_due_to_empty_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"\"):\n                result = self.client_get(\n                    \"http://testserver:9080/accounts/login/sso/\", REMOTE_USER=email\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assert_logged_in_user_id(None)\n                self.assert_in_response(\"You need an invitation to join this organization.\", result)\n\n    def test_login_success_under_subdomains(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"zulip\"):\n            with self.settings(\n                AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)\n            ):\n                result = self.client_get(\"/accounts/login/sso/\", REMOTE_USER=email)\n                self.assertEqual(result.status_code, 302)\n                self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_login_mobile_flow_otp_success_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        mobile_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"1234\"),\n            REMOTE_USER=email,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"invalido\" * 8),\n            REMOTE_USER=email,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=mobile_flow_otp),\n            REMOTE_USER=email,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(SSO_APPEND_DOMAIN=\"zulip.com\")\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",))\n    def test_login_mobile_flow_otp_success_username(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        remote_user = email_to_username(email)\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        mobile_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"1234\"),\n            REMOTE_USER=remote_user,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=\"invalido\" * 8),\n            REMOTE_USER=remote_user,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\",\n            dict(mobile_flow_otp=mobile_flow_otp),\n            REMOTE_USER=remote_user,\n            HTTP_USER_AGENT=\"ZulipAndroid\",\n        )\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result[\"Location\"]\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, \"zulip\")\n        self.assertEqual(query_params[\"realm\"], [\"http://zulip.testserver\"])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        hamlet_api_keys = get_all_api_keys(self.example_user(\"hamlet\"))\n        self.assertIn(otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp), hamlet_api_keys)\n        self.assert_length(mail.outbox, 1)\n        self.assertIn(\"Zulip on Android\", mail.outbox[0].body)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipRemoteUserBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_login_desktop_flow_otp_success_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        desktop_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"1234\"), REMOTE_USER=email\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"invalido\" * 8), REMOTE_USER=email\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=desktop_flow_otp), REMOTE_USER=email\n        )\n        self.verify_desktop_flow_end_page(result, email, desktop_flow_otp)\n\n    @override_settings(SEND_LOGIN_EMAILS=True)\n    @override_settings(SSO_APPEND_DOMAIN=\"zulip.com\")\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipRemoteUserBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_login_desktop_flow_otp_success_username(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        remote_user = email_to_username(email)\n        user_profile.date_joined = timezone_now() - datetime.timedelta(seconds=61)\n        user_profile.save()\n        desktop_flow_otp = \"1234abcd\" * 8\n\n        # Verify that the right thing happens with an invalid-format OTP\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"1234\"), REMOTE_USER=remote_user\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=\"invalido\" * 8), REMOTE_USER=remote_user\n        )\n        self.assert_logged_in_user_id(None)\n        self.assert_json_error_contains(result, \"Invalid OTP\", 400)\n\n        result = self.client_get(\n            \"/accounts/login/sso/\", dict(desktop_flow_otp=desktop_flow_otp), REMOTE_USER=remote_user\n        )\n        self.verify_desktop_flow_end_page(result, email, desktop_flow_otp)\n\n    def test_redirect_to(self) -> None:\n        \"\"\"This test verifies the behavior of the redirect_to logic in\n        login_or_register_remote_user.\"\"\"\n\n        def test_with_redirect_to_param_set_as_next(next: str = \"\") -> HttpResponse:\n            user_profile = self.example_user(\"hamlet\")\n            email = user_profile.delivery_email\n            with self.settings(\n                AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipRemoteUserBackend\",)\n            ):\n                result = self.client_get(\"/accounts/login/sso/\", {\"next\": next}, REMOTE_USER=email)\n            return result\n\n        res = test_with_redirect_to_param_set_as_next()\n        self.assertEqual(\"http://zulip.testserver\", res.url)\n        res = test_with_redirect_to_param_set_as_next(\"/user_uploads/image_path\")\n        self.assertEqual(\"http://zulip.testserver/user_uploads/image_path\", res.url)\n\n        # Third-party domains are rejected and just send you to root domain\n        res = test_with_redirect_to_param_set_as_next(\"https://rogue.zulip-like.server/login\")\n        self.assertEqual(\"http://zulip.testserver\", res.url)\n\n\nclass TestJWTLogin(ZulipTestCase):\n    \"\"\"\n    JWT uses ZulipDummyBackend.\n    \"\"\"\n\n    def test_login_success(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            email = self.example_email(\"hamlet\")\n            realm = get_realm(\"zulip\")\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n\n            user_profile = get_user_by_delivery_email(email, realm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assertEqual(result.status_code, 302)\n            self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_failure_when_user_is_missing(self) -> None:\n        payload = {\"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assert_json_error_contains(\n                result, \"No user specified in JSON web token claims\", 400\n            )\n\n    def test_login_failure_when_realm_is_missing(self) -> None:\n        payload = {\"user\": \"hamlet\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assert_json_error_contains(\n                result, \"No organization specified in JSON web token claims\", 400\n            )\n\n    def test_login_failure_when_key_does_not_exist(self) -> None:\n        data = {\"json_web_token\": \"not relevant\"}\n        result = self.client_post(\"/accounts/login/jwt/\", data)\n        self.assert_json_error_contains(result, \"Auth key for this subdomain not found.\", 400)\n\n    def test_login_failure_when_key_is_missing(self) -> None:\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            result = self.client_post(\"/accounts/login/jwt/\")\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n\n    def test_login_failure_when_bad_token_is_passed(self) -> None:\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            result = self.client_post(\"/accounts/login/jwt/\")\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n            data = {\"json_web_token\": \"bad token\"}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assert_json_error_contains(result, \"Bad JSON web token\", 400)\n\n    def test_login_failure_when_user_does_not_exist(self) -> None:\n        payload = {\"user\": \"nonexisting\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n            [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n            web_token = jwt.encode(payload, key, algorithm)\n            data = {\"json_web_token\": web_token}\n            result = self.client_post(\"/accounts/login/jwt/\", data)\n            self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n            self.assert_logged_in_user_id(None)\n\n    def test_login_failure_due_to_wrong_subdomain(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"acme\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"acme\"):\n                key = settings.JWT_AUTH_KEYS[\"acme\"][\"key\"]\n                [algorithm] = settings.JWT_AUTH_KEYS[\"acme\"][\"algorithms\"]\n                web_token = jwt.encode(payload, key, algorithm)\n\n                data = {\"json_web_token\": web_token}\n                result = self.client_post(\"/accounts/login/jwt/\", data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assert_logged_in_user_id(None)\n\n    def test_login_failure_due_to_empty_subdomain(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"\"):\n                key = settings.JWT_AUTH_KEYS[\"\"][\"key\"]\n                [algorithm] = settings.JWT_AUTH_KEYS[\"\"][\"algorithms\"]\n                web_token = jwt.encode(payload, key, algorithm)\n\n                data = {\"json_web_token\": web_token}\n                result = self.client_post(\"/accounts/login/jwt/\", data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assert_logged_in_user_id(None)\n\n    def test_login_success_under_subdomains(self) -> None:\n        payload = {\"user\": \"hamlet\", \"realm\": \"zulip.com\"}\n        with self.settings(JWT_AUTH_KEYS={\"zulip\": {\"key\": \"key\", \"algorithms\": [\"HS256\"]}}):\n            with mock.patch(\"zerver.views.auth.get_subdomain\", return_value=\"zulip\"):\n                key = settings.JWT_AUTH_KEYS[\"zulip\"][\"key\"]\n                [algorithm] = settings.JWT_AUTH_KEYS[\"zulip\"][\"algorithms\"]\n                web_token = jwt.encode(payload, key, algorithm)\n\n                data = {\"json_web_token\": web_token}\n                result = self.client_post(\"/accounts/login/jwt/\", data)\n                self.assertEqual(result.status_code, 302)\n                user_profile = self.example_user(\"hamlet\")\n                self.assert_logged_in_user_id(user_profile.id)\n\n\nclass DjangoToLDAPUsernameTests(ZulipTestCase):\n    def setUp(self) -> None:\n        self.init_default_ldap_database()\n        self.backend = ZulipLDAPAuthBackend()\n\n    def test_django_to_ldap_username_with_append_domain(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            self.assertEqual(self.backend.django_to_ldap_username(\"hamlet\"), \"hamlet\")\n            self.assertEqual(self.backend.django_to_ldap_username(\"hamlet@zulip.com\"), \"hamlet\")\n            with self.assertRaisesRegex(\n                ZulipLDAPExceptionOutsideDomain,\n                \"Email hamlet@example.com does not match LDAP domain zulip.com.\",\n            ):\n                self.backend.django_to_ldap_username(\"hamlet@example.com\")\n\n            self.mock_ldap.directory['uid=\"hamlet@test\",ou=users,dc=zulip,dc=com'] = {\n                \"cn\": [\"King Hamlet\"],\n                \"uid\": ['\"hamlet@test\"'],\n            }\n            username = self.backend.django_to_ldap_username('\"hamlet@test\"@zulip.com')\n            self.assertEqual(username, '\"hamlet@test\"')\n\n            self.mock_ldap.directory['uid=\"hamlet@test\"@zulip,ou=users,dc=zulip,dc=com'] = {\n                \"cn\": [\"King Hamlet\"],\n                \"uid\": ['\"hamlet@test\"@zulip'],\n            }\n            username = self.backend.django_to_ldap_username('\"hamlet@test\"@zulip')\n            self.assertEqual(username, '\"hamlet@test\"@zulip')\n\n    def test_django_to_ldap_username_with_email_search(self) -> None:\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"hamlet\"), self.ldap_username(\"hamlet\")\n        )\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"hamlet@zulip.com\"), self.ldap_username(\"hamlet\")\n        )\n        # If there are no matches through the email search, raise exception:\n        with self.assertRaises(ZulipLDAPExceptionNoMatchingLDAPUser):\n            self.backend.django_to_ldap_username(\"no_such_email@example.com\")\n\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"aaron@zulip.com\"), self.ldap_username(\"aaron\")\n        )\n\n        with self.assertLogs(level=\"WARNING\") as m:\n            with self.assertRaises(ZulipLDAPExceptionNoMatchingLDAPUser):\n                self.backend.django_to_ldap_username(\"shared_email@zulip.com\")\n        self.assertEqual(\n            m.output,\n            [\n                \"WARNING:root:Multiple users with email {} found in LDAP.\".format(\n                    \"shared_email@zulip.com\"\n                )\n            ],\n        )\n\n        # Test on a weird case of a user whose uid is an email and his actual \"mail\"\n        # attribute is a different email address:\n        self.mock_ldap.directory[\"uid=some_user@organization_a.com,ou=users,dc=zulip,dc=com\"] = {\n            \"cn\": [\"Some User\"],\n            \"uid\": [\"some_user@organization_a.com\"],\n            \"mail\": [\"some_user@contactaddress.com\"],\n        }\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"some_user@contactaddress.com\"),\n            \"some_user@organization_a.com\",\n        )\n        self.assertEqual(\n            self.backend.django_to_ldap_username(\"some_user@organization_a.com\"),\n            \"some_user@organization_a.com\",\n        )\n\n        # Configure email search for emails in the uid attribute:\n        with self.settings(\n            AUTH_LDAP_REVERSE_EMAIL_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(uid=%(email)s)\"\n            )\n        ):\n            self.assertEqual(\n                self.backend.django_to_ldap_username(\"newuser_email_as_uid@zulip.com\"),\n                \"newuser_email_as_uid@zulip.com\",\n            )\n\n            self.mock_ldap.directory['uid=\"hamlet@test\"@zulip.com\",ou=users,dc=zulip,dc=com'] = {\n                \"cn\": [\"King Hamlet\"],\n                \"uid\": ['\"hamlet@test\"@zulip.com'],\n            }\n            username = self.backend.django_to_ldap_username('\"hamlet@test\"@zulip.com')\n            self.assertEqual(username, '\"hamlet@test\"@zulip.com')\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n        )\n    )\n    def test_authenticate_to_ldap_via_email(self) -> None:\n        \"\"\"\n        With AUTH_LDAP_REVERSE_EMAIL_SEARCH configured, django_to_ldap_username\n        should be able to translate an email to LDAP username,\n        and thus it should be possible to authenticate through user_profile.delivery_email.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.assertEqual(\n                authenticate(\n                    request=mock.MagicMock(),\n                    username=user_profile.delivery_email,\n                    password=self.ldap_password(\"hamlet\"),\n                    realm=realm,\n                ),\n                user_profile,\n            )\n\n    @override_settings(LDAP_EMAIL_ATTR=\"mail\", LDAP_DEACTIVATE_NON_MATCHING_USERS=True)\n    def test_sync_user_from_ldap_with_email_attr(self) -> None:\n        \"\"\"In LDAP configurations with LDAP_EMAIL_ATTR configured and\n        LDAP_DEACTIVATE_NON_MATCHING_USERS set, a possible failure\n        mode if django_to_ldap_username isn't configured correctly is\n        all LDAP users having their accounts deactivated.  Before the\n        introduction of AUTH_LDAP_REVERSE_EMAIL_SEARCH, this would happen\n        even in valid LDAP configurations using LDAP_EMAIL_ATTR.\n\n        This test confirms that such a failure mode doesn't happen with\n        a valid LDAP configuration.\n        \"\"\"\n\n        user_profile = self.example_user(\"hamlet\")\n        with self.settings():\n            sync_user_from_ldap(user_profile, mock.Mock())\n            # Syncing didn't deactivate the user:\n            self.assertTrue(user_profile.is_active)\n\n\nclass ZulipLDAPTestCase(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n\n        self.init_default_ldap_database()\n\n        user_profile = self.example_user(\"hamlet\")\n        self.setup_subdomain(user_profile)\n        self.backend = ZulipLDAPAuthBackend()\n\n        # Internally `_realm` and `_prereg_user` attributes are automatically set\n        # by the `authenticate()` method. But for testing the `get_or_build_user()`\n        # method separately, we need to set them manually.\n        self.backend._realm = get_realm(\"zulip\")\n        self.backend._prereg_user = None\n\n    def setup_subdomain(self, user_profile: UserProfile) -> None:\n        realm = user_profile.realm\n        realm.string_id = \"zulip\"\n        realm.save()\n\n\nclass TestLDAP(ZulipLDAPTestCase):\n    def test_generate_dev_ldap_dir(self) -> None:\n        ldap_dir = generate_dev_ldap_dir(\"A\", 10)\n        self.assert_length(ldap_dir, 10)\n        regex = re.compile(\n            r\"(uid\\=)+[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+(\\,ou\\=users\\,dc\\=zulip\\,dc\\=com)\"\n        )\n        common_attrs = [\"cn\", \"userPassword\", \"phoneNumber\", \"birthDate\"]\n        for key, value in ldap_dir.items():\n            self.assertTrue(regex.match(key))\n            self.assertCountEqual(\n                list(value.keys()), [*common_attrs, \"uid\", \"thumbnailPhoto\", \"userAccountControl\"]\n            )\n\n        ldap_dir = generate_dev_ldap_dir(\"b\", 9)\n        self.assert_length(ldap_dir, 9)\n        regex = re.compile(r\"(uid\\=)+[a-zA-Z0-9_.+-]+(\\,ou\\=users\\,dc\\=zulip\\,dc\\=com)\")\n        for key, value in ldap_dir.items():\n            self.assertTrue(regex.match(key))\n            self.assertCountEqual(list(value.keys()), [*common_attrs, \"uid\", \"jpegPhoto\"])\n\n        ldap_dir = generate_dev_ldap_dir(\"c\", 8)\n        self.assert_length(ldap_dir, 8)\n        regex = re.compile(r\"(uid\\=)+[a-zA-Z0-9_.+-]+(\\,ou\\=users\\,dc\\=zulip\\,dc\\=com)\")\n        for key, value in ldap_dir.items():\n            self.assertTrue(regex.match(key))\n            self.assertCountEqual(list(value.keys()), [*common_attrs, \"uid\", \"email\"])\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_dev_ldap_fail_login(self) -> None:\n        # Tests that login with a substring of password fails. We had a bug in\n        # dev LDAP environment that allowed login via password substrings.\n        self.mock_ldap.directory = generate_dev_ldap_dir(\"B\", 8)\n        with self.settings(\n            AUTH_LDAP_USER_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(uid=%(user)s)\"\n            ),\n            AUTH_LDAP_REVERSE_EMAIL_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(email=%(email)s)\"\n            ),\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"ldapuser1\",\n                password=\"dapu\",\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is None\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_username(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"hamlet\",\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is not None\n            self.assertEqual(user_profile, self.example_user(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_email_attr(self) -> None:\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            username = self.ldap_username(\"aaron\")\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=username,\n                password=self.ldap_password(username),\n                realm=get_realm(\"zulip\"),\n            )\n\n            assert user_profile is not None\n            self.assertEqual(user_profile, self.example_user(\"aaron\"))\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n        )\n    )\n    def test_email_and_ldap_backends_together(self) -> None:\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_REVERSE_EMAIL_SEARCH=LDAPSearch(\n                \"ou=users,dc=zulip,dc=com\", ldap.SCOPE_ONELEVEL, \"(mail=%(email)s)\"\n            ),\n            AUTH_LDAP_USERNAME_ATTR=\"uid\",\n        ):\n            realm = get_realm(\"zulip\")\n            self.assertEqual(email_belongs_to_ldap(realm, self.example_email(\"aaron\")), True)\n            username = self.ldap_username(\"aaron\")\n            user_profile = ZulipLDAPAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=username,\n                password=self.ldap_password(username),\n                realm=realm,\n            )\n            self.assertEqual(user_profile, self.example_user(\"aaron\"))\n\n            othello = self.example_user(\"othello\")\n            password = \"testpassword\"\n            othello.set_password(password)\n            othello.save()\n\n            self.assertEqual(email_belongs_to_ldap(realm, othello.delivery_email), False)\n            user_profile = EmailAuthBackend().authenticate(\n                request=mock.MagicMock(),\n                username=othello.delivery_email,\n                password=password,\n                realm=realm,\n            )\n            self.assertEqual(user_profile, othello)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_due_to_wrong_password(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=\"wrong\",\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_due_to_nonexistent_user(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"), self.assertLogs(\n            \"zulip.ldap\", level=\"DEBUG\"\n        ) as log_debug:\n            user = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"nonexistent@zulip.com\",\n                password=\"doesnt_matter\",\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertEqual(\n                log_debug.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_permissions(self) -> None:\n        backend = self.backend\n        self.assertFalse(backend.has_perm(None, None))\n        self.assertFalse(backend.has_module_perms(None, None))\n        self.assertTrue(backend.get_all_permissions(None, None) == set())\n        self.assertTrue(backend.get_group_permissions(None, None) == set())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_user_email_from_ldapuser_with_append_domain(self) -> None:\n        backend = self.backend\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            username = backend.user_email_from_ldapuser(\n                \"this_argument_is_ignored\", _LDAPUser(self.backend, username='\"hamlet@test\"')\n            )\n            self.assertEqual(username, '\"hamlet@test\"@zulip.com')\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_user_exists(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"], \"sn\": [\"Short Name\"]}\n\n        backend = self.backend\n        email = self.example_email(\"hamlet\")\n        user_profile, created = backend.get_or_build_user(str(email), _LDAPUser())\n        self.assertFalse(created)\n        self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_user_does_not_exist(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = \"newuser@zulip.com\"\n            user_profile, created = backend.get_or_build_user(email, _LDAPUser())\n            self.assertTrue(created)\n            self.assertEqual(user_profile.delivery_email, email)\n            self.assertEqual(user_profile.full_name, \"Full Name\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_user_has_invalid_name(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"<invalid name>\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            with self.assertRaisesRegex(Exception, \"Invalid characters in name!\"):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_realm_is_deactivated(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            do_deactivate_realm(backend._realm, acting_user=None)\n            with self.assertRaisesRegex(Exception, \"Realm has been deactivated\"):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_ldap_has_no_email_attr(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"], \"sn\": [\"Short Name\"]}\n\n        nonexisting_attr = \"email\"\n        with self.settings(LDAP_EMAIL_ATTR=nonexisting_attr):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            with self.assertRaisesRegex(\n                Exception, \"LDAP user doesn't have the needed email attribute\"\n            ):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_email(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Test User\"]}\n\n        ldap_user_attr_map = {\"full_name\": \"fn\"}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            realm = self.backend._realm\n            realm.emails_restricted_to_domains = False\n            realm.disallow_disposable_email_addresses = True\n            realm.save()\n\n            email = \"spam@mailnator.com\"\n            with self.assertRaisesRegex(ZulipLDAPException, \"Email validation failed.\"):\n                self.backend.get_or_build_user(email, _LDAPUser())\n\n            realm.emails_restricted_to_domains = True\n            realm.save(update_fields=[\"emails_restricted_to_domains\"])\n\n            email = \"spam+spam@mailnator.com\"\n            with self.assertRaisesRegex(ZulipLDAPException, \"Email validation failed.\"):\n                self.backend.get_or_build_user(email, _LDAPUser())\n\n            email = \"spam@acme.com\"\n            with self.assertRaisesRegex(\n                ZulipLDAPException, \"This email domain isn't allowed in this organization.\"\n            ):\n                self.backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_get_or_build_user_when_ldap_has_no_full_name_mapping(self) -> None:\n        class _LDAPUser:\n            attrs = {\"fn\": [\"Full Name\"], \"sn\": [\"Short Name\"]}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={}):\n            backend = self.backend\n            email = \"nonexisting@zulip.com\"\n            with self.assertRaisesRegex(Exception, \"Missing required mapping for user's full name\"):\n                backend.get_or_build_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_when_domain_does_not_match(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"acme.com\"), self.assertLogs(\n            \"zulip.ldap\", \"DEBUG\"\n        ) as debug_log:\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertIs(user_profile, None)\n        self.assertEqual(\n            debug_log.output,\n            [\n                \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email hamlet@zulip.com does not match LDAP domain acme.com.\"\n            ],\n        )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_different_subdomain(self) -> None:\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        do_create_realm(string_id=\"acme\", name=\"acme\")\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"zulip.com\", AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map\n        ):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"acme\"),\n            )\n            self.assertEqual(user_profile.delivery_email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_with_valid_subdomain(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_failure_due_to_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=self.example_email(\"hamlet\"),\n                password=self.ldap_password(\"hamlet\"),\n                realm=get_realm(\"zulip\"),\n            )\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    @override_settings(\n        AUTH_LDAP_USER_ATTR_MAP={\n            \"full_name\": \"cn\",\n            \"avatar\": \"jpegPhoto\",\n        }\n    )\n    def test_login_success_when_user_does_not_exist_with_valid_subdomain(self) -> None:\n        RealmDomain.objects.create(realm=self.backend._realm, domain=\"acme.com\")\n        with self.settings(LDAP_APPEND_DOMAIN=\"acme.com\"):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"newuser@acme.com\",\n                password=self.ldap_password(\"newuser\"),\n                realm=get_realm(\"zulip\"),\n            )\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, \"newuser@acme.com\")\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n            self.assertEqual(user_profile.realm.string_id, \"zulip\")\n\n            # Verify avatar gets created\n            self.assertEqual(user_profile.avatar_source, UserProfile.AVATAR_FROM_USER)\n            url = avatar_url(user_profile)\n            assert url is not None\n            response = self.client_get(url)\n            self.assertEqual(response.status_code, 200)\n            with open(os.path.join(settings.DEPLOY_ROOT, \"static/images/team/tim.png\"), \"rb\") as f:\n                tim = f.read()\n            self.assert_streaming_content(response, resize_avatar(tim, DEFAULT_AVATAR_SIZE))\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_login_success_when_user_does_not_exist_with_split_full_name_mapping(self) -> None:\n        with self.settings(\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP={\"first_name\": \"sn\", \"last_name\": \"cn\"},\n        ):\n            user_profile = self.backend.authenticate(\n                request=mock.MagicMock(),\n                username=\"newuser_splitname@zulip.com\",\n                password=self.ldap_password(\"newuser_splitname\"),\n                realm=get_realm(\"zulip\"),\n            )\n            assert user_profile is not None\n            self.assertEqual(user_profile.delivery_email, \"newuser_splitname@zulip.com\")\n            self.assertEqual(user_profile.full_name, \"First Last\")\n            self.assertEqual(user_profile.realm.string_id, \"zulip\")\n\n\nclass TestZulipLDAPUserPopulator(ZulipLDAPTestCase):\n    def test_authenticate(self) -> None:\n        backend = ZulipLDAPUserPopulator()\n        result = backend.authenticate(\n            username=self.example_email(\"hamlet\"),\n            password=self.ldap_password(\"hamlet\"),\n            realm=get_realm(\"zulip\"),\n        )\n        self.assertIs(result, None)\n\n    def perform_ldap_sync(self, user_profile: UserProfile) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            result = sync_user_from_ldap(user_profile, mock.Mock())\n            self.assertTrue(result)\n\n    @mock.patch(\"zproject.backends.do_deactivate_user\")\n    def test_ldaperror_doesnt_deactivate_user(self, mock_deactivate: mock.MagicMock) -> None:\n        \"\"\"\n        This is a test for a bug where failure to connect to LDAP in sync_user_from_ldap\n        (e.g. due to invalid credentials) would cause the user to be deactivated if\n        LDAP_DEACTIVATE_NON_MATCHING_USERS was True.\n        Details: https://github.com/zulip/zulip/issues/13130\n        \"\"\"\n        with self.settings(\n            LDAP_DEACTIVATE_NON_MATCHING_USERS=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"wrongpass\",\n        ):\n            with self.assertRaises(ldap.INVALID_CREDENTIALS):\n                sync_user_from_ldap(self.example_user(\"hamlet\"), mock.Mock())\n            mock_deactivate.assert_not_called()\n\n        # Make sure other types of LDAPError won't cause deactivation either:\n        with mock.patch.object(_LDAPUser, \"_get_or_create_user\", side_effect=ldap.LDAPError):\n            with self.assertRaises(PopulateUserLDAPError):\n                sync_user_from_ldap(self.example_user(\"hamlet\"), mock.Mock())\n            mock_deactivate.assert_not_called()\n\n    @override_settings(LDAP_EMAIL_ATTR=\"mail\")\n    def test_populate_user_returns_none(self) -> None:\n        with mock.patch.object(ZulipLDAPUser, \"populate_user\", return_value=None):\n            with self.assertRaises(PopulateUserLDAPError):\n                sync_user_from_ldap(self.example_user(\"hamlet\"), mock.Mock())\n\n    def test_update_full_name(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"New Name\")\n\n        self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.full_name, \"New Name\")\n\n    def test_update_with_hidden_emails(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm,\n            \"email_address_visibility\",\n            Realm.EMAIL_ADDRESS_VISIBILITY_ADMINS,\n            acting_user=None,\n        )\n        hamlet.refresh_from_db()\n\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"New Name\")\n        self.perform_ldap_sync(hamlet)\n\n        hamlet.refresh_from_db()\n        self.assertEqual(hamlet.full_name, \"New Name\")\n\n    def test_update_split_full_name(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"Name\")\n        self.change_ldap_user_attr(\"hamlet\", \"sn\", \"Full\")\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"first_name\": \"sn\", \"last_name\": \"cn\"}):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertEqual(hamlet.full_name, \"Full Name\")\n\n    def test_same_full_name(self) -> None:\n        with mock.patch(\"zerver.lib.actions.do_change_full_name\") as fn:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_not_called()\n\n    def test_too_short_name(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"a\")\n\n        with self.assertRaises(ZulipLDAPException), self.assertLogs(\n            \"django_auth_ldap\", \"WARNING\"\n        ) as warn_log:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        self.assertEqual(\n            warn_log.output,\n            [\"WARNING:django_auth_ldap:Name too short! while authenticating hamlet\"],\n        )\n\n    def test_deactivate_user_with_useraccountcontrol_attr(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"userAccountControl\", \"2\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"userAccountControl\": \"userAccountControl\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertFalse(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Deactivating user hamlet@zulip.com because they are disabled in LDAP.\"\n            ],\n        )\n\n    def test_deactivate_reactivate_user_with_deactivated_attr(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"someCustomAttr\", \"TRUE\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"deactivated\": \"someCustomAttr\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertFalse(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Deactivating user hamlet@zulip.com because they are disabled in LDAP.\"\n            ],\n        )\n\n        self.change_ldap_user_attr(\"hamlet\", \"someCustomAttr\", \"FALSE\")\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"deactivated\": \"someCustomAttr\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet.refresh_from_db()\n        self.assertTrue(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Reactivating user hamlet@zulip.com because they are not disabled in LDAP.\"\n            ],\n        )\n\n        self.change_ldap_user_attr(\"hamlet\", \"someCustomAttr\", \"YESSS\")\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"deactivated\": \"someCustomAttr\"}\n        ), self.assertLogs(\"django_auth_ldap\") as ldap_logs, self.assertRaises(AssertionError):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet.refresh_from_db()\n        self.assertTrue(hamlet.is_active)\n        self.assertEqual(\n            ldap_logs.output,\n            [\n                \"WARNING:django_auth_ldap:Invalid value 'YESSS' in the LDAP attribute mapped to deactivated while authenticating hamlet\"\n            ],\n        )\n\n    @mock.patch(\"zproject.backends.ZulipLDAPAuthBackendBase.sync_full_name_from_ldap\")\n    def test_dont_sync_disabled_ldap_user(self, fake_sync: mock.MagicMock) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"userAccountControl\", \"2\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"userAccountControl\": \"userAccountControl\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fake_sync.assert_not_called()\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Deactivating user hamlet@zulip.com because they are disabled in LDAP.\"\n            ],\n        )\n\n    def test_reactivate_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"userAccountControl\": \"userAccountControl\"}\n        ), self.assertLogs(\"zulip.ldap\") as info_logs:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        self.assertTrue(hamlet.is_active)\n        self.assertEqual(\n            info_logs.output,\n            [\n                \"INFO:zulip.ldap:Reactivating user hamlet@zulip.com because they are not disabled in LDAP.\"\n            ],\n        )\n\n    def test_user_in_multiple_realms(self) -> None:\n        test_realm = do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n        hamlet = self.example_user(\"hamlet\")\n        email = hamlet.delivery_email\n        hamlet2 = do_create_user(email, None, test_realm, hamlet.full_name, acting_user=None)\n\n        self.change_ldap_user_attr(\"hamlet\", \"cn\", \"Second Hamlet\")\n        expected_call_args = [hamlet2, \"Second Hamlet\", None]\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\"}):\n            with mock.patch(\"zerver.lib.actions.do_change_full_name\") as f:\n                self.perform_ldap_sync(hamlet2)\n                f.assert_called_once_with(*expected_call_args)\n\n                # Get the updated model and make sure the full name is changed correctly:\n                hamlet2 = get_user_by_delivery_email(email, test_realm)\n                self.assertEqual(hamlet2.full_name, \"Second Hamlet\")\n                # Now get the original hamlet and make he still has his name unchanged:\n                hamlet = self.example_user(\"hamlet\")\n                self.assertEqual(hamlet.full_name, \"King Hamlet\")\n\n    def test_user_not_found_in_ldap(self) -> None:\n        with self.settings(\n            LDAP_DEACTIVATE_NON_MATCHING_USERS=False, LDAP_APPEND_DOMAIN=\"zulip.com\"\n        ):\n            othello = self.example_user(\"othello\")  # othello isn't in our test directory\n            mock_logger = mock.MagicMock()\n            result = sync_user_from_ldap(othello, mock_logger)\n            mock_logger.warning.assert_called_once_with(\n                \"Did not find %s in LDAP.\", othello.delivery_email\n            )\n            self.assertFalse(result)\n\n            do_deactivate_user(othello, acting_user=None)\n            mock_logger = mock.MagicMock()\n            result = sync_user_from_ldap(othello, mock_logger)\n            # In this case the logger shouldn't be used.\n            self.assertEqual(mock_logger.method_calls, [])\n            self.assertFalse(result)\n\n    def test_update_user_avatar(self) -> None:\n        # Hamlet has jpegPhoto set in our test directory by default.\n        with mock.patch(\"zerver.lib.upload.upload_avatar_image\") as fn, self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_called_once()\n            hamlet = self.example_user(\"hamlet\")\n            self.assertEqual(hamlet.avatar_source, UserProfile.AVATAR_FROM_USER)\n\n            # Verify that the next time we do an LDAP sync, we don't\n            # end up updating this user's avatar again if the LDAP\n            # data hasn't changed.\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_called_once()\n\n        # Now verify that if we do change the jpegPhoto image, we\n        # will upload a new avatar.\n        self.change_ldap_user_attr(\n            \"hamlet\", \"jpegPhoto\", static_path(\"images/logo/zulip-icon-512x512.png\"), binary=True\n        )\n        with mock.patch(\"zerver.lib.upload.upload_avatar_image\") as fn, self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            fn.assert_called_once()\n            hamlet = self.example_user(\"hamlet\")\n            self.assertEqual(hamlet.avatar_source, UserProfile.AVATAR_FROM_USER)\n\n    @use_s3_backend\n    def test_update_user_avatar_for_s3(self) -> None:\n        bucket = create_s3_buckets(settings.S3_AVATAR_BUCKET)[0]\n        test_image_data = read_test_image_file(\"img.png\")\n        self.change_ldap_user_attr(\"hamlet\", \"jpegPhoto\", test_image_data)\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n\n        hamlet = self.example_user(\"hamlet\")\n        path_id = user_avatar_path(hamlet)\n        original_image_path_id = path_id + \".original\"\n        medium_path_id = path_id + \"-medium.png\"\n\n        original_image_key = bucket.Object(original_image_path_id)\n        medium_image_key = bucket.Object(medium_path_id)\n\n        image_data = original_image_key.get()[\"Body\"].read()\n        self.assertEqual(image_data, test_image_data)\n\n        test_medium_image_data = resize_avatar(test_image_data, MEDIUM_AVATAR_SIZE)\n        medium_image_data = medium_image_key.get()[\"Body\"].read()\n        self.assertEqual(medium_image_data, test_medium_image_data)\n\n        # Try to use invalid data as the image:\n        self.change_ldap_user_attr(\"hamlet\", \"jpegPhoto\", b\"00\" + test_image_data)\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\", \"avatar\": \"jpegPhoto\"}):\n            with self.assertLogs(level=\"WARNING\") as m:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            self.assertEqual(\n                m.output,\n                [\n                    \"WARNING:root:Could not parse {} field for user {}\".format(\n                        \"jpegPhoto\", hamlet.id\n                    )\n                ],\n            )\n\n    def test_deactivate_non_matching_users(self) -> None:\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\", LDAP_DEACTIVATE_NON_MATCHING_USERS=True):\n            # othello isn't in our test directory\n            result = sync_user_from_ldap(self.example_user(\"othello\"), mock.Mock())\n\n            self.assertTrue(result)\n            othello = self.example_user(\"othello\")\n            self.assertFalse(othello.is_active)\n\n    def test_update_custom_profile_field(self) -> None:\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__phone_number\": \"homePhone\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n            }\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n        hamlet = self.example_user(\"hamlet\")\n        test_data = [\n            {\n                \"field_name\": \"Phone number\",\n                \"expected_value\": \"123456789\",\n            },\n            {\n                \"field_name\": \"Birthday\",\n                \"expected_value\": \"1900-09-08\",\n            },\n        ]\n        for test_case in test_data:\n            field = CustomProfileField.objects.get(realm=hamlet.realm, name=test_case[\"field_name\"])\n            field_value = CustomProfileFieldValue.objects.get(\n                user_profile=hamlet, field=field\n            ).value\n            self.assertEqual(field_value, test_case[\"expected_value\"])\n\n    def test_update_non_existent_profile_field(self) -> None:\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__non_existent\": \"homePhone\",\n            }\n        ):\n            with self.assertRaisesRegex(\n                ZulipLDAPException, \"Custom profile field with name non_existent not found\"\n            ), self.assertLogs(\"django_auth_ldap\", \"WARNING\") as warn_log:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            self.assertEqual(\n                warn_log.output,\n                [\n                    \"WARNING:django_auth_ldap:Custom profile field with name non_existent not found. while authenticating hamlet\"\n                ],\n            )\n\n    def test_update_custom_profile_field_invalid_data(self) -> None:\n        self.change_ldap_user_attr(\"hamlet\", \"birthDate\", \"9999\")\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n            }\n        ):\n            with self.assertRaisesRegex(\n                ZulipLDAPException, \"Invalid data for birthday field\"\n            ), self.assertLogs(\"django_auth_ldap\", \"WARNING\") as warn_log:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n            self.assertEqual(\n                warn_log.output,\n                [\n                    \"WARNING:django_auth_ldap:Invalid data for birthday field: Birthday is not a date while authenticating hamlet\"\n                ],\n            )\n\n    def test_update_custom_profile_field_no_mapping(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        no_op_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Phone number\")\n        expected_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n            }\n        ):\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n\n        actual_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n        self.assertEqual(actual_value, expected_value)\n\n    def test_update_custom_profile_field_no_update(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        phone_number_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Phone number\")\n        birthday_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Birthday\")\n        phone_number_field_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=phone_number_field\n        )\n        phone_number_field_value.value = \"123456789\"\n        phone_number_field_value.save(update_fields=[\"value\"])\n        expected_call_args = [\n            hamlet,\n            [\n                {\n                    \"id\": birthday_field.id,\n                    \"value\": \"1900-09-08\",\n                },\n            ],\n        ]\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n                \"custom_profile_field__phone_number\": \"homePhone\",\n            }\n        ):\n            with mock.patch(\"zproject.backends.do_update_user_custom_profile_data_if_changed\") as f:\n                self.perform_ldap_sync(self.example_user(\"hamlet\"))\n                f.assert_called_once_with(*expected_call_args)\n\n    def test_update_custom_profile_field_not_present_in_ldap(self) -> None:\n        hamlet = self.example_user(\"hamlet\")\n        no_op_field = CustomProfileField.objects.get(realm=hamlet.realm, name=\"Birthday\")\n        expected_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"custom_profile_field__birthday\": \"nonExistentAttr\",\n            }\n        ), self.assertLogs(\"django_auth_ldap\", \"WARNING\") as warn_log:\n            self.perform_ldap_sync(self.example_user(\"hamlet\"))\n\n        actual_value = CustomProfileFieldValue.objects.get(\n            user_profile=hamlet, field=no_op_field\n        ).value\n        self.assertEqual(actual_value, expected_value)\n        self.assertEqual(\n            warn_log.output,\n            [\n                \"WARNING:django_auth_ldap:uid=hamlet,ou=users,dc=zulip,dc=com does not have a value for the attribute nonExistentAttr\"\n            ],\n        )\n\n\nclass TestQueryLDAP(ZulipLDAPTestCase):\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",))\n    def test_ldap_not_configured(self) -> None:\n        values = query_ldap(self.example_email(\"hamlet\"))\n        self.assertEqual(values, [\"LDAP backend not configured on this server.\"])\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_user_not_present(self) -> None:\n        # othello doesn't have an entry in our test directory\n        values = query_ldap(self.example_email(\"othello\"))\n        self.assert_length(values, 1)\n        self.assertIn(\"No such user found\", values[0])\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_normal_query(self) -> None:\n        with self.settings(\n            AUTH_LDAP_USER_ATTR_MAP={\n                \"full_name\": \"cn\",\n                \"avatar\": \"jpegPhoto\",\n                \"custom_profile_field__birthday\": \"birthDate\",\n                \"custom_profile_field__phone_number\": \"nonExistentAttr\",\n            }\n        ):\n            values = query_ldap(self.example_email(\"hamlet\"))\n        self.assert_length(values, 4)\n        self.assertIn(\"full_name: King Hamlet\", values)\n        self.assertIn(\"avatar: (An avatar image file)\", values)\n        self.assertIn(\"custom_profile_field__birthday: 1900-09-08\", values)\n        self.assertIn(\"custom_profile_field__phone_number: LDAP field not present\", values)\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_query_email_attr(self) -> None:\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP={\"full_name\": \"cn\"}, LDAP_EMAIL_ATTR=\"mail\"):\n            # This will look up the user by email in our test dictionary,\n            # should successfully find hamlet's LDAP entry.\n            values = query_ldap(self.example_email(\"hamlet\"))\n        self.assert_length(values, 2)\n        self.assertIn(\"full_name: King Hamlet\", values)\n        self.assertIn(\"email: hamlet@zulip.com\", values)\n\n\nclass TestZulipAuthMixin(ZulipTestCase):\n    def test_get_user(self) -> None:\n        backend = ZulipAuthMixin()\n        result = backend.get_user(11111)\n        self.assertIs(result, None)\n\n\nclass TestPasswordAuthEnabled(ZulipTestCase):\n    def test_password_auth_enabled_for_ldap(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",)):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertTrue(password_auth_enabled(realm))\n\n\nclass TestRequireEmailFormatUsernames(ZulipTestCase):\n    def test_require_email_format_usernames_for_ldap_with_append_domain(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_ldap_with_email_attr(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            LDAP_EMAIL_ATTR=\"email\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_only(self) -> None:\n        with self.settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",)):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertTrue(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_email_attr(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.ZulipLDAPAuthBackend\",\n            ),\n            LDAP_EMAIL_ATTR=\"email\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_append_email(self) -> None:\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\n                \"zproject.backends.EmailAuthBackend\",\n                \"zproject.backends.ZulipLDAPAuthBackend\",\n            ),\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n        ):\n            realm = Realm.objects.get(string_id=\"zulip\")\n            self.assertFalse(require_email_format_usernames(realm))\n\n\nclass TestMaybeSendToRegistration(ZulipTestCase):\n    def test_sso_only_when_preregistration_user_does_not_exist(self) -> None:\n        rf = RequestFactory()\n        request = rf.get(\"/\")\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_homepage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form:\n            def is_valid(self) -> bool:\n                return True\n\n        with mock.patch(\"zerver.views.auth.HomepageForm\", return_value=Form()):\n            self.assertEqual(PreregistrationUser.objects.all().count(), 0)\n            result = maybe_send_to_registration(\n                request, self.example_email(\"hamlet\"), is_signup=True\n            )\n            self.assertEqual(result.status_code, 302)\n            confirmation = Confirmation.objects.all().first()\n            assert confirmation is not None\n            confirmation_key = confirmation.confirmation_key\n            self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n            self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        self.assert_in_response(f'value=\"{confirmation_key}\" name=\"key\"', result)\n\n    def test_sso_only_when_preregistration_user_exists(self) -> None:\n        rf = RequestFactory()\n        request = rf.get(\"/\")\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_homepage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form:\n            def is_valid(self) -> bool:\n                return True\n\n        email = self.example_email(\"hamlet\")\n        user = PreregistrationUser(email=email)\n        user.save()\n        create_confirmation_link(user, Confirmation.USER_REGISTRATION)\n\n        with mock.patch(\"zerver.views.auth.HomepageForm\", return_value=Form()):\n            self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n            result = maybe_send_to_registration(request, email, is_signup=True)\n            self.assertEqual(result.status_code, 302)\n            confirmation = Confirmation.objects.all().last()\n            assert confirmation is not None\n            confirmation_key = confirmation.confirmation_key\n            self.assertIn(\"do_confirm/\" + confirmation_key, result.url)\n            self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\n\nclass TestAdminSetBackends(ZulipTestCase):\n    def test_change_enabled_backends(self) -> None:\n        # Log in as admin\n        self.login(\"iago\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"authentication_methods\": orjson.dumps({\"Email\": False, \"Dev\": True}).decode()},\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"authentication_methods\": orjson.dumps({\"Email\": False, \"Dev\": True}).decode()},\n        )\n        self.assert_json_success(result)\n        realm = get_realm(\"zulip\")\n        self.assertFalse(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_disable_all_backends(self) -> None:\n        # Log in as admin\n        self.login(\"desdemona\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"authentication_methods\": orjson.dumps({\"Email\": False, \"Dev\": False}).decode()},\n        )\n        self.assert_json_error(result, \"At least one authentication method must be enabled.\")\n        realm = get_realm(\"zulip\")\n        self.assertTrue(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_supported_backends_only_updated(self) -> None:\n        # Log in as admin\n        self.login(\"desdemona\")\n        # Set some supported and unsupported backends\n        result = self.client_patch(\n            \"/json/realm\",\n            {\n                \"authentication_methods\": orjson.dumps(\n                    {\"Email\": False, \"Dev\": True, \"GitHub\": False}\n                ).decode()\n            },\n        )\n        self.assert_json_success(result)\n        realm = get_realm(\"zulip\")\n        # Check that unsupported backend is not enabled\n        self.assertFalse(github_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n        self.assertFalse(password_auth_enabled(realm))\n\n\nclass EmailValidatorTestCase(ZulipTestCase):\n    def test_valid_email(self) -> None:\n        validate_login_email(self.example_email(\"hamlet\"))\n\n    def test_invalid_email(self) -> None:\n        with self.assertRaises(JsonableError):\n            validate_login_email(\"hamlet\")\n\n    def test_validate_email(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        cordelia = self.example_user(\"cordelia\")\n\n        realm = inviter.realm\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n        inviter.realm.refresh_from_db()\n        error = validate_email_is_valid(\n            \"fred+5555@zulip.com\",\n            get_realm_email_validator(realm),\n        )\n        self.assertIn(\"containing + are not allowed\", error)\n\n        cordelia_email = cordelia.delivery_email\n        errors = get_existing_user_errors(realm, {cordelia_email})\n        error, is_deactivated = errors[cordelia_email]\n        self.assertEqual(False, is_deactivated)\n        self.assertEqual(error, \"Already has an account.\")\n\n        change_user_is_active(cordelia, False)\n\n        errors = get_existing_user_errors(realm, {cordelia_email})\n        error, is_deactivated = errors[cordelia_email]\n        self.assertEqual(True, is_deactivated)\n        self.assertEqual(error, \"Account has been deactivated.\")\n\n        errors = get_existing_user_errors(realm, {\"fred-is-fine@zulip.com\"})\n        self.assertEqual(errors, {})\n\n\nclass LDAPBackendTest(ZulipTestCase):\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_non_existing_realm(self) -> None:\n        self.init_default_ldap_database()\n        user = self.example_user(\"hamlet\")\n\n        data = dict(\n            username=user.delivery_email,\n            password=initial_password(user.delivery_email),\n        )\n        error_type = ZulipLDAPAuthBackend.REALM_IS_NONE_ERROR\n        error = ZulipLDAPConfigurationError(\"Realm is None\", error_type)\n        with mock.patch(\n            \"zproject.backends.ZulipLDAPAuthBackend.get_or_build_user\", side_effect=error\n        ), mock.patch(\"django_auth_ldap.backend._LDAPUser._authenticate_user_dn\"), self.assertLogs(\n            \"django_auth_ldap\", \"WARNING\"\n        ) as warn_log:\n            response = self.client_post(\"/login/\", data)\n            self.assert_in_success_response(\n                [\"Configuration error\", \"You are trying to log in using LDAP without creating an\"],\n                response,\n            )\n        self.assertEqual(\n            warn_log.output,\n            [\"WARNING:django_auth_ldap:('Realm is None', 1) while authenticating hamlet\"],\n        )\n", "import datetime\nimport re\nimport time\nimport urllib\nfrom typing import Any, Dict, List, Optional, Sequence, Union\nfrom unittest.mock import MagicMock, patch\nfrom urllib.parse import urlencode\n\nimport orjson\nfrom django.conf import settings\nfrom django.contrib.auth.views import PasswordResetConfirmView\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import Client, override_settings\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    create_confirmation_link,\n    get_object_from_key,\n    one_click_unsubscribe_link,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.context_processors import common_context\nfrom zerver.decorator import do_two_factor_login\nfrom zerver.forms import HomepageForm, check_subdomain_available\nfrom zerver.lib.actions import (\n    add_new_user_history,\n    change_user_is_active,\n    do_add_default_stream,\n    do_change_full_name,\n    do_change_realm_subdomain,\n    do_change_user_role,\n    do_create_default_stream_group,\n    do_create_multiuse_invite_link,\n    do_create_realm,\n    do_create_user,\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_set_realm_property,\n    do_set_realm_user_default_setting,\n    get_default_streams_for_realm,\n)\nfrom zerver.lib.email_notifications import enqueue_welcome_emails, followup_day2_email_delay\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import (\n    ascii_to_hex,\n    hex_to_ascii,\n    is_valid_otp,\n    otp_decrypt_api_key,\n    otp_encrypt_api_key,\n    xor_hex_strings,\n)\nfrom zerver.lib.name_restrictions import is_disposable_domain\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.send_email import (\n    EmailNotDeliveredException,\n    FromAddress,\n    deliver_scheduled_emails,\n    send_future_email,\n)\nfrom zerver.lib.stream_subscription import get_stream_subscriptions_for_user\nfrom zerver.lib.streams import create_stream_if_needed\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    avatar_disk_path,\n    cache_tries_captured,\n    find_key_by_email,\n    get_test_image_file,\n    load_subdomain_token,\n    message_stream_count,\n    most_recent_message,\n    most_recent_usermessage,\n    queries_captured,\n    reset_emails_in_zulip_realm,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    RealmAuditLog,\n    RealmUserDefault,\n    Recipient,\n    ScheduledEmail,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    flush_per_request_caches,\n    get_realm,\n    get_stream,\n    get_system_bot,\n    get_user,\n    get_user_by_delivery_email,\n)\nfrom zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\nfrom zerver.views.development.registration import confirmation_key\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zerver.views.registration import accounts_home\nfrom zproject.backends import ExternalAuthDataDict, ExternalAuthResult\n\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_data(self) -> None:\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        name = user_profile.full_name\n        email = user_profile.delivery_email\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(user_profile=user_profile))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\"full_name\": name, \"email\": email, \"subdomain\": realm.subdomain, \"is_signup\": False},\n        )\n\n        data_dict = ExternalAuthDataDict(is_signup=True, multiuse_object_key=\"key\")\n        response = redirect_and_log_into_subdomain(\n            ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n        )\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": name,\n                \"email\": email,\n                \"subdomain\": realm.subdomain,\n                # the email has an account at the subdomain,\n                # so is_signup get overridden to False:\n                \"is_signup\": False,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n        data_dict = ExternalAuthDataDict(\n            email=self.nonreg_email(\"alice\"),\n            full_name=\"Alice\",\n            subdomain=realm.subdomain,\n            is_signup=True,\n            full_name_validated=True,\n            multiuse_object_key=\"key\",\n        )\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(data_dict=data_dict))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": \"Alice\",\n                \"email\": self.nonreg_email(\"alice\"),\n                \"full_name_validated\": True,\n                \"subdomain\": realm.subdomain,\n                \"is_signup\": True,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"deactivated\", result.url)\n\n    def test_redirection_for_active_realm(self) -> None:\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self) -> None:\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result.url)\n\n    def test_deactivation_notice_when_deactivated(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n        self.assertNotIn(\"It has moved to\", result.content.decode())\n\n    def test_deactivation_notice_when_deactivated_and_deactivated_redirect_is_set(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.deactivated_redirect = \"http://example.zulipchat.com\"\n        realm.save(update_fields=[\"deactivated\", \"deactivated_redirect\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://example.zulipchat.com\">http://example.zulipchat.com</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivation_notice_when_realm_subdomain_is_changed(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-subdomain-name\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-subdomain-name.testserver\">http://new-subdomain-name.testserver</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivated_redirect_field_of_placeholder_realms_are_modified_on_changing_subdomain_multiple_times(\n        self,\n    ) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name-1\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-1.testserver\">http://new-name-1.testserver</a>.',\n            result.content.decode(),\n        )\n\n        realm = get_realm(\"new-name-1\")\n        do_change_realm_subdomain(realm, \"new-name-2\", acting_user=None)\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-2.testserver\">http://new-name-2.testserver</a>.',\n            result.content.decode(),\n        )\n\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self) -> None:\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        realm = get_realm(\"zulip\")\n        stream = Stream.objects.get(realm=realm, name=\"Denmark\")\n        DefaultStream.objects.create(stream=stream, realm=realm)\n        # Make sure at least 3 messages are sent to Denmark and it's a default stream.\n        message_id = self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 1\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 2\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 3\")\n\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        )\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n\n        # Sent a message afterwards to trigger a race between message\n        # sending and `add_new_user_history`.\n        race_message_id = self.send_stream_message(\n            self.example_user(\"hamlet\"), streams[0].name, \"test\"\n        )\n\n        # Overwrite ONBOARDING_UNREAD_MESSAGES to 2\n        ONBOARDING_UNREAD_MESSAGES = 2\n        with patch(\"zerver.lib.actions.ONBOARDING_UNREAD_MESSAGES\", ONBOARDING_UNREAD_MESSAGES):\n            add_new_user_history(user_profile, streams)\n\n        # Our first message is in the user's history\n        self.assertTrue(\n            UserMessage.objects.filter(user_profile=user_profile, message_id=message_id).exists()\n        )\n        # The race message is in the user's history and marked unread.\n        self.assertTrue(\n            UserMessage.objects.filter(\n                user_profile=user_profile, message_id=race_message_id\n            ).exists()\n        )\n        self.assertFalse(\n            UserMessage.objects.get(\n                user_profile=user_profile, message_id=race_message_id\n            ).flags.read.is_set\n        )\n\n        # Verify that the ONBOARDING_UNREAD_MESSAGES latest messages\n        # that weren't the race message are marked as unread.\n        latest_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[0:ONBOARDING_UNREAD_MESSAGES]\n        )\n        self.assert_length(latest_messages, 2)\n        for msg in latest_messages:\n            self.assertFalse(msg.flags.read.is_set)\n\n        # Verify that older messages are correctly marked as read.\n        older_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[ONBOARDING_UNREAD_MESSAGES : ONBOARDING_UNREAD_MESSAGES + 1]\n        )\n        self.assertGreater(len(older_messages), 0)\n        for msg in older_messages:\n            self.assertTrue(msg.flags.read.is_set)\n\n    def test_auto_subbed_to_personals(self) -> None:\n        \"\"\"\n        Newly created users are auto-subbed to the ability to receive\n        personals.\n        \"\"\"\n        test_email = self.nonreg_email(\"test\")\n        self.register(test_email, \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        old_messages_count = message_stream_count(user_profile)\n        self.send_personal_message(user_profile, user_profile)\n        new_messages_count = message_stream_count(user_profile)\n        self.assertEqual(new_messages_count, old_messages_count + 1)\n\n        recipient = Recipient.objects.get(type_id=user_profile.id, type=Recipient.PERSONAL)\n        message = most_recent_message(user_profile)\n        self.assertEqual(message.recipient, recipient)\n\n        with patch(\"zerver.models.get_display_recipient\", return_value=\"recip\"):\n            self.assertEqual(\n                str(message),\n                \"<Message: recip /  / \"\n                \"<UserProfile: {} {}>>\".format(user_profile.email, user_profile.realm),\n            )\n\n            user_message = most_recent_usermessage(user_profile)\n            self.assertEqual(\n                str(user_message),\n                f\"<UserMessage: recip / {user_profile.email} ([])>\",\n            )\n\n\nclass InitialPasswordTest(ZulipTestCase):\n    def test_none_initial_password_salt(self) -> None:\n        with self.settings(INITIAL_PASSWORD_SALT=None):\n            self.assertIsNone(initial_password(\"test@test.com\"))\n\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def get_reset_mail_body(self, subdomain: str = \"zulip\") -> str:\n        from django.core.mail import outbox\n\n        [message] = outbox\n        self.assertEqual(self.email_envelope_from(message), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(message),\n            rf\"^Zulip Account Security <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\",\n        )\n        self.assertIn(f\"{subdomain}.testserver\", message.extra_headers[\"List-Id\"])\n\n        return message.body\n\n    def test_password_reset(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.delivery_email\n        old_password = initial_password(email)\n        assert old_password is not None\n\n        self.login_user(user)\n\n        # test password reset template\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assert_in_response(\"Reset your password\", result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(\n            email, url_pattern=settings.EXTERNAL_HOST + r\"(\\S\\S+)\"\n        )\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.endswith(f\"/{PasswordResetConfirmView.reset_url_token}/\"))\n\n        final_reset_url = result.url\n        result = self.client_get(final_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            # Verify weak passwords don't work.\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"easy\", \"new_password2\": \"easy\"}\n            )\n            self.assert_in_response(\"The password is too weak.\", result)\n\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"f657gdGGk9\", \"new_password2\": \"f657gdGGk9\"}\n            )\n            # password reset succeeded\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n            # log back in with new password\n            self.login_by_email(email, password=\"f657gdGGk9\")\n            user_profile = self.example_user(\"hamlet\")\n            self.assert_logged_in_user_id(user_profile.id)\n\n            # make sure old password no longer works\n            self.assert_login_failure(email, password=old_password)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_alias_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True, ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_domain_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_alias_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_domain_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(EXTERNAL_HOST=\"www.testserver.com\", ROOT_SUBDOMAIN_ALIASES=[]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_always_for_subdomains(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"lear.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    def test_password_reset_for_non_existent_user(self) -> None:\n        email = \"nonexisting@mars.com\"\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_password_reset_for_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_user(user_profile, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"has been deactivated\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"not have an account\", body)\n\n    def test_password_reset_with_deactivated_realm(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(m.output, [\"INFO:root:Realm is deactivated\"])\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(RATE_LIMITING=True)\n    def test_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        from django.core.mail import outbox\n\n        add_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 2)\n\n            # Too many password reset emails sent to the address, we won't send more.\n            with self.assertLogs(level=\"INFO\") as info_logs:\n                self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                info_logs.output,\n                [\n                    \"INFO:root:Too many password reset attempts for email hamlet@zulip.com from 127.0.0.1\"\n                ],\n            )\n            self.assert_length(outbox, 2)\n\n            # Resetting for a different address works though.\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 3)\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 4)\n\n        # After time, password reset emails can be sent again.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 6)\n\n        remove_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n\n    def test_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        body = self.get_reset_mail_body(\"zephyr\")\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\n            \"active accounts in the following organization(s).\\nhttp://zulip.testserver\", body\n        )\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_invalid_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\n            \"/accounts/password/reset/\", {\"email\": email}, subdomain=\"invalid\"\n        )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auth_only(self) -> None:\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                m.output,\n                [\n                    \"INFO:root:Password reset attempted for hamlet@zulip.com even though password auth is disabled.\"\n                ],\n            )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_and_email_auth(self) -> None:\n        \"\"\"If both email and LDAP auth backends are enabled, limit password\n        reset to users outside the LDAP domain\"\"\"\n        # If the domain matches, we don't generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            email = self.example_email(\"hamlet\")\n            with self.assertLogs(level=\"INFO\") as m:\n                result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n                self.assertEqual(\n                    m.output, [\"INFO:root:Password reset not allowed for user in LDAP domain\"]\n                )\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # If the domain doesn't match, we do generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"example.com\"):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n            result = self.client_get(result[\"Location\"])\n\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n    def test_redirect_endpoints(self) -> None:\n        \"\"\"\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        \"\"\"\n        result = self.client_get(\"/accounts/password/reset/done/\")\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get(\"/accounts/password/done/\")\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get(\"/accounts/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/accounts/home/\"], result)\n\n        result = self.client_get(\"/accounts/new/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/new/\"], result)\n\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        result = self.login_with_return(user_profile.delivery_email, \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_bad_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        password: Optional[str] = \"wrongpassword\"\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assert_in_success_response([user.delivery_email], result)\n        self.assert_logged_in_user_id(None)\n\n        # Parallel test to confirm that the right password works using the\n        # same login code, which verifies our failing test isn't broken\n        # for some other reason.\n        password = initial_password(user.delivery_email)\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user.id)\n\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def test_login_bad_password_rate_limiter(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n\n            # We're over the allowed limit, so the next attempt, even with the correct\n            # password, will get blocked.\n            result = self.login_with_return(email)\n            self.assert_in_success_response([\"Try again in 10 seconds\"], result)\n\n        # After time passes, we should be able to log in.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.login_with_return(email)\n            self.assert_logged_in_user_id(user_profile.id)\n\n        remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_login_with_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.login_with_return(self.example_email(\"hamlet\"), password)\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\n                \"Your password has been disabled because it is too weak.\", result\n            )\n            self.assert_logged_in_user_id(None)\n\n    def test_login_nonexistent_user(self) -> None:\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_wrong_subdomain(self) -> None:\n        email = self.mit_email(\"sipbtest\")\n        with self.assertLogs(level=\"WARNING\") as m:\n            result = self.login_with_return(email, \"xxx\")\n            self.assertEqual(\n                m.output,\n                [\n                    \"WARNING:root:User sipbtest@mit.edu attempted password login to wrong subdomain zulip\"\n                ],\n            )\n        self.assertEqual(result.status_code, 200)\n        expected_error = (\n            f\"Your Zulip account {email} is not a member of the \"\n            + \"organization associated with this subdomain.\"\n        )\n        self.assert_in_response(expected_error, result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_invalid_subdomain(self) -> None:\n        result = self.login_with_return(self.example_email(\"hamlet\"), \"xxx\", subdomain=\"invalid\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_register(self) -> None:\n        reset_emails_in_zulip_realm()\n\n        realm = get_realm(\"zulip\")\n        hamlet = self.example_user(\"hamlet\")\n        stream_names = [f\"stream_{i}\" for i in range(40)]\n        for stream_name in stream_names:\n            stream = self.make_stream(stream_name, realm=realm)\n            DefaultStream.objects.create(stream=stream, realm=realm)\n\n        # Make sure there's at least one recent message to be mark\n        # unread.  This prevents a bug where this test would start\n        # failing the test database was generated more than\n        # ONBOARDING_RECENT_TIMEDELTA ago.\n        self.subscribe(hamlet, \"stream_0\")\n        self.send_stream_message(\n            hamlet,\n            \"stream_0\",\n            topic_name=\"test topic\",\n            content=\"test message\",\n        )\n\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n\n        with queries_captured() as queries, cache_tries_captured() as cache_tries:\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 90)\n\n        # We can probably avoid a couple cache hits here, but there doesn't\n        # seem to be any O(N) behavior.  Some of the cache hits are related\n        # to sending messages, such as getting the welcome bot, looking up\n        # the alert words for a realm, etc.\n        self.assert_length(cache_tries, 21)\n\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post(\n            \"/accounts/home/\", {\"email\": self.nonreg_email(\"test\")}, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_register_with_invalid_email(self) -> None:\n        \"\"\"\n        If you try to register with invalid email, you get an invalid email\n        page\n        \"\"\"\n        invalid_email = \"foo\\x00bar\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": invalid_email}, subdomain=\"zulip\")\n\n        self.assertEqual(result.status_code, 200)\n        self.assertContains(result, \"Enter a valid email address\")\n\n    def test_register_deactivated_partway_through(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertNotIn(\"deactivated\", result.url)\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_login_deactivated_realm(self) -> None:\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n    def test_logout(self) -> None:\n        self.login(\"hamlet\")\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post(\"/accounts/logout/\")\n        self.assert_logged_in_user_id(None)\n\n    def test_non_ascii_login(self) -> None:\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        password = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.logout()\n        self.assert_logged_in_user_id(None)\n\n        # Logging in succeeds.\n        self.logout()\n        self.login_by_email(email, password)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=False)\n    def test_login_page_redirects_logged_in_user(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(\"cordelia\")\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_options_request_to_login_page(self) -> None:\n        response = self.client_options(\"/login/\")\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True)\n    def test_login_page_redirects_logged_in_user_under_2fa(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        self.create_default_device(user_profile)\n\n        self.login(\"cordelia\")\n        self.login_2fa(user_profile)\n\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_start_two_factor_auth(self) -> None:\n        request = MagicMock(POST={})\n        with patch(\"zerver.views.auth.TwoFactorLoginView\") as mock_view:\n            mock_view.as_view.return_value = lambda *a, **k: HttpResponse()\n            response = start_two_factor_auth(request)\n            self.assertTrue(isinstance(response, HttpResponse))\n\n    def test_do_two_factor_login(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        request = MagicMock()\n        with patch(\"zerver.decorator.django_otp.login\") as mock_login:\n            do_two_factor_login(request, user_profile)\n            mock_login.assert_called_once()\n\n    def test_zulip_default_context_does_not_load_inline_previews(self) -> None:\n        realm = get_realm(\"zulip\")\n        description = \"https://www.google.com/images/srpr/logo4w.png\"\n        realm.description = description\n        realm.save(update_fields=[\"description\"])\n        response = self.client_get(\"/login/\")\n        expected_response = \"\"\"<p><a href=\"https://www.google.com/images/srpr/logo4w.png\">\\\nhttps://www.google.com/images/srpr/logo4w.png</a></p>\"\"\"\n        self.assertEqual(response.context_data[\"realm_description\"], expected_response)\n        self.assertEqual(response.status_code, 200)\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str]) -> None:\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(outbox[0]), rf\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_days: Optional[int] = settings.INVITATION_LINK_VALIDITY_DAYS,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ) -> HttpResponse:\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = []\n        for stream_name in stream_names:\n            stream_ids.append(self.get_stream_id(stream_name))\n\n        invite_expires_in: Union[str, Optional[int]] = invite_expires_in_days\n        if invite_expires_in is None:\n            invite_expires_in = orjson.dumps(None).decode()\n\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_days\": invite_expires_in,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - datetime.timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        stream_name = \"Denmark\"\n\n        # These constants only need to be in descending order\n        # for this test to trigger an InvitationError based\n        # on max daily counts.\n        site_max = 50\n        realm_max = 40\n        num_invitees = 30\n        max_daily_count = 20\n\n        daily_counts = [(1, max_daily_count)]\n\n        invite_emails = [f\"foo-{i:02}@zulip.com\" for i in range(num_invitees)]\n        invitees = \",\".join(invite_emails)\n\n        self.login_user(user_profile)\n\n        realm.max_invites = realm_max\n        realm.date_created = timezone_now()\n        realm.save()\n\n        def try_invite() -> HttpResponse:\n            with self.settings(\n                OPEN_REALM_CREATION=True,\n                INVITES_DEFAULT_REALM_DAILY_MAX=site_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=daily_counts,\n            ):\n                result = self.invite(invitees, [stream_name])\n                return result\n\n        result = try_invite()\n        self.assert_json_error_contains(result, \"reached the limit\")\n\n        # Next show that aggregate limits expire once the realm is old\n        # enough.\n\n        realm.date_created = timezone_now() - datetime.timedelta(days=8)\n        realm.save()\n\n        with queries_captured() as queries:\n            with cache_tries_captured() as cache_tries:\n                result = try_invite()\n\n        self.assert_json_success(result)\n\n        # TODO: Fix large query count here.\n        #\n        # TODO: There is some test OTHER than this one\n        #       that is leaking some kind of state change\n        #       that throws off the query count here.  It\n        #       is hard to investigate currently (due to\n        #       the large number of queries), so I just\n        #       use an approximate equality check.\n        actual_count = len(queries)\n        expected_count = 251\n        if abs(actual_count - expected_count) > 1:\n            raise AssertionError(\n                f\"\"\"\n                Unexpected number of queries:\n\n                expected query count: {expected_count}\n                actual: {actual_count}\n                \"\"\"\n            )\n\n        # Almost all of these cache hits are to re-fetch each one of the\n        # invitees.  These happen inside our queue processor for sending\n        # confirmation emails, so they are somewhat difficult to avoid.\n        #\n        # TODO: Mock the call to queue_json_publish, so we can measure the\n        # queue impact separately from the user-perceived impact.\n        self.assert_length(cache_tries, 32)\n\n        # Next get line coverage on bumping a realm's max_invites.\n        realm.date_created = timezone_now()\n        realm.max_invites = site_max + 10\n        realm.save()\n\n        result = try_invite()\n        self.assert_json_success(result)\n\n        # Finally get coverage on the case that OPEN_REALM_CREATION is False.\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            result = self.invite(invitees, [stream_name])\n\n        self.assert_json_success(result)\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = \",\".join([cross_realm_bot_email, legit_new_email])\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            \"Some of those addresses are already using Zulip,\"\n            + \" so we didn't send them an invitation.\"\n            + \" We did send invitations to everyone else!\",\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_invite_from_now_deactivated_user(self) -> None:\n        \"\"\"\n        While accepting an invitation from a user,\n        processing for a new user account will only\n        be completed if the inviter is not deactivated\n        after sending the invite.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n        invitee = self.nonreg_email(\"alice\")\n\n        result = self.invite(invitee, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        change_user_is_active(inviter, False)\n        do_create_user(\n            invitee,\n            \"password\",\n            inviter.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Must be invited as an valid type of user\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_invite_others_to_realm()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        from django.core import mail\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - datetime.timedelta(\n            days=(realm.waiting_period_threshold - 1)\n        )\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"alice_zulip.com <`{invitee_profile.email}`> accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_invite_too_many_users(self) -> None:\n        # Only a light test of this pathway; e.g. doesn't test that\n        # the limit gets reset after 24 hours\n        self.login(\"iago\")\n        invitee_emails = \"1@zulip.com, 2@zulip.com\"\n        self.invite(invitee_emails, [\"Denmark\"])\n        invitee_emails = \", \".join(str(i) for i in range(get_realm(\"zulip\").max_invites - 1))\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"To protect users, Zulip limits the number of invitations you can send in one day. Because you have reached the limit, no invitations were sent.\",\n        )\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n        invitee_emails = \"foo@zulip.com\"\n        self.assert_json_error(\n            self.invite(invitee_emails, []),\n            \"You must specify at least one stream for invitees to join.\",\n        )\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        from django.core.mail import outbox\n\n        body = self.normalize_string(outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color:#5f5ec7; text-decoration:underline\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                lambda: PreregistrationUser.objects.get(email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = PreregistrationUser.objects.get(email=\"foo-test@zulip.com\")\n        self.assertEqual(prereg_user.email, \"foo-test@zulip.com\")\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with email addresses\", result)\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please sign up using a real email address.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"Zulip Dev, does not allow signups using emails\\n        that contains +\", result\n        )\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self) -> None:\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_days = 2\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_days=validity_in_days\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_days=4)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_days=3)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyException) as cm:\n            get_object_from_key(registration_key, [Confirmation.INVITATION])\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyException.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - datetime.timedelta(weeks=3)\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_never_expire_confirmation_obejct(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        activation_url = create_confirmation_link(\n            prereg_user, Confirmation.INVITATION, validity_in_days=None\n        )\n        confirmation = Confirmation.objects.last()\n        assert confirmation is not None\n        self.assertEqual(confirmation.expiry_date, None)\n        activation_key = activation_url.split(\"/\")[-1]\n        response = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": activation_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"},\n        )\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, self.user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_days=invite_expires_in_days\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_ACTIVE\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the link_expired page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], response)\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.url,\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response.url, \"http://zulip.testserver/\")\n\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"New members cannot join this organization because all Zulip licenses are\"], response\n        )\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_invites_controlled_by_user(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            hamlet, [\"TestThree@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            othello, [\"TestFour@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n        self.assert_length(do_get_invites_controlled_by_user(user_profile), 5)\n        self.assert_length(do_get_invites_controlled_by_user(hamlet), 1)\n        self.assert_length(do_get_invites_controlled_by_user(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_ACTIVE\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=invite_expires_in_days + 1),\n        ):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_days=invite_expires_in_days,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three, Confirmation.INVITATION, validity_in_days=invite_expires_in_days\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_get_never_expiring_invitations(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=1000),\n        ):\n            # Testing the invitation with expiry date set to \"None\" exists\n            # after a large amount of days.\n            do_invite_users(\n                user_profile,\n                [\"TestOne@zulip.com\"],\n                streams,\n                invite_expires_in_days=None,\n            )\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_days=100,\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], None\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], 100\n            )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        # We only get invitations that will never expire because we have mocked time such\n        # that the other invitations are created in the deep past.\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertEqual(invites[0][\"expiry_date\"], None)\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], user_profile.id)\n        self.assertEqual(invites[1][\"expiry_date\"], None)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        # Test deleting owner mutiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite_in_mit, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_resend_never_expiring_invitation(self) -> None:\n        self.login(\"iago\")\n        invitee = \"resend@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], None))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_ACTIVE)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime.datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_days = 2\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        validity_in_days = 2\n        date_sent = timezone_now() - datetime.timedelta(days=validity_in_days - 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - datetime.timedelta(\n            days=settings.INVITATION_LINK_VALIDITY_DAYS + 1\n        )\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n    def test_multiuse_link_different_realms(self) -> None:\n        \"\"\"\n        Verify that an invitation generated for one realm can't be used\n        to join another.\n        \"\"\"\n        lear_realm = get_realm(\"lear\")\n        self.realm = lear_realm\n        invite_link = self.generate_multiuse_invite_link(streams=[])\n        key = invite_link.split(\"/\")[-2]\n\n        result = self.client_get(f\"/join/{key}/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n        # Now we want to test the accounts_home function, which can't be used\n        # for the multiuse invite case via an HTTP request, but is still supposed\n        # to do its own verification that the realms match as a hardening measure\n        # against a caller that fails to do that.\n        request = HttpRequest()\n        confirmation = Confirmation.objects.get(confirmation_key=key)\n        multiuse_object = confirmation.content_object\n        with patch(\n            \"zerver.views.registration.get_subdomain\", return_value=\"zulip\"\n        ), self.assertRaises(AssertionError):\n            accounts_home(request, multiuse_object=multiuse_object)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps(stream_ids).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n    def test_only_admin_can_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n        # Only admins should be able to create multiuse invites even if\n        # invite_to_realm_policy is set to Realm.POLICY_MEMBERS_ONLY.\n        self.realm.invite_to_realm_policy = Realm.POLICY_MEMBERS_ONLY\n        self.realm.save()\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps([54321]).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_error(result, \"Invalid stream id 54321. No invites were sent.\")\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self) -> None:\n\n        # An invalid unsubscribe token \"test123\" produces an error.\n        result = self.client_get(\"/accounts/unsubscribe/missed_messages/test123\")\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user(\"hamlet\")\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n    def test_message_notification_emails_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in message notification emails\n        that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_digest_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {\n            \"name\": \"\",\n            \"realm_uri\": \"\",\n            \"unread_pms\": [],\n            \"hot_conversations\": [],\n            \"new_users\": [],\n            \"new_streams\": {\"plain\": []},\n            \"unsubscribe_link\": \"\",\n        }\n        send_future_email(\n            \"zerver/emails/digest\",\n            user_profile.realm,\n            to_user_ids=[user_profile.id],\n            context=context,\n        )\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_login_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in login\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_login_emails = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"login\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_login_emails)\n\n    def test_marketing_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in marketing e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n    def test_marketing_unsubscribe_post(self) -> None:\n        \"\"\"\n        The List-Unsubscribe-Post header lets email clients trigger an\n        automatic unsubscription request via POST (see RFC 8058), so\n        test that too.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        client = Client(enforce_csrf_checks=True)\n        result = client.post(\n            urllib.parse.urlparse(unsubscribe_link).path, {\"List-Unsubscribe\": \"One-Click\"}\n        )\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n\nclass RealmCreationTest(ZulipTestCase):\n    @override_settings(OPEN_REALM_CREATION=True)\n    def check_able_to_create_realm(self, email: str, password: str = \"test\") -> None:\n        internal_realm = get_realm(settings.SYSTEM_BOT_REALM)\n        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, internal_realm.id)\n        signups_stream, _ = create_stream_if_needed(notification_bot.realm, \"signups\")\n\n        string_id = \"zuliptest\"\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Check confirmation email has the correct subject and body, extract\n        # confirmation link and visit it\n        confirmation_url = self.get_confirmation_url_from_outbox(\n            email,\n            email_subject_contains=\"Create your Zulip organization\",\n            email_body_contains=\"You have requested a new Zulip organization\",\n        )\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://zuliptest.testserver/accounts/login/subdomain/\")\n        )\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n\n        # Check that user is the owner.\n        self.assertEqual(user.role, UserProfile.ROLE_REALM_OWNER)\n\n        # Check defaults\n        self.assertEqual(realm.org_type, Realm.ORG_TYPES[\"business\"][\"id\"])\n        self.assertEqual(realm.emails_restricted_to_domains, False)\n        self.assertEqual(realm.invite_required, True)\n\n        # Check welcome messages\n        for stream_name, text, message_count in [\n            (Realm.DEFAULT_NOTIFICATION_STREAM_NAME, \"with the topic\", 3),\n            (Realm.INITIAL_PRIVATE_STREAM_NAME, \"private stream\", 1),\n        ]:\n            stream = get_stream(stream_name, realm)\n            recipient = stream.recipient\n            messages = Message.objects.filter(recipient=recipient).order_by(\"date_sent\")\n            self.assert_length(messages, message_count)\n            self.assertIn(text, messages[0].content)\n\n        # Check signup messages\n        recipient = signups_stream.recipient\n        messages = Message.objects.filter(recipient=recipient).order_by(\"id\")\n        self.assert_length(messages, 2)\n        self.assertIn(\"Signups enabled\", messages[0].content)\n        self.assertIn(\"signed up\", messages[1].content)\n        self.assertEqual(\"zuliptest\", messages[1].topic_name())\n\n        realm_creation_audit_log = RealmAuditLog.objects.get(\n            realm=realm, event_type=RealmAuditLog.REALM_CREATED\n        )\n        self.assertEqual(realm_creation_audit_log.acting_user, user)\n        self.assertEqual(realm_creation_audit_log.event_time, realm.date_created)\n\n        # Piggyback a little check for how we handle\n        # empty string_ids.\n        realm.string_id = \"\"\n        self.assertEqual(realm.display_subdomain, \".\")\n\n    def test_create_realm_non_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"user1@test.com\")\n\n    def test_create_realm_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"hamlet@zulip.com\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_create_realm_ldap_email(self) -> None:\n        self.init_default_ldap_database()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.check_able_to_create_realm(\n                \"newuser_email@zulip.com\", self.ldap_password(\"newuser_with_email\")\n            )\n\n    def test_create_realm_as_system_bot(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"notification-bot@zulip.com\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"notification-bot@zulip.com is reserved for system bots\", result)\n\n    def test_create_realm_no_creation_key(self) -> None:\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post(\"/new/\", {\"email\": email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"New organization creation disabled\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_enabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertTrue(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True, CORPORATE_ENABLED=False)\n    def test_create_realm_without_prompting_for_marketing_emails(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Simulate the initial POST that is made by confirm-preregistration.js\n        # by triggering submit on confirm_preregistration.html.\n        payload = {\n            \"full_name\": \"\",\n            \"key\": find_key_by_email(email),\n            \"from_confirmation\": \"1\",\n        }\n        result = self.client_post(\"/accounts/register/\", payload)\n        # Assert that the form did not prompt the user for enabling\n        # marketing emails.\n        self.assert_not_in_success_response(['input id=\"id_enable_marketing_emails\"'], result)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_disabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_regular_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_demo_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n            is_demo_organization=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True, FREE_TRIAL_DAYS=30)\n    def test_create_realm_during_free_trial(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.url, \"http://zuliptest.testserver/upgrade/?onboarding=true\")\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assert_in_success_response([\"Not ready to start your trial?\"], result)\n\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_two_realms(self) -> None:\n        \"\"\"\n        Verify correct behavior and PreregistrationUser handling when using\n        two pre-generated realm creation links to create two different realms.\n        \"\"\"\n        password = \"test\"\n        first_string_id = \"zuliptest\"\n        second_string_id = \"zuliptest2\"\n        email = \"user1@test.com\"\n        first_realm_name = \"Test\"\n        second_realm_name = \"Test\"\n\n        # Make sure the realms do not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(first_string_id)\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(second_string_id)\n\n        # Now we pre-generate two realm creation links\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Get a second realm creation link.\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 2)\n\n        # Create and verify the first realm\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=first_string_id,\n            realm_name=first_realm_name,\n            key=first_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(first_string_id)\n        self.assertEqual(realm.string_id, first_string_id)\n        self.assertEqual(realm.name, first_realm_name)\n\n        # One of the PreregistrationUsers should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Create and verify the second realm\n        result = self.client_get(second_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=second_string_id,\n            realm_name=second_realm_name,\n            key=second_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(second_string_id)\n        self.assertEqual(realm.string_id, second_string_id)\n        self.assertEqual(realm.name, second_realm_name)\n\n        # The remaining PreregistrationUser should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 0)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"hi@mailinator.com\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {\n            \"id\": \"length 3 or greater\",\n            \"-id\": \"cannot start or end with a\",\n            \"string-ID\": \"lowercase letters\",\n            \"string_id\": \"lowercase letters\",\n            \"stream\": \"unavailable\",\n            \"streams\": \"unavailable\",\n            \"about\": \"unavailable\",\n            \"abouts\": \"unavailable\",\n            \"zephyr\": \"unavailable\",\n        }\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=string_id, realm_name=realm_name\n            )\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"a-0\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://a-0.testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_using_old_subdomain_of_a_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name\", acting_user=None)\n\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"zulip\", realm_name=realm_name\n        )\n        self.assert_in_response(\"Subdomain unavailable. Please choose a different one.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=\"\", realm_name=realm_name\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_subdomain=\"abcdef\",\n                realm_in_root_domain=\"true\",\n                realm_name=realm_name,\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=\"abcdef\",\n            realm_in_root_domain=\"true\",\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    def test_is_root_domain_available(self) -> None:\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\n    def test_subdomain_check_api(self) -> None:\n        result = self.client_get(\"/json/realm/subdomain/zulip\")\n        self.assert_in_success_response(\n            [\"Subdomain unavailable. Please choose a different one.\"], result\n        )\n\n        result = self.client_get(\"/json/realm/subdomain/zu_lip\")\n        self.assert_in_success_response(\n            [\"Subdomain can only have lowercase letters, numbers, and '-'s.\"], result\n        )\n\n        with self.settings(SOCIAL_AUTH_SUBDOMAIN=\"zulipauth\"):\n            result = self.client_get(\"/json/realm/subdomain/zulipauth\")\n            self.assert_in_success_response(\n                [\"Subdomain unavailable. Please choose a different one.\"], result\n            )\n\n        result = self.client_get(\"/json/realm/subdomain/hufflepuff\")\n        self.assert_in_success_response([\"available\"], result)\n        self.assert_not_in_success_response([\"unavailable\"], result)\n\n    def test_subdomain_check_management_command(self) -> None:\n        # Short names should not work, even with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\", allow_reserved_subdomain=True)\n\n        # Malformed names should never work\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\", allow_reserved_subdomain=True)\n\n        with patch(\"zerver.lib.name_restrictions.is_reserved_subdomain\", return_value=False):\n            # Existing realms should never work even if they are not reserved keywords\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\")\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\", allow_reserved_subdomain=True)\n\n        # Reserved ones should only work with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"stream\")\n        check_subdomain_available(\"stream\", allow_reserved_subdomain=True)\n\n\nclass UserSignUpTest(InviteUserBase):\n    def _assert_redirected_to(self, result: HttpResponse, url: str) -> None:\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"LOCATION\"], url)\n\n    def verify_signup(\n        self,\n        *,\n        email: str = \"newguy@zulip.com\",\n        password: Optional[str] = \"newpassword\",\n        full_name: str = \"New user's name\",\n        realm: Optional[Realm] = None,\n        subdomain: Optional[str] = None,\n    ) -> Union[UserProfile, HttpResponse]:\n        \"\"\"Common test function for signup tests.  It is a goal to use this\n        common function for all signup tests to avoid code duplication; doing\n        so will likely require adding new parameters.\"\"\"\n\n        if realm is None:  # nocoverage\n            realm = get_realm(\"zulip\")\n\n        client_kwargs: Dict[str, Any] = {}\n        if subdomain:\n            client_kwargs[\"subdomain\"] = subdomain\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, **client_kwargs)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], **client_kwargs)\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, **client_kwargs)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS. This should create our\n        # account, log us in, and redirect to the app.\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=full_name, **client_kwargs\n        )\n\n        if result.status_code == 200:\n            # This usually indicated an error returned when submitting the form.\n            # Return the result for the caller to deal with reacting to this, since\n            # in many tests this is expected and the caller wants to assert the content\n            # of the error.\n            return result\n\n        # Verify that we were served a redirect to the app.\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"{realm.uri}/\")\n\n        # Verify that we successfully logged in.\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        return user_profile\n\n    def test_bad_email_configuration_for_accounts_home(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/accounts/home/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in accounts_home\"])\n\n    def test_bad_email_configuration_for_create_realm(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/new/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in create_realm\"])\n\n    def test_user_default_language_and_timezone(self) -> None:\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        timezone = \"America/Denver\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_twenty_four_hour_time(self) -> None:\n        \"\"\"\n        Check if the default twenty_four_hour_time setting of new user\n        is the default twenty_four_hour_time of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        do_set_realm_user_default_setting(\n            realm_user_default, \"twenty_four_hour_time\", True, acting_user=None\n        )\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        self.assertEqual(\n            user_profile.twenty_four_hour_time, realm_user_default.twenty_four_hour_time\n        )\n\n    def test_signup_already_active(self) -> None:\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_system_bot(self) -> None:\n        email = \"notification-bot@zulip.com\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"lear\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n\n        # This is not really the right error message, but at least it's an error.\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_existing_email(self) -> None:\n        \"\"\"\n        Check if signing up with an email used in another realm succeeds.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        self.verify_signup(email=email, realm=get_realm(\"lear\"), subdomain=\"lear\")\n        self.assertEqual(UserProfile.objects.filter(delivery_email=email).count(), 2)\n\n    def test_signup_invalid_name(self) -> None:\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n\n        result = self.verify_signup(full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_without_password(self) -> None:\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n        email = self.nonreg_email(\"newuser\")\n        with patch(\"zerver.views.registration.password_auth_enabled\", return_value=False):\n            user_profile = self.verify_signup(email=email, password=None)\n\n        assert isinstance(user_profile, UserProfile)\n        # User should now be logged in.\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_signup_without_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n        result = self.verify_signup(email=email, password=password, full_name=\"\")\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_email_message_contains_org_header(self) -> None:\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        from django.core.mail import outbox\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def test_signup_with_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n    def test_signup_with_weak_password(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\n                    \"password\": \"easy\",\n                    \"key\": find_key_by_email(email),\n                    \"terms\": True,\n                    \"full_name\": \"New Guy\",\n                    \"from_confirmation\": \"1\",\n                },\n            )\n            self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n            result = self.submit_reg_form_for_user(email, \"easy\", full_name=\"New Guy\")\n            self.assert_in_success_response([\"The password is too weak.\"], result)\n            with self.assertRaises(UserProfile.DoesNotExist):\n                # Account wasn't created.\n                get_user(email, get_realm(\"zulip\"))\n\n    def test_signup_with_default_stream_group(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream group as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        default_streams = []\n\n        existing_default_streams = DefaultStream.objects.filter(realm=realm)\n        self.assert_length(existing_default_streams, 1)\n        self.assertEqual(existing_default_streams[0].stream.name, \"Verona\")\n        default_streams.append(existing_default_streams[0].stream)\n\n        for stream_name in [\"venice\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        result = self.submit_reg_form_for_user(email, password, default_stream_groups=[\"group 1\"])\n        self.check_user_subscribed_only_to_streams(\"newguy\", default_streams + group1_streams)\n\n    def test_signup_two_confirmation_links(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        first_confirmation_key = find_key_by_email(email)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        # Sanity check:\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n\n        # Register the account (this will use the second confirmation url):\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=\"New Guy\", from_confirmation=\"1\"\n        )\n        self.assert_in_success_response(\n            [\"We just need you to do one last thing.\", \"New Guy\", email], result\n        )\n        result = self.submit_reg_form_for_user(email, password, full_name=\"New Guy\")\n        user_profile = UserProfile.objects.get(delivery_email=email)\n        self.assertEqual(user_profile.delivery_email, email)\n\n        # Now try to to register using the first confirmation url:\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 404)\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": first_confirmation_key,\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        # Error page should be displayed\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_signup_with_multiple_default_stream_groups(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream groups as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        DefaultStream.objects.filter(realm=realm).delete()\n        default_streams = []\n        for stream_name in [\"venice\", \"verona\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        group2_streams = []\n        for stream_name in [\"scotland\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            group2_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 2\", \"group 2 description\", group2_streams)\n\n        result = self.submit_reg_form_for_user(\n            email, password, default_stream_groups=[\"group 1\", \"group 2\"]\n        )\n        self.check_user_subscribed_only_to_streams(\n            \"newguy\", list(set(default_streams + group1_streams + group2_streams))\n        )\n\n    def test_signup_without_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        realm = get_realm(\"lear\")\n\n        # Make an account in the Zulip realm, but we're not copying from there.\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email, password, source_realm_id=\"\", HTTP_HOST=subdomain + \".testserver\"\n        )\n\n        hamlet = get_user(self.example_email(\"hamlet\"), realm)\n        self.assertEqual(hamlet.left_side_userlist, False)\n        self.assertEqual(hamlet.default_language, \"en\")\n        self.assertEqual(hamlet.emojiset, \"google\")\n        self.assertEqual(hamlet.high_contrast_mode, False)\n        self.assertEqual(hamlet.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet.enter_sends, False)\n        self.assertEqual(hamlet.tutorial_status, UserProfile.TUTORIAL_WAITING)\n\n    def test_signup_with_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        lear_realm = get_realm(\"lear\")\n\n        self.login(\"hamlet\")\n        with get_test_image_file(\"img.png\") as image_file:\n            self.client_post(\"/json/users/me/avatar\", {\"file\": image_file})\n        hamlet_in_zulip.refresh_from_db()\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"password\": password, \"key\": find_key_by_email(email), \"from_confirmation\": \"1\"},\n            subdomain=subdomain,\n        )\n        self.assert_in_success_response(\n            [\n                \"Import settings from existing Zulip account\",\n                \"selected >\\n                            Zulip Dev\",\n                \"We just need you to do one last thing.\",\n            ],\n            result,\n        )\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            source_realm_id=str(hamlet_in_zulip.realm.id),\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n\n        hamlet_in_lear = get_user(email, lear_realm)\n        self.assertEqual(hamlet_in_lear.left_side_userlist, True)\n        self.assertEqual(hamlet_in_lear.default_language, \"de\")\n        self.assertEqual(hamlet_in_lear.emojiset, \"twitter\")\n        self.assertEqual(hamlet_in_lear.high_contrast_mode, True)\n        self.assertEqual(hamlet_in_lear.enter_sends, True)\n        self.assertEqual(hamlet_in_lear.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet_in_lear.tutorial_status, UserProfile.TUTORIAL_FINISHED)\n\n        zulip_path_id = avatar_disk_path(hamlet_in_zulip)\n        lear_path_id = avatar_disk_path(hamlet_in_lear)\n        with open(zulip_path_id, \"rb\") as f:\n            zulip_avatar_bits = f.read()\n        with open(lear_path_id, \"rb\") as f:\n            lear_avatar_bits = f.read()\n\n        self.assertGreater(len(zulip_avatar_bits), 500)\n        self.assertEqual(zulip_avatar_bits, lear_avatar_bits)\n\n    def test_signup_invalid_subdomain(self) -> None:\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs: Any) -> Any:\n            return_data = kwargs.get(\"return_data\", {})\n            return_data[\"invalid_subdomain\"] = True\n\n        with patch(\"zerver.views.registration.authenticate\", side_effect=invalid_subdomain):\n            with self.assertLogs(level=\"ERROR\") as m:\n                result = self.client_post(\n                    \"/accounts/register/\",\n                    {\n                        \"password\": password,\n                        \"full_name\": \"New User\",\n                        \"key\": find_key_by_email(email),\n                        \"terms\": True,\n                    },\n                )\n                self.assertEqual(\n                    m.output,\n                    [\"ERROR:root:Subdomain mismatch in registration zulip: newuser@zulip.com\"],\n                )\n        self.assertEqual(result.status_code, 302)\n\n    def test_signup_using_invalid_subdomain_preserves_state_of_form(self) -> None:\n        \"\"\"\n        Check that when we give invalid subdomain and submit the registration form\n        all the values in the form are preserved.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n\n        password = \"test\"\n        email = self.example_email(\"iago\")\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Subdomain is already used, by construction.\n            realm_subdomain=realm.string_id,\n            realm_name=realm_name,\n            source_realm_id=str(realm.id),\n        )\n        self.assert_in_success_response(\n            [\n                \"Subdomain unavailable. Please choose a different one.\",\n                \"Zulip Dev\\n\",\n                'value=\"test\"',\n                'name=\"realm_name\"',\n            ],\n            result,\n        )\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post(\"/accounts/home/\", {\"email\": email})\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": \"password\",\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New User\",\n                \"from_confirmation\": \"1\",\n            },\n            subdomain=\"zephyr\",\n        )\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link\", result)\n\n    def test_signup_to_realm_on_manual_license_plan(self) -> None:\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        realm.signup_notifications_stream = denmark_stream\n        realm.save(update_fields=[\"signup_notifications_stream\"])\n\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n            last_message = Message.objects.last()\n            assert last_message is not None\n            self.assertIn(\n                f\"A new member ({self.nonreg_email('test')}) was unable to join your organization because all Zulip\",\n                last_message.content,\n            )\n            self.assertEqual(last_message.recipient.type_id, denmark_stream.id)\n\n        ledger.licenses_at_next_renewal = 50\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n\n        ledger.licenses = 50\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertEqual(form.errors, {})\n\n    def test_failed_signup_due_to_restricted_domain(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"invite_required\", False, acting_user=None)\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            f\"Your email address, {email}, is not in one of the domains\", form.errors[\"email\"][0]\n        )\n\n    def test_failed_signup_due_to_disposable_email(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = False\n        realm.disallow_disposable_email_addresses = True\n        realm.save()\n\n        email = \"abc@mailnator.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\"Please use your real email address\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_email_containing_plus(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = True\n        realm.save()\n\n        email = \"iago+label@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            \"Email addresses containing + are not allowed in this organization.\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_failed_signup_due_to_invite_required(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n        email = \"user@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(f\"Please request an invite for {email} from\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self) -> None:\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=None)\n        self.assertIn(\n            f\"organization you are trying to join using {email} does not exist\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_access_signup_page_in_root_domain_without_realm(self) -> None:\n        result = self.client_get(\"/register\", subdomain=\"\", follow=True)\n        self.assert_in_success_response([\"Find your Zulip accounts\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is asked for its LDAP/Active Directory password.\n            self.assert_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            self.assert_not_in_success_response([\"id_password\"], result)\n\n            # Test the TypeError exception handler\n            with patch(\n                \"zproject.backends.ZulipLDAPAuthBackendBase.get_mapped_name\", side_effect=TypeError\n            ):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPUserPopulator\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_populate_only_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTH_LDAP_USER_DN_TEMPLATE=\"uid=%(user)s,ou=users,dc=zulip,dc=com\",\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is NOT asked for its LDAP/Active Directory password.\n            # LDAP is not configured for authentication in this test.\n            self.assert_not_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            # If we were using e.g. the SAML auth backend, there\n            # shouldn't be a password prompt, but since it uses the\n            # EmailAuthBackend, there should be password field here.\n            self.assert_in_success_response([\"id_password\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_end_to_end(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", full_name, \"newuser@zulip.com\"], result\n            )\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"wrongpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the correct password.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_split_full_name_mapping(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"first_name\": \"sn\", \"last_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser_splitname@zulip.com\"\n        password = self.ldap_password(\"newuser_splitname\")\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Test split name mapping.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, \"First Last\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auto_registration_on_login(self) -> None:\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n            \"custom_profile_field__phone_number\": \"homePhone\",\n        }\n        full_name = \"New LDAP fullname\"\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n            # Test custom profile fields are properly synced.\n            phone_number_field = CustomProfileField.objects.get(\n                realm=user_profile.realm, name=\"Phone number\"\n            )\n            phone_number_field_value = CustomProfileFieldValue.objects.get(\n                user_profile=user_profile, field=phone_number_field\n            )\n            self.assertEqual(phone_number_field_value.value, \"a-new-number\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auto_registration_on_login_invalid_email_in_directory(self) -> None:\n        password = self.ldap_password(\"newuser_with_email\")\n        username = \"newuser_with_email\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n\n        self.change_ldap_user_attr(\"newuser_with_email\", \"mail\", \"thisisnotavalidemail\")\n\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n        ), self.assertLogs(\"zulip.auth.ldap\", \"WARNING\") as mock_log:\n            original_user_count = UserProfile.objects.count()\n            self.login_with_return(username, password, HTTP_HOST=subdomain + \".testserver\")\n            # Verify that the process failed as intended - no UserProfile is created.\n            self.assertEqual(UserProfile.objects.count(), original_user_count)\n            self.assertEqual(\n                mock_log.output,\n                [\"WARNING:zulip.auth.ldap:thisisnotavalidemail is not a valid email address.\"],\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_registration_multiple_realms(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n        }\n        do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            subdomain = \"zulip\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"zulip\"))\n            self.logout()\n\n            # Test registration in another realm works.\n            subdomain = \"test\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"test\"))\n            self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_when_names_changes_are_disabled(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_append_domain(self) -> None:\n        password = \"nonldappassword\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # For the rest of the test we delete the user from ldap.\n        del self.mock_ldap.directory[\"uid=newuser,ou=users,dc=zulip,dc=com\"]\n\n        # If the user's email is not in the LDAP directory, but fits LDAP_APPEND_DOMAIN,\n        # we refuse to create the account.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because emails matching LDAP_APPEND_DOMAIN,\n            # aren't allowed to create non-LDAP accounts.\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: newuser. Input username: newuser@zulip.com\"\n                ],\n            )\n\n        # If the email is outside of LDAP_APPEND_DOMAIN, we successfully create a non-LDAP account,\n        # with the password managed in the Zulip database.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"example.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                m.output,\n                [\"WARNING:root:New account email newuser@zulip.com could not be found in LDAP\"],\n            )\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email newuser@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_email_search(self) -> None:\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        password = \"nonldappassword\"\n        email = \"newuser_email@zulip.com\"  # belongs to user uid=newuser_with_email in the test directory\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser_email%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # If the user's email is not in the LDAP directory , though, we\n        # successfully create an account with a password in the Zulip\n        # database.\n        password = \"nonldappassword\"\n        email = \"nonexistent@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assertEqual(\n                    m.output,\n                    [\n                        \"WARNING:root:New account email nonexistent@zulip.com could not be found in LDAP\"\n                    ],\n                )\n\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent@zulip.com. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    def ldap_invite_and_signup_as(\n        self, invite_as: int, streams: Sequence[str] = [\"Denmark\"]\n    ) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser@zulip.com\"\n        password = self.ldap_password(\"newuser\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                # Invite user.\n                self.login(\"iago\")\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: iago. Input username: iago@zulip.com\"\n                ],\n            )\n            response = self.invite(\n                invitee_emails=\"newuser@zulip.com\", stream_names=streams, invite_as=invite_as\n            )\n            self.assert_json_success(response)\n            self.logout()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_admin(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_guest(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_guest)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_streams(self) -> None:\n        stream_name = \"Rome\"\n        realm = get_realm(\"zulip\")\n        stream = get_stream(stream_name, realm)\n        default_streams = get_default_streams_for_realm(realm.id)\n        default_streams_name = [stream.name for stream in default_streams]\n        self.assertNotIn(stream_name, default_streams_name)\n\n        # Invite user.\n        self.ldap_invite_and_signup_as(\n            PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"], streams=[stream_name]\n        )\n\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n        sub = get_stream_subscriptions_for_user(user_profile).filter(recipient__type_id=stream.id)\n        self.assert_length(sub, 1)\n\n    def test_registration_when_name_changes_are_disabled(self) -> None:\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"New Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New Name\")\n\n    def test_realm_creation_through_ldap(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TERMS_OF_SERVICE_VERSION=1.0,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email)\n            confirmation = Confirmation.objects.get(confirmation_key=key)\n            prereg_user = confirmation.content_object\n            assert prereg_user is not None\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_name=realm_name,\n                realm_subdomain=subdomain,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_mirror_dummy_user(self, ignored: Any) -> None:\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, False)\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to\n        # submit the registration form should raise an AssertionError\n        # (this is an invalid state, so it's a bug we got here):\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /accounts/register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n        change_user_is_active(user_profile, False)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            from_confirmation=\"1\",\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_active_mirror_dummy_user(self, ignored: Any) -> None:\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should\n        raise an AssertionError.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration(self) -> None:\n        \"\"\"Verify that /devtools/register_user creates a new user, logs them\n        in, and redirects to the logged-in app.\"\"\"\n        count = UserProfile.objects.count()\n        email = f\"user-{count}@zulip.com\"\n\n        result = self.client_post(\"/devtools/register_user/\")\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(user_profile.delivery_email, email)\n        self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_realm(self) -> None:\n        count = UserProfile.objects.count()\n        string_id = f\"realm-{count}\"\n\n        result = self.client_post(\"/devtools/register_realm/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(f\"http://{string_id}.testserver/accounts/login/subdomain\")\n        )\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_demo_realm(self) -> None:\n        result = self.client_post(\"/devtools/register_demo_realm/\")\n        self.assertEqual(result.status_code, 302)\n\n        realm = Realm.objects.latest(\"date_created\")\n        self.assertTrue(\n            result[\"Location\"].startswith(\n                f\"http://{realm.string_id}.testserver/accounts/login/subdomain\"\n            )\n        )\n        result = self.client_get(result[\"Location\"], subdomain=realm.string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{realm.string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n        expected_deletion_date = realm.date_created + datetime.timedelta(\n            days=settings.DEMO_ORG_DEADLINE_DAYS\n        )\n        self.assertEqual(realm.demo_organization_scheduled_deletion_date, expected_deletion_date)\n\n\nclass DeactivateUserTest(ZulipTestCase):\n    def test_deactivate_user(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n        password = initial_password(email)\n        assert password is not None\n        self.assert_login_failure(email, password=password)\n\n    def test_do_not_deactivate_final_owner(self) -> None:\n        user = self.example_user(\"desdemona\")\n        user_2 = self.example_user(\"iago\")\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only organization owner.\")\n        user = self.example_user(\"desdemona\")\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_owner)\n        do_change_user_role(user_2, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        self.assertTrue(user_2.is_realm_owner)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        do_change_user_role(user, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n\n    def test_do_not_deactivate_final_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        for user_profile in UserProfile.objects.filter(realm=realm).exclude(\n            role=UserProfile.ROLE_REALM_OWNER\n        ):\n            do_deactivate_user(user_profile, acting_user=None)\n        user = self.example_user(\"desdemona\")\n        self.login_user(user)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only user.\")\n\n\nclass TestLoginPage(ZulipTestCase):\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_alias(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_domain(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n            ROOT_SUBDOMAIN_ALIASES=[\"test\"],\n        ):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_works_without_subdomains(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n    def test_login_page_registration_hint(self) -> None:\n        response = self.client_get(\"/login/\")\n        self.assert_not_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save(update_fields=[\"invite_required\"])\n        response = self.client_get(\"/login/\")\n        self.assert_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n    @patch(\"django.http.HttpRequest.get_host\", return_value=\"auth.testserver\")\n    def test_social_auth_subdomain_login_page(self, mock_get_host: MagicMock) -> None:\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n        zulip_realm = get_realm(\"zulip\")\n        session = self.client.session\n        session[\"subdomain\"] = \"zulip\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, zulip_realm.uri)\n\n        session = self.client.session\n        session[\"subdomain\"] = \"invalid\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n    def test_login_page_is_deactivated_validation(self) -> None:\n        with patch(\"zerver.views.auth.logging.info\") as mock_info:\n            result = self.client_get(\"/login/?is_deactivated=invalid_email\")\n            mock_info.assert_called_once()\n            self.assert_not_in_success_response([\"invalid_email\"], result)\n\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self) -> None:\n        result = self.client_get(\"/accounts/find/\")\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode())\n\n    def test_result(self) -> None:\n        # We capitalize a letter in cordelia's email to test that the search is case-insensitive.\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,cordeliA@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2CcordeliA%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(\"iago@zulip.com\", content)\n        self.assertIn(\"cordeliA@zulip.com\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 2)\n        iago_message = outbox[1]\n        cordelia_message = outbox[0]\n        self.assertIn(\"Zulip Dev\", iago_message.body)\n        self.assertNotIn(\"Lear & Co\", iago_message.body)\n        self.assertIn(\"Zulip Dev\", cordelia_message.body)\n        self.assertIn(\"Lear & Co\", cordelia_message.body)\n\n    def test_find_team_ignore_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,invalid_email@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_reject_invalid_email(self) -> None:\n        result = self.client_post(\"/accounts/find/\", dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get(\"/accounts/find/\", {\"emails\": \"invalid\"})\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self) -> None:\n        data = {\"emails\": \"\"}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertIn(\"This field is required\", result.content.decode())\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_one_email(self) -> None:\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_deactivated_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_deactivated_realm(self) -> None:\n        do_deactivate_realm(get_realm(\"zulip\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_bot_email(self) -> None:\n        data = {\"emails\": self.example_email(\"webhook_bot\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=webhook-bot%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_more_than_ten_emails(self) -> None:\n        data = {\"emails\": \",\".join(f\"hamlet-{i}@zulip.com\" for i in range(11))}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode())\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self) -> None:\n        request = MagicMock()\n        request.session = {\n            \"confirmation_key\": {\"confirmation_key\": \"xyzzy\"},\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response(\"xyzzy\", result)\n\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self) -> None:\n        self.assertEqual(xor_hex_strings(\"1237c81ab\", \"18989fd12\"), \"0aaf57cb9\")\n        with self.assertRaises(AssertionError):\n            xor_hex_strings(\"1\", \"31\")\n\n    def test_is_valid_otp(self) -> None:\n        self.assertEqual(is_valid_otp(\"1234\"), False)\n        self.assertEqual(is_valid_otp(\"1234abcd\" * 8), True)\n        self.assertEqual(is_valid_otp(\"1234abcZ\" * 8), False)\n\n    def test_ascii_to_hex(self) -> None:\n        self.assertEqual(ascii_to_hex(\"ZcdR1234\"), \"5a63645231323334\")\n        self.assertEqual(hex_to_ascii(\"5a63645231323334\"), \"ZcdR1234\")\n\n    def test_otp_encrypt_api_key(self) -> None:\n        api_key = \"12ac\" * 8\n        otp = \"7be38894\" * 8\n        result = otp_encrypt_api_key(api_key, otp)\n        self.assertEqual(result, \"4ad1e9f7\" * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, api_key)\n\n\nclass FollowupEmailTest(ZulipTestCase):\n    def test_followup_day2_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        # Test date_joined == Sunday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 7, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Tuesday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 2, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Thursday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 4, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n        # Test date_joined == Friday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=3, hours=-1)\n        )\n\n        # Time offset of America/Phoenix is -07:00\n        user_profile.timezone = \"America/Phoenix\"\n        # Test date_joined == Friday in UTC, but Thursday in the user's time zone\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n\n\nclass NoReplyEmailTest(ZulipTestCase):\n    def test_noreply_email_address(self) -> None:\n        self.assertTrue(\n            re.search(self.TOKENIZED_NOREPLY_REGEX, FromAddress.tokenized_no_reply_address())\n        )\n\n        with self.settings(ADD_TOKENS_TO_NOREPLY_ADDRESS=False):\n            self.assertEqual(FromAddress.tokenized_no_reply_address(), \"noreply@testserver\")\n\n\nclass TwoFactorAuthTest(ZulipTestCase):\n    @patch(\"two_factor.models.totp\")\n    def test_two_factor_login(self, mock_totp: MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n        ):\n\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_logs:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(\n                info_logs.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n            self.assertEqual(result.status_code, 200)\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to '/' if user is already\n            # logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass NameRestrictionsTest(ZulipTestCase):\n    def test_whitelisted_disposable_domains(self) -> None:\n        self.assertFalse(is_disposable_domain(\"OPayQ.com\"))\n\n\nclass RealmRedirectTest(ZulipTestCase):\n    def test_realm_redirect_without_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\")\n        self.assert_in_success_response([\"Enter your organization's Zulip URL\"], result)\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"zephyr\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"invalid\"})\n        self.assert_in_success_response([\"We couldn&#39;t find that Zulip organization.\"], result)\n\n    def test_realm_redirect_with_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\", {\"next\": \"billing\"})\n        self.assert_in_success_response(\n            [\"Enter your organization's Zulip URL\", 'action=\"/accounts/go/?next=billing\"'], result\n        )\n\n        result = self.client_post(\"/accounts/go/?next=billing\", {\"subdomain\": \"lear\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://lear.testserver/billing\")\n", "import logging\nimport secrets\nimport urllib\nfrom functools import wraps\nfrom typing import Any, Dict, List, Mapping, Optional, cast\nfrom urllib.parse import urlencode\n\nimport jwt\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth.views import LoginView as DjangoLoginView\nfrom django.contrib.auth.views import PasswordResetView as DjangoPasswordResetView\nfrom django.contrib.auth.views import logout_then_login as django_logout_then_login\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import validate_email\nfrom django.forms import Form\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect, HttpResponseServerError\nfrom django.shortcuts import redirect, render\nfrom django.template.response import SimpleTemplateResponse\nfrom django.urls import reverse\nfrom django.utils.html import escape\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.translation import gettext as _\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.http import require_safe\nfrom markupsafe import Markup as mark_safe\nfrom social_django.utils import load_backend, load_strategy\nfrom two_factor.forms import BackupTokenForm\nfrom two_factor.views import LoginView as BaseTwoFactorLoginView\n\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n)\nfrom version import API_FEATURE_LEVEL, ZULIP_MERGE_BASE, ZULIP_VERSION\nfrom zerver.context_processors import get_realm_from_request, login_context, zulip_default_context\nfrom zerver.decorator import do_login, log_view_func, process_client, require_post\nfrom zerver.forms import (\n    DEACTIVATED_ACCOUNT_ERROR,\n    AuthenticationTokenForm,\n    HomepageForm,\n    OurAuthenticationForm,\n    ZulipPasswordResetForm,\n)\nfrom zerver.lib.exceptions import (\n    AuthenticationFailedError,\n    InvalidSubdomainError,\n    JsonableError,\n    PasswordAuthDisabledError,\n    PasswordResetRequiredError,\n    RateLimited,\n    RealmDeactivatedError,\n    UserDeactivatedError,\n)\nfrom zerver.lib.mobile_auth_otp import otp_encrypt_api_key\nfrom zerver.lib.push_notifications import push_notifications_enabled\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.realm_icon import realm_icon_url\nfrom zerver.lib.request import REQ, RequestNotes, has_request_variables\nfrom zerver.lib.response import json_success\nfrom zerver.lib.sessions import set_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_subdomain_root_or_alias\nfrom zerver.lib.types import ViewFuncT\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.user_agent import parse_user_agent\nfrom zerver.lib.users import get_api_key\nfrom zerver.lib.utils import has_api_key_format\nfrom zerver.lib.validator import validate_login_email\nfrom zerver.models import (\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    UserProfile,\n    filter_to_valid_prereg_users,\n    get_realm,\n    remote_user_to_email,\n)\nfrom zerver.signals import email_on_new_login\nfrom zproject.backends import (\n    AUTH_BACKEND_NAME_MAP,\n    AppleAuthBackend,\n    ExternalAuthDataDict,\n    ExternalAuthResult,\n    GenericOpenIdConnectBackend,\n    SAMLAuthBackend,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPConfigurationError,\n    ZulipRemoteUserBackend,\n    auth_enabled_helper,\n    dev_auth_enabled,\n    ldap_auth_enabled,\n    password_auth_enabled,\n    saml_auth_enabled,\n    validate_otp_params,\n)\n\nExtraContext = Optional[Dict[str, Any]]\n\n\ndef get_safe_redirect_to(url: str, redirect_host: str) -> str:\n    is_url_safe = url_has_allowed_host_and_scheme(url=url, allowed_hosts=None)\n    if is_url_safe:\n        # Mark as safe to prevent Pysa from surfacing false positives for\n        # open redirects. In this branch, we have already checked that the URL\n        # points to the specified 'redirect_host', or is relative.\n        return urllib.parse.urljoin(redirect_host, mark_sanitized(url))\n    else:\n        return redirect_host\n\n\ndef create_preregistration_user(\n    email: str,\n    request: HttpRequest,\n    realm_creation: bool = False,\n    password_required: bool = True,\n    full_name: Optional[str] = None,\n    full_name_validated: bool = False,\n) -> PreregistrationUser:\n    realm = None\n    if not realm_creation:\n        try:\n            realm = get_realm(get_subdomain(request))\n        except Realm.DoesNotExist:\n            pass\n    return PreregistrationUser.objects.create(\n        email=email,\n        realm_creation=realm_creation,\n        password_required=password_required,\n        realm=realm,\n        full_name=full_name,\n        full_name_validated=full_name_validated,\n    )\n\n\ndef maybe_send_to_registration(\n    request: HttpRequest,\n    email: str,\n    full_name: str = \"\",\n    mobile_flow_otp: Optional[str] = None,\n    desktop_flow_otp: Optional[str] = None,\n    is_signup: bool = False,\n    password_required: bool = True,\n    multiuse_object_key: str = \"\",\n    full_name_validated: bool = False,\n) -> HttpResponse:\n    \"\"\"Given a successful authentication for an email address (i.e. we've\n    confirmed the user controls the email address) that does not\n    currently have a Zulip account in the target realm, send them to\n    the registration flow or the \"continue to registration\" flow,\n    depending on is_signup, whether the email address can join the\n    organization (checked in HomepageForm), and similar details.\n    \"\"\"\n\n    # In the desktop and mobile registration flows, the sign up\n    # happens in the browser so the user can use their\n    # already-logged-in social accounts.  Then at the end, with the\n    # user account created, we pass the appropriate data to the app\n    # via e.g. a `zulip://` redirect.  We store the OTP keys for the\n    # mobile/desktop flow in the session with 1-hour expiry, because\n    # we want this configuration of having a successful authentication\n    # result in being logged into the app to persist if the user makes\n    # mistakes while trying to authenticate (E.g. clicks the wrong\n    # Google account, hits back, etc.) during a given browser session,\n    # rather than just logging into the web app in the target browser.\n    #\n    # We can't use our usual pre-account-creation state storage\n    # approach of putting something in PreregistrationUser, because\n    # that would apply to future registration attempts on other\n    # devices, e.g. just creating an account on the web on their laptop.\n    assert not (mobile_flow_otp and desktop_flow_otp)\n    if mobile_flow_otp:\n        set_expirable_session_var(\n            request.session, \"registration_mobile_flow_otp\", mobile_flow_otp, expiry_seconds=3600\n        )\n    elif desktop_flow_otp:\n        set_expirable_session_var(\n            request.session, \"registration_desktop_flow_otp\", desktop_flow_otp, expiry_seconds=3600\n        )\n\n    try:\n        # TODO: This should use get_realm_from_request, but a bunch of tests\n        # rely on mocking get_subdomain here, so they'll need to be tweaked first.\n        realm: Optional[Realm] = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        realm = None\n\n    multiuse_obj: Optional[MultiuseInvite] = None\n    from_multiuse_invite = False\n    if multiuse_object_key:\n        from_multiuse_invite = True\n        try:\n            multiuse_obj = get_object_from_key(multiuse_object_key, [Confirmation.MULTIUSE_INVITE])\n        except ConfirmationKeyException as exception:\n            return render_confirmation_key_error(request, exception)\n\n        assert multiuse_obj is not None\n        if realm != multiuse_obj.realm:\n            return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n\n        invited_as = multiuse_obj.invited_as\n    else:\n        invited_as = PreregistrationUser.INVITE_AS[\"MEMBER\"]\n\n    form = HomepageForm({\"email\": email}, realm=realm, from_multiuse_invite=from_multiuse_invite)\n    if form.is_valid():\n        # If the email address is allowed to sign up for an account in\n        # this organization, construct a PreregistrationUser and\n        # Confirmation objects, and then send the user to account\n        # creation or confirm-continue-registration depending on\n        # is_signup.\n        try:\n            prereg_user = filter_to_valid_prereg_users(\n                PreregistrationUser.objects.filter(email__iexact=email, realm=realm)\n            ).latest(\"invited_at\")\n\n            # password_required and full_name data passed here as argument should take precedence\n            # over the defaults with which the existing PreregistrationUser that we've just fetched\n            # was created.\n            prereg_user.password_required = password_required\n            update_fields = [\"password_required\"]\n            if full_name:\n                prereg_user.full_name = full_name\n                prereg_user.full_name_validated = full_name_validated\n                update_fields.extend([\"full_name\", \"full_name_validated\"])\n            prereg_user.save(update_fields=update_fields)\n        except PreregistrationUser.DoesNotExist:\n            prereg_user = create_preregistration_user(\n                email,\n                request,\n                password_required=password_required,\n                full_name=full_name,\n                full_name_validated=full_name_validated,\n            )\n\n        if multiuse_obj is not None:\n            request.session.modified = True\n            streams_to_subscribe = list(multiuse_obj.streams.all())\n            prereg_user.streams.set(streams_to_subscribe)\n            prereg_user.invited_as = invited_as\n            prereg_user.save()\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        if is_signup:\n            return redirect(confirmation_link)\n\n        context = {\"email\": email, \"continue_link\": confirmation_link, \"full_name\": full_name}\n        return render(request, \"zerver/confirm_continue_registration.html\", context=context)\n\n    # This email address it not allowed to join this organization, so\n    # just send the user back to the registration page.\n    url = reverse(\"register\")\n    context = login_context(request)\n    extra_context: Mapping[str, Any] = {\n        \"form\": form,\n        \"current_url\": lambda: url,\n        \"from_multiuse_invite\": from_multiuse_invite,\n        \"multiuse_object_key\": multiuse_object_key,\n        \"mobile_flow_otp\": mobile_flow_otp,\n        \"desktop_flow_otp\": desktop_flow_otp,\n    }\n    context.update(extra_context)\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef register_remote_user(request: HttpRequest, result: ExternalAuthResult) -> HttpResponse:\n    # We have verified the user controls an email address, but\n    # there's no associated Zulip user account.  Consider sending\n    # the request to registration.\n    kwargs: Dict[str, Any] = dict(result.data_dict)\n    # maybe_send_to_registration doesn't take these arguments, so delete them.\n    kwargs.pop(\"subdomain\", None)\n    kwargs.pop(\"redirect_to\", None)\n    kwargs.pop(\"is_realm_creation\", None)\n\n    kwargs[\"password_required\"] = False\n    return maybe_send_to_registration(request, **kwargs)\n\n\ndef login_or_register_remote_user(request: HttpRequest, result: ExternalAuthResult) -> HttpResponse:\n    \"\"\"Given a successful authentication showing the user controls given\n    email address (email) and potentially a UserProfile\n    object (if the user already has a Zulip account), redirect the\n    browser to the appropriate place:\n\n    * The logged-in app if the user already has a Zulip account and is\n      trying to log in, potentially to an initial narrow or page that had been\n      saved in the `redirect_to` parameter.\n    * The registration form if is_signup was set (i.e. the user is\n      trying to create a Zulip account)\n    * A special `confirm_continue_registration.html` \"do you want to\n      register or try another account\" if the user doesn't have a\n      Zulip account but is_signup is False (i.e. the user tried to log in\n      and then did social authentication selecting an email address that does\n      not have a Zulip account in this organization).\n    * A zulip:// URL to send control back to the mobile or desktop apps if they\n      are doing authentication using the mobile_flow_otp or desktop_flow_otp flow.\n    \"\"\"\n    user_profile = result.user_profile\n    if user_profile is None or user_profile.is_mirror_dummy:\n        return register_remote_user(request, result)\n    # Otherwise, the user has successfully authenticated to an\n    # account, and we need to do the right thing depending whether\n    # or not they're using the mobile OTP flow or want a browser session.\n    is_realm_creation = result.data_dict.get(\"is_realm_creation\")\n    mobile_flow_otp = result.data_dict.get(\"mobile_flow_otp\")\n    desktop_flow_otp = result.data_dict.get(\"desktop_flow_otp\")\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n\n    redirect_to = result.data_dict.get(\"redirect_to\", \"\")\n    if is_realm_creation is not None and settings.BILLING_ENABLED:\n        from corporate.lib.stripe import is_free_trial_offer_enabled\n\n        if is_free_trial_offer_enabled():\n            redirect_to = \"{}?onboarding=true\".format(reverse(\"initial_upgrade\"))\n\n    redirect_to = get_safe_redirect_to(redirect_to, user_profile.realm.uri)\n    return HttpResponseRedirect(redirect_to)\n\n\ndef finish_desktop_flow(request: HttpRequest, user_profile: UserProfile, otp: str) -> HttpResponse:\n    \"\"\"\n    The desktop otp flow returns to the app (through the clipboard)\n    a token that allows obtaining (through log_into_subdomain) a logged in session\n    for the user account we authenticated in this flow.\n    The token can only be used once and within ExternalAuthResult.LOGIN_KEY_EXPIRATION_SECONDS\n    of being created, as nothing more powerful is needed for the desktop flow\n    and this ensures the key can only be used for completing this authentication attempt.\n    \"\"\"\n    result = ExternalAuthResult(user_profile=user_profile)\n    token = result.store_data()\n    key = bytes.fromhex(otp)\n    iv = secrets.token_bytes(12)\n    desktop_data = (iv + AESGCM(key).encrypt(iv, token.encode(), b\"\")).hex()\n    context = {\n        \"desktop_data\": desktop_data,\n        \"browser_url\": reverse(\"login_page\", kwargs={\"template_name\": \"zerver/login.html\"}),\n        \"realm_icon_url\": realm_icon_url(user_profile.realm),\n    }\n    return render(request, \"zerver/desktop_redirect.html\", context=context)\n\n\ndef finish_mobile_flow(request: HttpRequest, user_profile: UserProfile, otp: str) -> HttpResponse:\n    # For the mobile OAuth flow, we send the API key and other\n    # necessary details in a redirect to a zulip:// URI scheme.\n    api_key = get_api_key(user_profile)\n    response = create_response_for_otp_flow(\n        api_key, otp, user_profile, encrypted_key_field_name=\"otp_encrypted_api_key\"\n    )\n\n    # Since we are returning an API key instead of going through\n    # the Django login() function (which creates a browser\n    # session, etc.), the \"new login\" signal handler (which\n    # triggers an email notification new logins) will not run\n    # automatically.  So we call it manually here.\n    #\n    # Arguably, sending a fake 'user_logged_in' signal would be a better approach:\n    #   user_logged_in.send(sender=user_profile.__class__, request=request, user=user_profile)\n    email_on_new_login(sender=user_profile.__class__, request=request, user=user_profile)\n\n    # Mark this request as having a logged-in user for our server logs.\n    process_client(request, user_profile)\n    RequestNotes.get_notes(request).requestor_for_logs = user_profile.format_requestor_for_logs()\n\n    return response\n\n\ndef create_response_for_otp_flow(\n    key: str, otp: str, user_profile: UserProfile, encrypted_key_field_name: str\n) -> HttpResponse:\n    realm_uri = user_profile.realm.uri\n\n    # Check if the mobile URI is overridden in settings, if so, replace it\n    # This block should only apply to the mobile flow, so we if add others, this\n    # needs to be conditional.\n    if realm_uri in settings.REALM_MOBILE_REMAP_URIS:\n        realm_uri = settings.REALM_MOBILE_REMAP_URIS[realm_uri]\n\n    params = {\n        encrypted_key_field_name: otp_encrypt_api_key(key, otp),\n        \"email\": user_profile.delivery_email,\n        \"user_id\": user_profile.id,\n        \"realm\": realm_uri,\n    }\n    # We can't use HttpResponseRedirect, since it only allows HTTP(S) URLs\n    response = HttpResponse(status=302)\n    response[\"Location\"] = append_url_query_string(\"zulip://login\", urllib.parse.urlencode(params))\n\n    return response\n\n\n@log_view_func\n@has_request_variables\ndef remote_user_sso(\n    request: HttpRequest,\n    mobile_flow_otp: Optional[str] = REQ(default=None),\n    desktop_flow_otp: Optional[str] = REQ(default=None),\n    next: str = REQ(default=\"/\"),\n) -> HttpResponse:\n    subdomain = get_subdomain(request)\n    try:\n        realm: Optional[Realm] = get_realm(subdomain)\n    except Realm.DoesNotExist:\n        realm = None\n\n    if not auth_enabled_helper([ZulipRemoteUserBackend.auth_backend_name], realm):\n        return config_error(request, \"remote_user_backend_disabled\")\n\n    try:\n        remote_user = request.META[\"REMOTE_USER\"]\n    except KeyError:\n        return config_error(request, \"remote_user_header_missing\")\n\n    # Django invokes authenticate methods by matching arguments, and this\n    # authentication flow will not invoke LDAP authentication because of\n    # this condition of Django so no need to check if LDAP backend is\n    # enabled.\n    validate_login_email(remote_user_to_email(remote_user))\n\n    # Here we support the mobile and desktop flow for REMOTE_USER_BACKEND; we\n    # validate the data format and then pass it through to\n    # login_or_register_remote_user if appropriate.\n    validate_otp_params(mobile_flow_otp, desktop_flow_otp)\n\n    if realm is None:\n        user_profile = None\n    else:\n        user_profile = authenticate(remote_user=remote_user, realm=realm)\n\n    email = remote_user_to_email(remote_user)\n    data_dict = ExternalAuthDataDict(\n        email=email,\n        mobile_flow_otp=mobile_flow_otp,\n        desktop_flow_otp=desktop_flow_otp,\n        redirect_to=next,\n    )\n    if realm:\n        data_dict[\"subdomain\"] = realm.subdomain\n    else:\n        data_dict[\"subdomain\"] = \"\"  # realm creation happens on root subdomain\n    result = ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n    return login_or_register_remote_user(request, result)\n\n\n@csrf_exempt\n@log_view_func\ndef remote_user_jwt(request: HttpRequest) -> HttpResponse:\n    subdomain = get_subdomain(request)\n    try:\n        key = settings.JWT_AUTH_KEYS[subdomain][\"key\"]\n        algorithms = settings.JWT_AUTH_KEYS[subdomain][\"algorithms\"]\n    except KeyError:\n        raise JsonableError(_(\"Auth key for this subdomain not found.\"))\n\n    try:\n        json_web_token = request.POST[\"json_web_token\"]\n        options = {\"verify_signature\": True}\n        payload = jwt.decode(json_web_token, key, algorithms=algorithms, options=options)\n    except KeyError:\n        raise JsonableError(_(\"No JSON web token passed in request\"))\n    except jwt.InvalidTokenError:\n        raise JsonableError(_(\"Bad JSON web token\"))\n\n    remote_user = payload.get(\"user\", None)\n    if remote_user is None:\n        raise JsonableError(_(\"No user specified in JSON web token claims\"))\n    email_domain = payload.get(\"realm\", None)\n    if email_domain is None:\n        raise JsonableError(_(\"No organization specified in JSON web token claims\"))\n\n    email = f\"{remote_user}@{email_domain}\"\n\n    try:\n        realm = get_realm(subdomain)\n    except Realm.DoesNotExist:\n        raise JsonableError(_(\"Wrong subdomain\"))\n\n    user_profile = authenticate(username=email, realm=realm, use_dummy_backend=True)\n    if user_profile is None:\n        result = ExternalAuthResult(\n            data_dict={\"email\": email, \"full_name\": remote_user, \"subdomain\": realm.subdomain}\n        )\n    else:\n        result = ExternalAuthResult(user_profile=user_profile)\n\n    return login_or_register_remote_user(request, result)\n\n\n@has_request_variables\ndef oauth_redirect_to_root(\n    request: HttpRequest,\n    url: str,\n    sso_type: str,\n    is_signup: bool = False,\n    extra_url_params: Dict[str, str] = {},\n    next: Optional[str] = REQ(default=None),\n    multiuse_object_key: str = REQ(default=\"\"),\n    mobile_flow_otp: Optional[str] = REQ(default=None),\n    desktop_flow_otp: Optional[str] = REQ(default=None),\n) -> HttpResponse:\n    main_site_uri = settings.ROOT_DOMAIN_URI + url\n    if settings.SOCIAL_AUTH_SUBDOMAIN is not None and sso_type == \"social\":\n        main_site_uri = (\n            settings.EXTERNAL_URI_SCHEME\n            + settings.SOCIAL_AUTH_SUBDOMAIN\n            + \".\"\n            + settings.EXTERNAL_HOST\n        ) + url\n\n    params = {\n        \"subdomain\": get_subdomain(request),\n        \"is_signup\": \"1\" if is_signup else \"0\",\n    }\n\n    params[\"multiuse_object_key\"] = multiuse_object_key\n\n    # mobile_flow_otp is a one-time pad provided by the app that we\n    # can use to encrypt the API key when passing back to the app.\n    validate_otp_params(mobile_flow_otp, desktop_flow_otp)\n    if mobile_flow_otp is not None:\n        params[\"mobile_flow_otp\"] = mobile_flow_otp\n    if desktop_flow_otp is not None:\n        params[\"desktop_flow_otp\"] = desktop_flow_otp\n\n    if next:\n        params[\"next\"] = next\n\n    params = {**params, **extra_url_params}\n\n    return redirect(append_url_query_string(main_site_uri, urllib.parse.urlencode(params)))\n\n\ndef handle_desktop_flow(func: ViewFuncT) -> ViewFuncT:\n    @wraps(func)\n    def wrapper(request: HttpRequest, *args: object, **kwargs: object) -> HttpResponse:\n        user_agent = parse_user_agent(request.META.get(\"HTTP_USER_AGENT\", \"Missing User-Agent\"))\n        if user_agent[\"name\"] == \"ZulipElectron\":\n            return render(request, \"zerver/desktop_login.html\")\n\n        return func(request, *args, **kwargs)\n\n    return cast(ViewFuncT, wrapper)  # https://github.com/python/mypy/issues/1927\n\n\n@handle_desktop_flow\ndef start_remote_user_sso(request: HttpRequest) -> HttpResponse:\n    \"\"\"\n    The purpose of this endpoint is to provide an initial step in the flow\n    on which we can handle the special behavior for the desktop app.\n    /accounts/login/sso may have Apache intercepting requests to it\n    to do authentication, so we need this additional endpoint.\n    \"\"\"\n    query = request.META[\"QUERY_STRING\"]\n    return redirect(append_url_query_string(reverse(remote_user_sso), query))\n\n\n@handle_desktop_flow\ndef start_social_login(\n    request: HttpRequest,\n    backend: str,\n    extra_arg: Optional[str] = None,\n) -> HttpResponse:\n    backend_url = reverse(\"social:begin\", args=[backend])\n    extra_url_params: Dict[str, str] = {}\n    if backend == \"saml\":\n        if not SAMLAuthBackend.check_config():\n            return config_error(request, \"saml\")\n\n        # This backend requires the name of the IdP (from the list of configured ones)\n        # to be passed as the parameter.\n        if not extra_arg or extra_arg not in settings.SOCIAL_AUTH_SAML_ENABLED_IDPS:\n            logging.info(\n                \"Attempted to initiate SAML authentication with wrong idp argument: %s\", extra_arg\n            )\n            return config_error(request, \"saml\")\n        extra_url_params = {\"idp\": extra_arg}\n\n    if backend == \"apple\" and not AppleAuthBackend.check_config():\n        return config_error(request, \"apple\")\n    if backend == \"oidc\" and not GenericOpenIdConnectBackend.check_config():\n        return config_error(request, \"oidc\")\n\n    # TODO: Add AzureAD also.\n    if backend in [\"github\", \"google\", \"gitlab\"]:\n        key_setting = \"SOCIAL_AUTH_\" + backend.upper() + \"_KEY\"\n        secret_setting = \"SOCIAL_AUTH_\" + backend.upper() + \"_SECRET\"\n        if not (getattr(settings, key_setting) and getattr(settings, secret_setting)):\n            return config_error(request, backend)\n\n    return oauth_redirect_to_root(request, backend_url, \"social\", extra_url_params=extra_url_params)\n\n\n@handle_desktop_flow\ndef start_social_signup(\n    request: HttpRequest,\n    backend: str,\n    extra_arg: Optional[str] = None,\n) -> HttpResponse:\n    backend_url = reverse(\"social:begin\", args=[backend])\n    extra_url_params: Dict[str, str] = {}\n    if backend == \"saml\":\n        if not SAMLAuthBackend.check_config():\n            return config_error(request, \"saml\")\n\n        if not extra_arg or extra_arg not in settings.SOCIAL_AUTH_SAML_ENABLED_IDPS:\n            logging.info(\n                \"Attempted to initiate SAML authentication with wrong idp argument: %s\", extra_arg\n            )\n            return config_error(request, \"saml\")\n        extra_url_params = {\"idp\": extra_arg}\n    return oauth_redirect_to_root(\n        request, backend_url, \"social\", is_signup=True, extra_url_params=extra_url_params\n    )\n\n\n_subdomain_token_salt = \"zerver.views.auth.log_into_subdomain\"\n\n\n@log_view_func\ndef log_into_subdomain(request: HttpRequest, token: str) -> HttpResponse:\n    \"\"\"Given a valid authentication token (generated by\n    redirect_and_log_into_subdomain called on auth.zulip.example.com),\n    call login_or_register_remote_user, passing all the authentication\n    result data that has been stored in Redis, associated with this token.\n    \"\"\"\n    # The tokens are intended to have the same format as API keys.\n    if not has_api_key_format(token):\n        logging.warning(\"log_into_subdomain: Malformed token given: %s\", token)\n        return HttpResponse(status=400)\n\n    try:\n        result = ExternalAuthResult(login_token=token)\n    except ExternalAuthResult.InvalidTokenError:\n        logging.warning(\"log_into_subdomain: Invalid token given: %s\", token)\n        return render(request, \"zerver/log_into_subdomain_token_invalid.html\", status=400)\n\n    subdomain = get_subdomain(request)\n    if result.data_dict[\"subdomain\"] != subdomain:\n        raise JsonableError(_(\"Invalid subdomain\"))\n\n    return login_or_register_remote_user(request, result)\n\n\ndef redirect_and_log_into_subdomain(result: ExternalAuthResult) -> HttpResponse:\n    token = result.store_data()\n    realm = get_realm(result.data_dict[\"subdomain\"])\n    subdomain_login_uri = realm.uri + reverse(log_into_subdomain, args=[token])\n    return redirect(subdomain_login_uri)\n\n\ndef redirect_to_misconfigured_ldap_notice(request: HttpRequest, error_type: int) -> HttpResponse:\n    if error_type == ZulipLDAPAuthBackend.REALM_IS_NONE_ERROR:\n        return config_error(request, \"ldap\")\n    else:\n        raise AssertionError(\"Invalid error type\")\n\n\ndef show_deactivation_notice(request: HttpRequest) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    if realm and realm.deactivated:\n        context = {\"deactivated_domain_name\": realm.name}\n        if realm.deactivated_redirect is not None:\n            context[\"deactivated_redirect\"] = realm.deactivated_redirect\n        return render(request, \"zerver/deactivated.html\", context=context)\n\n    return HttpResponseRedirect(reverse(\"login_page\"))\n\n\ndef redirect_to_deactivation_notice() -> HttpResponse:\n    return HttpResponseRedirect(reverse(show_deactivation_notice))\n\n\ndef update_login_page_context(request: HttpRequest, context: Dict[str, Any]) -> None:\n    for key in (\"email\", \"already_registered\"):\n        try:\n            context[key] = request.GET[key]\n        except KeyError:\n            pass\n\n    deactivated_email = request.GET.get(\"is_deactivated\")\n    if deactivated_email is None:\n        return\n    try:\n        validate_email(deactivated_email)\n        context[\"deactivated_account_error\"] = mark_safe(\n            DEACTIVATED_ACCOUNT_ERROR.format(username=escape(deactivated_email))\n        )\n    except ValidationError:\n        logging.info(\"Invalid email in is_deactivated param to login page: %s\", deactivated_email)\n\n\nclass TwoFactorLoginView(BaseTwoFactorLoginView):\n    extra_context: ExtraContext = None\n    form_list = (\n        (\"auth\", OurAuthenticationForm),\n        (\"token\", AuthenticationTokenForm),\n        (\"backup\", BackupTokenForm),\n    )\n\n    def __init__(self, extra_context: ExtraContext = None, *args: Any, **kwargs: Any) -> None:\n        self.extra_context = extra_context\n        super().__init__(*args, **kwargs)\n\n    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:\n        context = super().get_context_data(**kwargs)\n        if self.extra_context is not None:\n            context.update(self.extra_context)\n        update_login_page_context(self.request, context)\n\n        realm = get_realm_from_request(self.request)\n        redirect_to = realm.uri if realm else \"/\"\n        context[\"next\"] = self.request.POST.get(\n            \"next\",\n            self.request.GET.get(\"next\", redirect_to),\n        )\n        return context\n\n    def done(self, form_list: List[Form], **kwargs: Any) -> HttpResponse:\n        \"\"\"\n        Log in the user and redirect to the desired page.\n\n        We need to override this function so that we can redirect to\n        realm.uri instead of '/'.\n        \"\"\"\n        realm_uri = self.get_user().realm.uri\n        # This mock.patch business is an unpleasant hack that we'd\n        # ideally like to remove by instead patching the upstream\n        # module to support better configurability of the\n        # LOGIN_REDIRECT_URL setting.  But until then, it works.  We\n        # import mock.patch here because mock has an expensive import\n        # process involving pbr -> pkgresources (which is really slow).\n        from unittest.mock import patch\n\n        with patch.object(settings, \"LOGIN_REDIRECT_URL\", realm_uri):\n            return super().done(form_list, **kwargs)\n\n\n@has_request_variables\ndef login_page(\n    request: HttpRequest,\n    next: str = REQ(default=\"/\"),\n    **kwargs: Any,\n) -> HttpResponse:\n    if settings.SOCIAL_AUTH_SUBDOMAIN == get_subdomain(request):\n        return social_auth_subdomain_login_page(request)\n\n    # To support previewing the Zulip login pages, we have a special option\n    # that disables the default behavior of redirecting logged-in users to the\n    # logged-in app.\n    is_preview = \"preview\" in request.GET\n    if settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n        if request.user and request.user.is_verified():\n            return HttpResponseRedirect(request.user.realm.uri)\n    elif request.user.is_authenticated and not is_preview:\n        return HttpResponseRedirect(request.user.realm.uri)\n    if is_subdomain_root_or_alias(request) and settings.ROOT_DOMAIN_LANDING_PAGE:\n        redirect_url = reverse(\"realm_redirect\")\n        if request.GET:\n            redirect_url = append_url_query_string(redirect_url, request.GET.urlencode())\n        return HttpResponseRedirect(redirect_url)\n\n    realm = get_realm_from_request(request)\n    if realm and realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    extra_context = kwargs.pop(\"extra_context\", {})\n    extra_context[\"next\"] = next\n    if dev_auth_enabled() and kwargs.get(\"template_name\") == \"zerver/development/dev_login.html\":\n        from zerver.views.development.dev_login import add_dev_login_context\n\n        if \"new_realm\" in request.POST:\n            try:\n                realm = get_realm(request.POST[\"new_realm\"])\n            except Realm.DoesNotExist:\n                realm = None\n\n        add_dev_login_context(realm, extra_context)\n        if realm and \"new_realm\" in request.POST:\n            # If we're switching realms, redirect to that realm, but\n            # only if it actually exists.\n            return HttpResponseRedirect(realm.uri)\n\n    if \"username\" in request.POST:\n        extra_context[\"email\"] = request.POST[\"username\"]\n    extra_context.update(login_context(request))\n\n    if settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n        return start_two_factor_auth(request, extra_context=extra_context, **kwargs)\n\n    try:\n        template_response = DjangoLoginView.as_view(\n            authentication_form=OurAuthenticationForm, extra_context=extra_context, **kwargs\n        )(request)\n    except ZulipLDAPConfigurationError as e:\n        assert len(e.args) > 1\n        return redirect_to_misconfigured_ldap_notice(request, e.args[1])\n\n    if isinstance(template_response, SimpleTemplateResponse):\n        # Only those responses that are rendered using a template have\n        # context_data attribute. This attribute doesn't exist otherwise. It is\n        # added in SimpleTemplateResponse class, which is a derived class of\n        # HttpResponse. See django.template.response.SimpleTemplateResponse,\n        # https://github.com/django/django/blob/2.0/django/template/response.py#L19\n        update_login_page_context(request, template_response.context_data)\n\n    assert isinstance(template_response, HttpResponse)\n    return template_response\n\n\ndef social_auth_subdomain_login_page(request: HttpRequest) -> HttpResponse:\n    origin_subdomain = request.session.get(\"subdomain\")\n    if origin_subdomain is not None:\n        try:\n            origin_realm = get_realm(origin_subdomain)\n            return HttpResponseRedirect(origin_realm.uri)\n        except Realm.DoesNotExist:\n            pass\n\n    return render(request, \"zerver/auth_subdomain.html\", status=400)\n\n\ndef start_two_factor_auth(\n    request: HttpRequest, extra_context: ExtraContext = None, **kwargs: Any\n) -> HttpResponse:\n    two_fa_form_field = \"two_factor_login_view-current_step\"\n    if two_fa_form_field not in request.POST:\n        # Here we inject the 2FA step in the request context if it's missing to\n        # force the user to go to the first step of 2FA authentication process.\n        # This seems a bit hackish but simplifies things from testing point of\n        # view. I don't think this can result in anything bad because all the\n        # authentication logic runs after the auth step.\n        #\n        # If we don't do this, we will have to modify a lot of auth tests to\n        # insert this variable in the request.\n        request.POST = request.POST.copy()\n        request.POST.update({two_fa_form_field: \"auth\"})\n\n    \"\"\"\n    This is how Django implements as_view(), so extra_context will be passed\n    to the __init__ method of TwoFactorLoginView.\n\n    def as_view(cls, **initkwargs):\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            ...\n\n        return view\n    \"\"\"\n    two_fa_view = TwoFactorLoginView.as_view(extra_context=extra_context, **kwargs)\n    return two_fa_view(request, **kwargs)\n\n\n@csrf_exempt\n@require_post\n@has_request_variables\ndef api_fetch_api_key(\n    request: HttpRequest, username: str = REQ(), password: str = REQ()\n) -> HttpResponse:\n    return_data: Dict[str, bool] = {}\n\n    realm = get_realm_from_request(request)\n    if realm is None:\n        raise InvalidSubdomainError()\n\n    if not ldap_auth_enabled(realm=realm):\n        # In case we don't authenticate against LDAP, check for a valid\n        # email. LDAP backend can authenticate against a non-email.\n        validate_login_email(username)\n    user_profile = authenticate(\n        request=request, username=username, password=password, realm=realm, return_data=return_data\n    )\n    if return_data.get(\"inactive_user\"):\n        raise UserDeactivatedError()\n    if return_data.get(\"inactive_realm\"):\n        raise RealmDeactivatedError()\n    if return_data.get(\"password_auth_disabled\"):\n        raise PasswordAuthDisabledError()\n    if return_data.get(\"password_reset_needed\"):\n        raise PasswordResetRequiredError()\n    if user_profile is None:\n        raise AuthenticationFailedError()\n\n    assert user_profile.is_authenticated\n\n    # Maybe sending 'user_logged_in' signal is the better approach:\n    #   user_logged_in.send(sender=user_profile.__class__, request=request, user=user_profile)\n    # Not doing this only because over here we don't add the user information\n    # in the session. If the signal receiver assumes that we do then that\n    # would cause problems.\n    email_on_new_login(sender=user_profile.__class__, request=request, user=user_profile)\n\n    # Mark this request as having a logged-in user for our server logs.\n    process_client(request, user_profile)\n    RequestNotes.get_notes(request).requestor_for_logs = user_profile.format_requestor_for_logs()\n\n    api_key = get_api_key(user_profile)\n    return json_success(request, data={\"api_key\": api_key, \"email\": user_profile.delivery_email})\n\n\ndef get_auth_backends_data(request: HttpRequest) -> Dict[str, Any]:\n    \"\"\"Returns which authentication methods are enabled on the server\"\"\"\n    subdomain = get_subdomain(request)\n    try:\n        realm = Realm.objects.get(string_id=subdomain)\n    except Realm.DoesNotExist:\n        # If not the root subdomain, this is an error\n        if subdomain != Realm.SUBDOMAIN_FOR_ROOT_DOMAIN:\n            raise JsonableError(_(\"Invalid subdomain\"))\n        # With the root subdomain, it's an error or not depending\n        # whether ROOT_DOMAIN_LANDING_PAGE (which indicates whether\n        # there are some realms without subdomains on this server)\n        # is set.\n        if settings.ROOT_DOMAIN_LANDING_PAGE:\n            raise JsonableError(_(\"Subdomain required\"))\n        else:\n            realm = None\n    result = {\n        \"password\": password_auth_enabled(realm),\n    }\n    for auth_backend_name in AUTH_BACKEND_NAME_MAP:\n        key = auth_backend_name.lower()\n        result[key] = auth_enabled_helper([auth_backend_name], realm)\n    return result\n\n\ndef check_server_incompatibility(request: HttpRequest) -> bool:\n    user_agent = parse_user_agent(request.META.get(\"HTTP_USER_AGENT\", \"Missing User-Agent\"))\n    return user_agent[\"name\"] == \"ZulipInvalid\"\n\n\n@require_safe\n@csrf_exempt\ndef api_get_server_settings(request: HttpRequest) -> HttpResponse:\n    # Log which client is making this request.\n    process_client(request, request.user, skip_update_user_activity=True)\n    result = dict(\n        authentication_methods=get_auth_backends_data(request),\n        zulip_version=ZULIP_VERSION,\n        zulip_merge_base=ZULIP_MERGE_BASE,\n        zulip_feature_level=API_FEATURE_LEVEL,\n        push_notifications_enabled=push_notifications_enabled(),\n        is_incompatible=check_server_incompatibility(request),\n    )\n    context = zulip_default_context(request)\n    context.update(login_context(request))\n    # IMPORTANT NOTE:\n    # realm_name, realm_icon, etc. are not guaranteed to appear in the response.\n    # * If they do, that means the server URL has only one realm on it\n    # * If they don't, the server has multiple realms, and it's not clear which is\n    #   the requested realm, so we can't send back these data.\n    for settings_item in [\n        \"email_auth_enabled\",\n        \"require_email_format_usernames\",\n        \"realm_uri\",\n        \"realm_name\",\n        \"realm_icon\",\n        \"realm_description\",\n        \"realm_web_public_access_enabled\",\n        \"external_authentication_methods\",\n    ]:\n        if context[settings_item] is not None:\n            result[settings_item] = context[settings_item]\n    return json_success(request, data=result)\n\n\n@has_request_variables\ndef json_fetch_api_key(\n    request: HttpRequest, user_profile: UserProfile, password: str = REQ(default=\"\")\n) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    if realm is None:\n        raise JsonableError(_(\"Invalid subdomain\"))\n    if password_auth_enabled(user_profile.realm):\n        if not authenticate(\n            request=request, username=user_profile.delivery_email, password=password, realm=realm\n        ):\n            raise JsonableError(_(\"Password is incorrect.\"))\n\n    api_key = get_api_key(user_profile)\n    return json_success(request, data={\"api_key\": api_key, \"email\": user_profile.delivery_email})\n\n\nlogout_then_login = require_post(django_logout_then_login)\n\n\ndef password_reset(request: HttpRequest) -> HttpResponse:\n    if is_subdomain_root_or_alias(request) and settings.ROOT_DOMAIN_LANDING_PAGE:\n        redirect_url = append_url_query_string(\n            reverse(\"realm_redirect\"), urlencode({\"next\": reverse(\"password_reset\")})\n        )\n        return HttpResponseRedirect(redirect_url)\n\n    try:\n        response = DjangoPasswordResetView.as_view(\n            template_name=\"zerver/reset.html\",\n            form_class=ZulipPasswordResetForm,\n            success_url=\"/accounts/password/reset/done/\",\n        )(request)\n    except RateLimited as e:\n        assert e.secs_to_freedom is not None\n        return render(\n            request,\n            \"zerver/rate_limit_exceeded.html\",\n            context={\"retry_after\": int(e.secs_to_freedom)},\n            status=429,\n        )\n    assert isinstance(response, HttpResponse)\n    return response\n\n\n@csrf_exempt\ndef saml_sp_metadata(request: HttpRequest) -> HttpResponse:  # nocoverage\n    \"\"\"\n    This is the view function for generating our SP metadata\n    for SAML authentication. It's meant for helping check the correctness\n    of the configuration when setting up SAML, or for obtaining the XML metadata\n    if the IdP requires it.\n    Taken from https://python-social-auth.readthedocs.io/en/latest/backends/saml.html\n    \"\"\"\n    if not saml_auth_enabled():\n        return config_error(request, \"saml\")\n\n    complete_url = reverse(\"social:complete\", args=(\"saml\",))\n    saml_backend = load_backend(load_strategy(request), \"saml\", complete_url)\n    metadata, errors = saml_backend.generate_metadata_xml()\n    if not errors:\n        return HttpResponse(content=metadata, content_type=\"text/xml\")\n\n    return HttpResponseServerError(content=\", \".join(errors))\n\n\ndef config_error(request: HttpRequest, error_category_name: str) -> HttpResponse:\n    contexts = {\n        \"apple\": {\"social_backend_name\": \"apple\", \"has_markdown_file\": True},\n        \"google\": {\"social_backend_name\": \"google\", \"has_markdown_file\": True},\n        \"github\": {\"social_backend_name\": \"github\", \"has_markdown_file\": True},\n        \"gitlab\": {\"social_backend_name\": \"gitlab\", \"has_markdown_file\": True},\n        \"ldap\": {\"error_name\": \"ldap_error_realm_is_none\"},\n        \"dev\": {\"error_name\": \"dev_not_supported_error\"},\n        \"saml\": {\"social_backend_name\": \"saml\"},\n        \"smtp\": {\"error_name\": \"smtp_error\"},\n        \"remote_user_backend_disabled\": {\"error_name\": \"remoteuser_error_backend_disabled\"},\n        \"remote_user_header_missing\": {\"error_name\": \"remoteuser_error_remote_user_header_missing\"},\n        # TODO: Improve the config error page for OIDC.\n        \"oidc\": {\"error_name\": \"oidc_error\"},\n    }\n\n    return render(request, \"zerver/config_error.html\", contexts[error_category_name])\n", "import logging\nimport urllib\nfrom typing import Any, Dict, List, Optional\nfrom urllib.parse import urlencode\n\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.core import validators\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    RealmCreationKey,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n    validate_key,\n)\nfrom zerver.context_processors import get_realm_from_request, login_context\nfrom zerver.decorator import do_login, rate_limit_request_by_ip, require_post\nfrom zerver.forms import (\n    FindMyTeamForm,\n    HomepageForm,\n    RealmCreationForm,\n    RealmRedirectForm,\n    RegistrationForm,\n)\nfrom zerver.lib.actions import (\n    bulk_add_subscriptions,\n    do_activate_mirror_dummy_user,\n    do_change_full_name,\n    do_change_password,\n    do_change_user_setting,\n    do_create_realm,\n    do_create_user,\n    lookup_default_stream_groups,\n)\nfrom zerver.lib.email_validation import email_allowed_for_realm, validate_email_not_already_in_realm\nfrom zerver.lib.exceptions import RateLimited\nfrom zerver.lib.onboarding import send_initial_realm_messages, setup_realm_internal_bots\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.send_email import EmailNotDeliveredException, FromAddress, send_email\nfrom zerver.lib.sessions import get_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import get_accounts_for_email\nfrom zerver.lib.validator import to_converted_or_fallback, to_non_negative_int, to_timezone_or_empty\nfrom zerver.lib.zephyr import compute_mit_user_fullname\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    Stream,\n    UserProfile,\n    get_default_stream_groups,\n    get_realm,\n    get_source_profile,\n    get_user_by_delivery_email,\n    name_changes_disabled,\n)\nfrom zerver.views.auth import (\n    create_preregistration_user,\n    finish_desktop_flow,\n    finish_mobile_flow,\n    get_safe_redirect_to,\n    redirect_and_log_into_subdomain,\n    redirect_to_deactivation_notice,\n)\nfrom zproject.backends import (\n    ExternalAuthResult,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPExceptionNoMatchingLDAPUser,\n    email_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    ldap_auth_enabled,\n    password_auth_enabled,\n)\n\nif settings.BILLING_ENABLED:\n    from corporate.lib.registration import check_spare_licenses_available_for_registering_new_user\n    from corporate.lib.stripe import LicenseLimitError\n\n\n@has_request_variables\ndef get_prereg_key_and_redirect(\n    request: HttpRequest, confirmation_key: str, full_name: Optional[str] = REQ(default=None)\n) -> HttpResponse:\n    \"\"\"\n    The purpose of this little endpoint is primarily to take a GET\n    request to a long URL containing a confirmation key, and render\n    a page that will via JavaScript immediately do a POST request to\n    /accounts/register, so that the user can create their account on\n    a page with a cleaner URL (and with the browser security and UX\n    benefits of an HTTP POST having generated the page).\n\n    The only thing it does before rendering that page is to check\n    the validity of the confirmation link. This is redundant with a\n    similar check in accounts_register, but it provides a slightly nicer\n    user-facing error handling experience if the URL you visited is\n    displayed in the browser. (E.g. you can debug that you\n    accidentally adding an extra character after pasting).\n    \"\"\"\n    try:\n        check_prereg_key(request, confirmation_key)\n    except ConfirmationKeyException as e:\n        return render_confirmation_key_error(request, e)\n\n    return render(\n        request,\n        \"confirmation/confirm_preregistrationuser.html\",\n        context={\"key\": confirmation_key, \"full_name\": full_name},\n    )\n\n\ndef check_prereg_key(request: HttpRequest, confirmation_key: str) -> PreregistrationUser:\n    \"\"\"\n    Checks if the Confirmation key is valid, returning the PreregistrationUser object in case of success\n    and raising an appropriate ConfirmationKeyException otherwise.\n    \"\"\"\n    confirmation_types = [\n        Confirmation.USER_REGISTRATION,\n        Confirmation.INVITATION,\n        Confirmation.REALM_CREATION,\n    ]\n\n    prereg_user = get_object_from_key(confirmation_key, confirmation_types, activate_object=False)\n\n    if prereg_user.status == confirmation_settings.STATUS_REVOKED:\n        raise ConfirmationKeyException(ConfirmationKeyException.EXPIRED)\n\n    return prereg_user\n\n\n@require_post\n@has_request_variables\ndef accounts_register(\n    request: HttpRequest,\n    key: str = REQ(default=\"\"),\n    timezone: str = REQ(default=\"\", converter=to_timezone_or_empty),\n    from_confirmation: Optional[str] = REQ(default=None),\n    form_full_name: Optional[str] = REQ(\"full_name\", default=None),\n    source_realm_id: Optional[int] = REQ(\n        default=None, converter=to_converted_or_fallback(to_non_negative_int, None)\n    ),\n) -> HttpResponse:\n    try:\n        prereg_user = check_prereg_key(request, key)\n    except ConfirmationKeyException as e:\n        return render_confirmation_key_error(request, e)\n\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    role = prereg_user.invited_as\n    if realm_creation:\n        role = UserProfile.ROLE_REALM_OWNER\n\n    try:\n        validators.validate_email(email)\n    except ValidationError:\n        return render(request, \"zerver/invalid_email.html\", context={\"invalid_email\": True})\n\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        assert prereg_user.realm is not None\n        if get_subdomain(request) != prereg_user.realm.string_id:\n            return render_confirmation_key_error(\n                request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n            )\n        realm = prereg_user.realm\n        try:\n            email_allowed_for_realm(email, realm)\n        except DomainNotAllowedForRealmError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"closed_domain\": True},\n            )\n        except DisposableEmailError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"disposable_emails_not_allowed\": True},\n            )\n        except EmailContainsPlusError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"email_contains_plus\": True},\n            )\n\n        if realm.deactivated:\n            # The user is trying to register for a deactivated realm. Advise them to\n            # contact support.\n            return redirect_to_deactivation_notice()\n\n        try:\n            validate_email_not_already_in_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n\n        if settings.BILLING_ENABLED:\n            try:\n                check_spare_licenses_available_for_registering_new_user(realm, email)\n            except LicenseLimitError:\n                return render(request, \"zerver/no_spare_licenses.html\")\n\n    name_validated = False\n    require_ldap_password = False\n\n    if from_confirmation:\n        try:\n            del request.session[\"authenticated_full_name\"]\n        except KeyError:\n            pass\n\n        ldap_full_name = None\n        if settings.POPULATE_PROFILE_VIA_LDAP:\n            # If the user can be found in LDAP, we'll take the full name from the directory,\n            # and further down create a form pre-filled with it.\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    try:\n                        ldap_username = backend.django_to_ldap_username(email)\n                    except ZulipLDAPExceptionNoMatchingLDAPUser:\n                        logging.warning(\"New account email %s could not be found in LDAP\", email)\n                        break\n\n                    # Note that this `ldap_user` object is not a\n                    # `ZulipLDAPUser` with a `Realm` attached, so\n                    # calling `.populate_user()` on it will crash.\n                    # This is OK, since we're just accessing this user\n                    # to extract its name.\n                    #\n                    # TODO: We should potentially be accessing this\n                    # user to sync its initial avatar and custom\n                    # profile fields as well, if we indeed end up\n                    # creating a user account through this flow,\n                    # rather than waiting until `manage.py\n                    # sync_ldap_user_data` runs to populate it.\n                    ldap_user = _LDAPUser(backend, ldap_username)\n\n                    try:\n                        ldap_full_name = backend.get_mapped_name(ldap_user)\n                    except TypeError:\n                        break\n\n                    # Check whether this is ZulipLDAPAuthBackend,\n                    # which is responsible for authentication and\n                    # requires that LDAP accounts enter their LDAP\n                    # password to register, or ZulipLDAPUserPopulator,\n                    # which just populates UserProfile fields (no auth).\n                    require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)\n                    break\n\n        if ldap_full_name:\n            # We don't use initial= here, because if the form is\n            # complete (that is, no additional fields need to be\n            # filled out by the user) we want the form to validate,\n            # so they can be directly registered without having to\n            # go through this interstitial.\n            form = RegistrationForm({\"full_name\": ldap_full_name}, realm_creation=realm_creation)\n            request.session[\"authenticated_full_name\"] = ldap_full_name\n            name_validated = True\n        elif realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={\"full_name\": hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation,\n            )\n            name_validated = True\n        elif prereg_user.full_name:\n            if prereg_user.full_name_validated:\n                request.session[\"authenticated_full_name\"] = prereg_user.full_name\n                name_validated = True\n                form = RegistrationForm(\n                    {\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n            else:\n                form = RegistrationForm(\n                    initial={\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n        elif form_full_name is not None:\n            form = RegistrationForm(\n                initial={\"full_name\": form_full_name},\n                realm_creation=realm_creation,\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update(full_name=request.session[\"authenticated_full_name\"])\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n\n    if not (password_auth_enabled(realm) and password_required):\n        form[\"password\"].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm) and form[\"password\"].field.required:\n            password = form.cleaned_data[\"password\"]\n        else:\n            # If the user wasn't prompted for a password when\n            # completing the authentication form (because they're\n            # signing up with SSO and no password is required), set\n            # the password field to `None` (Which causes Django to\n            # create an unusable password).\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data[\"realm_subdomain\"]\n            realm_name = form.cleaned_data[\"realm_name\"]\n            realm_type = form.cleaned_data[\"realm_type\"]\n            is_demo_org = form.cleaned_data[\"is_demo_organization\"]\n            realm = do_create_realm(\n                string_id, realm_name, org_type=realm_type, is_demo_organization=is_demo_org\n            )\n            setup_realm_internal_bots(realm)\n        assert realm is not None\n\n        full_name = form.cleaned_data[\"full_name\"]\n        enable_marketing_emails = form.cleaned_data[\"enable_marketing_emails\"]\n        default_stream_group_names = request.POST.getlist(\"default_stream_group\")\n        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)\n\n        if source_realm_id is not None:\n            # Non-integer realm_id values like \"string\" are treated\n            # like the \"Do not import\" value of \"\".\n            source_profile: Optional[UserProfile] = get_source_profile(email, source_realm_id)\n        else:\n            source_profile = None\n\n        if not realm_creation:\n            try:\n                existing_user_profile: Optional[UserProfile] = get_user_by_delivery_email(\n                    email, realm\n                )\n            except UserProfile.DoesNotExist:\n                existing_user_profile = None\n        else:\n            existing_user_profile = None\n\n        user_profile: Optional[UserProfile] = None\n        return_data: Dict[str, bool] = {}\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            # prereg_user.realm_creation carries the information about whether\n            # we're in realm creation mode, and the ldap flow will handle\n            # that and create the user with the appropriate parameters.\n            user_profile = authenticate(\n                request=request,\n                username=email,\n                password=password,\n                realm=realm,\n                prereg_user=prereg_user,\n                return_data=return_data,\n            )\n            if user_profile is None:\n                can_use_different_backend = email_auth_enabled(realm) or (\n                    len(get_external_method_dicts(realm)) > 0\n                )\n                if settings.LDAP_APPEND_DOMAIN:\n                    # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account\n                    # if the email matches the ldap domain.\n                    can_use_different_backend = can_use_different_backend and (\n                        not email_belongs_to_ldap(realm, email)\n                    )\n                if return_data.get(\"no_matching_ldap_user\") and can_use_different_backend:\n                    # If both the LDAP and Email or Social auth backends are\n                    # enabled, and there's no matching user in the LDAP\n                    # directory then the intent is to create a user in the\n                    # realm with their email outside the LDAP organization\n                    # (with e.g. a password stored in the Zulip database,\n                    # not LDAP).  So we fall through and create the new\n                    # account.\n                    pass\n                else:\n                    # TODO: This probably isn't going to give a\n                    # user-friendly error message, but it doesn't\n                    # particularly matter, because the registration form\n                    # is hidden for most users.\n                    view_url = reverse(\"login\")\n                    query = urlencode({\"email\": email})\n                    redirect_url = append_url_query_string(view_url, query)\n                    return HttpResponseRedirect(redirect_url)\n            elif not realm_creation:\n                # Since we'll have created a user, we now just log them in.\n                return login_and_go_to_home(request, user_profile)\n            else:\n                # With realm_creation=True, we're going to return further down,\n                # after finishing up the creation process.\n                pass\n\n        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_mirror_dummy_user(user_profile, acting_user=user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_change_user_setting(user_profile, \"timezone\", timezone, acting_user=user_profile)\n            # TODO: When we clean up the `do_activate_mirror_dummy_user` code path,\n            # make it respect invited_as_admin / is_realm_admin.\n\n        if user_profile is None:\n            user_profile = do_create_user(\n                email,\n                password,\n                realm,\n                full_name,\n                prereg_user=prereg_user,\n                role=role,\n                tos_version=settings.TERMS_OF_SERVICE_VERSION,\n                timezone=timezone,\n                default_stream_groups=default_stream_groups,\n                source_profile=source_profile,\n                realm_creation=realm_creation,\n                acting_user=None,\n                enable_marketing_emails=enable_marketing_emails,\n            )\n\n        if realm_creation:\n            assert realm.signup_notifications_stream is not None\n            bulk_add_subscriptions(\n                realm, [realm.signup_notifications_stream], [user_profile], acting_user=None\n            )\n            send_initial_realm_messages(realm)\n\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(\n                ExternalAuthResult(user_profile=user_profile, data_dict={\"is_realm_creation\": True})\n            )\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(\n            username=user_profile.delivery_email,\n            realm=realm,\n            return_data=return_data,\n            use_dummy_backend=True,\n        )\n        if return_data.get(\"invalid_subdomain\"):\n            # By construction, this should never happen.\n            logging.error(\n                \"Subdomain mismatch in registration %s: %s\",\n                realm.subdomain,\n                user_profile.delivery_email,\n            )\n            return redirect(\"/\")\n\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        \"zerver/register.html\",\n        context={\n            \"form\": form,\n            \"email\": email,\n            \"key\": key,\n            \"full_name\": request.session.get(\"authenticated_full_name\", None),\n            \"lock_name\": name_validated and name_changes_disabled(realm),\n            # password_auth_enabled is normally set via our context processor,\n            # but for the registration form, there is no logged in user yet, so\n            # we have to set it here.\n            \"creating_new_team\": realm_creation,\n            \"password_required\": password_auth_enabled(realm) and password_required,\n            \"require_ldap_password\": require_ldap_password,\n            \"password_auth_enabled\": password_auth_enabled(realm),\n            \"root_domain_available\": is_root_domain_available(),\n            \"default_stream_groups\": [] if realm is None else get_default_stream_groups(realm),\n            \"accounts\": get_accounts_for_email(email),\n            \"MAX_REALM_NAME_LENGTH\": str(Realm.MAX_REALM_NAME_LENGTH),\n            \"MAX_NAME_LENGTH\": str(UserProfile.MAX_NAME_LENGTH),\n            \"MAX_PASSWORD_LENGTH\": str(form.MAX_PASSWORD_LENGTH),\n            \"MAX_REALM_SUBDOMAIN_LENGTH\": str(Realm.MAX_REALM_SUBDOMAIN_LENGTH),\n            \"corporate_enabled\": settings.CORPORATE_ENABLED,\n            \"sorted_realm_types\": sorted(\n                Realm.ORG_TYPES.values(), key=lambda d: d[\"display_order\"]\n            ),\n        },\n    )\n\n\ndef login_and_go_to_home(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    mobile_flow_otp = get_expirable_session_var(\n        request.session, \"registration_mobile_flow_otp\", delete=True\n    )\n    desktop_flow_otp = get_expirable_session_var(\n        request.session, \"registration_desktop_flow_otp\", delete=True\n    )\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n    # Using 'mark_sanitized' to work around false positive where Pysa thinks\n    # that 'user_profile' is user-controlled\n    return HttpResponseRedirect(mark_sanitized(user_profile.realm.uri) + reverse(\"home\"))\n\n\ndef prepare_activation_url(\n    email: str,\n    request: HttpRequest,\n    realm_creation: bool = False,\n    streams: Optional[List[Stream]] = None,\n    invited_as: Optional[int] = None,\n) -> str:\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(email, request, realm_creation)\n\n    if streams is not None:\n        prereg_user.streams.set(streams)\n\n    if invited_as is not None:\n        prereg_user.invited_as = invited_as\n        prereg_user.save()\n\n    confirmation_type = Confirmation.USER_REGISTRATION\n    if realm_creation:\n        confirmation_type = Confirmation.REALM_CREATION\n\n    activation_url = create_confirmation_link(prereg_user, confirmation_type)\n    if settings.DEVELOPMENT and realm_creation:\n        request.session[\"confirmation_key\"] = {\"confirmation_key\": activation_url.split(\"/\")[-1]}\n    return activation_url\n\n\ndef send_confirm_registration_email(\n    email: str,\n    activation_url: str,\n    *,\n    realm: Optional[Realm] = None,\n    request: Optional[HttpRequest] = None,\n) -> None:\n    send_email(\n        \"zerver/emails/confirm_registration\",\n        to_emails=[email],\n        from_address=FromAddress.tokenized_no_reply_address(),\n        language=request.LANGUAGE_CODE if request is not None else None,\n        context={\n            \"create_realm\": (realm is None),\n            \"activate_url\": activation_url,\n        },\n        realm=realm,\n        request=request,\n    )\n\n\ndef redirect_to_email_login_url(email: str) -> HttpResponseRedirect:\n    login_url = reverse(\"login\")\n    redirect_url = append_url_query_string(\n        login_url, urlencode({\"email\": email, \"already_registered\": 1})\n    )\n    return HttpResponseRedirect(redirect_url)\n\n\ndef create_realm(request: HttpRequest, creation_key: Optional[str] = None) -> HttpResponse:\n    try:\n        key_record = validate_key(creation_key)\n    except RealmCreationKey.Invalid:\n        return render(\n            request,\n            \"zerver/realm_creation_failed.html\",\n            context={\n                \"message\": _(\"The organization creation link has expired\" \" or is not valid.\")\n            },\n        )\n    if not settings.OPEN_REALM_CREATION:\n        if key_record is None:\n            return render(\n                request,\n                \"zerver/realm_creation_failed.html\",\n                context={\"message\": _(\"New organization creation disabled\")},\n            )\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # with a few restrictions on their email address.\n    if request.method == \"POST\":\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n            activation_url = prepare_activation_url(email, request, realm_creation=True)\n            if key_record is not None and key_record.presume_email_valid:\n                # The user has a token created from the server command line;\n                # skip confirming the email is theirs, taking their word for it.\n                # This is essential on first install if the admin hasn't stopped\n                # to configure outbound email up front, or it isn't working yet.\n                key_record.delete()\n                return HttpResponseRedirect(activation_url)\n\n            try:\n                send_confirm_registration_email(email, activation_url, request=request)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in create_realm\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if key_record is not None:\n                key_record.delete()\n            return HttpResponseRedirect(reverse(\"new_realm_send_confirm\", kwargs={\"email\": email}))\n    else:\n        form = RealmCreationForm()\n    return render(\n        request,\n        \"zerver/create_realm.html\",\n        context={\"form\": form, \"current_url\": request.get_full_path},\n    )\n\n\ndef accounts_home(\n    request: HttpRequest,\n    multiuse_object_key: str = \"\",\n    multiuse_object: Optional[MultiuseInvite] = None,\n) -> HttpResponse:\n    try:\n        realm = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        return HttpResponseRedirect(reverse(find_account))\n    if realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n    invited_as = None\n\n    if multiuse_object:\n        # multiuse_object's realm should have been validated by the caller,\n        # so this code shouldn't be reachable with a multiuse_object which\n        # has its realm mismatching the realm of the request.\n        assert realm == multiuse_object.realm\n\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n        invited_as = multiuse_object.invited_as\n\n    if request.method == \"POST\":\n        form = HomepageForm(request.POST, realm=realm, from_multiuse_invite=from_multiuse_invite)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n\n            try:\n                validate_email_not_already_in_realm(realm, email)\n            except ValidationError:\n                return redirect_to_email_login_url(email)\n\n            activation_url = prepare_activation_url(\n                email, request, streams=streams_to_subscribe, invited_as=invited_as\n            )\n            try:\n                send_confirm_registration_email(email, activation_url, request=request, realm=realm)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in accounts_home\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse(\"signup_send_confirm\", kwargs={\"email\": email}))\n\n    else:\n        form = HomepageForm(realm=realm)\n    context = login_context(request)\n    context.update(\n        form=form,\n        current_url=request.get_full_path,\n        multiuse_object_key=multiuse_object_key,\n        from_multiuse_invite=from_multiuse_invite,\n    )\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    multiuse_object = None\n    try:\n        multiuse_object = get_object_from_key(confirmation_key, [Confirmation.MULTIUSE_INVITE])\n        if realm != multiuse_object.realm:\n            return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n        # Required for OAuth 2\n    except ConfirmationKeyException as exception:\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(\n        request, multiuse_object_key=confirmation_key, multiuse_object=multiuse_object\n    )\n\n\n@has_request_variables\ndef find_account(\n    request: HttpRequest, raw_emails: Optional[str] = REQ(\"emails\", default=None)\n) -> HttpResponse:\n    url = reverse(\"find_account\")\n\n    emails: List[str] = []\n    if request.method == \"POST\":\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data[\"emails\"]\n            for i in range(len(emails)):\n                try:\n                    rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n                except RateLimited as e:\n                    assert e.secs_to_freedom is not None\n                    return render(\n                        request,\n                        \"zerver/rate_limit_exceeded.html\",\n                        context={\"retry_after\": int(e.secs_to_freedom)},\n                        status=429,\n                    )\n\n            # Django doesn't support __iexact__in lookup with EmailField, so we have\n            # to use Qs to get around that without needing to do multiple queries.\n            emails_q = Q()\n            for email in emails:\n                emails_q |= Q(delivery_email__iexact=email)\n\n            user_profiles = UserProfile.objects.filter(\n                emails_q, is_active=True, is_bot=False, realm__deactivated=False\n            )\n\n            # We organize the data in preparation for sending exactly\n            # one outgoing email per provided email address, with each\n            # email listing all of the accounts that email address has\n            # with the current Zulip server.\n            context: Dict[str, Dict[str, Any]] = {}\n            for user in user_profiles:\n                key = user.delivery_email.lower()\n                context.setdefault(key, {})\n                context[key].setdefault(\"realms\", [])\n                context[key][\"realms\"].append(user.realm)\n                context[key][\"external_host\"] = settings.EXTERNAL_HOST\n                # This value will end up being the last user ID among\n                # matching accounts; since it's only used for minor\n                # details like language, that arbitrary choice is OK.\n                context[key][\"to_user_id\"] = user.id\n\n            for delivery_email, realm_context in context.items():\n                realm_context[\"email\"] = delivery_email\n                send_email(\n                    \"zerver/emails/find_team\",\n                    to_user_ids=[realm_context[\"to_user_id\"]],\n                    context=realm_context,\n                    from_address=FromAddress.SUPPORT,\n                    request=request,\n                )\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({\"emails\": \",\".join(emails)})\n            return redirect(append_url_query_string(url, data))\n    else:\n        form = FindMyTeamForm()\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if raw_emails:\n            for email in raw_emails.split(\",\"):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(\n        request,\n        \"zerver/find_account.html\",\n        context={\"form\": form, \"current_url\": lambda: url, \"emails\": emails},\n    )\n\n\n@has_request_variables\ndef realm_redirect(request: HttpRequest, next: str = REQ(default=\"\")) -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = get_safe_redirect_to(next, realm.uri)\n            return HttpResponseRedirect(redirect_to)\n    else:\n        form = RealmRedirectForm()\n\n    return render(request, \"zerver/realm_redirect.html\", context={\"form\": form})\n"], "filenames": ["zerver/tests/test_auth_backends.py", "zerver/tests/test_signup.py", "zerver/views/auth.py", "zerver/views/registration.py"], "buggy_code_start_loc": [93, 14, 183, 679], "buggy_code_end_loc": [1584, 2904, 202, 735], "fixing_code_start_loc": [94, 14, 184, 679], "fixing_code_end_loc": [1628, 2934, 205, 740], "type": "CWE-863", "message": "Zulip is an open-source team collaboration tool with topic-based threading. Zulip Server version 2.0.0 and above are vulnerable to insufficient access control with multi-use invitations. A Zulip Server deployment which hosts multiple organizations is vulnerable to an attack where an invitation created in one organization (potentially as a role with elevated permissions) can be used to join any other organization. This bypasses any restrictions on required domains on users' email addresses, may be used to gain access to organizations which are only accessible by invitation, and may be used to gain access with elevated privileges. This issue has been patched in release 4.10. There are no known workarounds for this issue. ### Patches _Has the problem been patched? What versions should users upgrade to?_ ### Workarounds _Is there a way for users to fix or remediate the vulnerability without upgrading?_ ### References _Are there any links users can visit to find out more?_ ### For more information If you have any questions or comments about this advisory, you can discuss them on the [developer community Zulip server](https://zulip.com/developer-community/), or email the [Zulip security team](mailto:security@zulip.com).", "other": {"cve": {"id": "CVE-2022-21706", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-26T00:15:08.260", "lastModified": "2022-03-08T15:11:47.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip is an open-source team collaboration tool with topic-based threading. Zulip Server version 2.0.0 and above are vulnerable to insufficient access control with multi-use invitations. A Zulip Server deployment which hosts multiple organizations is vulnerable to an attack where an invitation created in one organization (potentially as a role with elevated permissions) can be used to join any other organization. This bypasses any restrictions on required domains on users' email addresses, may be used to gain access to organizations which are only accessible by invitation, and may be used to gain access with elevated privileges. This issue has been patched in release 4.10. There are no known workarounds for this issue. ### Patches _Has the problem been patched? What versions should users upgrade to?_ ### Workarounds _Is there a way for users to fix or remediate the vulnerability without upgrading?_ ### References _Are there any links users can visit to find out more?_ ### For more information If you have any questions or comments about this advisory, you can discuss them on the [developer community Zulip server](https://zulip.com/developer-community/), or email the [Zulip security team](mailto:security@zulip.com)."}, {"lang": "es", "value": "Zulip es una herramienta de colaboraci\u00f3n en equipo de c\u00f3digo abierto con hilos basados en temas. Zulip Server versi\u00f3n 2.0.0 y superior, es vulnerable a un control de acceso insuficiente con invitaciones de uso m\u00faltiple. Un despliegue de Zulip Server que alberga m\u00faltiples organizaciones es vulnerable a un ataque en el que una invitaci\u00f3n creada en una organizaci\u00f3n (potencialmente como un rol con permisos elevados) puede ser usada para unirse a cualquier otra organizaci\u00f3n. Esto evita cualquier restricci\u00f3n de dominios requeridos en las direcciones de correo electr\u00f3nico de usuarios, puede ser usado para conseguir acceso a organizaciones a las que s\u00f3lo puede accederse por invitaci\u00f3n, y puede ser usado para conseguir acceso con altos privilegios. Este problema ha sido parcheado en versi\u00f3n 4.10. No se presentan medidas de mitigaci\u00f3n conocidas para este problema. ### Parches _\u00bfHa sido parcheado el problema? \u00bfA qu\u00e9 versiones deber\u00edan actualizarse los usuarios?_ ### Mitigaciones _\u00bfSe presenta alguna forma de que los usuarios mitiguen o remedien la vulnerabilidad sin necesidad de actualizarse?_## Referencias _\u00bfSe presenta alg\u00fan enlace que los usuarios puedan visitar para obtener m\u00e1s informaci\u00f3n?_## Para m\u00e1s informaci\u00f3n Si presenta alguna pregunta o comentario sobre este aviso, puede discutirlo en el [servidor de la comunidad de desarrolladores de Zulip](https://zulip.com/developer-community/), o enviar un correo electr\u00f3nico al [equipo de seguridad de Zulip](mailto:security@zulip.com).\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}, {"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "4.10.0", "matchCriteriaId": "F19BE7BB-39B8-41FE-A025-1D985BEF3B67"}]}]}], "references": [{"url": "https://blog.zulip.com/2022/02/25/zulip-cloud-invitation-vulnerability/", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://blog.zulip.com/2022/02/25/zulip-server-4-10-security-release/#cve-2022-21706", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/zulip/zulip/commit/88917019f03860609114082cdc0f31a561503f9e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-6xmj-2wcm-p2jc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/88917019f03860609114082cdc0f31a561503f9e"}}