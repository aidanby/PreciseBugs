{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <jsi/test/testlib.h>\n#include <gtest/gtest.h>\n#include <jsi/decorator.h>\n#include <jsi/jsi.h>\n\n#include <stdlib.h>\n#include <chrono>\n#include <functional>\n#include <thread>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace facebook::jsi;\n\nclass JSITest : public JSITestBase {};\n\nTEST_P(JSITest, RuntimeTest) {\n  auto v = rt.evaluateJavaScript(std::make_unique<StringBuffer>(\"1\"), \"\");\n  EXPECT_EQ(v.getNumber(), 1);\n\n  rt.evaluateJavaScript(std::make_unique<StringBuffer>(\"x = 1\"), \"\");\n  EXPECT_EQ(rt.global().getProperty(rt, \"x\").getNumber(), 1);\n}\n\nTEST_P(JSITest, PropNameIDTest) {\n  // This is a little weird to test, because it doesn't really exist\n  // in JS yet.  All I can do is create them, compare them, and\n  // receive one as an argument to a HostObject.\n\n  PropNameID quux = PropNameID::forAscii(rt, \"quux1\", 4);\n  PropNameID movedQuux = std::move(quux);\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux\");\n  movedQuux = PropNameID::forAscii(rt, \"quux2\");\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux2\");\n  PropNameID copiedQuux = PropNameID(rt, movedQuux);\n  EXPECT_TRUE(PropNameID::compare(rt, movedQuux, copiedQuux));\n\n  EXPECT_TRUE(PropNameID::compare(rt, movedQuux, movedQuux));\n  EXPECT_TRUE(PropNameID::compare(\n      rt, movedQuux, PropNameID::forAscii(rt, std::string(\"quux2\"))));\n  EXPECT_FALSE(PropNameID::compare(\n      rt, movedQuux, PropNameID::forAscii(rt, std::string(\"foo\"))));\n  uint8_t utf8[] = {0xF0, 0x9F, 0x86, 0x97};\n  PropNameID utf8PropNameID = PropNameID::forUtf8(rt, utf8, sizeof(utf8));\n  EXPECT_EQ(utf8PropNameID.utf8(rt), u8\"\\U0001F197\");\n  EXPECT_TRUE(PropNameID::compare(\n      rt, utf8PropNameID, PropNameID::forUtf8(rt, utf8, sizeof(utf8))));\n  PropNameID nonUtf8PropNameID = PropNameID::forUtf8(rt, \"meow\");\n  EXPECT_TRUE(PropNameID::compare(\n      rt, nonUtf8PropNameID, PropNameID::forAscii(rt, \"meow\")));\n  EXPECT_EQ(nonUtf8PropNameID.utf8(rt), \"meow\");\n  PropNameID strPropNameID =\n      PropNameID::forString(rt, String::createFromAscii(rt, \"meow\"));\n  EXPECT_TRUE(PropNameID::compare(rt, nonUtf8PropNameID, strPropNameID));\n\n  auto names = PropNameID::names(\n      rt, \"Ala\", std::string(\"ma\"), PropNameID::forAscii(rt, \"kota\"));\n  EXPECT_EQ(names.size(), 3);\n  EXPECT_TRUE(\n      PropNameID::compare(rt, names[0], PropNameID::forAscii(rt, \"Ala\")));\n  EXPECT_TRUE(\n      PropNameID::compare(rt, names[1], PropNameID::forAscii(rt, \"ma\")));\n  EXPECT_TRUE(\n      PropNameID::compare(rt, names[2], PropNameID::forAscii(rt, \"kota\")));\n}\n\nTEST_P(JSITest, StringTest) {\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, \"foobar\", 3), \"'foo'\"));\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, \"foobar\"), \"'foobar'\"));\n\n  std::string baz = \"baz\";\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, baz), \"'baz'\"));\n\n  uint8_t utf8[] = {0xF0, 0x9F, 0x86, 0x97};\n  EXPECT_TRUE(checkValue(\n      String::createFromUtf8(rt, utf8, sizeof(utf8)), \"'\\\\uD83C\\\\uDD97'\"));\n\n  EXPECT_EQ(eval(\"'quux'\").getString(rt).utf8(rt), \"quux\");\n  EXPECT_EQ(eval(\"'\\\\u20AC'\").getString(rt).utf8(rt), \"\\xe2\\x82\\xac\");\n\n  String quux = String::createFromAscii(rt, \"quux\");\n  String movedQuux = std::move(quux);\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux\");\n  movedQuux = String::createFromAscii(rt, \"quux2\");\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux2\");\n}\n\nTEST_P(JSITest, ObjectTest) {\n  eval(\"x = {1:2, '3':4, 5:'six', 'seven':['eight', 'nine']}\");\n  Object x = rt.global().getPropertyAsObject(rt, \"x\");\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 4);\n  EXPECT_TRUE(x.hasProperty(rt, \"1\"));\n  EXPECT_TRUE(x.hasProperty(rt, PropNameID::forAscii(rt, \"1\")));\n  EXPECT_FALSE(x.hasProperty(rt, \"2\"));\n  EXPECT_FALSE(x.hasProperty(rt, PropNameID::forAscii(rt, \"2\")));\n  EXPECT_TRUE(x.hasProperty(rt, \"3\"));\n  EXPECT_TRUE(x.hasProperty(rt, PropNameID::forAscii(rt, \"3\")));\n  EXPECT_TRUE(x.hasProperty(rt, \"seven\"));\n  EXPECT_TRUE(x.hasProperty(rt, PropNameID::forAscii(rt, \"seven\")));\n  EXPECT_EQ(x.getProperty(rt, \"1\").getNumber(), 2);\n  EXPECT_EQ(x.getProperty(rt, PropNameID::forAscii(rt, \"1\")).getNumber(), 2);\n  EXPECT_EQ(x.getProperty(rt, \"3\").getNumber(), 4);\n  Value five = 5;\n  EXPECT_EQ(\n      x.getProperty(rt, PropNameID::forString(rt, five.toString(rt)))\n          .getString(rt)\n          .utf8(rt),\n      \"six\");\n\n  x.setProperty(rt, \"ten\", 11);\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 5);\n  EXPECT_TRUE(eval(\"x.ten == 11\").getBool());\n\n  x.setProperty(rt, \"e_as_float\", 2.71f);\n  EXPECT_TRUE(eval(\"Math.abs(x.e_as_float - 2.71) < 0.001\").getBool());\n\n  x.setProperty(rt, \"e_as_double\", 2.71);\n  EXPECT_TRUE(eval(\"x.e_as_double == 2.71\").getBool());\n\n  uint8_t utf8[] = {0xF0, 0x9F, 0x86, 0x97};\n  String nonAsciiName = String::createFromUtf8(rt, utf8, sizeof(utf8));\n  x.setProperty(rt, PropNameID::forString(rt, nonAsciiName), \"emoji\");\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 8);\n  EXPECT_TRUE(eval(\"x['\\\\uD83C\\\\uDD97'] == 'emoji'\").getBool());\n\n  Object seven = x.getPropertyAsObject(rt, \"seven\");\n  EXPECT_TRUE(seven.isArray(rt));\n  Object evalf = rt.global().getPropertyAsObject(rt, \"eval\");\n  EXPECT_TRUE(evalf.isFunction(rt));\n\n  Object movedX = Object(rt);\n  movedX = std::move(x);\n  EXPECT_EQ(movedX.getPropertyNames(rt).size(rt), 8);\n  EXPECT_EQ(movedX.getProperty(rt, \"1\").getNumber(), 2);\n\n  Object obj = Object(rt);\n  obj.setProperty(rt, \"roses\", \"red\");\n  obj.setProperty(rt, \"violets\", \"blue\");\n  Object oprop = Object(rt);\n  obj.setProperty(rt, \"oprop\", oprop);\n  obj.setProperty(rt, \"aprop\", Array(rt, 1));\n\n  EXPECT_TRUE(function(\"function (obj) { return \"\n                       \"obj.roses == 'red' && \"\n                       \"obj['violets'] == 'blue' && \"\n                       \"typeof obj.oprop == 'object' && \"\n                       \"Array.isArray(obj.aprop); }\")\n                  .call(rt, obj)\n                  .getBool());\n\n  // Check that getPropertyNames doesn't return non-enumerable\n  // properties.\n  obj = function(\n            \"function () {\"\n            \"  obj = {};\"\n            \"  obj.a = 1;\"\n            \"  Object.defineProperty(obj, 'b', {\"\n            \"    enumerable: false,\"\n            \"    value: 2\"\n            \"  });\"\n            \"  return obj;\"\n            \"}\")\n            .call(rt)\n            .getObject(rt);\n  EXPECT_EQ(obj.getProperty(rt, \"a\").getNumber(), 1);\n  EXPECT_EQ(obj.getProperty(rt, \"b\").getNumber(), 2);\n  Array names = obj.getPropertyNames(rt);\n  EXPECT_EQ(names.size(rt), 1);\n  EXPECT_EQ(names.getValueAtIndex(rt, 0).getString(rt).utf8(rt), \"a\");\n}\n\nTEST_P(JSITest, HostObjectTest) {\n  class ConstantHostObject : public HostObject {\n    Value get(Runtime&, const PropNameID& sym) override {\n      return 9000;\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n\n  Object cho =\n      Object::createFromHostObject(rt, std::make_shared<ConstantHostObject>());\n  EXPECT_TRUE(function(\"function (obj) { return obj.someRandomProp == 9000; }\")\n                  .call(rt, cho)\n                  .getBool());\n  EXPECT_TRUE(cho.isHostObject(rt));\n  EXPECT_TRUE(cho.getHostObject<ConstantHostObject>(rt).get() != nullptr);\n\n  struct SameRuntimeHostObject : HostObject {\n    SameRuntimeHostObject(Runtime& rt) : rt_(rt){};\n\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      EXPECT_EQ(&rt, &rt_);\n      return Value();\n    }\n\n    void set(Runtime& rt, const PropNameID& name, const Value& value) override {\n      EXPECT_EQ(&rt, &rt_);\n    }\n\n    std::vector<PropNameID> getPropertyNames(Runtime& rt) override {\n      EXPECT_EQ(&rt, &rt_);\n      return {};\n    }\n\n    Runtime& rt_;\n  };\n\n  Object srho = Object::createFromHostObject(\n      rt, std::make_shared<SameRuntimeHostObject>(rt));\n  // Test get's Runtime is as expected\n  function(\"function (obj) { return obj.isSame; }\").call(rt, srho);\n  // ... and set\n  function(\"function (obj) { obj['k'] = 'v'; }\").call(rt, srho);\n  // ... and getPropertyNames\n  function(\"function (obj) { for (k in obj) {} }\").call(rt, srho);\n\n  class TwiceHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      return String::createFromUtf8(rt, sym.utf8(rt) + sym.utf8(rt));\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n\n  Object tho =\n      Object::createFromHostObject(rt, std::make_shared<TwiceHostObject>());\n  EXPECT_TRUE(function(\"function (obj) { return obj.abc == 'abcabc'; }\")\n                  .call(rt, tho)\n                  .getBool());\n  EXPECT_TRUE(function(\"function (obj) { return obj['def'] == 'defdef'; }\")\n                  .call(rt, tho)\n                  .getBool());\n  EXPECT_TRUE(function(\"function (obj) { return obj[12] === '1212'; }\")\n                  .call(rt, tho)\n                  .getBool());\n  EXPECT_TRUE(tho.isHostObject(rt));\n  EXPECT_TRUE(\n      std::dynamic_pointer_cast<ConstantHostObject>(tho.getHostObject(rt)) ==\n      nullptr);\n  EXPECT_TRUE(tho.getHostObject<TwiceHostObject>(rt).get() != nullptr);\n\n  class PropNameIDHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      if (PropNameID::compare(rt, sym, PropNameID::forAscii(rt, \"undef\"))) {\n        return Value::undefined();\n      } else {\n        return PropNameID::compare(\n            rt, sym, PropNameID::forAscii(rt, \"somesymbol\"));\n      }\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n\n  Object sho = Object::createFromHostObject(\n      rt, std::make_shared<PropNameIDHostObject>());\n  EXPECT_TRUE(sho.isHostObject(rt));\n  EXPECT_TRUE(function(\"function (obj) { return obj.undef; }\")\n                  .call(rt, sho)\n                  .isUndefined());\n  EXPECT_TRUE(function(\"function (obj) { return obj.somesymbol; }\")\n                  .call(rt, sho)\n                  .getBool());\n  EXPECT_FALSE(function(\"function (obj) { return obj.notsomuch; }\")\n                   .call(rt, sho)\n                   .getBool());\n\n  class BagHostObject : public HostObject {\n   public:\n    const std::string& getThing() {\n      return bag_[\"thing\"];\n    }\n\n   private:\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      if (sym.utf8(rt) == \"thing\") {\n        return String::createFromUtf8(rt, bag_[sym.utf8(rt)]);\n      }\n      return Value::undefined();\n    }\n\n    void set(Runtime& rt, const PropNameID& sym, const Value& val) override {\n      std::string key(sym.utf8(rt));\n      if (key == \"thing\") {\n        bag_[key] = val.toString(rt).utf8(rt);\n      }\n    }\n\n    std::unordered_map<std::string, std::string> bag_;\n  };\n\n  std::shared_ptr<BagHostObject> shbho = std::make_shared<BagHostObject>();\n  Object bho = Object::createFromHostObject(rt, shbho);\n  EXPECT_TRUE(bho.isHostObject(rt));\n  EXPECT_TRUE(function(\"function (obj) { return obj.undef; }\")\n                  .call(rt, bho)\n                  .isUndefined());\n  EXPECT_EQ(\n      function(\"function (obj) { obj.thing = 'hello'; return obj.thing; }\")\n          .call(rt, bho)\n          .toString(rt)\n          .utf8(rt),\n      \"hello\");\n  EXPECT_EQ(shbho->getThing(), \"hello\");\n\n  class ThrowingHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      throw std::runtime_error(\"Cannot get\");\n    }\n\n    void set(Runtime& rt, const PropNameID& sym, const Value& val) override {\n      throw std::runtime_error(\"Cannot set\");\n    }\n  };\n\n  Object thro =\n      Object::createFromHostObject(rt, std::make_shared<ThrowingHostObject>());\n  EXPECT_TRUE(thro.isHostObject(rt));\n  std::string exc;\n  try {\n    function(\"function (obj) { return obj.thing; }\").call(rt, thro);\n  } catch (const JSError& ex) {\n    exc = ex.what();\n  }\n  EXPECT_NE(exc.find(\"Cannot get\"), std::string::npos);\n  exc = \"\";\n  try {\n    function(\"function (obj) { obj.thing = 'hello'; }\").call(rt, thro);\n  } catch (const JSError& ex) {\n    exc = ex.what();\n  }\n  EXPECT_NE(exc.find(\"Cannot set\"), std::string::npos);\n\n  class NopHostObject : public HostObject {};\n  Object nopHo =\n      Object::createFromHostObject(rt, std::make_shared<NopHostObject>());\n  EXPECT_TRUE(nopHo.isHostObject(rt));\n  EXPECT_TRUE(function(\"function (obj) { return obj.thing; }\")\n                  .call(rt, nopHo)\n                  .isUndefined());\n\n  std::string nopExc;\n  try {\n    function(\"function (obj) { obj.thing = 'pika'; }\").call(rt, nopHo);\n  } catch (const JSError& ex) {\n    nopExc = ex.what();\n  }\n  EXPECT_NE(nopExc.find(\"TypeError: \"), std::string::npos);\n\n  class HostObjectWithPropertyNames : public HostObject {\n    std::vector<PropNameID> getPropertyNames(Runtime& rt) override {\n      return PropNameID::names(\n          rt, \"a_prop\", \"1\", \"false\", \"a_prop\", \"3\", \"c_prop\");\n    }\n  };\n\n  Object howpn = Object::createFromHostObject(\n      rt, std::make_shared<HostObjectWithPropertyNames>());\n  EXPECT_TRUE(\n      function(\n          \"function (o) { return Object.getOwnPropertyNames(o).length == 5 }\")\n          .call(rt, howpn)\n          .getBool());\n\n  auto hasOwnPropertyName = function(\n      \"function (o, p) {\"\n      \"  return Object.getOwnPropertyNames(o).indexOf(p) >= 0\"\n      \"}\");\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"a_prop\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"1\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"false\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"3\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"c_prop\"))\n          .getBool());\n  EXPECT_FALSE(hasOwnPropertyName\n                   .call(rt, howpn, String::createFromAscii(rt, \"not_existing\"))\n                   .getBool());\n}\n\nTEST_P(JSITest, ArrayTest) {\n  eval(\"x = {1:2, '3':4, 5:'six', 'seven':['eight', 'nine']}\");\n\n  Object x = rt.global().getPropertyAsObject(rt, \"x\");\n  Array names = x.getPropertyNames(rt);\n  EXPECT_EQ(names.size(rt), 4);\n  std::unordered_set<std::string> strNames;\n  for (size_t i = 0; i < names.size(rt); ++i) {\n    Value n = names.getValueAtIndex(rt, i);\n    EXPECT_TRUE(n.isString());\n    strNames.insert(n.getString(rt).utf8(rt));\n  }\n\n  EXPECT_EQ(strNames.size(), 4);\n  EXPECT_EQ(strNames.count(\"1\"), 1);\n  EXPECT_EQ(strNames.count(\"3\"), 1);\n  EXPECT_EQ(strNames.count(\"5\"), 1);\n  EXPECT_EQ(strNames.count(\"seven\"), 1);\n\n  Object seven = x.getPropertyAsObject(rt, \"seven\");\n  Array arr = seven.getArray(rt);\n\n  EXPECT_EQ(arr.size(rt), 2);\n  EXPECT_EQ(arr.getValueAtIndex(rt, 0).getString(rt).utf8(rt), \"eight\");\n  EXPECT_EQ(arr.getValueAtIndex(rt, 1).getString(rt).utf8(rt), \"nine\");\n  // TODO: test out of range\n\n  EXPECT_EQ(x.getPropertyAsObject(rt, \"seven\").getArray(rt).size(rt), 2);\n\n  // Check that property access with both symbols and strings can access\n  // array values.\n  EXPECT_EQ(seven.getProperty(rt, \"0\").getString(rt).utf8(rt), \"eight\");\n  EXPECT_EQ(seven.getProperty(rt, \"1\").getString(rt).utf8(rt), \"nine\");\n  seven.setProperty(rt, \"1\", \"modified\");\n  EXPECT_EQ(seven.getProperty(rt, \"1\").getString(rt).utf8(rt), \"modified\");\n  EXPECT_EQ(arr.getValueAtIndex(rt, 1).getString(rt).utf8(rt), \"modified\");\n  EXPECT_EQ(\n      seven.getProperty(rt, PropNameID::forAscii(rt, \"0\"))\n          .getString(rt)\n          .utf8(rt),\n      \"eight\");\n  seven.setProperty(rt, PropNameID::forAscii(rt, \"0\"), \"modified2\");\n  EXPECT_EQ(arr.getValueAtIndex(rt, 0).getString(rt).utf8(rt), \"modified2\");\n\n  Array alpha = Array(rt, 4);\n  EXPECT_TRUE(alpha.getValueAtIndex(rt, 0).isUndefined());\n  EXPECT_TRUE(alpha.getValueAtIndex(rt, 3).isUndefined());\n  EXPECT_EQ(alpha.size(rt), 4);\n  alpha.setValueAtIndex(rt, 0, \"a\");\n  alpha.setValueAtIndex(rt, 1, \"b\");\n  EXPECT_EQ(alpha.length(rt), 4);\n  alpha.setValueAtIndex(rt, 2, \"c\");\n  alpha.setValueAtIndex(rt, 3, \"d\");\n  EXPECT_EQ(alpha.size(rt), 4);\n\n  EXPECT_TRUE(\n      function(\n          \"function (arr) { return \"\n          \"arr.length == 4 && \"\n          \"['a','b','c','d'].every(function(v,i) { return v === arr[i]}); }\")\n          .call(rt, alpha)\n          .getBool());\n\n  Array alpha2 = Array(rt, 1);\n  alpha2 = std::move(alpha);\n  EXPECT_EQ(alpha2.size(rt), 4);\n}\n\nTEST_P(JSITest, FunctionTest) {\n  // test move ctor\n  Function fmove = function(\"function() { return 1 }\");\n  {\n    Function g = function(\"function() { return 2 }\");\n    fmove = std::move(g);\n  }\n  EXPECT_EQ(fmove.call(rt).getNumber(), 2);\n\n  // This tests all the function argument converters, and all the\n  // non-lvalue overloads of call().\n  Function f = function(\n      \"function(n, b, d, df, i, s1, s2, s3, s_sun, s_bad, o, a, f, v) { \"\n      \"return \"\n      \"n === null && \"\n      \"b === true && \"\n      \"d === 3.14 && \"\n      \"Math.abs(df - 2.71) < 0.001 && \"\n      \"i === 17 && \"\n      \"s1 == 's1' && \"\n      \"s2 == 's2' && \"\n      \"s3 == 's3' && \"\n      \"s_sun == 's\\\\u2600' && \"\n      \"typeof s_bad == 'string' && \"\n      \"typeof o == 'object' && \"\n      \"Array.isArray(a) && \"\n      \"typeof f == 'function' && \"\n      \"v == 42 }\");\n  EXPECT_TRUE(f.call(\n                   rt,\n                   nullptr,\n                   true,\n                   3.14,\n                   2.71f,\n                   17,\n                   \"s1\",\n                   String::createFromAscii(rt, \"s2\"),\n                   std::string{\"s3\"},\n                   std::string{u8\"s\\u2600\"},\n                   // invalid UTF8 sequence due to unexpected continuation byte\n                   std::string{\"s\\x80\"},\n                   Object(rt),\n                   Array(rt, 1),\n                   function(\"function(){}\"),\n                   Value(42))\n                  .getBool());\n\n  // lvalue overloads of call()\n  Function flv = function(\n      \"function(s, o, a, f, v) { return \"\n      \"s == 's' && \"\n      \"typeof o == 'object' && \"\n      \"Array.isArray(a) && \"\n      \"typeof f == 'function' && \"\n      \"v == 42 }\");\n\n  String s = String::createFromAscii(rt, \"s\");\n  Object o = Object(rt);\n  Array a = Array(rt, 1);\n  Value v = 42;\n  EXPECT_TRUE(flv.call(rt, s, o, a, f, v).getBool());\n\n  Function f1 = function(\"function() { return 1; }\");\n  Function f2 = function(\"function() { return 2; }\");\n  f2 = std::move(f1);\n  EXPECT_EQ(f2.call(rt).getNumber(), 1);\n}\n\nTEST_P(JSITest, FunctionThisTest) {\n  Function checkPropertyFunction =\n      function(\"function() { return this.a === 'a_property' }\");\n\n  Object jsObject = Object(rt);\n  jsObject.setProperty(rt, \"a\", String::createFromUtf8(rt, \"a_property\"));\n\n  class APropertyHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      return String::createFromUtf8(rt, \"a_property\");\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n  Object hostObject =\n      Object::createFromHostObject(rt, std::make_shared<APropertyHostObject>());\n\n  EXPECT_TRUE(checkPropertyFunction.callWithThis(rt, jsObject).getBool());\n  EXPECT_TRUE(checkPropertyFunction.callWithThis(rt, hostObject).getBool());\n  EXPECT_FALSE(checkPropertyFunction.callWithThis(rt, Array(rt, 5)).getBool());\n  EXPECT_FALSE(checkPropertyFunction.call(rt).getBool());\n}\n\nTEST_P(JSITest, FunctionConstructorTest) {\n  Function ctor = function(\n      \"function (a) {\"\n      \"  if (typeof a !== 'undefined') {\"\n      \"   this.pika = a;\"\n      \"  }\"\n      \"}\");\n  ctor.getProperty(rt, \"prototype\")\n      .getObject(rt)\n      .setProperty(rt, \"pika\", \"chu\");\n  auto empty = ctor.callAsConstructor(rt);\n  EXPECT_TRUE(empty.isObject());\n  auto emptyObj = std::move(empty).getObject(rt);\n  EXPECT_EQ(emptyObj.getProperty(rt, \"pika\").getString(rt).utf8(rt), \"chu\");\n  auto who = ctor.callAsConstructor(rt, \"who\");\n  EXPECT_TRUE(who.isObject());\n  auto whoObj = std::move(who).getObject(rt);\n  EXPECT_EQ(whoObj.getProperty(rt, \"pika\").getString(rt).utf8(rt), \"who\");\n\n  auto instanceof = function(\"function (o, b) { return o instanceof b; }\");\n  EXPECT_TRUE(instanceof.call(rt, emptyObj, ctor).getBool());\n  EXPECT_TRUE(instanceof.call(rt, whoObj, ctor).getBool());\n\n  auto dateCtor = rt.global().getPropertyAsFunction(rt, \"Date\");\n  auto date = dateCtor.callAsConstructor(rt);\n  EXPECT_TRUE(date.isObject());\n  EXPECT_TRUE(instanceof.call(rt, date, dateCtor).getBool());\n  // Sleep for 50 milliseconds\n  std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  EXPECT_GE(\n      function(\"function (d) { return (new Date()).getTime() - d.getTime(); }\")\n          .call(rt, date)\n          .getNumber(),\n      50);\n}\n\nTEST_P(JSITest, InstanceOfTest) {\n  auto ctor = function(\"function Rick() { this.say = 'wubalubadubdub'; }\");\n  auto newObj = function(\"function (ctor) { return new ctor(); }\");\n  auto instance = newObj.call(rt, ctor).getObject(rt);\n  EXPECT_TRUE(instance.instanceOf(rt, ctor));\n  EXPECT_EQ(\n      instance.getProperty(rt, \"say\").getString(rt).utf8(rt), \"wubalubadubdub\");\n  EXPECT_FALSE(Object(rt).instanceOf(rt, ctor));\n  EXPECT_TRUE(ctor.callAsConstructor(rt, nullptr, 0)\n                  .getObject(rt)\n                  .instanceOf(rt, ctor));\n}\n\nTEST_P(JSITest, HostFunctionTest) {\n  auto one = std::make_shared<int>(1);\n  Function plusOne = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"plusOne\"),\n      2,\n      [one, savedRt = &rt](\n          Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        EXPECT_EQ(savedRt, &rt);\n        // We don't know if we're in strict mode or not, so it's either global\n        // or undefined.\n        EXPECT_TRUE(\n            Value::strictEquals(rt, thisVal, rt.global()) ||\n            thisVal.isUndefined());\n        return *one + args[0].getNumber() + args[1].getNumber();\n      });\n\n  EXPECT_EQ(plusOne.call(rt, 1, 2).getNumber(), 4);\n  EXPECT_TRUE(checkValue(plusOne.call(rt, 3, 5), \"9\"));\n  rt.global().setProperty(rt, \"plusOne\", plusOne);\n  EXPECT_TRUE(eval(\"plusOne(20, 300) == 321\").getBool());\n\n  Function dot = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"dot\"),\n      2,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        EXPECT_TRUE(\n            Value::strictEquals(rt, thisVal, rt.global()) ||\n            thisVal.isUndefined());\n        if (count != 2) {\n          throw std::runtime_error(\"expected 2 args\");\n        }\n        std::string ret = args[0].getString(rt).utf8(rt) + \".\" +\n            args[1].getString(rt).utf8(rt);\n        return String::createFromUtf8(\n            rt, reinterpret_cast<const uint8_t*>(ret.data()), ret.size());\n      });\n\n  rt.global().setProperty(rt, \"cons\", dot);\n  EXPECT_TRUE(eval(\"cons('left', 'right') == 'left.right'\").getBool());\n  EXPECT_TRUE(eval(\"cons.name == 'dot'\").getBool());\n  EXPECT_TRUE(eval(\"cons.length == 2\").getBool());\n  EXPECT_TRUE(eval(\"cons instanceof Function\").getBool());\n\n  EXPECT_TRUE(eval(\"(function() {\"\n                   \"  try {\"\n                   \"    cons('fail'); return false;\"\n                   \"  } catch (e) {\"\n                   \"    return ((e instanceof Error) &&\"\n                   \"            (e.message == 'Exception in HostFunction: ' +\"\n                   \"                          'expected 2 args'));\"\n                   \"  }})()\")\n                  .getBool());\n\n  Function coolify = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"coolify\"),\n      0,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        EXPECT_EQ(count, 0);\n        std::string ret = thisVal.toString(rt).utf8(rt) + \" is cool\";\n        return String::createFromUtf8(\n            rt, reinterpret_cast<const uint8_t*>(ret.data()), ret.size());\n      });\n  rt.global().setProperty(rt, \"coolify\", coolify);\n  EXPECT_TRUE(eval(\"coolify.name == 'coolify'\").getBool());\n  EXPECT_TRUE(eval(\"coolify.length == 0\").getBool());\n  EXPECT_TRUE(eval(\"coolify.bind('R&M')() == 'R&M is cool'\").getBool());\n  EXPECT_TRUE(eval(\"(function() {\"\n                   \"  var s = coolify.bind(function(){})();\"\n                   \"  return s.lastIndexOf(' is cool') == (s.length - 8);\"\n                   \"})()\")\n                  .getBool());\n\n  Function lookAtMe = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"lookAtMe\"),\n      0,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count)\n          -> Value {\n        EXPECT_TRUE(thisVal.isObject());\n        EXPECT_EQ(\n            thisVal.getObject(rt)\n                .getProperty(rt, \"name\")\n                .getString(rt)\n                .utf8(rt),\n            \"mr.meeseeks\");\n        return Value();\n      });\n  rt.global().setProperty(rt, \"lookAtMe\", lookAtMe);\n  EXPECT_TRUE(eval(\"lookAtMe.bind({'name': 'mr.meeseeks'})()\").isUndefined());\n\n  struct Callable {\n    Callable(std::string s) : str(s) {}\n\n    Value\n    operator()(Runtime& rt, const Value&, const Value* args, size_t count) {\n      if (count != 1) {\n        return Value();\n      }\n      return String::createFromUtf8(\n          rt, args[0].toString(rt).utf8(rt) + \" was called with \" + str);\n    }\n\n    std::string str;\n  };\n\n  Function callable = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"callable\"),\n      1,\n      Callable(\"std::function::target\"));\n  EXPECT_EQ(\n      function(\"function (f) { return f('A cat'); }\")\n          .call(rt, callable)\n          .getString(rt)\n          .utf8(rt),\n      \"A cat was called with std::function::target\");\n  EXPECT_TRUE(callable.isHostFunction(rt));\n  EXPECT_NE(callable.getHostFunction(rt).target<Callable>(), nullptr);\n\n  std::string strval = \"strval1\";\n  auto getter = Object(rt);\n  getter.setProperty(\n      rt,\n      \"get\",\n      Function::createFromHostFunction(\n          rt,\n          PropNameID::forAscii(rt, \"getter\"),\n          1,\n          [&strval](\n              Runtime& rt,\n              const Value& thisVal,\n              const Value* args,\n              size_t count) -> Value {\n            return String::createFromUtf8(rt, strval);\n          }));\n  auto obj = Object(rt);\n  rt.global()\n      .getPropertyAsObject(rt, \"Object\")\n      .getPropertyAsFunction(rt, \"defineProperty\")\n      .call(rt, obj, \"prop\", getter);\n  EXPECT_TRUE(function(\"function(value) { return value.prop == 'strval1'; }\")\n                  .call(rt, obj)\n                  .getBool());\n  strval = \"strval2\";\n  EXPECT_TRUE(function(\"function(value) { return value.prop == 'strval2'; }\")\n                  .call(rt, obj)\n                  .getBool());\n}\n\nTEST_P(JSITest, ValueTest) {\n  EXPECT_TRUE(checkValue(Value::undefined(), \"undefined\"));\n  EXPECT_TRUE(checkValue(Value(), \"undefined\"));\n  EXPECT_TRUE(checkValue(Value::null(), \"null\"));\n  EXPECT_TRUE(checkValue(nullptr, \"null\"));\n\n  EXPECT_TRUE(checkValue(Value(false), \"false\"));\n  EXPECT_TRUE(checkValue(false, \"false\"));\n  EXPECT_TRUE(checkValue(true, \"true\"));\n\n  EXPECT_TRUE(checkValue(Value(1.5), \"1.5\"));\n  EXPECT_TRUE(checkValue(2.5, \"2.5\"));\n\n  EXPECT_TRUE(checkValue(Value(10), \"10\"));\n  EXPECT_TRUE(checkValue(20, \"20\"));\n  EXPECT_TRUE(checkValue(30, \"30\"));\n\n  // rvalue implicit conversion\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, \"one\"), \"'one'\"));\n  // lvalue explicit copy\n  String s = String::createFromAscii(rt, \"two\");\n  EXPECT_TRUE(checkValue(Value(rt, s), \"'two'\"));\n\n  {\n    // rvalue assignment of trivial value\n    Value v1 = 100;\n    Value v2 = String::createFromAscii(rt, \"hundred\");\n    v2 = std::move(v1);\n    EXPECT_TRUE(v2.isNumber());\n    EXPECT_EQ(v2.getNumber(), 100);\n  }\n\n  {\n    // rvalue assignment of js heap value\n    Value v1 = String::createFromAscii(rt, \"hundred\");\n    Value v2 = 100;\n    v2 = std::move(v1);\n    EXPECT_TRUE(v2.isString());\n    EXPECT_EQ(v2.getString(rt).utf8(rt), \"hundred\");\n  }\n\n  Object o = Object(rt);\n  EXPECT_TRUE(function(\"function(value) { return typeof(value) == 'object'; }\")\n                  .call(rt, Value(rt, o))\n                  .getBool());\n\n  uint8_t utf8[] = \"[null, 2, \\\"c\\\", \\\"emoji: \\xf0\\x9f\\x86\\x97\\\", {}]\";\n\n  EXPECT_TRUE(\n      function(\"function (arr) { return \"\n               \"Array.isArray(arr) && \"\n               \"arr.length == 5 && \"\n               \"arr[0] === null && \"\n               \"arr[1] == 2 && \"\n               \"arr[2] == 'c' && \"\n               \"arr[3] == 'emoji: \\\\uD83C\\\\uDD97' && \"\n               \"typeof arr[4] == 'object'; }\")\n          .call(rt, Value::createFromJsonUtf8(rt, utf8, sizeof(utf8) - 1))\n          .getBool());\n\n  EXPECT_TRUE(eval(\"undefined\").isUndefined());\n  EXPECT_TRUE(eval(\"null\").isNull());\n  EXPECT_TRUE(eval(\"true\").isBool());\n  EXPECT_TRUE(eval(\"false\").isBool());\n  EXPECT_TRUE(eval(\"123\").isNumber());\n  EXPECT_TRUE(eval(\"123.4\").isNumber());\n  EXPECT_TRUE(eval(\"'str'\").isString());\n  // \"{}\" returns undefined.  empty code block?\n  EXPECT_TRUE(eval(\"({})\").isObject());\n  EXPECT_TRUE(eval(\"[]\").isObject());\n  EXPECT_TRUE(eval(\"(function(){})\").isObject());\n\n  EXPECT_EQ(eval(\"123\").getNumber(), 123);\n  EXPECT_EQ(eval(\"123.4\").getNumber(), 123.4);\n  EXPECT_EQ(eval(\"'str'\").getString(rt).utf8(rt), \"str\");\n  EXPECT_TRUE(eval(\"[]\").getObject(rt).isArray(rt));\n\n  EXPECT_EQ(eval(\"456\").asNumber(), 456);\n  EXPECT_THROW(eval(\"'word'\").asNumber(), JSIException);\n  EXPECT_EQ(\n      eval(\"({1:2, 3:4})\").asObject(rt).getProperty(rt, \"1\").getNumber(), 2);\n  EXPECT_THROW(eval(\"'oops'\").asObject(rt), JSIException);\n\n  EXPECT_EQ(eval(\"['zero',1,2,3]\").toString(rt).utf8(rt), \"zero,1,2,3\");\n}\n\nTEST_P(JSITest, EqualsTest) {\n  EXPECT_TRUE(Object::strictEquals(rt, rt.global(), rt.global()));\n  EXPECT_TRUE(Value::strictEquals(rt, 1, 1));\n  EXPECT_FALSE(Value::strictEquals(rt, true, 1));\n  EXPECT_FALSE(Value::strictEquals(rt, true, false));\n  EXPECT_TRUE(Value::strictEquals(rt, false, false));\n  EXPECT_FALSE(Value::strictEquals(rt, nullptr, 1));\n  EXPECT_TRUE(Value::strictEquals(rt, nullptr, nullptr));\n  EXPECT_TRUE(Value::strictEquals(rt, Value::undefined(), Value()));\n  EXPECT_TRUE(Value::strictEquals(rt, rt.global(), Value(rt.global())));\n  EXPECT_FALSE(Value::strictEquals(\n      rt,\n      std::numeric_limits<double>::quiet_NaN(),\n      std::numeric_limits<double>::quiet_NaN()));\n  EXPECT_FALSE(Value::strictEquals(\n      rt,\n      std::numeric_limits<double>::signaling_NaN(),\n      std::numeric_limits<double>::signaling_NaN()));\n  EXPECT_TRUE(Value::strictEquals(rt, +0.0, -0.0));\n  EXPECT_TRUE(Value::strictEquals(rt, -0.0, +0.0));\n\n  Function noop = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"noop\"),\n      0,\n      [](const Runtime&, const Value&, const Value*, size_t) {\n        return Value();\n      });\n  auto noopDup = Value(rt, noop).getObject(rt);\n  EXPECT_TRUE(Object::strictEquals(rt, noop, noopDup));\n  EXPECT_TRUE(Object::strictEquals(rt, noopDup, noop));\n  EXPECT_FALSE(Object::strictEquals(rt, noop, rt.global()));\n  EXPECT_TRUE(Object::strictEquals(rt, noop, noop));\n  EXPECT_TRUE(Value::strictEquals(rt, Value(rt, noop), Value(rt, noop)));\n\n  String str = String::createFromAscii(rt, \"rick\");\n  String strDup = String::createFromAscii(rt, \"rick\");\n  String otherStr = String::createFromAscii(rt, \"morty\");\n  EXPECT_TRUE(String::strictEquals(rt, str, str));\n  EXPECT_TRUE(String::strictEquals(rt, str, strDup));\n  EXPECT_TRUE(String::strictEquals(rt, strDup, str));\n  EXPECT_FALSE(String::strictEquals(rt, str, otherStr));\n  EXPECT_TRUE(Value::strictEquals(rt, Value(rt, str), Value(rt, str)));\n  EXPECT_FALSE(Value::strictEquals(rt, Value(rt, str), Value(rt, noop)));\n  EXPECT_FALSE(Value::strictEquals(rt, Value(rt, str), 1.0));\n}\n\nTEST_P(JSITest, ExceptionStackTraceTest) {\n  static const char invokeUndefinedScript[] =\n      \"function hello() {\"\n      \"  var a = {}; a.log(); }\"\n      \"function world() { hello(); }\"\n      \"world()\";\n  std::string stack;\n  try {\n    rt.evaluateJavaScript(\n        std::make_unique<StringBuffer>(invokeUndefinedScript), \"\");\n  } catch (JSError& e) {\n    stack = e.getStack();\n  }\n  EXPECT_NE(stack.find(\"world\"), std::string::npos);\n}\n\nTEST_P(JSITest, PreparedJavaScriptSourceTest) {\n  rt.evaluateJavaScript(std::make_unique<StringBuffer>(\"var q = 0;\"), \"\");\n  auto prep = rt.prepareJavaScript(std::make_unique<StringBuffer>(\"q++;\"), \"\");\n  EXPECT_EQ(rt.global().getProperty(rt, \"q\").getNumber(), 0);\n  rt.evaluatePreparedJavaScript(prep);\n  EXPECT_EQ(rt.global().getProperty(rt, \"q\").getNumber(), 1);\n  rt.evaluatePreparedJavaScript(prep);\n  EXPECT_EQ(rt.global().getProperty(rt, \"q\").getNumber(), 2);\n}\n\nTEST_P(JSITest, PreparedJavaScriptURLInBacktrace) {\n  std::string sourceURL = \"//PreparedJavaScriptURLInBacktrace/Test/URL\";\n  std::string throwingSource =\n      \"function thrower() { throw new Error('oops')}\"\n      \"thrower();\";\n  auto prep = rt.prepareJavaScript(\n      std::make_unique<StringBuffer>(throwingSource), sourceURL);\n  try {\n    rt.evaluatePreparedJavaScript(prep);\n    FAIL() << \"prepareJavaScript should have thrown an exception\";\n  } catch (facebook::jsi::JSError err) {\n    EXPECT_NE(std::string::npos, err.getStack().find(sourceURL))\n        << \"Backtrace should contain source URL\";\n  }\n}\n\nnamespace {\n\nunsigned countOccurences(const std::string& of, const std::string& in) {\n  unsigned occurences = 0;\n  std::string::size_type lastOccurence = -1;\n  while ((lastOccurence = in.find(of, lastOccurence + 1)) !=\n         std::string::npos) {\n    occurences++;\n  }\n  return occurences;\n}\n\n} // namespace\n\nTEST_P(JSITest, JSErrorsArePropagatedNicely) {\n  unsigned callsBeforeError = 5;\n\n  Function sometimesThrows = function(\n      \"function sometimesThrows(shouldThrow, callback) {\"\n      \"  if (shouldThrow) {\"\n      \"    throw Error('Omg, what a nasty exception')\"\n      \"  }\"\n      \"  callback(callback);\"\n      \"}\");\n\n  Function callback = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"callback\"),\n      0,\n      [&sometimesThrows, &callsBeforeError](\n          Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        return sometimesThrows.call(rt, --callsBeforeError == 0, args[0]);\n      });\n\n  try {\n    sometimesThrows.call(rt, false, callback);\n  } catch (JSError& error) {\n    EXPECT_EQ(error.getMessage(), \"Omg, what a nasty exception\");\n    EXPECT_EQ(countOccurences(\"sometimesThrows\", error.getStack()), 6);\n\n    // system JSC JSI does not implement host function names\n    // EXPECT_EQ(countOccurences(\"callback\", error.getStack(rt)), 5);\n  }\n}\n\nTEST_P(JSITest, JSErrorsCanBeConstructedWithStack) {\n  auto err = JSError(rt, \"message\", \"stack\");\n  EXPECT_EQ(err.getMessage(), \"message\");\n  EXPECT_EQ(err.getStack(), \"stack\");\n}\n\nTEST_P(JSITest, JSErrorDoesNotInfinitelyRecurse) {\n  Value globalError = rt.global().getProperty(rt, \"Error\");\n  rt.global().setProperty(rt, \"Error\", Value::undefined());\n  try {\n    rt.global().getPropertyAsFunction(rt, \"NotAFunction\");\n    FAIL() << \"expected exception\";\n  } catch (const JSError& ex) {\n    EXPECT_EQ(\n        ex.getMessage(),\n        \"callGlobalFunction: JS global property 'Error' is undefined, \"\n        \"expected a Function (while raising getPropertyAsObject: \"\n        \"property 'NotAFunction' is undefined, expected an Object)\");\n  }\n\n  // If Error is missing, this is fundamentally a problem with JS code\n  // messing up the global object, so it should present in JS code as\n  // a catchable string.  Not an Error (because that's broken), or as\n  // a C++ failure.\n\n  auto fails = [](Runtime& rt, const Value&, const Value*, size_t) -> Value {\n    return rt.global().getPropertyAsObject(rt, \"NotAProperty\");\n  };\n  EXPECT_EQ(\n      function(\"function (f) { try { f(); return 'undefined'; }\"\n               \"catch (e) { return typeof e; } }\")\n          .call(\n              rt,\n              Function::createFromHostFunction(\n                  rt, PropNameID::forAscii(rt, \"fails\"), 0, fails))\n          .getString(rt)\n          .utf8(rt),\n      \"string\");\n\n  rt.global().setProperty(rt, \"Error\", globalError);\n}\n\nTEST_P(JSITest, JSErrorStackOverflowHandling) {\n  rt.global().setProperty(\n      rt,\n      \"callSomething\",\n      Function::createFromHostFunction(\n          rt,\n          PropNameID::forAscii(rt, \"callSomething\"),\n          0,\n          [this](\n              Runtime& rt2,\n              const Value& thisVal,\n              const Value* args,\n              size_t count) {\n            EXPECT_EQ(&rt, &rt2);\n            return function(\"function() { return 0; }\").call(rt);\n          }));\n  try {\n    eval(\"(function f() { callSomething(); f.apply(); })()\");\n    FAIL();\n  } catch (const JSError& ex) {\n    EXPECT_NE(std::string(ex.what()).find(\"exceeded\"), std::string::npos);\n  }\n}\n\nTEST_P(JSITest, ScopeDoesNotCrashTest) {\n  Scope scope(rt);\n  Object o(rt);\n}\n\nTEST_P(JSITest, ScopeDoesNotCrashWhenValueEscapes) {\n  Value v;\n  Scope::callInNewScope(rt, [&]() {\n    Object o(rt);\n    o.setProperty(rt, \"a\", 5);\n    v = std::move(o);\n  });\n  EXPECT_EQ(v.getObject(rt).getProperty(rt, \"a\").getNumber(), 5);\n}\n\n// Verifies you can have a host object that emulates a normal object\nTEST_P(JSITest, HostObjectWithValueMembers) {\n  class Bag : public HostObject {\n   public:\n    Bag() = default;\n\n    const Value& operator[](const std::string& name) const {\n      auto iter = data_.find(name);\n      if (iter == data_.end()) {\n        return undef_;\n      }\n      return iter->second;\n    }\n\n   protected:\n    Value get(Runtime& rt, const PropNameID& name) override {\n      return Value(rt, (*this)[name.utf8(rt)]);\n    }\n\n    void set(Runtime& rt, const PropNameID& name, const Value& val) override {\n      data_.emplace(name.utf8(rt), Value(rt, val));\n    }\n\n    Value undef_;\n    std::map<std::string, Value> data_;\n  };\n\n  auto sharedBag = std::make_shared<Bag>();\n  auto& bag = *sharedBag;\n  Object jsbag = Object::createFromHostObject(rt, std::move(sharedBag));\n  auto set = function(\n      \"function (o) {\"\n      \"  o.foo = 'bar';\"\n      \"  o.count = 37;\"\n      \"  o.nul = null;\"\n      \"  o.iscool = true;\"\n      \"  o.obj = { 'foo': 'bar' };\"\n      \"}\");\n  set.call(rt, jsbag);\n  auto checkFoo = function(\"function (o) { return o.foo === 'bar'; }\");\n  auto checkCount = function(\"function (o) { return o.count === 37; }\");\n  auto checkNul = function(\"function (o) { return o.nul === null; }\");\n  auto checkIsCool = function(\"function (o) { return o.iscool === true; }\");\n  auto checkObj = function(\n      \"function (o) {\"\n      \"  return (typeof o.obj) === 'object' && o.obj.foo === 'bar';\"\n      \"}\");\n  // Check this looks good from js\n  EXPECT_TRUE(checkFoo.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkCount.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkNul.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkIsCool.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkObj.call(rt, jsbag).getBool());\n\n  // Check this looks good from c++\n  EXPECT_EQ(bag[\"foo\"].getString(rt).utf8(rt), \"bar\");\n  EXPECT_EQ(bag[\"count\"].getNumber(), 37);\n  EXPECT_TRUE(bag[\"nul\"].isNull());\n  EXPECT_TRUE(bag[\"iscool\"].getBool());\n  EXPECT_EQ(\n      bag[\"obj\"].getObject(rt).getProperty(rt, \"foo\").getString(rt).utf8(rt),\n      \"bar\");\n}\n\nTEST_P(JSITest, DecoratorTest) {\n  struct Count {\n    // init here is just to show that a With type does not need to be\n    // default constructible.\n    explicit Count(int init) : count(init) {}\n\n    // Test optional before method.\n\n    void after() {\n      ++count;\n    }\n\n    int count;\n  };\n\n  static constexpr int kInit = 17;\n\n  class CountRuntime final : public WithRuntimeDecorator<Count> {\n   public:\n    explicit CountRuntime(std::unique_ptr<Runtime> rt)\n        : WithRuntimeDecorator<Count>(*rt, count_),\n          rt_(std::move(rt)),\n          count_(kInit) {}\n\n    int count() {\n      return count_.count;\n    }\n\n   private:\n    std::unique_ptr<Runtime> rt_;\n    Count count_;\n  };\n\n  CountRuntime crt(factory());\n\n  crt.description();\n  EXPECT_EQ(crt.count(), kInit + 1);\n\n  crt.global().setProperty(crt, \"o\", Object(crt));\n  EXPECT_EQ(crt.count(), kInit + 6);\n}\n\nTEST_P(JSITest, MultiDecoratorTest) {\n  struct Inc {\n    void before() {\n      ++count;\n    }\n\n    // Test optional after method.\n\n    int count = 0;\n  };\n\n  struct Nest {\n    void before() {\n      ++nest;\n    }\n\n    void after() {\n      --nest;\n    }\n\n    int nest = 0;\n  };\n\n  class MultiRuntime final\n      : public WithRuntimeDecorator<std::tuple<Inc, Nest>> {\n   public:\n    explicit MultiRuntime(std::unique_ptr<Runtime> rt)\n        : WithRuntimeDecorator<std::tuple<Inc, Nest>>(*rt, tuple_),\n          rt_(std::move(rt)) {}\n\n    int count() {\n      return std::get<0>(tuple_).count;\n    }\n    int nest() {\n      return std::get<1>(tuple_).nest;\n    }\n\n   private:\n    std::unique_ptr<Runtime> rt_;\n    std::tuple<Inc, Nest> tuple_;\n  };\n\n  MultiRuntime mrt(factory());\n\n  Function expectNestOne = Function::createFromHostFunction(\n      mrt,\n      PropNameID::forAscii(mrt, \"expectNestOne\"),\n      0,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        MultiRuntime* funcmrt = dynamic_cast<MultiRuntime*>(&rt);\n        EXPECT_NE(funcmrt, nullptr);\n        EXPECT_EQ(funcmrt->count(), 3);\n        EXPECT_EQ(funcmrt->nest(), 1);\n        return Value::undefined();\n      });\n\n  expectNestOne.call(mrt);\n\n  EXPECT_EQ(mrt.count(), 3);\n  EXPECT_EQ(mrt.nest(), 0);\n}\n\nTEST_P(JSITest, SymbolTest) {\n  if (!rt.global().hasProperty(rt, \"Symbol\")) {\n    // Symbol is an es6 feature which doesn't exist in older VMs.  So\n    // the tests which might be elsewhere are all here so they can be\n    // skipped.\n    return;\n  }\n\n  // ObjectTest\n  eval(\"x = {1:2, 'three':Symbol('four')}\");\n  Object x = rt.global().getPropertyAsObject(rt, \"x\");\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 2);\n  EXPECT_TRUE(x.hasProperty(rt, \"three\"));\n  EXPECT_EQ(\n      x.getProperty(rt, \"three\").getSymbol(rt).toString(rt), \"Symbol(four)\");\n\n  // ValueTest\n  EXPECT_TRUE(eval(\"Symbol('sym')\").isSymbol());\n  EXPECT_EQ(eval(\"Symbol('sym')\").getSymbol(rt).toString(rt), \"Symbol(sym)\");\n\n  // EqualsTest\n  EXPECT_FALSE(Symbol::strictEquals(\n      rt,\n      eval(\"Symbol('a')\").getSymbol(rt),\n      eval(\"Symbol('a')\").getSymbol(rt)));\n  EXPECT_TRUE(Symbol::strictEquals(\n      rt,\n      eval(\"Symbol.for('a')\").getSymbol(rt),\n      eval(\"Symbol.for('a')\").getSymbol(rt)));\n  EXPECT_FALSE(\n      Value::strictEquals(rt, eval(\"Symbol('a')\"), eval(\"Symbol('a')\")));\n  EXPECT_TRUE(Value::strictEquals(\n      rt, eval(\"Symbol.for('a')\"), eval(\"Symbol.for('a')\")));\n  EXPECT_FALSE(Value::strictEquals(rt, eval(\"Symbol('a')\"), eval(\"'a'\")));\n}\n\nTEST_P(JSITest, JSErrorTest) {\n  // JSError creation can lead to further errors.  Make sure these\n  // cases are handled and don't cause weird crashes or other issues.\n  //\n  // Getting message property can throw\n\n  EXPECT_THROW(\n      eval(\"var GetMessageThrows = {get message() { throw Error('ex'); }};\"\n           \"throw GetMessageThrows;\"),\n      JSIException);\n\n  EXPECT_THROW(\n      eval(\"var GetMessageThrows = {get message() { throw GetMessageThrows; }};\"\n           \"throw GetMessageThrows;\"),\n      JSIException);\n\n  // Converting exception message to String can throw\n\n  EXPECT_THROW(\n      eval(\n          \"Object.defineProperty(\"\n          \"  globalThis, 'String', {configurable:true, get() { var e = Error(); e.message = 23; throw e; }});\"\n          \"var e = Error();\"\n          \"e.message = 17;\"\n          \"throw e;\"),\n      JSIException);\n\n  EXPECT_THROW(\n      eval(\n          \"var e = Error();\"\n          \"Object.defineProperty(\"\n          \"  e, 'message', {configurable:true, get() { throw Error('getter'); }});\"\n          \"throw e;\"),\n      JSIException);\n\n  EXPECT_THROW(\n      eval(\"var e = Error();\"\n           \"String = function() { throw Error('ctor'); };\"\n           \"throw e;\"),\n      JSIException);\n\n  // Converting an exception message to String can return a non-String\n\n  EXPECT_THROW(\n      eval(\"String = function() { return 42; };\"\n           \"var e = Error();\"\n           \"e.message = 17;\"\n           \"throw e;\"),\n      JSIException);\n\n  // Exception can be non-Object\n\n  EXPECT_THROW(eval(\"throw 17;\"), JSIException);\n\n  EXPECT_THROW(eval(\"throw undefined;\"), JSIException);\n\n  // Converting exception with no message or stack property to String can throw\n\n  EXPECT_THROW(\n      eval(\"var e = {toString() { throw new Error('errstr'); }};\"\n           \"throw e;\"),\n      JSIException);\n}\n\n//----------------------------------------------------------------------\n// Test that multiple levels of delegation in DecoratedHostObjects works.\n\nclass RD1 : public RuntimeDecorator<Runtime, Runtime> {\n public:\n  RD1(Runtime& plain) : RuntimeDecorator(plain) {}\n\n  Object createObject(std::shared_ptr<HostObject> ho) {\n    class DHO1 : public DecoratedHostObject {\n     public:\n      using DecoratedHostObject::DecoratedHostObject;\n\n      Value get(Runtime& rt, const PropNameID& name) override {\n        numGets++;\n        return DecoratedHostObject::get(rt, name);\n      }\n    };\n    return Object::createFromHostObject(\n        plain(), std::make_shared<DHO1>(*this, ho));\n  }\n\n  static unsigned numGets;\n};\n\nclass RD2 : public RuntimeDecorator<Runtime, Runtime> {\n public:\n  RD2(Runtime& plain) : RuntimeDecorator(plain) {}\n\n  Object createObject(std::shared_ptr<HostObject> ho) {\n    class DHO2 : public DecoratedHostObject {\n     public:\n      using DecoratedHostObject::DecoratedHostObject;\n\n      Value get(Runtime& rt, const PropNameID& name) override {\n        numGets++;\n        return DecoratedHostObject::get(rt, name);\n      }\n    };\n    return Object::createFromHostObject(\n        plain(), std::make_shared<DHO2>(*this, ho));\n  }\n\n  static unsigned numGets;\n};\n\nclass HO : public HostObject {\n public:\n  explicit HO(Runtime* expectedRT) : expectedRT_(expectedRT) {}\n\n  Value get(Runtime& rt, const PropNameID& name) override {\n    EXPECT_EQ(expectedRT_, &rt);\n    return Value(17.0);\n  }\n\n private:\n  // The runtime we expect to be called with.\n  Runtime* expectedRT_;\n};\n\nunsigned RD1::numGets = 0;\nunsigned RD2::numGets = 0;\n\nTEST_P(JSITest, MultilevelDecoratedHostObject) {\n  // This test will be run for various test instantiations, so initialize these\n  // counters.\n  RD1::numGets = 0;\n  RD2::numGets = 0;\n\n  RD1 rd1(rt);\n  RD2 rd2(rd1);\n  // We expect the \"get\" operation of ho to be called with rd2.\n  auto ho = std::make_shared<HO>(&rd2);\n  auto obj = Object::createFromHostObject(rd2, ho);\n  Value v = obj.getProperty(rd2, \"p\");\n  EXPECT_TRUE(v.isNumber());\n  EXPECT_EQ(17.0, v.asNumber());\n  auto ho2 = obj.getHostObject(rd2);\n  EXPECT_EQ(ho, ho2);\n  EXPECT_EQ(1, RD1::numGets);\n  EXPECT_EQ(1, RD2::numGets);\n}\n\nINSTANTIATE_TEST_CASE_P(\n    Runtimes,\n    JSITest,\n    ::testing::ValuesIn(runtimeGenerators()));\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/VM/JSObject.h\"\n\n#include \"hermes/VM/BuildMetadata.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/HostModel.h\"\n#include \"hermes/VM/InternalProperty.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSDate.h\"\n#include \"hermes/VM/JSProxy.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include \"llvh/ADT/SmallSet.h\"\n\nnamespace hermes {\nnamespace vm {\n\nObjectVTable JSObject::vt{\n    VTable(\n        CellKind::ObjectKind,\n        cellSize<JSObject>(),\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr, // externalMemorySize\n        VTable::HeapSnapshotMetadata{HeapSnapshot::NodeType::Object,\n                                     JSObject::_snapshotNameImpl,\n                                     JSObject::_snapshotAddEdgesImpl,\n                                     nullptr,\n                                     JSObject::_snapshotAddLocationsImpl}),\n    JSObject::_getOwnIndexedRangeImpl,\n    JSObject::_haveOwnIndexedImpl,\n    JSObject::_getOwnIndexedPropertyFlagsImpl,\n    JSObject::_getOwnIndexedImpl,\n    JSObject::_setOwnIndexedImpl,\n    JSObject::_deleteOwnIndexedImpl,\n    JSObject::_checkAllOwnIndexedImpl,\n};\n\nvoid ObjectBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  // This call is just for debugging and consistency purposes.\n  mb.addJSObjectOverlapSlots(JSObject::numOverlapSlots<JSObject>());\n\n  const auto *self = static_cast<const JSObject *>(cell);\n  mb.addField(\"parent\", &self->parent_);\n  mb.addField(\"class\", &self->clazz_);\n  mb.addField(\"propStorage\", &self->propStorage_);\n\n  // Declare the direct properties.\n  static const char *directPropName[JSObject::DIRECT_PROPERTY_SLOTS] = {\n      \"directProp0\", \"directProp1\", \"directProp2\", \"directProp3\"};\n  for (unsigned i = mb.getJSObjectOverlapSlots();\n       i < JSObject::DIRECT_PROPERTY_SLOTS;\n       ++i) {\n    mb.addField(directPropName[i], self->directProps() + i);\n  }\n}\n\n#ifdef HERMESVM_SERIALIZE\nvoid JSObject::serializeObjectImpl(\n    Serializer &s,\n    const GCCell *cell,\n    unsigned overlapSlots) {\n  auto *self = vmcast<const JSObject>(cell);\n  s.writeData(&self->flags_, sizeof(ObjectFlags));\n  s.writeRelocation(self->parent_.get(s.getRuntime()));\n  s.writeRelocation(self->clazz_.get(s.getRuntime()));\n  // propStorage_ : GCPointer<PropStorage> is also ArrayStorage. Serialize\n  // *propStorage_ with this JSObject.\n  bool hasArray = (bool)self->propStorage_;\n  s.writeInt<uint8_t>(hasArray);\n  if (hasArray) {\n    ArrayStorage::serializeArrayStorage(\n        s, self->propStorage_.get(s.getRuntime()));\n  }\n\n  // Record the number of overlap slots, so that the deserialization code\n  // doesn't need to keep track of it.\n  s.writeInt<uint8_t>(overlapSlots);\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    s.writeHermesValue(self->directProps()[i]);\n  }\n}\n\nvoid ObjectSerialize(Serializer &s, const GCCell *cell) {\n  JSObject::serializeObjectImpl(s, cell, JSObject::numOverlapSlots<JSObject>());\n  s.endObject(cell);\n}\n\nvoid ObjectDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::ObjectKind && \"Expected JSObject\");\n  void *mem = d.getRuntime()->alloc</*fixedSize*/ true>(cellSize<JSObject>());\n  auto *obj = new (mem) JSObject(d, &JSObject::vt.base);\n\n  d.endObject(obj);\n}\n\nJSObject::JSObject(Deserializer &d, const VTable *vtp)\n    : GCCell(&d.getRuntime()->getHeap(), vtp) {\n  d.readData(&flags_, sizeof(ObjectFlags));\n  d.readRelocation(&parent_, RelocationKind::GCPointer);\n  d.readRelocation(&clazz_, RelocationKind::GCPointer);\n  if (d.readInt<uint8_t>()) {\n    propStorage_.set(\n        d.getRuntime(),\n        ArrayStorage::deserializeArrayStorage(d),\n        &d.getRuntime()->getHeap());\n  }\n\n  auto overlapSlots = d.readInt<uint8_t>();\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    d.readHermesValue(&directProps()[i]);\n  }\n}\n#endif\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<JSObject> parentHandle) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      *parentHandle,\n      runtime->getHiddenClassForPrototypeRaw(\n          *parentHandle,\n          numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(Runtime *runtime) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    unsigned propertyCount) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  auto self = mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n\n  return runtime->ignoreAllocationFailure(\n      JSObject::allocatePropStorage(std::move(self), runtime, propertyCount));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<HiddenClass> clazz) {\n  auto obj = JSObject::create(runtime, clazz->getNumProperties());\n  obj->clazz_.set(runtime, *clazz, &runtime->getHeap());\n  // If the hidden class has index like property, we need to clear the fast path\n  // flag.\n  if (LLVM_UNLIKELY(obj->clazz_.get(runtime)->getHasIndexLikeProperties()))\n    obj->flags_.fastIndexProperties = false;\n  return obj;\n}\n\nvoid JSObject::initializeLazyObject(\n    Runtime *runtime,\n    Handle<JSObject> lazyObject) {\n  assert(lazyObject->flags_.lazyObject && \"object must be lazy\");\n  // object is now assumed to be a regular object.\n  lazyObject->flags_.lazyObject = 0;\n\n  // only functions can be lazy.\n  assert(vmisa<Callable>(lazyObject.get()) && \"unexpected lazy object\");\n  Callable::defineLazyProperties(Handle<Callable>::vmcast(lazyObject), runtime);\n}\n\nObjectID JSObject::getObjectID(JSObject *self, Runtime *runtime) {\n  if (LLVM_LIKELY(self->flags_.objectID))\n    return self->flags_.objectID;\n\n  // Object ID does not yet exist, get next unique global ID..\n  self->flags_.objectID = runtime->generateNextObjectID();\n  // Make sure it is not zero.\n  if (LLVM_UNLIKELY(!self->flags_.objectID))\n    --self->flags_.objectID;\n  return self->flags_.objectID;\n}\n\nCallResult<PseudoHandle<JSObject>> JSObject::getPrototypeOf(\n    PseudoHandle<JSObject> selfHandle,\n    Runtime *runtime) {\n  if (LLVM_LIKELY(!selfHandle->isProxyObject())) {\n    return createPseudoHandle(selfHandle->getParent(runtime));\n  }\n\n  return JSProxy::getPrototypeOf(\n      runtime->makeHandle(std::move(selfHandle)), runtime);\n}\n\nnamespace {\n\nCallResult<bool> proxyOpFlags(\n    Runtime *runtime,\n    PropOpFlags opFlags,\n    const char *msg,\n    CallResult<bool> res) {\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*res && opFlags.getThrowOnError()) {\n    return runtime->raiseTypeError(msg);\n  }\n  return res;\n}\n\n} // namespace\n\nCallResult<bool> JSObject::setParent(\n    JSObject *self,\n    Runtime *runtime,\n    JSObject *parent,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Object is not extensible.\",\n        JSProxy::setPrototypeOf(\n            runtime->makeHandle(self), runtime, runtime->makeHandle(parent)));\n  }\n  // ES9 9.1.2\n  // 4.\n  if (self->parent_.get(runtime) == parent)\n    return true;\n  // 5.\n  if (!self->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\"Object is not extensible.\");\n    } else {\n      return false;\n    }\n  }\n  // 6-8. Check for a prototype cycle.\n  for (JSObject *cur = parent; cur; cur = cur->parent_.get(runtime)) {\n    if (cur == self) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\"Prototype cycle detected\");\n      } else {\n        return false;\n      }\n    } else if (LLVM_UNLIKELY(cur->isProxyObject())) {\n      // TODO this branch should also be used for module namespace and\n      // immutable prototype exotic objects.\n      break;\n    }\n  }\n  // 9.\n  self->parent_.set(runtime, parent, &runtime->getHeap());\n  // 10.\n  return true;\n}\n\nvoid JSObject::allocateNewSlotStorage(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SlotIndex newSlotIndex,\n    Handle<> valueHandle) {\n  // If it is a direct property, just store the value and we are done.\n  if (LLVM_LIKELY(newSlotIndex < DIRECT_PROPERTY_SLOTS)) {\n    selfHandle->directProps()[newSlotIndex].set(\n        *valueHandle, &runtime->getHeap());\n    return;\n  }\n\n  // Make the slot index relative to the indirect storage.\n  newSlotIndex -= DIRECT_PROPERTY_SLOTS;\n\n  // Allocate a new property storage if not already allocated.\n  if (LLVM_UNLIKELY(!selfHandle->propStorage_)) {\n    // Allocate new storage.\n    assert(newSlotIndex == 0 && \"allocated slot must be at end\");\n    auto arrRes = runtime->ignoreAllocationFailure(\n        PropStorage::create(runtime, DEFAULT_PROPERTY_CAPACITY));\n    selfHandle->propStorage_.set(\n        runtime, vmcast<PropStorage>(arrRes), &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(\n                 newSlotIndex >=\n                 selfHandle->propStorage_.get(runtime)->capacity())) {\n    // Reallocate the existing one.\n    assert(\n        newSlotIndex == selfHandle->propStorage_.get(runtime)->size() &&\n        \"allocated slot must be at end\");\n    auto hnd = runtime->makeMutableHandle(selfHandle->propStorage_);\n    PropStorage::resize(hnd, runtime, newSlotIndex + 1);\n    selfHandle->propStorage_.set(runtime, *hnd, &runtime->getHeap());\n  }\n\n  {\n    NoAllocScope scope{runtime};\n    auto *const propStorage = selfHandle->propStorage_.getNonNull(runtime);\n    if (newSlotIndex >= propStorage->size()) {\n      assert(\n          newSlotIndex == propStorage->size() &&\n          \"allocated slot must be at end\");\n      PropStorage::resizeWithinCapacity(propStorage, runtime, newSlotIndex + 1);\n    }\n    // If we don't need to resize, just store it directly.\n    propStorage->at(newSlotIndex).set(*valueHandle, &runtime->getHeap());\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    NamedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getNamedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(getNamedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor =\n      vmcast<PropertyAccessor>(getNamedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getComputedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor = vmcast<PropertyAccessor>(\n      getComputedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc,\n    Handle<> nameValHandle) {\n  if (!propObj) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n\n  if (LLVM_LIKELY(!desc.flags.proxyObject)) {\n    return JSObject::getComputedPropertyValue_RJS(\n        selfHandle, runtime, propObj, desc);\n  }\n\n  CallResult<Handle<>> keyRes = toPropertyKey(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(keyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  CallResult<bool> hasRes = JSProxy::hasComputed(propObj, runtime, *keyRes);\n  if (LLVM_UNLIKELY(hasRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*hasRes) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n  return JSProxy::getComputed(propObj, runtime, *keyRes, selfHandle);\n}\n\nCallResult<Handle<JSArray>> JSObject::getOwnPropertyKeys(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    OwnKeysFlags okFlags) {\n  assert(\n      (okFlags.getIncludeNonSymbols() || okFlags.getIncludeSymbols()) &&\n      \"Can't exclude symbols and strings\");\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      CallResult<PseudoHandle<JSArray>> proxyRes =\n          JSProxy::ownPropertyKeys(selfHandle, runtime, okFlags);\n      if (LLVM_UNLIKELY(proxyRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return runtime->makeHandle(std::move(*proxyRes));\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    initializeLazyObject(runtime, selfHandle);\n  }\n\n  auto range = getOwnIndexedRange(selfHandle.get(), runtime);\n\n  // Estimate the capacity of the output array.  This estimate is only\n  // reasonable for the non-symbol case.\n  uint32_t capacity = okFlags.getIncludeNonSymbols()\n      ? (selfHandle->clazz_.get(runtime)->getNumProperties() + range.second -\n         range.first)\n      : 0;\n\n  auto arrayRes = JSArray::create(runtime, capacity, 0);\n  if (LLVM_UNLIKELY(arrayRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto array = runtime->makeHandle(std::move(*arrayRes));\n\n  // Optional array of SymbolIDs reported via host object API\n  llvh::Optional<Handle<JSArray>> hostObjectSymbols;\n  size_t hostObjectSymbolCount = 0;\n\n  // If current object is a host object we need to deduplicate its properties\n  llvh::SmallSet<SymbolID::RawType, 16> dedupSet;\n\n  // Output index.\n  uint32_t index = 0;\n\n  // Avoid allocating a new handle per element.\n  MutableHandle<> tmpHandle{runtime};\n\n  // Number of indexed properties.\n  uint32_t numIndexed = 0;\n\n  // Regular properties with names that are array indexes are stashed here, if\n  // encountered.\n  llvh::SmallVector<uint32_t, 8> indexNames{};\n\n  // Iterate the named properties excluding those which use Symbols.\n  if (okFlags.getIncludeNonSymbols()) {\n    // Get host object property names\n    if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n      assert(\n          range.first == range.second &&\n          \"Host objects cannot own indexed range\");\n      auto hostSymbolsRes =\n          vmcast<HostObject>(selfHandle.get())->getHostPropertyNames();\n      if (hostSymbolsRes == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if ((hostObjectSymbolCount = (**hostSymbolsRes)->getEndIndex()) != 0) {\n        Handle<JSArray> hostSymbols = *hostSymbolsRes;\n        hostObjectSymbols = std::move(hostSymbols);\n        capacity += hostObjectSymbolCount;\n      }\n    }\n\n    // Iterate the indexed properties.\n    GCScopeMarkerRAII marker{runtime};\n    for (auto i = range.first; i != range.second; ++i) {\n      auto res = getOwnIndexedPropertyFlags(selfHandle.get(), runtime, i);\n      if (!res)\n        continue;\n\n      // If specified, check whether it is enumerable.\n      if (!okFlags.getIncludeNonEnumerable() && !res->enumerable)\n        continue;\n\n      tmpHandle = HermesValue::encodeDoubleValue(i);\n      JSArray::setElementAt(array, runtime, index++, tmpHandle);\n      marker.flush();\n    }\n\n    numIndexed = index;\n\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime,\n         okFlags,\n         array,\n         hostObjectSymbolCount,\n         &index,\n         &indexNames,\n         &tmpHandle,\n         &dedupSet](SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isPropertyNamePrimitive(id)) {\n            return;\n          }\n\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n\n          // Host properties might overlap with the ones recognized by the\n          // hidden class. If we're dealing with a host object then keep track\n          // of hidden class properties for the deduplication purposes.\n          if (LLVM_UNLIKELY(hostObjectSymbolCount > 0)) {\n            dedupSet.insert(id.unsafeGetRaw());\n          }\n\n          // Check if this property is an integer index. If it is, we stash it\n          // away to deal with it later. This check should be fast since most\n          // property names don't start with a digit.\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            return;\n          }\n\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        });\n\n    // Iterate over HostObject properties and append them to the array. Do not\n    // append duplicates.\n    if (LLVM_UNLIKELY(hostObjectSymbols)) {\n      for (size_t i = 0; i < hostObjectSymbolCount; ++i) {\n        assert(\n            (*hostObjectSymbols)->at(runtime, i).isSymbol() &&\n            \"Host object needs to return array of SymbolIDs\");\n        marker.flush();\n        SymbolID id = (*hostObjectSymbols)->at(runtime, i).getSymbol();\n        if (dedupSet.count(id.unsafeGetRaw()) == 0) {\n          dedupSet.insert(id.unsafeGetRaw());\n\n          assert(\n              !InternalProperty::isInternal(id) &&\n              \"host object returned reserved symbol\");\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            continue;\n          }\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        }\n      }\n    }\n  }\n\n  // Now iterate the named properties again, including only Symbols.\n  // We could iterate only once, if we chose to ignore (and disallow)\n  // own properties on HostObjects, as we do with Proxies.\n  if (okFlags.getIncludeSymbols()) {\n    MutableHandle<SymbolID> idHandle{runtime};\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime, okFlags, array, &index, &idHandle](\n            SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isSymbolPrimitive(id)) {\n            return;\n          }\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n          idHandle = id;\n          JSArray::setElementAt(array, runtime, index++, idHandle);\n        });\n  }\n\n  // The end (exclusive) of the named properties.\n  uint32_t endNamed = index;\n\n  // Properly set the length of the array.\n  auto cr = JSArray::setLength(\n      array, runtime, endNamed + indexNames.size(), PropOpFlags{});\n  (void)cr;\n  assert(\n      cr != ExecutionStatus::EXCEPTION && *cr && \"JSArray::setLength() failed\");\n\n  // If we have no index-like names, we are done.\n  if (LLVM_LIKELY(indexNames.empty()))\n    return array;\n\n  // In the unlikely event that we encountered index-like names, we need to sort\n  // them and merge them with the real indexed properties. Note that it is\n  // guaranteed that there are no clashes.\n  std::sort(indexNames.begin(), indexNames.end());\n\n  // Also make space for the new elements by shifting all the named properties\n  // to the right. First, resize the array.\n  JSArray::setStorageEndIndex(array, runtime, endNamed + indexNames.size());\n\n  // Shift the non-index property names. The region [numIndexed..endNamed) is\n  // moved to [numIndexed+indexNames.size()..array->size()).\n  // TODO: optimize this by implementing memcpy-like functionality in ArrayImpl.\n  for (uint32_t last = endNamed, toLast = array->getEndIndex();\n       last != numIndexed;) {\n    --last;\n    --toLast;\n    tmpHandle = array->at(runtime, last);\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  // Now we need to merge the indexes in indexNames and the array\n  // [0..numIndexed). We start from the end and copy the larger element from\n  // either array.\n  // 1+ the destination position to copy into.\n  for (uint32_t toLast = numIndexed + indexNames.size(),\n                indexNamesLast = indexNames.size();\n       toLast != 0;) {\n    if (numIndexed) {\n      uint32_t a = (uint32_t)array->at(runtime, numIndexed - 1).getNumber();\n      uint32_t b;\n\n      if (indexNamesLast && (b = indexNames[indexNamesLast - 1]) > a) {\n        tmpHandle = HermesValue::encodeDoubleValue(b);\n        --indexNamesLast;\n      } else {\n        tmpHandle = HermesValue::encodeDoubleValue(a);\n        --numIndexed;\n      }\n    } else {\n      assert(indexNamesLast && \"prematurely ran out of source values\");\n      tmpHandle =\n          HermesValue::encodeDoubleValue(indexNames[indexNamesLast - 1]);\n      --indexNamesLast;\n    }\n\n    --toLast;\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  return array;\n}\n\n/// Convert a value to string unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n#define LAZY_TO_STRING(runtime, nameValHandle, str)       \\\n  do {                                                    \\\n    if (!str) {                                           \\\n      auto status = toString_RJS(runtime, nameValHandle); \\\n      assert(                                             \\\n          status != ExecutionStatus::EXCEPTION &&         \\\n          \"toString() of primitive cannot fail\");         \\\n      str = status->get();                                \\\n    }                                                     \\\n  } while (0)\n\n/// Convert a value to an identifier unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param id [SymbolID] the identifier is stored there. Must be initialized\n///   to INVALID_IDENTIFIER_ID initially.\n#define LAZY_TO_IDENTIFIER(runtime, nameValHandle, id)          \\\n  do {                                                          \\\n    if (id.isInvalid()) {                                       \\\n      CallResult<Handle<SymbolID>> idRes =                      \\\n          valueToSymbolID(runtime, nameValHandle);              \\\n      if (LLVM_UNLIKELY(idRes == ExecutionStatus::EXCEPTION)) { \\\n        return ExecutionStatus::EXCEPTION;                      \\\n      }                                                         \\\n      id = **idRes;                                             \\\n    }                                                           \\\n  } while (0)\n\n/// Convert a value to array index, if possible.\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n/// \\param arrayIndex [OptValue<uint32_t>] the array index is stored\n///   there.\n#define TO_ARRAY_INDEX(runtime, nameValHandle, str, arrayIndex) \\\n  do {                                                          \\\n    arrayIndex = toArrayIndexFastPath(*nameValHandle);          \\\n    if (!arrayIndex && !nameValHandle->isSymbol()) {            \\\n      LAZY_TO_STRING(runtime, nameValHandle, str);              \\\n      arrayIndex = toArrayIndex(runtime, str);                  \\\n    }                                                           \\\n  } while (0)\n\n/// \\return true if the flags of a new property make it suitable for indexed\n///   storage. All new indexed properties are enumerable, writable and\n///   configurable and have no accessors.\nstatic bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {\n  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&\n      dpf.writable && dpf.setConfigurable && dpf.configurable &&\n      !dpf.setSetter && !dpf.setGetter;\n}\n\nstruct JSObject::Helper {\n public:\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static ObjectFlags &flags(JSObject *self) {\n    return self->flags_;\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static OptValue<PropertyFlags>\n  getOwnIndexedPropertyFlags(JSObject *self, Runtime *runtime, uint32_t index) {\n    return JSObject::getOwnIndexedPropertyFlags(self, runtime, index);\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static NamedPropertyDescriptor &castToNamedPropertyDescriptorRef(\n      ComputedPropertyDescriptor &desc) {\n    return desc.castToNamedPropertyDescriptorRef();\n  }\n};\n\nnamespace {\n\n/// ES5.1 8.12.1.\n\n/// A helper which takes a SymbolID which caches the conversion of\n/// nameValHandle if it's needed.  It should be default constructed,\n/// and may or may not be set.  This has been measured to be a useful\n/// perf win.  Note that always_inline seems to be ignored on static\n/// methods, so this function has to be local to the cpp file in order\n/// to be inlined for the perf win.\nLLVM_ATTRIBUTE_ALWAYS_INLINE\nCallResult<bool> getOwnComputedPrimitiveDescriptorImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    SymbolID &id,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getOwnComputedPrimitiveDescriptor \"\n      \"cannot be an object\");\n\n  // Try the fast paths first if we have \"fast\" index properties and the\n  // property name is an obvious index.\n  if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n    if (JSObject::Helper::flags(*selfHandle).fastIndexProperties) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        // This a valid array index, residing in our indexed storage.\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n\n      // This a valid array index, but we don't have it in our indexed storage,\n      // and we don't have index-like named properties.\n      return false;\n    }\n\n    if (!selfHandle->getClass(runtime)->getHasIndexLikeProperties() &&\n        !selfHandle->isHostObject() && !selfHandle->isLazy() &&\n        !selfHandle->isProxyObject()) {\n      // Early return to handle the case where an object definitely has no\n      // index-like properties. This avoids allocating a new StringPrimitive and\n      // uniquing it below.\n      return false;\n    }\n  }\n\n  // Convert the string to a SymbolID\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n  // Look for a named property with this name.\n  if (JSObject::getOwnNamedDescriptor(\n          selfHandle,\n          runtime,\n          id,\n          JSObject::Helper::castToNamedPropertyDescriptorRef(desc))) {\n    return true;\n  }\n\n  if (LLVM_LIKELY(\n          !JSObject::Helper::flags(*selfHandle).indexedStorage &&\n          !selfHandle->isLazy() && !selfHandle->isProxyObject())) {\n    return false;\n  }\n  MutableHandle<StringPrimitive> strPrim{runtime};\n\n  // If we have indexed storage, perform potentially expensive conversions\n  // to array index and check it.\n  if (JSObject::Helper::flags(*selfHandle).indexedStorage) {\n    // If the name is a valid integer array index, store it here.\n    OptValue<uint32_t> arrayIndex;\n\n    // Try to convert the property name to an array index.\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n\n    if (arrayIndex) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (selfHandle->isLazy()) {\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return JSObject::getOwnComputedPrimitiveDescriptor(\n        selfHandle, runtime, nameValHandle, ignoreProxy, desc);\n  }\n\n  assert(selfHandle->isProxyObject() && \"descriptor flags are impossible\");\n  if (ignoreProxy == JSObject::IgnoreProxy::Yes) {\n    return false;\n  }\n  return JSProxy::getOwnProperty(\n      selfHandle, runtime, nameValHandle, desc, nullptr);\n}\n\n} // namespace\n\nCallResult<bool> JSObject::getOwnComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    ComputedPropertyDescriptor &desc) {\n  SymbolID id{};\n\n  return getOwnComputedPrimitiveDescriptorImpl(\n      selfHandle, runtime, nameValHandle, ignoreProxy, id, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::No, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc,\n    MutableHandle<> &valueOrAccessor) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // The proxy is ignored here so we can avoid calling\n  // JSProxy::getOwnProperty twice on proxies, since\n  // getOwnComputedPrimitiveDescriptor doesn't pass back the\n  // valueOrAccessor.\n  CallResult<bool> res = JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::Yes, desc);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (*res) {\n    valueOrAccessor = getComputedSlotValue(selfHandle.get(), runtime, desc);\n    return true;\n  }\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::getOwnProperty(\n        selfHandle, runtime, nameValHandle, desc, &valueOrAccessor);\n  }\n  return false;\n}\n\nJSObject *JSObject::getNamedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags expectedFlags,\n    NamedPropertyDescriptor &desc) {\n  if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n    return *selfHandle;\n\n  // Check here for host object flag.  This means that \"normal\" own\n  // properties above win over host-defined properties, but there's no\n  // cost imposed on own property lookups.  This should do what we\n  // need in practice, and we can define host vs js property\n  // disambiguation however we want.  This is here in order to avoid\n  // impacting perf for the common case where an own property exists\n  // in normal storage.\n  if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n    desc.flags.hostObject = true;\n    desc.flags.writable = true;\n    return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    assert(\n        !selfHandle->flags_.proxyObject &&\n        \"Proxy objects should never be lazy\");\n    // Initialize the object and perform the lookup again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n\n    if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n      return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    desc.flags.proxyObject = true;\n    return *selfHandle;\n  }\n\n  if (selfHandle->parent_) {\n    MutableHandle<JSObject> mutableSelfHandle{\n        runtime, selfHandle->parent_.getNonNull(runtime)};\n\n    do {\n      // Check the most common case first, at the cost of some code duplication.\n      if (LLVM_LIKELY(\n              !mutableSelfHandle->flags_.lazyObject &&\n              !mutableSelfHandle->flags_.hostObject &&\n              !mutableSelfHandle->flags_.proxyObject)) {\n      findProp:\n        if (findProperty(\n                mutableSelfHandle,\n                runtime,\n                name,\n                PropertyFlags::invalid(),\n                desc)) {\n          assert(\n              !selfHandle->flags_.proxyObject &&\n              \"Proxy object parents should never have own properties\");\n          return *mutableSelfHandle;\n        }\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.lazyObject)) {\n        JSObject::initializeLazyObject(runtime, mutableSelfHandle);\n        goto findProp;\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.hostObject)) {\n        desc.flags.hostObject = true;\n        desc.flags.writable = true;\n        return *mutableSelfHandle;\n      } else {\n        assert(\n            mutableSelfHandle->flags_.proxyObject &&\n            \"descriptor flags are impossible\");\n        desc.flags.proxyObject = true;\n        return *mutableSelfHandle;\n      }\n    } while ((mutableSelfHandle = mutableSelfHandle->parent_.get(runtime)));\n  }\n\n  return nullptr;\n}\n\nExecutionStatus JSObject::getComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getComputedPrimitiveDescriptor cannot \"\n      \"be an object\");\n\n  propObj = selfHandle.get();\n\n  SymbolID id{};\n\n  GCScopeMarkerRAII marker{runtime};\n  do {\n    // A proxy is ignored here so we can check the bit later and\n    // return it back to the caller for additional processing.\n\n    Handle<JSObject> loopHandle = propObj;\n\n    CallResult<bool> res = getOwnComputedPrimitiveDescriptorImpl(\n        loopHandle, runtime, nameValHandle, IgnoreProxy::Yes, id, desc);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*res) {\n      return ExecutionStatus::RETURNED;\n    }\n\n    if (LLVM_UNLIKELY(propObj->flags_.hostObject)) {\n      desc.flags.hostObject = true;\n      desc.flags.writable = true;\n      return ExecutionStatus::RETURNED;\n    }\n    if (LLVM_UNLIKELY(propObj->flags_.proxyObject)) {\n      desc.flags.proxyObject = true;\n      return ExecutionStatus::RETURNED;\n    }\n    // This isn't a proxy, so use the faster getParent() instead of\n    // getPrototypeOf.\n    propObj = propObj->getParent(runtime);\n    // Flush at the end of the loop to allow first iteration to be as fast as\n    // possible.\n    marker.flush();\n  } while (propObj);\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::getComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return getComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, propObj, desc);\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> receiver,\n    PropOpFlags opFlags,\n    PropertyCacheEntry *cacheEntry) {\n  NamedPropertyDescriptor desc;\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (!propObj) {\n    if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n      return runtime->raiseReferenceError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' doesn't exist\");\n    }\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  }\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject)) {\n    // Populate the cache if requested.\n    if (cacheEntry && !propObj->getClass(runtime)->isDictionaryNoCache()) {\n      cacheEntry->clazz = propObj->getClassGCPtr().getStorageType();\n      cacheEntry->slot = desc.slot;\n    }\n    return createPseudoHandle(getNamedSlotValue(propObj, runtime, desc));\n  }\n\n  if (desc.flags.accessor) {\n    auto *accessor =\n        vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return Callable::executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    auto res = vmcast<HostObject>(propObj)->get(name);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return createPseudoHandle(*res);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    return JSProxy::getNamed(\n        runtime->makeHandle(propObj), runtime, name, receiver);\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return getComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)));\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to getNamed().\n  }\n  return getNamed_RJS(selfHandle, runtime, name, opFlags);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return it.\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}\n\nCallResult<bool> JSObject::hasNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  NamedPropertyDescriptor desc;\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (propObj == nullptr) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    return JSProxy::hasNamed(runtime->makeHandle(propObj), runtime, name);\n  }\n  return true;\n}\n\nCallResult<bool> JSObject::hasNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      if (haveOwnIndexed(selfHandle.get(), runtime, *nameAsIndex)) {\n        return true;\n      }\n      if (selfHandle->flags_.fastIndexProperties) {\n        return false;\n      }\n    }\n    // Here we have indexed properties but the symbol was not stored in the\n    // indexedStorage.\n    // Fall through to getNamed().\n  }\n  return hasNamed(selfHandle, runtime, name);\n}\n\nCallResult<bool> JSObject::hasComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return true.\n      if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n        return true;\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (getComputedPrimitiveDescriptor(\n          selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n      ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::hasComputed(propObj, runtime, *key);\n  }\n  // For compatibility with polyfills we want to pretend that all HostObject\n  // properties are \"own\" properties in 'in'. Since there is no way to check for\n  // a HostObject property, we must always assume success. In practice the\n  // property name would have been obtained from enumerating the properties in\n  // JS code that looks something like this:\n  //    for(key in hostObj) {\n  //      if (key in hostObj)\n  //        ...\n  //    }\n  return true;\n}\n\nstatic ExecutionStatus raiseErrorForOverridingStaticBuiltin(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<SymbolID> name) {\n  Handle<StringPrimitive> methodNameHnd =\n      runtime->makeHandle(runtime->getStringPrimFromSymbolID(name.get()));\n  // If the 'name' property does not exist or is an accessor, we don't display\n  // the name.\n  NamedPropertyDescriptor desc;\n  auto *obj = JSObject::getNamedDescriptor(\n      selfHandle, runtime, Predefined::getSymbolID(Predefined::name), desc);\n  assert(\n      !selfHandle->isProxyObject() &&\n      \"raiseErrorForOverridingStaticBuiltin cannot be used with proxy objects\");\n\n  if (!obj || desc.flags.accessor) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  // Display the name property of the builtin object if it is a string.\n  StringPrimitive *objName = dyn_vmcast<StringPrimitive>(\n      JSObject::getNamedSlotValue(selfHandle.get(), runtime, desc));\n  if (!objName) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  return runtime->raiseTypeError(\n      TwineChar16(\"Attempting to override read-only builtin method '\") +\n      TwineChar16(objName) + \".\" + TwineChar16(methodNameHnd.get()) + \"'\");\n}\n\nCallResult<bool> JSObject::putNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  NamedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(\n      selfHandle,\n      runtime,\n      name,\n      PropertyFlags::defaultNewNamedPropertyFlags(),\n      desc);\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            *selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      setNamedSlotValue(\n          *selfHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor =\n          vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              TwineChar16(\"Cannot assign to property '\") +\n              runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n              \"' which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              *valueHandle) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<bool> setRes = JSProxy::setNamed(\n          runtime->makeHandle(propObj), runtime, name, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy set returned false for property '\") +\n            runtime->getIdentifierTable().getStringView(runtime, name) + \"'\");\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(name));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Cannot assign to read-only property '\") +\n            runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n            \"'\");\n      }\n      return false;\n    }\n\n    if (*selfHandle == propObj && desc.flags.internalSetter) {\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueHandle, opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n\n    if (getOwnNamedDescriptor(receiverHandle, runtime, name, desc)) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      assert(\n          !receiverHandle->isHostObject() && !receiverHandle->isProxyObject() &&\n          \"getOwnNamedDescriptor never sets hostObject or proxyObject flags\");\n\n      setNamedSlotValue(\n          *receiverHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    // Now deal with host and proxy object cases.  We need to call\n    // getOwnComputedPrimitiveDescriptor because it knows how to call\n    // the [[getOwnProperty]] Proxy impl if needed.\n    if (LLVM_UNLIKELY(\n            receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())\n            ->set(name, *valueHandle);\n      }\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n          receiverHandle,\n          runtime,\n          name.isUniqued() ? runtime->makeHandle(HermesValue::encodeStringValue(\n                                 runtime->getStringPrimFromSymbolID(name)))\n                           : runtime->makeHandle(name),\n          IgnoreProxy::No,\n          desc);\n      if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      DefinePropertyFlags dpf;\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle, runtime, name, dpf, valueHandle, opFlags);\n    }\n  }\n\n  // Does the caller require it to exist?\n  if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n    return runtime->raiseReferenceError(\n        TwineChar16(\"Property '\") +\n        runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n        \"' doesn't exist\");\n  }\n\n  // Add a new property.\n\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      name,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::putNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return putComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)),\n          valueHandle,\n          opFlags);\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to putNamed().\n  }\n  return putNamed_RJS(selfHandle, runtime, name, valueHandle, opFlags);\n}\n\nCallResult<bool> JSObject::putComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() &&\n      \"mustExist flag cannot be used with computed properties\");\n\n  // Try the fast-path first: has \"index-like\" properties, the \"name\"\n  // already is a valid integer index, selfHandle and receiver are the\n  // same, and it is present in storage.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {\n        if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n          auto result =\n              setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);\n          if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_LIKELY(*result))\n            return true;\n          if (opFlags.getThrowOnError()) {\n            // TODO: better message.\n            return runtime->raiseTypeError(\n                \"Cannot assign to read-only property\");\n          }\n          return false;\n        }\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      if (LLVM_UNLIKELY(\n              setComputedSlotValue(selfHandle, runtime, desc, valueHandle) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    // Is it an accessor?\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor = vmcast<PropertyAccessor>(\n          getComputedSlotValue(propObj.get(), runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeErrorForValue(\n              \"Cannot assign to property \",\n              nameValPrimitiveHandle,\n              \" which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              valueHandle.get()) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n      if (key == ExecutionStatus::EXCEPTION)\n        return ExecutionStatus::EXCEPTION;\n      CallResult<bool> setRes =\n          JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy trap returned false for property\"));\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        SymbolID id{};\n        LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(id));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeErrorForValue(\n            \"Cannot assign to read-only property \", nameValPrimitiveHandle, \"\");\n      }\n      return false;\n    }\n\n    if (selfHandle == propObj && desc.flags.internalSetter) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      return internalSetter(\n          selfHandle,\n          runtime,\n          id,\n          desc.castToNamedPropertyDescriptorRef(),\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n    CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n        receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);\n    if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    DefinePropertyFlags dpf;\n    if (*descDefinedRes) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      if (LLVM_LIKELY(\n              !desc.flags.internalSetter && !receiverHandle->isHostObject() &&\n              !receiverHandle->isProxyObject())) {\n        if (LLVM_UNLIKELY(\n                setComputedSlotValue(\n                    receiverHandle, runtime, desc, valueHandle) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        return true;\n      }\n    }\n\n    if (LLVM_UNLIKELY(\n            desc.flags.internalSetter || receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      if (desc.flags.internalSetter) {\n        return internalSetter(\n            receiverHandle,\n            runtime,\n            id,\n            desc.castToNamedPropertyDescriptorRef(),\n            valueHandle,\n            opFlags);\n      } else if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n      }\n      assert(\n          receiverHandle->isProxyObject() && \"descriptor flags are impossible\");\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle, runtime, id, dpf, valueHandle, opFlags);\n    }\n  }\n\n  /// Can we add more properties?\n  if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // If we have indexed storage we must check whether the property is an index,\n  // and if it is, store it in indexed storage.\n  if (receiverHandle->flags_.indexedStorage) {\n    OptValue<uint32_t> arrayIndex;\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n    if (arrayIndex) {\n      // Check whether we need to update array's \".length\" property.\n      if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {\n        if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {\n          auto cr = putNamed_RJS(\n              receiverHandle,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime->makeHandle(\n                  HermesValue::encodeNumberValue(*arrayIndex + 1)),\n              opFlags);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_UNLIKELY(!*cr))\n            return false;\n        }\n      }\n\n      auto result =\n          setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (LLVM_LIKELY(*result))\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\"Cannot assign to read-only property\");\n      }\n      return false;\n    }\n  }\n\n  SymbolID id{};\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Add a new named property.\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      id,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::deleteNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n\n  // If the property doesn't exist in this object, return success.\n  if (!pos) {\n    if (LLVM_LIKELY(\n            !selfHandle->flags_.lazyObject &&\n            !selfHandle->flags_.proxyObject)) {\n      return true;\n    } else if (selfHandle->flags_.lazyObject) {\n      // object is lazy, initialize and read again.\n      initializeLazyObject(runtime, selfHandle);\n      pos = findProperty(selfHandle, runtime, name, desc);\n      if (!pos) // still not there, return true.\n        return true;\n    } else {\n      assert(selfHandle->flags_.proxyObject && \"object flags are impossible\");\n      return proxyOpFlags(\n          runtime,\n          opFlags,\n          \"Proxy delete returned false\",\n          JSProxy::deleteNamed(selfHandle, runtime, name));\n    }\n  }\n  // If the property isn't configurable, fail.\n  if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' is not configurable\");\n    }\n    return false;\n  }\n\n  // Clear the deleted property value to prevent memory leaks.\n  setNamedSlotValue(\n      *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n  // Perform the actual deletion.\n  auto newClazz = HiddenClass::deleteProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  return true;\n}\n\nCallResult<bool> JSObject::deleteComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  auto nameValPrimitiveHandle = *converted;\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n  }\n\n  // Try the fast-path first: the \"name\" is a valid array index and we don't\n  // have \"index-like\" named properties.\n  if (arrayIndex && selfHandle->flags_.fastIndexProperties) {\n    // Delete the indexed property.\n    if (deleteOwnIndexed(selfHandle, runtime, *arrayIndex))\n      return true;\n\n    // Cannot delete property (for example this may be a typed array).\n    if (opFlags.getThrowOnError()) {\n      // TODO: better error message.\n      return runtime->raiseTypeError(\"Cannot delete property\");\n    }\n    return false;\n  }\n\n  // slow path, check if object is lazy before continuing.\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    // initialize and try again.\n    initializeLazyObject(runtime, selfHandle);\n    return deleteComputed(selfHandle, runtime, nameValHandle, opFlags);\n  }\n\n  // Convert the string to an SymbolID;\n  SymbolID id;\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, id, desc);\n\n  // If the property exists, make sure it is configurable.\n  if (pos) {\n    // If the property isn't configurable, fail.\n    if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: a better message.\n        return runtime->raiseTypeError(\"Property is not configurable\");\n      }\n      return false;\n    }\n  }\n\n  // At this point we know that the named property either doesn't exist, or\n  // is configurable and so can be deleted, or the object is a Proxy.\n\n  // If it is an \"index-like\" property, we must also delete the \"shadow\" indexed\n  // property in order to keep Array.length correct.\n  if (arrayIndex) {\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      // Cannot delete property (for example this may be a typed array).\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot delete property\");\n      }\n      return false;\n    }\n  }\n\n  if (pos) {\n    // delete the named property (if it exists).\n    // Clear the deleted property value to prevent memory leaks.\n    setNamedSlotValue(\n        *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n    // Remove the property descriptor.\n    auto newClazz = HiddenClass::deleteProperty(\n        runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Proxy delete returned false\",\n        JSProxy::deleteComputed(selfHandle, runtime, *key));\n  }\n\n  return true;\n}\n\nCallResult<bool> JSObject::defineOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // Is it an existing property.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n  if (pos) {\n    return updateOwnProperty(\n        selfHandle,\n        runtime,\n        name,\n        *pos,\n        desc,\n        dpFlags,\n        valueOrAccessor,\n        opFlags);\n  }\n\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      return JSProxy::defineOwnProperty(\n          selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    // if the property was not found and the object is lazy we need to\n    // initialize it and try again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return defineOwnProperty(\n        selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  return addOwnProperty(\n      selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n}\n\nExecutionStatus JSObject::defineNewOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"definedNewOwnProperty cannot be used with proxy objects\");\n  assert(\n      !(propertyFlags.accessor && !valueOrAccessor.get().isPointer()) &&\n      \"accessor must be non-empty\");\n  assert(\n      !(propertyFlags.accessor && propertyFlags.writable) &&\n      \"writable must not be set with accessors\");\n  assert(\n      !HiddenClass::debugIsPropertyDefined(\n          selfHandle->clazz_.get(runtime), runtime, name) &&\n      \"new property is already defined\");\n\n  return addOwnPropertyImpl(\n      selfHandle, runtime, name, propertyFlags, valueOrAccessor);\n}\n\nCallResult<bool> JSObject::defineOwnComputedPrimitive(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"defineOwnComputedPrimitive() cannot be \"\n      \"an object\");\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"Cannot set internalSetter on a computed property\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n  }\n\n  SymbolID id{};\n\n  // If not storing a property with an array index name, or if we don't have\n  // indexed storage, just pass to the named routine.\n  if (!arrayIndex) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return defineOwnProperty(\n        selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  // At this point we know that we have indexed storage and that the property\n  // has an index-like name.\n\n  // First check if a named property with the same name exists.\n  if (selfHandle->clazz_.get(runtime)->getHasIndexLikeProperties()) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n    NamedPropertyDescriptor desc;\n    auto pos = findProperty(selfHandle, runtime, id, desc);\n    // If we found a named property, update it.\n    if (pos) {\n      return updateOwnProperty(\n          selfHandle,\n          runtime,\n          id,\n          *pos,\n          desc,\n          dpFlags,\n          valueOrAccessor,\n          opFlags);\n    }\n  }\n\n  // Does an indexed property with that index exist?\n  auto indexedPropPresent =\n      getOwnIndexedPropertyFlags(selfHandle.get(), runtime, *arrayIndex);\n  if (indexedPropPresent) {\n    // The current value of the property.\n    HermesValue curValueOrAccessor =\n        getOwnIndexed(selfHandle.get(), runtime, *arrayIndex);\n\n    auto updateStatus = checkPropertyUpdate(\n        runtime,\n        *indexedPropPresent,\n        dpFlags,\n        curValueOrAccessor,\n        valueOrAccessor,\n        opFlags);\n    if (updateStatus == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    if (updateStatus->first == PropertyUpdateStatus::failed)\n      return false;\n\n    // The property update is valid, but can the property remain an \"indexed\"\n    // property, or do we need to convert it to a named property?\n    // If the property flags didn't change, the property remains indexed.\n    if (updateStatus->second == *indexedPropPresent) {\n      // If the value doesn't change, we are done.\n      if (updateStatus->first == PropertyUpdateStatus::done)\n        return true;\n\n      // If we successfully updated the value, we are done.\n      auto result =\n          setOwnIndexed(selfHandle, runtime, *arrayIndex, valueOrAccessor);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*result)\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\n            \"cannot change read-only property value\");\n      }\n\n      return false;\n    }\n\n    // OK, we need to convert an indexed property to a named one.\n\n    // Check whether to use the supplied value, or to reuse the old one, as we\n    // are simply reconfiguring it.\n    MutableHandle<> value{runtime};\n    if (dpFlags.setValue || dpFlags.isAccessor()) {\n      value = valueOrAccessor.get();\n    } else {\n      value = curValueOrAccessor;\n    }\n\n    // Update dpFlags to match the existing property flags.\n    dpFlags.setEnumerable = 1;\n    dpFlags.setWritable = 1;\n    dpFlags.setConfigurable = 1;\n    dpFlags.enumerable = updateStatus->second.enumerable;\n    dpFlags.writable = updateStatus->second.writable;\n    dpFlags.configurable = updateStatus->second.configurable;\n\n    // Delete the existing indexed property.\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n\n    // Add the new named property.\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return addOwnProperty(selfHandle, runtime, id, dpFlags, value, opFlags);\n  }\n\n  /// Can we add new properties?\n  if (!selfHandle->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // This is a new property with an index-like name.\n  // Check whether we need to update array's \".length\" property.\n  bool updateLength = false;\n  if (auto arrayHandle = Handle<JSArray>::dyn_vmcast(selfHandle)) {\n    if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(*arrayHandle))) {\n      NamedPropertyDescriptor lengthDesc;\n      bool lengthPresent = getOwnNamedDescriptor(\n          arrayHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::length),\n          lengthDesc);\n      (void)lengthPresent;\n      assert(lengthPresent && \".length must be present in JSArray\");\n\n      if (!lengthDesc.flags.writable) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"Cannot assign to read-only 'length' property of array\");\n        }\n        return false;\n      }\n\n      updateLength = true;\n    }\n  }\n\n  bool newIsIndexed = canNewPropertyBeIndexed(dpFlags);\n  if (newIsIndexed) {\n    auto result = setOwnIndexed(\n        selfHandle,\n        runtime,\n        *arrayIndex,\n        dpFlags.setValue ? valueOrAccessor : Runtime::getUndefinedValue());\n    if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    if (!*result) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n  }\n\n  // If this is an array and we need to update \".length\", do so.\n  if (updateLength) {\n    // This should always succeed since we are simply enlarging the length.\n    auto res = JSArray::setLength(\n        Handle<JSArray>::vmcast(selfHandle), runtime, *arrayIndex + 1, opFlags);\n    (void)res;\n    assert(\n        res != ExecutionStatus::EXCEPTION && *res &&\n        \"JSArray::setLength() failed unexpectedly\");\n  }\n\n  if (newIsIndexed)\n    return true;\n\n  // We are adding a new property with an index-like name.\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n  return addOwnProperty(\n      selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n}\n\nCallResult<bool> JSObject::defineOwnComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return defineOwnComputedPrimitive(\n      selfHandle, runtime, *converted, dpFlags, valueOrAccessor, opFlags);\n}\n\nstd::string JSObject::getHeuristicTypeName(GC *gc) {\n  PointerBase *const base = gc->getPointerBase();\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (auto *constructor = dyn_vmcast<JSObject>(*constructorVal)) {\n      auto name = constructor->getNameIfExists(base);\n      // If the constructor's name doesn't exist, or it is just the object\n      // constructor, attempt to find a different name.\n      if (!name.empty() && name != \"Object\")\n        return name;\n    }\n  }\n\n  std::string name = getVT()->base.snapshotMetaData.defaultNameForNode(this);\n  // A constructor's name was not found, check if the object is in dictionary\n  // mode.\n  if (getClass(base)->isDictionary()) {\n    return name + \"(Dictionary)\";\n  }\n\n  // If it's not an Object, the CellKind is most likely good enough on its own\n  if (getKind() != CellKind::ObjectKind) {\n    return name;\n  }\n\n  // If the object isn't a dictionary, and it has only a few property names,\n  // make the name based on those property names.\n  std::vector<std::string> propertyNames;\n  HiddenClass::forEachPropertyNoAlloc(\n      getClass(base),\n      base,\n      [gc, &propertyNames](SymbolID id, NamedPropertyDescriptor) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        propertyNames.emplace_back(gc->convertSymbolToUTF8(id));\n      });\n  // NOTE: One option is to sort the property names before truncation, to\n  // reduce the number of groups; however, by not sorting them it makes it\n  // easier to spot sets of objects with the same properties but in different\n  // orders, and thus find HiddenClass optimizations to make.\n\n  // For objects with a lot of properties but aren't in dictionary mode yet,\n  // keep the number displayed small.\n  constexpr int kMaxPropertiesForTypeName = 5;\n  bool truncated = false;\n  if (propertyNames.size() > kMaxPropertiesForTypeName) {\n    propertyNames.erase(\n        propertyNames.begin() + kMaxPropertiesForTypeName, propertyNames.end());\n    truncated = true;\n  }\n  // The final name should look like Object(a, b, c).\n  if (propertyNames.empty()) {\n    // Don't add parentheses for objects with no properties.\n    return name;\n  }\n  name += \"(\";\n  bool first = true;\n  for (const auto &prop : propertyNames) {\n    if (!first) {\n      name += \", \";\n    }\n    first = false;\n    name += prop;\n  }\n  if (truncated) {\n    // No need to check for comma edge case because this only happens for\n    // greater than one property.\n    static_assert(\n        kMaxPropertiesForTypeName >= 1,\n        \"Property truncation should not happen for 0 properties\");\n    name += \", ...\";\n  }\n  name += \")\";\n  return name;\n}\n\nstd::string JSObject::getNameIfExists(PointerBase *base) {\n  // Try \"displayName\" first, if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::displayName))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // Next, use \"name\" if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::name))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // There is no other way to access the \"name\" property on an object.\n  return \"\";\n}\n\nstd::string JSObject::_snapshotNameImpl(GCCell *cell, GC *gc) {\n  auto *const self = vmcast<JSObject>(cell);\n  return self->getHeuristicTypeName(gc);\n}\n\nvoid JSObject::_snapshotAddEdgesImpl(GCCell *cell, GC *gc, HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n\n  // Add the prototype as a property edge, so it's easy for JS developers to\n  // walk the prototype chain on their own.\n  if (self->parent_) {\n    snap.addNamedEdge(\n        HeapSnapshot::EdgeType::Property,\n        // __proto__ chosen for similarity to V8.\n        \"__proto__\",\n        gc->getObjectID(self->parent_));\n  }\n\n  HiddenClass::forEachPropertyNoAlloc(\n      self->clazz_.get(gc->getPointerBase()),\n      gc->getPointerBase(),\n      [self, gc, &snap](SymbolID id, NamedPropertyDescriptor desc) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        // Else, it's a user-visible property.\n        GCHermesValue &prop =\n            namedSlotRef(self, gc->getPointerBase(), desc.slot);\n        const llvh::Optional<HeapSnapshot::NodeID> idForProp =\n            gc->getSnapshotID(prop);\n        if (!idForProp) {\n          return;\n        }\n        std::string propName = gc->convertSymbolToUTF8(id);\n        // If the property name is a valid array index, display it as an\n        // \"element\" instead of a \"property\". This will put square brackets\n        // around the number and sort it numerically rather than\n        // alphabetically.\n        if (auto index = ::hermes::toArrayIndex(propName)) {\n          snap.addIndexedEdge(\n              HeapSnapshot::EdgeType::Element,\n              index.getValue(),\n              idForProp.getValue());\n        } else {\n          snap.addNamedEdge(\n              HeapSnapshot::EdgeType::Property, propName, idForProp.getValue());\n        }\n      });\n}\n\nvoid JSObject::_snapshotAddLocationsImpl(\n    GCCell *cell,\n    GC *gc,\n    HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n  PointerBase *const base = gc->getPointerBase();\n  // Add the location of the constructor function for this object, if that\n  // constructor is a user-defined JS function.\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          self, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (constructorVal->isObject()) {\n      if (auto *constructor = dyn_vmcast<JSFunction>(*constructorVal)) {\n        constructor->addLocationToSnapshot(snap, gc->getObjectID(self));\n      }\n    }\n  }\n}\n\nstd::pair<uint32_t, uint32_t> JSObject::_getOwnIndexedRangeImpl(\n    JSObject *self,\n    Runtime *runtime) {\n  return {0, 0};\n}\n\nbool JSObject::_haveOwnIndexedImpl(JSObject *self, Runtime *, uint32_t) {\n  return false;\n}\n\nOptValue<PropertyFlags> JSObject::_getOwnIndexedPropertyFlagsImpl(\n    JSObject *self,\n    Runtime *runtime,\n    uint32_t) {\n  return llvh::None;\n}\n\nHermesValue JSObject::_getOwnIndexedImpl(JSObject *, Runtime *, uint32_t) {\n  return HermesValue::encodeEmptyValue();\n}\n\nCallResult<bool>\nJSObject::_setOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t, Handle<>) {\n  return false;\n}\n\nbool JSObject::_deleteOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t) {\n  return false;\n}\n\nbool JSObject::_checkAllOwnIndexedImpl(\n    JSObject * /*self*/,\n    Runtime * /*runtime*/,\n    ObjectVTable::CheckAllOwnIndexedMode /*mode*/) {\n  return true;\n}\n\nvoid JSObject::preventExtensions(JSObject *self) {\n  assert(\n      !self->flags_.proxyObject &&\n      \"[[Extensible]] slot cannot be set directly on Proxy objects\");\n  self->flags_.noExtend = true;\n}\n\nCallResult<bool> JSObject::preventExtensions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::preventExtensions(selfHandle, runtime, opFlags);\n  }\n  JSObject::preventExtensions(*selfHandle);\n  return true;\n}\n\nExecutionStatus JSObject::seal(Handle<JSObject> selfHandle, Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes && \"seal preventExtensions with ThrowOnError returned false\");\n\n  // Already sealed?\n  if (selfHandle->flags_.sealed)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllNonConfigurable(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::freeze(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes &&\n      \"freeze preventExtensions with ThrowOnError returned false\");\n\n  // Already frozen?\n  if (selfHandle->flags_.frozen)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllReadOnly(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nvoid JSObject::updatePropertyFlagsWithoutTransitions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropertyFlags flagsToClear,\n    PropertyFlags flagsToSet,\n    OptValue<llvh::ArrayRef<SymbolID>> props) {\n  auto newClazz = HiddenClass::updatePropertyFlagsWithoutTransitions(\n      runtime->makeHandle(selfHandle->clazz_),\n      runtime,\n      flagsToClear,\n      flagsToSet,\n      props);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n}\n\nCallResult<bool> JSObject::isExtensible(\n    PseudoHandle<JSObject> self,\n    Runtime *runtime) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return JSProxy::isExtensible(runtime->makeHandle(std::move(self)), runtime);\n  }\n  return self->isExtensible();\n}\n\nbool JSObject::isSealed(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.sealed)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllNonConfigurable(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::NonConfigurable)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nbool JSObject::isFrozen(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.frozen)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllReadOnly(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::ReadOnly)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nCallResult<bool> JSObject::addOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  /// Can we add more properties?\n  if (!selfHandle->isExtensible() && !opFlags.getInternalForce()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Cannot add new property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"'\");\n    }\n    return false;\n  }\n\n  PropertyFlags flags{};\n\n  // Accessors don't set writeable.\n  if (dpFlags.isAccessor()) {\n    dpFlags.setWritable = 0;\n    flags.accessor = 1;\n  }\n\n  // Override the default flags if specified.\n  if (dpFlags.setEnumerable)\n    flags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    flags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    flags.configurable = dpFlags.configurable;\n  flags.internalSetter = dpFlags.enableInternalSetter;\n\n  if (LLVM_UNLIKELY(\n          addOwnPropertyImpl(\n              selfHandle, runtime, name, flags, valueOrAccessor) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  return true;\n}\n\nExecutionStatus JSObject::addOwnPropertyImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"Internal properties cannot be added to Proxy objects\");\n  // Add a new property to the class.\n  // TODO: if we check for OOM here in the future, we must undo the slot\n  // allocation.\n  auto addResult = HiddenClass::addProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, name, propertyFlags);\n  if (LLVM_UNLIKELY(addResult == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  selfHandle->clazz_.set(runtime, *addResult->first, &runtime->getHeap());\n\n  allocateNewSlotStorage(\n      selfHandle, runtime, addResult->second, valueOrAccessor);\n\n  // If this is an index-like property, we need to clear the fast path flags.\n  if (LLVM_UNLIKELY(\n          selfHandle->clazz_.getNonNull(runtime)->getHasIndexLikeProperties()))\n    selfHandle->flags_.fastIndexProperties = false;\n\n  return ExecutionStatus::RETURNED;\n}\n\nCallResult<bool> JSObject::updateOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    HiddenClass::PropertyPos propertyPos,\n    NamedPropertyDescriptor desc,\n    const DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto updateStatus = checkPropertyUpdate(\n      runtime,\n      desc.flags,\n      dpFlags,\n      getNamedSlotValue(selfHandle.get(), runtime, desc),\n      valueOrAccessor,\n      opFlags);\n  if (updateStatus == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n  if (updateStatus->first == PropertyUpdateStatus::failed)\n    return false;\n\n  // If the property flags changed, update them.\n  if (updateStatus->second != desc.flags) {\n    desc.flags = updateStatus->second;\n    auto newClazz = HiddenClass::updateProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        propertyPos,\n        desc.flags);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  }\n\n  if (updateStatus->first == PropertyUpdateStatus::done)\n    return true;\n  assert(\n      updateStatus->first == PropertyUpdateStatus::needSet &&\n      \"unexpected PropertyUpdateStatus\");\n\n  if (dpFlags.setValue) {\n    if (LLVM_LIKELY(!desc.flags.internalSetter))\n      setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n    else\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueOrAccessor, opFlags);\n  } else if (dpFlags.isAccessor()) {\n    setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n  } else {\n    // If checkPropertyUpdate() returned needSet, but there is no value or\n    // accessor, clear the value.\n    setNamedSlotValue(\n        selfHandle.get(), runtime, desc, HermesValue::encodeUndefinedValue());\n  }\n\n  return true;\n}\n\nCallResult<std::pair<JSObject::PropertyUpdateStatus, PropertyFlags>>\nJSObject::checkPropertyUpdate(\n    Runtime *runtime,\n    const PropertyFlags currentFlags,\n    DefinePropertyFlags dpFlags,\n    const HermesValue curValueOrAccessor,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  // 8.12.9 [5] Return true, if every field in Desc is absent.\n  if (dpFlags.isEmpty())\n    return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n\n  assert(\n      (!dpFlags.isAccessor() || (!dpFlags.setWritable && !dpFlags.writable)) &&\n      \"can't set both accessor and writable\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"cannot change the value of internalSetter\");\n\n  // 8.12.9 [6] Return true, if every field in Desc also occurs in current and\n  // the value of every field in Desc is the same value as the corresponding\n  // field in current when compared using the SameValue algorithm (9.12).\n  // TODO: this would probably be much more efficient with bitmasks.\n  if ((!dpFlags.setEnumerable ||\n       dpFlags.enumerable == currentFlags.enumerable) &&\n      (!dpFlags.setConfigurable ||\n       dpFlags.configurable == currentFlags.configurable)) {\n    if (dpFlags.isAccessor()) {\n      if (currentFlags.accessor) {\n        auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n        auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n        if ((!dpFlags.setGetter ||\n             curAccessor->getter == newAccessor->getter) &&\n            (!dpFlags.setSetter ||\n             curAccessor->setter == newAccessor->setter)) {\n          return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n        }\n      }\n    } else {\n      if (!currentFlags.accessor &&\n          (!dpFlags.setValue ||\n           isSameValue(curValueOrAccessor, valueOrAccessor.get())) &&\n          (!dpFlags.setWritable || dpFlags.writable == currentFlags.writable)) {\n        return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n      }\n    }\n  }\n\n  // 8.12.9 [7]\n  // If the property is not configurable, some aspects are not changeable.\n  if (!currentFlags.configurable) {\n    // Trying to change non-configurable to configurable?\n    if (dpFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // Trying to change the enumerability of non-configurable property?\n    if (dpFlags.setEnumerable &&\n        dpFlags.enumerable != currentFlags.enumerable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n  }\n\n  PropertyFlags newFlags = currentFlags;\n\n  // 8.12.9 [8] If IsGenericDescriptor(Desc) is true, then no further validation\n  // is required.\n  if (!(dpFlags.setValue || dpFlags.setWritable || dpFlags.setGetter ||\n        dpFlags.setSetter)) {\n    // Do nothing\n  }\n  // 8.12.9 [9]\n  // Changing between accessor and data descriptor?\n  else if (currentFlags.accessor != dpFlags.isAccessor()) {\n    if (!currentFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // If we change from accessor to data descriptor, Preserve the existing\n    // values of the converted property\u2019s [[Configurable]] and [[Enumerable]]\n    // attributes and set the rest of the property\u2019s attributes to their default\n    // values.\n    // If it's the other way around, since the accessor doesn't have the\n    // [[Writable]] attribute, do nothing.\n    newFlags.writable = 0;\n\n    // If we are changing from accessor to non-accessor, we must set a new\n    // value.\n    if (!dpFlags.isAccessor())\n      dpFlags.setValue = 1;\n  }\n  // 8.12.9 [10] if both are data descriptors.\n  else if (!currentFlags.accessor) {\n    if (!currentFlags.configurable) {\n      if (!currentFlags.writable) {\n        // If the current property is not writable, but the new one is.\n        if (dpFlags.writable) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not configurable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n\n        // If we are setting a different value.\n        if (dpFlags.setValue &&\n            !isSameValue(curValueOrAccessor, valueOrAccessor.get())) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not writable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n      }\n    }\n  }\n  // 8.12.9 [11] Both are accessors.\n  else {\n    auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n    auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n    // If not configurable, make sure that nothing is changing.\n    if (!currentFlags.configurable) {\n      if ((dpFlags.setGetter && newAccessor->getter != curAccessor->getter) ||\n          (dpFlags.setSetter && newAccessor->setter != curAccessor->setter)) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"property is not configurable\"); // TODO: better message.\n        }\n        return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n      }\n    }\n\n    // If not setting the getter or the setter, re-use the current one.\n    if (!dpFlags.setGetter)\n      newAccessor->getter.set(\n          runtime, curAccessor->getter, &runtime->getHeap());\n    if (!dpFlags.setSetter)\n      newAccessor->setter.set(\n          runtime, curAccessor->setter, &runtime->getHeap());\n  }\n\n  // 8.12.9 [12] For each attribute field of Desc that is present, set the\n  // correspondingly named attribute of the property named P of object O to the\n  // value of the field.\n  if (dpFlags.setEnumerable)\n    newFlags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    newFlags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    newFlags.configurable = dpFlags.configurable;\n\n  if (dpFlags.setValue)\n    newFlags.accessor = false;\n  else if (dpFlags.isAccessor())\n    newFlags.accessor = true;\n  else\n    return std::make_pair(PropertyUpdateStatus::done, newFlags);\n\n  return std::make_pair(PropertyUpdateStatus::needSet, newFlags);\n}\n\nCallResult<bool> JSObject::internalSetter(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    NamedPropertyDescriptor /*desc*/,\n    Handle<> value,\n    PropOpFlags opFlags) {\n  if (vmisa<JSArray>(selfHandle.get())) {\n    if (name == Predefined::getSymbolID(Predefined::length)) {\n      return JSArray::setLength(\n          Handle<JSArray>::vmcast(selfHandle), runtime, value, opFlags);\n    }\n  }\n\n  llvm_unreachable(\"unhandled property in Object::internalSetter()\");\n}\n\nnamespace {\n\n/// Helper function to add all the property names of an object to an\n/// array, starting at the given index. Only enumerable properties are\n/// incluced. Returns the index after the last property added, but...\nCallResult<uint32_t> appendAllPropertyNames(\n    Handle<JSObject> obj,\n    Runtime *runtime,\n    MutableHandle<BigStorage> &arr,\n    uint32_t beginIndex) {\n  uint32_t size = beginIndex;\n  // We know that duplicate property names can only exist between objects in\n  // the prototype chain. Hence there should not be duplicated properties\n  // before we start to look at any prototype.\n  bool needDedup = false;\n  MutableHandle<> prop(runtime);\n  MutableHandle<JSObject> head(runtime, obj.get());\n  MutableHandle<StringPrimitive> tmpVal{runtime};\n  while (head.get()) {\n    GCScope gcScope(runtime);\n\n    // enumerableProps will contain all enumerable own properties from obj.\n    // Impl note: this is the only place where getOwnPropertyKeys will be\n    // called without IncludeNonEnumerable on a Proxy.  Everywhere else,\n    // trap ordering is specified but ES9 13.7.5.15 says \"The mechanics and\n    // order of enumerating the properties is not specified\", which is\n    // unusual.\n    auto cr =\n        JSObject::getOwnPropertyNames(head, runtime, true /* onlyEnumerable */);\n    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto enumerableProps = *cr;\n    auto marker = gcScope.createMarker();\n    for (unsigned i = 0, e = enumerableProps->getEndIndex(); i < e; ++i) {\n      gcScope.flushToMarker(marker);\n      prop = enumerableProps->at(runtime, i);\n      if (!needDedup) {\n        // If no dedup is needed, add it directly.\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n        continue;\n      }\n      // Otherwise loop through all existing properties and check if we\n      // have seen it before.\n      bool dupFound = false;\n      if (prop->isNumber()) {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            dupFound = val.getNumber() == prop->getNumber();\n          } else {\n            // val is string, prop is number.\n            tmpVal = val.getString();\n            auto valNum = toArrayIndex(\n                StringPrimitive::createStringView(runtime, tmpVal));\n            dupFound = valNum && valNum.getValue() == prop->getNumber();\n          }\n        }\n      } else {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            // val is number, prop is string.\n            auto propNum = toArrayIndex(StringPrimitive::createStringView(\n                runtime, Handle<StringPrimitive>::vmcast(prop)));\n            dupFound = propNum && (propNum.getValue() == val.getNumber());\n          } else {\n            dupFound = val.getString()->equals(prop->getString());\n          }\n        }\n      }\n      if (LLVM_LIKELY(!dupFound)) {\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n      }\n    }\n    // Continue to follow the prototype chain.\n    CallResult<PseudoHandle<JSObject>> parentRes =\n        JSObject::getPrototypeOf(head, runtime);\n    if (LLVM_UNLIKELY(parentRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = parentRes->get();\n    needDedup = true;\n  }\n  return size;\n}\n\n/// Adds the hidden classes of the prototype chain of obj to arr,\n/// starting with the prototype of obj at index 0, etc., and\n/// terminates with null.\n///\n/// \\param obj The object whose prototype chain should be output\n/// \\param[out] arr The array where the classes will be appended. This\n/// array is cleared if any object is unsuitable for caching.\nExecutionStatus setProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    MutableHandle<BigStorage> &arr) {\n  // Layout of a JSArray stored in the for-in cache:\n  // [class(proto(obj)), class(proto(proto(obj))), ..., null, prop0, prop1, ...]\n\n  if (!obj->shouldCacheForIn(runtime)) {\n    arr->clear(runtime);\n    return ExecutionStatus::RETURNED;\n  }\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  MutableHandle<> clazz(runtime);\n  GCScopeMarkerRAII marker{runtime};\n  while (head.get()) {\n    if (!head->shouldCacheForIn(runtime)) {\n      arr->clear(runtime);\n      return ExecutionStatus::RETURNED;\n    }\n    if (JSObject::Helper::flags(*head).lazyObject) {\n      // Ensure all properties have been initialized before caching the hidden\n      // class. Not doing this will result in changes to the hidden class\n      // when getOwnPropertyKeys is called later.\n      JSObject::initializeLazyObject(runtime, head);\n    }\n    clazz = HermesValue::encodeObjectValue(head->getClass(runtime));\n    if (LLVM_UNLIKELY(\n            BigStorage::push_back(arr, runtime, clazz) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = head->getParent(runtime);\n    marker.flush();\n  }\n  clazz = HermesValue::encodeNullValue();\n  return BigStorage::push_back(arr, runtime, clazz);\n}\n\n/// Verifies that the classes of obj's prototype chain still matches those\n/// previously prefixed to arr by setProtoClasses.\n///\n/// \\param obj The object whose prototype chain should be verified\n/// \\param arr Array previously populated by setProtoClasses\n/// \\return The index after the terminating null if everything matches,\n/// otherwise 0.\nuint32_t matchesProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    Handle<BigStorage> arr) {\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  uint32_t i = 0;\n  while (head.get()) {\n    HermesValue protoCls = arr->at(i++);\n    if (protoCls.isNull() || protoCls.getObject() != head->getClass(runtime) ||\n        head->isProxyObject()) {\n      return 0;\n    }\n    head = head->getParent(runtime);\n  }\n  // The chains must both end at the same point.\n  if (head || !arr->at(i++).isNull()) {\n    return 0;\n  }\n  assert(i > 0 && \"success should be positive\");\n  return i;\n}\n\n} // namespace\n\nCallResult<Handle<BigStorage>> getForInPropertyNames(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    uint32_t &beginIndex,\n    uint32_t &endIndex) {\n  Handle<HiddenClass> clazz(runtime, obj->getClass(runtime));\n\n  // Fast case: Check the cache.\n  MutableHandle<BigStorage> arr(runtime, clazz->getForInCache(runtime));\n  if (arr) {\n    beginIndex = matchesProtoClasses(runtime, obj, arr);\n    if (beginIndex) {\n      // Cache is valid for this object, so use it.\n      endIndex = arr->size();\n      return arr;\n    }\n    // Invalid for this object. We choose to clear the cache since the\n    // changes to the prototype chain probably affect other objects too.\n    clazz->clearForInCache(runtime);\n    // Clear arr to slightly reduce risk of OOM from allocation below.\n    arr = nullptr;\n  }\n\n  // Slow case: Build the array of properties.\n  auto ownPropEstimate = clazz->getNumProperties();\n  auto arrRes = obj->shouldCacheForIn(runtime)\n      ? BigStorage::createLongLived(runtime, ownPropEstimate)\n      : BigStorage::create(runtime, ownPropEstimate);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  arr = std::move(*arrRes);\n  if (setProtoClasses(runtime, obj, arr) == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  beginIndex = arr->size();\n  // If obj or any of its prototypes are unsuitable for caching, then\n  // beginIndex is 0 and we return an array with only the property names.\n  bool canCache = beginIndex;\n  auto end = appendAllPropertyNames(obj, runtime, arr, beginIndex);\n  if (end == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  endIndex = *end;\n  // Avoid degenerate memory explosion: if > 75% of the array is properties\n  // or classes from prototypes, then don't cache it.\n  const bool tooMuchProto = *end / 4 > ownPropEstimate;\n  if (canCache && !tooMuchProto) {\n    assert(beginIndex > 0 && \"cached array must start with proto classes\");\n#ifdef HERMES_SLOW_DEBUG\n    assert(beginIndex == matchesProtoClasses(runtime, obj, arr) && \"matches\");\n#endif\n    clazz->setForInCache(*arr, runtime);\n  }\n  return arr;\n}\n\n//===----------------------------------------------------------------------===//\n// class PropertyAccessor\n\nVTable PropertyAccessor::vt{CellKind::PropertyAccessorKind,\n                            cellSize<PropertyAccessor>()};\n\nvoid PropertyAccessorBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  const auto *self = static_cast<const PropertyAccessor *>(cell);\n  mb.addField(\"getter\", &self->getter);\n  mb.addField(\"setter\", &self->setter);\n}\n\n#ifdef HERMESVM_SERIALIZE\nPropertyAccessor::PropertyAccessor(Deserializer &d)\n    : GCCell(&d.getRuntime()->getHeap(), &vt) {\n  d.readRelocation(&getter, RelocationKind::GCPointer);\n  d.readRelocation(&setter, RelocationKind::GCPointer);\n}\n\nvoid PropertyAccessorSerialize(Serializer &s, const GCCell *cell) {\n  auto *self = vmcast<const PropertyAccessor>(cell);\n  s.writeRelocation(self->getter.get(s.getRuntime()));\n  s.writeRelocation(self->setter.get(s.getRuntime()));\n  s.endObject(cell);\n}\n\nvoid PropertyAccessorDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::PropertyAccessorKind && \"Expected PropertyAccessor\");\n  void *mem = d.getRuntime()->alloc(cellSize<PropertyAccessor>());\n  auto *cell = new (mem) PropertyAccessor(d);\n  d.endObject(cell);\n}\n#endif\n\nCallResult<HermesValue> PropertyAccessor::create(\n    Runtime *runtime,\n    Handle<Callable> getter,\n    Handle<Callable> setter) {\n  void *mem = runtime->alloc(cellSize<PropertyAccessor>());\n  return HermesValue::encodeObjectValue(\n      new (mem) PropertyAccessor(runtime, *getter, *setter));\n}\n\n} // namespace vm\n} // namespace hermes\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <jsi/test/testlib.h>\n#include <gtest/gtest.h>\n#include <jsi/decorator.h>\n#include <jsi/jsi.h>\n\n#include <stdlib.h>\n#include <chrono>\n#include <functional>\n#include <thread>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace facebook::jsi;\n\nclass JSITest : public JSITestBase {};\n\nTEST_P(JSITest, RuntimeTest) {\n  auto v = rt.evaluateJavaScript(std::make_unique<StringBuffer>(\"1\"), \"\");\n  EXPECT_EQ(v.getNumber(), 1);\n\n  rt.evaluateJavaScript(std::make_unique<StringBuffer>(\"x = 1\"), \"\");\n  EXPECT_EQ(rt.global().getProperty(rt, \"x\").getNumber(), 1);\n}\n\nTEST_P(JSITest, PropNameIDTest) {\n  // This is a little weird to test, because it doesn't really exist\n  // in JS yet.  All I can do is create them, compare them, and\n  // receive one as an argument to a HostObject.\n\n  PropNameID quux = PropNameID::forAscii(rt, \"quux1\", 4);\n  PropNameID movedQuux = std::move(quux);\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux\");\n  movedQuux = PropNameID::forAscii(rt, \"quux2\");\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux2\");\n  PropNameID copiedQuux = PropNameID(rt, movedQuux);\n  EXPECT_TRUE(PropNameID::compare(rt, movedQuux, copiedQuux));\n\n  EXPECT_TRUE(PropNameID::compare(rt, movedQuux, movedQuux));\n  EXPECT_TRUE(PropNameID::compare(\n      rt, movedQuux, PropNameID::forAscii(rt, std::string(\"quux2\"))));\n  EXPECT_FALSE(PropNameID::compare(\n      rt, movedQuux, PropNameID::forAscii(rt, std::string(\"foo\"))));\n  uint8_t utf8[] = {0xF0, 0x9F, 0x86, 0x97};\n  PropNameID utf8PropNameID = PropNameID::forUtf8(rt, utf8, sizeof(utf8));\n  EXPECT_EQ(utf8PropNameID.utf8(rt), u8\"\\U0001F197\");\n  EXPECT_TRUE(PropNameID::compare(\n      rt, utf8PropNameID, PropNameID::forUtf8(rt, utf8, sizeof(utf8))));\n  PropNameID nonUtf8PropNameID = PropNameID::forUtf8(rt, \"meow\");\n  EXPECT_TRUE(PropNameID::compare(\n      rt, nonUtf8PropNameID, PropNameID::forAscii(rt, \"meow\")));\n  EXPECT_EQ(nonUtf8PropNameID.utf8(rt), \"meow\");\n  PropNameID strPropNameID =\n      PropNameID::forString(rt, String::createFromAscii(rt, \"meow\"));\n  EXPECT_TRUE(PropNameID::compare(rt, nonUtf8PropNameID, strPropNameID));\n\n  auto names = PropNameID::names(\n      rt, \"Ala\", std::string(\"ma\"), PropNameID::forAscii(rt, \"kota\"));\n  EXPECT_EQ(names.size(), 3);\n  EXPECT_TRUE(\n      PropNameID::compare(rt, names[0], PropNameID::forAscii(rt, \"Ala\")));\n  EXPECT_TRUE(\n      PropNameID::compare(rt, names[1], PropNameID::forAscii(rt, \"ma\")));\n  EXPECT_TRUE(\n      PropNameID::compare(rt, names[2], PropNameID::forAscii(rt, \"kota\")));\n}\n\nTEST_P(JSITest, StringTest) {\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, \"foobar\", 3), \"'foo'\"));\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, \"foobar\"), \"'foobar'\"));\n\n  std::string baz = \"baz\";\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, baz), \"'baz'\"));\n\n  uint8_t utf8[] = {0xF0, 0x9F, 0x86, 0x97};\n  EXPECT_TRUE(checkValue(\n      String::createFromUtf8(rt, utf8, sizeof(utf8)), \"'\\\\uD83C\\\\uDD97'\"));\n\n  EXPECT_EQ(eval(\"'quux'\").getString(rt).utf8(rt), \"quux\");\n  EXPECT_EQ(eval(\"'\\\\u20AC'\").getString(rt).utf8(rt), \"\\xe2\\x82\\xac\");\n\n  String quux = String::createFromAscii(rt, \"quux\");\n  String movedQuux = std::move(quux);\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux\");\n  movedQuux = String::createFromAscii(rt, \"quux2\");\n  EXPECT_EQ(movedQuux.utf8(rt), \"quux2\");\n}\n\nTEST_P(JSITest, ObjectTest) {\n  eval(\"x = {1:2, '3':4, 5:'six', 'seven':['eight', 'nine']}\");\n  Object x = rt.global().getPropertyAsObject(rt, \"x\");\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 4);\n  EXPECT_TRUE(x.hasProperty(rt, \"1\"));\n  EXPECT_TRUE(x.hasProperty(rt, PropNameID::forAscii(rt, \"1\")));\n  EXPECT_FALSE(x.hasProperty(rt, \"2\"));\n  EXPECT_FALSE(x.hasProperty(rt, PropNameID::forAscii(rt, \"2\")));\n  EXPECT_TRUE(x.hasProperty(rt, \"3\"));\n  EXPECT_TRUE(x.hasProperty(rt, PropNameID::forAscii(rt, \"3\")));\n  EXPECT_TRUE(x.hasProperty(rt, \"seven\"));\n  EXPECT_TRUE(x.hasProperty(rt, PropNameID::forAscii(rt, \"seven\")));\n  EXPECT_EQ(x.getProperty(rt, \"1\").getNumber(), 2);\n  EXPECT_EQ(x.getProperty(rt, PropNameID::forAscii(rt, \"1\")).getNumber(), 2);\n  EXPECT_EQ(x.getProperty(rt, \"3\").getNumber(), 4);\n  Value five = 5;\n  EXPECT_EQ(\n      x.getProperty(rt, PropNameID::forString(rt, five.toString(rt)))\n          .getString(rt)\n          .utf8(rt),\n      \"six\");\n\n  x.setProperty(rt, \"ten\", 11);\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 5);\n  EXPECT_TRUE(eval(\"x.ten == 11\").getBool());\n\n  x.setProperty(rt, \"e_as_float\", 2.71f);\n  EXPECT_TRUE(eval(\"Math.abs(x.e_as_float - 2.71) < 0.001\").getBool());\n\n  x.setProperty(rt, \"e_as_double\", 2.71);\n  EXPECT_TRUE(eval(\"x.e_as_double == 2.71\").getBool());\n\n  uint8_t utf8[] = {0xF0, 0x9F, 0x86, 0x97};\n  String nonAsciiName = String::createFromUtf8(rt, utf8, sizeof(utf8));\n  x.setProperty(rt, PropNameID::forString(rt, nonAsciiName), \"emoji\");\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 8);\n  EXPECT_TRUE(eval(\"x['\\\\uD83C\\\\uDD97'] == 'emoji'\").getBool());\n\n  Object seven = x.getPropertyAsObject(rt, \"seven\");\n  EXPECT_TRUE(seven.isArray(rt));\n  Object evalf = rt.global().getPropertyAsObject(rt, \"eval\");\n  EXPECT_TRUE(evalf.isFunction(rt));\n\n  Object movedX = Object(rt);\n  movedX = std::move(x);\n  EXPECT_EQ(movedX.getPropertyNames(rt).size(rt), 8);\n  EXPECT_EQ(movedX.getProperty(rt, \"1\").getNumber(), 2);\n\n  Object obj = Object(rt);\n  obj.setProperty(rt, \"roses\", \"red\");\n  obj.setProperty(rt, \"violets\", \"blue\");\n  Object oprop = Object(rt);\n  obj.setProperty(rt, \"oprop\", oprop);\n  obj.setProperty(rt, \"aprop\", Array(rt, 1));\n\n  EXPECT_TRUE(function(\"function (obj) { return \"\n                       \"obj.roses == 'red' && \"\n                       \"obj['violets'] == 'blue' && \"\n                       \"typeof obj.oprop == 'object' && \"\n                       \"Array.isArray(obj.aprop); }\")\n                  .call(rt, obj)\n                  .getBool());\n\n  // Check that getPropertyNames doesn't return non-enumerable\n  // properties.\n  obj = function(\n            \"function () {\"\n            \"  obj = {};\"\n            \"  obj.a = 1;\"\n            \"  Object.defineProperty(obj, 'b', {\"\n            \"    enumerable: false,\"\n            \"    value: 2\"\n            \"  });\"\n            \"  return obj;\"\n            \"}\")\n            .call(rt)\n            .getObject(rt);\n  EXPECT_EQ(obj.getProperty(rt, \"a\").getNumber(), 1);\n  EXPECT_EQ(obj.getProperty(rt, \"b\").getNumber(), 2);\n  Array names = obj.getPropertyNames(rt);\n  EXPECT_EQ(names.size(rt), 1);\n  EXPECT_EQ(names.getValueAtIndex(rt, 0).getString(rt).utf8(rt), \"a\");\n}\n\nTEST_P(JSITest, HostObjectTest) {\n  class ConstantHostObject : public HostObject {\n    Value get(Runtime&, const PropNameID& sym) override {\n      return 9000;\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n\n  Object cho =\n      Object::createFromHostObject(rt, std::make_shared<ConstantHostObject>());\n  EXPECT_TRUE(function(\"function (obj) { return obj.someRandomProp == 9000; }\")\n                  .call(rt, cho)\n                  .getBool());\n  EXPECT_TRUE(cho.isHostObject(rt));\n  EXPECT_TRUE(cho.getHostObject<ConstantHostObject>(rt).get() != nullptr);\n\n  struct SameRuntimeHostObject : HostObject {\n    SameRuntimeHostObject(Runtime& rt) : rt_(rt){};\n\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      EXPECT_EQ(&rt, &rt_);\n      return Value();\n    }\n\n    void set(Runtime& rt, const PropNameID& name, const Value& value) override {\n      EXPECT_EQ(&rt, &rt_);\n    }\n\n    std::vector<PropNameID> getPropertyNames(Runtime& rt) override {\n      EXPECT_EQ(&rt, &rt_);\n      return {};\n    }\n\n    Runtime& rt_;\n  };\n\n  Object srho = Object::createFromHostObject(\n      rt, std::make_shared<SameRuntimeHostObject>(rt));\n  // Test get's Runtime is as expected\n  function(\"function (obj) { return obj.isSame; }\").call(rt, srho);\n  // ... and set\n  function(\"function (obj) { obj['k'] = 'v'; }\").call(rt, srho);\n  // ... and getPropertyNames\n  function(\"function (obj) { for (k in obj) {} }\").call(rt, srho);\n\n  class TwiceHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      return String::createFromUtf8(rt, sym.utf8(rt) + sym.utf8(rt));\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n\n  Object tho =\n      Object::createFromHostObject(rt, std::make_shared<TwiceHostObject>());\n  EXPECT_TRUE(function(\"function (obj) { return obj.abc == 'abcabc'; }\")\n                  .call(rt, tho)\n                  .getBool());\n  EXPECT_TRUE(function(\"function (obj) { return obj['def'] == 'defdef'; }\")\n                  .call(rt, tho)\n                  .getBool());\n  EXPECT_TRUE(function(\"function (obj) { return obj[12] === '1212'; }\")\n                  .call(rt, tho)\n                  .getBool());\n  EXPECT_TRUE(tho.isHostObject(rt));\n  EXPECT_TRUE(\n      std::dynamic_pointer_cast<ConstantHostObject>(tho.getHostObject(rt)) ==\n      nullptr);\n  EXPECT_TRUE(tho.getHostObject<TwiceHostObject>(rt).get() != nullptr);\n\n  class PropNameIDHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      if (PropNameID::compare(rt, sym, PropNameID::forAscii(rt, \"undef\"))) {\n        return Value::undefined();\n      } else {\n        return PropNameID::compare(\n            rt, sym, PropNameID::forAscii(rt, \"somesymbol\"));\n      }\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n\n  Object sho = Object::createFromHostObject(\n      rt, std::make_shared<PropNameIDHostObject>());\n  EXPECT_TRUE(sho.isHostObject(rt));\n  EXPECT_TRUE(function(\"function (obj) { return obj.undef; }\")\n                  .call(rt, sho)\n                  .isUndefined());\n  EXPECT_TRUE(function(\"function (obj) { return obj.somesymbol; }\")\n                  .call(rt, sho)\n                  .getBool());\n  EXPECT_FALSE(function(\"function (obj) { return obj.notsomuch; }\")\n                   .call(rt, sho)\n                   .getBool());\n\n  class BagHostObject : public HostObject {\n   public:\n    const std::string& getThing() {\n      return bag_[\"thing\"];\n    }\n\n   private:\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      if (sym.utf8(rt) == \"thing\") {\n        return String::createFromUtf8(rt, bag_[sym.utf8(rt)]);\n      }\n      return Value::undefined();\n    }\n\n    void set(Runtime& rt, const PropNameID& sym, const Value& val) override {\n      std::string key(sym.utf8(rt));\n      if (key == \"thing\") {\n        bag_[key] = val.toString(rt).utf8(rt);\n      }\n    }\n\n    std::unordered_map<std::string, std::string> bag_;\n  };\n\n  std::shared_ptr<BagHostObject> shbho = std::make_shared<BagHostObject>();\n  Object bho = Object::createFromHostObject(rt, shbho);\n  EXPECT_TRUE(bho.isHostObject(rt));\n  EXPECT_TRUE(function(\"function (obj) { return obj.undef; }\")\n                  .call(rt, bho)\n                  .isUndefined());\n  EXPECT_EQ(\n      function(\"function (obj) { obj.thing = 'hello'; return obj.thing; }\")\n          .call(rt, bho)\n          .toString(rt)\n          .utf8(rt),\n      \"hello\");\n  EXPECT_EQ(shbho->getThing(), \"hello\");\n\n  class ThrowingHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      throw std::runtime_error(\"Cannot get\");\n    }\n\n    void set(Runtime& rt, const PropNameID& sym, const Value& val) override {\n      throw std::runtime_error(\"Cannot set\");\n    }\n  };\n\n  Object thro =\n      Object::createFromHostObject(rt, std::make_shared<ThrowingHostObject>());\n  EXPECT_TRUE(thro.isHostObject(rt));\n  std::string exc;\n  try {\n    function(\"function (obj) { return obj.thing; }\").call(rt, thro);\n  } catch (const JSError& ex) {\n    exc = ex.what();\n  }\n  EXPECT_NE(exc.find(\"Cannot get\"), std::string::npos);\n  exc = \"\";\n  try {\n    function(\"function (obj) { obj.thing = 'hello'; }\").call(rt, thro);\n  } catch (const JSError& ex) {\n    exc = ex.what();\n  }\n  EXPECT_NE(exc.find(\"Cannot set\"), std::string::npos);\n\n  class NopHostObject : public HostObject {};\n  Object nopHo =\n      Object::createFromHostObject(rt, std::make_shared<NopHostObject>());\n  EXPECT_TRUE(nopHo.isHostObject(rt));\n  EXPECT_TRUE(function(\"function (obj) { return obj.thing; }\")\n                  .call(rt, nopHo)\n                  .isUndefined());\n\n  std::string nopExc;\n  try {\n    function(\"function (obj) { obj.thing = 'pika'; }\").call(rt, nopHo);\n  } catch (const JSError& ex) {\n    nopExc = ex.what();\n  }\n  EXPECT_NE(nopExc.find(\"TypeError: \"), std::string::npos);\n\n  class HostObjectWithPropertyNames : public HostObject {\n    std::vector<PropNameID> getPropertyNames(Runtime& rt) override {\n      return PropNameID::names(\n          rt, \"a_prop\", \"1\", \"false\", \"a_prop\", \"3\", \"c_prop\");\n    }\n  };\n\n  Object howpn = Object::createFromHostObject(\n      rt, std::make_shared<HostObjectWithPropertyNames>());\n  EXPECT_TRUE(\n      function(\n          \"function (o) { return Object.getOwnPropertyNames(o).length == 5 }\")\n          .call(rt, howpn)\n          .getBool());\n\n  auto hasOwnPropertyName = function(\n      \"function (o, p) {\"\n      \"  return Object.getOwnPropertyNames(o).indexOf(p) >= 0\"\n      \"}\");\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"a_prop\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"1\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"false\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"3\"))\n          .getBool());\n  EXPECT_TRUE(\n      hasOwnPropertyName.call(rt, howpn, String::createFromAscii(rt, \"c_prop\"))\n          .getBool());\n  EXPECT_FALSE(hasOwnPropertyName\n                   .call(rt, howpn, String::createFromAscii(rt, \"not_existing\"))\n                   .getBool());\n}\n\nTEST_P(JSITest, HostObjectProtoTest) {\n  class ProtoHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID&) override {\n      return String::createFromAscii(rt, \"phoprop\");\n    }\n  };\n\n  rt.global().setProperty(\n      rt,\n      \"pho\",\n      Object::createFromHostObject(rt, std::make_shared<ProtoHostObject>()));\n\n  EXPECT_EQ(\n      eval(\"({__proto__: pho})[Symbol.toPrimitive]\").getString(rt).utf8(rt),\n      \"phoprop\");\n}\n\nTEST_P(JSITest, ArrayTest) {\n  eval(\"x = {1:2, '3':4, 5:'six', 'seven':['eight', 'nine']}\");\n\n  Object x = rt.global().getPropertyAsObject(rt, \"x\");\n  Array names = x.getPropertyNames(rt);\n  EXPECT_EQ(names.size(rt), 4);\n  std::unordered_set<std::string> strNames;\n  for (size_t i = 0; i < names.size(rt); ++i) {\n    Value n = names.getValueAtIndex(rt, i);\n    EXPECT_TRUE(n.isString());\n    strNames.insert(n.getString(rt).utf8(rt));\n  }\n\n  EXPECT_EQ(strNames.size(), 4);\n  EXPECT_EQ(strNames.count(\"1\"), 1);\n  EXPECT_EQ(strNames.count(\"3\"), 1);\n  EXPECT_EQ(strNames.count(\"5\"), 1);\n  EXPECT_EQ(strNames.count(\"seven\"), 1);\n\n  Object seven = x.getPropertyAsObject(rt, \"seven\");\n  Array arr = seven.getArray(rt);\n\n  EXPECT_EQ(arr.size(rt), 2);\n  EXPECT_EQ(arr.getValueAtIndex(rt, 0).getString(rt).utf8(rt), \"eight\");\n  EXPECT_EQ(arr.getValueAtIndex(rt, 1).getString(rt).utf8(rt), \"nine\");\n  // TODO: test out of range\n\n  EXPECT_EQ(x.getPropertyAsObject(rt, \"seven\").getArray(rt).size(rt), 2);\n\n  // Check that property access with both symbols and strings can access\n  // array values.\n  EXPECT_EQ(seven.getProperty(rt, \"0\").getString(rt).utf8(rt), \"eight\");\n  EXPECT_EQ(seven.getProperty(rt, \"1\").getString(rt).utf8(rt), \"nine\");\n  seven.setProperty(rt, \"1\", \"modified\");\n  EXPECT_EQ(seven.getProperty(rt, \"1\").getString(rt).utf8(rt), \"modified\");\n  EXPECT_EQ(arr.getValueAtIndex(rt, 1).getString(rt).utf8(rt), \"modified\");\n  EXPECT_EQ(\n      seven.getProperty(rt, PropNameID::forAscii(rt, \"0\"))\n          .getString(rt)\n          .utf8(rt),\n      \"eight\");\n  seven.setProperty(rt, PropNameID::forAscii(rt, \"0\"), \"modified2\");\n  EXPECT_EQ(arr.getValueAtIndex(rt, 0).getString(rt).utf8(rt), \"modified2\");\n\n  Array alpha = Array(rt, 4);\n  EXPECT_TRUE(alpha.getValueAtIndex(rt, 0).isUndefined());\n  EXPECT_TRUE(alpha.getValueAtIndex(rt, 3).isUndefined());\n  EXPECT_EQ(alpha.size(rt), 4);\n  alpha.setValueAtIndex(rt, 0, \"a\");\n  alpha.setValueAtIndex(rt, 1, \"b\");\n  EXPECT_EQ(alpha.length(rt), 4);\n  alpha.setValueAtIndex(rt, 2, \"c\");\n  alpha.setValueAtIndex(rt, 3, \"d\");\n  EXPECT_EQ(alpha.size(rt), 4);\n\n  EXPECT_TRUE(\n      function(\n          \"function (arr) { return \"\n          \"arr.length == 4 && \"\n          \"['a','b','c','d'].every(function(v,i) { return v === arr[i]}); }\")\n          .call(rt, alpha)\n          .getBool());\n\n  Array alpha2 = Array(rt, 1);\n  alpha2 = std::move(alpha);\n  EXPECT_EQ(alpha2.size(rt), 4);\n}\n\nTEST_P(JSITest, FunctionTest) {\n  // test move ctor\n  Function fmove = function(\"function() { return 1 }\");\n  {\n    Function g = function(\"function() { return 2 }\");\n    fmove = std::move(g);\n  }\n  EXPECT_EQ(fmove.call(rt).getNumber(), 2);\n\n  // This tests all the function argument converters, and all the\n  // non-lvalue overloads of call().\n  Function f = function(\n      \"function(n, b, d, df, i, s1, s2, s3, s_sun, s_bad, o, a, f, v) { \"\n      \"return \"\n      \"n === null && \"\n      \"b === true && \"\n      \"d === 3.14 && \"\n      \"Math.abs(df - 2.71) < 0.001 && \"\n      \"i === 17 && \"\n      \"s1 == 's1' && \"\n      \"s2 == 's2' && \"\n      \"s3 == 's3' && \"\n      \"s_sun == 's\\\\u2600' && \"\n      \"typeof s_bad == 'string' && \"\n      \"typeof o == 'object' && \"\n      \"Array.isArray(a) && \"\n      \"typeof f == 'function' && \"\n      \"v == 42 }\");\n  EXPECT_TRUE(f.call(\n                   rt,\n                   nullptr,\n                   true,\n                   3.14,\n                   2.71f,\n                   17,\n                   \"s1\",\n                   String::createFromAscii(rt, \"s2\"),\n                   std::string{\"s3\"},\n                   std::string{u8\"s\\u2600\"},\n                   // invalid UTF8 sequence due to unexpected continuation byte\n                   std::string{\"s\\x80\"},\n                   Object(rt),\n                   Array(rt, 1),\n                   function(\"function(){}\"),\n                   Value(42))\n                  .getBool());\n\n  // lvalue overloads of call()\n  Function flv = function(\n      \"function(s, o, a, f, v) { return \"\n      \"s == 's' && \"\n      \"typeof o == 'object' && \"\n      \"Array.isArray(a) && \"\n      \"typeof f == 'function' && \"\n      \"v == 42 }\");\n\n  String s = String::createFromAscii(rt, \"s\");\n  Object o = Object(rt);\n  Array a = Array(rt, 1);\n  Value v = 42;\n  EXPECT_TRUE(flv.call(rt, s, o, a, f, v).getBool());\n\n  Function f1 = function(\"function() { return 1; }\");\n  Function f2 = function(\"function() { return 2; }\");\n  f2 = std::move(f1);\n  EXPECT_EQ(f2.call(rt).getNumber(), 1);\n}\n\nTEST_P(JSITest, FunctionThisTest) {\n  Function checkPropertyFunction =\n      function(\"function() { return this.a === 'a_property' }\");\n\n  Object jsObject = Object(rt);\n  jsObject.setProperty(rt, \"a\", String::createFromUtf8(rt, \"a_property\"));\n\n  class APropertyHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID& sym) override {\n      return String::createFromUtf8(rt, \"a_property\");\n    }\n\n    void set(Runtime&, const PropNameID&, const Value&) override {}\n  };\n  Object hostObject =\n      Object::createFromHostObject(rt, std::make_shared<APropertyHostObject>());\n\n  EXPECT_TRUE(checkPropertyFunction.callWithThis(rt, jsObject).getBool());\n  EXPECT_TRUE(checkPropertyFunction.callWithThis(rt, hostObject).getBool());\n  EXPECT_FALSE(checkPropertyFunction.callWithThis(rt, Array(rt, 5)).getBool());\n  EXPECT_FALSE(checkPropertyFunction.call(rt).getBool());\n}\n\nTEST_P(JSITest, FunctionConstructorTest) {\n  Function ctor = function(\n      \"function (a) {\"\n      \"  if (typeof a !== 'undefined') {\"\n      \"   this.pika = a;\"\n      \"  }\"\n      \"}\");\n  ctor.getProperty(rt, \"prototype\")\n      .getObject(rt)\n      .setProperty(rt, \"pika\", \"chu\");\n  auto empty = ctor.callAsConstructor(rt);\n  EXPECT_TRUE(empty.isObject());\n  auto emptyObj = std::move(empty).getObject(rt);\n  EXPECT_EQ(emptyObj.getProperty(rt, \"pika\").getString(rt).utf8(rt), \"chu\");\n  auto who = ctor.callAsConstructor(rt, \"who\");\n  EXPECT_TRUE(who.isObject());\n  auto whoObj = std::move(who).getObject(rt);\n  EXPECT_EQ(whoObj.getProperty(rt, \"pika\").getString(rt).utf8(rt), \"who\");\n\n  auto instanceof = function(\"function (o, b) { return o instanceof b; }\");\n  EXPECT_TRUE(instanceof.call(rt, emptyObj, ctor).getBool());\n  EXPECT_TRUE(instanceof.call(rt, whoObj, ctor).getBool());\n\n  auto dateCtor = rt.global().getPropertyAsFunction(rt, \"Date\");\n  auto date = dateCtor.callAsConstructor(rt);\n  EXPECT_TRUE(date.isObject());\n  EXPECT_TRUE(instanceof.call(rt, date, dateCtor).getBool());\n  // Sleep for 50 milliseconds\n  std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  EXPECT_GE(\n      function(\"function (d) { return (new Date()).getTime() - d.getTime(); }\")\n          .call(rt, date)\n          .getNumber(),\n      50);\n}\n\nTEST_P(JSITest, InstanceOfTest) {\n  auto ctor = function(\"function Rick() { this.say = 'wubalubadubdub'; }\");\n  auto newObj = function(\"function (ctor) { return new ctor(); }\");\n  auto instance = newObj.call(rt, ctor).getObject(rt);\n  EXPECT_TRUE(instance.instanceOf(rt, ctor));\n  EXPECT_EQ(\n      instance.getProperty(rt, \"say\").getString(rt).utf8(rt), \"wubalubadubdub\");\n  EXPECT_FALSE(Object(rt).instanceOf(rt, ctor));\n  EXPECT_TRUE(ctor.callAsConstructor(rt, nullptr, 0)\n                  .getObject(rt)\n                  .instanceOf(rt, ctor));\n}\n\nTEST_P(JSITest, HostFunctionTest) {\n  auto one = std::make_shared<int>(1);\n  Function plusOne = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"plusOne\"),\n      2,\n      [one, savedRt = &rt](\n          Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        EXPECT_EQ(savedRt, &rt);\n        // We don't know if we're in strict mode or not, so it's either global\n        // or undefined.\n        EXPECT_TRUE(\n            Value::strictEquals(rt, thisVal, rt.global()) ||\n            thisVal.isUndefined());\n        return *one + args[0].getNumber() + args[1].getNumber();\n      });\n\n  EXPECT_EQ(plusOne.call(rt, 1, 2).getNumber(), 4);\n  EXPECT_TRUE(checkValue(plusOne.call(rt, 3, 5), \"9\"));\n  rt.global().setProperty(rt, \"plusOne\", plusOne);\n  EXPECT_TRUE(eval(\"plusOne(20, 300) == 321\").getBool());\n\n  Function dot = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"dot\"),\n      2,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        EXPECT_TRUE(\n            Value::strictEquals(rt, thisVal, rt.global()) ||\n            thisVal.isUndefined());\n        if (count != 2) {\n          throw std::runtime_error(\"expected 2 args\");\n        }\n        std::string ret = args[0].getString(rt).utf8(rt) + \".\" +\n            args[1].getString(rt).utf8(rt);\n        return String::createFromUtf8(\n            rt, reinterpret_cast<const uint8_t*>(ret.data()), ret.size());\n      });\n\n  rt.global().setProperty(rt, \"cons\", dot);\n  EXPECT_TRUE(eval(\"cons('left', 'right') == 'left.right'\").getBool());\n  EXPECT_TRUE(eval(\"cons.name == 'dot'\").getBool());\n  EXPECT_TRUE(eval(\"cons.length == 2\").getBool());\n  EXPECT_TRUE(eval(\"cons instanceof Function\").getBool());\n\n  EXPECT_TRUE(eval(\"(function() {\"\n                   \"  try {\"\n                   \"    cons('fail'); return false;\"\n                   \"  } catch (e) {\"\n                   \"    return ((e instanceof Error) &&\"\n                   \"            (e.message == 'Exception in HostFunction: ' +\"\n                   \"                          'expected 2 args'));\"\n                   \"  }})()\")\n                  .getBool());\n\n  Function coolify = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"coolify\"),\n      0,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        EXPECT_EQ(count, 0);\n        std::string ret = thisVal.toString(rt).utf8(rt) + \" is cool\";\n        return String::createFromUtf8(\n            rt, reinterpret_cast<const uint8_t*>(ret.data()), ret.size());\n      });\n  rt.global().setProperty(rt, \"coolify\", coolify);\n  EXPECT_TRUE(eval(\"coolify.name == 'coolify'\").getBool());\n  EXPECT_TRUE(eval(\"coolify.length == 0\").getBool());\n  EXPECT_TRUE(eval(\"coolify.bind('R&M')() == 'R&M is cool'\").getBool());\n  EXPECT_TRUE(eval(\"(function() {\"\n                   \"  var s = coolify.bind(function(){})();\"\n                   \"  return s.lastIndexOf(' is cool') == (s.length - 8);\"\n                   \"})()\")\n                  .getBool());\n\n  Function lookAtMe = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"lookAtMe\"),\n      0,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count)\n          -> Value {\n        EXPECT_TRUE(thisVal.isObject());\n        EXPECT_EQ(\n            thisVal.getObject(rt)\n                .getProperty(rt, \"name\")\n                .getString(rt)\n                .utf8(rt),\n            \"mr.meeseeks\");\n        return Value();\n      });\n  rt.global().setProperty(rt, \"lookAtMe\", lookAtMe);\n  EXPECT_TRUE(eval(\"lookAtMe.bind({'name': 'mr.meeseeks'})()\").isUndefined());\n\n  struct Callable {\n    Callable(std::string s) : str(s) {}\n\n    Value\n    operator()(Runtime& rt, const Value&, const Value* args, size_t count) {\n      if (count != 1) {\n        return Value();\n      }\n      return String::createFromUtf8(\n          rt, args[0].toString(rt).utf8(rt) + \" was called with \" + str);\n    }\n\n    std::string str;\n  };\n\n  Function callable = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"callable\"),\n      1,\n      Callable(\"std::function::target\"));\n  EXPECT_EQ(\n      function(\"function (f) { return f('A cat'); }\")\n          .call(rt, callable)\n          .getString(rt)\n          .utf8(rt),\n      \"A cat was called with std::function::target\");\n  EXPECT_TRUE(callable.isHostFunction(rt));\n  EXPECT_NE(callable.getHostFunction(rt).target<Callable>(), nullptr);\n\n  std::string strval = \"strval1\";\n  auto getter = Object(rt);\n  getter.setProperty(\n      rt,\n      \"get\",\n      Function::createFromHostFunction(\n          rt,\n          PropNameID::forAscii(rt, \"getter\"),\n          1,\n          [&strval](\n              Runtime& rt,\n              const Value& thisVal,\n              const Value* args,\n              size_t count) -> Value {\n            return String::createFromUtf8(rt, strval);\n          }));\n  auto obj = Object(rt);\n  rt.global()\n      .getPropertyAsObject(rt, \"Object\")\n      .getPropertyAsFunction(rt, \"defineProperty\")\n      .call(rt, obj, \"prop\", getter);\n  EXPECT_TRUE(function(\"function(value) { return value.prop == 'strval1'; }\")\n                  .call(rt, obj)\n                  .getBool());\n  strval = \"strval2\";\n  EXPECT_TRUE(function(\"function(value) { return value.prop == 'strval2'; }\")\n                  .call(rt, obj)\n                  .getBool());\n}\n\nTEST_P(JSITest, ValueTest) {\n  EXPECT_TRUE(checkValue(Value::undefined(), \"undefined\"));\n  EXPECT_TRUE(checkValue(Value(), \"undefined\"));\n  EXPECT_TRUE(checkValue(Value::null(), \"null\"));\n  EXPECT_TRUE(checkValue(nullptr, \"null\"));\n\n  EXPECT_TRUE(checkValue(Value(false), \"false\"));\n  EXPECT_TRUE(checkValue(false, \"false\"));\n  EXPECT_TRUE(checkValue(true, \"true\"));\n\n  EXPECT_TRUE(checkValue(Value(1.5), \"1.5\"));\n  EXPECT_TRUE(checkValue(2.5, \"2.5\"));\n\n  EXPECT_TRUE(checkValue(Value(10), \"10\"));\n  EXPECT_TRUE(checkValue(20, \"20\"));\n  EXPECT_TRUE(checkValue(30, \"30\"));\n\n  // rvalue implicit conversion\n  EXPECT_TRUE(checkValue(String::createFromAscii(rt, \"one\"), \"'one'\"));\n  // lvalue explicit copy\n  String s = String::createFromAscii(rt, \"two\");\n  EXPECT_TRUE(checkValue(Value(rt, s), \"'two'\"));\n\n  {\n    // rvalue assignment of trivial value\n    Value v1 = 100;\n    Value v2 = String::createFromAscii(rt, \"hundred\");\n    v2 = std::move(v1);\n    EXPECT_TRUE(v2.isNumber());\n    EXPECT_EQ(v2.getNumber(), 100);\n  }\n\n  {\n    // rvalue assignment of js heap value\n    Value v1 = String::createFromAscii(rt, \"hundred\");\n    Value v2 = 100;\n    v2 = std::move(v1);\n    EXPECT_TRUE(v2.isString());\n    EXPECT_EQ(v2.getString(rt).utf8(rt), \"hundred\");\n  }\n\n  Object o = Object(rt);\n  EXPECT_TRUE(function(\"function(value) { return typeof(value) == 'object'; }\")\n                  .call(rt, Value(rt, o))\n                  .getBool());\n\n  uint8_t utf8[] = \"[null, 2, \\\"c\\\", \\\"emoji: \\xf0\\x9f\\x86\\x97\\\", {}]\";\n\n  EXPECT_TRUE(\n      function(\"function (arr) { return \"\n               \"Array.isArray(arr) && \"\n               \"arr.length == 5 && \"\n               \"arr[0] === null && \"\n               \"arr[1] == 2 && \"\n               \"arr[2] == 'c' && \"\n               \"arr[3] == 'emoji: \\\\uD83C\\\\uDD97' && \"\n               \"typeof arr[4] == 'object'; }\")\n          .call(rt, Value::createFromJsonUtf8(rt, utf8, sizeof(utf8) - 1))\n          .getBool());\n\n  EXPECT_TRUE(eval(\"undefined\").isUndefined());\n  EXPECT_TRUE(eval(\"null\").isNull());\n  EXPECT_TRUE(eval(\"true\").isBool());\n  EXPECT_TRUE(eval(\"false\").isBool());\n  EXPECT_TRUE(eval(\"123\").isNumber());\n  EXPECT_TRUE(eval(\"123.4\").isNumber());\n  EXPECT_TRUE(eval(\"'str'\").isString());\n  // \"{}\" returns undefined.  empty code block?\n  EXPECT_TRUE(eval(\"({})\").isObject());\n  EXPECT_TRUE(eval(\"[]\").isObject());\n  EXPECT_TRUE(eval(\"(function(){})\").isObject());\n\n  EXPECT_EQ(eval(\"123\").getNumber(), 123);\n  EXPECT_EQ(eval(\"123.4\").getNumber(), 123.4);\n  EXPECT_EQ(eval(\"'str'\").getString(rt).utf8(rt), \"str\");\n  EXPECT_TRUE(eval(\"[]\").getObject(rt).isArray(rt));\n\n  EXPECT_EQ(eval(\"456\").asNumber(), 456);\n  EXPECT_THROW(eval(\"'word'\").asNumber(), JSIException);\n  EXPECT_EQ(\n      eval(\"({1:2, 3:4})\").asObject(rt).getProperty(rt, \"1\").getNumber(), 2);\n  EXPECT_THROW(eval(\"'oops'\").asObject(rt), JSIException);\n\n  EXPECT_EQ(eval(\"['zero',1,2,3]\").toString(rt).utf8(rt), \"zero,1,2,3\");\n}\n\nTEST_P(JSITest, EqualsTest) {\n  EXPECT_TRUE(Object::strictEquals(rt, rt.global(), rt.global()));\n  EXPECT_TRUE(Value::strictEquals(rt, 1, 1));\n  EXPECT_FALSE(Value::strictEquals(rt, true, 1));\n  EXPECT_FALSE(Value::strictEquals(rt, true, false));\n  EXPECT_TRUE(Value::strictEquals(rt, false, false));\n  EXPECT_FALSE(Value::strictEquals(rt, nullptr, 1));\n  EXPECT_TRUE(Value::strictEquals(rt, nullptr, nullptr));\n  EXPECT_TRUE(Value::strictEquals(rt, Value::undefined(), Value()));\n  EXPECT_TRUE(Value::strictEquals(rt, rt.global(), Value(rt.global())));\n  EXPECT_FALSE(Value::strictEquals(\n      rt,\n      std::numeric_limits<double>::quiet_NaN(),\n      std::numeric_limits<double>::quiet_NaN()));\n  EXPECT_FALSE(Value::strictEquals(\n      rt,\n      std::numeric_limits<double>::signaling_NaN(),\n      std::numeric_limits<double>::signaling_NaN()));\n  EXPECT_TRUE(Value::strictEquals(rt, +0.0, -0.0));\n  EXPECT_TRUE(Value::strictEquals(rt, -0.0, +0.0));\n\n  Function noop = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"noop\"),\n      0,\n      [](const Runtime&, const Value&, const Value*, size_t) {\n        return Value();\n      });\n  auto noopDup = Value(rt, noop).getObject(rt);\n  EXPECT_TRUE(Object::strictEquals(rt, noop, noopDup));\n  EXPECT_TRUE(Object::strictEquals(rt, noopDup, noop));\n  EXPECT_FALSE(Object::strictEquals(rt, noop, rt.global()));\n  EXPECT_TRUE(Object::strictEquals(rt, noop, noop));\n  EXPECT_TRUE(Value::strictEquals(rt, Value(rt, noop), Value(rt, noop)));\n\n  String str = String::createFromAscii(rt, \"rick\");\n  String strDup = String::createFromAscii(rt, \"rick\");\n  String otherStr = String::createFromAscii(rt, \"morty\");\n  EXPECT_TRUE(String::strictEquals(rt, str, str));\n  EXPECT_TRUE(String::strictEquals(rt, str, strDup));\n  EXPECT_TRUE(String::strictEquals(rt, strDup, str));\n  EXPECT_FALSE(String::strictEquals(rt, str, otherStr));\n  EXPECT_TRUE(Value::strictEquals(rt, Value(rt, str), Value(rt, str)));\n  EXPECT_FALSE(Value::strictEquals(rt, Value(rt, str), Value(rt, noop)));\n  EXPECT_FALSE(Value::strictEquals(rt, Value(rt, str), 1.0));\n}\n\nTEST_P(JSITest, ExceptionStackTraceTest) {\n  static const char invokeUndefinedScript[] =\n      \"function hello() {\"\n      \"  var a = {}; a.log(); }\"\n      \"function world() { hello(); }\"\n      \"world()\";\n  std::string stack;\n  try {\n    rt.evaluateJavaScript(\n        std::make_unique<StringBuffer>(invokeUndefinedScript), \"\");\n  } catch (JSError& e) {\n    stack = e.getStack();\n  }\n  EXPECT_NE(stack.find(\"world\"), std::string::npos);\n}\n\nTEST_P(JSITest, PreparedJavaScriptSourceTest) {\n  rt.evaluateJavaScript(std::make_unique<StringBuffer>(\"var q = 0;\"), \"\");\n  auto prep = rt.prepareJavaScript(std::make_unique<StringBuffer>(\"q++;\"), \"\");\n  EXPECT_EQ(rt.global().getProperty(rt, \"q\").getNumber(), 0);\n  rt.evaluatePreparedJavaScript(prep);\n  EXPECT_EQ(rt.global().getProperty(rt, \"q\").getNumber(), 1);\n  rt.evaluatePreparedJavaScript(prep);\n  EXPECT_EQ(rt.global().getProperty(rt, \"q\").getNumber(), 2);\n}\n\nTEST_P(JSITest, PreparedJavaScriptURLInBacktrace) {\n  std::string sourceURL = \"//PreparedJavaScriptURLInBacktrace/Test/URL\";\n  std::string throwingSource =\n      \"function thrower() { throw new Error('oops')}\"\n      \"thrower();\";\n  auto prep = rt.prepareJavaScript(\n      std::make_unique<StringBuffer>(throwingSource), sourceURL);\n  try {\n    rt.evaluatePreparedJavaScript(prep);\n    FAIL() << \"prepareJavaScript should have thrown an exception\";\n  } catch (facebook::jsi::JSError err) {\n    EXPECT_NE(std::string::npos, err.getStack().find(sourceURL))\n        << \"Backtrace should contain source URL\";\n  }\n}\n\nnamespace {\n\nunsigned countOccurences(const std::string& of, const std::string& in) {\n  unsigned occurences = 0;\n  std::string::size_type lastOccurence = -1;\n  while ((lastOccurence = in.find(of, lastOccurence + 1)) !=\n         std::string::npos) {\n    occurences++;\n  }\n  return occurences;\n}\n\n} // namespace\n\nTEST_P(JSITest, JSErrorsArePropagatedNicely) {\n  unsigned callsBeforeError = 5;\n\n  Function sometimesThrows = function(\n      \"function sometimesThrows(shouldThrow, callback) {\"\n      \"  if (shouldThrow) {\"\n      \"    throw Error('Omg, what a nasty exception')\"\n      \"  }\"\n      \"  callback(callback);\"\n      \"}\");\n\n  Function callback = Function::createFromHostFunction(\n      rt,\n      PropNameID::forAscii(rt, \"callback\"),\n      0,\n      [&sometimesThrows, &callsBeforeError](\n          Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        return sometimesThrows.call(rt, --callsBeforeError == 0, args[0]);\n      });\n\n  try {\n    sometimesThrows.call(rt, false, callback);\n  } catch (JSError& error) {\n    EXPECT_EQ(error.getMessage(), \"Omg, what a nasty exception\");\n    EXPECT_EQ(countOccurences(\"sometimesThrows\", error.getStack()), 6);\n\n    // system JSC JSI does not implement host function names\n    // EXPECT_EQ(countOccurences(\"callback\", error.getStack(rt)), 5);\n  }\n}\n\nTEST_P(JSITest, JSErrorsCanBeConstructedWithStack) {\n  auto err = JSError(rt, \"message\", \"stack\");\n  EXPECT_EQ(err.getMessage(), \"message\");\n  EXPECT_EQ(err.getStack(), \"stack\");\n}\n\nTEST_P(JSITest, JSErrorDoesNotInfinitelyRecurse) {\n  Value globalError = rt.global().getProperty(rt, \"Error\");\n  rt.global().setProperty(rt, \"Error\", Value::undefined());\n  try {\n    rt.global().getPropertyAsFunction(rt, \"NotAFunction\");\n    FAIL() << \"expected exception\";\n  } catch (const JSError& ex) {\n    EXPECT_EQ(\n        ex.getMessage(),\n        \"callGlobalFunction: JS global property 'Error' is undefined, \"\n        \"expected a Function (while raising getPropertyAsObject: \"\n        \"property 'NotAFunction' is undefined, expected an Object)\");\n  }\n\n  // If Error is missing, this is fundamentally a problem with JS code\n  // messing up the global object, so it should present in JS code as\n  // a catchable string.  Not an Error (because that's broken), or as\n  // a C++ failure.\n\n  auto fails = [](Runtime& rt, const Value&, const Value*, size_t) -> Value {\n    return rt.global().getPropertyAsObject(rt, \"NotAProperty\");\n  };\n  EXPECT_EQ(\n      function(\"function (f) { try { f(); return 'undefined'; }\"\n               \"catch (e) { return typeof e; } }\")\n          .call(\n              rt,\n              Function::createFromHostFunction(\n                  rt, PropNameID::forAscii(rt, \"fails\"), 0, fails))\n          .getString(rt)\n          .utf8(rt),\n      \"string\");\n\n  rt.global().setProperty(rt, \"Error\", globalError);\n}\n\nTEST_P(JSITest, JSErrorStackOverflowHandling) {\n  rt.global().setProperty(\n      rt,\n      \"callSomething\",\n      Function::createFromHostFunction(\n          rt,\n          PropNameID::forAscii(rt, \"callSomething\"),\n          0,\n          [this](\n              Runtime& rt2,\n              const Value& thisVal,\n              const Value* args,\n              size_t count) {\n            EXPECT_EQ(&rt, &rt2);\n            return function(\"function() { return 0; }\").call(rt);\n          }));\n  try {\n    eval(\"(function f() { callSomething(); f.apply(); })()\");\n    FAIL();\n  } catch (const JSError& ex) {\n    EXPECT_NE(std::string(ex.what()).find(\"exceeded\"), std::string::npos);\n  }\n}\n\nTEST_P(JSITest, ScopeDoesNotCrashTest) {\n  Scope scope(rt);\n  Object o(rt);\n}\n\nTEST_P(JSITest, ScopeDoesNotCrashWhenValueEscapes) {\n  Value v;\n  Scope::callInNewScope(rt, [&]() {\n    Object o(rt);\n    o.setProperty(rt, \"a\", 5);\n    v = std::move(o);\n  });\n  EXPECT_EQ(v.getObject(rt).getProperty(rt, \"a\").getNumber(), 5);\n}\n\n// Verifies you can have a host object that emulates a normal object\nTEST_P(JSITest, HostObjectWithValueMembers) {\n  class Bag : public HostObject {\n   public:\n    Bag() = default;\n\n    const Value& operator[](const std::string& name) const {\n      auto iter = data_.find(name);\n      if (iter == data_.end()) {\n        return undef_;\n      }\n      return iter->second;\n    }\n\n   protected:\n    Value get(Runtime& rt, const PropNameID& name) override {\n      return Value(rt, (*this)[name.utf8(rt)]);\n    }\n\n    void set(Runtime& rt, const PropNameID& name, const Value& val) override {\n      data_.emplace(name.utf8(rt), Value(rt, val));\n    }\n\n    Value undef_;\n    std::map<std::string, Value> data_;\n  };\n\n  auto sharedBag = std::make_shared<Bag>();\n  auto& bag = *sharedBag;\n  Object jsbag = Object::createFromHostObject(rt, std::move(sharedBag));\n  auto set = function(\n      \"function (o) {\"\n      \"  o.foo = 'bar';\"\n      \"  o.count = 37;\"\n      \"  o.nul = null;\"\n      \"  o.iscool = true;\"\n      \"  o.obj = { 'foo': 'bar' };\"\n      \"}\");\n  set.call(rt, jsbag);\n  auto checkFoo = function(\"function (o) { return o.foo === 'bar'; }\");\n  auto checkCount = function(\"function (o) { return o.count === 37; }\");\n  auto checkNul = function(\"function (o) { return o.nul === null; }\");\n  auto checkIsCool = function(\"function (o) { return o.iscool === true; }\");\n  auto checkObj = function(\n      \"function (o) {\"\n      \"  return (typeof o.obj) === 'object' && o.obj.foo === 'bar';\"\n      \"}\");\n  // Check this looks good from js\n  EXPECT_TRUE(checkFoo.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkCount.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkNul.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkIsCool.call(rt, jsbag).getBool());\n  EXPECT_TRUE(checkObj.call(rt, jsbag).getBool());\n\n  // Check this looks good from c++\n  EXPECT_EQ(bag[\"foo\"].getString(rt).utf8(rt), \"bar\");\n  EXPECT_EQ(bag[\"count\"].getNumber(), 37);\n  EXPECT_TRUE(bag[\"nul\"].isNull());\n  EXPECT_TRUE(bag[\"iscool\"].getBool());\n  EXPECT_EQ(\n      bag[\"obj\"].getObject(rt).getProperty(rt, \"foo\").getString(rt).utf8(rt),\n      \"bar\");\n}\n\nTEST_P(JSITest, DecoratorTest) {\n  struct Count {\n    // init here is just to show that a With type does not need to be\n    // default constructible.\n    explicit Count(int init) : count(init) {}\n\n    // Test optional before method.\n\n    void after() {\n      ++count;\n    }\n\n    int count;\n  };\n\n  static constexpr int kInit = 17;\n\n  class CountRuntime final : public WithRuntimeDecorator<Count> {\n   public:\n    explicit CountRuntime(std::unique_ptr<Runtime> rt)\n        : WithRuntimeDecorator<Count>(*rt, count_),\n          rt_(std::move(rt)),\n          count_(kInit) {}\n\n    int count() {\n      return count_.count;\n    }\n\n   private:\n    std::unique_ptr<Runtime> rt_;\n    Count count_;\n  };\n\n  CountRuntime crt(factory());\n\n  crt.description();\n  EXPECT_EQ(crt.count(), kInit + 1);\n\n  crt.global().setProperty(crt, \"o\", Object(crt));\n  EXPECT_EQ(crt.count(), kInit + 6);\n}\n\nTEST_P(JSITest, MultiDecoratorTest) {\n  struct Inc {\n    void before() {\n      ++count;\n    }\n\n    // Test optional after method.\n\n    int count = 0;\n  };\n\n  struct Nest {\n    void before() {\n      ++nest;\n    }\n\n    void after() {\n      --nest;\n    }\n\n    int nest = 0;\n  };\n\n  class MultiRuntime final\n      : public WithRuntimeDecorator<std::tuple<Inc, Nest>> {\n   public:\n    explicit MultiRuntime(std::unique_ptr<Runtime> rt)\n        : WithRuntimeDecorator<std::tuple<Inc, Nest>>(*rt, tuple_),\n          rt_(std::move(rt)) {}\n\n    int count() {\n      return std::get<0>(tuple_).count;\n    }\n    int nest() {\n      return std::get<1>(tuple_).nest;\n    }\n\n   private:\n    std::unique_ptr<Runtime> rt_;\n    std::tuple<Inc, Nest> tuple_;\n  };\n\n  MultiRuntime mrt(factory());\n\n  Function expectNestOne = Function::createFromHostFunction(\n      mrt,\n      PropNameID::forAscii(mrt, \"expectNestOne\"),\n      0,\n      [](Runtime& rt, const Value& thisVal, const Value* args, size_t count) {\n        MultiRuntime* funcmrt = dynamic_cast<MultiRuntime*>(&rt);\n        EXPECT_NE(funcmrt, nullptr);\n        EXPECT_EQ(funcmrt->count(), 3);\n        EXPECT_EQ(funcmrt->nest(), 1);\n        return Value::undefined();\n      });\n\n  expectNestOne.call(mrt);\n\n  EXPECT_EQ(mrt.count(), 3);\n  EXPECT_EQ(mrt.nest(), 0);\n}\n\nTEST_P(JSITest, SymbolTest) {\n  if (!rt.global().hasProperty(rt, \"Symbol\")) {\n    // Symbol is an es6 feature which doesn't exist in older VMs.  So\n    // the tests which might be elsewhere are all here so they can be\n    // skipped.\n    return;\n  }\n\n  // ObjectTest\n  eval(\"x = {1:2, 'three':Symbol('four')}\");\n  Object x = rt.global().getPropertyAsObject(rt, \"x\");\n  EXPECT_EQ(x.getPropertyNames(rt).size(rt), 2);\n  EXPECT_TRUE(x.hasProperty(rt, \"three\"));\n  EXPECT_EQ(\n      x.getProperty(rt, \"three\").getSymbol(rt).toString(rt), \"Symbol(four)\");\n\n  // ValueTest\n  EXPECT_TRUE(eval(\"Symbol('sym')\").isSymbol());\n  EXPECT_EQ(eval(\"Symbol('sym')\").getSymbol(rt).toString(rt), \"Symbol(sym)\");\n\n  // EqualsTest\n  EXPECT_FALSE(Symbol::strictEquals(\n      rt,\n      eval(\"Symbol('a')\").getSymbol(rt),\n      eval(\"Symbol('a')\").getSymbol(rt)));\n  EXPECT_TRUE(Symbol::strictEquals(\n      rt,\n      eval(\"Symbol.for('a')\").getSymbol(rt),\n      eval(\"Symbol.for('a')\").getSymbol(rt)));\n  EXPECT_FALSE(\n      Value::strictEquals(rt, eval(\"Symbol('a')\"), eval(\"Symbol('a')\")));\n  EXPECT_TRUE(Value::strictEquals(\n      rt, eval(\"Symbol.for('a')\"), eval(\"Symbol.for('a')\")));\n  EXPECT_FALSE(Value::strictEquals(rt, eval(\"Symbol('a')\"), eval(\"'a'\")));\n}\n\nTEST_P(JSITest, JSErrorTest) {\n  // JSError creation can lead to further errors.  Make sure these\n  // cases are handled and don't cause weird crashes or other issues.\n  //\n  // Getting message property can throw\n\n  EXPECT_THROW(\n      eval(\"var GetMessageThrows = {get message() { throw Error('ex'); }};\"\n           \"throw GetMessageThrows;\"),\n      JSIException);\n\n  EXPECT_THROW(\n      eval(\"var GetMessageThrows = {get message() { throw GetMessageThrows; }};\"\n           \"throw GetMessageThrows;\"),\n      JSIException);\n\n  // Converting exception message to String can throw\n\n  EXPECT_THROW(\n      eval(\n          \"Object.defineProperty(\"\n          \"  globalThis, 'String', {configurable:true, get() { var e = Error(); e.message = 23; throw e; }});\"\n          \"var e = Error();\"\n          \"e.message = 17;\"\n          \"throw e;\"),\n      JSIException);\n\n  EXPECT_THROW(\n      eval(\n          \"var e = Error();\"\n          \"Object.defineProperty(\"\n          \"  e, 'message', {configurable:true, get() { throw Error('getter'); }});\"\n          \"throw e;\"),\n      JSIException);\n\n  EXPECT_THROW(\n      eval(\"var e = Error();\"\n           \"String = function() { throw Error('ctor'); };\"\n           \"throw e;\"),\n      JSIException);\n\n  // Converting an exception message to String can return a non-String\n\n  EXPECT_THROW(\n      eval(\"String = function() { return 42; };\"\n           \"var e = Error();\"\n           \"e.message = 17;\"\n           \"throw e;\"),\n      JSIException);\n\n  // Exception can be non-Object\n\n  EXPECT_THROW(eval(\"throw 17;\"), JSIException);\n\n  EXPECT_THROW(eval(\"throw undefined;\"), JSIException);\n\n  // Converting exception with no message or stack property to String can throw\n\n  EXPECT_THROW(\n      eval(\"var e = {toString() { throw new Error('errstr'); }};\"\n           \"throw e;\"),\n      JSIException);\n}\n\n//----------------------------------------------------------------------\n// Test that multiple levels of delegation in DecoratedHostObjects works.\n\nclass RD1 : public RuntimeDecorator<Runtime, Runtime> {\n public:\n  RD1(Runtime& plain) : RuntimeDecorator(plain) {}\n\n  Object createObject(std::shared_ptr<HostObject> ho) {\n    class DHO1 : public DecoratedHostObject {\n     public:\n      using DecoratedHostObject::DecoratedHostObject;\n\n      Value get(Runtime& rt, const PropNameID& name) override {\n        numGets++;\n        return DecoratedHostObject::get(rt, name);\n      }\n    };\n    return Object::createFromHostObject(\n        plain(), std::make_shared<DHO1>(*this, ho));\n  }\n\n  static unsigned numGets;\n};\n\nclass RD2 : public RuntimeDecorator<Runtime, Runtime> {\n public:\n  RD2(Runtime& plain) : RuntimeDecorator(plain) {}\n\n  Object createObject(std::shared_ptr<HostObject> ho) {\n    class DHO2 : public DecoratedHostObject {\n     public:\n      using DecoratedHostObject::DecoratedHostObject;\n\n      Value get(Runtime& rt, const PropNameID& name) override {\n        numGets++;\n        return DecoratedHostObject::get(rt, name);\n      }\n    };\n    return Object::createFromHostObject(\n        plain(), std::make_shared<DHO2>(*this, ho));\n  }\n\n  static unsigned numGets;\n};\n\nclass HO : public HostObject {\n public:\n  explicit HO(Runtime* expectedRT) : expectedRT_(expectedRT) {}\n\n  Value get(Runtime& rt, const PropNameID& name) override {\n    EXPECT_EQ(expectedRT_, &rt);\n    return Value(17.0);\n  }\n\n private:\n  // The runtime we expect to be called with.\n  Runtime* expectedRT_;\n};\n\nunsigned RD1::numGets = 0;\nunsigned RD2::numGets = 0;\n\nTEST_P(JSITest, MultilevelDecoratedHostObject) {\n  // This test will be run for various test instantiations, so initialize these\n  // counters.\n  RD1::numGets = 0;\n  RD2::numGets = 0;\n\n  RD1 rd1(rt);\n  RD2 rd2(rd1);\n  // We expect the \"get\" operation of ho to be called with rd2.\n  auto ho = std::make_shared<HO>(&rd2);\n  auto obj = Object::createFromHostObject(rd2, ho);\n  Value v = obj.getProperty(rd2, \"p\");\n  EXPECT_TRUE(v.isNumber());\n  EXPECT_EQ(17.0, v.asNumber());\n  auto ho2 = obj.getHostObject(rd2);\n  EXPECT_EQ(ho, ho2);\n  EXPECT_EQ(1, RD1::numGets);\n  EXPECT_EQ(1, RD2::numGets);\n}\n\nINSTANTIATE_TEST_CASE_P(\n    Runtimes,\n    JSITest,\n    ::testing::ValuesIn(runtimeGenerators()));\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/VM/JSObject.h\"\n\n#include \"hermes/VM/BuildMetadata.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/HostModel.h\"\n#include \"hermes/VM/InternalProperty.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSDate.h\"\n#include \"hermes/VM/JSProxy.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include \"llvh/ADT/SmallSet.h\"\n\nnamespace hermes {\nnamespace vm {\n\nObjectVTable JSObject::vt{\n    VTable(\n        CellKind::ObjectKind,\n        cellSize<JSObject>(),\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr,\n        nullptr, // externalMemorySize\n        VTable::HeapSnapshotMetadata{HeapSnapshot::NodeType::Object,\n                                     JSObject::_snapshotNameImpl,\n                                     JSObject::_snapshotAddEdgesImpl,\n                                     nullptr,\n                                     JSObject::_snapshotAddLocationsImpl}),\n    JSObject::_getOwnIndexedRangeImpl,\n    JSObject::_haveOwnIndexedImpl,\n    JSObject::_getOwnIndexedPropertyFlagsImpl,\n    JSObject::_getOwnIndexedImpl,\n    JSObject::_setOwnIndexedImpl,\n    JSObject::_deleteOwnIndexedImpl,\n    JSObject::_checkAllOwnIndexedImpl,\n};\n\nvoid ObjectBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  // This call is just for debugging and consistency purposes.\n  mb.addJSObjectOverlapSlots(JSObject::numOverlapSlots<JSObject>());\n\n  const auto *self = static_cast<const JSObject *>(cell);\n  mb.addField(\"parent\", &self->parent_);\n  mb.addField(\"class\", &self->clazz_);\n  mb.addField(\"propStorage\", &self->propStorage_);\n\n  // Declare the direct properties.\n  static const char *directPropName[JSObject::DIRECT_PROPERTY_SLOTS] = {\n      \"directProp0\", \"directProp1\", \"directProp2\", \"directProp3\"};\n  for (unsigned i = mb.getJSObjectOverlapSlots();\n       i < JSObject::DIRECT_PROPERTY_SLOTS;\n       ++i) {\n    mb.addField(directPropName[i], self->directProps() + i);\n  }\n}\n\n#ifdef HERMESVM_SERIALIZE\nvoid JSObject::serializeObjectImpl(\n    Serializer &s,\n    const GCCell *cell,\n    unsigned overlapSlots) {\n  auto *self = vmcast<const JSObject>(cell);\n  s.writeData(&self->flags_, sizeof(ObjectFlags));\n  s.writeRelocation(self->parent_.get(s.getRuntime()));\n  s.writeRelocation(self->clazz_.get(s.getRuntime()));\n  // propStorage_ : GCPointer<PropStorage> is also ArrayStorage. Serialize\n  // *propStorage_ with this JSObject.\n  bool hasArray = (bool)self->propStorage_;\n  s.writeInt<uint8_t>(hasArray);\n  if (hasArray) {\n    ArrayStorage::serializeArrayStorage(\n        s, self->propStorage_.get(s.getRuntime()));\n  }\n\n  // Record the number of overlap slots, so that the deserialization code\n  // doesn't need to keep track of it.\n  s.writeInt<uint8_t>(overlapSlots);\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    s.writeHermesValue(self->directProps()[i]);\n  }\n}\n\nvoid ObjectSerialize(Serializer &s, const GCCell *cell) {\n  JSObject::serializeObjectImpl(s, cell, JSObject::numOverlapSlots<JSObject>());\n  s.endObject(cell);\n}\n\nvoid ObjectDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::ObjectKind && \"Expected JSObject\");\n  void *mem = d.getRuntime()->alloc</*fixedSize*/ true>(cellSize<JSObject>());\n  auto *obj = new (mem) JSObject(d, &JSObject::vt.base);\n\n  d.endObject(obj);\n}\n\nJSObject::JSObject(Deserializer &d, const VTable *vtp)\n    : GCCell(&d.getRuntime()->getHeap(), vtp) {\n  d.readData(&flags_, sizeof(ObjectFlags));\n  d.readRelocation(&parent_, RelocationKind::GCPointer);\n  d.readRelocation(&clazz_, RelocationKind::GCPointer);\n  if (d.readInt<uint8_t>()) {\n    propStorage_.set(\n        d.getRuntime(),\n        ArrayStorage::deserializeArrayStorage(d),\n        &d.getRuntime()->getHeap());\n  }\n\n  auto overlapSlots = d.readInt<uint8_t>();\n  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {\n    d.readHermesValue(&directProps()[i]);\n  }\n}\n#endif\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<JSObject> parentHandle) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      *parentHandle,\n      runtime->getHiddenClassForPrototypeRaw(\n          *parentHandle,\n          numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(Runtime *runtime) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  return mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    unsigned propertyCount) {\n  JSObjectAlloc<JSObject> mem{runtime};\n  JSObject *objProto = runtime->objectPrototypeRawPtr;\n  auto self = mem.initToPseudoHandle(new (mem) JSObject(\n      runtime,\n      &vt.base,\n      objProto,\n      runtime->getHiddenClassForPrototypeRaw(\n          objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS),\n      GCPointerBase::NoBarriers()));\n\n  return runtime->ignoreAllocationFailure(\n      JSObject::allocatePropStorage(std::move(self), runtime, propertyCount));\n}\n\nPseudoHandle<JSObject> JSObject::create(\n    Runtime *runtime,\n    Handle<HiddenClass> clazz) {\n  auto obj = JSObject::create(runtime, clazz->getNumProperties());\n  obj->clazz_.set(runtime, *clazz, &runtime->getHeap());\n  // If the hidden class has index like property, we need to clear the fast path\n  // flag.\n  if (LLVM_UNLIKELY(obj->clazz_.get(runtime)->getHasIndexLikeProperties()))\n    obj->flags_.fastIndexProperties = false;\n  return obj;\n}\n\nvoid JSObject::initializeLazyObject(\n    Runtime *runtime,\n    Handle<JSObject> lazyObject) {\n  assert(lazyObject->flags_.lazyObject && \"object must be lazy\");\n  // object is now assumed to be a regular object.\n  lazyObject->flags_.lazyObject = 0;\n\n  // only functions can be lazy.\n  assert(vmisa<Callable>(lazyObject.get()) && \"unexpected lazy object\");\n  Callable::defineLazyProperties(Handle<Callable>::vmcast(lazyObject), runtime);\n}\n\nObjectID JSObject::getObjectID(JSObject *self, Runtime *runtime) {\n  if (LLVM_LIKELY(self->flags_.objectID))\n    return self->flags_.objectID;\n\n  // Object ID does not yet exist, get next unique global ID..\n  self->flags_.objectID = runtime->generateNextObjectID();\n  // Make sure it is not zero.\n  if (LLVM_UNLIKELY(!self->flags_.objectID))\n    --self->flags_.objectID;\n  return self->flags_.objectID;\n}\n\nCallResult<PseudoHandle<JSObject>> JSObject::getPrototypeOf(\n    PseudoHandle<JSObject> selfHandle,\n    Runtime *runtime) {\n  if (LLVM_LIKELY(!selfHandle->isProxyObject())) {\n    return createPseudoHandle(selfHandle->getParent(runtime));\n  }\n\n  return JSProxy::getPrototypeOf(\n      runtime->makeHandle(std::move(selfHandle)), runtime);\n}\n\nnamespace {\n\nCallResult<bool> proxyOpFlags(\n    Runtime *runtime,\n    PropOpFlags opFlags,\n    const char *msg,\n    CallResult<bool> res) {\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*res && opFlags.getThrowOnError()) {\n    return runtime->raiseTypeError(msg);\n  }\n  return res;\n}\n\n} // namespace\n\nCallResult<bool> JSObject::setParent(\n    JSObject *self,\n    Runtime *runtime,\n    JSObject *parent,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Object is not extensible.\",\n        JSProxy::setPrototypeOf(\n            runtime->makeHandle(self), runtime, runtime->makeHandle(parent)));\n  }\n  // ES9 9.1.2\n  // 4.\n  if (self->parent_.get(runtime) == parent)\n    return true;\n  // 5.\n  if (!self->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\"Object is not extensible.\");\n    } else {\n      return false;\n    }\n  }\n  // 6-8. Check for a prototype cycle.\n  for (JSObject *cur = parent; cur; cur = cur->parent_.get(runtime)) {\n    if (cur == self) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\"Prototype cycle detected\");\n      } else {\n        return false;\n      }\n    } else if (LLVM_UNLIKELY(cur->isProxyObject())) {\n      // TODO this branch should also be used for module namespace and\n      // immutable prototype exotic objects.\n      break;\n    }\n  }\n  // 9.\n  self->parent_.set(runtime, parent, &runtime->getHeap());\n  // 10.\n  return true;\n}\n\nvoid JSObject::allocateNewSlotStorage(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SlotIndex newSlotIndex,\n    Handle<> valueHandle) {\n  // If it is a direct property, just store the value and we are done.\n  if (LLVM_LIKELY(newSlotIndex < DIRECT_PROPERTY_SLOTS)) {\n    selfHandle->directProps()[newSlotIndex].set(\n        *valueHandle, &runtime->getHeap());\n    return;\n  }\n\n  // Make the slot index relative to the indirect storage.\n  newSlotIndex -= DIRECT_PROPERTY_SLOTS;\n\n  // Allocate a new property storage if not already allocated.\n  if (LLVM_UNLIKELY(!selfHandle->propStorage_)) {\n    // Allocate new storage.\n    assert(newSlotIndex == 0 && \"allocated slot must be at end\");\n    auto arrRes = runtime->ignoreAllocationFailure(\n        PropStorage::create(runtime, DEFAULT_PROPERTY_CAPACITY));\n    selfHandle->propStorage_.set(\n        runtime, vmcast<PropStorage>(arrRes), &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(\n                 newSlotIndex >=\n                 selfHandle->propStorage_.get(runtime)->capacity())) {\n    // Reallocate the existing one.\n    assert(\n        newSlotIndex == selfHandle->propStorage_.get(runtime)->size() &&\n        \"allocated slot must be at end\");\n    auto hnd = runtime->makeMutableHandle(selfHandle->propStorage_);\n    PropStorage::resize(hnd, runtime, newSlotIndex + 1);\n    selfHandle->propStorage_.set(runtime, *hnd, &runtime->getHeap());\n  }\n\n  {\n    NoAllocScope scope{runtime};\n    auto *const propStorage = selfHandle->propStorage_.getNonNull(runtime);\n    if (newSlotIndex >= propStorage->size()) {\n      assert(\n          newSlotIndex == propStorage->size() &&\n          \"allocated slot must be at end\");\n      PropStorage::resizeWithinCapacity(propStorage, runtime, newSlotIndex + 1);\n    }\n    // If we don't need to resize, just store it directly.\n    propStorage->at(newSlotIndex).set(*valueHandle, &runtime->getHeap());\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    NamedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getNamedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(getNamedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor =\n      vmcast<PropertyAccessor>(getNamedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc) {\n  assert(\n      !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject &&\n      \"getComputedPropertyValue_RJS cannot be used with proxy objects\");\n\n  if (LLVM_LIKELY(!desc.flags.accessor))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  auto *accessor = vmcast<PropertyAccessor>(\n      getComputedSlotValue(propObj.get(), runtime, desc));\n  if (!accessor->getter)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  // Execute the accessor on this object.\n  return accessor->getter.get(runtime)->executeCall0(\n      runtime->makeHandle(accessor->getter), runtime, selfHandle);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<JSObject> propObj,\n    ComputedPropertyDescriptor desc,\n    Handle<> nameValHandle) {\n  if (!propObj) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n\n  if (LLVM_LIKELY(!desc.flags.proxyObject)) {\n    return JSObject::getComputedPropertyValue_RJS(\n        selfHandle, runtime, propObj, desc);\n  }\n\n  CallResult<Handle<>> keyRes = toPropertyKey(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(keyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  CallResult<bool> hasRes = JSProxy::hasComputed(propObj, runtime, *keyRes);\n  if (LLVM_UNLIKELY(hasRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!*hasRes) {\n    return createPseudoHandle(HermesValue::encodeEmptyValue());\n  }\n  return JSProxy::getComputed(propObj, runtime, *keyRes, selfHandle);\n}\n\nCallResult<Handle<JSArray>> JSObject::getOwnPropertyKeys(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    OwnKeysFlags okFlags) {\n  assert(\n      (okFlags.getIncludeNonSymbols() || okFlags.getIncludeSymbols()) &&\n      \"Can't exclude symbols and strings\");\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      CallResult<PseudoHandle<JSArray>> proxyRes =\n          JSProxy::ownPropertyKeys(selfHandle, runtime, okFlags);\n      if (LLVM_UNLIKELY(proxyRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return runtime->makeHandle(std::move(*proxyRes));\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    initializeLazyObject(runtime, selfHandle);\n  }\n\n  auto range = getOwnIndexedRange(selfHandle.get(), runtime);\n\n  // Estimate the capacity of the output array.  This estimate is only\n  // reasonable for the non-symbol case.\n  uint32_t capacity = okFlags.getIncludeNonSymbols()\n      ? (selfHandle->clazz_.get(runtime)->getNumProperties() + range.second -\n         range.first)\n      : 0;\n\n  auto arrayRes = JSArray::create(runtime, capacity, 0);\n  if (LLVM_UNLIKELY(arrayRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto array = runtime->makeHandle(std::move(*arrayRes));\n\n  // Optional array of SymbolIDs reported via host object API\n  llvh::Optional<Handle<JSArray>> hostObjectSymbols;\n  size_t hostObjectSymbolCount = 0;\n\n  // If current object is a host object we need to deduplicate its properties\n  llvh::SmallSet<SymbolID::RawType, 16> dedupSet;\n\n  // Output index.\n  uint32_t index = 0;\n\n  // Avoid allocating a new handle per element.\n  MutableHandle<> tmpHandle{runtime};\n\n  // Number of indexed properties.\n  uint32_t numIndexed = 0;\n\n  // Regular properties with names that are array indexes are stashed here, if\n  // encountered.\n  llvh::SmallVector<uint32_t, 8> indexNames{};\n\n  // Iterate the named properties excluding those which use Symbols.\n  if (okFlags.getIncludeNonSymbols()) {\n    // Get host object property names\n    if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n      assert(\n          range.first == range.second &&\n          \"Host objects cannot own indexed range\");\n      auto hostSymbolsRes =\n          vmcast<HostObject>(selfHandle.get())->getHostPropertyNames();\n      if (hostSymbolsRes == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if ((hostObjectSymbolCount = (**hostSymbolsRes)->getEndIndex()) != 0) {\n        Handle<JSArray> hostSymbols = *hostSymbolsRes;\n        hostObjectSymbols = std::move(hostSymbols);\n        capacity += hostObjectSymbolCount;\n      }\n    }\n\n    // Iterate the indexed properties.\n    GCScopeMarkerRAII marker{runtime};\n    for (auto i = range.first; i != range.second; ++i) {\n      auto res = getOwnIndexedPropertyFlags(selfHandle.get(), runtime, i);\n      if (!res)\n        continue;\n\n      // If specified, check whether it is enumerable.\n      if (!okFlags.getIncludeNonEnumerable() && !res->enumerable)\n        continue;\n\n      tmpHandle = HermesValue::encodeDoubleValue(i);\n      JSArray::setElementAt(array, runtime, index++, tmpHandle);\n      marker.flush();\n    }\n\n    numIndexed = index;\n\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime,\n         okFlags,\n         array,\n         hostObjectSymbolCount,\n         &index,\n         &indexNames,\n         &tmpHandle,\n         &dedupSet](SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isPropertyNamePrimitive(id)) {\n            return;\n          }\n\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n\n          // Host properties might overlap with the ones recognized by the\n          // hidden class. If we're dealing with a host object then keep track\n          // of hidden class properties for the deduplication purposes.\n          if (LLVM_UNLIKELY(hostObjectSymbolCount > 0)) {\n            dedupSet.insert(id.unsafeGetRaw());\n          }\n\n          // Check if this property is an integer index. If it is, we stash it\n          // away to deal with it later. This check should be fast since most\n          // property names don't start with a digit.\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            return;\n          }\n\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        });\n\n    // Iterate over HostObject properties and append them to the array. Do not\n    // append duplicates.\n    if (LLVM_UNLIKELY(hostObjectSymbols)) {\n      for (size_t i = 0; i < hostObjectSymbolCount; ++i) {\n        assert(\n            (*hostObjectSymbols)->at(runtime, i).isSymbol() &&\n            \"Host object needs to return array of SymbolIDs\");\n        marker.flush();\n        SymbolID id = (*hostObjectSymbols)->at(runtime, i).getSymbol();\n        if (dedupSet.count(id.unsafeGetRaw()) == 0) {\n          dedupSet.insert(id.unsafeGetRaw());\n\n          assert(\n              !InternalProperty::isInternal(id) &&\n              \"host object returned reserved symbol\");\n          auto propNameAsIndex = toArrayIndex(\n              runtime->getIdentifierTable().getStringView(runtime, id));\n          if (LLVM_UNLIKELY(propNameAsIndex)) {\n            indexNames.push_back(*propNameAsIndex);\n            continue;\n          }\n          tmpHandle = HermesValue::encodeStringValue(\n              runtime->getStringPrimFromSymbolID(id));\n          JSArray::setElementAt(array, runtime, index++, tmpHandle);\n        }\n      }\n    }\n  }\n\n  // Now iterate the named properties again, including only Symbols.\n  // We could iterate only once, if we chose to ignore (and disallow)\n  // own properties on HostObjects, as we do with Proxies.\n  if (okFlags.getIncludeSymbols()) {\n    MutableHandle<SymbolID> idHandle{runtime};\n    HiddenClass::forEachProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        [runtime, okFlags, array, &index, &idHandle](\n            SymbolID id, NamedPropertyDescriptor desc) {\n          if (!isSymbolPrimitive(id)) {\n            return;\n          }\n          // If specified, check whether it is enumerable.\n          if (!okFlags.getIncludeNonEnumerable()) {\n            if (!desc.flags.enumerable)\n              return;\n          }\n          idHandle = id;\n          JSArray::setElementAt(array, runtime, index++, idHandle);\n        });\n  }\n\n  // The end (exclusive) of the named properties.\n  uint32_t endNamed = index;\n\n  // Properly set the length of the array.\n  auto cr = JSArray::setLength(\n      array, runtime, endNamed + indexNames.size(), PropOpFlags{});\n  (void)cr;\n  assert(\n      cr != ExecutionStatus::EXCEPTION && *cr && \"JSArray::setLength() failed\");\n\n  // If we have no index-like names, we are done.\n  if (LLVM_LIKELY(indexNames.empty()))\n    return array;\n\n  // In the unlikely event that we encountered index-like names, we need to sort\n  // them and merge them with the real indexed properties. Note that it is\n  // guaranteed that there are no clashes.\n  std::sort(indexNames.begin(), indexNames.end());\n\n  // Also make space for the new elements by shifting all the named properties\n  // to the right. First, resize the array.\n  JSArray::setStorageEndIndex(array, runtime, endNamed + indexNames.size());\n\n  // Shift the non-index property names. The region [numIndexed..endNamed) is\n  // moved to [numIndexed+indexNames.size()..array->size()).\n  // TODO: optimize this by implementing memcpy-like functionality in ArrayImpl.\n  for (uint32_t last = endNamed, toLast = array->getEndIndex();\n       last != numIndexed;) {\n    --last;\n    --toLast;\n    tmpHandle = array->at(runtime, last);\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  // Now we need to merge the indexes in indexNames and the array\n  // [0..numIndexed). We start from the end and copy the larger element from\n  // either array.\n  // 1+ the destination position to copy into.\n  for (uint32_t toLast = numIndexed + indexNames.size(),\n                indexNamesLast = indexNames.size();\n       toLast != 0;) {\n    if (numIndexed) {\n      uint32_t a = (uint32_t)array->at(runtime, numIndexed - 1).getNumber();\n      uint32_t b;\n\n      if (indexNamesLast && (b = indexNames[indexNamesLast - 1]) > a) {\n        tmpHandle = HermesValue::encodeDoubleValue(b);\n        --indexNamesLast;\n      } else {\n        tmpHandle = HermesValue::encodeDoubleValue(a);\n        --numIndexed;\n      }\n    } else {\n      assert(indexNamesLast && \"prematurely ran out of source values\");\n      tmpHandle =\n          HermesValue::encodeDoubleValue(indexNames[indexNamesLast - 1]);\n      --indexNamesLast;\n    }\n\n    --toLast;\n    JSArray::setElementAt(array, runtime, toLast, tmpHandle);\n  }\n\n  return array;\n}\n\n/// Convert a value to string unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n#define LAZY_TO_STRING(runtime, nameValHandle, str)       \\\n  do {                                                    \\\n    if (!str) {                                           \\\n      auto status = toString_RJS(runtime, nameValHandle); \\\n      assert(                                             \\\n          status != ExecutionStatus::EXCEPTION &&         \\\n          \"toString() of primitive cannot fail\");         \\\n      str = status->get();                                \\\n    }                                                     \\\n  } while (0)\n\n/// Convert a value to an identifier unless already converted\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param id [SymbolID] the identifier is stored there. Must be initialized\n///   to INVALID_IDENTIFIER_ID initially.\n#define LAZY_TO_IDENTIFIER(runtime, nameValHandle, id)          \\\n  do {                                                          \\\n    if (id.isInvalid()) {                                       \\\n      CallResult<Handle<SymbolID>> idRes =                      \\\n          valueToSymbolID(runtime, nameValHandle);              \\\n      if (LLVM_UNLIKELY(idRes == ExecutionStatus::EXCEPTION)) { \\\n        return ExecutionStatus::EXCEPTION;                      \\\n      }                                                         \\\n      id = **idRes;                                             \\\n    }                                                           \\\n  } while (0)\n\n/// Convert a value to array index, if possible.\n/// \\param nameValHandle [Handle<>] the value to convert\n/// \\param str [MutableHandle<StringPrimitive>] the string is stored\n///   there. Must be initialized to null initially.\n/// \\param arrayIndex [OptValue<uint32_t>] the array index is stored\n///   there.\n#define TO_ARRAY_INDEX(runtime, nameValHandle, str, arrayIndex) \\\n  do {                                                          \\\n    arrayIndex = toArrayIndexFastPath(*nameValHandle);          \\\n    if (!arrayIndex && !nameValHandle->isSymbol()) {            \\\n      LAZY_TO_STRING(runtime, nameValHandle, str);              \\\n      arrayIndex = toArrayIndex(runtime, str);                  \\\n    }                                                           \\\n  } while (0)\n\n/// \\return true if the flags of a new property make it suitable for indexed\n///   storage. All new indexed properties are enumerable, writable and\n///   configurable and have no accessors.\nstatic bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {\n  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&\n      dpf.writable && dpf.setConfigurable && dpf.configurable &&\n      !dpf.setSetter && !dpf.setGetter;\n}\n\nstruct JSObject::Helper {\n public:\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static ObjectFlags &flags(JSObject *self) {\n    return self->flags_;\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static OptValue<PropertyFlags>\n  getOwnIndexedPropertyFlags(JSObject *self, Runtime *runtime, uint32_t index) {\n    return JSObject::getOwnIndexedPropertyFlags(self, runtime, index);\n  }\n\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static NamedPropertyDescriptor &castToNamedPropertyDescriptorRef(\n      ComputedPropertyDescriptor &desc) {\n    return desc.castToNamedPropertyDescriptorRef();\n  }\n};\n\nnamespace {\n\n/// ES5.1 8.12.1.\n\n/// A helper which takes a SymbolID which caches the conversion of\n/// nameValHandle if it's needed.  It should be default constructed,\n/// and may or may not be set.  This has been measured to be a useful\n/// perf win.  Note that always_inline seems to be ignored on static\n/// methods, so this function has to be local to the cpp file in order\n/// to be inlined for the perf win.\nLLVM_ATTRIBUTE_ALWAYS_INLINE\nCallResult<bool> getOwnComputedPrimitiveDescriptorImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    SymbolID &id,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getOwnComputedPrimitiveDescriptor \"\n      \"cannot be an object\");\n\n  // Try the fast paths first if we have \"fast\" index properties and the\n  // property name is an obvious index.\n  if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n    if (JSObject::Helper::flags(*selfHandle).fastIndexProperties) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        // This a valid array index, residing in our indexed storage.\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n\n      // This a valid array index, but we don't have it in our indexed storage,\n      // and we don't have index-like named properties.\n      return false;\n    }\n\n    if (!selfHandle->getClass(runtime)->getHasIndexLikeProperties() &&\n        !selfHandle->isHostObject() && !selfHandle->isLazy() &&\n        !selfHandle->isProxyObject()) {\n      // Early return to handle the case where an object definitely has no\n      // index-like properties. This avoids allocating a new StringPrimitive and\n      // uniquing it below.\n      return false;\n    }\n  }\n\n  // Convert the string to a SymbolID\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n  // Look for a named property with this name.\n  if (JSObject::getOwnNamedDescriptor(\n          selfHandle,\n          runtime,\n          id,\n          JSObject::Helper::castToNamedPropertyDescriptorRef(desc))) {\n    return true;\n  }\n\n  if (LLVM_LIKELY(\n          !JSObject::Helper::flags(*selfHandle).indexedStorage &&\n          !selfHandle->isLazy() && !selfHandle->isProxyObject())) {\n    return false;\n  }\n  MutableHandle<StringPrimitive> strPrim{runtime};\n\n  // If we have indexed storage, perform potentially expensive conversions\n  // to array index and check it.\n  if (JSObject::Helper::flags(*selfHandle).indexedStorage) {\n    // If the name is a valid integer array index, store it here.\n    OptValue<uint32_t> arrayIndex;\n\n    // Try to convert the property name to an array index.\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n\n    if (arrayIndex) {\n      auto res = JSObject::Helper::getOwnIndexedPropertyFlags(\n          selfHandle.get(), runtime, *arrayIndex);\n      if (res) {\n        desc.flags = *res;\n        desc.flags.indexed = 1;\n        desc.slot = *arrayIndex;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (selfHandle->isLazy()) {\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return JSObject::getOwnComputedPrimitiveDescriptor(\n        selfHandle, runtime, nameValHandle, ignoreProxy, desc);\n  }\n\n  assert(selfHandle->isProxyObject() && \"descriptor flags are impossible\");\n  if (ignoreProxy == JSObject::IgnoreProxy::Yes) {\n    return false;\n  }\n  return JSProxy::getOwnProperty(\n      selfHandle, runtime, nameValHandle, desc, nullptr);\n}\n\n} // namespace\n\nCallResult<bool> JSObject::getOwnComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    JSObject::IgnoreProxy ignoreProxy,\n    ComputedPropertyDescriptor &desc) {\n  SymbolID id{};\n\n  return getOwnComputedPrimitiveDescriptorImpl(\n      selfHandle, runtime, nameValHandle, ignoreProxy, id, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::No, desc);\n}\n\nCallResult<bool> JSObject::getOwnComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    ComputedPropertyDescriptor &desc,\n    MutableHandle<> &valueOrAccessor) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // The proxy is ignored here so we can avoid calling\n  // JSProxy::getOwnProperty twice on proxies, since\n  // getOwnComputedPrimitiveDescriptor doesn't pass back the\n  // valueOrAccessor.\n  CallResult<bool> res = JSObject::getOwnComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, IgnoreProxy::Yes, desc);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (*res) {\n    valueOrAccessor = getComputedSlotValue(selfHandle.get(), runtime, desc);\n    return true;\n  }\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::getOwnProperty(\n        selfHandle, runtime, nameValHandle, desc, &valueOrAccessor);\n  }\n  return false;\n}\n\nJSObject *JSObject::getNamedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags expectedFlags,\n    NamedPropertyDescriptor &desc) {\n  if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n    return *selfHandle;\n\n  // Check here for host object flag.  This means that \"normal\" own\n  // properties above win over host-defined properties, but there's no\n  // cost imposed on own property lookups.  This should do what we\n  // need in practice, and we can define host vs js property\n  // disambiguation however we want.  This is here in order to avoid\n  // impacting perf for the common case where an own property exists\n  // in normal storage.\n  if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {\n    desc.flags.hostObject = true;\n    desc.flags.writable = true;\n    return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    assert(\n        !selfHandle->flags_.proxyObject &&\n        \"Proxy objects should never be lazy\");\n    // Initialize the object and perform the lookup again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n\n    if (findProperty(selfHandle, runtime, name, expectedFlags, desc))\n      return *selfHandle;\n  }\n\n  if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    desc.flags.proxyObject = true;\n    return *selfHandle;\n  }\n\n  if (selfHandle->parent_) {\n    MutableHandle<JSObject> mutableSelfHandle{\n        runtime, selfHandle->parent_.getNonNull(runtime)};\n\n    do {\n      // Check the most common case first, at the cost of some code duplication.\n      if (LLVM_LIKELY(\n              !mutableSelfHandle->flags_.lazyObject &&\n              !mutableSelfHandle->flags_.hostObject &&\n              !mutableSelfHandle->flags_.proxyObject)) {\n      findProp:\n        if (findProperty(\n                mutableSelfHandle,\n                runtime,\n                name,\n                PropertyFlags::invalid(),\n                desc)) {\n          assert(\n              !selfHandle->flags_.proxyObject &&\n              \"Proxy object parents should never have own properties\");\n          return *mutableSelfHandle;\n        }\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.lazyObject)) {\n        JSObject::initializeLazyObject(runtime, mutableSelfHandle);\n        goto findProp;\n      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.hostObject)) {\n        desc.flags.hostObject = true;\n        desc.flags.writable = true;\n        return *mutableSelfHandle;\n      } else {\n        assert(\n            mutableSelfHandle->flags_.proxyObject &&\n            \"descriptor flags are impossible\");\n        desc.flags.proxyObject = true;\n        return *mutableSelfHandle;\n      }\n    } while ((mutableSelfHandle = mutableSelfHandle->parent_.get(runtime)));\n  }\n\n  return nullptr;\n}\n\nExecutionStatus JSObject::getComputedPrimitiveDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"getComputedPrimitiveDescriptor cannot \"\n      \"be an object\");\n\n  propObj = selfHandle.get();\n\n  SymbolID id{};\n\n  GCScopeMarkerRAII marker{runtime};\n  do {\n    // A proxy is ignored here so we can check the bit later and\n    // return it back to the caller for additional processing.\n\n    Handle<JSObject> loopHandle = propObj;\n\n    CallResult<bool> res = getOwnComputedPrimitiveDescriptorImpl(\n        loopHandle, runtime, nameValHandle, IgnoreProxy::Yes, id, desc);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*res) {\n      return ExecutionStatus::RETURNED;\n    }\n\n    if (LLVM_UNLIKELY(propObj->flags_.hostObject)) {\n      desc.flags.hostObject = true;\n      desc.flags.writable = true;\n      return ExecutionStatus::RETURNED;\n    }\n    if (LLVM_UNLIKELY(propObj->flags_.proxyObject)) {\n      desc.flags.proxyObject = true;\n      return ExecutionStatus::RETURNED;\n    }\n    // This isn't a proxy, so use the faster getParent() instead of\n    // getPrototypeOf.\n    propObj = propObj->getParent(runtime);\n    // Flush at the end of the loop to allow first iteration to be as fast as\n    // possible.\n    marker.flush();\n  } while (propObj);\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::getComputedDescriptor(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    MutableHandle<JSObject> &propObj,\n    ComputedPropertyDescriptor &desc) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return getComputedPrimitiveDescriptor(\n      selfHandle, runtime, *converted, propObj, desc);\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> receiver,\n    PropOpFlags opFlags,\n    PropertyCacheEntry *cacheEntry) {\n  NamedPropertyDescriptor desc;\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (!propObj) {\n    if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n      return runtime->raiseReferenceError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' doesn't exist\");\n    }\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  }\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject)) {\n    // Populate the cache if requested.\n    if (cacheEntry && !propObj->getClass(runtime)->isDictionaryNoCache()) {\n      cacheEntry->clazz = propObj->getClassGCPtr().getStorageType();\n      cacheEntry->slot = desc.slot;\n    }\n    return createPseudoHandle(getNamedSlotValue(propObj, runtime, desc));\n  }\n\n  if (desc.flags.accessor) {\n    auto *accessor =\n        vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return Callable::executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    auto res = vmcast<HostObject>(propObj)->get(name);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return createPseudoHandle(*res);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    return JSProxy::getNamed(\n        runtime->makeHandle(propObj), runtime, name, receiver);\n  }\n}\n\nCallResult<PseudoHandle<>> JSObject::getNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return getComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)));\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to getNamed().\n  }\n  return getNamed_RJS(selfHandle, runtime, name, opFlags);\n}\n\nCallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return it.\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}\n\nCallResult<bool> JSObject::hasNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  NamedPropertyDescriptor desc;\n  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);\n  if (propObj == nullptr) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    return JSProxy::hasNamed(runtime->makeHandle(propObj), runtime, name);\n  }\n  return true;\n}\n\nCallResult<bool> JSObject::hasNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      if (haveOwnIndexed(selfHandle.get(), runtime, *nameAsIndex)) {\n        return true;\n      }\n      if (selfHandle->flags_.fastIndexProperties) {\n        return false;\n      }\n    }\n    // Here we have indexed properties but the symbol was not stored in the\n    // indexedStorage.\n    // Fall through to getNamed().\n  }\n  return hasNamed(selfHandle, runtime, name);\n}\n\nCallResult<bool> JSObject::hasComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return true.\n      if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n        return true;\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (getComputedPrimitiveDescriptor(\n          selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n      ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj) {\n    return false;\n  }\n  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::hasComputed(propObj, runtime, *key);\n  }\n  // For compatibility with polyfills we want to pretend that all HostObject\n  // properties are \"own\" properties in 'in'. Since there is no way to check for\n  // a HostObject property, we must always assume success. In practice the\n  // property name would have been obtained from enumerating the properties in\n  // JS code that looks something like this:\n  //    for(key in hostObj) {\n  //      if (key in hostObj)\n  //        ...\n  //    }\n  return true;\n}\n\nstatic ExecutionStatus raiseErrorForOverridingStaticBuiltin(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<SymbolID> name) {\n  Handle<StringPrimitive> methodNameHnd =\n      runtime->makeHandle(runtime->getStringPrimFromSymbolID(name.get()));\n  // If the 'name' property does not exist or is an accessor, we don't display\n  // the name.\n  NamedPropertyDescriptor desc;\n  auto *obj = JSObject::getNamedDescriptor(\n      selfHandle, runtime, Predefined::getSymbolID(Predefined::name), desc);\n  assert(\n      !selfHandle->isProxyObject() &&\n      \"raiseErrorForOverridingStaticBuiltin cannot be used with proxy objects\");\n\n  if (!obj || desc.flags.accessor) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  // Display the name property of the builtin object if it is a string.\n  StringPrimitive *objName = dyn_vmcast<StringPrimitive>(\n      JSObject::getNamedSlotValue(selfHandle.get(), runtime, desc));\n  if (!objName) {\n    return runtime->raiseTypeError(\n        TwineChar16(\"Attempting to override read-only builtin method '\") +\n        TwineChar16(methodNameHnd.get()) + \"'\");\n  }\n\n  return runtime->raiseTypeError(\n      TwineChar16(\"Attempting to override read-only builtin method '\") +\n      TwineChar16(objName) + \".\" + TwineChar16(methodNameHnd.get()) + \"'\");\n}\n\nCallResult<bool> JSObject::putNamedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  NamedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  JSObject *propObj = getNamedDescriptor(\n      selfHandle,\n      runtime,\n      name,\n      PropertyFlags::defaultNewNamedPropertyFlags(),\n      desc);\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            *selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      setNamedSlotValue(\n          *selfHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor =\n          vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              TwineChar16(\"Cannot assign to property '\") +\n              runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n              \"' which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              *valueHandle) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<bool> setRes = JSProxy::setNamed(\n          runtime->makeHandle(propObj), runtime, name, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy set returned false for property '\") +\n            runtime->getIdentifierTable().getStringView(runtime, name) + \"'\");\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(name));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            TwineChar16(\"Cannot assign to read-only property '\") +\n            runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n            \"'\");\n      }\n      return false;\n    }\n\n    if (*selfHandle == propObj && desc.flags.internalSetter) {\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueHandle, opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n\n    if (getOwnNamedDescriptor(receiverHandle, runtime, name, desc)) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      assert(\n          !receiverHandle->isHostObject() && !receiverHandle->isProxyObject() &&\n          \"getOwnNamedDescriptor never sets hostObject or proxyObject flags\");\n\n      setNamedSlotValue(\n          *receiverHandle, runtime, desc, valueHandle.getHermesValue());\n      return true;\n    }\n\n    // Now deal with host and proxy object cases.  We need to call\n    // getOwnComputedPrimitiveDescriptor because it knows how to call\n    // the [[getOwnProperty]] Proxy impl if needed.\n    if (LLVM_UNLIKELY(\n            receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())\n            ->set(name, *valueHandle);\n      }\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n          receiverHandle,\n          runtime,\n          name.isUniqued() ? runtime->makeHandle(HermesValue::encodeStringValue(\n                                 runtime->getStringPrimFromSymbolID(name)))\n                           : runtime->makeHandle(name),\n          IgnoreProxy::No,\n          desc);\n      if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      DefinePropertyFlags dpf;\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle, runtime, name, dpf, valueHandle, opFlags);\n    }\n  }\n\n  // Does the caller require it to exist?\n  if (LLVM_UNLIKELY(opFlags.getMustExist())) {\n    return runtime->raiseReferenceError(\n        TwineChar16(\"Property '\") +\n        runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n        \"' doesn't exist\");\n  }\n\n  // Add a new property.\n\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      name,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::putNamedOrIndexed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    Handle<> valueHandle,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {\n    // Note that getStringView can be satisfied without materializing the\n    // Identifier.\n    const auto strView =\n        runtime->getIdentifierTable().getStringView(runtime, name);\n    if (auto nameAsIndex = toArrayIndex(strView)) {\n      return putComputed_RJS(\n          selfHandle,\n          runtime,\n          runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)),\n          valueHandle,\n          opFlags);\n    }\n    // Here we have indexed properties but the symbol was not index-like.\n    // Fall through to putNamed().\n  }\n  return putNamed_RJS(selfHandle, runtime, name, valueHandle, opFlags);\n}\n\nCallResult<bool> JSObject::putComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> valueHandle,\n    Handle<> receiver,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() &&\n      \"mustExist flag cannot be used with computed properties\");\n\n  // Try the fast-path first: has \"index-like\" properties, the \"name\"\n  // already is a valid integer index, selfHandle and receiver are the\n  // same, and it is present in storage.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {\n        if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n          auto result =\n              setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);\n          if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_LIKELY(*result))\n            return true;\n          if (opFlags.getThrowOnError()) {\n            // TODO: better message.\n            return runtime->raiseTypeError(\n                \"Cannot assign to read-only property\");\n          }\n          return false;\n        }\n      }\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Look for the property in this object or along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // If the property exists (or, we hit a proxy/hostobject on the way\n  // up the chain)\n  if (propObj) {\n    // Get the simple case out of the way: If the property already\n    // exists on selfHandle, is not an accessor, selfHandle and\n    // receiver are the same, selfHandle is not a host\n    // object/proxy/internal setter, and the property is writable,\n    // just write into the same slot.\n\n    if (LLVM_LIKELY(\n            selfHandle == propObj &&\n            selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n            !desc.flags.accessor && !desc.flags.internalSetter &&\n            !desc.flags.hostObject && !desc.flags.proxyObject &&\n            desc.flags.writable)) {\n      if (LLVM_UNLIKELY(\n              setComputedSlotValue(selfHandle, runtime, desc, valueHandle) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    // Is it an accessor?\n    if (LLVM_UNLIKELY(desc.flags.accessor)) {\n      auto *accessor = vmcast<PropertyAccessor>(\n          getComputedSlotValue(propObj.get(), runtime, desc));\n\n      // If it is a read-only accessor, fail.\n      if (!accessor->setter) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeErrorForValue(\n              \"Cannot assign to property \",\n              nameValPrimitiveHandle,\n              \" which has only a getter\");\n        }\n        return false;\n      }\n\n      // Execute the accessor on this object.\n      if (accessor->setter.get(runtime)->executeCall1(\n              runtime->makeHandle(accessor->setter),\n              runtime,\n              receiver,\n              valueHandle.get()) == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      return true;\n    }\n\n    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n      assert(\n          !opFlags.getMustExist() &&\n          \"MustExist cannot be used with Proxy objects\");\n      CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n      if (key == ExecutionStatus::EXCEPTION)\n        return ExecutionStatus::EXCEPTION;\n      CallResult<bool> setRes =\n          JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);\n      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (!*setRes && opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\n            TwineChar16(\"Proxy trap returned false for property\"));\n      }\n      return setRes;\n    }\n\n    if (LLVM_UNLIKELY(!desc.flags.writable)) {\n      if (desc.flags.staticBuiltin) {\n        SymbolID id{};\n        LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n        return raiseErrorForOverridingStaticBuiltin(\n            selfHandle, runtime, runtime->makeHandle(id));\n      }\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeErrorForValue(\n            \"Cannot assign to read-only property \", nameValPrimitiveHandle, \"\");\n      }\n      return false;\n    }\n\n    if (selfHandle == propObj && desc.flags.internalSetter) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      return internalSetter(\n          selfHandle,\n          runtime,\n          id,\n          desc.castToNamedPropertyDescriptorRef(),\n          valueHandle,\n          opFlags);\n    }\n  }\n\n  // The property does not exist as an conventional own property on\n  // this object.\n\n  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n      receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n      receiverHandle = dyn_vmcast<JSObject>(*receiver);\n    }\n    if (!receiverHandle) {\n      return false;\n    }\n    CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n        receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);\n    if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    DefinePropertyFlags dpf;\n    if (*descDefinedRes) {\n      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n        return false;\n      }\n\n      if (LLVM_LIKELY(\n              !desc.flags.internalSetter && !receiverHandle->isHostObject() &&\n              !receiverHandle->isProxyObject())) {\n        if (LLVM_UNLIKELY(\n                setComputedSlotValue(\n                    receiverHandle, runtime, desc, valueHandle) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        return true;\n      }\n    }\n\n    if (LLVM_UNLIKELY(\n            desc.flags.internalSetter || receiverHandle->isHostObject() ||\n            receiverHandle->isProxyObject())) {\n      SymbolID id{};\n      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n      if (desc.flags.internalSetter) {\n        return internalSetter(\n            receiverHandle,\n            runtime,\n            id,\n            desc.castToNamedPropertyDescriptorRef(),\n            valueHandle,\n            opFlags);\n      } else if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n      }\n      assert(\n          receiverHandle->isProxyObject() && \"descriptor flags are impossible\");\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle, runtime, id, dpf, valueHandle, opFlags);\n    }\n  }\n\n  /// Can we add more properties?\n  if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // If we have indexed storage we must check whether the property is an index,\n  // and if it is, store it in indexed storage.\n  if (receiverHandle->flags_.indexedStorage) {\n    OptValue<uint32_t> arrayIndex;\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n    if (arrayIndex) {\n      // Check whether we need to update array's \".length\" property.\n      if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {\n        if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {\n          auto cr = putNamed_RJS(\n              receiverHandle,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime->makeHandle(\n                  HermesValue::encodeNumberValue(*arrayIndex + 1)),\n              opFlags);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return ExecutionStatus::EXCEPTION;\n          if (LLVM_UNLIKELY(!*cr))\n            return false;\n        }\n      }\n\n      auto result =\n          setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (LLVM_LIKELY(*result))\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better message.\n        return runtime->raiseTypeError(\"Cannot assign to read-only property\");\n      }\n      return false;\n    }\n  }\n\n  SymbolID id{};\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Add a new named property.\n  return addOwnProperty(\n      receiverHandle,\n      runtime,\n      id,\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      valueHandle,\n      opFlags);\n}\n\nCallResult<bool> JSObject::deleteNamed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n\n  // If the property doesn't exist in this object, return success.\n  if (!pos) {\n    if (LLVM_LIKELY(\n            !selfHandle->flags_.lazyObject &&\n            !selfHandle->flags_.proxyObject)) {\n      return true;\n    } else if (selfHandle->flags_.lazyObject) {\n      // object is lazy, initialize and read again.\n      initializeLazyObject(runtime, selfHandle);\n      pos = findProperty(selfHandle, runtime, name, desc);\n      if (!pos) // still not there, return true.\n        return true;\n    } else {\n      assert(selfHandle->flags_.proxyObject && \"object flags are impossible\");\n      return proxyOpFlags(\n          runtime,\n          opFlags,\n          \"Proxy delete returned false\",\n          JSProxy::deleteNamed(selfHandle, runtime, name));\n    }\n  }\n  // If the property isn't configurable, fail.\n  if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"' is not configurable\");\n    }\n    return false;\n  }\n\n  // Clear the deleted property value to prevent memory leaks.\n  setNamedSlotValue(\n      *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n  // Perform the actual deletion.\n  auto newClazz = HiddenClass::deleteProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  return true;\n}\n\nCallResult<bool> JSObject::deleteComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"mustExist cannot be specified when deleting\");\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  auto nameValPrimitiveHandle = *converted;\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n  }\n\n  // Try the fast-path first: the \"name\" is a valid array index and we don't\n  // have \"index-like\" named properties.\n  if (arrayIndex && selfHandle->flags_.fastIndexProperties) {\n    // Delete the indexed property.\n    if (deleteOwnIndexed(selfHandle, runtime, *arrayIndex))\n      return true;\n\n    // Cannot delete property (for example this may be a typed array).\n    if (opFlags.getThrowOnError()) {\n      // TODO: better error message.\n      return runtime->raiseTypeError(\"Cannot delete property\");\n    }\n    return false;\n  }\n\n  // slow path, check if object is lazy before continuing.\n  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {\n    // initialize and try again.\n    initializeLazyObject(runtime, selfHandle);\n    return deleteComputed(selfHandle, runtime, nameValHandle, opFlags);\n  }\n\n  // Convert the string to an SymbolID;\n  SymbolID id;\n  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n\n  // Find the property by name.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, id, desc);\n\n  // If the property exists, make sure it is configurable.\n  if (pos) {\n    // If the property isn't configurable, fail.\n    if (LLVM_UNLIKELY(!desc.flags.configurable)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: a better message.\n        return runtime->raiseTypeError(\"Property is not configurable\");\n      }\n      return false;\n    }\n  }\n\n  // At this point we know that the named property either doesn't exist, or\n  // is configurable and so can be deleted, or the object is a Proxy.\n\n  // If it is an \"index-like\" property, we must also delete the \"shadow\" indexed\n  // property in order to keep Array.length correct.\n  if (arrayIndex) {\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      // Cannot delete property (for example this may be a typed array).\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot delete property\");\n      }\n      return false;\n    }\n  }\n\n  if (pos) {\n    // delete the named property (if it exists).\n    // Clear the deleted property value to prevent memory leaks.\n    setNamedSlotValue(\n        *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());\n\n    // Remove the property descriptor.\n    auto newClazz = HiddenClass::deleteProperty(\n        runtime->makeHandle(selfHandle->clazz_), runtime, *pos);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  } else if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return proxyOpFlags(\n        runtime,\n        opFlags,\n        \"Proxy delete returned false\",\n        JSProxy::deleteComputed(selfHandle, runtime, *key));\n  }\n\n  return true;\n}\n\nCallResult<bool> JSObject::defineOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // Is it an existing property.\n  NamedPropertyDescriptor desc;\n  auto pos = findProperty(selfHandle, runtime, name, desc);\n  if (pos) {\n    return updateOwnProperty(\n        selfHandle,\n        runtime,\n        name,\n        *pos,\n        desc,\n        dpFlags,\n        valueOrAccessor,\n        opFlags);\n  }\n\n  if (LLVM_UNLIKELY(\n          selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {\n    if (selfHandle->flags_.proxyObject) {\n      return JSProxy::defineOwnProperty(\n          selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n    }\n    assert(selfHandle->flags_.lazyObject && \"descriptor flags are impossible\");\n    // if the property was not found and the object is lazy we need to\n    // initialize it and try again.\n    JSObject::initializeLazyObject(runtime, selfHandle);\n    return defineOwnProperty(\n        selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  return addOwnProperty(\n      selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);\n}\n\nExecutionStatus JSObject::defineNewOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"definedNewOwnProperty cannot be used with proxy objects\");\n  assert(\n      !(propertyFlags.accessor && !valueOrAccessor.get().isPointer()) &&\n      \"accessor must be non-empty\");\n  assert(\n      !(propertyFlags.accessor && propertyFlags.writable) &&\n      \"writable must not be set with accessors\");\n  assert(\n      !HiddenClass::debugIsPropertyDefined(\n          selfHandle->clazz_.get(runtime), runtime, name) &&\n      \"new property is already defined\");\n\n  return addOwnPropertyImpl(\n      selfHandle, runtime, name, propertyFlags, valueOrAccessor);\n}\n\nCallResult<bool> JSObject::defineOwnComputedPrimitive(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  assert(\n      !nameValHandle->isObject() &&\n      \"nameValHandle passed to \"\n      \"defineOwnComputedPrimitive() cannot be \"\n      \"an object\");\n  assert(\n      !opFlags.getMustExist() && \"cannot use mustExist with defineOwnProperty\");\n  assert(\n      !(dpFlags.setValue && dpFlags.isAccessor()) &&\n      \"Cannot set both value and accessor\");\n  assert(\n      (dpFlags.setValue || dpFlags.isAccessor() ||\n       valueOrAccessor.get().isUndefined()) &&\n      \"value must be undefined when all of setValue/setSetter/setGetter are \"\n      \"false\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"Cannot set internalSetter on a computed property\");\n#ifndef NDEBUG\n  if (dpFlags.isAccessor()) {\n    assert(valueOrAccessor.get().isPointer() && \"accessor must be non-empty\");\n    assert(\n        !dpFlags.setWritable && !dpFlags.writable &&\n        \"writable must not be set with accessors\");\n  }\n#endif\n\n  // If the name is a valid integer array index, store it here.\n  OptValue<uint32_t> arrayIndex;\n\n  // If we have indexed storage, we must attempt to convert the name to array\n  // index, even if the conversion is expensive.\n  if (selfHandle->flags_.indexedStorage) {\n    MutableHandle<StringPrimitive> strPrim{runtime};\n    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);\n  }\n\n  SymbolID id{};\n\n  // If not storing a property with an array index name, or if we don't have\n  // indexed storage, just pass to the named routine.\n  if (!arrayIndex) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return defineOwnProperty(\n        selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n  }\n\n  // At this point we know that we have indexed storage and that the property\n  // has an index-like name.\n\n  // First check if a named property with the same name exists.\n  if (selfHandle->clazz_.get(runtime)->getHasIndexLikeProperties()) {\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n\n    NamedPropertyDescriptor desc;\n    auto pos = findProperty(selfHandle, runtime, id, desc);\n    // If we found a named property, update it.\n    if (pos) {\n      return updateOwnProperty(\n          selfHandle,\n          runtime,\n          id,\n          *pos,\n          desc,\n          dpFlags,\n          valueOrAccessor,\n          opFlags);\n    }\n  }\n\n  // Does an indexed property with that index exist?\n  auto indexedPropPresent =\n      getOwnIndexedPropertyFlags(selfHandle.get(), runtime, *arrayIndex);\n  if (indexedPropPresent) {\n    // The current value of the property.\n    HermesValue curValueOrAccessor =\n        getOwnIndexed(selfHandle.get(), runtime, *arrayIndex);\n\n    auto updateStatus = checkPropertyUpdate(\n        runtime,\n        *indexedPropPresent,\n        dpFlags,\n        curValueOrAccessor,\n        valueOrAccessor,\n        opFlags);\n    if (updateStatus == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    if (updateStatus->first == PropertyUpdateStatus::failed)\n      return false;\n\n    // The property update is valid, but can the property remain an \"indexed\"\n    // property, or do we need to convert it to a named property?\n    // If the property flags didn't change, the property remains indexed.\n    if (updateStatus->second == *indexedPropPresent) {\n      // If the value doesn't change, we are done.\n      if (updateStatus->first == PropertyUpdateStatus::done)\n        return true;\n\n      // If we successfully updated the value, we are done.\n      auto result =\n          setOwnIndexed(selfHandle, runtime, *arrayIndex, valueOrAccessor);\n      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*result)\n        return true;\n\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\n            \"cannot change read-only property value\");\n      }\n\n      return false;\n    }\n\n    // OK, we need to convert an indexed property to a named one.\n\n    // Check whether to use the supplied value, or to reuse the old one, as we\n    // are simply reconfiguring it.\n    MutableHandle<> value{runtime};\n    if (dpFlags.setValue || dpFlags.isAccessor()) {\n      value = valueOrAccessor.get();\n    } else {\n      value = curValueOrAccessor;\n    }\n\n    // Update dpFlags to match the existing property flags.\n    dpFlags.setEnumerable = 1;\n    dpFlags.setWritable = 1;\n    dpFlags.setConfigurable = 1;\n    dpFlags.enumerable = updateStatus->second.enumerable;\n    dpFlags.writable = updateStatus->second.writable;\n    dpFlags.configurable = updateStatus->second.configurable;\n\n    // Delete the existing indexed property.\n    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n\n    // Add the new named property.\n    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n    return addOwnProperty(selfHandle, runtime, id, dpFlags, value, opFlags);\n  }\n\n  /// Can we add new properties?\n  if (!selfHandle->isExtensible()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          \"cannot add a new property\"); // TODO: better message.\n    }\n    return false;\n  }\n\n  // This is a new property with an index-like name.\n  // Check whether we need to update array's \".length\" property.\n  bool updateLength = false;\n  if (auto arrayHandle = Handle<JSArray>::dyn_vmcast(selfHandle)) {\n    if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(*arrayHandle))) {\n      NamedPropertyDescriptor lengthDesc;\n      bool lengthPresent = getOwnNamedDescriptor(\n          arrayHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::length),\n          lengthDesc);\n      (void)lengthPresent;\n      assert(lengthPresent && \".length must be present in JSArray\");\n\n      if (!lengthDesc.flags.writable) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"Cannot assign to read-only 'length' property of array\");\n        }\n        return false;\n      }\n\n      updateLength = true;\n    }\n  }\n\n  bool newIsIndexed = canNewPropertyBeIndexed(dpFlags);\n  if (newIsIndexed) {\n    auto result = setOwnIndexed(\n        selfHandle,\n        runtime,\n        *arrayIndex,\n        dpFlags.setValue ? valueOrAccessor : Runtime::getUndefinedValue());\n    if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    if (!*result) {\n      if (opFlags.getThrowOnError()) {\n        // TODO: better error message.\n        return runtime->raiseTypeError(\"Cannot define property\");\n      }\n      return false;\n    }\n  }\n\n  // If this is an array and we need to update \".length\", do so.\n  if (updateLength) {\n    // This should always succeed since we are simply enlarging the length.\n    auto res = JSArray::setLength(\n        Handle<JSArray>::vmcast(selfHandle), runtime, *arrayIndex + 1, opFlags);\n    (void)res;\n    assert(\n        res != ExecutionStatus::EXCEPTION && *res &&\n        \"JSArray::setLength() failed unexpectedly\");\n  }\n\n  if (newIsIndexed)\n    return true;\n\n  // We are adding a new property with an index-like name.\n  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);\n  return addOwnProperty(\n      selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);\n}\n\nCallResult<bool> JSObject::defineOwnComputed(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return defineOwnComputedPrimitive(\n      selfHandle, runtime, *converted, dpFlags, valueOrAccessor, opFlags);\n}\n\nstd::string JSObject::getHeuristicTypeName(GC *gc) {\n  PointerBase *const base = gc->getPointerBase();\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (auto *constructor = dyn_vmcast<JSObject>(*constructorVal)) {\n      auto name = constructor->getNameIfExists(base);\n      // If the constructor's name doesn't exist, or it is just the object\n      // constructor, attempt to find a different name.\n      if (!name.empty() && name != \"Object\")\n        return name;\n    }\n  }\n\n  std::string name = getVT()->base.snapshotMetaData.defaultNameForNode(this);\n  // A constructor's name was not found, check if the object is in dictionary\n  // mode.\n  if (getClass(base)->isDictionary()) {\n    return name + \"(Dictionary)\";\n  }\n\n  // If it's not an Object, the CellKind is most likely good enough on its own\n  if (getKind() != CellKind::ObjectKind) {\n    return name;\n  }\n\n  // If the object isn't a dictionary, and it has only a few property names,\n  // make the name based on those property names.\n  std::vector<std::string> propertyNames;\n  HiddenClass::forEachPropertyNoAlloc(\n      getClass(base),\n      base,\n      [gc, &propertyNames](SymbolID id, NamedPropertyDescriptor) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        propertyNames.emplace_back(gc->convertSymbolToUTF8(id));\n      });\n  // NOTE: One option is to sort the property names before truncation, to\n  // reduce the number of groups; however, by not sorting them it makes it\n  // easier to spot sets of objects with the same properties but in different\n  // orders, and thus find HiddenClass optimizations to make.\n\n  // For objects with a lot of properties but aren't in dictionary mode yet,\n  // keep the number displayed small.\n  constexpr int kMaxPropertiesForTypeName = 5;\n  bool truncated = false;\n  if (propertyNames.size() > kMaxPropertiesForTypeName) {\n    propertyNames.erase(\n        propertyNames.begin() + kMaxPropertiesForTypeName, propertyNames.end());\n    truncated = true;\n  }\n  // The final name should look like Object(a, b, c).\n  if (propertyNames.empty()) {\n    // Don't add parentheses for objects with no properties.\n    return name;\n  }\n  name += \"(\";\n  bool first = true;\n  for (const auto &prop : propertyNames) {\n    if (!first) {\n      name += \", \";\n    }\n    first = false;\n    name += prop;\n  }\n  if (truncated) {\n    // No need to check for comma edge case because this only happens for\n    // greater than one property.\n    static_assert(\n        kMaxPropertiesForTypeName >= 1,\n        \"Property truncation should not happen for 0 properties\");\n    name += \", ...\";\n  }\n  name += \")\";\n  return name;\n}\n\nstd::string JSObject::getNameIfExists(PointerBase *base) {\n  // Try \"displayName\" first, if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::displayName))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // Next, use \"name\" if it is defined.\n  if (auto nameVal = tryGetNamedNoAlloc(\n          this, base, Predefined::getSymbolID(Predefined::name))) {\n    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {\n      return converter(name);\n    }\n  }\n  // There is no other way to access the \"name\" property on an object.\n  return \"\";\n}\n\nstd::string JSObject::_snapshotNameImpl(GCCell *cell, GC *gc) {\n  auto *const self = vmcast<JSObject>(cell);\n  return self->getHeuristicTypeName(gc);\n}\n\nvoid JSObject::_snapshotAddEdgesImpl(GCCell *cell, GC *gc, HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n\n  // Add the prototype as a property edge, so it's easy for JS developers to\n  // walk the prototype chain on their own.\n  if (self->parent_) {\n    snap.addNamedEdge(\n        HeapSnapshot::EdgeType::Property,\n        // __proto__ chosen for similarity to V8.\n        \"__proto__\",\n        gc->getObjectID(self->parent_));\n  }\n\n  HiddenClass::forEachPropertyNoAlloc(\n      self->clazz_.get(gc->getPointerBase()),\n      gc->getPointerBase(),\n      [self, gc, &snap](SymbolID id, NamedPropertyDescriptor desc) {\n        if (InternalProperty::isInternal(id)) {\n          // Internal properties aren't user-visible, skip them.\n          return;\n        }\n        // Else, it's a user-visible property.\n        GCHermesValue &prop =\n            namedSlotRef(self, gc->getPointerBase(), desc.slot);\n        const llvh::Optional<HeapSnapshot::NodeID> idForProp =\n            gc->getSnapshotID(prop);\n        if (!idForProp) {\n          return;\n        }\n        std::string propName = gc->convertSymbolToUTF8(id);\n        // If the property name is a valid array index, display it as an\n        // \"element\" instead of a \"property\". This will put square brackets\n        // around the number and sort it numerically rather than\n        // alphabetically.\n        if (auto index = ::hermes::toArrayIndex(propName)) {\n          snap.addIndexedEdge(\n              HeapSnapshot::EdgeType::Element,\n              index.getValue(),\n              idForProp.getValue());\n        } else {\n          snap.addNamedEdge(\n              HeapSnapshot::EdgeType::Property, propName, idForProp.getValue());\n        }\n      });\n}\n\nvoid JSObject::_snapshotAddLocationsImpl(\n    GCCell *cell,\n    GC *gc,\n    HeapSnapshot &snap) {\n  auto *const self = vmcast<JSObject>(cell);\n  PointerBase *const base = gc->getPointerBase();\n  // Add the location of the constructor function for this object, if that\n  // constructor is a user-defined JS function.\n  if (auto constructorVal = tryGetNamedNoAlloc(\n          self, base, Predefined::getSymbolID(Predefined::constructor))) {\n    if (constructorVal->isObject()) {\n      if (auto *constructor = dyn_vmcast<JSFunction>(*constructorVal)) {\n        constructor->addLocationToSnapshot(snap, gc->getObjectID(self));\n      }\n    }\n  }\n}\n\nstd::pair<uint32_t, uint32_t> JSObject::_getOwnIndexedRangeImpl(\n    JSObject *self,\n    Runtime *runtime) {\n  return {0, 0};\n}\n\nbool JSObject::_haveOwnIndexedImpl(JSObject *self, Runtime *, uint32_t) {\n  return false;\n}\n\nOptValue<PropertyFlags> JSObject::_getOwnIndexedPropertyFlagsImpl(\n    JSObject *self,\n    Runtime *runtime,\n    uint32_t) {\n  return llvh::None;\n}\n\nHermesValue JSObject::_getOwnIndexedImpl(JSObject *, Runtime *, uint32_t) {\n  return HermesValue::encodeEmptyValue();\n}\n\nCallResult<bool>\nJSObject::_setOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t, Handle<>) {\n  return false;\n}\n\nbool JSObject::_deleteOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t) {\n  return false;\n}\n\nbool JSObject::_checkAllOwnIndexedImpl(\n    JSObject * /*self*/,\n    Runtime * /*runtime*/,\n    ObjectVTable::CheckAllOwnIndexedMode /*mode*/) {\n  return true;\n}\n\nvoid JSObject::preventExtensions(JSObject *self) {\n  assert(\n      !self->flags_.proxyObject &&\n      \"[[Extensible]] slot cannot be set directly on Proxy objects\");\n  self->flags_.noExtend = true;\n}\n\nCallResult<bool> JSObject::preventExtensions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropOpFlags opFlags) {\n  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {\n    return JSProxy::preventExtensions(selfHandle, runtime, opFlags);\n  }\n  JSObject::preventExtensions(*selfHandle);\n  return true;\n}\n\nExecutionStatus JSObject::seal(Handle<JSObject> selfHandle, Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes && \"seal preventExtensions with ThrowOnError returned false\");\n\n  // Already sealed?\n  if (selfHandle->flags_.sealed)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllNonConfigurable(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus JSObject::freeze(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime) {\n  CallResult<bool> statusRes = JSObject::preventExtensions(\n      selfHandle, runtime, PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  assert(\n      *statusRes &&\n      \"freeze preventExtensions with ThrowOnError returned false\");\n\n  // Already frozen?\n  if (selfHandle->flags_.frozen)\n    return ExecutionStatus::RETURNED;\n\n  auto newClazz = HiddenClass::makeAllReadOnly(\n      runtime->makeHandle(selfHandle->clazz_), runtime);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n\n  return ExecutionStatus::RETURNED;\n}\n\nvoid JSObject::updatePropertyFlagsWithoutTransitions(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    PropertyFlags flagsToClear,\n    PropertyFlags flagsToSet,\n    OptValue<llvh::ArrayRef<SymbolID>> props) {\n  auto newClazz = HiddenClass::updatePropertyFlagsWithoutTransitions(\n      runtime->makeHandle(selfHandle->clazz_),\n      runtime,\n      flagsToClear,\n      flagsToSet,\n      props);\n  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n}\n\nCallResult<bool> JSObject::isExtensible(\n    PseudoHandle<JSObject> self,\n    Runtime *runtime) {\n  if (LLVM_UNLIKELY(self->isProxyObject())) {\n    return JSProxy::isExtensible(runtime->makeHandle(std::move(self)), runtime);\n  }\n  return self->isExtensible();\n}\n\nbool JSObject::isSealed(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.sealed)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllNonConfigurable(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::NonConfigurable)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nbool JSObject::isFrozen(PseudoHandle<JSObject> self, Runtime *runtime) {\n  if (self->flags_.frozen)\n    return true;\n  if (!self->flags_.noExtend)\n    return false;\n\n  auto selfHandle = runtime->makeHandle(std::move(self));\n\n  if (!HiddenClass::areAllReadOnly(\n          runtime->makeHandle(selfHandle->clazz_), runtime)) {\n    return false;\n  }\n\n  if (!checkAllOwnIndexed(\n          *selfHandle,\n          runtime,\n          ObjectVTable::CheckAllOwnIndexedMode::ReadOnly)) {\n    return false;\n  }\n\n  // Now that we know we are sealed, set the flag.\n  selfHandle->flags_.frozen = true;\n  selfHandle->flags_.sealed = true;\n  return true;\n}\n\nCallResult<bool> JSObject::addOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  /// Can we add more properties?\n  if (!selfHandle->isExtensible() && !opFlags.getInternalForce()) {\n    if (opFlags.getThrowOnError()) {\n      return runtime->raiseTypeError(\n          TwineChar16(\"Cannot add new property '\") +\n          runtime->getIdentifierTable().getStringViewForDev(runtime, name) +\n          \"'\");\n    }\n    return false;\n  }\n\n  PropertyFlags flags{};\n\n  // Accessors don't set writeable.\n  if (dpFlags.isAccessor()) {\n    dpFlags.setWritable = 0;\n    flags.accessor = 1;\n  }\n\n  // Override the default flags if specified.\n  if (dpFlags.setEnumerable)\n    flags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    flags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    flags.configurable = dpFlags.configurable;\n  flags.internalSetter = dpFlags.enableInternalSetter;\n\n  if (LLVM_UNLIKELY(\n          addOwnPropertyImpl(\n              selfHandle, runtime, name, flags, valueOrAccessor) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  return true;\n}\n\nExecutionStatus JSObject::addOwnPropertyImpl(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    PropertyFlags propertyFlags,\n    Handle<> valueOrAccessor) {\n  assert(\n      !selfHandle->flags_.proxyObject &&\n      \"Internal properties cannot be added to Proxy objects\");\n  // Add a new property to the class.\n  // TODO: if we check for OOM here in the future, we must undo the slot\n  // allocation.\n  auto addResult = HiddenClass::addProperty(\n      runtime->makeHandle(selfHandle->clazz_), runtime, name, propertyFlags);\n  if (LLVM_UNLIKELY(addResult == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  selfHandle->clazz_.set(runtime, *addResult->first, &runtime->getHeap());\n\n  allocateNewSlotStorage(\n      selfHandle, runtime, addResult->second, valueOrAccessor);\n\n  // If this is an index-like property, we need to clear the fast path flags.\n  if (LLVM_UNLIKELY(\n          selfHandle->clazz_.getNonNull(runtime)->getHasIndexLikeProperties()))\n    selfHandle->flags_.fastIndexProperties = false;\n\n  return ExecutionStatus::RETURNED;\n}\n\nCallResult<bool> JSObject::updateOwnProperty(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    HiddenClass::PropertyPos propertyPos,\n    NamedPropertyDescriptor desc,\n    const DefinePropertyFlags dpFlags,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  auto updateStatus = checkPropertyUpdate(\n      runtime,\n      desc.flags,\n      dpFlags,\n      getNamedSlotValue(selfHandle.get(), runtime, desc),\n      valueOrAccessor,\n      opFlags);\n  if (updateStatus == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n  if (updateStatus->first == PropertyUpdateStatus::failed)\n    return false;\n\n  // If the property flags changed, update them.\n  if (updateStatus->second != desc.flags) {\n    desc.flags = updateStatus->second;\n    auto newClazz = HiddenClass::updateProperty(\n        runtime->makeHandle(selfHandle->clazz_),\n        runtime,\n        propertyPos,\n        desc.flags);\n    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());\n  }\n\n  if (updateStatus->first == PropertyUpdateStatus::done)\n    return true;\n  assert(\n      updateStatus->first == PropertyUpdateStatus::needSet &&\n      \"unexpected PropertyUpdateStatus\");\n\n  if (dpFlags.setValue) {\n    if (LLVM_LIKELY(!desc.flags.internalSetter))\n      setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n    else\n      return internalSetter(\n          selfHandle, runtime, name, desc, valueOrAccessor, opFlags);\n  } else if (dpFlags.isAccessor()) {\n    setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());\n  } else {\n    // If checkPropertyUpdate() returned needSet, but there is no value or\n    // accessor, clear the value.\n    setNamedSlotValue(\n        selfHandle.get(), runtime, desc, HermesValue::encodeUndefinedValue());\n  }\n\n  return true;\n}\n\nCallResult<std::pair<JSObject::PropertyUpdateStatus, PropertyFlags>>\nJSObject::checkPropertyUpdate(\n    Runtime *runtime,\n    const PropertyFlags currentFlags,\n    DefinePropertyFlags dpFlags,\n    const HermesValue curValueOrAccessor,\n    Handle<> valueOrAccessor,\n    PropOpFlags opFlags) {\n  // 8.12.9 [5] Return true, if every field in Desc is absent.\n  if (dpFlags.isEmpty())\n    return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n\n  assert(\n      (!dpFlags.isAccessor() || (!dpFlags.setWritable && !dpFlags.writable)) &&\n      \"can't set both accessor and writable\");\n  assert(\n      !dpFlags.enableInternalSetter &&\n      \"cannot change the value of internalSetter\");\n\n  // 8.12.9 [6] Return true, if every field in Desc also occurs in current and\n  // the value of every field in Desc is the same value as the corresponding\n  // field in current when compared using the SameValue algorithm (9.12).\n  // TODO: this would probably be much more efficient with bitmasks.\n  if ((!dpFlags.setEnumerable ||\n       dpFlags.enumerable == currentFlags.enumerable) &&\n      (!dpFlags.setConfigurable ||\n       dpFlags.configurable == currentFlags.configurable)) {\n    if (dpFlags.isAccessor()) {\n      if (currentFlags.accessor) {\n        auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n        auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n        if ((!dpFlags.setGetter ||\n             curAccessor->getter == newAccessor->getter) &&\n            (!dpFlags.setSetter ||\n             curAccessor->setter == newAccessor->setter)) {\n          return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n        }\n      }\n    } else {\n      if (!currentFlags.accessor &&\n          (!dpFlags.setValue ||\n           isSameValue(curValueOrAccessor, valueOrAccessor.get())) &&\n          (!dpFlags.setWritable || dpFlags.writable == currentFlags.writable)) {\n        return std::make_pair(PropertyUpdateStatus::done, currentFlags);\n      }\n    }\n  }\n\n  // 8.12.9 [7]\n  // If the property is not configurable, some aspects are not changeable.\n  if (!currentFlags.configurable) {\n    // Trying to change non-configurable to configurable?\n    if (dpFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // Trying to change the enumerability of non-configurable property?\n    if (dpFlags.setEnumerable &&\n        dpFlags.enumerable != currentFlags.enumerable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n  }\n\n  PropertyFlags newFlags = currentFlags;\n\n  // 8.12.9 [8] If IsGenericDescriptor(Desc) is true, then no further validation\n  // is required.\n  if (!(dpFlags.setValue || dpFlags.setWritable || dpFlags.setGetter ||\n        dpFlags.setSetter)) {\n    // Do nothing\n  }\n  // 8.12.9 [9]\n  // Changing between accessor and data descriptor?\n  else if (currentFlags.accessor != dpFlags.isAccessor()) {\n    if (!currentFlags.configurable) {\n      if (opFlags.getThrowOnError()) {\n        return runtime->raiseTypeError(\n            \"property is not configurable\"); // TODO: better message.\n      }\n      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n    }\n\n    // If we change from accessor to data descriptor, Preserve the existing\n    // values of the converted property\u2019s [[Configurable]] and [[Enumerable]]\n    // attributes and set the rest of the property\u2019s attributes to their default\n    // values.\n    // If it's the other way around, since the accessor doesn't have the\n    // [[Writable]] attribute, do nothing.\n    newFlags.writable = 0;\n\n    // If we are changing from accessor to non-accessor, we must set a new\n    // value.\n    if (!dpFlags.isAccessor())\n      dpFlags.setValue = 1;\n  }\n  // 8.12.9 [10] if both are data descriptors.\n  else if (!currentFlags.accessor) {\n    if (!currentFlags.configurable) {\n      if (!currentFlags.writable) {\n        // If the current property is not writable, but the new one is.\n        if (dpFlags.writable) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not configurable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n\n        // If we are setting a different value.\n        if (dpFlags.setValue &&\n            !isSameValue(curValueOrAccessor, valueOrAccessor.get())) {\n          if (opFlags.getThrowOnError()) {\n            return runtime->raiseTypeError(\n                \"property is not writable\"); // TODO: better message.\n          }\n          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n        }\n      }\n    }\n  }\n  // 8.12.9 [11] Both are accessors.\n  else {\n    auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);\n    auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());\n\n    // If not configurable, make sure that nothing is changing.\n    if (!currentFlags.configurable) {\n      if ((dpFlags.setGetter && newAccessor->getter != curAccessor->getter) ||\n          (dpFlags.setSetter && newAccessor->setter != curAccessor->setter)) {\n        if (opFlags.getThrowOnError()) {\n          return runtime->raiseTypeError(\n              \"property is not configurable\"); // TODO: better message.\n        }\n        return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});\n      }\n    }\n\n    // If not setting the getter or the setter, re-use the current one.\n    if (!dpFlags.setGetter)\n      newAccessor->getter.set(\n          runtime, curAccessor->getter, &runtime->getHeap());\n    if (!dpFlags.setSetter)\n      newAccessor->setter.set(\n          runtime, curAccessor->setter, &runtime->getHeap());\n  }\n\n  // 8.12.9 [12] For each attribute field of Desc that is present, set the\n  // correspondingly named attribute of the property named P of object O to the\n  // value of the field.\n  if (dpFlags.setEnumerable)\n    newFlags.enumerable = dpFlags.enumerable;\n  if (dpFlags.setWritable)\n    newFlags.writable = dpFlags.writable;\n  if (dpFlags.setConfigurable)\n    newFlags.configurable = dpFlags.configurable;\n\n  if (dpFlags.setValue)\n    newFlags.accessor = false;\n  else if (dpFlags.isAccessor())\n    newFlags.accessor = true;\n  else\n    return std::make_pair(PropertyUpdateStatus::done, newFlags);\n\n  return std::make_pair(PropertyUpdateStatus::needSet, newFlags);\n}\n\nCallResult<bool> JSObject::internalSetter(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    SymbolID name,\n    NamedPropertyDescriptor /*desc*/,\n    Handle<> value,\n    PropOpFlags opFlags) {\n  if (vmisa<JSArray>(selfHandle.get())) {\n    if (name == Predefined::getSymbolID(Predefined::length)) {\n      return JSArray::setLength(\n          Handle<JSArray>::vmcast(selfHandle), runtime, value, opFlags);\n    }\n  }\n\n  llvm_unreachable(\"unhandled property in Object::internalSetter()\");\n}\n\nnamespace {\n\n/// Helper function to add all the property names of an object to an\n/// array, starting at the given index. Only enumerable properties are\n/// incluced. Returns the index after the last property added, but...\nCallResult<uint32_t> appendAllPropertyNames(\n    Handle<JSObject> obj,\n    Runtime *runtime,\n    MutableHandle<BigStorage> &arr,\n    uint32_t beginIndex) {\n  uint32_t size = beginIndex;\n  // We know that duplicate property names can only exist between objects in\n  // the prototype chain. Hence there should not be duplicated properties\n  // before we start to look at any prototype.\n  bool needDedup = false;\n  MutableHandle<> prop(runtime);\n  MutableHandle<JSObject> head(runtime, obj.get());\n  MutableHandle<StringPrimitive> tmpVal{runtime};\n  while (head.get()) {\n    GCScope gcScope(runtime);\n\n    // enumerableProps will contain all enumerable own properties from obj.\n    // Impl note: this is the only place where getOwnPropertyKeys will be\n    // called without IncludeNonEnumerable on a Proxy.  Everywhere else,\n    // trap ordering is specified but ES9 13.7.5.15 says \"The mechanics and\n    // order of enumerating the properties is not specified\", which is\n    // unusual.\n    auto cr =\n        JSObject::getOwnPropertyNames(head, runtime, true /* onlyEnumerable */);\n    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto enumerableProps = *cr;\n    auto marker = gcScope.createMarker();\n    for (unsigned i = 0, e = enumerableProps->getEndIndex(); i < e; ++i) {\n      gcScope.flushToMarker(marker);\n      prop = enumerableProps->at(runtime, i);\n      if (!needDedup) {\n        // If no dedup is needed, add it directly.\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n        continue;\n      }\n      // Otherwise loop through all existing properties and check if we\n      // have seen it before.\n      bool dupFound = false;\n      if (prop->isNumber()) {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            dupFound = val.getNumber() == prop->getNumber();\n          } else {\n            // val is string, prop is number.\n            tmpVal = val.getString();\n            auto valNum = toArrayIndex(\n                StringPrimitive::createStringView(runtime, tmpVal));\n            dupFound = valNum && valNum.getValue() == prop->getNumber();\n          }\n        }\n      } else {\n        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {\n          HermesValue val = arr->at(j);\n          if (val.isNumber()) {\n            // val is number, prop is string.\n            auto propNum = toArrayIndex(StringPrimitive::createStringView(\n                runtime, Handle<StringPrimitive>::vmcast(prop)));\n            dupFound = propNum && (propNum.getValue() == val.getNumber());\n          } else {\n            dupFound = val.getString()->equals(prop->getString());\n          }\n        }\n      }\n      if (LLVM_LIKELY(!dupFound)) {\n        if (LLVM_UNLIKELY(\n                BigStorage::push_back(arr, runtime, prop) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        ++size;\n      }\n    }\n    // Continue to follow the prototype chain.\n    CallResult<PseudoHandle<JSObject>> parentRes =\n        JSObject::getPrototypeOf(head, runtime);\n    if (LLVM_UNLIKELY(parentRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = parentRes->get();\n    needDedup = true;\n  }\n  return size;\n}\n\n/// Adds the hidden classes of the prototype chain of obj to arr,\n/// starting with the prototype of obj at index 0, etc., and\n/// terminates with null.\n///\n/// \\param obj The object whose prototype chain should be output\n/// \\param[out] arr The array where the classes will be appended. This\n/// array is cleared if any object is unsuitable for caching.\nExecutionStatus setProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    MutableHandle<BigStorage> &arr) {\n  // Layout of a JSArray stored in the for-in cache:\n  // [class(proto(obj)), class(proto(proto(obj))), ..., null, prop0, prop1, ...]\n\n  if (!obj->shouldCacheForIn(runtime)) {\n    arr->clear(runtime);\n    return ExecutionStatus::RETURNED;\n  }\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  MutableHandle<> clazz(runtime);\n  GCScopeMarkerRAII marker{runtime};\n  while (head.get()) {\n    if (!head->shouldCacheForIn(runtime)) {\n      arr->clear(runtime);\n      return ExecutionStatus::RETURNED;\n    }\n    if (JSObject::Helper::flags(*head).lazyObject) {\n      // Ensure all properties have been initialized before caching the hidden\n      // class. Not doing this will result in changes to the hidden class\n      // when getOwnPropertyKeys is called later.\n      JSObject::initializeLazyObject(runtime, head);\n    }\n    clazz = HermesValue::encodeObjectValue(head->getClass(runtime));\n    if (LLVM_UNLIKELY(\n            BigStorage::push_back(arr, runtime, clazz) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    head = head->getParent(runtime);\n    marker.flush();\n  }\n  clazz = HermesValue::encodeNullValue();\n  return BigStorage::push_back(arr, runtime, clazz);\n}\n\n/// Verifies that the classes of obj's prototype chain still matches those\n/// previously prefixed to arr by setProtoClasses.\n///\n/// \\param obj The object whose prototype chain should be verified\n/// \\param arr Array previously populated by setProtoClasses\n/// \\return The index after the terminating null if everything matches,\n/// otherwise 0.\nuint32_t matchesProtoClasses(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    Handle<BigStorage> arr) {\n  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));\n  uint32_t i = 0;\n  while (head.get()) {\n    HermesValue protoCls = arr->at(i++);\n    if (protoCls.isNull() || protoCls.getObject() != head->getClass(runtime) ||\n        head->isProxyObject()) {\n      return 0;\n    }\n    head = head->getParent(runtime);\n  }\n  // The chains must both end at the same point.\n  if (head || !arr->at(i++).isNull()) {\n    return 0;\n  }\n  assert(i > 0 && \"success should be positive\");\n  return i;\n}\n\n} // namespace\n\nCallResult<Handle<BigStorage>> getForInPropertyNames(\n    Runtime *runtime,\n    Handle<JSObject> obj,\n    uint32_t &beginIndex,\n    uint32_t &endIndex) {\n  Handle<HiddenClass> clazz(runtime, obj->getClass(runtime));\n\n  // Fast case: Check the cache.\n  MutableHandle<BigStorage> arr(runtime, clazz->getForInCache(runtime));\n  if (arr) {\n    beginIndex = matchesProtoClasses(runtime, obj, arr);\n    if (beginIndex) {\n      // Cache is valid for this object, so use it.\n      endIndex = arr->size();\n      return arr;\n    }\n    // Invalid for this object. We choose to clear the cache since the\n    // changes to the prototype chain probably affect other objects too.\n    clazz->clearForInCache(runtime);\n    // Clear arr to slightly reduce risk of OOM from allocation below.\n    arr = nullptr;\n  }\n\n  // Slow case: Build the array of properties.\n  auto ownPropEstimate = clazz->getNumProperties();\n  auto arrRes = obj->shouldCacheForIn(runtime)\n      ? BigStorage::createLongLived(runtime, ownPropEstimate)\n      : BigStorage::create(runtime, ownPropEstimate);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  arr = std::move(*arrRes);\n  if (setProtoClasses(runtime, obj, arr) == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  beginIndex = arr->size();\n  // If obj or any of its prototypes are unsuitable for caching, then\n  // beginIndex is 0 and we return an array with only the property names.\n  bool canCache = beginIndex;\n  auto end = appendAllPropertyNames(obj, runtime, arr, beginIndex);\n  if (end == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  endIndex = *end;\n  // Avoid degenerate memory explosion: if > 75% of the array is properties\n  // or classes from prototypes, then don't cache it.\n  const bool tooMuchProto = *end / 4 > ownPropEstimate;\n  if (canCache && !tooMuchProto) {\n    assert(beginIndex > 0 && \"cached array must start with proto classes\");\n#ifdef HERMES_SLOW_DEBUG\n    assert(beginIndex == matchesProtoClasses(runtime, obj, arr) && \"matches\");\n#endif\n    clazz->setForInCache(*arr, runtime);\n  }\n  return arr;\n}\n\n//===----------------------------------------------------------------------===//\n// class PropertyAccessor\n\nVTable PropertyAccessor::vt{CellKind::PropertyAccessorKind,\n                            cellSize<PropertyAccessor>()};\n\nvoid PropertyAccessorBuildMeta(const GCCell *cell, Metadata::Builder &mb) {\n  const auto *self = static_cast<const PropertyAccessor *>(cell);\n  mb.addField(\"getter\", &self->getter);\n  mb.addField(\"setter\", &self->setter);\n}\n\n#ifdef HERMESVM_SERIALIZE\nPropertyAccessor::PropertyAccessor(Deserializer &d)\n    : GCCell(&d.getRuntime()->getHeap(), &vt) {\n  d.readRelocation(&getter, RelocationKind::GCPointer);\n  d.readRelocation(&setter, RelocationKind::GCPointer);\n}\n\nvoid PropertyAccessorSerialize(Serializer &s, const GCCell *cell) {\n  auto *self = vmcast<const PropertyAccessor>(cell);\n  s.writeRelocation(self->getter.get(s.getRuntime()));\n  s.writeRelocation(self->setter.get(s.getRuntime()));\n  s.endObject(cell);\n}\n\nvoid PropertyAccessorDeserialize(Deserializer &d, CellKind kind) {\n  assert(kind == CellKind::PropertyAccessorKind && \"Expected PropertyAccessor\");\n  void *mem = d.getRuntime()->alloc(cellSize<PropertyAccessor>());\n  auto *cell = new (mem) PropertyAccessor(d);\n  d.endObject(cell);\n}\n#endif\n\nCallResult<HermesValue> PropertyAccessor::create(\n    Runtime *runtime,\n    Handle<Callable> getter,\n    Handle<Callable> setter) {\n  void *mem = runtime->alloc(cellSize<PropertyAccessor>());\n  return HermesValue::encodeObjectValue(\n      new (mem) PropertyAccessor(runtime, *getter, *setter));\n}\n\n} // namespace vm\n} // namespace hermes\n"], "filenames": ["API/jsi/jsi/test/testlib.cpp", "lib/VM/JSObject.cpp"], "buggy_code_start_loc": [394, 1176], "buggy_code_end_loc": [394, 1177], "fixing_code_start_loc": [395, 1176], "fixing_code_end_loc": [412, 1177], "type": "CWE-843", "message": "A type confusion vulnerability when resolving properties of JavaScript objects with specially-crafted prototype chains in Facebook Hermes prior to commit fe52854cdf6725c2eaa9e125995da76e6ceb27da allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "other": {"cve": {"id": "CVE-2020-1911", "sourceIdentifier": "cve-assign@fb.com", "published": "2020-09-04T03:15:09.700", "lastModified": "2020-09-11T17:02:45.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A type confusion vulnerability when resolving properties of JavaScript objects with specially-crafted prototype chains in Facebook Hermes prior to commit fe52854cdf6725c2eaa9e125995da76e6ceb27da allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."}, {"lang": "es", "value": "Una vulnerabilidad de confusi\u00f3n de tipos al resolver propiedades de objetos JavaScript con cadenas de prototipos especialmente dise\u00f1adas en Facebook Hermes versiones anteriores al commit fe52854cdf6725c2eaa9e125995da76e6ceb27da, permite a atacantes ejecutar potencialmente c\u00f3digo arbitrario por medio de un JavaScript dise\u00f1ado. Tome en cuenta que esto solo se puede explotar si la aplicaci\u00f3n que usa Hermes permite una evaluaci\u00f3n de JavaScript que no es confiable. Por lo tanto, la mayor\u00eda de las aplicaciones React Native no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hermes:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.3", "matchCriteriaId": "A050D3EF-B82D-4B22-8504-42B384E738B9"}]}]}], "references": [{"url": "https://github.com/facebook/hermes/commit/fe52854cdf6725c2eaa9e125995da76e6ceb27da", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2020-1911", "source": "cve-assign@fb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hermes/commit/fe52854cdf6725c2eaa9e125995da76e6ceb27da"}}