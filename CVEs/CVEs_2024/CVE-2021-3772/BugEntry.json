{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n * Copyright (c) 2002      Nokia Corp.\n *\n * This is part of the SCTP Linux Kernel Implementation.\n *\n * These are the state functions for the state machine.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Mathew Kotowsky       <kotowsky@sctp.org>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Hui Huang \t    <hui.huang@nokia.com>\n *    Dajiang Zhang \t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Kevin Gao\t\t    <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/sctp.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tconst void *payload, size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t struct sctp_cmd_seq *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       struct sctp_cmd_seq *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic enum sctp_disposition sctp_sf_do_5_2_6_stale(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_shut_8_4_5(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_tabort_8_4_8(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_new_encap_port(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic enum sctp_disposition sctp_stop_t1_and_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\t__be16 error, int sk_err,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_transport *transport);\n\nstatic enum sctp_disposition sctp_sf_abort_violation(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen);\n\nstatic enum sctp_disposition sctp_sf_violation_chunklen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_paramlen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg, void *ext,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_chunk(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_ierror sctp_sf_authenticate(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk);\n\nstatic enum sctp_disposition __sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\n/* Small helper function that checks if the chunk length\n * is of the appropriate length.  The 'required_length' argument\n * is set to be the size of a specific chunk we are testing.\n * Return Values:  true  = Valid length\n * \t\t   false = Invalid length\n *\n */\nstatic inline bool sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\t/* Previously already marked? */\n\tif (unlikely(chunk->pdiscard))\n\t\treturn false;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn false;\n\n\treturn true;\n}\n\n/* Check for format error in an ABORT chunk */\nstatic inline bool sctp_err_chunk_valid(struct sctp_chunk *chunk)\n{\n\tstruct sctp_errhdr *err;\n\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\n\treturn (void *)err == (void *)chunk->chunk_end;\n}\n\n/**********************************************************\n * These are the state functions for handling chunk events.\n **********************************************************/\n\n/*\n * Process the final SHUTDOWN COMPLETE.\n *\n * Section: 4 (C) (diagram), 9.2\n * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify\n * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be\n * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint\n * should stop the T2-shutdown timer and remove all knowledge of the\n * association (and thus the association enters the CLOSED state).\n *\n * Verification Tag: 8.5.1(C), sctpimpguide 2.41.\n * C) Rules for packet carrying SHUTDOWN COMPLETE:\n * ...\n * - The receiver of a SHUTDOWN COMPLETE shall accept the packet\n *   if the Verification Tag field of the packet matches its own tag and\n *   the T bit is not set\n *   OR\n *   it is set to its peer's tag and the T bit is set in the Chunk\n *   Flags.\n *   Otherwise, the receiver MUST silently discard the packet\n *   and take no further action.  An endpoint MUST ignore the\n *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_4_C(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const union sctp_subtype type,\n\t\t\t\t     void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * Respond to a normal INIT chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, B\n * B) \"Z\" shall respond immediately with an INIT ACK chunk.  The\n *    destination IP address of the INIT ACK MUST be set to the source\n *    IP address of the INIT to which this INIT ACK is responding.  In\n *    the response, besides filling in other parameters, \"Z\" must set the\n *    Verification Tag field to Tag_A, and also provide its own\n *    Verification Tag (Tag_Z) in the Initiate Tag field.\n *\n * Verification Tag: Must be 0.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg, *repl, *err_chunk;\n\tstruct sctp_unrecognized_param *unk_param;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_packet *packet;\n\tint len;\n\n\t/* Update socket peer label if first association. */\n\tif (security_sctp_assoc_request((struct sctp_endpoint *)ep,\n\t\t\t\t\tchunk->skb))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * Normally, this would cause an ABORT with a Protocol Violation\n\t * error, but since we don't have an association, we'll\n\t * just discard the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the INIT is coming toward a closing socket, we'll send back\n\t * and ABORT.  Essentially, this catches the race of INIT being\n\t * backloged to the socket at the same time as the user issues close().\n\t * Since the socket and all its associations are going away, we\n\t * can treat this OOTB\n\t */\n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t/* The call, sctp_process_init(), can fail on memory allocation.  */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (struct sctp_init_chunk *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t      sizeof(struct sctp_chunkhdr);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (struct sctp_unrecognized_param *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(struct sctp_chunkhdr));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note:  After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources, nor keep any states for the\n\t * new association.  Otherwise, \"Z\" will be vulnerable to resource\n\t * attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal INIT ACK chunk.\n * We are the side that is initiating the association.\n *\n * Section: 5.1 Normal Establishment of an Association, C\n * C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-init\n *    timer and leave COOKIE-WAIT state. \"A\" shall then send the State\n *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start\n *    the T1-cookie timer, and enter the COOKIE-ECHOED state.\n *\n *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound\n *    DATA chunks, but it MUST be the first chunk in the packet and\n *    until the COOKIE ACK is returned the sender MUST NOT send any\n *    other packets to the peer.\n *\n * Verification Tag: 3.3.3\n *   If the value of the Initiate Tag in a received INIT ACK chunk is\n *   found to be 0, the receiver MUST treat it as an error and close the\n *   association by transmitting an ABORT.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_init_chunk *initchunk;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT-ACK chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_initack_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tenum sctp_error error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes.  If there are no causes,\n\t\t * then there wasn't enough memory.  Just terminate\n\t\t * the association.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t/* SCTP-AUTH, Section 6.3:\n\t\t *    It should be noted that if the receiver wants to tear\n\t\t *    down an association in an authenticated way only, the\n\t\t *    handling of malformed packets should not result in\n\t\t *    tearing down the association.\n\t\t *\n\t\t * This means that if we only want to abort associations\n\t\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t\t * can't destroy this association just because the packet\n\t\t * was malformed.\n\t\t */\n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t/* Tag the variable length parameters.  Note that we never\n\t * convert the parameters in an INIT chunk.\n\t */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\tinitchunk = (struct sctp_init_chunk *)chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t/* Reset init error count upon receipt of INIT-ACK.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall stop the T1-init timer and leave\n\t * COOKIE-WAIT state.  \"A\" shall then ... start the T1-cookie\n\t * timer, and enter the COOKIE-ECHOED state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t/* SCTP-AUTH: generate the association shared keys so that\n\t * we can potentially sign the COOKIE-ECHO.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall then send the State Cookie received in the\n\t * INIT ACK chunk in a COOKIE ECHO chunk, ...\n\t */\n\t/* If there is any errors to report, send the ERROR chunk generated\n\t * for unknown parameters as well.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\nstatic bool sctp_auth_chunk_verify(struct net *net, struct sctp_chunk *chunk,\n\t\t\t\t   const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk auth;\n\n\tif (!chunk->auth_chunk)\n\t\treturn true;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\n\t/* Make sure that we and the peer are AUTH capable */\n\tif (!net->sctp.auth_enable || !asoc->peer.auth_capable)\n\t\treturn false;\n\n\t/* set-up our fake chunk so that we can process it */\n\tauth.skb = chunk->auth_chunk;\n\tauth.asoc = chunk->asoc;\n\tauth.sctp_hdr = chunk->sctp_hdr;\n\tauth.chunk_hdr = (struct sctp_chunkhdr *)\n\t\t\t\tskb_push(chunk->auth_chunk,\n\t\t\t\t\t sizeof(struct sctp_chunkhdr));\n\tskb_pull(chunk->auth_chunk, sizeof(struct sctp_chunkhdr));\n\tauth.transport = chunk->transport;\n\n\treturn sctp_sf_authenticate(asoc, &auth) == SCTP_IERROR_NO_ERROR;\n}\n\n/*\n * Respond to a normal COOKIE ECHO chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, D\n * D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply\n *    with a COOKIE ACK chunk after building a TCB and moving to\n *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with\n *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK\n *    chunk MUST be the first chunk in the packet.\n *\n *   IMPLEMENTATION NOTE: An implementation may choose to send the\n *   Communication Up notification to the SCTP user upon reception\n *   of a valid COOKIE ECHO chunk.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * D) Rules for packet carrying a COOKIE ECHO\n *\n * - When sending a COOKIE ECHO, the endpoint MUST use the value of the\n *   Initial Tag received in the INIT ACK.\n *\n * - The receiver of a COOKIE ECHO follows the procedures in Section 5.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL, *auth_ev = NULL;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_init_chunk *peer_init;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sctp_chunk *repl;\n\tstruct sock *sk;\n\tint error = 0;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(struct sctp_chunkhdr)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the association shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\tif (!new_asoc->peer.auth_capable) {\n\t\tauth_ev = sctp_ulpevent_make_authkey(new_asoc, 0,\n\t\t\t\t\t\t     SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!auth_ev)\n\t\t\tgoto nomem_authev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correctly count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\tif (auth_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(auth_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_authev:\n\tsctp_ulpevent_free(ai_ev);\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal COOKIE ACK chunk.\n * We are the side that is asking for an association.\n *\n * RFC 2960 5.1 Normal Establishment of an Association\n *\n * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie\n *    timer. It may also notify its ULP about the successful\n *    establishment of the association with a Communication Up\n *    notification (see Section 10).\n *\n * Verification Tag:\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Verify that the chunk length for the COOKIE-ACK is OK.\n\t * If we don't do this, any bundled chunks may be junked.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Reset init error count upon receipt of COOKIE-ACK,\n\t * to avoid problems with the management of this\n\t * counter in stale cookie situations when a transition back\n\t * from the COOKIE-ECHOED state to the COOKIE-WAIT\n\t * state is performed.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* Set peer label for connection. */\n\tsecurity_inet_conn_established(ep->base.sk, chunk->skb);\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move\n\t * from the COOKIE-ECHOED state to the ESTABLISHED state,\n\t * stopping the T1-cookie timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* It may also notify its ULP about the successful\n\t * establishment of the association with a Communication Up\n\t * notification (see Section 10).\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\tif (!asoc->peer.auth_capable) {\n\t\tev = sctp_ulpevent_make_authkey(asoc, 0, SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Generate and sendout a heartbeat packet.  */\nstatic enum sctp_disposition sctp_sf_heartbeat(\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Send a heartbeat to our peer.  */\n\treply = sctp_make_heartbeat(asoc, transport, 0);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Set rto_pending indicating that an RTT measurement\n\t * is started with this heartbeat chunk.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Generate a HEARTBEAT packet on the given transport.  */\nenum sctp_disposition sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t/* Section 3.3.5.\n\t * The Sender-specific Heartbeat Info field should normally include\n\t * information about the sender's current time when this HEARTBEAT\n\t * chunk is sent and the destination transport address to which this\n\t * HEARTBEAT is sent (see Section 8.3).\n\t */\n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Set transport error counter and association error counter\n\t\t * when sending heartbeat.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* resend asoc strreset_chunk.  */\nenum sctp_disposition sctp_sf_send_reconf(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->strreset_chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* send hb chunk with padding for PLPMUTD.  */\nenum sctp_disposition sctp_sf_send_probe(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *)arg;\n\tstruct sctp_chunk *reply;\n\n\tif (!sctp_transport_pl_enabled(transport))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_transport_pl_send(transport)) {\n\t\treply = sctp_make_heartbeat(asoc, transport, transport->pl.probe_size);\n\t\tif (!reply)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROBE_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an heartbeat request.\n *\n * Section: 8.3 Path Heartbeat\n * The receiver of the HEARTBEAT should immediately respond with a\n * HEARTBEAT ACK that contains the Heartbeat Information field copied\n * from the received HEARTBEAT chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * When receiving an SCTP packet, the endpoint MUST ensure that the\n * value in the Verification Tag field of the received SCTP packet\n * matches its own Tag. If the received Verification Tag value does not\n * match the receiver's own tag value, the receiver shall silently\n * discard the packet and shall not process it any further except for\n * those cases listed in Section 8.5.1 below.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t     sizeof(struct sctp_heartbeat_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* 8.3 The receiver of the HEARTBEAT should immediately\n\t * respond with a HEARTBEAT ACK that contains the Heartbeat\n\t * Information field copied from the received HEARTBEAT chunk.\n\t */\n\tchunk->subh.hb_hdr = (struct sctp_heartbeathdr *)chunk->skb->data;\n\tparam_hdr = (struct sctp_paramhdr *)chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(struct sctp_chunkhdr);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the returning HEARTBEAT ACK.\n *\n * Section: 8.3 Path Heartbeat\n * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n * should clear the error counter of the destination transport\n * address to which the HEARTBEAT was sent, and mark the destination\n * transport address as active if it is not so marked. The endpoint may\n * optionally report to the upper layer when an inactive destination\n * address is marked as active due to the reception of the latest\n * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also\n * clear the association overall error count as well (as defined\n * in section 8.1).\n *\n * The receiver of the HEARTBEAT ACK should also perform an RTT\n * measurement for that destination transport address using the time\n * value carried in the HEARTBEAT ACK chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_sender_hb_info *hbinfo;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_transport *link;\n\tunsigned long max_interval;\n\tunion sctp_addr from_addr;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr) +\n\t\t\t\t\t    sizeof(*hbinfo)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (struct sctp_sender_hb_info *)chunk->skb->data;\n\t/* Make sure that the length of the parameter is what we expect */\n\tif (ntohs(hbinfo->param_hdr.length) != sizeof(*hbinfo))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t/* This should never happen, but lets log it if so.  */\n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Validate the 64-bit random nonce. */\n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tif (hbinfo->probe_size) {\n\t\tif (hbinfo->probe_size != link->pl.probe_size ||\n\t\t    !sctp_transport_pl_enabled(link))\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\tif (sctp_transport_pl_recv(link))\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t\treturn sctp_sf_send_probe(net, ep, asoc, type, link, commands);\n\t}\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t/* Check if the timestamp looks valid.  */\n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tpr_debug(\"%s: HEARTBEAT ACK with invalid timestamp received \"\n\t\t\t \"for transport:%p\\n\", __func__, link);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of\n\t * the HEARTBEAT should clear the error counter of the\n\t * destination transport address to which the HEARTBEAT was\n\t * sent and mark the destination transport address as active if\n\t * it is not so marked.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Helper function to send out an abort for the restart\n * condition.\n */\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tchar buffer[sizeof(*errhdr) + sizeof(*addrparm)];\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_packet *pkt;\n\tint len;\n\n\t/* Build the error on the stack.   We are way to malloc crazy\n\t * throughout the code today.\n\t */\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\n\t/* Copy into a parm format. */\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(*errhdr);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t/* Assign to the control socket. */\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t/* Association is NULL since this may be a restart attack and we\n\t * want to send back the attacker's vtag.\n\t */\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* Discard the rest of the inbound packet. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t/* Even if there is no memory, treat as a failure so\n\t * the packet will get dropped.\n\t */\n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n/* A restart is occurring, check to make sure no new addresses\n * are being added as we may be under a takeover attack.\n */\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       struct sctp_cmd_seq *commands)\n{\n\tstruct net *net = new_asoc->base.net;\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t/* Implementor's Guide - Section 5.2.2\n\t * ...\n\t * Before responding the endpoint MUST check to see if the\n\t * unexpected INIT adds new addresses to the association. If new\n\t * addresses are added to the association, the endpoint MUST respond\n\t * with an ABORT..\n\t */\n\n\t/* Search through all current addresses and make sure\n\t * we aren't adding any new ones.\n\t */\n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Return success if all addresses were found. */\n\treturn ret;\n}\n\n/* Populate the verification/tie tags based on overlapping INIT\n * scenario.\n *\n * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.\n */\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n/*\n * Compare vtag/tietag values to determine unexpected COOKIE-ECHO\n * handling action.\n *\n * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.\n *\n * Returns value representing action to be taken.   These action values\n * correspond to Action/Description values in RFC 2960, Table 2.\n */\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t/* In this case, the peer may have restarted.  */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t/* Collision case B. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t/* Collision case D. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t/* Collision case C. */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t/* No match to any of the special cases; discard this packet. */\n\treturn 'E';\n}\n\n/* Common helper routine for both duplicate and simultaneous INIT\n * chunk handling.\n */\nstatic enum sctp_disposition sctp_sf_do_unexpected_init(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg, *repl, *err_chunk;\n\tstruct sctp_unrecognized_param *unk_param;\n\tstruct sctp_association *new_asoc;\n\tenum sctp_disposition retval;\n\tstruct sctp_packet *packet;\n\tint len;\n\n\t/* Update socket peer label if first association. */\n\tif (security_sctp_assoc_request((struct sctp_endpoint *)ep,\n\t\t\t\t\tchunk->skb))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * In this case, we generate a protocol violation since we have\n\t * an association established.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tif (SCTP_INPUT_CB(chunk->skb)->encap_port != chunk->transport->encap_port)\n\t\treturn sctp_sf_new_encap_port(net, ep, asoc, type, arg, commands);\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/*\n\t * Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t * FIXME:  We are copying parameters from the endpoint not the\n\t * association.\n\t */\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t/* In the outbound INIT ACK the endpoint MUST copy its current\n\t * Verification Tag and Peers Verification tag into a reserved\n\t * place (local tie-tag and per tie-tag) within the state cookie.\n\t */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (struct sctp_init_chunk *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.   Do not do this check for COOKIE-WAIT state,\n\t * since there are no peer addresses to check against.\n\t * Upon return an ABORT will have been sent if needed.\n\t */\n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t      sizeof(struct sctp_chunkhdr);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (struct sctp_unrecognized_param *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(struct sctp_chunkhdr));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note: After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources for this new association.\n\t * Otherwise, \"Z\" will be vulnerable to resource attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n/*\n * Handle simultaneous INIT.\n * This means we started an INIT and then we got an INIT request from\n * our peer.\n *\n * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n * This usually indicates an initialization collision, i.e., each\n * endpoint is attempting, at about the same time, to establish an\n * association with the other endpoint.\n *\n * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n * endpoint MUST respond with an INIT ACK using the same parameters it\n * sent in its original INIT chunk (including its Verification Tag,\n * unchanged). These original parameters are combined with those from the\n * newly received INIT chunk. The endpoint shall also generate a State\n * Cookie with the INIT ACK. The endpoint uses the parameters sent in its\n * INIT to calculate the State Cookie.\n *\n * After that, the endpoint MUST NOT change its state, the T1-init\n * timer shall be left running and the corresponding TCB MUST NOT be\n * destroyed. The normal procedures for handling State Cookies when\n * a TCB exists will resolve the duplicate INITs to a single association.\n *\n * For an endpoint that is in the COOKIE-ECHOED state it MUST populate\n * its Tie-Tags with the Tag information of itself and its peer (see\n * section 5.2.2 for a description of the Tie-Tags).\n *\n * Verification Tag: Not explicit, but an INIT can not have a valid\n * verification tag, so we skip the check.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_2_1_siminit(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Call helper to do the real work for both simultaneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle duplicated INIT messages.  These are usually delayed\n * restransmissions.\n *\n * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,\n * COOKIE-ECHOED and COOKIE-WAIT\n *\n * Unless otherwise stated, upon reception of an unexpected INIT for\n * this association, the endpoint shall generate an INIT ACK with a\n * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n * current Verification Tag and peer's Verification Tag into a reserved\n * place within the state cookie.  We shall refer to these locations as\n * the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n * containing this INIT ACK MUST carry a Verification Tag value equal to\n * the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n * MUST contain a new Initiation Tag (randomly generated see Section\n * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the\n * existing parameters of the association (e.g. number of outbound\n * streams) into the INIT ACK and cookie.\n *\n * After sending out the INIT ACK, the endpoint shall take no further\n * actions, i.e., the existing association, including its current state,\n * and the corresponding TCB MUST NOT be changed.\n *\n * Note: Only when a TCB exists and the association is not in a COOKIE-\n * WAIT state are the Tie-Tags populated.  For a normal association INIT\n * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n * set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n * State Cookie are populated as specified in section 5.2.1.\n *\n * Verification Tag: Not specified, but an INIT has no way of knowing\n * what the verification tag could be, so we ignore it.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_2_2_dupinit(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Call helper to do the real work for both simultaneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n/*\n * Unexpected INIT-ACK handler.\n *\n * Section 5.2.3\n * If an INIT ACK received by an endpoint in any state other than the\n * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.\n * An unexpected INIT ACK usually indicates the processing of an old or\n * duplicated INIT chunk.\n*/\nenum sctp_disposition sctp_sf_do_5_2_3_initack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Per the above section, we'll discard the chunk if we have an\n\t * endpoint.  If this is an OOTB INIT-ACK, treat it as such.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\nstatic int sctp_sf_do_assoc_update(struct sctp_association *asoc,\n\t\t\t\t   struct sctp_association *new,\n\t\t\t\t   struct sctp_cmd_seq *cmds)\n{\n\tstruct net *net = asoc->base.net;\n\tstruct sctp_chunk *abort;\n\n\tif (!sctp_assoc_update(asoc, new))\n\t\treturn 0;\n\n\tabort = sctp_make_abort(asoc, NULL, sizeof(struct sctp_errhdr));\n\tif (abort) {\n\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\tsctp_add_cmd_sf(cmds, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t}\n\tsctp_add_cmd_sf(cmds, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(cmds, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_RSRC_LOW));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn -ENOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action 'A')\n *\n * Section 5.2.4\n *  A)  In this case, the peer may have restarted.\n */\nstatic enum sctp_disposition sctp_sf_do_dupcook_a(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_init_chunk *peer_init;\n\tenum sctp_disposition disposition;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.  Though this is a pretty complicated attack\n\t * since you'd have to get inside the cookie.\n\t */\n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes\n\t * the peer has restarted (Action A), it MUST NOT setup a new\n\t * association but instead resend the SHUTDOWN ACK and send an ERROR\n\t * chunk with a \"Cookie Received while Shutting Down\" error cause to\n\t * its peer.\n\t*/\n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\tSCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\tchunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked\n\t * data. Consider the optional choice of resending of this data.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue\n\t * and ASCONF-ACK cache.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\t/* Update the content of current association. */\n\tif (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))\n\t\tgoto nomem;\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Report association restart to upper layer. */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tif ((sctp_state(asoc, SHUTDOWN_PENDING) ||\n\t     sctp_state(asoc, SHUTDOWN_SENT)) &&\n\t    (sctp_sstate(asoc->base.sk, CLOSING) ||\n\t     sock_flag(asoc->base.sk, SOCK_DEAD))) {\n\t\t/* If the socket has been closed by user, don't\n\t\t * transition to ESTABLISHED. Instead trigger SHUTDOWN\n\t\t * bundled with COOKIE_ACK.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t\treturn sctp_sf_do_9_2_start_shutdown(net, ep, asoc,\n\t\t\t\t\t\t     SCTP_ST_CHUNK(0), repl,\n\t\t\t\t\t\t     commands);\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'B')\n *\n * Section 5.2.4\n *   B) In this case, both sides may be attempting to start an association\n *      at about the same time but the peer endpoint started its INIT\n *      after responding to the local endpoint's INIT\n */\n/* This case represents an initialization collision.  */\nstatic enum sctp_disposition sctp_sf_do_dupcook_b(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_init_chunk *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tif (asoc->state < SCTP_STATE_ESTABLISHED)\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\t/* Update the content of current association.  */\n\tif (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))\n\t\tgoto nomem;\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\tif (!asoc->peer.auth_capable)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_NO_AUTH, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'C')\n *\n * Section 5.2.4\n *  C) In this case, the local endpoint's cookie has arrived late.\n *     Before it arrived, the local endpoint sent an INIT and received an\n *     INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n *     but a new tag of its own.\n */\n/* This case represents an initialization collision.  */\nstatic enum sctp_disposition sctp_sf_do_dupcook_c(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t/* The cookie should be silently discarded.\n\t * The endpoint SHOULD NOT change states and should leave\n\t * any timers running.\n\t */\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action 'D')\n *\n * Section 5.2.4\n *\n * D) When both local and remote tags match the endpoint should always\n *    enter the ESTABLISHED state, if it has not already done so.\n */\n/* This case represents an initialization collision.  */\nstatic enum sctp_disposition sctp_sf_do_dupcook_d(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL, *auth_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t/* Clarification from Implementor's Guide:\n\t * D) When both local and remote tags match the endpoint should\n\t * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.\n\t * It should stop any cookie timer that may be running and send\n\t * a COOKIE ACK.\n\t */\n\n\tif (!sctp_auth_chunk_verify(net, chunk, asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t/* Don't accidentally move back into established state. */\n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t\t *\n\t\t * D) IMPLEMENTATION NOTE: An implementation may choose\n\t\t * to send the Communication Up notification to the\n\t\t * SCTP user upon reception of a valid COOKIE\n\t\t * ECHO chunk.\n\t\t */\n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t/* Sockets API Draft Section 5.3.1.6\n\t\t * When a peer sends a Adaptation Layer Indication parameter,\n\t\t * SCTP delivers this notification to inform the application\n\t\t * that of the peers requested adaptation layer.\n\t\t */\n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\n\t\tif (!asoc->peer.auth_capable) {\n\t\t\tauth_ev = sctp_ulpevent_make_authkey(asoc, 0,\n\t\t\t\t\t\t\t     SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\t\t     GFP_ATOMIC);\n\t\t\tif (!auth_ev)\n\t\t\t\tgoto nomem;\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\tif (auth_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(auth_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (auth_ev)\n\t\tsctp_ulpevent_free(auth_ev);\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying\n * chunk was retransmitted and then delayed in the network.\n *\n * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists\n *\n * Verification Tag: None.  Do cookie validation.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_2_4_dupcook(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *chunk = arg;\n\tenum sctp_disposition retval;\n\tstruct sctp_chunk *err_chk_p;\n\tint error = 0;\n\tchar action;\n\n\t/* Make sure that the chunk has a valid length from the protocol\n\t * perspective.  In this case check to make sure we have at least\n\t * enough for the chunk header.  Cookie length verification is\n\t * done later.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr)))\n\t\tgoto nomem;\n\n\t/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie\n\t * of a duplicate COOKIE ECHO match the Verification Tags of the\n\t * current association, consider the State Cookie valid even if\n\t * the lifespan is exceeded.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t/* Update socket peer label if first association. */\n\tif (security_sctp_assoc_request((struct sctp_endpoint *)ep,\n\t\t\t\t\tchunk->skb)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Set temp so that it won't be added into hashtable */\n\tnew_asoc->temp = 1;\n\n\t/* Compare the tie_tag in cookie with the verification tag of\n\t * current association.\n\t */\n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A': /* Association restart. */\n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B': /* Collision case B. */\n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C': /* Collision case C. */\n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D': /* Collision case D. */\n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault: /* Discard packet for all others. */\n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t/* Delete the temporary new association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t/* Restore association pointer to provide SCTP command interpreter\n\t * with a valid context in case it needs to manipulate\n\t * the queues */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-PENDING state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nenum sctp_disposition sctp_sf_shutdown_pending_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nenum sctp_disposition sctp_sf_shutdown_sent_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Stop the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-ACK-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nenum sctp_disposition sctp_sf_shutdown_ack_sent_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an Error received in COOKIE_ECHOED state.\n *\n * Only handle the error type of stale COOKIE Error, the other errors will\n * be ignored.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_cookie_echoed_err(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_errhdr *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_operr_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle a Stale COOKIE Error\n *\n * Section: 5.2.6 Handle Stale COOKIE Error\n * If the association is in the COOKIE-ECHOED state, the endpoint may elect\n * one of the following three alternatives.\n * ...\n * 3) Send a new INIT chunk to the endpoint, adding a Cookie\n *    Preservative parameter requesting an extension to the lifetime of\n *    the State Cookie. When calculating the time extension, an\n *    implementation SHOULD use the RTT information measured based on the\n *    previous COOKIE ECHO / ERROR exchange, and should add no more\n *    than 1 second beyond the measured RTT, due to long State Cookie\n *    lifetimes making the endpoint more subject to a replay attack.\n *\n * Verification Tag:  Not explicit, but safe to ignore.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nstatic enum sctp_disposition sctp_sf_do_5_2_6_stale(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *chunk = arg, *reply;\n\tstruct sctp_cookie_preserve_param bht;\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_errhdr *err;\n\tu32 stale;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (struct sctp_errhdr *)(chunk->skb->data);\n\n\t/* When calculating the time extension, an implementation\n\t * SHOULD use the RTT information measured based on the\n\t * previous COOKIE ECHO / ERROR exchange, and should add no\n\t * more than 1 second beyond the measured RTT, due to long\n\t * State Cookie lifetimes making the endpoint more subject to\n\t * a replay attack.\n\t * Measure of Staleness's unit is usec. (1/1000000 sec)\n\t * Suggested Cookie Life-span Increment's unit is msec.\n\t * (1/1000 sec)\n\t * In general, if you use the suggested cookie life, the value\n\t * found in the field of measure of staleness should be doubled\n\t * to give ample time to retransmit the new cookie and thus\n\t * yield a higher probability of success on the reattempt.\n\t */\n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(*err)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t/* Build that new INIT chunk.  */\n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t/* Clear peer's init_tag cached in assoc as we are sending a new INIT */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t/* Stop pending T3-rtx and heartbeat timers */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t/* Delete non-primary peer ip addresses since we are transitioning\n\t * back to the COOKIE-WAIT state\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t/* If we've sent any data bundled with COOKIE-ECHO we will need to\n\t * resend\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.\n *\n * Section: 9.1\n * After checking the Verification Tag, the receiving endpoint shall\n * remove the association from its record, and shall report the\n * termination to its upper layer.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * B) Rules for packet carrying ABORT:\n *\n *  - The endpoint shall always fill in the Verification Tag field of the\n *    outbound packet with the destination endpoint's tag value if it\n *    is known.\n *\n *  - If the ABORT is sent in response to an OOTB packet, the endpoint\n *    MUST follow the procedure described in Section 8.4.\n *\n *  - The receiver MUST accept the packet if the Verification Tag\n *    matches either its own tag, OR the tag of its peer. Otherwise, the\n *    receiver MUST silently discard the packet and take no further\n *    action.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic enum sctp_disposition __sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((struct sctp_errhdr *)chunk->skb->data)->cause;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t/* ASSOC_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * Process an ABORT.  (COOKIE-WAIT state)\n *\n * See sctp_sf_do_9_1_abort() above.\n */\nenum sctp_disposition sctp_sf_cookie_wait_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((struct sctp_errhdr *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n/*\n * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)\n */\nenum sctp_disposition sctp_sf_cookie_wait_icmp_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n/*\n * Process an ABORT.  (COOKIE-ECHOED state)\n */\nenum sctp_disposition sctp_sf_cookie_echoed_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Stop T1 timer and abort association with \"INIT failed\".\n *\n * This is common code called by several sctp_sf_*_abort() functions above.\n */\nstatic enum sctp_disposition sctp_stop_t1_and_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\t__be16 error, int sk_err,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_do_9_2_shut\n *\n * Section: 9.2\n * Upon the reception of the SHUTDOWN, the peer endpoint shall\n *  - enter the SHUTDOWN-RECEIVED state,\n *\n *  - stop accepting new data from its SCTP user\n *\n *  - verify, by checking the Cumulative TSN Ack field of the chunk,\n *    that all its outstanding DATA chunks have been received by the\n *    SHUTDOWN sender.\n *\n * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT\n * send a SHUTDOWN in response to a ULP request. And should discard\n * subsequent SHUTDOWN chunks.\n *\n * If there are still outstanding DATA chunks left, the SHUTDOWN\n * receiver shall continue to follow normal data transmission\n * procedures defined in Section 6 until all outstanding DATA chunks\n * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept\n * new data from its SCTP user.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_9_2_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_shutdownhdr *sdh;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Convert the elaborate header.  */\n\tsdh = (struct sctp_shutdownhdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*sdh));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT\n\t * When a peer sends a SHUTDOWN, SCTP delivers this notification to\n\t * inform the application that it should cease sending data.\n\t */\n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the reception of the SHUTDOWN, the peer endpoint shall\n\t *  - enter the SHUTDOWN-RECEIVED state,\n\t *  - stop accepting new data from its SCTP user\n\t *\n\t * [This is implicit in the new state.]\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t/*  - verify, by checking the Cumulative TSN Ack field of the\n\t *    chunk, that all its outstanding DATA chunks have been\n\t *    received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n/*\n * sctp_sf_do_9_2_shut_ctsn\n *\n * Once an endpoint has reached the SHUTDOWN-RECEIVED state,\n * it MUST NOT send a SHUTDOWN in response to a ULP request.\n * The Cumulative TSN Ack of the received SHUTDOWN chunk\n * MUST be processed.\n */\nenum sctp_disposition sctp_sf_do_9_2_shut_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_shutdownhdr *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (struct sctp_shutdownhdr *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* verify, by checking the Cumulative TSN Ack field of the\n\t * chunk, that all its outstanding DATA chunks have been\n\t * received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC 2960 9.2\n * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk\n * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination\n * transport addresses (either in the IP addresses or in the INIT chunk)\n * that belong to this association, it should discard the INIT chunk and\n * retransmit the SHUTDOWN ACK chunk.\n */\nenum sctp_disposition sctp_sf_do_9_2_reshutack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Make sure that the chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Since we are not going to really process this INIT, there\n\t * is no point in verifying chunk boundaries.  Just generate\n\t * the SHUTDOWN ACK.\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-SHUTDOWN timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and restart the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * sctp_sf_do_ecn_cwr\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * CWR:\n *\n * RFC 2481 details a specific bit for a sender to send in the header of\n * its next outbound TCP segment to indicate to its peer that it has\n * reduced its congestion window.  This is termed the CWR bit.  For\n * SCTP the same indication is made by including the CWR chunk.\n * This chunk contains one data element, i.e. the TSN number that\n * was sent in the ECNE chunk.  This element represents the lowest\n * TSN number in the datagram that was originally marked with the\n * CE bit.\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_cwrhdr *cwr;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_ecne_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (struct sctp_cwrhdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*cwr));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_do_ecne\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * ECN-Echo\n *\n * RFC 2481 details a specific bit for a receiver to send back in its\n * TCP acknowledgements to notify the sender of the Congestion\n * Experienced (CE) bit having arrived from the network.  For SCTP this\n * same indication is made by including the ECNE chunk.  This chunk\n * contains one data element, i.e. the lowest TSN associated with the IP\n * datagram marked with the CE bit.....\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_ecne(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const union sctp_subtype type,\n\t\t\t\t      void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ecnehdr *ecne;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_ecne_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (struct sctp_ecnehdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*ecne));\n\n\t/* If this is a newer ECNE than the last CWR packet we sent out */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The SCTP endpoint MUST always acknowledge the reception of each valid\n * DATA chunk.\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated within\n * 200 ms of the arrival of any unacknowledged DATA chunk. In some\n * situations it may be beneficial for an SCTP transmitter to be more\n * conservative than the algorithms detailed in this document allow.\n * However, an SCTP transmitter MUST NOT be more aggressive than the\n * following algorithms allow.\n *\n * A SCTP receiver MUST NOT generate more than one SACK for every\n * incoming packet, other than to update the offered window as the\n * receiving application consumes new data.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tunion sctp_arg force = SCTP_NOFORCE();\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sctp_datachk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\treturn SCTP_DISPOSITION_ABORT;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t\t\t       (u8 *)chunk->subh.data_hdr,\n\t\t\t\t\t       sctp_datahdr_len(&asoc->stream));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* If this is the last chunk in a packet, we need to count it\n\t * toward sack generation.  Note that we need to SACK every\n\t * OTHER packet containing data chunks, EVEN IF WE DISCARD\n\t * THEM.  We elect to NOT generate SACK's if the chunk fails\n\t * the verification tag test.\n\t *\n\t * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * The SCTP endpoint MUST always acknowledge the reception of\n\t * each valid DATA chunk.\n\t *\n\t * The guidelines on delayed acknowledgement algorithm\n\t * specified in  Section 4.2 of [RFC2581] SHOULD be followed.\n\t * Specifically, an acknowledgement SHOULD be generated for at\n\t * least every second packet (not every second DATA chunk)\n\t * received, and SHOULD be generated within 200 ms of the\n\t * arrival of any unacknowledged DATA chunk.  In some\n\t * situations it may be beneficial for an SCTP transmitter to\n\t * be more conservative than the algorithms detailed in this\n\t * document allow. However, an SCTP transmitter MUST NOT be\n\t * more aggressive than the following algorithms allow.\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * When a packet arrives with duplicate DATA chunk(s) and with\n\t * no new DATA chunk(s), the endpoint MUST immediately send a\n\t * SACK with no delay.  If a packet arrives with duplicate\n\t * DATA chunk(s) bundled with new DATA chunks, the endpoint\n\t * MAY immediately send a SACK.  Normally receipt of duplicate\n\t * DATA chunks will occur when the original SACK chunk was lost\n\t * and the peer's RTO has expired.  The duplicate TSN number(s)\n\t * SHOULD be reported in the SACK as duplicate.\n\t */\n\t/* In our case, we split the MAY SACK advice up whether or not\n\t * the last chunk is a duplicate.'\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * sctp_sf_eat_data_fast_4_4\n *\n * Section: 4 (4)\n * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received\n *    DATA chunks without delay.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_data_fast_4_4(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sctp_datachk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\treturn SCTP_DISPOSITION_ABORT;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t\t\t       (u8 *)chunk->subh.data_hdr,\n\t\t\t\t\t       sctp_datahdr_len(&asoc->stream));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Go a head and force a SACK, since we are shutting down. */\n\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tif (chunk->end_of_packet) {\n\t\t/* We must delay the chunk creation since the cumulative\n\t\t * TSN has not been updated yet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Processing a Received SACK\n * D) Any time a SACK arrives, the endpoint performs the following:\n *\n *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,\n *     then drop the SACK.   Since Cumulative TSN Ack is monotonically\n *     increasing, a SACK whose Cumulative TSN Ack is less than the\n *     Cumulative TSN Ack Point indicates an out-of-order SACK.\n *\n *     ii) Set rwnd equal to the newly received a_rwnd minus the number\n *     of bytes still outstanding after processing the Cumulative TSN Ack\n *     and the Gap Ack Blocks.\n *\n *     iii) If the SACK is missing a TSN that was previously\n *     acknowledged via a Gap Ack Block (e.g., the data receiver\n *     reneged on the data), then mark the corresponding DATA chunk\n *     as available for retransmit:  Mark it as missing for fast\n *     retransmit as described in Section 7.2.4 and if no retransmit\n *     timer is running for the destination address to which the DATA\n *     chunk was originally transmitted, then T3-rtx is started for\n *     that destination address.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_sackhdr *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_sack_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Pull the SACK chunk from the data buffer */\n\tsackh = sctp_sm_pull_sack(chunk);\n\t/* Was this a bogus SACK? */\n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (TSN_lte(asoc->next_tsn, ctsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\ttrace_sctp_probe(ep, asoc, chunk);\n\n\t/* i) If Cumulative TSN Ack is less than the Cumulative TSN\n\t *     Ack Point, then drop the SACK.  Since Cumulative TSN\n\t *     Ack is monotonically increasing, a SACK whose\n\t *     Cumulative TSN Ack is less than the Cumulative TSN Ack\n\t *     Point indicates an out-of-order SACK.\n\t */\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Return this SACK for further processing.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t/* Note: We do the rest of the work on the PROCESS_SACK\n\t * sideeffect.\n\t */\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate an ABORT in response to a packet.\n *\n * Section: 8.4 Handle \"Out of the blue\" Packets, sctpimpguide 2.41\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n *\n * Verification Tag:\n *\n * The return value is the disposition of the chunk.\n*/\nstatic enum sctp_disposition sctp_sf_tabort_8_4_8(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Make an ABORT. The T bit will be set if the asoc\n\t * is NULL.\n\t */\n\tabort = sctp_make_abort(asoc, chunk, 0);\n\tif (!abort) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\t/* Reflect vtag if T-Bit is set */\n\tif (sctp_test_T_bit(abort))\n\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t/* Set the skb to the belonging sock for accounting.  */\n\tabort->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, abort);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Handling of SCTP Packets Containing an INIT Chunk Matching an\n * Existing Associations when the UDP encap port is incorrect.\n *\n * From Section 4 at draft-tuexen-tsvwg-sctp-udp-encaps-cons-03.\n */\nstatic enum sctp_disposition sctp_sf_new_encap_port(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tabort = sctp_make_new_encap_port(asoc, chunk);\n\tif (!abort) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\tabort->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, abort);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR\n * event as ULP notification for each cause included in the chunk.\n *\n * API 5.3.1.3 - SCTP_REMOTE_ERROR\n *\n * The return value is the disposition of the chunk.\n*/\nenum sctp_disposition sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_errhdr *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_operr_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an inbound SHUTDOWN ACK.\n *\n * From Section 9.2:\n * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its\n * peer, and remove all record of the association.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* 10.2 H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t/* ...send a SHUTDOWN COMPLETE chunk to its peer, */\n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t/* Do all the commands now (after allocation), so that we\n\t * have consistent state if memory allocation fails\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n\t * stop the T2-shutdown timer,\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t/* ...and remove all record of the association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n */\nenum sctp_disposition sctp_sf_ootb(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t   void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tstruct sctp_chunkhdr *ch;\n\tstruct sctp_errhdr *err;\n\tint ootb_cookie_ack = 0;\n\tint ootb_shut_ack = 0;\n\t__u8 *ch_end;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (struct sctp_chunkhdr *)chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(*ch))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tch = (struct sctp_chunkhdr *)ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an \"Out of the blue\" SHUTDOWN ACK.\n *\n * Section: 8.4 5, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * Inputs\n * (endpoint, asoc, type, arg, commands)\n *\n * Outputs\n * (enum sctp_disposition)\n *\n * The return value is the disposition of the chunk.\n */\nstatic enum sctp_disposition sctp_sf_shut_8_4_5(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Make an SHUTDOWN_COMPLETE.\n\t * The T bit will be set if the asoc is NULL.\n\t */\n\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!shut) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\t/* Reflect vtag if T-Bit is set */\n\tif (sctp_test_T_bit(shut))\n\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t/* Set the skb to the belonging sock for accounting.  */\n\tshut->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, shut);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* If the chunk length is invalid, we don't want to process\n\t * the reset of the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* We need to discard the rest of the packet to prevent\n\t * potential boomming attacks from additional bundled chunks.\n\t * This is documented in SCTP Threats ID.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.\n *\n * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK\n *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the\n *   procedures in section 8.4 SHOULD be followed, in other words it\n *   should be treated as an Out Of The Blue packet.\n *   [This means that we do NOT check the Verification Tag on these\n *   chunks. --piggy ]\n *\n */\nenum sctp_disposition sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Although we do have an association in this case, it corresponds\n\t * to a restarted association. So the packet is treated as an OOTB\n\t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n\t * called with a NULL association.\n\t */\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */\nenum sctp_disposition sctp_sf_do_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *asconf_ack = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_addiphdr *hdr;\n\t__u32 serial;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!asoc->peer.asconf_capable ||\n\t    (!net->sctp.addip_noauth && !chunk->auth))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\n\t\t\t\t\t     commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_addip_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (struct sctp_addiphdr *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc, chunk, true, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t/* Reset the transport so that we select the correct one\n\t\t * this time around.  This is to make sure that we don't\n\t\t * accidentally use a stale transport that's been removed.\n\t\t */\n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created until we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t\tsctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\nstatic enum sctp_disposition sctp_send_next_asconf(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *asconf;\n\tstruct list_head *entry;\n\n\tif (list_empty(&asoc->addip_chunk_list))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\tentry = asoc->addip_chunk_list.next;\n\tasconf = list_entry(entry, struct sctp_chunk, list);\n\n\tlist_del_init(entry);\n\tsctp_chunk_hold(asconf);\n\tasoc->addip_last_asconf = asconf;\n\n\treturn sctp_sf_do_prm_asconf(net, ep, asoc, type, asconf, commands);\n}\n\n/*\n * ADDIP Section 4.3 General rules for address manipulation\n * When building TLV parameters for the ASCONF Chunk that will add or\n * delete IP addresses the D0 to D13 rules should be applied:\n */\nenum sctp_disposition sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *asconf_ack = arg;\n\tstruct sctp_addiphdr *addip_hdr;\n\t__u32 sent_serial, rcvd_serial;\n\tstruct sctp_chunk *abort;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!asoc->peer.asconf_capable ||\n\t    (!net->sctp.addip_noauth && !asconf_ack->auth))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\n\t\t\t\t\t     commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack,\n\t\t\t\t     sizeof(struct sctp_addip_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (struct sctp_addiphdr *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc, asconf_ack, false, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (struct sctp_addiphdr *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(struct sctp_errhdr));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack))\n\t\t\treturn sctp_send_next_asconf(net, ep,\n\t\t\t\t\t(struct sctp_association *)asoc,\n\t\t\t\t\t\t\ttype, commands);\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(struct sctp_errhdr));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* RE-CONFIG Section 5.2 Upon reception of an RECONF Chunk. */\nenum sctp_disposition sctp_sf_do_reconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_reconf_chunk *hdr;\n\tunion sctp_params param;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the RECONF chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(*hdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tif (!sctp_verify_reconf(asoc, chunk, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\thdr = (struct sctp_reconf_chunk *)chunk->chunk_hdr;\n\tsctp_walk_params(param, hdr, params) {\n\t\tstruct sctp_chunk *reply = NULL;\n\t\tstruct sctp_ulpevent *ev = NULL;\n\n\t\tif (param.p->type == SCTP_PARAM_RESET_OUT_REQUEST)\n\t\t\treply = sctp_process_strreset_outreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_IN_REQUEST)\n\t\t\treply = sctp_process_strreset_inreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_TSN_REQUEST)\n\t\t\treply = sctp_process_strreset_tsnreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_ADD_OUT_STREAMS)\n\t\t\treply = sctp_process_strreset_addstrm_out(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_ADD_IN_STREAMS)\n\t\t\treply = sctp_process_strreset_addstrm_in(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_RESPONSE)\n\t\t\treply = sctp_process_strreset_resp(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\n\t\tif (ev)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t\tif (reply)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(reply));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP\n *\n * When a FORWARD TSN chunk arrives, the data receiver MUST first update\n * its cumulative TSN point to the value carried in the FORWARD TSN\n * chunk, and then MUST further advance its cumulative TSN point locally\n * if possible.\n * After the above processing, the data receiver MUST stop reporting any\n * missing TSNs earlier than or equal to the new cumulative TSN point.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sctp_ftsnchk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\tif (!asoc->stream.si->validate_ftsn(chunk))\n\t\tgoto discard_noforce;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sctp_ftsnhdr_len(&asoc->stream))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nenum sctp_disposition sctp_sf_eat_fwd_tsn_fast(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sctp_ftsnchk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\tif (!asoc->stream.si->validate_ftsn(chunk))\n\t\tgoto gen_shutdown;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sctp_ftsnhdr_len(&asoc->stream))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * SCTP-AUTH Section 6.3 Receiving authenticated chunks\n *\n *    The receiver MUST use the HMAC algorithm indicated in the HMAC\n *    Identifier field.  If this algorithm was not specified by the\n *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk\n *    during association setup, the AUTH chunk and all chunks after it MUST\n *    be discarded and an ERROR chunk SHOULD be sent with the error cause\n *    defined in Section 4.1.\n *\n *    If an endpoint with no shared key receives a Shared Key Identifier\n *    other than 0, it MUST silently discard all authenticated chunks.  If\n *    the endpoint has at least one endpoint pair shared key for the peer,\n *    it MUST use the key specified by the Shared Key Identifier if a\n *    key has been configured for that Shared Key Identifier.  If no\n *    endpoint pair shared key has been configured for that Shared Key\n *    Identifier, all authenticated chunks MUST be silently discarded.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nstatic enum sctp_ierror sctp_sf_authenticate(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_shared_key *sh_key = NULL;\n\tstruct sctp_authhdr *auth_hdr;\n\t__u8 *save_digest, *digest;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\n\t/* Pull in the auth header, so we can do some more verification */\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(*auth_hdr));\n\n\t/* Make sure that we support the HMAC algorithm from the auth\n\t * chunk.\n\t */\n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t/* Make sure that the provided shared key identifier has been\n\t * configured\n\t */\n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id) {\n\t\tsh_key = sctp_auth_get_shkey(asoc, key_id);\n\t\tif (!sh_key)\n\t\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\t}\n\n\t/* Make sure that the length of the signature matches what\n\t * we expect.\n\t */\n\tsig_len = ntohs(chunk->chunk_hdr->length) -\n\t\t  sizeof(struct sctp_auth_chunk);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Now that we've done validation checks, we can compute and\n\t * verify the hmac.  The steps involved are:\n\t *  1. Save the digest from the chunk.\n\t *  2. Zero out the digest in the chunk.\n\t *  3. Compute the new digest\n\t *  4. Compare saved and new digests.\n\t */\n\tdigest = auth_hdr->hmac;\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t (struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\t sh_key, GFP_ATOMIC);\n\n\t/* Discard the packet if the digests do not match */\n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nenum sctp_disposition sctp_sf_eat_auth(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *err_chunk;\n\tenum sctp_ierror error;\n\n\t/* Make sure that the peer has AUTH capable */\n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the AUTH chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(asoc, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t/* Generate the ERROR chunk and discard the rest\n\t\t * of the packet\n\t\t */\n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\tfallthrough;\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t/* Prevent gcc warnings */\n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEW_KEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn -ENOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an unknown chunk.\n *\n * Section: 3.2. Also, 2.1 in the implementor's guide.\n *\n * Chunk Types are encoded such that the highest-order two bits specify\n * the action that must be taken if the processing endpoint does not\n * recognize the Chunk Type.\n *\n * 00 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it.\n *\n * 01 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it, and report the unrecognized\n *      chunk in an 'Unrecognized Chunk Type'.\n *\n * 10 - Skip this chunk and continue processing.\n *\n * 11 - Skip this chunk and continue processing, but report in an ERROR\n *      Chunk using the 'Unrecognized Chunk Type' cause of error.\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_chunkhdr *hdr;\n\n\tpr_debug(\"%s: processing unknown chunk id:%d\\n\", __func__, type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(*hdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t/* Discard the packet.  */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       SCTP_PAD4(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t/* Discard the packet.  */\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       SCTP_PAD4(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the chunk.\n *\n * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2\n * [Too numerous to mention...]\n * Verification Tag: No verification needed.\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tpr_debug(\"%s: chunk:%d is discarded\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the whole packet.\n *\n * Section: 8.4 2)\n *\n * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n *    silently discard the OOTB packet and take no further action.\n *\n * Verification Tag: No verification necessary\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_pdiscard(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n/*\n * The other end is violating protocol.\n *\n * Section: Not specified\n * Verification Tag: Not specified\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * We simply tag the chunk as a violation.  The state machine will log\n * the violation and continue.\n */\nenum sctp_disposition sctp_sf_violation(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n/*\n * Common function to handle a protocol violation.\n */\nstatic enum sctp_disposition sctp_sf_abort_violation(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tstruct sctp_initack_chunk *initack;\n\n\t\t\tinitack = (struct sctp_initack_chunk *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk, sizeof(*initack)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a protocol violation when the chunk length is invalid.\n * \"Invalid\" length is identified as smaller than the minimal length a\n * given chunk can be.  For example, a SACK chunk has invalid length\n * if its length is set to be smaller than the size of struct sctp_sack_chunk.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n *\n * Section: Not specified\n * Verification Tag:  Nothing to do\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (reply_msg, msg_up, counters)\n *\n * Generate an  ABORT chunk and terminate the association.\n */\nstatic enum sctp_disposition sctp_sf_violation_chunklen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n\n/*\n * Handle a protocol violation when the parameter length is invalid.\n * If the length is smaller than the minimum length of a given parameter,\n * or accumulated length in multi parameters exceeds the end of the chunk,\n * the length is considered as invalid.\n */\nstatic enum sctp_disposition sctp_sf_violation_paramlen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg, void *ext,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle a protocol violation when the peer trying to advance the\n * cumulative tsn ack to a point beyond the max tsn currently sent.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n */\nstatic enum sctp_disposition sctp_sf_violation_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n\n/* Handle protocol violation of an invalid chunk bundling.  For example,\n * when we have an association and we receive bundled INIT-ACK, or\n * SHUTDOWN-COMPLETE, our peer is clearly violating the \"MUST NOT bundle\"\n * statement from the specs.  Additionally, there might be an attacker\n * on the path and we may not want to continue this communication.\n */\nstatic enum sctp_disposition sctp_sf_violation_chunk(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n/***************************************************************************\n * These are the state functions for handling primitive (Section 10) events.\n ***************************************************************************/\n/*\n * sctp_sf_do_prm_asoc\n *\n * Section: 10.1 ULP-to-SCTP\n * B) Associate\n *\n * Format: ASSOCIATE(local SCTP instance name, destination transport addr,\n * outbound stream count)\n * -> association id [,destination transport addr list] [,outbound stream\n * count]\n *\n * This primitive allows the upper layer to initiate an association to a\n * specific peer endpoint.\n *\n * The peer endpoint shall be specified by one of the transport addresses\n * which defines the endpoint (see Section 1.4).  If the local SCTP\n * instance has not been initialized, the ASSOCIATE is considered an\n * error.\n * [This is not relevant for the kernel implementation since we do all\n * initialization at boot time.  It we hadn't initialized we wouldn't\n * get anywhere near this code.]\n *\n * An association id, which is a local handle to the SCTP association,\n * will be returned on successful establishment of the association. If\n * SCTP is not able to open an SCTP association with the peer endpoint,\n * an error is returned.\n * [In the kernel implementation, the struct sctp_association needs to\n * be created BEFORE causing this primitive to run.]\n *\n * Other association parameters may be returned, including the\n * complete destination transport addresses of the peer as well as the\n * outbound stream count of the local endpoint. One of the transport\n * address from the returned destination addresses will be selected by\n * the local endpoint as default primary path for sending SCTP packets\n * to this peer.  The returned \"destination transport addr list\" can\n * be used by the ULP to change the default primary path or to force\n * sending a packet to a specific transport address.  [All of this\n * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING\n * function.]\n *\n * Mandatory attributes:\n *\n * o local SCTP instance name - obtained from the INITIALIZE operation.\n *   [This is the argument asoc.]\n * o destination transport addr - specified as one of the transport\n * addresses of the peer endpoint with which the association is to be\n * established.\n *  [This is asoc->peer.active_path.]\n * o outbound stream count - the number of outbound streams the ULP\n * would like to open towards this peer endpoint.\n * [BUG: This is not currently implemented.]\n * Optional attributes:\n *\n * None.\n *\n * The return value is a disposition.\n */\nenum sctp_disposition sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_association *my_asoc;\n\tstruct sctp_chunk *repl;\n\n\t/* The comment below says that we enter COOKIE-WAIT AFTER\n\t * sending the INIT, but that doesn't actually work in our\n\t * implementation...\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\"\n\t * must provide its Verification Tag (Tag_A) in the Initiate\n\t * Tag field.  Tag_A SHOULD be a random number in the range of\n\t * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...\n\t */\n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Choose transport for INIT. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t/* After sending the INIT, \"A\" starts the T1-init timer and\n\t * enters the COOKIE-WAIT state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the SEND primitive.\n *\n * Section: 10.1 ULP-to-SCTP\n * E) Send\n *\n * Format: SEND(association id, buffer address, byte count [,context]\n *         [,stream id] [,life time] [,destination transport address]\n *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n * -> result\n *\n * This is the main method to send user data via SCTP.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n *  o buffer address - the location where the user message to be\n *    transmitted is stored;\n *\n *  o byte count - The size of the user data in number of bytes;\n *\n * Optional attributes:\n *\n *  o context - an optional 32 bit integer that will be carried in the\n *    sending failure notification to the ULP if the transportation of\n *    this User Message fails.\n *\n *  o stream id - to indicate which stream to send the data on. If not\n *    specified, stream 0 will be used.\n *\n *  o life time - specifies the life time of the user data. The user data\n *    will not be sent by SCTP after the life time expires. This\n *    parameter can be used to avoid efforts to transmit stale\n *    user messages. SCTP notifies the ULP if the data cannot be\n *    initiated to transport (i.e. sent to the destination via SCTP's\n *    send primitive) within the life time variable. However, the\n *    user data will be transmitted if SCTP has attempted to transmit a\n *    chunk before the life time expired.\n *\n *  o destination transport address - specified as one of the destination\n *    transport addresses of the peer endpoint to which this packet\n *    should be sent. Whenever possible, SCTP should use this destination\n *    transport address for sending the packets, instead of the current\n *    primary path.\n *\n *  o unorder flag - this flag, if present, indicates that the user\n *    would like the data delivered in an unordered fashion to the peer\n *    (i.e., the U flag is set to 1 on all DATA chunks carrying this\n *    message).\n *\n *  o no-bundle flag - instructs SCTP not to bundle this user data with\n *    other outbound DATA chunks. SCTP MAY still bundle even when\n *    this flag is present, when faced with network congestion.\n *\n *  o payload protocol-id - A 32 bit unsigned integer that is to be\n *    passed to the peer indicating the type of payload protocol data\n *    being transmitted. This value is passed as opaque data by SCTP.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process the SHUTDOWN primitive.\n *\n * Section: 10.1:\n * C) Shutdown\n *\n * Format: SHUTDOWN(association id)\n * -> result\n *\n * Gracefully closes an association. Any locally queued user data\n * will be delivered to the peer. The association will be terminated only\n * after the peer acknowledges all the SCTP packets sent.  A success code\n * will be returned on successful termination of the association. If\n * attempting to terminate the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n * None.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\n\treturn disposition;\n}\n\n/*\n * Process the ABORT primitive.\n *\n * Section: 10.1:\n * C) Abort\n *\n * Format: Abort(association id [, cause code])\n * -> result\n *\n * Ungracefully closes an association. Any locally queued user data\n * will be discarded and an ABORT chunk is sent to the peer.  A success code\n * will be returned on successful abortion of the association. If\n * attempting to abort the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n *  o cause code - reason of the abort to be passed to the peer\n *\n * None.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_1_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\n\tif (abort)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/* We tried an illegal operation on an association which is closed.  */\nenum sctp_disposition sctp_sf_error_closed(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* We tried an illegal operation on an association which is shutting\n * down.\n */\nenum sctp_disposition sctp_sf_error_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_cookie_wait_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_wait_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * sctp_cookie_echoed_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_echoed_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_wait_prm_abort\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_wait_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\n\t/* Stop T1-init timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tif (abort)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Section: 4 Note: 3\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_echoed_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_pending_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-PENDING state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_shutdown_pending_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_sent_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-SENT state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_shutdown_sent_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Stop the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_shutdown_ack_sent_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process the REQUESTHEARTBEAT primitive\n *\n * 10.1 ULP-to-SCTP\n * J) Request Heartbeat\n *\n * Format: REQUESTHEARTBEAT(association id, destination transport address)\n *\n * -> result\n *\n * Instructs the local endpoint to perform a HeartBeat on the specified\n * destination transport address of the given association. The returned\n * result should indicate whether the transmission of the HEARTBEAT\n * chunk to the destination address is successful.\n *\n * Mandatory attributes:\n *\n * o association id - local handle to the SCTP association\n *\n * o destination transport address - the transport address of the\n *   association on which a heartbeat should be issued.\n */\nenum sctp_disposition sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/*\n\t * RFC 2960 (bis), section 8.3\n\t *\n\t *    D) Request an on-demand HEARTBEAT on a specific destination\n\t *    transport address of a given association.\n\t *\n\t *    The endpoint should increment the respective error  counter of\n\t *    the destination transport address each time a HEARTBEAT is sent\n\t *    to that address and not acknowledged within one RTO.\n\t *\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * When an endpoint has an ASCONF signaled change to be sent to the\n * remote endpoint it should do A1 to A9\n */\nenum sctp_disposition sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RE-CONFIG Section 5.1 RECONF Chunk Procedures */\nenum sctp_disposition sctp_sf_do_prm_reconf(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Ignore the primitive event\n *\n * The return value is the disposition of the primitive.\n */\nenum sctp_disposition sctp_sf_ignore_primitive(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: primitive type:%d is ignored\\n\", __func__,\n\t\t type.primitive);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/***************************************************************************\n * These are the state functions for the OTHER events.\n ***************************************************************************/\n\n/*\n * When the SCTP stack has no more user data to send or retransmit, this\n * notification is given to the user. Also, at the time when a user app\n * subscribes to this event, if there is no data to be sent or\n * retransmit, the stack will immediately send up this notification.\n */\nenum sctp_disposition sctp_sf_do_no_pending_tsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Start the shutdown negotiation.\n *\n * From Section 9.2:\n * Once all its outstanding data has been acknowledged, the endpoint\n * shall send a SHUTDOWN chunk to its peer including in the Cumulative\n * TSN Ack field the last sequential TSN it has received from the peer.\n * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n * state. If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_start_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t/* Once all its outstanding data has been acknowledged, the\n\t * endpoint shall send a SHUTDOWN chunk to its peer including\n\t * in the Cumulative TSN Ack field the last sequential TSN it\n\t * has received from the peer.\n\t */\n\treply = sctp_make_shutdown(asoc, arg);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN chunk and the timeout for the\n\t * T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* It shall then start the T2-shutdown timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* RFC 4960 Section 9.2\n\t * The sender of the SHUTDOWN MAY also start an overall guard timer\n\t * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* and enter the SHUTDOWN-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Generate a SHUTDOWN ACK now that everything is SACK'd.\n *\n * From Section 9.2:\n *\n * If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the\n * endpoint must re-send the SHUTDOWN ACK.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_shutdown_ack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg,\n\t\t\t\t\t\tcommands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(\n\t\t\t\tchunk, sizeof(struct sctp_shutdown_chunk)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Ignore the event defined as other\n *\n * The return value is the disposition of the event.\n */\nenum sctp_disposition sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: the event other type:%d is ignored\\n\",\n\t\t __func__, type.other);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/************************************************************\n * These are the state functions for handling timeout events.\n ************************************************************/\n\n/*\n * RTX Timeout\n *\n * Section: 6.3.3 Handle T3-rtx Expiration\n *\n * Whenever the retransmission timer T3-rtx expires for a destination\n * address, do the following:\n * [See below]\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->peer.zero_window_announced &&\n\t\t    asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate delayed SACK on timeout\n *\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated\n * within 200 ms of the arrival of any unacknowledged DATA chunk.  In\n * some situations it may be beneficial for an SCTP transmitter to be\n * more conservative than the algorithms detailed in this document\n * allow. However, an SCTP transmitter MUST NOT be more aggressive than\n * the following algorithms allow.\n */\nenum sctp_disposition sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_init_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT\n *     and re-start the T1-init timer without changing state.  This MUST\n *     be repeated up to 'Max.Init.Retransmits' times.  After that, the\n *     endpoint MUST abort the initialization process and report the\n *     error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nenum sctp_disposition sctp_sf_t1_init_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\n\tpr_debug(\"%s: timer T1 expired (INIT)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Choose transport for INIT. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tpr_debug(\"%s: giving up on INIT, attempts:%d \"\n\t\t\t \"max_init_attempts:%d\\n\", __func__, attempts,\n\t\t\t asoc->max_init_attempts);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_cookie_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  3) If the T1-cookie timer expires, the endpoint MUST retransmit\n *     COOKIE ECHO and re-start the T1-cookie timer without changing\n *     state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n *     After that, the endpoint MUST abort the initialization process and\n *     report the error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nenum sctp_disposition sctp_sf_t1_cookie_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *repl = NULL;\n\n\tpr_debug(\"%s: timer T1 expired (COOKIE-ECHO)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * An endpoint should limit the number of retransmission of the\n * SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n * If this threshold is exceeded the endpoint should destroy the TCB and\n * MUST report the peer endpoint unreachable to the upper layer (and\n * thus the association enters the CLOSED state).  The reception of any\n * packet from its peer (i.e. as the peer sends all of its queued DATA\n * chunks) should clear the endpoint's retransmission count and restart\n * the T2-Shutdown timer,  giving its peer ample opportunity to transmit\n * all of its queued DATA chunks that have not yet been sent.\n */\nenum sctp_disposition sctp_sf_t2_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T2 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Do some failure management (Section 8.2).\n\t * If we remove the transport an SHUTDOWN was last sent to, don't\n\t * do failure management.\n\t */\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* Restart the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * If the T4 RTO timer expires the endpoint should do B1 to B5\n */\nenum sctp_disposition sctp_sf_t4_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t/* ADDIP 4.1 B1) Increment the error counters and perform path failure\n\t * detection on the appropriate destination address as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t */\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t/* Reconfig T4 timer and transport. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t/* ADDIP 4.1 B2) Increment the association error counters and perform\n\t * endpoint failure detection on the association as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t * association error counter is incremented in SCTP_CMD_STRIKE.\n\t */\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t/* ADDIP 4.1 B3) Back-off the destination address RTO value to which\n\t * the ASCONF chunk was sent by doubling the RTO timer value.\n\t * This is done in SCTP_CMD_STRIKE.\n\t */\n\n\t/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible\n\t * choose an alternate destination address (please refer to RFC2960\n\t * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this\n\t * chunk, it MUST be the same (including its serial number) as the last\n\t * ASCONF sent.\n\t */\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different\n\t * destination is selected, then the RTO used will be that of the new\n\t * destination address.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* sctpimpguide-05 Section 2.12.2\n * The sender of the SHUTDOWN MAY also start an overall guard timer\n * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n * At the expiration of this timer the sender SHOULD abort the association\n * by sending an ABORT chunk.\n */\nenum sctp_disposition sctp_sf_t5_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T5 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,\n * the association is automatically closed by starting the shutdown process.\n * The work that needs to be done is same as when SHUTDOWN is initiated by\n * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().\n */\nenum sctp_disposition sctp_sf_autoclose_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    NULL, commands);\n\t}\n\n\treturn disposition;\n}\n\n/*****************************************************************************\n * These are sa state functions which could apply to all types of events.\n ****************************************************************************/\n\n/*\n * This table entry is not implemented.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_not_impl(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n/*\n * This table entry represents a bug.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_bug(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t  void *arg, struct sctp_cmd_seq *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n/*\n * This table entry represents the firing of a timer in the wrong state.\n * Since timer deletion cannot be guaranteed a timer 'may' end up firing\n * when the association is in the wrong state.   This event should\n * be ignored, so as to prevent any rearming of the timer.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: timer %d ignored\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Pull the SACK chunk based on the SACK header. */\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\t__u16 num_dup_tsns;\n\tunsigned int len;\n\t__u16 num_blocks;\n\n\t/* Protect ourselves from reading too far into\n\t * the skb from a bogus sender.\n\t */\n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n/* Create an ABORT packet to be sent as a response, with the specified\n * error causes.\n */\nstatic struct sctp_packet *sctp_abort_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tconst void *payload, size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Add specified error causes, i.e., payload, to the\n\t\t * end of the chunk.\n\t\t */\n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n/* Allocate a packet for responding in the OOTB conditions.  */\nstatic struct sctp_packet *sctp_ootb_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *transport;\n\tstruct sctp_packet *packet;\n\t__u16 sport, dport;\n\t__u32 vtag;\n\n\t/* Get the source and destination port from the inbound packet.  */\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t/* The V-tag is going to be the same as the inbound packet if no\n\t * association exists, otherwise, use the peer's vtag.\n\t */\n\tif (asoc) {\n\t\t/* Special case the INIT-ACK as there is no peer's vtag\n\t\t * yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tstruct sctp_initack_chunk *initack;\n\n\t\t\tinitack = (struct sctp_initack_chunk *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Special case the INIT and stale COOKIE_ECHO as there is no\n\t\t * vtag yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tstruct sctp_init_chunk *init;\n\n\t\t\tinit = (struct sctp_init_chunk *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make a transport for the bucket, Eliza... */\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\ttransport->encap_port = SCTP_INPUT_CB(chunk->skb)->encap_port;\n\n\t/* Cache a route for the transport with the chunk's destination as\n\t * the source address.\n\t */\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = &transport->packet;\n\tsctp_packet_init(packet, transport, sport, dport);\n\tsctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n/* Free the packet allocated earlier for responding in the OOTB condition.  */\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       struct sctp_cmd_seq *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t/* Override the OOTB vtag from the cookie. */\n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t/* Set the skb to the belonging sock for accounting. */\n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n/* Process a data chunk */\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_datahdr *data_hdr;\n\tstruct sctp_chunk *err;\n\tenum sctp_verb deliver;\n\tsize_t datalen;\n\t__u32 tsn;\n\tint tmp;\n\n\tdata_hdr = (struct sctp_datahdr *)chunk->skb->data;\n\tchunk->subh.data_hdr = data_hdr;\n\tskb_pull(chunk->skb, sctp_datahdr_len(&asoc->stream));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (asoc->peer.ecn_capable && !chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af = SCTP_INPUT_CB(chunk->skb)->af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\tif (af->is_ce(sctp_gso_headskb(chunk->skb))) {\n\t\t\t/* Do real work as side effect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sctp_datachk_len(&asoc->stream);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (sk_under_memory_pressure(sk)) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tsk_mem_reclaim(sk);\n\t\t}\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tif (ntohs(data_hdr->stream) >= asoc->stream.incnt) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tif (!asoc->stream.si->validate_data(chunk))\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n * Copyright (c) 2002      Nokia Corp.\n *\n * This is part of the SCTP Linux Kernel Implementation.\n *\n * These are the state functions for the state machine.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Mathew Kotowsky       <kotowsky@sctp.org>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Hui Huang \t    <hui.huang@nokia.com>\n *    Dajiang Zhang \t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Kevin Gao\t\t    <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/sctp.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tconst void *payload, size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t struct sctp_cmd_seq *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       struct sctp_cmd_seq *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic enum sctp_disposition sctp_sf_do_5_2_6_stale(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_shut_8_4_5(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_tabort_8_4_8(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_new_encap_port(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic enum sctp_disposition sctp_stop_t1_and_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\t__be16 error, int sk_err,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_transport *transport);\n\nstatic enum sctp_disposition sctp_sf_abort_violation(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen);\n\nstatic enum sctp_disposition sctp_sf_violation_chunklen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_paramlen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg, void *ext,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_chunk(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_ierror sctp_sf_authenticate(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk);\n\nstatic enum sctp_disposition __sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition\n__sctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\t\t\t   const struct sctp_association *asoc,\n\t\t\t   const union sctp_subtype type, void *arg,\n\t\t\t   struct sctp_cmd_seq *commands);\n\n/* Small helper function that checks if the chunk length\n * is of the appropriate length.  The 'required_length' argument\n * is set to be the size of a specific chunk we are testing.\n * Return Values:  true  = Valid length\n * \t\t   false = Invalid length\n *\n */\nstatic inline bool sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\t/* Previously already marked? */\n\tif (unlikely(chunk->pdiscard))\n\t\treturn false;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn false;\n\n\treturn true;\n}\n\n/* Check for format error in an ABORT chunk */\nstatic inline bool sctp_err_chunk_valid(struct sctp_chunk *chunk)\n{\n\tstruct sctp_errhdr *err;\n\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\n\treturn (void *)err == (void *)chunk->chunk_end;\n}\n\n/**********************************************************\n * These are the state functions for handling chunk events.\n **********************************************************/\n\n/*\n * Process the final SHUTDOWN COMPLETE.\n *\n * Section: 4 (C) (diagram), 9.2\n * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify\n * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be\n * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint\n * should stop the T2-shutdown timer and remove all knowledge of the\n * association (and thus the association enters the CLOSED state).\n *\n * Verification Tag: 8.5.1(C), sctpimpguide 2.41.\n * C) Rules for packet carrying SHUTDOWN COMPLETE:\n * ...\n * - The receiver of a SHUTDOWN COMPLETE shall accept the packet\n *   if the Verification Tag field of the packet matches its own tag and\n *   the T bit is not set\n *   OR\n *   it is set to its peer's tag and the T bit is set in the Chunk\n *   Flags.\n *   Otherwise, the receiver MUST silently discard the packet\n *   and take no further action.  An endpoint MUST ignore the\n *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_4_C(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const union sctp_subtype type,\n\t\t\t\t     void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * Respond to a normal INIT chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, B\n * B) \"Z\" shall respond immediately with an INIT ACK chunk.  The\n *    destination IP address of the INIT ACK MUST be set to the source\n *    IP address of the INIT to which this INIT ACK is responding.  In\n *    the response, besides filling in other parameters, \"Z\" must set the\n *    Verification Tag field to Tag_A, and also provide its own\n *    Verification Tag (Tag_Z) in the Initiate Tag field.\n *\n * Verification Tag: Must be 0.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg, *repl, *err_chunk;\n\tstruct sctp_unrecognized_param *unk_param;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_packet *packet;\n\tint len;\n\n\t/* Update socket peer label if first association. */\n\tif (security_sctp_assoc_request((struct sctp_endpoint *)ep,\n\t\t\t\t\tchunk->skb))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * Normally, this would cause an ABORT with a Protocol Violation\n\t * error, but since we don't have an association, we'll\n\t * just discard the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* If the INIT is coming toward a closing socket, we'll send back\n\t * and ABORT.  Essentially, this catches the race of INIT being\n\t * backloged to the socket at the same time as the user issues close().\n\t * Since the socket and all its associations are going away, we\n\t * can treat this OOTB\n\t */\n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t/* The call, sctp_process_init(), can fail on memory allocation.  */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (struct sctp_init_chunk *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t      sizeof(struct sctp_chunkhdr);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (struct sctp_unrecognized_param *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(struct sctp_chunkhdr));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note:  After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources, nor keep any states for the\n\t * new association.  Otherwise, \"Z\" will be vulnerable to resource\n\t * attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal INIT ACK chunk.\n * We are the side that is initiating the association.\n *\n * Section: 5.1 Normal Establishment of an Association, C\n * C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-init\n *    timer and leave COOKIE-WAIT state. \"A\" shall then send the State\n *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start\n *    the T1-cookie timer, and enter the COOKIE-ECHOED state.\n *\n *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound\n *    DATA chunks, but it MUST be the first chunk in the packet and\n *    until the COOKIE ACK is returned the sender MUST NOT send any\n *    other packets to the peer.\n *\n * Verification Tag: 3.3.3\n *   If the value of the Initiate Tag in a received INIT ACK chunk is\n *   found to be 0, the receiver MUST treat it as an error and close the\n *   association by transmitting an ABORT.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_init_chunk *initchunk;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT-ACK chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_initack_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tenum sctp_error error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes.  If there are no causes,\n\t\t * then there wasn't enough memory.  Just terminate\n\t\t * the association.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t/* SCTP-AUTH, Section 6.3:\n\t\t *    It should be noted that if the receiver wants to tear\n\t\t *    down an association in an authenticated way only, the\n\t\t *    handling of malformed packets should not result in\n\t\t *    tearing down the association.\n\t\t *\n\t\t * This means that if we only want to abort associations\n\t\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t\t * can't destroy this association just because the packet\n\t\t * was malformed.\n\t\t */\n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t/* Tag the variable length parameters.  Note that we never\n\t * convert the parameters in an INIT chunk.\n\t */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\tinitchunk = (struct sctp_init_chunk *)chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t/* Reset init error count upon receipt of INIT-ACK.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall stop the T1-init timer and leave\n\t * COOKIE-WAIT state.  \"A\" shall then ... start the T1-cookie\n\t * timer, and enter the COOKIE-ECHOED state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t/* SCTP-AUTH: generate the association shared keys so that\n\t * we can potentially sign the COOKIE-ECHO.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall then send the State Cookie received in the\n\t * INIT ACK chunk in a COOKIE ECHO chunk, ...\n\t */\n\t/* If there is any errors to report, send the ERROR chunk generated\n\t * for unknown parameters as well.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\nstatic bool sctp_auth_chunk_verify(struct net *net, struct sctp_chunk *chunk,\n\t\t\t\t   const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk auth;\n\n\tif (!chunk->auth_chunk)\n\t\treturn true;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\n\t/* Make sure that we and the peer are AUTH capable */\n\tif (!net->sctp.auth_enable || !asoc->peer.auth_capable)\n\t\treturn false;\n\n\t/* set-up our fake chunk so that we can process it */\n\tauth.skb = chunk->auth_chunk;\n\tauth.asoc = chunk->asoc;\n\tauth.sctp_hdr = chunk->sctp_hdr;\n\tauth.chunk_hdr = (struct sctp_chunkhdr *)\n\t\t\t\tskb_push(chunk->auth_chunk,\n\t\t\t\t\t sizeof(struct sctp_chunkhdr));\n\tskb_pull(chunk->auth_chunk, sizeof(struct sctp_chunkhdr));\n\tauth.transport = chunk->transport;\n\n\treturn sctp_sf_authenticate(asoc, &auth) == SCTP_IERROR_NO_ERROR;\n}\n\n/*\n * Respond to a normal COOKIE ECHO chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, D\n * D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply\n *    with a COOKIE ACK chunk after building a TCB and moving to\n *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with\n *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK\n *    chunk MUST be the first chunk in the packet.\n *\n *   IMPLEMENTATION NOTE: An implementation may choose to send the\n *   Communication Up notification to the SCTP user upon reception\n *   of a valid COOKIE ECHO chunk.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * D) Rules for packet carrying a COOKIE ECHO\n *\n * - When sending a COOKIE ECHO, the endpoint MUST use the value of the\n *   Initial Tag received in the INIT ACK.\n *\n * - The receiver of a COOKIE ECHO follows the procedures in Section 5.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL, *auth_ev = NULL;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_init_chunk *peer_init;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sctp_chunk *repl;\n\tstruct sock *sk;\n\tint error = 0;\n\n\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(struct sctp_chunkhdr)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the association shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\tif (!new_asoc->peer.auth_capable) {\n\t\tauth_ev = sctp_ulpevent_make_authkey(new_asoc, 0,\n\t\t\t\t\t\t     SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!auth_ev)\n\t\t\tgoto nomem_authev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correctly count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\tif (auth_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(auth_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_authev:\n\tsctp_ulpevent_free(ai_ev);\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal COOKIE ACK chunk.\n * We are the side that is asking for an association.\n *\n * RFC 2960 5.1 Normal Establishment of an Association\n *\n * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie\n *    timer. It may also notify its ULP about the successful\n *    establishment of the association with a Communication Up\n *    notification (see Section 10).\n *\n * Verification Tag:\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Verify that the chunk length for the COOKIE-ACK is OK.\n\t * If we don't do this, any bundled chunks may be junked.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Reset init error count upon receipt of COOKIE-ACK,\n\t * to avoid problems with the management of this\n\t * counter in stale cookie situations when a transition back\n\t * from the COOKIE-ECHOED state to the COOKIE-WAIT\n\t * state is performed.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* Set peer label for connection. */\n\tsecurity_inet_conn_established(ep->base.sk, chunk->skb);\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move\n\t * from the COOKIE-ECHOED state to the ESTABLISHED state,\n\t * stopping the T1-cookie timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* It may also notify its ULP about the successful\n\t * establishment of the association with a Communication Up\n\t * notification (see Section 10).\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\tif (!asoc->peer.auth_capable) {\n\t\tev = sctp_ulpevent_make_authkey(asoc, 0, SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Generate and sendout a heartbeat packet.  */\nstatic enum sctp_disposition sctp_sf_heartbeat(\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Send a heartbeat to our peer.  */\n\treply = sctp_make_heartbeat(asoc, transport, 0);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Set rto_pending indicating that an RTT measurement\n\t * is started with this heartbeat chunk.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Generate a HEARTBEAT packet on the given transport.  */\nenum sctp_disposition sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t/* Section 3.3.5.\n\t * The Sender-specific Heartbeat Info field should normally include\n\t * information about the sender's current time when this HEARTBEAT\n\t * chunk is sent and the destination transport address to which this\n\t * HEARTBEAT is sent (see Section 8.3).\n\t */\n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Set transport error counter and association error counter\n\t\t * when sending heartbeat.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* resend asoc strreset_chunk.  */\nenum sctp_disposition sctp_sf_send_reconf(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->strreset_chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* send hb chunk with padding for PLPMUTD.  */\nenum sctp_disposition sctp_sf_send_probe(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *)arg;\n\tstruct sctp_chunk *reply;\n\n\tif (!sctp_transport_pl_enabled(transport))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_transport_pl_send(transport)) {\n\t\treply = sctp_make_heartbeat(asoc, transport, transport->pl.probe_size);\n\t\tif (!reply)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROBE_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an heartbeat request.\n *\n * Section: 8.3 Path Heartbeat\n * The receiver of the HEARTBEAT should immediately respond with a\n * HEARTBEAT ACK that contains the Heartbeat Information field copied\n * from the received HEARTBEAT chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * When receiving an SCTP packet, the endpoint MUST ensure that the\n * value in the Verification Tag field of the received SCTP packet\n * matches its own Tag. If the received Verification Tag value does not\n * match the receiver's own tag value, the receiver shall silently\n * discard the packet and shall not process it any further except for\n * those cases listed in Section 8.5.1 below.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t     sizeof(struct sctp_heartbeat_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* 8.3 The receiver of the HEARTBEAT should immediately\n\t * respond with a HEARTBEAT ACK that contains the Heartbeat\n\t * Information field copied from the received HEARTBEAT chunk.\n\t */\n\tchunk->subh.hb_hdr = (struct sctp_heartbeathdr *)chunk->skb->data;\n\tparam_hdr = (struct sctp_paramhdr *)chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(struct sctp_chunkhdr);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the returning HEARTBEAT ACK.\n *\n * Section: 8.3 Path Heartbeat\n * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n * should clear the error counter of the destination transport\n * address to which the HEARTBEAT was sent, and mark the destination\n * transport address as active if it is not so marked. The endpoint may\n * optionally report to the upper layer when an inactive destination\n * address is marked as active due to the reception of the latest\n * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also\n * clear the association overall error count as well (as defined\n * in section 8.1).\n *\n * The receiver of the HEARTBEAT ACK should also perform an RTT\n * measurement for that destination transport address using the time\n * value carried in the HEARTBEAT ACK chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_sender_hb_info *hbinfo;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_transport *link;\n\tunsigned long max_interval;\n\tunion sctp_addr from_addr;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr) +\n\t\t\t\t\t    sizeof(*hbinfo)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (struct sctp_sender_hb_info *)chunk->skb->data;\n\t/* Make sure that the length of the parameter is what we expect */\n\tif (ntohs(hbinfo->param_hdr.length) != sizeof(*hbinfo))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t/* This should never happen, but lets log it if so.  */\n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Validate the 64-bit random nonce. */\n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tif (hbinfo->probe_size) {\n\t\tif (hbinfo->probe_size != link->pl.probe_size ||\n\t\t    !sctp_transport_pl_enabled(link))\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\tif (sctp_transport_pl_recv(link))\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t\treturn sctp_sf_send_probe(net, ep, asoc, type, link, commands);\n\t}\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t/* Check if the timestamp looks valid.  */\n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tpr_debug(\"%s: HEARTBEAT ACK with invalid timestamp received \"\n\t\t\t \"for transport:%p\\n\", __func__, link);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of\n\t * the HEARTBEAT should clear the error counter of the\n\t * destination transport address to which the HEARTBEAT was\n\t * sent and mark the destination transport address as active if\n\t * it is not so marked.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Helper function to send out an abort for the restart\n * condition.\n */\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tchar buffer[sizeof(*errhdr) + sizeof(*addrparm)];\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_packet *pkt;\n\tint len;\n\n\t/* Build the error on the stack.   We are way to malloc crazy\n\t * throughout the code today.\n\t */\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\n\t/* Copy into a parm format. */\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(*errhdr);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t/* Assign to the control socket. */\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t/* Association is NULL since this may be a restart attack and we\n\t * want to send back the attacker's vtag.\n\t */\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* Discard the rest of the inbound packet. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t/* Even if there is no memory, treat as a failure so\n\t * the packet will get dropped.\n\t */\n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n/* A restart is occurring, check to make sure no new addresses\n * are being added as we may be under a takeover attack.\n */\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       struct sctp_cmd_seq *commands)\n{\n\tstruct net *net = new_asoc->base.net;\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t/* Implementor's Guide - Section 5.2.2\n\t * ...\n\t * Before responding the endpoint MUST check to see if the\n\t * unexpected INIT adds new addresses to the association. If new\n\t * addresses are added to the association, the endpoint MUST respond\n\t * with an ABORT..\n\t */\n\n\t/* Search through all current addresses and make sure\n\t * we aren't adding any new ones.\n\t */\n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Return success if all addresses were found. */\n\treturn ret;\n}\n\n/* Populate the verification/tie tags based on overlapping INIT\n * scenario.\n *\n * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.\n */\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n/*\n * Compare vtag/tietag values to determine unexpected COOKIE-ECHO\n * handling action.\n *\n * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.\n *\n * Returns value representing action to be taken.   These action values\n * correspond to Action/Description values in RFC 2960, Table 2.\n */\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t/* In this case, the peer may have restarted.  */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t/* Collision case B. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t/* Collision case D. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t/* Collision case C. */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t/* No match to any of the special cases; discard this packet. */\n\treturn 'E';\n}\n\n/* Common helper routine for both duplicate and simultaneous INIT\n * chunk handling.\n */\nstatic enum sctp_disposition sctp_sf_do_unexpected_init(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg, *repl, *err_chunk;\n\tstruct sctp_unrecognized_param *unk_param;\n\tstruct sctp_association *new_asoc;\n\tenum sctp_disposition retval;\n\tstruct sctp_packet *packet;\n\tint len;\n\n\t/* Update socket peer label if first association. */\n\tif (security_sctp_assoc_request((struct sctp_endpoint *)ep,\n\t\t\t\t\tchunk->skb))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\tif (SCTP_INPUT_CB(chunk->skb)->encap_port != chunk->transport->encap_port)\n\t\treturn sctp_sf_new_encap_port(net, ep, asoc, type, arg, commands);\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/*\n\t * Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t * FIXME:  We are copying parameters from the endpoint not the\n\t * association.\n\t */\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t/* In the outbound INIT ACK the endpoint MUST copy its current\n\t * Verification Tag and Peers Verification tag into a reserved\n\t * place (local tie-tag and per tie-tag) within the state cookie.\n\t */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (struct sctp_init_chunk *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.   Do not do this check for COOKIE-WAIT state,\n\t * since there are no peer addresses to check against.\n\t * Upon return an ABORT will have been sent if needed.\n\t */\n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t      sizeof(struct sctp_chunkhdr);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (struct sctp_unrecognized_param *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(struct sctp_chunkhdr));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note: After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources for this new association.\n\t * Otherwise, \"Z\" will be vulnerable to resource attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n/*\n * Handle simultaneous INIT.\n * This means we started an INIT and then we got an INIT request from\n * our peer.\n *\n * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n * This usually indicates an initialization collision, i.e., each\n * endpoint is attempting, at about the same time, to establish an\n * association with the other endpoint.\n *\n * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n * endpoint MUST respond with an INIT ACK using the same parameters it\n * sent in its original INIT chunk (including its Verification Tag,\n * unchanged). These original parameters are combined with those from the\n * newly received INIT chunk. The endpoint shall also generate a State\n * Cookie with the INIT ACK. The endpoint uses the parameters sent in its\n * INIT to calculate the State Cookie.\n *\n * After that, the endpoint MUST NOT change its state, the T1-init\n * timer shall be left running and the corresponding TCB MUST NOT be\n * destroyed. The normal procedures for handling State Cookies when\n * a TCB exists will resolve the duplicate INITs to a single association.\n *\n * For an endpoint that is in the COOKIE-ECHOED state it MUST populate\n * its Tie-Tags with the Tag information of itself and its peer (see\n * section 5.2.2 for a description of the Tie-Tags).\n *\n * Verification Tag: Not explicit, but an INIT can not have a valid\n * verification tag, so we skip the check.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_2_1_siminit(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Call helper to do the real work for both simultaneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle duplicated INIT messages.  These are usually delayed\n * restransmissions.\n *\n * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,\n * COOKIE-ECHOED and COOKIE-WAIT\n *\n * Unless otherwise stated, upon reception of an unexpected INIT for\n * this association, the endpoint shall generate an INIT ACK with a\n * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n * current Verification Tag and peer's Verification Tag into a reserved\n * place within the state cookie.  We shall refer to these locations as\n * the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n * containing this INIT ACK MUST carry a Verification Tag value equal to\n * the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n * MUST contain a new Initiation Tag (randomly generated see Section\n * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the\n * existing parameters of the association (e.g. number of outbound\n * streams) into the INIT ACK and cookie.\n *\n * After sending out the INIT ACK, the endpoint shall take no further\n * actions, i.e., the existing association, including its current state,\n * and the corresponding TCB MUST NOT be changed.\n *\n * Note: Only when a TCB exists and the association is not in a COOKIE-\n * WAIT state are the Tie-Tags populated.  For a normal association INIT\n * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n * set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n * State Cookie are populated as specified in section 5.2.1.\n *\n * Verification Tag: Not specified, but an INIT has no way of knowing\n * what the verification tag could be, so we ignore it.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_2_2_dupinit(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Call helper to do the real work for both simultaneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n/*\n * Unexpected INIT-ACK handler.\n *\n * Section 5.2.3\n * If an INIT ACK received by an endpoint in any state other than the\n * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.\n * An unexpected INIT ACK usually indicates the processing of an old or\n * duplicated INIT chunk.\n*/\nenum sctp_disposition sctp_sf_do_5_2_3_initack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Per the above section, we'll discard the chunk if we have an\n\t * endpoint.  If this is an OOTB INIT-ACK, treat it as such.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\nstatic int sctp_sf_do_assoc_update(struct sctp_association *asoc,\n\t\t\t\t   struct sctp_association *new,\n\t\t\t\t   struct sctp_cmd_seq *cmds)\n{\n\tstruct net *net = asoc->base.net;\n\tstruct sctp_chunk *abort;\n\n\tif (!sctp_assoc_update(asoc, new))\n\t\treturn 0;\n\n\tabort = sctp_make_abort(asoc, NULL, sizeof(struct sctp_errhdr));\n\tif (abort) {\n\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\tsctp_add_cmd_sf(cmds, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t}\n\tsctp_add_cmd_sf(cmds, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(cmds, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_RSRC_LOW));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn -ENOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action 'A')\n *\n * Section 5.2.4\n *  A)  In this case, the peer may have restarted.\n */\nstatic enum sctp_disposition sctp_sf_do_dupcook_a(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_init_chunk *peer_init;\n\tenum sctp_disposition disposition;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.  Though this is a pretty complicated attack\n\t * since you'd have to get inside the cookie.\n\t */\n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes\n\t * the peer has restarted (Action A), it MUST NOT setup a new\n\t * association but instead resend the SHUTDOWN ACK and send an ERROR\n\t * chunk with a \"Cookie Received while Shutting Down\" error cause to\n\t * its peer.\n\t*/\n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = __sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\t\t\t\t SCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\t\t\t\t chunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked\n\t * data. Consider the optional choice of resending of this data.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue\n\t * and ASCONF-ACK cache.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\t/* Update the content of current association. */\n\tif (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))\n\t\tgoto nomem;\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Report association restart to upper layer. */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tif ((sctp_state(asoc, SHUTDOWN_PENDING) ||\n\t     sctp_state(asoc, SHUTDOWN_SENT)) &&\n\t    (sctp_sstate(asoc->base.sk, CLOSING) ||\n\t     sock_flag(asoc->base.sk, SOCK_DEAD))) {\n\t\t/* If the socket has been closed by user, don't\n\t\t * transition to ESTABLISHED. Instead trigger SHUTDOWN\n\t\t * bundled with COOKIE_ACK.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t\treturn sctp_sf_do_9_2_start_shutdown(net, ep, asoc,\n\t\t\t\t\t\t     SCTP_ST_CHUNK(0), repl,\n\t\t\t\t\t\t     commands);\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'B')\n *\n * Section 5.2.4\n *   B) In this case, both sides may be attempting to start an association\n *      at about the same time but the peer endpoint started its INIT\n *      after responding to the local endpoint's INIT\n */\n/* This case represents an initialization collision.  */\nstatic enum sctp_disposition sctp_sf_do_dupcook_b(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_init_chunk *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tif (asoc->state < SCTP_STATE_ESTABLISHED)\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\t/* Update the content of current association.  */\n\tif (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))\n\t\tgoto nomem;\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\tif (!asoc->peer.auth_capable)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_NO_AUTH, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'C')\n *\n * Section 5.2.4\n *  C) In this case, the local endpoint's cookie has arrived late.\n *     Before it arrived, the local endpoint sent an INIT and received an\n *     INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n *     but a new tag of its own.\n */\n/* This case represents an initialization collision.  */\nstatic enum sctp_disposition sctp_sf_do_dupcook_c(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t/* The cookie should be silently discarded.\n\t * The endpoint SHOULD NOT change states and should leave\n\t * any timers running.\n\t */\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action 'D')\n *\n * Section 5.2.4\n *\n * D) When both local and remote tags match the endpoint should always\n *    enter the ESTABLISHED state, if it has not already done so.\n */\n/* This case represents an initialization collision.  */\nstatic enum sctp_disposition sctp_sf_do_dupcook_d(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL, *auth_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t/* Clarification from Implementor's Guide:\n\t * D) When both local and remote tags match the endpoint should\n\t * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.\n\t * It should stop any cookie timer that may be running and send\n\t * a COOKIE ACK.\n\t */\n\n\tif (!sctp_auth_chunk_verify(net, chunk, asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t/* Don't accidentally move back into established state. */\n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t\t *\n\t\t * D) IMPLEMENTATION NOTE: An implementation may choose\n\t\t * to send the Communication Up notification to the\n\t\t * SCTP user upon reception of a valid COOKIE\n\t\t * ECHO chunk.\n\t\t */\n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t/* Sockets API Draft Section 5.3.1.6\n\t\t * When a peer sends a Adaptation Layer Indication parameter,\n\t\t * SCTP delivers this notification to inform the application\n\t\t * that of the peers requested adaptation layer.\n\t\t */\n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\n\t\tif (!asoc->peer.auth_capable) {\n\t\t\tauth_ev = sctp_ulpevent_make_authkey(asoc, 0,\n\t\t\t\t\t\t\t     SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\t\t     GFP_ATOMIC);\n\t\t\tif (!auth_ev)\n\t\t\t\tgoto nomem;\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\tif (auth_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(auth_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (auth_ev)\n\t\tsctp_ulpevent_free(auth_ev);\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying\n * chunk was retransmitted and then delayed in the network.\n *\n * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists\n *\n * Verification Tag: None.  Do cookie validation.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_5_2_4_dupcook(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *chunk = arg;\n\tenum sctp_disposition retval;\n\tstruct sctp_chunk *err_chk_p;\n\tint error = 0;\n\tchar action;\n\n\t/* Make sure that the chunk has a valid length from the protocol\n\t * perspective.  In this case check to make sure we have at least\n\t * enough for the chunk header.  Cookie length verification is\n\t * done later.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr))) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\tasoc = NULL;\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr)))\n\t\tgoto nomem;\n\n\t/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie\n\t * of a duplicate COOKIE ECHO match the Verification Tags of the\n\t * current association, consider the State Cookie valid even if\n\t * the lifespan is exceeded.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t/* Update socket peer label if first association. */\n\tif (security_sctp_assoc_request((struct sctp_endpoint *)ep,\n\t\t\t\t\tchunk->skb)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Set temp so that it won't be added into hashtable */\n\tnew_asoc->temp = 1;\n\n\t/* Compare the tie_tag in cookie with the verification tag of\n\t * current association.\n\t */\n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A': /* Association restart. */\n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B': /* Collision case B. */\n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C': /* Collision case C. */\n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D': /* Collision case D. */\n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault: /* Discard packet for all others. */\n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t/* Delete the temporary new association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t/* Restore association pointer to provide SCTP command interpreter\n\t * with a valid context in case it needs to manipulate\n\t * the queues */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-PENDING state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nenum sctp_disposition sctp_sf_shutdown_pending_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nenum sctp_disposition sctp_sf_shutdown_sent_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Stop the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-ACK-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nenum sctp_disposition sctp_sf_shutdown_ack_sent_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an Error received in COOKIE_ECHOED state.\n *\n * Only handle the error type of stale COOKIE Error, the other errors will\n * be ignored.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_cookie_echoed_err(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_errhdr *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_operr_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle a Stale COOKIE Error\n *\n * Section: 5.2.6 Handle Stale COOKIE Error\n * If the association is in the COOKIE-ECHOED state, the endpoint may elect\n * one of the following three alternatives.\n * ...\n * 3) Send a new INIT chunk to the endpoint, adding a Cookie\n *    Preservative parameter requesting an extension to the lifetime of\n *    the State Cookie. When calculating the time extension, an\n *    implementation SHOULD use the RTT information measured based on the\n *    previous COOKIE ECHO / ERROR exchange, and should add no more\n *    than 1 second beyond the measured RTT, due to long State Cookie\n *    lifetimes making the endpoint more subject to a replay attack.\n *\n * Verification Tag:  Not explicit, but safe to ignore.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nstatic enum sctp_disposition sctp_sf_do_5_2_6_stale(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *chunk = arg, *reply;\n\tstruct sctp_cookie_preserve_param bht;\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_errhdr *err;\n\tu32 stale;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (struct sctp_errhdr *)(chunk->skb->data);\n\n\t/* When calculating the time extension, an implementation\n\t * SHOULD use the RTT information measured based on the\n\t * previous COOKIE ECHO / ERROR exchange, and should add no\n\t * more than 1 second beyond the measured RTT, due to long\n\t * State Cookie lifetimes making the endpoint more subject to\n\t * a replay attack.\n\t * Measure of Staleness's unit is usec. (1/1000000 sec)\n\t * Suggested Cookie Life-span Increment's unit is msec.\n\t * (1/1000 sec)\n\t * In general, if you use the suggested cookie life, the value\n\t * found in the field of measure of staleness should be doubled\n\t * to give ample time to retransmit the new cookie and thus\n\t * yield a higher probability of success on the reattempt.\n\t */\n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(*err)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t/* Build that new INIT chunk.  */\n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t/* Clear peer's init_tag cached in assoc as we are sending a new INIT */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t/* Stop pending T3-rtx and heartbeat timers */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t/* Delete non-primary peer ip addresses since we are transitioning\n\t * back to the COOKIE-WAIT state\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t/* If we've sent any data bundled with COOKIE-ECHO we will need to\n\t * resend\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.\n *\n * Section: 9.1\n * After checking the Verification Tag, the receiving endpoint shall\n * remove the association from its record, and shall report the\n * termination to its upper layer.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * B) Rules for packet carrying ABORT:\n *\n *  - The endpoint shall always fill in the Verification Tag field of the\n *    outbound packet with the destination endpoint's tag value if it\n *    is known.\n *\n *  - If the ABORT is sent in response to an OOTB packet, the endpoint\n *    MUST follow the procedure described in Section 8.4.\n *\n *  - The receiver MUST accept the packet if the Verification Tag\n *    matches either its own tag, OR the tag of its peer. Otherwise, the\n *    receiver MUST silently discard the packet and take no further\n *    action.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic enum sctp_disposition __sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((struct sctp_errhdr *)chunk->skb->data)->cause;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t/* ASSOC_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * Process an ABORT.  (COOKIE-WAIT state)\n *\n * See sctp_sf_do_9_1_abort() above.\n */\nenum sctp_disposition sctp_sf_cookie_wait_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((struct sctp_errhdr *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n/*\n * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)\n */\nenum sctp_disposition sctp_sf_cookie_wait_icmp_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n/*\n * Process an ABORT.  (COOKIE-ECHOED state)\n */\nenum sctp_disposition sctp_sf_cookie_echoed_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Stop T1 timer and abort association with \"INIT failed\".\n *\n * This is common code called by several sctp_sf_*_abort() functions above.\n */\nstatic enum sctp_disposition sctp_stop_t1_and_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\t__be16 error, int sk_err,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_do_9_2_shut\n *\n * Section: 9.2\n * Upon the reception of the SHUTDOWN, the peer endpoint shall\n *  - enter the SHUTDOWN-RECEIVED state,\n *\n *  - stop accepting new data from its SCTP user\n *\n *  - verify, by checking the Cumulative TSN Ack field of the chunk,\n *    that all its outstanding DATA chunks have been received by the\n *    SHUTDOWN sender.\n *\n * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT\n * send a SHUTDOWN in response to a ULP request. And should discard\n * subsequent SHUTDOWN chunks.\n *\n * If there are still outstanding DATA chunks left, the SHUTDOWN\n * receiver shall continue to follow normal data transmission\n * procedures defined in Section 6 until all outstanding DATA chunks\n * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept\n * new data from its SCTP user.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_9_2_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_shutdownhdr *sdh;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Convert the elaborate header.  */\n\tsdh = (struct sctp_shutdownhdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*sdh));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT\n\t * When a peer sends a SHUTDOWN, SCTP delivers this notification to\n\t * inform the application that it should cease sending data.\n\t */\n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the reception of the SHUTDOWN, the peer endpoint shall\n\t *  - enter the SHUTDOWN-RECEIVED state,\n\t *  - stop accepting new data from its SCTP user\n\t *\n\t * [This is implicit in the new state.]\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t/*  - verify, by checking the Cumulative TSN Ack field of the\n\t *    chunk, that all its outstanding DATA chunks have been\n\t *    received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n/*\n * sctp_sf_do_9_2_shut_ctsn\n *\n * Once an endpoint has reached the SHUTDOWN-RECEIVED state,\n * it MUST NOT send a SHUTDOWN in response to a ULP request.\n * The Cumulative TSN Ack of the received SHUTDOWN chunk\n * MUST be processed.\n */\nenum sctp_disposition sctp_sf_do_9_2_shut_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_shutdownhdr *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (struct sctp_shutdownhdr *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* verify, by checking the Cumulative TSN Ack field of the\n\t * chunk, that all its outstanding DATA chunks have been\n\t * received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC 2960 9.2\n * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk\n * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination\n * transport addresses (either in the IP addresses or in the INIT chunk)\n * that belong to this association, it should discard the INIT chunk and\n * retransmit the SHUTDOWN ACK chunk.\n */\nstatic enum sctp_disposition\n__sctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\t\t\t   const struct sctp_association *asoc,\n\t\t\t   const union sctp_subtype type, void *arg,\n\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Make sure that the chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Since we are not going to really process this INIT, there\n\t * is no point in verifying chunk boundaries.  Just generate\n\t * the SHUTDOWN ACK.\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-SHUTDOWN timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and restart the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\nenum sctp_disposition\nsctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\t\t\t const struct sctp_association *asoc,\n\t\t\t const union sctp_subtype type, void *arg,\n\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_2_reshutack(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_do_ecn_cwr\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * CWR:\n *\n * RFC 2481 details a specific bit for a sender to send in the header of\n * its next outbound TCP segment to indicate to its peer that it has\n * reduced its congestion window.  This is termed the CWR bit.  For\n * SCTP the same indication is made by including the CWR chunk.\n * This chunk contains one data element, i.e. the TSN number that\n * was sent in the ECNE chunk.  This element represents the lowest\n * TSN number in the datagram that was originally marked with the\n * CE bit.\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_cwrhdr *cwr;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_ecne_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (struct sctp_cwrhdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*cwr));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_do_ecne\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * ECN-Echo\n *\n * RFC 2481 details a specific bit for a receiver to send back in its\n * TCP acknowledgements to notify the sender of the Congestion\n * Experienced (CE) bit having arrived from the network.  For SCTP this\n * same indication is made by including the ECNE chunk.  This chunk\n * contains one data element, i.e. the lowest TSN associated with the IP\n * datagram marked with the CE bit.....\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_ecne(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const union sctp_subtype type,\n\t\t\t\t      void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ecnehdr *ecne;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_ecne_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (struct sctp_ecnehdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*ecne));\n\n\t/* If this is a newer ECNE than the last CWR packet we sent out */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The SCTP endpoint MUST always acknowledge the reception of each valid\n * DATA chunk.\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated within\n * 200 ms of the arrival of any unacknowledged DATA chunk. In some\n * situations it may be beneficial for an SCTP transmitter to be more\n * conservative than the algorithms detailed in this document allow.\n * However, an SCTP transmitter MUST NOT be more aggressive than the\n * following algorithms allow.\n *\n * A SCTP receiver MUST NOT generate more than one SACK for every\n * incoming packet, other than to update the offered window as the\n * receiving application consumes new data.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tunion sctp_arg force = SCTP_NOFORCE();\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sctp_datachk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\treturn SCTP_DISPOSITION_ABORT;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t\t\t       (u8 *)chunk->subh.data_hdr,\n\t\t\t\t\t       sctp_datahdr_len(&asoc->stream));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* If this is the last chunk in a packet, we need to count it\n\t * toward sack generation.  Note that we need to SACK every\n\t * OTHER packet containing data chunks, EVEN IF WE DISCARD\n\t * THEM.  We elect to NOT generate SACK's if the chunk fails\n\t * the verification tag test.\n\t *\n\t * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * The SCTP endpoint MUST always acknowledge the reception of\n\t * each valid DATA chunk.\n\t *\n\t * The guidelines on delayed acknowledgement algorithm\n\t * specified in  Section 4.2 of [RFC2581] SHOULD be followed.\n\t * Specifically, an acknowledgement SHOULD be generated for at\n\t * least every second packet (not every second DATA chunk)\n\t * received, and SHOULD be generated within 200 ms of the\n\t * arrival of any unacknowledged DATA chunk.  In some\n\t * situations it may be beneficial for an SCTP transmitter to\n\t * be more conservative than the algorithms detailed in this\n\t * document allow. However, an SCTP transmitter MUST NOT be\n\t * more aggressive than the following algorithms allow.\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * When a packet arrives with duplicate DATA chunk(s) and with\n\t * no new DATA chunk(s), the endpoint MUST immediately send a\n\t * SACK with no delay.  If a packet arrives with duplicate\n\t * DATA chunk(s) bundled with new DATA chunks, the endpoint\n\t * MAY immediately send a SACK.  Normally receipt of duplicate\n\t * DATA chunks will occur when the original SACK chunk was lost\n\t * and the peer's RTO has expired.  The duplicate TSN number(s)\n\t * SHOULD be reported in the SACK as duplicate.\n\t */\n\t/* In our case, we split the MAY SACK advice up whether or not\n\t * the last chunk is a duplicate.'\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * sctp_sf_eat_data_fast_4_4\n *\n * Section: 4 (4)\n * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received\n *    DATA chunks without delay.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_data_fast_4_4(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sctp_datachk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\treturn SCTP_DISPOSITION_ABORT;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t\t\t       (u8 *)chunk->subh.data_hdr,\n\t\t\t\t\t       sctp_datahdr_len(&asoc->stream));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Go a head and force a SACK, since we are shutting down. */\n\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tif (chunk->end_of_packet) {\n\t\t/* We must delay the chunk creation since the cumulative\n\t\t * TSN has not been updated yet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Processing a Received SACK\n * D) Any time a SACK arrives, the endpoint performs the following:\n *\n *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,\n *     then drop the SACK.   Since Cumulative TSN Ack is monotonically\n *     increasing, a SACK whose Cumulative TSN Ack is less than the\n *     Cumulative TSN Ack Point indicates an out-of-order SACK.\n *\n *     ii) Set rwnd equal to the newly received a_rwnd minus the number\n *     of bytes still outstanding after processing the Cumulative TSN Ack\n *     and the Gap Ack Blocks.\n *\n *     iii) If the SACK is missing a TSN that was previously\n *     acknowledged via a Gap Ack Block (e.g., the data receiver\n *     reneged on the data), then mark the corresponding DATA chunk\n *     as available for retransmit:  Mark it as missing for fast\n *     retransmit as described in Section 7.2.4 and if no retransmit\n *     timer is running for the destination address to which the DATA\n *     chunk was originally transmitted, then T3-rtx is started for\n *     that destination address.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_sackhdr *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_sack_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Pull the SACK chunk from the data buffer */\n\tsackh = sctp_sm_pull_sack(chunk);\n\t/* Was this a bogus SACK? */\n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (TSN_lte(asoc->next_tsn, ctsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\ttrace_sctp_probe(ep, asoc, chunk);\n\n\t/* i) If Cumulative TSN Ack is less than the Cumulative TSN\n\t *     Ack Point, then drop the SACK.  Since Cumulative TSN\n\t *     Ack is monotonically increasing, a SACK whose\n\t *     Cumulative TSN Ack is less than the Cumulative TSN Ack\n\t *     Point indicates an out-of-order SACK.\n\t */\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Return this SACK for further processing.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t/* Note: We do the rest of the work on the PROCESS_SACK\n\t * sideeffect.\n\t */\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate an ABORT in response to a packet.\n *\n * Section: 8.4 Handle \"Out of the blue\" Packets, sctpimpguide 2.41\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n *\n * Verification Tag:\n *\n * The return value is the disposition of the chunk.\n*/\nstatic enum sctp_disposition sctp_sf_tabort_8_4_8(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Make an ABORT. The T bit will be set if the asoc\n\t * is NULL.\n\t */\n\tabort = sctp_make_abort(asoc, chunk, 0);\n\tif (!abort) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\t/* Reflect vtag if T-Bit is set */\n\tif (sctp_test_T_bit(abort))\n\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t/* Set the skb to the belonging sock for accounting.  */\n\tabort->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, abort);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Handling of SCTP Packets Containing an INIT Chunk Matching an\n * Existing Associations when the UDP encap port is incorrect.\n *\n * From Section 4 at draft-tuexen-tsvwg-sctp-udp-encaps-cons-03.\n */\nstatic enum sctp_disposition sctp_sf_new_encap_port(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tabort = sctp_make_new_encap_port(asoc, chunk);\n\tif (!abort) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\tabort->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, abort);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR\n * event as ULP notification for each cause included in the chunk.\n *\n * API 5.3.1.3 - SCTP_REMOTE_ERROR\n *\n * The return value is the disposition of the chunk.\n*/\nenum sctp_disposition sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_errhdr *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_operr_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an inbound SHUTDOWN ACK.\n *\n * From Section 9.2:\n * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its\n * peer, and remove all record of the association.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* 10.2 H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t/* ...send a SHUTDOWN COMPLETE chunk to its peer, */\n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t/* Do all the commands now (after allocation), so that we\n\t * have consistent state if memory allocation fails\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n\t * stop the T2-shutdown timer,\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t/* ...and remove all record of the association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n */\nenum sctp_disposition sctp_sf_ootb(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t   void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tstruct sctp_chunkhdr *ch;\n\tstruct sctp_errhdr *err;\n\tint ootb_cookie_ack = 0;\n\tint ootb_shut_ack = 0;\n\t__u8 *ch_end;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n\t\tasoc = NULL;\n\n\tch = (struct sctp_chunkhdr *)chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(*ch))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tch = (struct sctp_chunkhdr *)ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an \"Out of the blue\" SHUTDOWN ACK.\n *\n * Section: 8.4 5, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * Inputs\n * (endpoint, asoc, type, arg, commands)\n *\n * Outputs\n * (enum sctp_disposition)\n *\n * The return value is the disposition of the chunk.\n */\nstatic enum sctp_disposition sctp_sf_shut_8_4_5(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Make an SHUTDOWN_COMPLETE.\n\t * The T bit will be set if the asoc is NULL.\n\t */\n\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!shut) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\t/* Reflect vtag if T-Bit is set */\n\tif (sctp_test_T_bit(shut))\n\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t/* Set the skb to the belonging sock for accounting.  */\n\tshut->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, shut);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* We need to discard the rest of the packet to prevent\n\t * potential boomming attacks from additional bundled chunks.\n\t * This is documented in SCTP Threats ID.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.\n *\n * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK\n *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the\n *   procedures in section 8.4 SHOULD be followed, in other words it\n *   should be treated as an Out Of The Blue packet.\n *   [This means that we do NOT check the Verification Tag on these\n *   chunks. --piggy ]\n *\n */\nenum sctp_disposition sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\tasoc = NULL;\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Although we do have an association in this case, it corresponds\n\t * to a restarted association. So the packet is treated as an OOTB\n\t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n\t * called with a NULL association.\n\t */\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */\nenum sctp_disposition sctp_sf_do_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *asconf_ack = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_addiphdr *hdr;\n\t__u32 serial;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_addip_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!asoc->peer.asconf_capable ||\n\t    (!net->sctp.addip_noauth && !chunk->auth))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\thdr = (struct sctp_addiphdr *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc, chunk, true, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t/* Reset the transport so that we select the correct one\n\t\t * this time around.  This is to make sure that we don't\n\t\t * accidentally use a stale transport that's been removed.\n\t\t */\n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created until we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t\tsctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\nstatic enum sctp_disposition sctp_send_next_asconf(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *asconf;\n\tstruct list_head *entry;\n\n\tif (list_empty(&asoc->addip_chunk_list))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\tentry = asoc->addip_chunk_list.next;\n\tasconf = list_entry(entry, struct sctp_chunk, list);\n\n\tlist_del_init(entry);\n\tsctp_chunk_hold(asconf);\n\tasoc->addip_last_asconf = asconf;\n\n\treturn sctp_sf_do_prm_asconf(net, ep, asoc, type, asconf, commands);\n}\n\n/*\n * ADDIP Section 4.3 General rules for address manipulation\n * When building TLV parameters for the ASCONF Chunk that will add or\n * delete IP addresses the D0 to D13 rules should be applied:\n */\nenum sctp_disposition sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *asconf_ack = arg;\n\tstruct sctp_addiphdr *addip_hdr;\n\t__u32 sent_serial, rcvd_serial;\n\tstruct sctp_chunk *abort;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack,\n\t\t\t\t     sizeof(struct sctp_addip_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!asoc->peer.asconf_capable ||\n\t    (!net->sctp.addip_noauth && !asconf_ack->auth))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\taddip_hdr = (struct sctp_addiphdr *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc, asconf_ack, false, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (struct sctp_addiphdr *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(struct sctp_errhdr));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack))\n\t\t\treturn sctp_send_next_asconf(net, ep,\n\t\t\t\t\t(struct sctp_association *)asoc,\n\t\t\t\t\t\t\ttype, commands);\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(struct sctp_errhdr));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* RE-CONFIG Section 5.2 Upon reception of an RECONF Chunk. */\nenum sctp_disposition sctp_sf_do_reconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_reconf_chunk *hdr;\n\tunion sctp_params param;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the RECONF chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(*hdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tif (!sctp_verify_reconf(asoc, chunk, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\thdr = (struct sctp_reconf_chunk *)chunk->chunk_hdr;\n\tsctp_walk_params(param, hdr, params) {\n\t\tstruct sctp_chunk *reply = NULL;\n\t\tstruct sctp_ulpevent *ev = NULL;\n\n\t\tif (param.p->type == SCTP_PARAM_RESET_OUT_REQUEST)\n\t\t\treply = sctp_process_strreset_outreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_IN_REQUEST)\n\t\t\treply = sctp_process_strreset_inreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_TSN_REQUEST)\n\t\t\treply = sctp_process_strreset_tsnreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_ADD_OUT_STREAMS)\n\t\t\treply = sctp_process_strreset_addstrm_out(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_ADD_IN_STREAMS)\n\t\t\treply = sctp_process_strreset_addstrm_in(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_RESPONSE)\n\t\t\treply = sctp_process_strreset_resp(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\n\t\tif (ev)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t\tif (reply)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(reply));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP\n *\n * When a FORWARD TSN chunk arrives, the data receiver MUST first update\n * its cumulative TSN point to the value carried in the FORWARD TSN\n * chunk, and then MUST further advance its cumulative TSN point locally\n * if possible.\n * After the above processing, the data receiver MUST stop reporting any\n * missing TSNs earlier than or equal to the new cumulative TSN point.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sctp_ftsnchk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\tif (!asoc->stream.si->validate_ftsn(chunk))\n\t\tgoto discard_noforce;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sctp_ftsnhdr_len(&asoc->stream))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nenum sctp_disposition sctp_sf_eat_fwd_tsn_fast(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sctp_ftsnchk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\tif (!asoc->stream.si->validate_ftsn(chunk))\n\t\tgoto gen_shutdown;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sctp_ftsnhdr_len(&asoc->stream))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * SCTP-AUTH Section 6.3 Receiving authenticated chunks\n *\n *    The receiver MUST use the HMAC algorithm indicated in the HMAC\n *    Identifier field.  If this algorithm was not specified by the\n *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk\n *    during association setup, the AUTH chunk and all chunks after it MUST\n *    be discarded and an ERROR chunk SHOULD be sent with the error cause\n *    defined in Section 4.1.\n *\n *    If an endpoint with no shared key receives a Shared Key Identifier\n *    other than 0, it MUST silently discard all authenticated chunks.  If\n *    the endpoint has at least one endpoint pair shared key for the peer,\n *    it MUST use the key specified by the Shared Key Identifier if a\n *    key has been configured for that Shared Key Identifier.  If no\n *    endpoint pair shared key has been configured for that Shared Key\n *    Identifier, all authenticated chunks MUST be silently discarded.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nstatic enum sctp_ierror sctp_sf_authenticate(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_shared_key *sh_key = NULL;\n\tstruct sctp_authhdr *auth_hdr;\n\t__u8 *save_digest, *digest;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\n\t/* Pull in the auth header, so we can do some more verification */\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(*auth_hdr));\n\n\t/* Make sure that we support the HMAC algorithm from the auth\n\t * chunk.\n\t */\n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t/* Make sure that the provided shared key identifier has been\n\t * configured\n\t */\n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id) {\n\t\tsh_key = sctp_auth_get_shkey(asoc, key_id);\n\t\tif (!sh_key)\n\t\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\t}\n\n\t/* Make sure that the length of the signature matches what\n\t * we expect.\n\t */\n\tsig_len = ntohs(chunk->chunk_hdr->length) -\n\t\t  sizeof(struct sctp_auth_chunk);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Now that we've done validation checks, we can compute and\n\t * verify the hmac.  The steps involved are:\n\t *  1. Save the digest from the chunk.\n\t *  2. Zero out the digest in the chunk.\n\t *  3. Compute the new digest\n\t *  4. Compare saved and new digests.\n\t */\n\tdigest = auth_hdr->hmac;\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t (struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\t sh_key, GFP_ATOMIC);\n\n\t/* Discard the packet if the digests do not match */\n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nenum sctp_disposition sctp_sf_eat_auth(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *err_chunk;\n\tenum sctp_ierror error;\n\n\t/* Make sure that the peer has AUTH capable */\n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the AUTH chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(asoc, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t/* Generate the ERROR chunk and discard the rest\n\t\t * of the packet\n\t\t */\n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\tfallthrough;\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t/* Prevent gcc warnings */\n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEW_KEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn -ENOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an unknown chunk.\n *\n * Section: 3.2. Also, 2.1 in the implementor's guide.\n *\n * Chunk Types are encoded such that the highest-order two bits specify\n * the action that must be taken if the processing endpoint does not\n * recognize the Chunk Type.\n *\n * 00 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it.\n *\n * 01 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it, and report the unrecognized\n *      chunk in an 'Unrecognized Chunk Type'.\n *\n * 10 - Skip this chunk and continue processing.\n *\n * 11 - Skip this chunk and continue processing, but report in an ERROR\n *      Chunk using the 'Unrecognized Chunk Type' cause of error.\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_chunkhdr *hdr;\n\n\tpr_debug(\"%s: processing unknown chunk id:%d\\n\", __func__, type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(*hdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t/* Discard the packet.  */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       SCTP_PAD4(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t/* Discard the packet.  */\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       SCTP_PAD4(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the chunk.\n *\n * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2\n * [Too numerous to mention...]\n * Verification Tag: No verification needed.\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tpr_debug(\"%s: chunk:%d is discarded\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the whole packet.\n *\n * Section: 8.4 2)\n *\n * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n *    silently discard the OOTB packet and take no further action.\n *\n * Verification Tag: No verification necessary\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_pdiscard(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n/*\n * The other end is violating protocol.\n *\n * Section: Not specified\n * Verification Tag: Not specified\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * We simply tag the chunk as a violation.  The state machine will log\n * the violation and continue.\n */\nenum sctp_disposition sctp_sf_violation(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n/*\n * Common function to handle a protocol violation.\n */\nstatic enum sctp_disposition sctp_sf_abort_violation(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tstruct sctp_initack_chunk *initack;\n\n\t\t\tinitack = (struct sctp_initack_chunk *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk, sizeof(*initack)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a protocol violation when the chunk length is invalid.\n * \"Invalid\" length is identified as smaller than the minimal length a\n * given chunk can be.  For example, a SACK chunk has invalid length\n * if its length is set to be smaller than the size of struct sctp_sack_chunk.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n *\n * Section: Not specified\n * Verification Tag:  Nothing to do\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (reply_msg, msg_up, counters)\n *\n * Generate an  ABORT chunk and terminate the association.\n */\nstatic enum sctp_disposition sctp_sf_violation_chunklen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n\n/*\n * Handle a protocol violation when the parameter length is invalid.\n * If the length is smaller than the minimum length of a given parameter,\n * or accumulated length in multi parameters exceeds the end of the chunk,\n * the length is considered as invalid.\n */\nstatic enum sctp_disposition sctp_sf_violation_paramlen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg, void *ext,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle a protocol violation when the peer trying to advance the\n * cumulative tsn ack to a point beyond the max tsn currently sent.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n */\nstatic enum sctp_disposition sctp_sf_violation_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n\n/* Handle protocol violation of an invalid chunk bundling.  For example,\n * when we have an association and we receive bundled INIT-ACK, or\n * SHUTDOWN-COMPLETE, our peer is clearly violating the \"MUST NOT bundle\"\n * statement from the specs.  Additionally, there might be an attacker\n * on the path and we may not want to continue this communication.\n */\nstatic enum sctp_disposition sctp_sf_violation_chunk(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n/***************************************************************************\n * These are the state functions for handling primitive (Section 10) events.\n ***************************************************************************/\n/*\n * sctp_sf_do_prm_asoc\n *\n * Section: 10.1 ULP-to-SCTP\n * B) Associate\n *\n * Format: ASSOCIATE(local SCTP instance name, destination transport addr,\n * outbound stream count)\n * -> association id [,destination transport addr list] [,outbound stream\n * count]\n *\n * This primitive allows the upper layer to initiate an association to a\n * specific peer endpoint.\n *\n * The peer endpoint shall be specified by one of the transport addresses\n * which defines the endpoint (see Section 1.4).  If the local SCTP\n * instance has not been initialized, the ASSOCIATE is considered an\n * error.\n * [This is not relevant for the kernel implementation since we do all\n * initialization at boot time.  It we hadn't initialized we wouldn't\n * get anywhere near this code.]\n *\n * An association id, which is a local handle to the SCTP association,\n * will be returned on successful establishment of the association. If\n * SCTP is not able to open an SCTP association with the peer endpoint,\n * an error is returned.\n * [In the kernel implementation, the struct sctp_association needs to\n * be created BEFORE causing this primitive to run.]\n *\n * Other association parameters may be returned, including the\n * complete destination transport addresses of the peer as well as the\n * outbound stream count of the local endpoint. One of the transport\n * address from the returned destination addresses will be selected by\n * the local endpoint as default primary path for sending SCTP packets\n * to this peer.  The returned \"destination transport addr list\" can\n * be used by the ULP to change the default primary path or to force\n * sending a packet to a specific transport address.  [All of this\n * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING\n * function.]\n *\n * Mandatory attributes:\n *\n * o local SCTP instance name - obtained from the INITIALIZE operation.\n *   [This is the argument asoc.]\n * o destination transport addr - specified as one of the transport\n * addresses of the peer endpoint with which the association is to be\n * established.\n *  [This is asoc->peer.active_path.]\n * o outbound stream count - the number of outbound streams the ULP\n * would like to open towards this peer endpoint.\n * [BUG: This is not currently implemented.]\n * Optional attributes:\n *\n * None.\n *\n * The return value is a disposition.\n */\nenum sctp_disposition sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_association *my_asoc;\n\tstruct sctp_chunk *repl;\n\n\t/* The comment below says that we enter COOKIE-WAIT AFTER\n\t * sending the INIT, but that doesn't actually work in our\n\t * implementation...\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\"\n\t * must provide its Verification Tag (Tag_A) in the Initiate\n\t * Tag field.  Tag_A SHOULD be a random number in the range of\n\t * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...\n\t */\n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Choose transport for INIT. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t/* After sending the INIT, \"A\" starts the T1-init timer and\n\t * enters the COOKIE-WAIT state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the SEND primitive.\n *\n * Section: 10.1 ULP-to-SCTP\n * E) Send\n *\n * Format: SEND(association id, buffer address, byte count [,context]\n *         [,stream id] [,life time] [,destination transport address]\n *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n * -> result\n *\n * This is the main method to send user data via SCTP.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n *  o buffer address - the location where the user message to be\n *    transmitted is stored;\n *\n *  o byte count - The size of the user data in number of bytes;\n *\n * Optional attributes:\n *\n *  o context - an optional 32 bit integer that will be carried in the\n *    sending failure notification to the ULP if the transportation of\n *    this User Message fails.\n *\n *  o stream id - to indicate which stream to send the data on. If not\n *    specified, stream 0 will be used.\n *\n *  o life time - specifies the life time of the user data. The user data\n *    will not be sent by SCTP after the life time expires. This\n *    parameter can be used to avoid efforts to transmit stale\n *    user messages. SCTP notifies the ULP if the data cannot be\n *    initiated to transport (i.e. sent to the destination via SCTP's\n *    send primitive) within the life time variable. However, the\n *    user data will be transmitted if SCTP has attempted to transmit a\n *    chunk before the life time expired.\n *\n *  o destination transport address - specified as one of the destination\n *    transport addresses of the peer endpoint to which this packet\n *    should be sent. Whenever possible, SCTP should use this destination\n *    transport address for sending the packets, instead of the current\n *    primary path.\n *\n *  o unorder flag - this flag, if present, indicates that the user\n *    would like the data delivered in an unordered fashion to the peer\n *    (i.e., the U flag is set to 1 on all DATA chunks carrying this\n *    message).\n *\n *  o no-bundle flag - instructs SCTP not to bundle this user data with\n *    other outbound DATA chunks. SCTP MAY still bundle even when\n *    this flag is present, when faced with network congestion.\n *\n *  o payload protocol-id - A 32 bit unsigned integer that is to be\n *    passed to the peer indicating the type of payload protocol data\n *    being transmitted. This value is passed as opaque data by SCTP.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process the SHUTDOWN primitive.\n *\n * Section: 10.1:\n * C) Shutdown\n *\n * Format: SHUTDOWN(association id)\n * -> result\n *\n * Gracefully closes an association. Any locally queued user data\n * will be delivered to the peer. The association will be terminated only\n * after the peer acknowledges all the SCTP packets sent.  A success code\n * will be returned on successful termination of the association. If\n * attempting to terminate the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n * None.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\n\treturn disposition;\n}\n\n/*\n * Process the ABORT primitive.\n *\n * Section: 10.1:\n * C) Abort\n *\n * Format: Abort(association id [, cause code])\n * -> result\n *\n * Ungracefully closes an association. Any locally queued user data\n * will be discarded and an ABORT chunk is sent to the peer.  A success code\n * will be returned on successful abortion of the association. If\n * attempting to abort the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n *  o cause code - reason of the abort to be passed to the peer\n *\n * None.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_1_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\n\tif (abort)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/* We tried an illegal operation on an association which is closed.  */\nenum sctp_disposition sctp_sf_error_closed(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* We tried an illegal operation on an association which is shutting\n * down.\n */\nenum sctp_disposition sctp_sf_error_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_cookie_wait_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_wait_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * sctp_cookie_echoed_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_echoed_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_wait_prm_abort\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_wait_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\n\t/* Stop T1-init timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tif (abort)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Section: 4 Note: 3\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_cookie_echoed_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_pending_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-PENDING state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_shutdown_pending_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_sent_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-SENT state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_shutdown_sent_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* Stop the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nenum sctp_disposition sctp_sf_shutdown_ack_sent_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process the REQUESTHEARTBEAT primitive\n *\n * 10.1 ULP-to-SCTP\n * J) Request Heartbeat\n *\n * Format: REQUESTHEARTBEAT(association id, destination transport address)\n *\n * -> result\n *\n * Instructs the local endpoint to perform a HeartBeat on the specified\n * destination transport address of the given association. The returned\n * result should indicate whether the transmission of the HEARTBEAT\n * chunk to the destination address is successful.\n *\n * Mandatory attributes:\n *\n * o association id - local handle to the SCTP association\n *\n * o destination transport address - the transport address of the\n *   association on which a heartbeat should be issued.\n */\nenum sctp_disposition sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/*\n\t * RFC 2960 (bis), section 8.3\n\t *\n\t *    D) Request an on-demand HEARTBEAT on a specific destination\n\t *    transport address of a given association.\n\t *\n\t *    The endpoint should increment the respective error  counter of\n\t *    the destination transport address each time a HEARTBEAT is sent\n\t *    to that address and not acknowledged within one RTO.\n\t *\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * When an endpoint has an ASCONF signaled change to be sent to the\n * remote endpoint it should do A1 to A9\n */\nenum sctp_disposition sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RE-CONFIG Section 5.1 RECONF Chunk Procedures */\nenum sctp_disposition sctp_sf_do_prm_reconf(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Ignore the primitive event\n *\n * The return value is the disposition of the primitive.\n */\nenum sctp_disposition sctp_sf_ignore_primitive(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: primitive type:%d is ignored\\n\", __func__,\n\t\t type.primitive);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/***************************************************************************\n * These are the state functions for the OTHER events.\n ***************************************************************************/\n\n/*\n * When the SCTP stack has no more user data to send or retransmit, this\n * notification is given to the user. Also, at the time when a user app\n * subscribes to this event, if there is no data to be sent or\n * retransmit, the stack will immediately send up this notification.\n */\nenum sctp_disposition sctp_sf_do_no_pending_tsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Start the shutdown negotiation.\n *\n * From Section 9.2:\n * Once all its outstanding data has been acknowledged, the endpoint\n * shall send a SHUTDOWN chunk to its peer including in the Cumulative\n * TSN Ack field the last sequential TSN it has received from the peer.\n * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n * state. If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_start_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t/* Once all its outstanding data has been acknowledged, the\n\t * endpoint shall send a SHUTDOWN chunk to its peer including\n\t * in the Cumulative TSN Ack field the last sequential TSN it\n\t * has received from the peer.\n\t */\n\treply = sctp_make_shutdown(asoc, arg);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN chunk and the timeout for the\n\t * T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* It shall then start the T2-shutdown timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* RFC 4960 Section 9.2\n\t * The sender of the SHUTDOWN MAY also start an overall guard timer\n\t * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* and enter the SHUTDOWN-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Generate a SHUTDOWN ACK now that everything is SACK'd.\n *\n * From Section 9.2:\n *\n * If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the\n * endpoint must re-send the SHUTDOWN ACK.\n *\n * The return value is the disposition.\n */\nenum sctp_disposition sctp_sf_do_9_2_shutdown_ack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg,\n\t\t\t\t\t\tcommands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(\n\t\t\t\tchunk, sizeof(struct sctp_shutdown_chunk)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Ignore the event defined as other\n *\n * The return value is the disposition of the event.\n */\nenum sctp_disposition sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: the event other type:%d is ignored\\n\",\n\t\t __func__, type.other);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/************************************************************\n * These are the state functions for handling timeout events.\n ************************************************************/\n\n/*\n * RTX Timeout\n *\n * Section: 6.3.3 Handle T3-rtx Expiration\n *\n * Whenever the retransmission timer T3-rtx expires for a destination\n * address, do the following:\n * [See below]\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->peer.zero_window_announced &&\n\t\t    asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate delayed SACK on timeout\n *\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated\n * within 200 ms of the arrival of any unacknowledged DATA chunk.  In\n * some situations it may be beneficial for an SCTP transmitter to be\n * more conservative than the algorithms detailed in this document\n * allow. However, an SCTP transmitter MUST NOT be more aggressive than\n * the following algorithms allow.\n */\nenum sctp_disposition sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_init_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT\n *     and re-start the T1-init timer without changing state.  This MUST\n *     be repeated up to 'Max.Init.Retransmits' times.  After that, the\n *     endpoint MUST abort the initialization process and report the\n *     error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nenum sctp_disposition sctp_sf_t1_init_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\n\tpr_debug(\"%s: timer T1 expired (INIT)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Choose transport for INIT. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tpr_debug(\"%s: giving up on INIT, attempts:%d \"\n\t\t\t \"max_init_attempts:%d\\n\", __func__, attempts,\n\t\t\t asoc->max_init_attempts);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_cookie_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  3) If the T1-cookie timer expires, the endpoint MUST retransmit\n *     COOKIE ECHO and re-start the T1-cookie timer without changing\n *     state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n *     After that, the endpoint MUST abort the initialization process and\n *     report the error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nenum sctp_disposition sctp_sf_t1_cookie_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *repl = NULL;\n\n\tpr_debug(\"%s: timer T1 expired (COOKIE-ECHO)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * An endpoint should limit the number of retransmission of the\n * SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n * If this threshold is exceeded the endpoint should destroy the TCB and\n * MUST report the peer endpoint unreachable to the upper layer (and\n * thus the association enters the CLOSED state).  The reception of any\n * packet from its peer (i.e. as the peer sends all of its queued DATA\n * chunks) should clear the endpoint's retransmission count and restart\n * the T2-Shutdown timer,  giving its peer ample opportunity to transmit\n * all of its queued DATA chunks that have not yet been sent.\n */\nenum sctp_disposition sctp_sf_t2_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T2 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Do some failure management (Section 8.2).\n\t * If we remove the transport an SHUTDOWN was last sent to, don't\n\t * do failure management.\n\t */\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* Restart the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * If the T4 RTO timer expires the endpoint should do B1 to B5\n */\nenum sctp_disposition sctp_sf_t4_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t/* ADDIP 4.1 B1) Increment the error counters and perform path failure\n\t * detection on the appropriate destination address as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t */\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t/* Reconfig T4 timer and transport. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t/* ADDIP 4.1 B2) Increment the association error counters and perform\n\t * endpoint failure detection on the association as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t * association error counter is incremented in SCTP_CMD_STRIKE.\n\t */\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t/* ADDIP 4.1 B3) Back-off the destination address RTO value to which\n\t * the ASCONF chunk was sent by doubling the RTO timer value.\n\t * This is done in SCTP_CMD_STRIKE.\n\t */\n\n\t/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible\n\t * choose an alternate destination address (please refer to RFC2960\n\t * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this\n\t * chunk, it MUST be the same (including its serial number) as the last\n\t * ASCONF sent.\n\t */\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different\n\t * destination is selected, then the RTO used will be that of the new\n\t * destination address.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* sctpimpguide-05 Section 2.12.2\n * The sender of the SHUTDOWN MAY also start an overall guard timer\n * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n * At the expiration of this timer the sender SHOULD abort the association\n * by sending an ABORT chunk.\n */\nenum sctp_disposition sctp_sf_t5_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T5 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,\n * the association is automatically closed by starting the shutdown process.\n * The work that needs to be done is same as when SHUTDOWN is initiated by\n * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().\n */\nenum sctp_disposition sctp_sf_autoclose_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    NULL, commands);\n\t}\n\n\treturn disposition;\n}\n\n/*****************************************************************************\n * These are sa state functions which could apply to all types of events.\n ****************************************************************************/\n\n/*\n * This table entry is not implemented.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_not_impl(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n/*\n * This table entry represents a bug.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_bug(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t  void *arg, struct sctp_cmd_seq *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n/*\n * This table entry represents the firing of a timer in the wrong state.\n * Since timer deletion cannot be guaranteed a timer 'may' end up firing\n * when the association is in the wrong state.   This event should\n * be ignored, so as to prevent any rearming of the timer.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nenum sctp_disposition sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: timer %d ignored\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Pull the SACK chunk based on the SACK header. */\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\t__u16 num_dup_tsns;\n\tunsigned int len;\n\t__u16 num_blocks;\n\n\t/* Protect ourselves from reading too far into\n\t * the skb from a bogus sender.\n\t */\n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n/* Create an ABORT packet to be sent as a response, with the specified\n * error causes.\n */\nstatic struct sctp_packet *sctp_abort_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tconst void *payload, size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Add specified error causes, i.e., payload, to the\n\t\t * end of the chunk.\n\t\t */\n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n/* Allocate a packet for responding in the OOTB conditions.  */\nstatic struct sctp_packet *sctp_ootb_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *transport;\n\tstruct sctp_packet *packet;\n\t__u16 sport, dport;\n\t__u32 vtag;\n\n\t/* Get the source and destination port from the inbound packet.  */\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t/* The V-tag is going to be the same as the inbound packet if no\n\t * association exists, otherwise, use the peer's vtag.\n\t */\n\tif (asoc) {\n\t\t/* Special case the INIT-ACK as there is no peer's vtag\n\t\t * yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tstruct sctp_initack_chunk *initack;\n\n\t\t\tinitack = (struct sctp_initack_chunk *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Special case the INIT and stale COOKIE_ECHO as there is no\n\t\t * vtag yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tstruct sctp_init_chunk *init;\n\n\t\t\tinit = (struct sctp_init_chunk *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make a transport for the bucket, Eliza... */\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\ttransport->encap_port = SCTP_INPUT_CB(chunk->skb)->encap_port;\n\n\t/* Cache a route for the transport with the chunk's destination as\n\t * the source address.\n\t */\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = &transport->packet;\n\tsctp_packet_init(packet, transport, sport, dport);\n\tsctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n/* Free the packet allocated earlier for responding in the OOTB condition.  */\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       struct sctp_cmd_seq *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t/* Override the OOTB vtag from the cookie. */\n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t/* Set the skb to the belonging sock for accounting. */\n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n/* Process a data chunk */\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_datahdr *data_hdr;\n\tstruct sctp_chunk *err;\n\tenum sctp_verb deliver;\n\tsize_t datalen;\n\t__u32 tsn;\n\tint tmp;\n\n\tdata_hdr = (struct sctp_datahdr *)chunk->skb->data;\n\tchunk->subh.data_hdr = data_hdr;\n\tskb_pull(chunk->skb, sctp_datahdr_len(&asoc->stream));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (asoc->peer.ecn_capable && !chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af = SCTP_INPUT_CB(chunk->skb)->af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\tif (af->is_ce(sctp_gso_headskb(chunk->skb))) {\n\t\t\t/* Do real work as side effect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sctp_datachk_len(&asoc->stream);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (sk_under_memory_pressure(sk)) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tsk_mem_reclaim(sk);\n\t\t}\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tif (ntohs(data_hdr->stream) >= asoc->stream.incnt) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tif (!asoc->stream.si->validate_data(chunk))\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n"], "filenames": ["net/sctp/sm_statefuns.c"], "buggy_code_start_loc": [158], "buggy_code_end_loc": [6350], "fixing_code_start_loc": [159], "fixing_code_end_loc": [6382], "type": "CWE-354", "message": "A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.", "other": {"cve": {"id": "CVE-2021-3772", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-02T23:15:09.127", "lastModified": "2023-02-12T23:42:47.697", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses."}, {"lang": "es", "value": "Se ha encontrado un fallo en la pila SCTP de Linux. Un atacante ciego puede ser capaz de matar una asociaci\u00f3n SCTP existente mediante trozos no v\u00e1lidos si el atacante conoce las direcciones IP y los n\u00fameros de puerto que est\u00e1n siendo usados y el atacante puede enviar paquetes con direcciones IP falsas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-354"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-354"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.15.0", "matchCriteriaId": "103D9D8F-806F-4043-80C3-73831775798E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:22.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "6EDB6772-7FDB-45FF-8D72-952902A7EE56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_exposure_function:22.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "9955F62A-75D3-4347-9AD3-5947FC365838"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:22.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "7A6D77C7-A2F4-4700-AB5A-3EC853496ECA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "8AFF1109-26F3-43A5-A4CB-0F169FDBC0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AF71C49-ADEF-4EE2-802C-6159ADD51355"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.20:*:*:*:*:*:*:*", "matchCriteriaId": "B3BC6E59-2134-4A28-AAD2-77C8AE236BCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.25:*:*:*:*:*:*:*", "matchCriteriaId": "24377899-5389-4BDC-AC82-0E4186F4DE53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30:*:*:*:*:*:*:*", "matchCriteriaId": "23FE83DE-AE7C-4313-88E3-886110C31302"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30.5r3:*:*:*:*:*:*:*", "matchCriteriaId": "490B327B-AC20-419B-BB76-8AB6971304BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40:*:*:*:*:*:*:*", "matchCriteriaId": "8DCE2754-7A9E-4B3B-91D1-DCF90C1BABE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.3r2:*:*:*:*:*:*:*", "matchCriteriaId": "6CA74E8B-51E2-4A7C-8A98-0583D31134A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B64AB37-A1D9-4163-A51B-4C780361F1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.1:*:*:*:*:*:*:*", "matchCriteriaId": "7BE9C9D7-9CED-4184-A190-1024A6FB8C82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:-:*:*:*:*:*:*", "matchCriteriaId": "B73D4C3C-A511-4E14-B19F-91F561ACB1B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:p1:*:*:*:*:*:*", "matchCriteriaId": "0C47D72C-9B6B-4E52-AF0E-56AD58E4A930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60:*:*:*:*:*:*:*", "matchCriteriaId": "039C3790-5AA2-4895-AEAE-CC84A71DB907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4592238-D1F2-43D6-9BAB-2F63ECF9C965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BA78068-80E9-4E49-9056-88EAB7E3682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.3:*:*:*:*:*:*:*", "matchCriteriaId": "092F366C-E8B0-4BE5-B106-0B7A73B08D34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.1:*:*:*:*:*:*:*", "matchCriteriaId": "E7992E92-B159-4810-B895-01A9B944058A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.2:*:*:*:*:*:*:*", "matchCriteriaId": "5BDD7AAB-2BF3-4E8C-BEE2-5217E2926C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D452B464-1200-4B72-9A89-42DC58486191"}, {"vulnerable": true, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "89612649-BACF-4FAC-9BA4-324724FD93A6"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610c:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3D9B255-C1AF-42D1-BF9B-13642FBDC080"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h615c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "5921A877-18BF-43FE-915C-D226E140ACFC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h615c:-:*:*:*:*:*:*:*", "matchCriteriaId": "7296A1F2-D315-4FD5-8A73-65C480C855BE"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2000694", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=32f8807a48ae55be0e76880cfe8607a18b5bb0df", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/32f8807a48ae55be0e76880cfe8607a18b5bb0df", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221007-0001/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://ubuntu.com/security/CVE-2021-3772", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5096", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/32f8807a48ae55be0e76880cfe8607a18b5bb0df"}}