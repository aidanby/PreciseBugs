{"buggy_code": ["/*-\n * Copyright (c) 2003-2010 Tim Kientzle\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_write.c 201099 2009-12-28 03:03:00Z kientzle $\");\n\n/*\n * This file contains the \"essential\" portions of the write API, that\n * is, stuff that will essentially always be used by any client that\n * actually needs to write an archive.  Optional pieces have been, as\n * far as possible, separated out into separate files to reduce\n * needlessly bloating statically-linked clients.\n */\n\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#include <time.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_write_private.h\"\n\nstatic struct archive_vtable *archive_write_vtable(void);\n\nstatic int\t_archive_filter_code(struct archive *, int);\nstatic const char *_archive_filter_name(struct archive *, int);\nstatic int64_t\t_archive_filter_bytes(struct archive *, int);\nstatic int  _archive_write_filter_count(struct archive *);\nstatic int\t_archive_write_close(struct archive *);\nstatic int\t_archive_write_free(struct archive *);\nstatic int\t_archive_write_header(struct archive *, struct archive_entry *);\nstatic int\t_archive_write_finish_entry(struct archive *);\nstatic ssize_t\t_archive_write_data(struct archive *, const void *, size_t);\n\nstruct archive_none {\n\tsize_t buffer_size;\n\tsize_t avail;\n\tchar *buffer;\n\tchar *next;\n};\n\nstatic struct archive_vtable *\narchive_write_vtable(void)\n{\n\tstatic struct archive_vtable av;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tav.archive_close = _archive_write_close;\n\t\tav.archive_filter_bytes = _archive_filter_bytes;\n\t\tav.archive_filter_code = _archive_filter_code;\n\t\tav.archive_filter_name = _archive_filter_name;\n\t\tav.archive_filter_count = _archive_write_filter_count;\n\t\tav.archive_free = _archive_write_free;\n\t\tav.archive_write_header = _archive_write_header;\n\t\tav.archive_write_finish_entry = _archive_write_finish_entry;\n\t\tav.archive_write_data = _archive_write_data;\n\t\tinited = 1;\n\t}\n\treturn (&av);\n}\n\n/*\n * Allocate, initialize and return an archive object.\n */\nstruct archive *\narchive_write_new(void)\n{\n\tstruct archive_write *a;\n\tunsigned char *nulls;\n\n\ta = (struct archive_write *)malloc(sizeof(*a));\n\tif (a == NULL)\n\t\treturn (NULL);\n\tmemset(a, 0, sizeof(*a));\n\ta->archive.magic = ARCHIVE_WRITE_MAGIC;\n\ta->archive.state = ARCHIVE_STATE_NEW;\n\ta->archive.vtable = archive_write_vtable();\n\t/*\n\t * The value 10240 here matches the traditional tar default,\n\t * but is otherwise arbitrary.\n\t * TODO: Set the default block size from the format selected.\n\t */\n\ta->bytes_per_block = 10240;\n\ta->bytes_in_last_block = -1;\t/* Default */\n\n\t/* Initialize a block of nulls for padding purposes. */\n\ta->null_length = 1024;\n\tnulls = (unsigned char *)malloc(a->null_length);\n\tif (nulls == NULL) {\n\t\tfree(a);\n\t\treturn (NULL);\n\t}\n\tmemset(nulls, 0, a->null_length);\n\ta->nulls = nulls;\n\treturn (&a->archive);\n}\n\n/*\n * Set the block size.  Returns 0 if successful.\n */\nint\narchive_write_set_bytes_per_block(struct archive *_a, int bytes_per_block)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_set_bytes_per_block\");\n\ta->bytes_per_block = bytes_per_block;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Get the current block size.  -1 if it has never been set.\n */\nint\narchive_write_get_bytes_per_block(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_per_block\");\n\treturn (a->bytes_per_block);\n}\n\n/*\n * Set the size for the last block.\n * Returns 0 if successful.\n */\nint\narchive_write_set_bytes_in_last_block(struct archive *_a, int bytes)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_set_bytes_in_last_block\");\n\ta->bytes_in_last_block = bytes;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Return the value set above.  -1 indicates it has not been set.\n */\nint\narchive_write_get_bytes_in_last_block(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_in_last_block\");\n\treturn (a->bytes_in_last_block);\n}\n\n/*\n * dev/ino of a file to be rejected.  Used to prevent adding\n * an archive to itself recursively.\n */\nint\narchive_write_set_skip_file(struct archive *_a, int64_t d, int64_t i)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_set_skip_file\");\n\ta->skip_file_set = 1;\n\ta->skip_file_dev = d;\n\ta->skip_file_ino = i;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Allocate and return the next filter structure.\n */\nstruct archive_write_filter *\n__archive_write_allocate_filter(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *f;\n\n\tf = calloc(1, sizeof(*f));\n\tf->archive = _a;\n\tif (a->filter_first == NULL)\n\t\ta->filter_first = f;\n\telse\n\t\ta->filter_last->next_filter = f;\n\ta->filter_last = f;\n\treturn f;\n}\n\n/*\n * Write data to a particular filter.\n */\nint\n__archive_write_filter(struct archive_write_filter *f,\n    const void *buff, size_t length)\n{\n\tint r;\n\tif (length == 0)\n\t\treturn(ARCHIVE_OK);\n\tif (f->write == NULL)\n\t\t/* If unset, a fatal error has already ocuured, so this filter\n\t\t * didn't open. We cannot write anything. */\n\t\treturn(ARCHIVE_FATAL);\n\tr = (f->write)(f, buff, length);\n\tf->bytes_written += length;\n\treturn (r);\n}\n\n/*\n * Open a filter.\n */\nint\n__archive_write_open_filter(struct archive_write_filter *f)\n{\n\tif (f->open == NULL)\n\t\treturn (ARCHIVE_OK);\n\treturn (f->open)(f);\n}\n\n/*\n * Close a filter.\n */\nint\n__archive_write_close_filter(struct archive_write_filter *f)\n{\n\tif (f->close != NULL)\n\t\treturn (f->close)(f);\n\tif (f->next_filter != NULL)\n\t\treturn (__archive_write_close_filter(f->next_filter));\n\treturn (ARCHIVE_OK);\n}\n\nint\n__archive_write_output(struct archive_write *a, const void *buff, size_t length)\n{\n\treturn (__archive_write_filter(a->filter_first, buff, length));\n}\n\nint\n__archive_write_nulls(struct archive_write *a, size_t length)\n{\n\tif (length == 0)\n\t\treturn (ARCHIVE_OK);\n\n\twhile (length > 0) {\n\t\tsize_t to_write = length < a->null_length ? length : a->null_length;\n\t\tint r = __archive_write_output(a, a->nulls, to_write);\n\t\tif (r < ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tlength -= to_write;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_write_client_open(struct archive_write_filter *f)\n{\n\tstruct archive_write *a = (struct archive_write *)f->archive;\n\tstruct archive_none *state;\n\tvoid *buffer;\n\tsize_t buffer_size;\n\n\tf->bytes_per_block = archive_write_get_bytes_per_block(f->archive);\n\tf->bytes_in_last_block =\n\t    archive_write_get_bytes_in_last_block(f->archive);\n\tbuffer_size = f->bytes_per_block;\n\n\tstate = (struct archive_none *)calloc(1, sizeof(*state));\n\tbuffer = (char *)malloc(buffer_size);\n\tif (state == NULL || buffer == NULL) {\n\t\tfree(state);\n\t\tfree(buffer);\n\t\tarchive_set_error(f->archive, ENOMEM,\n\t\t    \"Can't allocate data for output buffering\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tstate->buffer_size = buffer_size;\n\tstate->buffer = buffer;\n\tstate->next = state->buffer;\n\tstate->avail = state->buffer_size;\n\tf->data = state;\n\n\tif (a->client_opener == NULL)\n\t\treturn (ARCHIVE_OK);\n\treturn (a->client_opener(f->archive, a->client_data));\n}\n\nstatic int\narchive_write_client_write(struct archive_write_filter *f,\n    const void *_buff, size_t length)\n{\n\tstruct archive_write *a = (struct archive_write *)f->archive;\n        struct archive_none *state = (struct archive_none *)f->data;\n\tconst char *buff = (const char *)_buff;\n\tssize_t remaining, to_copy;\n\tssize_t bytes_written;\n\n\tremaining = length;\n\n\t/*\n\t * If there is no buffer for blocking, just pass the data\n\t * straight through to the client write callback.  In\n\t * particular, this supports \"no write delay\" operation for\n\t * special applications.  Just set the block size to zero.\n\t */\n\tif (state->buffer_size == 0) {\n\t\twhile (remaining > 0) {\n\t\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t\t    a->client_data, buff, remaining);\n\t\t\tif (bytes_written <= 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tremaining -= bytes_written;\n\t\t\tbuff += bytes_written;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* If the copy buffer isn't empty, try to fill it. */\n\tif (state->avail < state->buffer_size) {\n\t\t/* If buffer is not empty... */\n\t\t/* ... copy data into buffer ... */\n\t\tto_copy = ((size_t)remaining > state->avail) ?\n\t\t\tstate->avail : (size_t)remaining;\n\t\tmemcpy(state->next, buff, to_copy);\n\t\tstate->next += to_copy;\n\t\tstate->avail -= to_copy;\n\t\tbuff += to_copy;\n\t\tremaining -= to_copy;\n\t\t/* ... if it's full, write it out. */\n\t\tif (state->avail == 0) {\n\t\t\tchar *p = state->buffer;\n\t\t\tsize_t to_write = state->buffer_size;\n\t\t\twhile (to_write > 0) {\n\t\t\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t\t\t    a->client_data, p, to_write);\n\t\t\t\tif (bytes_written <= 0)\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\tif ((size_t)bytes_written > to_write) {\n\t\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t\t    -1, \"write overrun\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tp += bytes_written;\n\t\t\t\tto_write -= bytes_written;\n\t\t\t}\n\t\t\tstate->next = state->buffer;\n\t\t\tstate->avail = state->buffer_size;\n\t\t}\n\t}\n\n\twhile ((size_t)remaining >= state->buffer_size) {\n\t\t/* Write out full blocks directly to client. */\n\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t    a->client_data, buff, state->buffer_size);\n\t\tif (bytes_written <= 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbuff += bytes_written;\n\t\tremaining -= bytes_written;\n\t}\n\n\tif (remaining > 0) {\n\t\t/* Copy last bit into copy buffer. */\n\t\tmemcpy(state->next, buff, remaining);\n\t\tstate->next += remaining;\n\t\tstate->avail -= remaining;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_write_client_close(struct archive_write_filter *f)\n{\n\tstruct archive_write *a = (struct archive_write *)f->archive;\n\tstruct archive_none *state = (struct archive_none *)f->data;\n\tssize_t block_length;\n\tssize_t target_block_length;\n\tssize_t bytes_written;\n\tint ret = ARCHIVE_OK;\n\n\t/* If there's pending data, pad and write the last block */\n\tif (state->next != state->buffer) {\n\t\tblock_length = state->buffer_size - state->avail;\n\n\t\t/* Tricky calculation to determine size of last block */\n\t\tif (a->bytes_in_last_block <= 0)\n\t\t\t/* Default or Zero: pad to full block */\n\t\t\ttarget_block_length = a->bytes_per_block;\n\t\telse\n\t\t\t/* Round to next multiple of bytes_in_last_block. */\n\t\t\ttarget_block_length = a->bytes_in_last_block *\n\t\t\t    ( (block_length + a->bytes_in_last_block - 1) /\n\t\t\t        a->bytes_in_last_block);\n\t\tif (target_block_length > a->bytes_per_block)\n\t\t\ttarget_block_length = a->bytes_per_block;\n\t\tif (block_length < target_block_length) {\n\t\t\tmemset(state->next, 0,\n\t\t\t    target_block_length - block_length);\n\t\t\tblock_length = target_block_length;\n\t\t}\n\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t    a->client_data, state->buffer, block_length);\n\t\tret = bytes_written <= 0 ? ARCHIVE_FATAL : ARCHIVE_OK;\n\t}\n\tif (a->client_closer)\n\t\t(*a->client_closer)(&a->archive, a->client_data);\n\tfree(state->buffer);\n\tfree(state);\n\t/* Clear the close handler myself not to be called again. */\n\tf->close = NULL;\n\ta->client_data = NULL;\n\treturn (ret);\n}\n\n/*\n * Open the archive using the current settings.\n */\nint\narchive_write_open(struct archive *_a, void *client_data,\n    archive_open_callback *opener, archive_write_callback *writer,\n    archive_close_callback *closer)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *client_filter;\n\tint ret, r1;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_open\");\n\tarchive_clear_error(&a->archive);\n\n\ta->client_writer = writer;\n\ta->client_opener = opener;\n\ta->client_closer = closer;\n\ta->client_data = client_data;\n\n\tclient_filter = __archive_write_allocate_filter(_a);\n\tclient_filter->open = archive_write_client_open;\n\tclient_filter->write = archive_write_client_write;\n\tclient_filter->close = archive_write_client_close;\n\n\tret = __archive_write_open_filter(a->filter_first);\n\tif (ret < ARCHIVE_WARN) {\n\t\tr1 = __archive_write_close_filter(a->filter_first);\n\t\treturn (r1 < ret ? r1 : ret);\n\t}\n\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\tif (a->format_init)\n\t\tret = (a->format_init)(a);\n\treturn (ret);\n}\n\n/*\n * Close out the archive.\n */\nstatic int\n_archive_write_close(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r = ARCHIVE_OK, r1 = ARCHIVE_OK;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL,\n\t    \"archive_write_close\");\n\tif (a->archive.state == ARCHIVE_STATE_NEW\n\t    || a->archive.state == ARCHIVE_STATE_CLOSED)\n\t\treturn (ARCHIVE_OK); /* Okay to close() when not open. */\n\n\tarchive_clear_error(&a->archive);\n\n\t/* Finish the last entry if a finish callback is specified */\n\tif (a->archive.state == ARCHIVE_STATE_DATA\n\t    && a->format_finish_entry != NULL)\n\t\tr = ((a->format_finish_entry)(a));\n\n\t/* Finish off the archive. */\n\t/* TODO: have format closers invoke compression close. */\n\tif (a->format_close != NULL) {\n\t\tr1 = (a->format_close)(a);\n\t\tif (r1 < r)\n\t\t\tr = r1;\n\t}\n\n\t/* Finish the compression and close the stream. */\n\tr1 = __archive_write_close_filter(a->filter_first);\n\tif (r1 < r)\n\t\tr = r1;\n\n\tif (a->archive.state != ARCHIVE_STATE_FATAL)\n\t\ta->archive.state = ARCHIVE_STATE_CLOSED;\n\treturn (r);\n}\n\nstatic int\n_archive_write_filter_count(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *p = a->filter_first;\n\tint count = 0;\n\twhile(p) {\n\t\tcount++;\n\t\tp = p->next_filter;\n\t}\n\treturn count;\n}\n\nvoid\n__archive_write_filters_free(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r = ARCHIVE_OK, r1;\n\n\twhile (a->filter_first != NULL) {\n\t\tstruct archive_write_filter *next\n\t\t    = a->filter_first->next_filter;\n\t\tif (a->filter_first->free != NULL) {\n\t\t\tr1 = (*a->filter_first->free)(a->filter_first);\n\t\t\tif (r > r1)\n\t\t\t\tr = r1;\n\t\t}\n\t\tfree(a->filter_first);\n\t\ta->filter_first = next;\n\t}\n\ta->filter_last = NULL;\n}\n\n/*\n * Destroy the archive structure.\n *\n * Be careful: user might just call write_new and then write_free.\n * Don't assume we actually wrote anything or performed any non-trivial\n * initialization.\n */\nstatic int\n_archive_write_free(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r = ARCHIVE_OK, r1;\n\n\tif (_a == NULL)\n\t\treturn (ARCHIVE_OK);\n\t/* It is okay to call free() in state FATAL. */\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_write_free\");\n\tif (a->archive.state != ARCHIVE_STATE_FATAL)\n\t\tr = archive_write_close(&a->archive);\n\n\t/* Release format resources. */\n\tif (a->format_free != NULL) {\n\t\tr1 = (a->format_free)(a);\n\t\tif (r1 < r)\n\t\t\tr = r1;\n\t}\n\n\t__archive_write_filters_free(_a);\n\n\t/* Release various dynamic buffers. */\n\tfree((void *)(uintptr_t)(const void *)a->nulls);\n\tarchive_string_free(&a->archive.error_string);\n\ta->archive.magic = 0;\n\t__archive_clean(&a->archive);\n\tfree(a);\n\treturn (r);\n}\n\n/*\n * Write the appropriate header.\n */\nstatic int\n_archive_write_header(struct archive *_a, struct archive_entry *entry)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint ret, r2;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA | ARCHIVE_STATE_HEADER, \"archive_write_header\");\n\tarchive_clear_error(&a->archive);\n\n\tif (a->format_write_header == NULL) {\n\t\tarchive_set_error(&(a->archive), -1,\n\t\t    \"Format must be set before you can write to an archive.\");\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* In particular, \"retry\" and \"fatal\" get returned immediately. */\n\tret = archive_write_finish_entry(&a->archive);\n\tif (ret == ARCHIVE_FATAL) {\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (ret < ARCHIVE_OK && ret != ARCHIVE_WARN)\n\t\treturn (ret);\n\n\tif (a->skip_file_set &&\n\t    archive_entry_dev_is_set(entry) &&\n\t    archive_entry_ino_is_set(entry) &&\n\t    archive_entry_dev(entry) == (dev_t)a->skip_file_dev &&\n\t    archive_entry_ino64(entry) == a->skip_file_ino) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Can't add archive to itself\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/* Format and write header. */\n\tr2 = ((a->format_write_header)(a, entry));\n\tif (r2 == ARCHIVE_FATAL) {\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (r2 < ret)\n\t\tret = r2;\n\n\ta->archive.state = ARCHIVE_STATE_DATA;\n\treturn (ret);\n}\n\nstatic int\n_archive_write_finish_entry(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint ret = ARCHIVE_OK;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_finish_entry\");\n\tif (a->archive.state & ARCHIVE_STATE_DATA\n\t    && a->format_finish_entry != NULL)\n\t\tret = (a->format_finish_entry)(a);\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\treturn (ret);\n}\n\n/*\n * Note that the compressor is responsible for blocking.\n */\nstatic ssize_t\n_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}\n\nstatic struct archive_write_filter *\nfilter_lookup(struct archive *_a, int n)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *f = a->filter_first;\n\tif (n == -1)\n\t\treturn a->filter_last;\n\tif (n < 0)\n\t\treturn NULL;\n\twhile (n > 0 && f != NULL) {\n\t\tf = f->next_filter;\n\t\t--n;\n\t}\n\treturn f;\n}\n\nstatic int\n_archive_filter_code(struct archive *_a, int n)\n{\n\tstruct archive_write_filter *f = filter_lookup(_a, n);\n\treturn f == NULL ? -1 : f->code;\n}\n\nstatic const char *\n_archive_filter_name(struct archive *_a, int n)\n{\n\tstruct archive_write_filter *f = filter_lookup(_a, n);\n\treturn f == NULL ? NULL : f->name;\n}\n\nstatic int64_t\n_archive_filter_bytes(struct archive *_a, int n)\n{\n\tstruct archive_write_filter *f = filter_lookup(_a, n);\n\treturn f == NULL ? -1 : f->bytes_written;\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2003-2010 Tim Kientzle\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD: head/lib/libarchive/archive_write.c 201099 2009-12-28 03:03:00Z kientzle $\");\n\n/*\n * This file contains the \"essential\" portions of the write API, that\n * is, stuff that will essentially always be used by any client that\n * actually needs to write an archive.  Optional pieces have been, as\n * far as possible, separated out into separate files to reduce\n * needlessly bloating statically-linked clients.\n */\n\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#include <time.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_write_private.h\"\n\nstatic struct archive_vtable *archive_write_vtable(void);\n\nstatic int\t_archive_filter_code(struct archive *, int);\nstatic const char *_archive_filter_name(struct archive *, int);\nstatic int64_t\t_archive_filter_bytes(struct archive *, int);\nstatic int  _archive_write_filter_count(struct archive *);\nstatic int\t_archive_write_close(struct archive *);\nstatic int\t_archive_write_free(struct archive *);\nstatic int\t_archive_write_header(struct archive *, struct archive_entry *);\nstatic int\t_archive_write_finish_entry(struct archive *);\nstatic ssize_t\t_archive_write_data(struct archive *, const void *, size_t);\n\nstruct archive_none {\n\tsize_t buffer_size;\n\tsize_t avail;\n\tchar *buffer;\n\tchar *next;\n};\n\nstatic struct archive_vtable *\narchive_write_vtable(void)\n{\n\tstatic struct archive_vtable av;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tav.archive_close = _archive_write_close;\n\t\tav.archive_filter_bytes = _archive_filter_bytes;\n\t\tav.archive_filter_code = _archive_filter_code;\n\t\tav.archive_filter_name = _archive_filter_name;\n\t\tav.archive_filter_count = _archive_write_filter_count;\n\t\tav.archive_free = _archive_write_free;\n\t\tav.archive_write_header = _archive_write_header;\n\t\tav.archive_write_finish_entry = _archive_write_finish_entry;\n\t\tav.archive_write_data = _archive_write_data;\n\t\tinited = 1;\n\t}\n\treturn (&av);\n}\n\n/*\n * Allocate, initialize and return an archive object.\n */\nstruct archive *\narchive_write_new(void)\n{\n\tstruct archive_write *a;\n\tunsigned char *nulls;\n\n\ta = (struct archive_write *)malloc(sizeof(*a));\n\tif (a == NULL)\n\t\treturn (NULL);\n\tmemset(a, 0, sizeof(*a));\n\ta->archive.magic = ARCHIVE_WRITE_MAGIC;\n\ta->archive.state = ARCHIVE_STATE_NEW;\n\ta->archive.vtable = archive_write_vtable();\n\t/*\n\t * The value 10240 here matches the traditional tar default,\n\t * but is otherwise arbitrary.\n\t * TODO: Set the default block size from the format selected.\n\t */\n\ta->bytes_per_block = 10240;\n\ta->bytes_in_last_block = -1;\t/* Default */\n\n\t/* Initialize a block of nulls for padding purposes. */\n\ta->null_length = 1024;\n\tnulls = (unsigned char *)malloc(a->null_length);\n\tif (nulls == NULL) {\n\t\tfree(a);\n\t\treturn (NULL);\n\t}\n\tmemset(nulls, 0, a->null_length);\n\ta->nulls = nulls;\n\treturn (&a->archive);\n}\n\n/*\n * Set the block size.  Returns 0 if successful.\n */\nint\narchive_write_set_bytes_per_block(struct archive *_a, int bytes_per_block)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_set_bytes_per_block\");\n\ta->bytes_per_block = bytes_per_block;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Get the current block size.  -1 if it has never been set.\n */\nint\narchive_write_get_bytes_per_block(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_per_block\");\n\treturn (a->bytes_per_block);\n}\n\n/*\n * Set the size for the last block.\n * Returns 0 if successful.\n */\nint\narchive_write_set_bytes_in_last_block(struct archive *_a, int bytes)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_set_bytes_in_last_block\");\n\ta->bytes_in_last_block = bytes;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Return the value set above.  -1 indicates it has not been set.\n */\nint\narchive_write_get_bytes_in_last_block(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_get_bytes_in_last_block\");\n\treturn (a->bytes_in_last_block);\n}\n\n/*\n * dev/ino of a file to be rejected.  Used to prevent adding\n * an archive to itself recursively.\n */\nint\narchive_write_set_skip_file(struct archive *_a, int64_t d, int64_t i)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_set_skip_file\");\n\ta->skip_file_set = 1;\n\ta->skip_file_dev = d;\n\ta->skip_file_ino = i;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Allocate and return the next filter structure.\n */\nstruct archive_write_filter *\n__archive_write_allocate_filter(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *f;\n\n\tf = calloc(1, sizeof(*f));\n\tf->archive = _a;\n\tif (a->filter_first == NULL)\n\t\ta->filter_first = f;\n\telse\n\t\ta->filter_last->next_filter = f;\n\ta->filter_last = f;\n\treturn f;\n}\n\n/*\n * Write data to a particular filter.\n */\nint\n__archive_write_filter(struct archive_write_filter *f,\n    const void *buff, size_t length)\n{\n\tint r;\n\tif (length == 0)\n\t\treturn(ARCHIVE_OK);\n\tif (f->write == NULL)\n\t\t/* If unset, a fatal error has already ocuured, so this filter\n\t\t * didn't open. We cannot write anything. */\n\t\treturn(ARCHIVE_FATAL);\n\tr = (f->write)(f, buff, length);\n\tf->bytes_written += length;\n\treturn (r);\n}\n\n/*\n * Open a filter.\n */\nint\n__archive_write_open_filter(struct archive_write_filter *f)\n{\n\tif (f->open == NULL)\n\t\treturn (ARCHIVE_OK);\n\treturn (f->open)(f);\n}\n\n/*\n * Close a filter.\n */\nint\n__archive_write_close_filter(struct archive_write_filter *f)\n{\n\tif (f->close != NULL)\n\t\treturn (f->close)(f);\n\tif (f->next_filter != NULL)\n\t\treturn (__archive_write_close_filter(f->next_filter));\n\treturn (ARCHIVE_OK);\n}\n\nint\n__archive_write_output(struct archive_write *a, const void *buff, size_t length)\n{\n\treturn (__archive_write_filter(a->filter_first, buff, length));\n}\n\nint\n__archive_write_nulls(struct archive_write *a, size_t length)\n{\n\tif (length == 0)\n\t\treturn (ARCHIVE_OK);\n\n\twhile (length > 0) {\n\t\tsize_t to_write = length < a->null_length ? length : a->null_length;\n\t\tint r = __archive_write_output(a, a->nulls, to_write);\n\t\tif (r < ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tlength -= to_write;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_write_client_open(struct archive_write_filter *f)\n{\n\tstruct archive_write *a = (struct archive_write *)f->archive;\n\tstruct archive_none *state;\n\tvoid *buffer;\n\tsize_t buffer_size;\n\n\tf->bytes_per_block = archive_write_get_bytes_per_block(f->archive);\n\tf->bytes_in_last_block =\n\t    archive_write_get_bytes_in_last_block(f->archive);\n\tbuffer_size = f->bytes_per_block;\n\n\tstate = (struct archive_none *)calloc(1, sizeof(*state));\n\tbuffer = (char *)malloc(buffer_size);\n\tif (state == NULL || buffer == NULL) {\n\t\tfree(state);\n\t\tfree(buffer);\n\t\tarchive_set_error(f->archive, ENOMEM,\n\t\t    \"Can't allocate data for output buffering\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tstate->buffer_size = buffer_size;\n\tstate->buffer = buffer;\n\tstate->next = state->buffer;\n\tstate->avail = state->buffer_size;\n\tf->data = state;\n\n\tif (a->client_opener == NULL)\n\t\treturn (ARCHIVE_OK);\n\treturn (a->client_opener(f->archive, a->client_data));\n}\n\nstatic int\narchive_write_client_write(struct archive_write_filter *f,\n    const void *_buff, size_t length)\n{\n\tstruct archive_write *a = (struct archive_write *)f->archive;\n        struct archive_none *state = (struct archive_none *)f->data;\n\tconst char *buff = (const char *)_buff;\n\tssize_t remaining, to_copy;\n\tssize_t bytes_written;\n\n\tremaining = length;\n\n\t/*\n\t * If there is no buffer for blocking, just pass the data\n\t * straight through to the client write callback.  In\n\t * particular, this supports \"no write delay\" operation for\n\t * special applications.  Just set the block size to zero.\n\t */\n\tif (state->buffer_size == 0) {\n\t\twhile (remaining > 0) {\n\t\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t\t    a->client_data, buff, remaining);\n\t\t\tif (bytes_written <= 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tremaining -= bytes_written;\n\t\t\tbuff += bytes_written;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/* If the copy buffer isn't empty, try to fill it. */\n\tif (state->avail < state->buffer_size) {\n\t\t/* If buffer is not empty... */\n\t\t/* ... copy data into buffer ... */\n\t\tto_copy = ((size_t)remaining > state->avail) ?\n\t\t\tstate->avail : (size_t)remaining;\n\t\tmemcpy(state->next, buff, to_copy);\n\t\tstate->next += to_copy;\n\t\tstate->avail -= to_copy;\n\t\tbuff += to_copy;\n\t\tremaining -= to_copy;\n\t\t/* ... if it's full, write it out. */\n\t\tif (state->avail == 0) {\n\t\t\tchar *p = state->buffer;\n\t\t\tsize_t to_write = state->buffer_size;\n\t\t\twhile (to_write > 0) {\n\t\t\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t\t\t    a->client_data, p, to_write);\n\t\t\t\tif (bytes_written <= 0)\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\tif ((size_t)bytes_written > to_write) {\n\t\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t\t    -1, \"write overrun\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tp += bytes_written;\n\t\t\t\tto_write -= bytes_written;\n\t\t\t}\n\t\t\tstate->next = state->buffer;\n\t\t\tstate->avail = state->buffer_size;\n\t\t}\n\t}\n\n\twhile ((size_t)remaining >= state->buffer_size) {\n\t\t/* Write out full blocks directly to client. */\n\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t    a->client_data, buff, state->buffer_size);\n\t\tif (bytes_written <= 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbuff += bytes_written;\n\t\tremaining -= bytes_written;\n\t}\n\n\tif (remaining > 0) {\n\t\t/* Copy last bit into copy buffer. */\n\t\tmemcpy(state->next, buff, remaining);\n\t\tstate->next += remaining;\n\t\tstate->avail -= remaining;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_write_client_close(struct archive_write_filter *f)\n{\n\tstruct archive_write *a = (struct archive_write *)f->archive;\n\tstruct archive_none *state = (struct archive_none *)f->data;\n\tssize_t block_length;\n\tssize_t target_block_length;\n\tssize_t bytes_written;\n\tint ret = ARCHIVE_OK;\n\n\t/* If there's pending data, pad and write the last block */\n\tif (state->next != state->buffer) {\n\t\tblock_length = state->buffer_size - state->avail;\n\n\t\t/* Tricky calculation to determine size of last block */\n\t\tif (a->bytes_in_last_block <= 0)\n\t\t\t/* Default or Zero: pad to full block */\n\t\t\ttarget_block_length = a->bytes_per_block;\n\t\telse\n\t\t\t/* Round to next multiple of bytes_in_last_block. */\n\t\t\ttarget_block_length = a->bytes_in_last_block *\n\t\t\t    ( (block_length + a->bytes_in_last_block - 1) /\n\t\t\t        a->bytes_in_last_block);\n\t\tif (target_block_length > a->bytes_per_block)\n\t\t\ttarget_block_length = a->bytes_per_block;\n\t\tif (block_length < target_block_length) {\n\t\t\tmemset(state->next, 0,\n\t\t\t    target_block_length - block_length);\n\t\t\tblock_length = target_block_length;\n\t\t}\n\t\tbytes_written = (a->client_writer)(&a->archive,\n\t\t    a->client_data, state->buffer, block_length);\n\t\tret = bytes_written <= 0 ? ARCHIVE_FATAL : ARCHIVE_OK;\n\t}\n\tif (a->client_closer)\n\t\t(*a->client_closer)(&a->archive, a->client_data);\n\tfree(state->buffer);\n\tfree(state);\n\t/* Clear the close handler myself not to be called again. */\n\tf->close = NULL;\n\ta->client_data = NULL;\n\treturn (ret);\n}\n\n/*\n * Open the archive using the current settings.\n */\nint\narchive_write_open(struct archive *_a, void *client_data,\n    archive_open_callback *opener, archive_write_callback *writer,\n    archive_close_callback *closer)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *client_filter;\n\tint ret, r1;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_write_open\");\n\tarchive_clear_error(&a->archive);\n\n\ta->client_writer = writer;\n\ta->client_opener = opener;\n\ta->client_closer = closer;\n\ta->client_data = client_data;\n\n\tclient_filter = __archive_write_allocate_filter(_a);\n\tclient_filter->open = archive_write_client_open;\n\tclient_filter->write = archive_write_client_write;\n\tclient_filter->close = archive_write_client_close;\n\n\tret = __archive_write_open_filter(a->filter_first);\n\tif (ret < ARCHIVE_WARN) {\n\t\tr1 = __archive_write_close_filter(a->filter_first);\n\t\treturn (r1 < ret ? r1 : ret);\n\t}\n\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\tif (a->format_init)\n\t\tret = (a->format_init)(a);\n\treturn (ret);\n}\n\n/*\n * Close out the archive.\n */\nstatic int\n_archive_write_close(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r = ARCHIVE_OK, r1 = ARCHIVE_OK;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL,\n\t    \"archive_write_close\");\n\tif (a->archive.state == ARCHIVE_STATE_NEW\n\t    || a->archive.state == ARCHIVE_STATE_CLOSED)\n\t\treturn (ARCHIVE_OK); /* Okay to close() when not open. */\n\n\tarchive_clear_error(&a->archive);\n\n\t/* Finish the last entry if a finish callback is specified */\n\tif (a->archive.state == ARCHIVE_STATE_DATA\n\t    && a->format_finish_entry != NULL)\n\t\tr = ((a->format_finish_entry)(a));\n\n\t/* Finish off the archive. */\n\t/* TODO: have format closers invoke compression close. */\n\tif (a->format_close != NULL) {\n\t\tr1 = (a->format_close)(a);\n\t\tif (r1 < r)\n\t\t\tr = r1;\n\t}\n\n\t/* Finish the compression and close the stream. */\n\tr1 = __archive_write_close_filter(a->filter_first);\n\tif (r1 < r)\n\t\tr = r1;\n\n\tif (a->archive.state != ARCHIVE_STATE_FATAL)\n\t\ta->archive.state = ARCHIVE_STATE_CLOSED;\n\treturn (r);\n}\n\nstatic int\n_archive_write_filter_count(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *p = a->filter_first;\n\tint count = 0;\n\twhile(p) {\n\t\tcount++;\n\t\tp = p->next_filter;\n\t}\n\treturn count;\n}\n\nvoid\n__archive_write_filters_free(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r = ARCHIVE_OK, r1;\n\n\twhile (a->filter_first != NULL) {\n\t\tstruct archive_write_filter *next\n\t\t    = a->filter_first->next_filter;\n\t\tif (a->filter_first->free != NULL) {\n\t\t\tr1 = (*a->filter_first->free)(a->filter_first);\n\t\t\tif (r > r1)\n\t\t\t\tr = r1;\n\t\t}\n\t\tfree(a->filter_first);\n\t\ta->filter_first = next;\n\t}\n\ta->filter_last = NULL;\n}\n\n/*\n * Destroy the archive structure.\n *\n * Be careful: user might just call write_new and then write_free.\n * Don't assume we actually wrote anything or performed any non-trivial\n * initialization.\n */\nstatic int\n_archive_write_free(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint r = ARCHIVE_OK, r1;\n\n\tif (_a == NULL)\n\t\treturn (ARCHIVE_OK);\n\t/* It is okay to call free() in state FATAL. */\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_write_free\");\n\tif (a->archive.state != ARCHIVE_STATE_FATAL)\n\t\tr = archive_write_close(&a->archive);\n\n\t/* Release format resources. */\n\tif (a->format_free != NULL) {\n\t\tr1 = (a->format_free)(a);\n\t\tif (r1 < r)\n\t\t\tr = r1;\n\t}\n\n\t__archive_write_filters_free(_a);\n\n\t/* Release various dynamic buffers. */\n\tfree((void *)(uintptr_t)(const void *)a->nulls);\n\tarchive_string_free(&a->archive.error_string);\n\ta->archive.magic = 0;\n\t__archive_clean(&a->archive);\n\tfree(a);\n\treturn (r);\n}\n\n/*\n * Write the appropriate header.\n */\nstatic int\n_archive_write_header(struct archive *_a, struct archive_entry *entry)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint ret, r2;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA | ARCHIVE_STATE_HEADER, \"archive_write_header\");\n\tarchive_clear_error(&a->archive);\n\n\tif (a->format_write_header == NULL) {\n\t\tarchive_set_error(&(a->archive), -1,\n\t\t    \"Format must be set before you can write to an archive.\");\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* In particular, \"retry\" and \"fatal\" get returned immediately. */\n\tret = archive_write_finish_entry(&a->archive);\n\tif (ret == ARCHIVE_FATAL) {\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (ret < ARCHIVE_OK && ret != ARCHIVE_WARN)\n\t\treturn (ret);\n\n\tif (a->skip_file_set &&\n\t    archive_entry_dev_is_set(entry) &&\n\t    archive_entry_ino_is_set(entry) &&\n\t    archive_entry_dev(entry) == (dev_t)a->skip_file_dev &&\n\t    archive_entry_ino64(entry) == a->skip_file_ino) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Can't add archive to itself\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\t/* Format and write header. */\n\tr2 = ((a->format_write_header)(a, entry));\n\tif (r2 == ARCHIVE_FATAL) {\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (r2 < ret)\n\t\tret = r2;\n\n\ta->archive.state = ARCHIVE_STATE_DATA;\n\treturn (ret);\n}\n\nstatic int\n_archive_write_finish_entry(struct archive *_a)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tint ret = ARCHIVE_OK;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_finish_entry\");\n\tif (a->archive.state & ARCHIVE_STATE_DATA\n\t    && a->format_finish_entry != NULL)\n\t\tret = (a->format_finish_entry)(a);\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\treturn (ret);\n}\n\n/*\n * Note that the compressor is responsible for blocking.\n */\nstatic ssize_t\n_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\t/* In particular, this catches attempts to pass negative values. */\n\tif (s > max_write)\n\t\ts = max_write;\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}\n\nstatic struct archive_write_filter *\nfilter_lookup(struct archive *_a, int n)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tstruct archive_write_filter *f = a->filter_first;\n\tif (n == -1)\n\t\treturn a->filter_last;\n\tif (n < 0)\n\t\treturn NULL;\n\twhile (n > 0 && f != NULL) {\n\t\tf = f->next_filter;\n\t\t--n;\n\t}\n\treturn f;\n}\n\nstatic int\n_archive_filter_code(struct archive *_a, int n)\n{\n\tstruct archive_write_filter *f = filter_lookup(_a, n);\n\treturn f == NULL ? -1 : f->code;\n}\n\nstatic const char *\n_archive_filter_name(struct archive *_a, int n)\n{\n\tstruct archive_write_filter *f = filter_lookup(_a, n);\n\treturn f == NULL ? NULL : f->name;\n}\n\nstatic int64_t\n_archive_filter_bytes(struct archive *_a, int n)\n{\n\tstruct archive_write_filter *f = filter_lookup(_a, n);\n\treturn f == NULL ? -1 : f->bytes_written;\n}\n"], "filenames": ["libarchive/archive_write.c"], "buggy_code_start_loc": [675], "buggy_code_end_loc": [677], "fixing_code_start_loc": [676], "fixing_code_end_loc": [683], "type": "CWE-189", "message": "Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.", "other": {"cve": {"id": "CVE-2013-0211", "sourceIdentifier": "secalert@redhat.com", "published": "2013-09-30T22:55:04.557", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow."}, {"lang": "es", "value": "Error de signo de enteros en la funci\u00f3n archive_write_zip_data de archive_write_set_format_zip.c en la versi\u00f3n 3.1.2 y anteriores, cuando se ejecuta en equipos de 64 bits, permite a atacantes dependientes del contexto causar una denegaci\u00f3n del servicio (ca\u00edda) a trav\u00e9s de vectores sin especificar, que desencadena en una conversi\u00f3n incorrecta entre tipos con signo y sin signo, dando lugar a un desbordamiento de b\u00fafer."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:x64:*:*", "versionEndIncluding": "3.1.2", "matchCriteriaId": "58595970-A83C-4FD0-B505-837B653ADF31"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:17:*:*:*:*:*:*:*", "matchCriteriaId": "2DA9D861-3EAF-42F5-B0B6-A4CD7BDD6188"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:freebsd:freebsd:9.3:*:*:*:*:*:*:*", "matchCriteriaId": "57052F01-8695-4C63-A947-7671375B9312"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/101687.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/101700.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/101872.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/101876.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-03/msg00065.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:147", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/58926", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1035995", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2549-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=902998", "source": "secalert@redhat.com", "tags": ["Patch", "Issue Tracking"]}, {"url": "https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://www.freebsd.org/security/advisories/FreeBSD-SA-16:23.libarchive.asc", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4"}}