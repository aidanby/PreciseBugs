{"buggy_code": ["/*\n * IOCTL interface for SCLP\n *\n * Copyright IBM Corp. 2012\n *\n * Author: Michael Holzheu <holzheu@linux.vnet.ibm.com>\n */\n\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <asm/compat.h>\n#include <asm/sclp_ctl.h>\n#include <asm/sclp.h>\n\n#include \"sclp.h\"\n\n/*\n * Supported command words\n */\nstatic unsigned int sclp_ctl_sccb_wlist[] = {\n\t0x00400002,\n\t0x00410002,\n};\n\n/*\n * Check if command word is supported\n */\nstatic int sclp_ctl_cmdw_supported(unsigned int cmdw)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sclp_ctl_sccb_wlist); i++) {\n\t\tif (cmdw == sclp_ctl_sccb_wlist[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void __user *u64_to_uptr(u64 value)\n{\n\tif (is_compat_task())\n\t\treturn compat_ptr(value);\n\telse\n\t\treturn (void __user *)(unsigned long)value;\n}\n\n/*\n * Start SCLP request\n */\nstatic int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n\n/*\n * SCLP SCCB ioctl function\n */\nstatic long sclp_ctl_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tvoid __user *argp;\n\n\tif (is_compat_task())\n\t\targp = compat_ptr(arg);\n\telse\n\t\targp = (void __user *) arg;\n\tswitch (cmd) {\n\tcase SCLP_CTL_SCCB:\n\t\treturn sclp_ctl_ioctl_sccb(argp);\n\tdefault: /* unknown ioctl number */\n\t\treturn -ENOTTY;\n\t}\n}\n\n/*\n * File operations\n */\nstatic const struct file_operations sclp_ctl_fops = {\n\t.owner = THIS_MODULE,\n\t.open = nonseekable_open,\n\t.unlocked_ioctl = sclp_ctl_ioctl,\n\t.compat_ioctl = sclp_ctl_ioctl,\n\t.llseek = no_llseek,\n};\n\n/*\n * Misc device definition\n */\nstatic struct miscdevice sclp_ctl_device = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"sclp\",\n\t.fops = &sclp_ctl_fops,\n};\n\n/*\n * Register sclp_ctl misc device\n */\nstatic int __init sclp_ctl_init(void)\n{\n\treturn misc_register(&sclp_ctl_device);\n}\nmodule_init(sclp_ctl_init);\n\n/*\n * Deregister sclp_ctl misc device\n */\nstatic void __exit sclp_ctl_exit(void)\n{\n\tmisc_deregister(&sclp_ctl_device);\n}\nmodule_exit(sclp_ctl_exit);\n"], "fixing_code": ["/*\n * IOCTL interface for SCLP\n *\n * Copyright IBM Corp. 2012\n *\n * Author: Michael Holzheu <holzheu@linux.vnet.ibm.com>\n */\n\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <asm/compat.h>\n#include <asm/sclp_ctl.h>\n#include <asm/sclp.h>\n\n#include \"sclp.h\"\n\n/*\n * Supported command words\n */\nstatic unsigned int sclp_ctl_sccb_wlist[] = {\n\t0x00400002,\n\t0x00410002,\n};\n\n/*\n * Check if command word is supported\n */\nstatic int sclp_ctl_cmdw_supported(unsigned int cmdw)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sclp_ctl_sccb_wlist); i++) {\n\t\tif (cmdw == sclp_ctl_sccb_wlist[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void __user *u64_to_uptr(u64 value)\n{\n\tif (is_compat_task())\n\t\treturn compat_ptr(value);\n\telse\n\t\treturn (void __user *)(unsigned long)value;\n}\n\n/*\n * Start SCLP request\n */\nstatic int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tunsigned long copied;\n\tint rc;\n\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tcopied = PAGE_SIZE -\n\t\tcopy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), PAGE_SIZE);\n\tif (offsetof(struct sccb_header, length) +\n\t    sizeof(sccb->length) > copied || sccb->length > copied) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length < 8) {\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}\n\n/*\n * SCLP SCCB ioctl function\n */\nstatic long sclp_ctl_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tvoid __user *argp;\n\n\tif (is_compat_task())\n\t\targp = compat_ptr(arg);\n\telse\n\t\targp = (void __user *) arg;\n\tswitch (cmd) {\n\tcase SCLP_CTL_SCCB:\n\t\treturn sclp_ctl_ioctl_sccb(argp);\n\tdefault: /* unknown ioctl number */\n\t\treturn -ENOTTY;\n\t}\n}\n\n/*\n * File operations\n */\nstatic const struct file_operations sclp_ctl_fops = {\n\t.owner = THIS_MODULE,\n\t.open = nonseekable_open,\n\t.unlocked_ioctl = sclp_ctl_ioctl,\n\t.compat_ioctl = sclp_ctl_ioctl,\n\t.llseek = no_llseek,\n};\n\n/*\n * Misc device definition\n */\nstatic struct miscdevice sclp_ctl_device = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"sclp\",\n\t.fops = &sclp_ctl_fops,\n};\n\n/*\n * Register sclp_ctl misc device\n */\nstatic int __init sclp_ctl_init(void)\n{\n\treturn misc_register(&sclp_ctl_device);\n}\nmodule_init(sclp_ctl_init);\n\n/*\n * Deregister sclp_ctl misc device\n */\nstatic void __exit sclp_ctl_exit(void)\n{\n\tmisc_deregister(&sclp_ctl_device);\n}\nmodule_exit(sclp_ctl_exit);\n"], "filenames": ["drivers/s390/char/sclp_ctl.c"], "buggy_code_start_loc": [58], "buggy_code_end_loc": [76], "fixing_code_start_loc": [59], "fixing_code_end_loc": [78], "type": "CWE-362", "message": "Race condition in the sclp_ctl_ioctl_sccb function in drivers/s390/char/sclp_ctl.c in the Linux kernel before 4.6 allows local users to obtain sensitive information from kernel memory by changing a certain length value, aka a \"double fetch\" vulnerability.", "other": {"cve": {"id": "CVE-2016-6130", "sourceIdentifier": "cve@mitre.org", "published": "2016-07-03T21:59:18.040", "lastModified": "2016-11-28T20:30:33.697", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the sclp_ctl_ioctl_sccb function in drivers/s390/char/sclp_ctl.c in the Linux kernel before 4.6 allows local users to obtain sensitive information from kernel memory by changing a certain length value, aka a \"double fetch\" vulnerability."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n sclp_ctl_ioctl_sccb en drivers/s390/char/sclp_ctl.c en el kernel de Linux en versiones anteriores a 4.6 permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel cambiando un valor de longitud determinado, tambi\u00e9n conocida como una vulnerabilidad \"double fetch\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.5", "matchCriteriaId": "2870CD78-709E-4894-8CE7-147FD70F4070"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=532c34b5fbf1687df63b3fcd5b2846312ac943c6", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2016/dsa-3616", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/archive/1/538803/30/0/threaded", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/91540", "source": "cve@mitre.org"}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=116741", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/532c34b5fbf1687df63b3fcd5b2846312ac943c6", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/532c34b5fbf1687df63b3fcd5b2846312ac943c6"}}