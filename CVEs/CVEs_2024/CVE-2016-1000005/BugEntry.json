{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/ext/extension.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/ext/std/ext_std_math.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#define NON_FREE\n#define MCRYPT2\n#include <mcrypt.h>\n\nnamespace HPHP {\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct MCrypt : SweepableResourceData {\n  explicit MCrypt(MCRYPT td) : m_td(td), m_init(false) {}\n\n  ~MCrypt() {\n    MCrypt::close();\n  }\n\n  bool isInvalid() const override {\n    return m_td == MCRYPT_FAILED;\n  }\n\n  void close() {\n    if (m_td != MCRYPT_FAILED) {\n      mcrypt_generic_deinit(m_td);\n      mcrypt_module_close(m_td);\n      m_td = MCRYPT_FAILED;\n    }\n  }\n\n  CLASSNAME_IS(\"mcrypt\");\n  // overriding ResourceData\n  const String& o_getClassNameHook() const override { return classnameof(); }\n\n  DECLARE_RESOURCE_ALLOCATION(MCrypt)\n\npublic:\n  MCRYPT m_td;\n  bool m_init;\n};\n\nIMPLEMENT_RESOURCE_ALLOCATION(MCrypt)\n\ntypedef enum {\n  RANDOM = 0,\n  URANDOM,\n  RAND\n} iv_source;\n\nstruct mcrypt_data {\n  std::string algorithms_dir;\n  std::string modes_dir;\n};\nstatic mcrypt_data s_globals;\n#define MCG(n) (s_globals.n)\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n#define MCRYPT_OPEN_MODULE_FAILED(str) \\\n raise_warning(\"%s(): Module initialization failed\", str);\n\nstatic Variant php_mcrypt_do_crypt(const String& cipher, const String& key,\n                                   const String& data, const String& mode,\n                                   const String& iv, bool dencrypt,\n                                   char *name) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)mode.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(name);\n    return false;\n  }\n\n  /* Checking for key-length */\n  int max_key_length = mcrypt_enc_get_key_size(td);\n  if (key.size() > max_key_length) {\n    raise_warning(\"Size of key is too large for this algorithm\");\n  }\n  int count;\n  int *key_length_sizes = mcrypt_enc_get_supported_key_sizes(td, &count);\n  int use_key_length;\n  char *key_s = nullptr;\n  if (count == 0 && key_length_sizes == nullptr) { // all lengths 1 - k_l_s = OK\n    use_key_length = key.size();\n    key_s = (char*)malloc(use_key_length);\n    memcpy(key_s, key.data(), use_key_length);\n  } else if (count == 1) {  /* only m_k_l = OK */\n    key_s = (char*)malloc(key_length_sizes[0]);\n    memset(key_s, 0, key_length_sizes[0]);\n    memcpy(key_s, key.data(), MIN(key.size(), key_length_sizes[0]));\n    use_key_length = key_length_sizes[0];\n  } else { /* dertermine smallest supported key > length of requested key */\n    use_key_length = max_key_length; /* start with max key length */\n    for (int i = 0; i < count; i++) {\n      if (key_length_sizes[i] >= key.size() &&\n          key_length_sizes[i] < use_key_length) {\n        use_key_length = key_length_sizes[i];\n      }\n    }\n    key_s = (char*)malloc(use_key_length);\n    memset(key_s, 0, use_key_length);\n    memcpy(key_s, key.data(), MIN(key.size(), use_key_length));\n  }\n  mcrypt_free(key_length_sizes);\n\n  /* Check IV */\n  char *iv_s = nullptr;\n  int iv_size = mcrypt_enc_get_iv_size(td);\n\n  /* IV is required */\n  if (mcrypt_enc_mode_has_iv(td) == 1) {\n    if (!iv.empty()) {\n      if (iv_size != iv.size()) {\n        raise_warning(\"%s(): The IV parameter must be as long as \"\n                      \"the blocksize\", name);\n      } else {\n        iv_s = (char*)malloc(iv_size + 1);\n        memcpy(iv_s, iv.data(), iv_size);\n      }\n    } else {\n      raise_warning(\"%s(): The IV parameter must be as long as \"\n                    \"the blocksize\", name);\n      iv_s = (char*)malloc(iv_size + 1);\n      memset(iv_s, 0, iv_size + 1);\n    }\n  }\n\n  int block_size;\n  unsigned long int data_size;\n  String s;\n  char *data_s;\n  /* Check blocksize */\n  if (mcrypt_enc_is_block_mode(td) == 1) { /* It's a block algorithm */\n    block_size = mcrypt_enc_get_block_size(td);\n    data_size = (((data.size() - 1) / block_size) + 1) * block_size;\n    s = String(data_size, ReserveString);\n    data_s = (char*)s.mutableData();\n    memset(data_s, 0, data_size);\n    memcpy(data_s, data.data(), data.size());\n  } else { /* It's not a block algorithm */\n    data_size = data.size();\n    s = String(data_size, ReserveString);\n    data_s = (char*)s.mutableData();\n    memcpy(data_s, data.data(), data.size());\n  }\n\n  if (mcrypt_generic_init(td, key_s, use_key_length, iv_s) < 0) {\n    raise_warning(\"Mcrypt initialisation failed\");\n    return false;\n  }\n  if (dencrypt) {\n    mdecrypt_generic(td, data_s, data_size);\n  } else {\n    mcrypt_generic(td, data_s, data_size);\n  }\n\n  /* freeing vars */\n  mcrypt_generic_end(td);\n  if (key_s != nullptr) {\n    free(key_s);\n  }\n  if (iv_s != nullptr) {\n    free(iv_s);\n  }\n  s.setSize(data_size);\n  return s;\n}\n\nstatic req::ptr<MCrypt> get_valid_mcrypt_resource(const Resource& td) {\n  auto pm = dyn_cast_or_null<MCrypt>(td);\n\n  if (pm == nullptr || pm->isInvalid()) {\n    raise_warning(\"supplied argument is not a valid MCrypt resource\");\n    return nullptr;\n  }\n\n  return pm;\n}\n\nstatic Variant mcrypt_generic(const Resource& td, const String& data,\n                              bool dencrypt) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  } else if (!pm->m_init) {\n    raise_warning(\"Operation disallowed prior to mcrypt_generic_init().\");\n    return false;\n  }\n\n  if (data.empty()) {\n    raise_warning(\"An empty string was passed\");\n    return false;\n  }\n\n  String s;\n  unsigned char* data_s;\n  int block_size, data_size;\n  /* Check blocksize */\n  if (mcrypt_enc_is_block_mode(pm->m_td) == 1) { /* It's a block algorithm */\n    block_size = mcrypt_enc_get_block_size(pm->m_td);\n    data_size = (((data.size() - 1) / block_size) + 1) * block_size;\n    s = String(data_size, ReserveString);\n    data_s = (unsigned char *)s.mutableData();\n    memset(data_s, 0, data_size);\n    memcpy(data_s, data.data(), data.size());\n  } else { /* It's not a block algorithm */\n    data_size = data.size();\n    s = String(data_size, ReserveString);\n    data_s = (unsigned char *)s.mutableData();\n    memcpy(data_s, data.data(), data.size());\n  }\n\n  if (dencrypt) {\n    mdecrypt_generic(pm->m_td, data_s, data_size);\n  } else {\n    mcrypt_generic(pm->m_td, data_s, data_size);\n  }\n  s.setSize(data_size);\n  return s;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nVariant HHVM_FUNCTION(mcrypt_module_open, const String& algorithm,\n                                          const String& algorithm_directory,\n                             const String& mode, const String& mode_directory) {\n  MCRYPT td = mcrypt_module_open\n    ((char*)algorithm.data(),\n     (char*)(algorithm_directory.empty() ? MCG(algorithms_dir).data() :\n             algorithm_directory.data()),\n     (char*)mode.data(),\n     (char*)(mode_directory.empty() ? (char*)MCG(modes_dir).data() :\n             mode_directory.data()));\n\n  if (td == MCRYPT_FAILED) {\n    raise_warning(\"Could not open encryption module\");\n    return false;\n  }\n\n  return Variant(req::make<MCrypt>(td));\n}\n\nbool HHVM_FUNCTION(mcrypt_module_close, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  pm->close();\n  return true;\n}\n\nArray HHVM_FUNCTION(mcrypt_list_algorithms,\n                    const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n\n  int count = 0;\n  char **modules = mcrypt_list_algorithms((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No algorithms found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}\n\nArray HHVM_FUNCTION(mcrypt_list_modes,\n                    const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n\n  int count = 0;\n  char **modules = mcrypt_list_modes((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No modes found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}\n\nint64_t HHVM_FUNCTION(mcrypt_module_get_algo_block_size,\n                                   const String& algorithm,\n                                   const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_get_algo_block_size((char*)algorithm.data(),\n                                           (char*)dir.data());\n}\n\nint64_t HHVM_FUNCTION(mcrypt_module_get_algo_key_size, const String& algorithm,\n                                   const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_get_algo_key_size((char*)algorithm.data(),\n                                         (char*)dir.data());\n}\n\nArray HHVM_FUNCTION(mcrypt_module_get_supported_key_sizes,\n                    const String& algorithm,\n                    const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n\n  int count = 0;\n  int *key_sizes = mcrypt_module_get_algo_supported_key_sizes\n    ((char*)algorithm.data(), (char*)dir.data(), &count);\n\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(key_sizes[i]);\n  }\n  mcrypt_free(key_sizes);\n  return ret;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_is_block_algorithm_mode, const String& mode,\n                                  const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  return mcrypt_module_is_block_algorithm_mode((char*)mode.data(),\n                                               (char*)dir.data()) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_is_block_algorithm, const String& algorithm,\n                                  const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_is_block_algorithm((char*)algorithm.data(),\n                                          (char*)dir.data()) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_is_block_mode, const String& mode,\n                                   const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  return mcrypt_module_is_block_mode((char*)mode.data(),\n                                     (char*)dir.data()) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_self_test, const String& algorithm,\n                               const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_self_test((char*)algorithm.data(),\n                                 (char*)dir.data()) == 0;\n}\n\nVariant HHVM_FUNCTION(mcrypt_create_iv, int size, int source /* = 0 */) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      // Use userspace rand() function because it handles auto-seeding\n      iv[--size] = (char)HHVM_FN(rand)(0, 255);\n    }\n  }\n  return String(iv, n, AttachString);\n}\n\nVariant HHVM_FUNCTION(mcrypt_encrypt, const String& cipher, const String& key,\n                                      const String& data, const String& mode,\n                                      const Variant& viv /* = null_string */) {\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, mode, iv, false,\n                             \"mcrypt_encrypt\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_decrypt, const String& cipher, const String& key,\n                                      const String& data, const String& mode,\n                                      const Variant& viv /* = null_string */) {\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, mode, iv, true,\n                             \"mcrypt_decrypt\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_cbc, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_cbc() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"cbc\", iv, mode.toInt32(),\n                             \"mcrypt_cbc\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_cfb, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_cfb() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"cfb\", iv, mode.toInt32(),\n                             \"mcrypt_cfb\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_ecb, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_ecb() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"ecb\", iv, mode.toInt32(),\n                             \"mcrypt_ecb\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_ofb, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_ofb() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"ofb\", iv, mode.toInt32(),\n                             \"mcrypt_ofb\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module /* = null_string */) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_cipher_name, const String& cipher) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)\"ecb\",\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    td = mcrypt_module_open((char*)cipher.data(),\n                            (char*)MCG(algorithms_dir).data(),\n                            (char*)\"stream\",\n                            (char*)MCG(modes_dir).data());\n    if (td == MCRYPT_FAILED) {\n      MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_cipher_name\");\n      return false;\n    }\n  }\n\n  char *cipher_name = mcrypt_enc_get_algorithms_name(td);\n  mcrypt_module_close(td);\n  String ret(cipher_name, CopyString);\n  mcrypt_free(cipher_name);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_iv_size, const String& cipher,\n                                          const String& mode) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)mode.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_iv_size\");\n    return false;\n  }\n\n  int64_t ret = mcrypt_enc_get_iv_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_key_size, const String& cipher,\n                                           const String& module) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_key_size\");\n    return false;\n  }\n\n  int64_t ret = mcrypt_enc_get_key_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_algorithms_name, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  char *name = mcrypt_enc_get_algorithms_name(pm->m_td);\n  String ret(name, CopyString);\n  mcrypt_free(name);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_block_size, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_get_block_size(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_iv_size, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_get_iv_size(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_key_size, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_get_key_size(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_modes_name, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  char *name = mcrypt_enc_get_modes_name(pm->m_td);\n  String ret(name, CopyString);\n  mcrypt_free(name);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_supported_key_sizes, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int count = 0;\n  int *key_sizes =\n    mcrypt_enc_get_supported_key_sizes(pm->m_td, &count);\n\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(key_sizes[i]);\n  }\n  mcrypt_free(key_sizes);\n  return ret;\n}\n\nbool HHVM_FUNCTION(mcrypt_enc_is_block_algorithm_mode, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_is_block_algorithm_mode(pm->m_td) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_enc_is_block_algorithm, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_is_block_algorithm(pm->m_td) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_enc_is_block_mode, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_is_block_mode(pm->m_td) == 1;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_self_test, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_self_test(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n\nVariant HHVM_FUNCTION(mcrypt_generic, const Resource& td, const String& data) {\n  return mcrypt_generic(td, data, false);\n}\n\nVariant HHVM_FUNCTION(mdecrypt_generic, const Resource& td,\n                                        const String& data) {\n  return mcrypt_generic(td, data, true);\n}\n\nbool HHVM_FUNCTION(mcrypt_generic_deinit, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  if (mcrypt_generic_deinit(pm->m_td) < 0) {\n    raise_warning(\"Could not terminate encryption specifier\");\n    return false;\n  }\n  pm->m_init = false;\n  return true;\n}\n\nbool HHVM_FUNCTION(mcrypt_generic_end, const Resource& td) {\n  return HHVM_FUNCTION(mcrypt_generic_deinit, td);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct McryptExtension final : Extension {\n  McryptExtension() : Extension(\"mcrypt\") {}\n  void moduleInit() override {\n    HHVM_RC_STR(MCRYPT_3DES, \"tripledes\");\n    HHVM_RC_STR(MCRYPT_ARCFOUR, \"arcfour\");\n    HHVM_RC_STR(MCRYPT_ARCFOUR_IV, \"arcfour-iv\");\n    HHVM_RC_STR(MCRYPT_BLOWFISH, \"blowfish\");\n    HHVM_RC_STR(MCRYPT_BLOWFISH_COMPAT, \"blowfish-compat\");\n    HHVM_RC_STR(MCRYPT_CAST_128, \"cast-128\");\n    HHVM_RC_STR(MCRYPT_CAST_256, \"cast-256\");\n    HHVM_RC_STR(MCRYPT_CRYPT, \"crypt\");\n    HHVM_RC_INT(MCRYPT_DECRYPT, 1);\n    HHVM_RC_STR(MCRYPT_DES, \"des\");\n    HHVM_RC_INT(MCRYPT_DEV_RANDOM, RANDOM);\n    HHVM_RC_INT(MCRYPT_DEV_URANDOM, URANDOM);\n    HHVM_RC_INT(MCRYPT_ENCRYPT, 0);\n    HHVM_RC_STR(MCRYPT_ENIGNA, \"crypt\");\n    HHVM_RC_STR(MCRYPT_GOST, \"gost\");\n    HHVM_RC_STR(MCRYPT_IDEA, \"idea\");\n    HHVM_RC_STR(MCRYPT_LOKI97, \"loki97\");\n    HHVM_RC_STR(MCRYPT_MARS, \"mars\");\n    HHVM_RC_STR(MCRYPT_MODE_CBC, \"cbc\");\n    HHVM_RC_STR(MCRYPT_MODE_CFB, \"cfb\");\n    HHVM_RC_STR(MCRYPT_MODE_ECB, \"ecb\");\n    HHVM_RC_STR(MCRYPT_MODE_NOFB, \"nofb\");\n    HHVM_RC_STR(MCRYPT_MODE_OFB, \"ofb\");\n    HHVM_RC_STR(MCRYPT_MODE_STREAM, \"stream\");\n    HHVM_RC_STR(MCRYPT_PANAMA, \"panama\");\n    HHVM_RC_INT(MCRYPT_RAND, RAND);\n    HHVM_RC_STR(MCRYPT_RC2, \"rc2\");\n    HHVM_RC_STR(MCRYPT_RC6, \"rc6\");\n    HHVM_RC_STR(MCRYPT_RIJNDAEL_128, \"rijndael-128\");\n    HHVM_RC_STR(MCRYPT_RIJNDAEL_192, \"rijndael-192\");\n    HHVM_RC_STR(MCRYPT_RIJNDAEL_256, \"rijndael-256\");\n    HHVM_RC_STR(MCRYPT_SAFER128, \"safer-sk128\");\n    HHVM_RC_STR(MCRYPT_SAFER64, \"safer-sk64\");\n    HHVM_RC_STR(MCRYPT_SAFERPLUS, \"saferplus\");\n    HHVM_RC_STR(MCRYPT_SERPENT, \"serpent\");\n    HHVM_RC_STR(MCRYPT_SKIPJACK, \"skipjack\");\n    HHVM_RC_STR(MCRYPT_THREEWAY, \"threeway\");\n    HHVM_RC_STR(MCRYPT_TRIPLEDES, \"tripledes\");\n    HHVM_RC_STR(MCRYPT_TWOFISH, \"twofish\");\n    HHVM_RC_STR(MCRYPT_WAKE, \"wake\");\n    HHVM_RC_STR(MCRYPT_XTEA, \"xtea\");\n\n    HHVM_FE(mcrypt_module_open);\n    HHVM_FE(mcrypt_module_close);\n    HHVM_FE(mcrypt_list_algorithms);\n    HHVM_FE(mcrypt_list_modes);\n    HHVM_FE(mcrypt_module_get_algo_block_size);\n    HHVM_FE(mcrypt_module_get_algo_key_size);\n    HHVM_FE(mcrypt_module_get_supported_key_sizes);\n    HHVM_FE(mcrypt_module_is_block_algorithm_mode);\n    HHVM_FE(mcrypt_module_is_block_algorithm);\n    HHVM_FE(mcrypt_module_is_block_mode);\n    HHVM_FE(mcrypt_module_self_test);\n    HHVM_FE(mcrypt_create_iv);\n    HHVM_FE(mcrypt_encrypt);\n    HHVM_FE(mcrypt_decrypt);\n    HHVM_FE(mcrypt_cbc);\n    HHVM_FE(mcrypt_cfb);\n    HHVM_FE(mcrypt_ecb);\n    HHVM_FE(mcrypt_ofb);\n    HHVM_FE(mcrypt_get_block_size);\n    HHVM_FE(mcrypt_get_cipher_name);\n    HHVM_FE(mcrypt_get_iv_size);\n    HHVM_FE(mcrypt_get_key_size);\n    HHVM_FE(mcrypt_enc_get_algorithms_name);\n    HHVM_FE(mcrypt_enc_get_block_size);\n    HHVM_FE(mcrypt_enc_get_iv_size);\n    HHVM_FE(mcrypt_enc_get_key_size);\n    HHVM_FE(mcrypt_enc_get_modes_name);\n    HHVM_FE(mcrypt_enc_get_supported_key_sizes);\n    HHVM_FE(mcrypt_enc_is_block_algorithm_mode);\n    HHVM_FE(mcrypt_enc_is_block_algorithm);\n    HHVM_FE(mcrypt_enc_is_block_mode);\n    HHVM_FE(mcrypt_enc_self_test);\n    HHVM_FE(mcrypt_generic_init);\n    HHVM_FE(mcrypt_generic);\n    HHVM_FE(mdecrypt_generic);\n    HHVM_FE(mcrypt_generic_deinit);\n    HHVM_FE(mcrypt_generic_end);\n\n    loadSystemlib();\n  }\n} s_mcrypt_extension;\n\n///////////////////////////////////////////////////////////////////////////////\n\n}\n", "<?hh\n\n/**\n * Encrypts/decrypts data in CBC mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_cbc(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Encrypts/decrypts data in CFB mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_cfb(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Creates an initialization vector (IV) from a random source\n *\n * @param int $size - The size of the IV.\n * @param int $source - The source of the IV. The source can be\n *   MCRYPT_RAND (system random number generator), MCRYPT_DEV_RANDOM (read\n *   data from /dev/random) and MCRYPT_DEV_URANDOM (read data from\n *   /dev/urandom). Prior to 5.3.0, MCRYPT_RAND was the only one supported\n *   on Windows.\n *\n * @return string - Returns the initialization vector, or FALSE on error.\n */\n<<__Native>>\nfunction mcrypt_create_iv(int $size,\n                          int $source = MCRYPT_DEV_RANDOM): mixed;\n\n/**\n * Decrypts crypttext with given parameters\n *\n * @param string $cipher -\n * @param string $key - The key with which the data was encrypted. If\n *   it's smaller than the required keysize, it is padded with '\\0'.\n * @param string $data - The data that will be decrypted with the given\n *   cipher and mode. If the size of the data is not n * blocksize, the\n *   data will be padded with '\\0'.\n * @param string $mode -\n * @param string $iv -\n *\n * @return string - Returns the decrypted data as a string.\n */\n<<__Native>>\nfunction mcrypt_decrypt(string $cipher,\n                        string $key,\n                        string $data,\n                        string $mode,\n                        ?string $iv = null): mixed;\n\n/**\n * Deprecated: Encrypts/decrypts data in ECB mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_ecb(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Returns the name of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return string - Returns the name of the opened algorithm as a string.\n */\n<<__Native>>\nfunction mcrypt_enc_get_algorithms_name(resource $td): mixed;\n\n/**\n * Returns the blocksize of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - Returns the block size of the specified algorithm in\n *   bytes.\n */\n<<__Native>>\nfunction mcrypt_enc_get_block_size(resource $td): mixed;\n\n/**\n * Returns the size of the IV of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - Returns the size of the IV, or 0 if the IV is ignored by\n *   the algorithm.\n */\n<<__Native>>\nfunction mcrypt_enc_get_iv_size(resource $td): mixed;\n\n/**\n * Returns the maximum supported keysize of the opened mode\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - Returns the maximum supported key size of the algorithm\n *   in bytes.\n */\n<<__Native>>\nfunction mcrypt_enc_get_key_size(resource $td): mixed;\n\n/**\n * Returns the name of the opened mode\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return string - Returns the name as a string.\n */\n<<__Native>>\nfunction mcrypt_enc_get_modes_name(resource $td): mixed;\n\n/**\n * Returns an array with the supported keysizes of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return array - Returns an array with the key sizes supported by the\n *   algorithm specified by the encryption descriptor. If it returns an\n *   empty array then all key sizes between 1 and mcrypt_enc_get_key_size()\n *   are supported by the algorithm.\n */\n<<__Native>>\nfunction mcrypt_enc_get_supported_key_sizes(resource $td): mixed;\n\n/**\n * Checks whether the encryption of the opened mode works on blocks\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool - Returns TRUE if the mode is for use with block\n *   algorithms, otherwise it returns FALSE.\n */\n<<__Native>>\nfunction mcrypt_enc_is_block_algorithm_mode(resource $td): bool;\n\n/**\n * Checks whether the algorithm of the opened mode is a block algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool - Returns TRUE if the algorithm is a block algorithm or\n *   FALSE if it is a stream one.\n */\n<<__Native>>\nfunction mcrypt_enc_is_block_algorithm(resource $td): bool;\n\n/**\n * Checks whether the opened mode outputs blocks\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool - Returns TRUE if the mode outputs blocks of bytes, or\n *   FALSE if it outputs just bytes.\n */\n<<__Native>>\nfunction mcrypt_enc_is_block_mode(resource $td): bool;\n\n/**\n * Runs a self test on the opened module\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - If the self test succeeds it returns FALSE. In case of\n *   an error, it returns TRUE.\n */\n<<__Native>>\nfunction mcrypt_enc_self_test(resource $td): mixed;\n\n/**\n * Encrypts plaintext with given parameters\n *\n * @param string $cipher -\n * @param string $key - The key with which the data will be encrypted. If\n *   it's smaller than the required keysize, it is padded with '\\0'. It is\n *   better not to use ASCII strings for keys.   It is recommended to use\n *   the mhash functions to create a key from a string.\n * @param string $data - The data that will be encrypted with the given\n *   cipher and mode. If the size of the data is not n * blocksize, the\n *   data will be padded with '\\0'.   The returned crypttext can be larger\n *   than the size of the data that was given by data.\n * @param string $mode -\n * @param string $iv -\n *\n * @return string - Returns the encrypted data, as a string.\n */\n<<__Native>>\nfunction mcrypt_encrypt(string $cipher,\n                        string $key,\n                        string $data,\n                        string $mode,\n                        ?string $iv = null): mixed;\n\n/**\n * This function deinitializes an encryption module\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool -\n */\n<<__Native>>\nfunction mcrypt_generic_deinit(resource $td): bool;\n\n/**\n * This function terminates encryption\n *\n * @param resource $td -\n *\n * @return bool -\n */\n<<__Native>>\nfunction mcrypt_generic_end(resource $td): bool;\n\n/**\n * This function initializes all buffers needed for encryption\n *\n * @param resource $td - The encryption descriptor.\n * @param string $key - The maximum length of the key should be the one\n *   obtained by calling mcrypt_enc_get_key_size() and every value smaller\n *   than this is legal.\n * @param string $iv - The IV should normally have the size of the\n *   algorithms block size, but you must obtain the size by calling\n *   mcrypt_enc_get_iv_size(). IV is ignored in ECB. IV MUST exist in CFB,\n *   CBC, STREAM, nOFB and OFB modes. It needs to be random and unique (but\n *   not secret). The same IV must be used for encryption/decryption. If\n *   you do not want to use it you should set it to zeros, but this is not\n *   recommended.\n *\n * @return int - The function returns a negative value on error: -3 when\n *   the key length was incorrect, -4 when there was a memory allocation\n *   problem and any other return value is an unknown error. If an error\n *   occurs a warning will be displayed accordingly. FALSE is returned if\n *   incorrect parameters were passed.\n */\n<<__Native>>\nfunction mcrypt_generic_init(resource $td,\n                             string $key,\n                             string $iv): mixed;\n\n/**\n * This function encrypts data\n *\n * @param resource $td - The encryption descriptor.   The encryption\n *   handle should always be initialized with mcrypt_generic_init() with a\n *   key and an IV before calling this function. Where the encryption is\n *   done, you should free the encryption buffers by calling\n *   mcrypt_generic_deinit(). See mcrypt_module_open() for an example.\n * @param string $data - The data to encrypt.\n *\n * @return string - Returns the encrypted data.\n */\n<<__Native>>\nfunction mcrypt_generic(resource $td,\n                        string $data): mixed;\n\n/**\n * Gets the block size of the specified cipher\n *\n * @param string $cipher -\n * @param string $mode -\n *\n * @return int - Gets the block size, as an integer.\n */\n<<__Native>>\nfunction mcrypt_get_block_size(string $cipher,\n                               ?string $mode = null): mixed;\n\n/**\n * Gets the name of the specified cipher\n *\n * @param string $cipher -\n *\n * @return string - This function returns the name of the cipher or FALSE\n *   if the cipher does not exist.\n */\n<<__Native>>\nfunction mcrypt_get_cipher_name(string $cipher): mixed;\n\n/**\n * Returns the size of the IV belonging to a specific cipher/mode combination\n *\n * @param string $cipher -\n * @param string $mode - The IV is ignored in ECB mode as this mode does\n *   not require it. You will need to have the same IV (think: starting\n *   point) both at encryption and decryption stages, otherwise your\n *   encryption will fail.\n *\n * @return int - Returns the size of the Initialization Vector (IV) in\n *   bytes. On error the function returns FALSE. If the IV is ignored in\n *   the specified cipher/mode combination zero is returned.\n */\n<<__Native>>\nfunction mcrypt_get_iv_size(string $cipher,\n                            string $mode): mixed;\n\n/**\n * Gets the key size of the specified cipher\n *\n * @param string $cipher -\n * @param string $mode -\n *\n * @return int - Returns the maximum supported key size of the algorithm\n *   in bytes .\n */\n<<__Native>>\nfunction mcrypt_get_key_size(string $cipher,\n                             string $mode): mixed;\n\n/**\n * Gets an array of all supported ciphers\n *\n * @param string $lib_dir - Specifies the directory where all algorithms\n *   are located. If not specified, the value of the mcrypt.algorithms_dir\n *   directive is used.\n *\n * @return array - Returns an array with all the supported algorithms.\n */\n<<__Native>>\nfunction mcrypt_list_algorithms(string $lib_dir = ''): array;\n\n/**\n * Gets an array of all supported modes\n *\n * @param string $lib_dir - Specifies the directory where all modes are\n *   located. If not specified, the value of the mcrypt.modes_dir directive\n *   is used.\n *\n * @return array - Returns an array with all the supported modes.\n */\n<<__Native>>\nfunction mcrypt_list_modes(string $lib_dir = ''): array;\n\n/**\n * Closes the mcrypt module\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool -\n */\n<<__Native>>\nfunction mcrypt_module_close(resource $td): bool;\n\n/**\n * Returns the blocksize of the specified algorithm\n *\n * @param string $algorithm - The algorithm name.\n * @param string $lib_dir - This optional parameter can contain the\n *   location where the mode module is on the system.\n *\n * @return int - Returns the block size of the algorithm specified in\n *   bytes.\n */\n<<__Native>>\nfunction mcrypt_module_get_algo_block_size(string $algorithm,\n                                           string $lib_dir = ''): int;\n\n/**\n * Returns the maximum supported keysize of the opened mode\n *\n * @param string $algorithm - The algorithm name.\n * @param string $lib_dir - This optional parameter can contain the\n *   location where the mode module is on the system.\n *\n * @return int - This function returns the maximum supported key size of\n *   the algorithm specified in bytes.\n */\n<<__Native>>\nfunction mcrypt_module_get_algo_key_size(string $algorithm,\n                                         string $lib_dir = ''): int;\n\n/**\n * Returns an array with the supported keysizes of the opened algorithm\n *\n * @param string $algorithm - The algorithm to be used.\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return array - Returns an array with the key sizes supported by the\n *   specified algorithm. If it returns an empty array then all key sizes\n *   between 1 and mcrypt_module_get_algo_key_size() are supported by the\n *   algorithm.\n */\n<<__Native>>\nfunction mcrypt_module_get_supported_key_sizes(string $algorithm,\n                                               string $lib_dir = ''): array;\n\n/**\n * Returns if the specified module is a block algorithm or not\n *\n * @param string $mode - The mode to check.\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - This function returns TRUE if the mode is for use with\n *   block algorithms, otherwise it returns FALSE. (e.g. FALSE for stream,\n *   and TRUE for cbc, cfb, ofb).\n */\n<<__Native>>\nfunction mcrypt_module_is_block_algorithm_mode(string $mode,\n                                               string $lib_dir= ''): bool;\n\n/**\n * This function checks whether the specified algorithm is a block algorithm\n *\n * @param string $algorithm - The algorithm to check.\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - This function returns TRUE if the specified algorithm\n *   is a block algorithm, or FALSE if it is a stream one.\n */\n<<__Native>>\nfunction mcrypt_module_is_block_algorithm(string $algorithm,\n                                          string $lib_dir= ''): bool;\n\n/**\n * Returns if the specified mode outputs blocks or not\n *\n * @param string $mode -\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - This function returns TRUE if the mode outputs blocks\n *   of bytes or FALSE if it outputs just bytes. (e.g. TRUE for cbc and\n *   ecb, and FALSE for cfb and stream).\n */\n<<__Native>>\nfunction mcrypt_module_is_block_mode(string $mode,\n                                     string $lib_dir= ''): bool;\n\n/**\n * Opens the module of the algorithm and the mode to be used\n *\n * @param string $algorithm -\n * @param string $algorithm_directory - The algorithm_directory parameter\n *   is used to locate the encryption module. When you supply a directory\n *   name, it is used. When you set it to an empty string (\"\"), the value\n *   set by the mcrypt.algorithms_dir directive is used. When it is not\n *   set, the default directory that is used is the one that was compiled\n *   into libmcrypt (usually /usr/local/lib/libmcrypt).\n * @param string $mode -\n * @param string $mode_directory - The mode_directory parameter is used\n *   to locate the encryption module. When you supply a directory name, it\n *   is used. When you set it to an empty string (\"\"), the value set by the\n *   mcrypt.modes_dir directive is used. When it is not set, the default\n *   directory that is used is the one that was compiled-in into libmcrypt\n *   (usually /usr/local/lib/libmcrypt).\n *\n * @return resource - Normally it returns an encryption descriptor, or\n *   FALSE on error.\n */\n<<__Native>>\nfunction mcrypt_module_open(string $algorithm,\n                            string $algorithm_directory,\n                            string $mode,\n                            string $mode_directory): mixed;\n\n/**\n * This function runs a self test on the specified module\n *\n * @param string $algorithm -\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - The function returns TRUE if the self test succeeds, or\n *   FALSE when it fails.\n */\n<<__Native>>\nfunction mcrypt_module_self_test(string $algorithm,\n                                 string $lib_dir = ''): bool;\n\n/**\n * Encrypts/decrypts data in OFB mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_ofb(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Decrypts data\n *\n * @param resource $td - An encryption descriptor returned by\n *   mcrypt_module_open()\n * @param string $data - Encrypted data.\n *\n * @return string -\n */\n<<__Native>>\nfunction mdecrypt_generic(resource $td,\n                          string $data): mixed;\n", "<?php\n\nfunction VS($x, $y) {\n  var_dump($x === $y);\n  if ($x !== $y) { echo \"Failed: $y\\n\"; echo \"Got: $x\\n\";\n                   var_dump(debug_backtrace()); }\n}\nfunction VERIFY($x) { VS($x != false, true); }\n\n//////////////////////////////////////////////////////////////////////\n\n$td = mcrypt_module_open(\"rijndael-256\", \"\", \"ofb\", \"\");\n$iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td),\n                                MCRYPT_DEV_RANDOM);\n$ks = mcrypt_enc_get_key_size($td);\n$key = substr(md5(\"very secret key\"), 0, $ks);\nmcrypt_generic_init($td, $key, $iv);\n$encrypted = mcrypt_generic($td, \"This is very important data\");\nVERIFY($encrypted !== \"This is very important data\");\nmcrypt_generic_deinit($td);\nmcrypt_generic_init($td, $key, $iv);\n$decrypted = mdecrypt_generic($td, $encrypted);\nmcrypt_generic_end($td);\nmcrypt_module_close($td);\n\nVS($decrypted, \"This is very important data\");\n\nVERIFY(in_array(\"blowfish\", mcrypt_list_algorithms()));\nVERIFY(in_array(\"cbc\", mcrypt_list_modes()));\nVS(mcrypt_module_get_algo_block_size(\"blowfish\"), 8);\nVS(mcrypt_module_get_algo_key_size(\"blowfish\"), 56);\n\nVS(mcrypt_module_get_supported_key_sizes(\"blowfish\"), array());\nVS(mcrypt_module_get_supported_key_sizes(\"twofish\"),\n   array(16, 24, 32));\n\nVS(mcrypt_module_is_block_algorithm_mode(\"cbc\"), true);\nVS(mcrypt_module_is_block_algorithm(\"blowfish\"), true);\nVS(mcrypt_module_is_block_mode(\"cbc\"), true);\nVS(mcrypt_module_self_test(MCRYPT_RIJNDAEL_128), true);\nVS(mcrypt_module_self_test(\"bogus\"), false);\n\n$text = \"boggles the inivisble monkey will rule the world\";\n$key = \"very secret key\";\n$iv_size = mcrypt_get_iv_size(MCRYPT_XTEA, MCRYPT_MODE_ECB);\n$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);\n$enc = mcrypt_encrypt(MCRYPT_XTEA, $key, $text, MCRYPT_MODE_ECB,\n                               $iv);\nVS(bin2hex($enc), \"f522c62002fa16129c8576bcddc6dd0f7ea81991103ba42962d94c8bfff3ee660d53b187d7e989540abf5a729c2f7baf\");\n$crypttext = mcrypt_decrypt(MCRYPT_XTEA, $key, $enc,\n                                     MCRYPT_MODE_ECB, $iv);\nVS($crypttext, $text);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_cbc(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_cbc(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS(trim((string)$decrypted), $CC);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_cfb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_cfb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS(trim((string)$decrypted), $CC);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_ecb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_ecb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS(trim((string)$decrypted), $CC);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_ofb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_ofb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS($decrypted, $CC);\n\n//////////////////////////////////////////////////////////////////////\n\nVS(mcrypt_get_block_size(\"tripledes\", \"ecb\"), 8);\nVS(mcrypt_get_cipher_name(MCRYPT_TRIPLEDES), \"3DES\");\nVS(mcrypt_get_iv_size(MCRYPT_CAST_256, MCRYPT_MODE_CFB), 16);\nVS(mcrypt_get_iv_size(\"des\", \"ecb\"), 8);\nVS(mcrypt_get_key_size(\"tripledes\", \"ecb\"), 24);\n\n$td = mcrypt_module_open(\"cast-256\", \"\", \"cfb\", \"\");\nVS(mcrypt_enc_get_algorithms_name($td), \"CAST-256\");\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_get_block_size($td), 8);\n\n$td = mcrypt_module_open(\"cast-256\", \"\", \"cfb\", \"\");\nVS(mcrypt_enc_get_iv_size($td), 16);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_get_key_size($td), 24);\n\n$td = mcrypt_module_open(\"cast-256\", \"\", \"cfb\", \"\");\nVS(mcrypt_enc_get_modes_name($td), \"CFB\");\n\n$td = mcrypt_module_open(\"rijndael-256\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_get_supported_key_sizes($td),\n   array(16, 24, 32));\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_is_block_algorithm_mode($td), true);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_is_block_algorithm($td), true);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_is_block_mode($td), true);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_self_test($td), 0);\n", "bool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_cbc() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 60\n\nDeprecated: Function mcrypt_cbc() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 63\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_cfb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 73\n\nDeprecated: Function mcrypt_cfb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 76\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_ecb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 86\n\nDeprecated: Function mcrypt_ecb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 89\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_ofb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 99\n\nDeprecated: Function mcrypt_ofb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 102\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/ext/extension.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/ext/std/ext_std_math.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#define NON_FREE\n#define MCRYPT2\n#include <mcrypt.h>\n\nnamespace HPHP {\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct MCrypt : SweepableResourceData {\n  explicit MCrypt(MCRYPT td) : m_td(td), m_init(false) {}\n\n  ~MCrypt() {\n    MCrypt::close();\n  }\n\n  bool isInvalid() const override {\n    return m_td == MCRYPT_FAILED;\n  }\n\n  void close() {\n    if (m_td != MCRYPT_FAILED) {\n      mcrypt_generic_deinit(m_td);\n      mcrypt_module_close(m_td);\n      m_td = MCRYPT_FAILED;\n    }\n  }\n\n  CLASSNAME_IS(\"mcrypt\");\n  // overriding ResourceData\n  const String& o_getClassNameHook() const override { return classnameof(); }\n\n  DECLARE_RESOURCE_ALLOCATION(MCrypt)\n\npublic:\n  MCRYPT m_td;\n  bool m_init;\n};\n\nIMPLEMENT_RESOURCE_ALLOCATION(MCrypt)\n\ntypedef enum {\n  RANDOM = 0,\n  URANDOM,\n  RAND\n} iv_source;\n\nstruct mcrypt_data {\n  std::string algorithms_dir;\n  std::string modes_dir;\n};\nstatic mcrypt_data s_globals;\n#define MCG(n) (s_globals.n)\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n#define MCRYPT_OPEN_MODULE_FAILED(str) \\\n raise_warning(\"%s(): Module initialization failed\", str);\n\nstatic Variant php_mcrypt_do_crypt(const String& cipher, const String& key,\n                                   const String& data, const String& mode,\n                                   const String& iv, bool dencrypt,\n                                   char *name) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)mode.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(name);\n    return false;\n  }\n\n  /* Checking for key-length */\n  int max_key_length = mcrypt_enc_get_key_size(td);\n  if (key.size() > max_key_length) {\n    raise_warning(\"Size of key is too large for this algorithm\");\n  }\n  int count;\n  int *key_length_sizes = mcrypt_enc_get_supported_key_sizes(td, &count);\n  int use_key_length;\n  char *key_s = nullptr;\n  if (count == 0 && key_length_sizes == nullptr) { // all lengths 1 - k_l_s = OK\n    use_key_length = key.size();\n    key_s = (char*)malloc(use_key_length);\n    memcpy(key_s, key.data(), use_key_length);\n  } else if (count == 1) {  /* only m_k_l = OK */\n    key_s = (char*)malloc(key_length_sizes[0]);\n    memset(key_s, 0, key_length_sizes[0]);\n    memcpy(key_s, key.data(), MIN(key.size(), key_length_sizes[0]));\n    use_key_length = key_length_sizes[0];\n  } else { /* dertermine smallest supported key > length of requested key */\n    use_key_length = max_key_length; /* start with max key length */\n    for (int i = 0; i < count; i++) {\n      if (key_length_sizes[i] >= key.size() &&\n          key_length_sizes[i] < use_key_length) {\n        use_key_length = key_length_sizes[i];\n      }\n    }\n    key_s = (char*)malloc(use_key_length);\n    memset(key_s, 0, use_key_length);\n    memcpy(key_s, key.data(), MIN(key.size(), use_key_length));\n  }\n  mcrypt_free(key_length_sizes);\n\n  /* Check IV */\n  char *iv_s = nullptr;\n  int iv_size = mcrypt_enc_get_iv_size(td);\n\n  /* IV is required */\n  if (mcrypt_enc_mode_has_iv(td) == 1) {\n    if (!iv.empty()) {\n      if (iv_size != iv.size()) {\n        raise_warning(\"%s(): The IV parameter must be as long as \"\n                      \"the blocksize\", name);\n      } else {\n        iv_s = (char*)malloc(iv_size + 1);\n        memcpy(iv_s, iv.data(), iv_size);\n      }\n    } else {\n      raise_warning(\"%s(): The IV parameter must be as long as \"\n                    \"the blocksize\", name);\n      iv_s = (char*)malloc(iv_size + 1);\n      memset(iv_s, 0, iv_size + 1);\n    }\n  }\n\n  int block_size;\n  unsigned long int data_size;\n  String s;\n  char *data_s;\n  /* Check blocksize */\n  if (mcrypt_enc_is_block_mode(td) == 1) { /* It's a block algorithm */\n    block_size = mcrypt_enc_get_block_size(td);\n    data_size = (((data.size() - 1) / block_size) + 1) * block_size;\n    s = String(data_size, ReserveString);\n    data_s = (char*)s.mutableData();\n    memset(data_s, 0, data_size);\n    memcpy(data_s, data.data(), data.size());\n  } else { /* It's not a block algorithm */\n    data_size = data.size();\n    s = String(data_size, ReserveString);\n    data_s = (char*)s.mutableData();\n    memcpy(data_s, data.data(), data.size());\n  }\n\n  if (mcrypt_generic_init(td, key_s, use_key_length, iv_s) < 0) {\n    raise_warning(\"Mcrypt initialisation failed\");\n    return false;\n  }\n  if (dencrypt) {\n    mdecrypt_generic(td, data_s, data_size);\n  } else {\n    mcrypt_generic(td, data_s, data_size);\n  }\n\n  /* freeing vars */\n  mcrypt_generic_end(td);\n  if (key_s != nullptr) {\n    free(key_s);\n  }\n  if (iv_s != nullptr) {\n    free(iv_s);\n  }\n  s.setSize(data_size);\n  return s;\n}\n\nstatic req::ptr<MCrypt> get_valid_mcrypt_resource(const Resource& td) {\n  auto pm = dyn_cast_or_null<MCrypt>(td);\n\n  if (pm == nullptr || pm->isInvalid()) {\n    raise_warning(\"supplied argument is not a valid MCrypt resource\");\n    return nullptr;\n  }\n\n  return pm;\n}\n\nstatic Variant mcrypt_generic(const Resource& td, const String& data,\n                              bool dencrypt) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  } else if (!pm->m_init) {\n    raise_warning(\"Operation disallowed prior to mcrypt_generic_init().\");\n    return false;\n  }\n\n  if (data.empty()) {\n    raise_warning(\"An empty string was passed\");\n    return false;\n  }\n\n  String s;\n  unsigned char* data_s;\n  int block_size, data_size;\n  /* Check blocksize */\n  if (mcrypt_enc_is_block_mode(pm->m_td) == 1) { /* It's a block algorithm */\n    block_size = mcrypt_enc_get_block_size(pm->m_td);\n    data_size = (((data.size() - 1) / block_size) + 1) * block_size;\n    s = String(data_size, ReserveString);\n    data_s = (unsigned char *)s.mutableData();\n    memset(data_s, 0, data_size);\n    memcpy(data_s, data.data(), data.size());\n  } else { /* It's not a block algorithm */\n    data_size = data.size();\n    s = String(data_size, ReserveString);\n    data_s = (unsigned char *)s.mutableData();\n    memcpy(data_s, data.data(), data.size());\n  }\n\n  if (dencrypt) {\n    mdecrypt_generic(pm->m_td, data_s, data_size);\n  } else {\n    mcrypt_generic(pm->m_td, data_s, data_size);\n  }\n  s.setSize(data_size);\n  return s;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nVariant HHVM_FUNCTION(mcrypt_module_open, const String& algorithm,\n                                          const String& algorithm_directory,\n                             const String& mode, const String& mode_directory) {\n  MCRYPT td = mcrypt_module_open\n    ((char*)algorithm.data(),\n     (char*)(algorithm_directory.empty() ? MCG(algorithms_dir).data() :\n             algorithm_directory.data()),\n     (char*)mode.data(),\n     (char*)(mode_directory.empty() ? (char*)MCG(modes_dir).data() :\n             mode_directory.data()));\n\n  if (td == MCRYPT_FAILED) {\n    raise_warning(\"Could not open encryption module\");\n    return false;\n  }\n\n  return Variant(req::make<MCrypt>(td));\n}\n\nbool HHVM_FUNCTION(mcrypt_module_close, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  pm->close();\n  return true;\n}\n\nArray HHVM_FUNCTION(mcrypt_list_algorithms,\n                    const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n\n  int count = 0;\n  char **modules = mcrypt_list_algorithms((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No algorithms found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}\n\nArray HHVM_FUNCTION(mcrypt_list_modes,\n                    const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n\n  int count = 0;\n  char **modules = mcrypt_list_modes((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No modes found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}\n\nint64_t HHVM_FUNCTION(mcrypt_module_get_algo_block_size,\n                                   const String& algorithm,\n                                   const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_get_algo_block_size((char*)algorithm.data(),\n                                           (char*)dir.data());\n}\n\nint64_t HHVM_FUNCTION(mcrypt_module_get_algo_key_size, const String& algorithm,\n                                   const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_get_algo_key_size((char*)algorithm.data(),\n                                         (char*)dir.data());\n}\n\nArray HHVM_FUNCTION(mcrypt_module_get_supported_key_sizes,\n                    const String& algorithm,\n                    const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n\n  int count = 0;\n  int *key_sizes = mcrypt_module_get_algo_supported_key_sizes\n    ((char*)algorithm.data(), (char*)dir.data(), &count);\n\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(key_sizes[i]);\n  }\n  mcrypt_free(key_sizes);\n  return ret;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_is_block_algorithm_mode, const String& mode,\n                                  const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  return mcrypt_module_is_block_algorithm_mode((char*)mode.data(),\n                                               (char*)dir.data()) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_is_block_algorithm, const String& algorithm,\n                                  const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_is_block_algorithm((char*)algorithm.data(),\n                                          (char*)dir.data()) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_is_block_mode, const String& mode,\n                                   const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  return mcrypt_module_is_block_mode((char*)mode.data(),\n                                     (char*)dir.data()) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_module_self_test, const String& algorithm,\n                               const String& lib_dir /* = null_string */) {\n  String dir = lib_dir.empty() ? String(MCG(algorithms_dir)) : lib_dir;\n  return mcrypt_module_self_test((char*)algorithm.data(),\n                                 (char*)dir.data()) == 0;\n}\n\nVariant HHVM_FUNCTION(mcrypt_create_iv, int size, int source /* = 0 */) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      // Use userspace rand() function because it handles auto-seeding\n      iv[--size] = (char)HHVM_FN(rand)(0, 255);\n    }\n  }\n  return String(iv, n, AttachString);\n}\n\nVariant HHVM_FUNCTION(mcrypt_encrypt, const String& cipher, const String& key,\n                                      const String& data, const String& mode,\n                                      const Variant& viv /* = null_string */) {\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, mode, iv, false,\n                             \"mcrypt_encrypt\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_decrypt, const String& cipher, const String& key,\n                                      const String& data, const String& mode,\n                                      const Variant& viv /* = null_string */) {\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, mode, iv, true,\n                             \"mcrypt_decrypt\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_cbc, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_cbc() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"cbc\", iv, mode.toInt32(),\n                             \"mcrypt_cbc\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_cfb, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_cfb() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"cfb\", iv, mode.toInt32(),\n                             \"mcrypt_cfb\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_ecb, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_ecb() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"ecb\", iv, mode.toInt32(),\n                             \"mcrypt_ecb\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_ofb, const String& cipher, const String& key,\n                                  const String& data, const Variant& mode,\n                                  const Variant& viv /* = null_string */) {\n  raise_deprecated(\"Function mcrypt_ofb() is deprecated\");\n  String iv = viv.toString();\n  return php_mcrypt_do_crypt(cipher, key, data, \"ofb\", iv, mode.toInt32(),\n                             \"mcrypt_ofb\");\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                             const String& mode) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)mode.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_cipher_name, const String& cipher) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)\"ecb\",\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    td = mcrypt_module_open((char*)cipher.data(),\n                            (char*)MCG(algorithms_dir).data(),\n                            (char*)\"stream\",\n                            (char*)MCG(modes_dir).data());\n    if (td == MCRYPT_FAILED) {\n      MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_cipher_name\");\n      return false;\n    }\n  }\n\n  char *cipher_name = mcrypt_enc_get_algorithms_name(td);\n  mcrypt_module_close(td);\n  String ret(cipher_name, CopyString);\n  mcrypt_free(cipher_name);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_iv_size, const String& cipher,\n                                          const String& mode) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)mode.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_iv_size\");\n    return false;\n  }\n\n  int64_t ret = mcrypt_enc_get_iv_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_get_key_size, const String& cipher,\n                                           const String& module) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_key_size\");\n    return false;\n  }\n\n  int64_t ret = mcrypt_enc_get_key_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_algorithms_name, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  char *name = mcrypt_enc_get_algorithms_name(pm->m_td);\n  String ret(name, CopyString);\n  mcrypt_free(name);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_block_size, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_get_block_size(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_iv_size, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_get_iv_size(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_key_size, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_get_key_size(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_modes_name, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  char *name = mcrypt_enc_get_modes_name(pm->m_td);\n  String ret(name, CopyString);\n  mcrypt_free(name);\n  return ret;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_get_supported_key_sizes, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int count = 0;\n  int *key_sizes =\n    mcrypt_enc_get_supported_key_sizes(pm->m_td, &count);\n\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(key_sizes[i]);\n  }\n  mcrypt_free(key_sizes);\n  return ret;\n}\n\nbool HHVM_FUNCTION(mcrypt_enc_is_block_algorithm_mode, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_is_block_algorithm_mode(pm->m_td) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_enc_is_block_algorithm, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_is_block_algorithm(pm->m_td) == 1;\n}\n\nbool HHVM_FUNCTION(mcrypt_enc_is_block_mode, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_is_block_mode(pm->m_td) == 1;\n}\n\nVariant HHVM_FUNCTION(mcrypt_enc_self_test, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  return mcrypt_enc_self_test(pm->m_td);\n}\n\nVariant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td,\n                                           const String& key,\n                                           const String& iv) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  int max_key_size = mcrypt_enc_get_key_size(pm->m_td);\n  int iv_size = mcrypt_enc_get_iv_size(pm->m_td);\n\n  if (key.empty()) {\n    raise_warning(\"Key size is 0\");\n  }\n\n  unsigned char *key_s = (unsigned char *)malloc(key.size());\n  memset(key_s, 0, key.size());\n\n  unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1);\n  memset(iv_s, 0, iv_size + 1);\n\n  int key_size;\n  if (key.size() > max_key_size) {\n    raise_warning(\"Key size too large; supplied length: %d, max: %d\",\n                    key.size(), max_key_size);\n    key_size = max_key_size;\n  } else {\n    key_size = key.size();\n  }\n  memcpy(key_s, key.data(), key.size());\n\n  if (iv.size() != iv_size) {\n    raise_warning(\"Iv size incorrect; supplied length: %d, needed: %d\",\n                    iv.size(), iv_size);\n  }\n  memcpy(iv_s, iv.data(), std::min(iv_size, iv.size()));\n\n  mcrypt_generic_deinit(pm->m_td);\n  int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s);\n\n  /* If this function fails, close the mcrypt module to prevent crashes\n   * when further functions want to access this resource */\n  if (result < 0) {\n    pm->close();\n    switch (result) {\n    case -3:\n      raise_warning(\"Key length incorrect\");\n      break;\n    case -4:\n      raise_warning(\"Memory allocation error\");\n      break;\n    case -1:\n    default:\n      raise_warning(\"Unknown error\");\n      break;\n    }\n  } else {\n    pm->m_init = true;\n  }\n\n  free(iv_s);\n  free(key_s);\n  return result;\n}\n\nVariant HHVM_FUNCTION(mcrypt_generic, const Resource& td, const String& data) {\n  return mcrypt_generic(td, data, false);\n}\n\nVariant HHVM_FUNCTION(mdecrypt_generic, const Resource& td,\n                                        const String& data) {\n  return mcrypt_generic(td, data, true);\n}\n\nbool HHVM_FUNCTION(mcrypt_generic_deinit, const Resource& td) {\n  auto pm = get_valid_mcrypt_resource(td);\n  if (!pm) {\n    return false;\n  }\n\n  if (mcrypt_generic_deinit(pm->m_td) < 0) {\n    raise_warning(\"Could not terminate encryption specifier\");\n    return false;\n  }\n  pm->m_init = false;\n  return true;\n}\n\nbool HHVM_FUNCTION(mcrypt_generic_end, const Resource& td) {\n  return HHVM_FUNCTION(mcrypt_generic_deinit, td);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct McryptExtension final : Extension {\n  McryptExtension() : Extension(\"mcrypt\") {}\n  void moduleInit() override {\n    HHVM_RC_STR(MCRYPT_3DES, \"tripledes\");\n    HHVM_RC_STR(MCRYPT_ARCFOUR, \"arcfour\");\n    HHVM_RC_STR(MCRYPT_ARCFOUR_IV, \"arcfour-iv\");\n    HHVM_RC_STR(MCRYPT_BLOWFISH, \"blowfish\");\n    HHVM_RC_STR(MCRYPT_BLOWFISH_COMPAT, \"blowfish-compat\");\n    HHVM_RC_STR(MCRYPT_CAST_128, \"cast-128\");\n    HHVM_RC_STR(MCRYPT_CAST_256, \"cast-256\");\n    HHVM_RC_STR(MCRYPT_CRYPT, \"crypt\");\n    HHVM_RC_INT(MCRYPT_DECRYPT, 1);\n    HHVM_RC_STR(MCRYPT_DES, \"des\");\n    HHVM_RC_INT(MCRYPT_DEV_RANDOM, RANDOM);\n    HHVM_RC_INT(MCRYPT_DEV_URANDOM, URANDOM);\n    HHVM_RC_INT(MCRYPT_ENCRYPT, 0);\n    HHVM_RC_STR(MCRYPT_ENIGNA, \"crypt\");\n    HHVM_RC_STR(MCRYPT_GOST, \"gost\");\n    HHVM_RC_STR(MCRYPT_IDEA, \"idea\");\n    HHVM_RC_STR(MCRYPT_LOKI97, \"loki97\");\n    HHVM_RC_STR(MCRYPT_MARS, \"mars\");\n    HHVM_RC_STR(MCRYPT_MODE_CBC, \"cbc\");\n    HHVM_RC_STR(MCRYPT_MODE_CFB, \"cfb\");\n    HHVM_RC_STR(MCRYPT_MODE_ECB, \"ecb\");\n    HHVM_RC_STR(MCRYPT_MODE_NOFB, \"nofb\");\n    HHVM_RC_STR(MCRYPT_MODE_OFB, \"ofb\");\n    HHVM_RC_STR(MCRYPT_MODE_STREAM, \"stream\");\n    HHVM_RC_STR(MCRYPT_PANAMA, \"panama\");\n    HHVM_RC_INT(MCRYPT_RAND, RAND);\n    HHVM_RC_STR(MCRYPT_RC2, \"rc2\");\n    HHVM_RC_STR(MCRYPT_RC6, \"rc6\");\n    HHVM_RC_STR(MCRYPT_RIJNDAEL_128, \"rijndael-128\");\n    HHVM_RC_STR(MCRYPT_RIJNDAEL_192, \"rijndael-192\");\n    HHVM_RC_STR(MCRYPT_RIJNDAEL_256, \"rijndael-256\");\n    HHVM_RC_STR(MCRYPT_SAFER128, \"safer-sk128\");\n    HHVM_RC_STR(MCRYPT_SAFER64, \"safer-sk64\");\n    HHVM_RC_STR(MCRYPT_SAFERPLUS, \"saferplus\");\n    HHVM_RC_STR(MCRYPT_SERPENT, \"serpent\");\n    HHVM_RC_STR(MCRYPT_SKIPJACK, \"skipjack\");\n    HHVM_RC_STR(MCRYPT_THREEWAY, \"threeway\");\n    HHVM_RC_STR(MCRYPT_TRIPLEDES, \"tripledes\");\n    HHVM_RC_STR(MCRYPT_TWOFISH, \"twofish\");\n    HHVM_RC_STR(MCRYPT_WAKE, \"wake\");\n    HHVM_RC_STR(MCRYPT_XTEA, \"xtea\");\n\n    HHVM_FE(mcrypt_module_open);\n    HHVM_FE(mcrypt_module_close);\n    HHVM_FE(mcrypt_list_algorithms);\n    HHVM_FE(mcrypt_list_modes);\n    HHVM_FE(mcrypt_module_get_algo_block_size);\n    HHVM_FE(mcrypt_module_get_algo_key_size);\n    HHVM_FE(mcrypt_module_get_supported_key_sizes);\n    HHVM_FE(mcrypt_module_is_block_algorithm_mode);\n    HHVM_FE(mcrypt_module_is_block_algorithm);\n    HHVM_FE(mcrypt_module_is_block_mode);\n    HHVM_FE(mcrypt_module_self_test);\n    HHVM_FE(mcrypt_create_iv);\n    HHVM_FE(mcrypt_encrypt);\n    HHVM_FE(mcrypt_decrypt);\n    HHVM_FE(mcrypt_cbc);\n    HHVM_FE(mcrypt_cfb);\n    HHVM_FE(mcrypt_ecb);\n    HHVM_FE(mcrypt_ofb);\n    HHVM_FE(mcrypt_get_block_size);\n    HHVM_FE(mcrypt_get_cipher_name);\n    HHVM_FE(mcrypt_get_iv_size);\n    HHVM_FE(mcrypt_get_key_size);\n    HHVM_FE(mcrypt_enc_get_algorithms_name);\n    HHVM_FE(mcrypt_enc_get_block_size);\n    HHVM_FE(mcrypt_enc_get_iv_size);\n    HHVM_FE(mcrypt_enc_get_key_size);\n    HHVM_FE(mcrypt_enc_get_modes_name);\n    HHVM_FE(mcrypt_enc_get_supported_key_sizes);\n    HHVM_FE(mcrypt_enc_is_block_algorithm_mode);\n    HHVM_FE(mcrypt_enc_is_block_algorithm);\n    HHVM_FE(mcrypt_enc_is_block_mode);\n    HHVM_FE(mcrypt_enc_self_test);\n    HHVM_FE(mcrypt_generic_init);\n    HHVM_FE(mcrypt_generic);\n    HHVM_FE(mdecrypt_generic);\n    HHVM_FE(mcrypt_generic_deinit);\n    HHVM_FE(mcrypt_generic_end);\n\n    loadSystemlib();\n  }\n} s_mcrypt_extension;\n\n///////////////////////////////////////////////////////////////////////////////\n\n}\n", "<?hh\n\n/**\n * Encrypts/decrypts data in CBC mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_cbc(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Encrypts/decrypts data in CFB mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_cfb(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Creates an initialization vector (IV) from a random source\n *\n * @param int $size - The size of the IV.\n * @param int $source - The source of the IV. The source can be\n *   MCRYPT_RAND (system random number generator), MCRYPT_DEV_RANDOM (read\n *   data from /dev/random) and MCRYPT_DEV_URANDOM (read data from\n *   /dev/urandom). Prior to 5.3.0, MCRYPT_RAND was the only one supported\n *   on Windows.\n *\n * @return string - Returns the initialization vector, or FALSE on error.\n */\n<<__Native>>\nfunction mcrypt_create_iv(int $size,\n                          int $source = MCRYPT_DEV_RANDOM): mixed;\n\n/**\n * Decrypts crypttext with given parameters\n *\n * @param string $cipher -\n * @param string $key - The key with which the data was encrypted. If\n *   it's smaller than the required keysize, it is padded with '\\0'.\n * @param string $data - The data that will be decrypted with the given\n *   cipher and mode. If the size of the data is not n * blocksize, the\n *   data will be padded with '\\0'.\n * @param string $mode -\n * @param string $iv -\n *\n * @return string - Returns the decrypted data as a string.\n */\n<<__Native>>\nfunction mcrypt_decrypt(string $cipher,\n                        string $key,\n                        string $data,\n                        string $mode,\n                        ?string $iv = null): mixed;\n\n/**\n * Deprecated: Encrypts/decrypts data in ECB mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_ecb(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Returns the name of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return string - Returns the name of the opened algorithm as a string.\n */\n<<__Native>>\nfunction mcrypt_enc_get_algorithms_name(resource $td): mixed;\n\n/**\n * Returns the blocksize of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - Returns the block size of the specified algorithm in\n *   bytes.\n */\n<<__Native>>\nfunction mcrypt_enc_get_block_size(resource $td): mixed;\n\n/**\n * Returns the size of the IV of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - Returns the size of the IV, or 0 if the IV is ignored by\n *   the algorithm.\n */\n<<__Native>>\nfunction mcrypt_enc_get_iv_size(resource $td): mixed;\n\n/**\n * Returns the maximum supported keysize of the opened mode\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - Returns the maximum supported key size of the algorithm\n *   in bytes.\n */\n<<__Native>>\nfunction mcrypt_enc_get_key_size(resource $td): mixed;\n\n/**\n * Returns the name of the opened mode\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return string - Returns the name as a string.\n */\n<<__Native>>\nfunction mcrypt_enc_get_modes_name(resource $td): mixed;\n\n/**\n * Returns an array with the supported keysizes of the opened algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return array - Returns an array with the key sizes supported by the\n *   algorithm specified by the encryption descriptor. If it returns an\n *   empty array then all key sizes between 1 and mcrypt_enc_get_key_size()\n *   are supported by the algorithm.\n */\n<<__Native>>\nfunction mcrypt_enc_get_supported_key_sizes(resource $td): mixed;\n\n/**\n * Checks whether the encryption of the opened mode works on blocks\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool - Returns TRUE if the mode is for use with block\n *   algorithms, otherwise it returns FALSE.\n */\n<<__Native>>\nfunction mcrypt_enc_is_block_algorithm_mode(resource $td): bool;\n\n/**\n * Checks whether the algorithm of the opened mode is a block algorithm\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool - Returns TRUE if the algorithm is a block algorithm or\n *   FALSE if it is a stream one.\n */\n<<__Native>>\nfunction mcrypt_enc_is_block_algorithm(resource $td): bool;\n\n/**\n * Checks whether the opened mode outputs blocks\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool - Returns TRUE if the mode outputs blocks of bytes, or\n *   FALSE if it outputs just bytes.\n */\n<<__Native>>\nfunction mcrypt_enc_is_block_mode(resource $td): bool;\n\n/**\n * Runs a self test on the opened module\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return int - If the self test succeeds it returns FALSE. In case of\n *   an error, it returns TRUE.\n */\n<<__Native>>\nfunction mcrypt_enc_self_test(resource $td): mixed;\n\n/**\n * Encrypts plaintext with given parameters\n *\n * @param string $cipher -\n * @param string $key - The key with which the data will be encrypted. If\n *   it's smaller than the required keysize, it is padded with '\\0'. It is\n *   better not to use ASCII strings for keys.   It is recommended to use\n *   the mhash functions to create a key from a string.\n * @param string $data - The data that will be encrypted with the given\n *   cipher and mode. If the size of the data is not n * blocksize, the\n *   data will be padded with '\\0'.   The returned crypttext can be larger\n *   than the size of the data that was given by data.\n * @param string $mode -\n * @param string $iv -\n *\n * @return string - Returns the encrypted data, as a string.\n */\n<<__Native>>\nfunction mcrypt_encrypt(string $cipher,\n                        string $key,\n                        string $data,\n                        string $mode,\n                        ?string $iv = null): mixed;\n\n/**\n * This function deinitializes an encryption module\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool -\n */\n<<__Native>>\nfunction mcrypt_generic_deinit(resource $td): bool;\n\n/**\n * This function terminates encryption\n *\n * @param resource $td -\n *\n * @return bool -\n */\n<<__Native>>\nfunction mcrypt_generic_end(resource $td): bool;\n\n/**\n * This function initializes all buffers needed for encryption\n *\n * @param resource $td - The encryption descriptor.\n * @param string $key - The maximum length of the key should be the one\n *   obtained by calling mcrypt_enc_get_key_size() and every value smaller\n *   than this is legal.\n * @param string $iv - The IV should normally have the size of the\n *   algorithms block size, but you must obtain the size by calling\n *   mcrypt_enc_get_iv_size(). IV is ignored in ECB. IV MUST exist in CFB,\n *   CBC, STREAM, nOFB and OFB modes. It needs to be random and unique (but\n *   not secret). The same IV must be used for encryption/decryption. If\n *   you do not want to use it you should set it to zeros, but this is not\n *   recommended.\n *\n * @return int - The function returns a negative value on error: -3 when\n *   the key length was incorrect, -4 when there was a memory allocation\n *   problem and any other return value is an unknown error. If an error\n *   occurs a warning will be displayed accordingly. FALSE is returned if\n *   incorrect parameters were passed.\n */\n<<__Native>>\nfunction mcrypt_generic_init(resource $td,\n                             string $key,\n                             string $iv): mixed;\n\n/**\n * This function encrypts data\n *\n * @param resource $td - The encryption descriptor.   The encryption\n *   handle should always be initialized with mcrypt_generic_init() with a\n *   key and an IV before calling this function. Where the encryption is\n *   done, you should free the encryption buffers by calling\n *   mcrypt_generic_deinit(). See mcrypt_module_open() for an example.\n * @param string $data - The data to encrypt.\n *\n * @return string - Returns the encrypted data.\n */\n<<__Native>>\nfunction mcrypt_generic(resource $td,\n                        string $data): mixed;\n\n/**\n * Gets the block size of the specified cipher\n *\n * @param string $cipher -\n * @param string $mode -\n *\n * @return int - Gets the block size, as an integer.\n */\n<<__Native>>\nfunction mcrypt_get_block_size(string $cipher,\n                               string $mode): mixed;\n\n/**\n * Gets the name of the specified cipher\n *\n * @param string $cipher -\n *\n * @return string - This function returns the name of the cipher or FALSE\n *   if the cipher does not exist.\n */\n<<__Native>>\nfunction mcrypt_get_cipher_name(string $cipher): mixed;\n\n/**\n * Returns the size of the IV belonging to a specific cipher/mode combination\n *\n * @param string $cipher -\n * @param string $mode - The IV is ignored in ECB mode as this mode does\n *   not require it. You will need to have the same IV (think: starting\n *   point) both at encryption and decryption stages, otherwise your\n *   encryption will fail.\n *\n * @return int - Returns the size of the Initialization Vector (IV) in\n *   bytes. On error the function returns FALSE. If the IV is ignored in\n *   the specified cipher/mode combination zero is returned.\n */\n<<__Native>>\nfunction mcrypt_get_iv_size(string $cipher,\n                            string $mode): mixed;\n\n/**\n * Gets the key size of the specified cipher\n *\n * @param string $cipher -\n * @param string $mode -\n *\n * @return int - Returns the maximum supported key size of the algorithm\n *   in bytes .\n */\n<<__Native>>\nfunction mcrypt_get_key_size(string $cipher,\n                             string $mode): mixed;\n\n/**\n * Gets an array of all supported ciphers\n *\n * @param string $lib_dir - Specifies the directory where all algorithms\n *   are located. If not specified, the value of the mcrypt.algorithms_dir\n *   directive is used.\n *\n * @return array - Returns an array with all the supported algorithms.\n */\n<<__Native>>\nfunction mcrypt_list_algorithms(string $lib_dir = ''): array;\n\n/**\n * Gets an array of all supported modes\n *\n * @param string $lib_dir - Specifies the directory where all modes are\n *   located. If not specified, the value of the mcrypt.modes_dir directive\n *   is used.\n *\n * @return array - Returns an array with all the supported modes.\n */\n<<__Native>>\nfunction mcrypt_list_modes(string $lib_dir = ''): array;\n\n/**\n * Closes the mcrypt module\n *\n * @param resource $td - The encryption descriptor.\n *\n * @return bool -\n */\n<<__Native>>\nfunction mcrypt_module_close(resource $td): bool;\n\n/**\n * Returns the blocksize of the specified algorithm\n *\n * @param string $algorithm - The algorithm name.\n * @param string $lib_dir - This optional parameter can contain the\n *   location where the mode module is on the system.\n *\n * @return int - Returns the block size of the algorithm specified in\n *   bytes.\n */\n<<__Native>>\nfunction mcrypt_module_get_algo_block_size(string $algorithm,\n                                           string $lib_dir = ''): int;\n\n/**\n * Returns the maximum supported keysize of the opened mode\n *\n * @param string $algorithm - The algorithm name.\n * @param string $lib_dir - This optional parameter can contain the\n *   location where the mode module is on the system.\n *\n * @return int - This function returns the maximum supported key size of\n *   the algorithm specified in bytes.\n */\n<<__Native>>\nfunction mcrypt_module_get_algo_key_size(string $algorithm,\n                                         string $lib_dir = ''): int;\n\n/**\n * Returns an array with the supported keysizes of the opened algorithm\n *\n * @param string $algorithm - The algorithm to be used.\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return array - Returns an array with the key sizes supported by the\n *   specified algorithm. If it returns an empty array then all key sizes\n *   between 1 and mcrypt_module_get_algo_key_size() are supported by the\n *   algorithm.\n */\n<<__Native>>\nfunction mcrypt_module_get_supported_key_sizes(string $algorithm,\n                                               string $lib_dir = ''): array;\n\n/**\n * Returns if the specified module is a block algorithm or not\n *\n * @param string $mode - The mode to check.\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - This function returns TRUE if the mode is for use with\n *   block algorithms, otherwise it returns FALSE. (e.g. FALSE for stream,\n *   and TRUE for cbc, cfb, ofb).\n */\n<<__Native>>\nfunction mcrypt_module_is_block_algorithm_mode(string $mode,\n                                               string $lib_dir= ''): bool;\n\n/**\n * This function checks whether the specified algorithm is a block algorithm\n *\n * @param string $algorithm - The algorithm to check.\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - This function returns TRUE if the specified algorithm\n *   is a block algorithm, or FALSE if it is a stream one.\n */\n<<__Native>>\nfunction mcrypt_module_is_block_algorithm(string $algorithm,\n                                          string $lib_dir= ''): bool;\n\n/**\n * Returns if the specified mode outputs blocks or not\n *\n * @param string $mode -\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - This function returns TRUE if the mode outputs blocks\n *   of bytes or FALSE if it outputs just bytes. (e.g. TRUE for cbc and\n *   ecb, and FALSE for cfb and stream).\n */\n<<__Native>>\nfunction mcrypt_module_is_block_mode(string $mode,\n                                     string $lib_dir= ''): bool;\n\n/**\n * Opens the module of the algorithm and the mode to be used\n *\n * @param string $algorithm -\n * @param string $algorithm_directory - The algorithm_directory parameter\n *   is used to locate the encryption module. When you supply a directory\n *   name, it is used. When you set it to an empty string (\"\"), the value\n *   set by the mcrypt.algorithms_dir directive is used. When it is not\n *   set, the default directory that is used is the one that was compiled\n *   into libmcrypt (usually /usr/local/lib/libmcrypt).\n * @param string $mode -\n * @param string $mode_directory - The mode_directory parameter is used\n *   to locate the encryption module. When you supply a directory name, it\n *   is used. When you set it to an empty string (\"\"), the value set by the\n *   mcrypt.modes_dir directive is used. When it is not set, the default\n *   directory that is used is the one that was compiled-in into libmcrypt\n *   (usually /usr/local/lib/libmcrypt).\n *\n * @return resource - Normally it returns an encryption descriptor, or\n *   FALSE on error.\n */\n<<__Native>>\nfunction mcrypt_module_open(string $algorithm,\n                            string $algorithm_directory,\n                            string $mode,\n                            string $mode_directory): mixed;\n\n/**\n * This function runs a self test on the specified module\n *\n * @param string $algorithm -\n * @param string $lib_dir - The optional lib_dir parameter can contain\n *   the location where the algorithm module is on the system.\n *\n * @return bool - The function returns TRUE if the self test succeeds, or\n *   FALSE when it fails.\n */\n<<__Native>>\nfunction mcrypt_module_self_test(string $algorithm,\n                                 string $lib_dir = ''): bool;\n\n/**\n * Encrypts/decrypts data in OFB mode\n *\n * @param string $cipher -\n * @param string $key -\n * @param string $data -\n * @param int $mode -\n * @param string $iv -\n *\n * @return string -\n */\n<<__Native>>\nfunction mcrypt_ofb(string $cipher,\n                    string $key,\n                    string $data,\n                    mixed $mode,\n                    ?string $iv = null): mixed;\n\n/**\n * Decrypts data\n *\n * @param resource $td - An encryption descriptor returned by\n *   mcrypt_module_open()\n * @param string $data - Encrypted data.\n *\n * @return string -\n */\n<<__Native>>\nfunction mdecrypt_generic(resource $td,\n                          string $data): mixed;\n", "<?php\n\nfunction VS($x, $y) {\n  var_dump($x === $y);\n  if ($x !== $y) { echo \"Failed: $y\\n\"; echo \"Got: $x\\n\";\n                   var_dump(debug_backtrace()); }\n}\nfunction VERIFY($x) { VS($x != false, true); }\n\n//////////////////////////////////////////////////////////////////////\n\n$td = mcrypt_module_open(\"rijndael-256\", \"\", \"ofb\", \"\");\n$iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td),\n                                MCRYPT_DEV_RANDOM);\n$ks = mcrypt_enc_get_key_size($td);\n$key = substr(md5(\"very secret key\"), 0, $ks);\nmcrypt_generic_init($td, $key, $iv);\n$encrypted = mcrypt_generic($td, \"This is very important data\");\nVERIFY($encrypted !== \"This is very important data\");\nmcrypt_generic_deinit($td);\nmcrypt_generic_init($td, $key, $iv);\n$decrypted = mdecrypt_generic($td, $encrypted);\nmcrypt_generic_end($td);\nmcrypt_module_close($td);\n\nVS($decrypted, \"This is very important data\");\n\nVERIFY(in_array(\"blowfish\", mcrypt_list_algorithms()));\nVERIFY(in_array(\"cbc\", mcrypt_list_modes()));\nVS(mcrypt_module_get_algo_block_size(\"blowfish\"), 8);\nVS(mcrypt_module_get_algo_key_size(\"blowfish\"), 56);\n\nVS(mcrypt_module_get_supported_key_sizes(\"blowfish\"), array());\nVS(mcrypt_module_get_supported_key_sizes(\"twofish\"),\n   array(16, 24, 32));\n\nVS(mcrypt_module_is_block_algorithm_mode(\"cbc\"), true);\nVS(mcrypt_module_is_block_algorithm(\"blowfish\"), true);\nVS(mcrypt_module_is_block_mode(\"cbc\"), true);\nVS(mcrypt_module_self_test(MCRYPT_RIJNDAEL_128), true);\nVS(mcrypt_module_self_test(\"bogus\"), false);\n\n$text = \"boggles the inivisble monkey will rule the world\";\n$key = \"very secret key\";\n$iv_size = mcrypt_get_iv_size(MCRYPT_XTEA, MCRYPT_MODE_ECB);\n$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);\n$enc = mcrypt_encrypt(MCRYPT_XTEA, $key, $text, MCRYPT_MODE_ECB,\n                               $iv);\nVS(bin2hex($enc), \"f522c62002fa16129c8576bcddc6dd0f7ea81991103ba42962d94c8bfff3ee660d53b187d7e989540abf5a729c2f7baf\");\n$crypttext = mcrypt_decrypt(MCRYPT_XTEA, $key, $enc,\n                                     MCRYPT_MODE_ECB, $iv);\nVS($crypttext, $text);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_cbc(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_cbc(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS(trim((string)$decrypted), $CC);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_cfb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_cfb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS(trim((string)$decrypted), $CC);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_ecb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_ecb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS(trim((string)$decrypted), $CC);\n\n//////////////////////////////////////////////////////////////////////\n\n$key = \"123456789012345678901234567890123456789012345678901234567890\";\n$CC = \"4007000000027\";\n$encrypted =\n  mcrypt_ofb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $CC, MCRYPT_ENCRYPT, substr($key,32,16));\n$decrypted =\n  mcrypt_ofb(MCRYPT_RIJNDAEL_128, substr($key,0,32),\n               $encrypted, MCRYPT_DECRYPT, substr($key,32,16));\nVERIFY($encrypted !== $decrypted);\nVS($decrypted, $CC);\n\n//////////////////////////////////////////////////////////////////////\n\nVS(mcrypt_get_block_size(\"tripledes\", \"ecb\"), 8);\nmcrypt_get_block_size(\"tripledes\");\nVS(mcrypt_get_cipher_name(MCRYPT_TRIPLEDES), \"3DES\");\nVS(mcrypt_get_iv_size(MCRYPT_CAST_256, MCRYPT_MODE_CFB), 16);\nVS(mcrypt_get_iv_size(\"des\", \"ecb\"), 8);\nVS(mcrypt_get_key_size(\"tripledes\", \"ecb\"), 24);\n\n$td = mcrypt_module_open(\"cast-256\", \"\", \"cfb\", \"\");\nVS(mcrypt_enc_get_algorithms_name($td), \"CAST-256\");\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_get_block_size($td), 8);\n\n$td = mcrypt_module_open(\"cast-256\", \"\", \"cfb\", \"\");\nVS(mcrypt_enc_get_iv_size($td), 16);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_get_key_size($td), 24);\n\n$td = mcrypt_module_open(\"cast-256\", \"\", \"cfb\", \"\");\nVS(mcrypt_enc_get_modes_name($td), \"CFB\");\n\n$td = mcrypt_module_open(\"rijndael-256\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_get_supported_key_sizes($td),\n   array(16, 24, 32));\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_is_block_algorithm_mode($td), true);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_is_block_algorithm($td), true);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_is_block_mode($td), true);\n\n$td = mcrypt_module_open(\"tripledes\", \"\", \"ecb\", \"\");\nVS(mcrypt_enc_self_test($td), 0);\n", "bool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_cbc() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 60\n\nDeprecated: Function mcrypt_cbc() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 63\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_cfb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 73\n\nDeprecated: Function mcrypt_cfb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 76\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_ecb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 86\n\nDeprecated: Function mcrypt_ecb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 89\nbool(true)\nbool(true)\n\nDeprecated: Function mcrypt_ofb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 99\n\nDeprecated: Function mcrypt_ofb() is deprecated in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 102\nbool(true)\nbool(true)\nbool(true)\n\nWarning: mcrypt_get_block_size() expects exactly 2 parameters, 1 given in %s/test/slow/ext_mcrypt/ext_mcrypt.php on line 109\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\nbool(true)\n"], "filenames": ["hphp/runtime/ext/mcrypt/ext_mcrypt.cpp", "hphp/runtime/ext/mcrypt/ext_mcrypt.php", "hphp/test/slow/ext_mcrypt/ext_mcrypt.php", "hphp/test/slow/ext_mcrypt/ext_mcrypt.php.expectf"], "buggy_code_start_loc": [460, 300, 108, 40], "buggy_code_end_loc": [464, 301, 108, 40], "fixing_code_start_loc": [460, 300, 109, 41], "fixing_code_end_loc": [464, 301, 110, 43], "type": "CWE-843", "message": "mcrypt_get_block_size did not enforce that the provided \"module\" parameter was a string, leading to type confusion if other types of data were passed in. This issue affects HHVM versions prior to 3.9.5, all versions between 3.10.0 and 3.12.3 (inclusive), and all versions between 3.13.0 and 3.14.1 (inclusive).", "other": {"cve": {"id": "CVE-2016-1000005", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-19T13:15:10.837", "lastModified": "2020-03-05T18:16:33.920", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mcrypt_get_block_size did not enforce that the provided \"module\" parameter was a string, leading to type confusion if other types of data were passed in. This issue affects HHVM versions prior to 3.9.5, all versions between 3.10.0 and 3.12.3 (inclusive), and all versions between 3.13.0 and 3.14.1 (inclusive)."}, {"lang": "es", "value": "La funci\u00f3n mcrypt_get_block_size no aplicaba que el par\u00e1metro \"module\" provisto era una cadena, conllevando a una confusi\u00f3n de tipo si otros tipos de datos fueron pasados. Este problema afecta a HHVM versiones anteriores a 3.9.5, todas las versiones entre 3.10.0 y 3.12.3 (inclusive), y todas las versiones entre 3.13.0 y 3.14.1 (inclusive)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.9.5", "matchCriteriaId": "E7E30D34-CAAC-49B1-96A0-57DCFC1D06FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.10.0", "versionEndIncluding": "3.12.3", "matchCriteriaId": "38334FB4-2311-4E24-B1A8-A667A2DC7121"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13.0", "versionEndIncluding": "3.14.1", "matchCriteriaId": "7C0B828B-409C-4F67-82CD-FBE17BB084C0"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/39e7e177473350b3a5c34e8824af3b98e25efa89", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2016-1000005", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/39e7e177473350b3a5c34e8824af3b98e25efa89"}}