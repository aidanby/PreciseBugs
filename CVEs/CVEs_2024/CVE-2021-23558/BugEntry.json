{"buggy_code": ["{\r\n  \"name\": \"bmoor\",\r\n  \"version\": \"0.10.0\",\r\n  \"author\": \"Brian Heilman <das.ist.junk@gmail.com>\",\r\n  \"description\": \"A basic foundation for other libraries, establishing useful patterbs, and letting them be more.\",\r\n  \"license\": \"MIT\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git://github.com/b-heilman/bmoor.git\"\r\n  },\r\n  \"main\": \"src/index.js\",\r\n  \"dependencies\": {\r\n    \"uuid\": \"^3.4.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typescript-eslint/eslint-plugin\": \"^5.0.0\",\r\n    \"@typescript-eslint/parser\": \"^5.0.0\",\r\n    \"chai\": \"^4.2.0\",\r\n    \"eslint\": \"^8.0.0\",\r\n    \"eslint-config-prettier\": \"^8.3.0\",\r\n    \"eslint-plugin-prettier\": \"^4.0.0\",\r\n    \"jshint\": \"^2.13.1\",\r\n    \"jshint-stylish\": \"2.1.0\",\r\n    \"mocha\": \"^9.1.2\",\r\n    \"prettier\": \"2.4.1\",\r\n    \"sinon\": \"^7.5.0\",\r\n    \"typescript\": \"^4.4.4\",\r\n    \"yargs\": \"^15.3.1\"\r\n  },\r\n  \"scripts\": {\r\n    \"lint\": \"node ./node_modules/eslint/bin/eslint ./src\",\r\n    \"test\": \"npm run prettier && mocha --recursive \\\"./src/**/*.spec.js\\\"\",\r\n    \"prettier\": \"npx prettier --write ./src && npm run lint\"\r\n  }\r\n}\r\n", "/**\n * The core of bmoor's usefulness\n * @module bmoor\n **/\n\n/**\n * Tests if the value is undefined\n *\n * @function isUndefined\n * @param {*} value - The variable to test\n * @return {boolean}\n **/\nfunction isUndefined(value) {\n\treturn value === undefined;\n}\n\n/**\n * Tests if the value is not undefined\n *\n * @function isDefined\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isDefined(value) {\n\treturn value !== undefined;\n}\n\n/**\n * Tests if the value is a string\n *\n * @function isString\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Tests if the value is numeric\n *\n * @function isNumber\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isNumber(value) {\n\treturn typeof value === 'number';\n}\n\n/**\n * Tests if the value is a function\n *\n * @function isFuncion\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isFunction(value) {\n\treturn typeof value === 'function';\n}\n\n/**\n * Tests if the value is an object\n *\n * @function isObject\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isObject(value) {\n\treturn !!value && typeof value === 'object';\n}\n\n/**\n * Tests if the value is a boolean\n *\n * @function isBoolean\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isBoolean(value) {\n\treturn typeof value === 'boolean';\n}\n\n/**\n * Tests if the value can be used as an array\n *\n * @function isArrayLike\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isArrayLike(value) {\n\t// for me, if you have a length, I'm assuming you're array like, might change\n\tif (value) {\n\t\treturn (\n\t\t\tisObject(value) &&\n\t\t\t(value.length === 0 || (0 in value && value.length - 1 in value))\n\t\t);\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Tests if the value is an array\n *\n * @function isArray\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isArray(value) {\n\treturn value instanceof Array;\n}\n\n/**\n * Tests if the value has no content.\n * If an object, has no own properties.\n * If array, has length == 0.\n * If other, is not defined\n *\n * @function isEmpty\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isEmpty(value) {\n\tvar key;\n\n\tif (isObject(value)) {\n\t\tfor (key in value) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(value, key)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else if (isArrayLike(value)) {\n\t\treturn value.length === 0;\n\t} else {\n\t\treturn isUndefined(value);\n\t}\n\n\treturn true;\n}\n\nfunction parse(path) {\n\tif (!path) {\n\t\treturn [];\n\t} else if (isString(path)) {\n\t\t// this isn't perfect, I'm making it work with arrays though\n\t\tif (path.indexOf('[') !== -1) {\n\t\t\treturn path.match(/[^\\][.]+/g).map((d) => {\n\t\t\t\tif (d[0] === '\"' || d[0] === \"'\") {\n\t\t\t\t\treturn d.substring(1, d.length - 1);\n\t\t\t\t} else {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn path.split('.');\n\t\t}\n\t} else if (isArray(path)) {\n\t\treturn path.slice(0);\n\t} else {\n\t\tthrow new Error('unable to parse path: ' + path + ' : ' + typeof path);\n\t}\n}\n\n/**\n * Sets a value to a namespace, returns the old value\n *\n * @function set\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\n * @param {string|array} space The namespace\n * @param {*} value The value to set the namespace to\n * @return {*}\n **/\nfunction set(root, space, value) {\n\tvar i,\n\t\tc,\n\t\tval,\n\t\tnextSpace,\n\t\tcurSpace = root;\n\n\tspace = parse(space);\n\n\tval = space.pop();\n\n\tfor (i = 0, c = space.length; i < c; i++) {\n\t\tnextSpace = space[i];\n\n\t\tif (\n\t\t\tnextSpace === '__proto__' ||\n\t\t\tnextSpace === 'constructor' ||\n\t\t\tnextSpace === 'prototype'\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isUndefined(curSpace[nextSpace])) {\n\t\t\tcurSpace[nextSpace] = {};\n\t\t}\n\n\t\tcurSpace = curSpace[nextSpace];\n\t}\n\n\tcurSpace[val] = value;\n\n\treturn curSpace;\n}\n\nfunction _makeSetter(property, next) {\n\tif (\n\t\tproperty === '__proto__' ||\n\t\tproperty === 'constructor' ||\n\t\tproperty === 'prototype'\n\t) {\n\t\tthrow new Error('unable to access __proto__, constructor, prototype');\n\t}\n\n\tif (next) {\n\t\treturn function setter(ctx, value) {\n\t\t\tvar t = ctx[property];\n\n\t\t\tif (!t) {\n\t\t\t\tt = ctx[property] = {};\n\t\t\t}\n\n\t\t\treturn next(t, value);\n\t\t};\n\t} else {\n\t\treturn function (ctx, value) {\n\t\t\tctx[property] = value;\n\t\t\treturn ctx;\n\t\t};\n\t}\n}\n\nfunction makeSetter(space) {\n\tvar i,\n\t\tfn,\n\t\treadings = parse(space);\n\n\tfor (i = readings.length - 1; i > -1; i--) {\n\t\tfn = _makeSetter(readings[i], fn);\n\t}\n\n\treturn fn;\n}\n\n/**\n * get a value from a namespace, if it doesn't exist, the path will be created\n *\n * @function get\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\n * @param {string|array|function} space The namespace\n * @return {array}\n **/\nfunction get(root, path) {\n\tvar i,\n\t\tc,\n\t\tspace,\n\t\tnextSpace,\n\t\tcurSpace = root;\n\n\tif (!root) {\n\t\treturn root;\n\t}\n\n\tspace = parse(path);\n\tif (space.length) {\n\t\tfor (i = 0, c = space.length; i < c; i++) {\n\t\t\tnextSpace = space[i];\n\n\t\t\tif (\n\t\t\t\tnextSpace === '__proto__' ||\n\t\t\t\tnextSpace === 'constructor' ||\n\t\t\t\tnextSpace === 'prototype'\n\t\t\t) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isUndefined(curSpace[nextSpace])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurSpace = curSpace[nextSpace];\n\t\t}\n\t}\n\n\treturn curSpace;\n}\n\nfunction _makeGetter(property, next) {\n\tif (\n\t\tproperty === '__proto__' ||\n\t\tproperty === 'constructor' ||\n\t\tproperty === 'prototype'\n\t) {\n\t\tthrow new Error('unable to access __proto__, constructor, prototype');\n\t}\n\n\tif (next) {\n\t\treturn function getter(obj) {\n\t\t\ttry {\n\t\t\t\treturn next(obj[property]);\n\t\t\t} catch (ex) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn function getter(obj) {\n\t\t\ttry {\n\t\t\t\treturn obj[property];\n\t\t\t} catch (ex) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t};\n\t}\n}\n\nfunction makeGetter(path) {\n\tvar i,\n\t\tfn,\n\t\tspace = parse(path);\n\n\tif (space.length) {\n\t\tfor (i = space.length - 1; i > -1; i--) {\n\t\t\tfn = _makeGetter(space[i], fn);\n\t\t}\n\t} else {\n\t\treturn function (obj) {\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\treturn fn;\n}\n\n/**\n * Delete a namespace, returns the old value\n *\n * @function del\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\n * @param {string|array} space The namespace\n * @return {*}\n **/\nfunction del(root, space) {\n\tvar old,\n\t\tval,\n\t\tnextSpace,\n\t\tcurSpace = root;\n\n\tif (space && (isString(space) || isArrayLike(space))) {\n\t\tspace = parse(space);\n\n\t\tval = space.pop();\n\n\t\tfor (var i = 0; i < space.length; i++) {\n\t\t\tnextSpace = space[i];\n\n\t\t\tif (isUndefined(curSpace[nextSpace])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurSpace = curSpace[nextSpace];\n\t\t}\n\n\t\told = curSpace[val];\n\t\tdelete curSpace[val];\n\t}\n\n\treturn old;\n}\n\nmodule.exports = {\n\t// booleans\n\tisUndefined: isUndefined,\n\tisDefined: isDefined,\n\tisString: isString,\n\tisNumber: isNumber,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisBoolean: isBoolean,\n\tisArrayLike: isArrayLike,\n\tisArray: isArray,\n\tisEmpty: isEmpty,\n\t// access\n\tparse: parse,\n\tset: set,\n\tmakeSetter: makeSetter,\n\tget: get,\n\tmakeGetter: makeGetter,\n\tdel: del\n};\n", "const {expect} = require('chai');\n\nconst bmoor = require('./index.js');\n\ndescribe('Testing object setting/getting', function () {\n\tdescribe('::get', function () {\n\t\tit('should be working', function () {\n\t\t\tvar t = {\n\t\t\t\teins: 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t};\n\n\t\t\texpect(bmoor.get(t, 'eins')).to.equal(1);\n\t\t\texpect(bmoor.get(t, 'zwei.drei')).to.equal(3);\n\t\t});\n\n\t\tit('should be working with empty strings', function () {\n\t\t\tvar t = {\n\t\t\t\teins: 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t};\n\n\t\t\texpect(bmoor.get(t, '')).to.equal(t);\n\t\t});\n\n\t\tit('should not allow __proto__', function () {\n\t\t\tvar t = bmoor.get({}, '__proto__');\n\n\t\t\texpect(t).to.equal(null);\n\t\t});\n\t});\n\n\tdescribe('::makeGetter', function () {\n\t\tit('should be working', function () {\n\t\t\tvar t = {\n\t\t\t\t\teins: 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tf1 = bmoor.makeGetter('eins'),\n\t\t\t\tf2 = bmoor.makeGetter('zwei.drei');\n\n\t\t\texpect(f1(t)).to.equal(1);\n\t\t\texpect(f2(t)).to.equal(3);\n\t\t});\n\n\t\tit('should fail with __proto__', function () {\n\t\t\tlet failed = false;\n\n\t\t\ttry {\n\t\t\t\tbmoor.makeGetter('__proto__.polluted');\n\t\t\t} catch (ex) {\n\t\t\t\tfailed = true;\n\t\t\t}\n\n\t\t\texpect(failed).to.equal(true);\n\t\t});\n\n\t\tit('should work with empty strings', function () {\n\t\t\tvar t = {\n\t\t\t\t\teins: 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tf1 = bmoor.makeGetter('');\n\n\t\t\texpect(f1(t)).to.equal(t);\n\t\t});\n\t});\n\n\tdescribe('::set', function () {\n\t\tit('should be working working', function () {\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t, 'eins', 1);\n\t\t\tbmoor.set(t, 'zwei.drei', 3);\n\n\t\t\texpect(t.eins).to.equal(1);\n\t\t\texpect(t.zwei.drei).to.equal(3);\n\t\t});\n\n\t\tit('should not allow __proto__', function () {\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t, '__proto__.polluted', true);\n\n\t\t\texpect(t.polluted).to.not.equal(true);\n\t\t});\n\t});\n\n\tdescribe('::makeSetter', function () {\n\t\tit('should actually work', function () {\n\t\t\tvar t = {},\n\t\t\t\tf1 = bmoor.makeSetter('eins'),\n\t\t\t\tf2 = bmoor.makeSetter('zwei.drei');\n\n\t\t\tf1(t, 1);\n\t\t\tf2(t, 3);\n\n\t\t\texpect(t.eins).to.equal(1);\n\t\t\texpect(t.zwei.drei).to.equal(3);\n\t\t});\n\n\t\tit('should fail with __proto__', function () {\n\t\t\tlet failed = false;\n\n\t\t\ttry {\n\t\t\t\tbmoor.makeGetter('__proto__.polluted');\n\t\t\t} catch (ex) {\n\t\t\t\tfailed = true;\n\t\t\t}\n\n\t\t\texpect(failed).to.equal(true);\n\t\t});\n\t});\n\n\tit('should have del working', function () {\n\t\tvar t = {\n\t\t\teins: 1,\n\t\t\tzwei: {\n\t\t\t\tdrei: 3\n\t\t\t}\n\t\t};\n\n\t\texpect(bmoor.del(t, 'eins')).to.equal(1);\n\t\texpect(bmoor.del(t, 'zwei.drei')).to.equal(3);\n\t\texpect(t.eins).to.not.exist;\n\t\texpect(t.zwei).to.exist;\n\t\texpect(t.zwei.drei).to.not.exist;\n\t});\n\n\tdescribe('::parse', function () {\n\t\tit('should parse an array correctly', function () {\n\t\t\texpect(bmoor.parse([1, 2, 3])).to.deep.equal([1, 2, 3]);\n\t\t});\n\n\t\tit('should parse dot notation correctly', function () {\n\t\t\texpect(bmoor.parse('1.2.3')).to.deep.equal(['1', '2', '3']);\n\t\t});\n\n\t\tit('should parse brackets correctly', function () {\n\t\t\texpect(bmoor.parse('[1][2][3]')).to.deep.equal(['1', '2', '3']);\n\t\t});\n\n\t\tit('should parse brackets with quotes correctly', function () {\n\t\t\texpect(bmoor.parse('[\\'1\\'][\"2\"][3]')).to.deep.equal(['1', '2', '3']);\n\t\t});\n\n\t\tit('should parse mixed correctly', function () {\n\t\t\texpect(bmoor.parse('foo[\"bar\"].ok[hello]')).to.deep.equal([\n\t\t\t\t'foo',\n\t\t\t\t'bar',\n\t\t\t\t'ok',\n\t\t\t\t'hello'\n\t\t\t]);\n\t\t});\n\t});\n});\n\ndescribe('Testing object functions', function () {\n\t// mask\n\tit('should allow for the creation of object from a base object', function () {\n\t\tvar t, v;\n\n\t\tfunction Foo(derp) {\n\t\t\tthis.woot = derp;\n\t\t}\n\n\t\tFoo.prototype.bar = 'yay';\n\n\t\tt = new Foo();\n\n\t\tv = bmoor.object.mask(t);\n\n\t\texpect(v.bar).to.equal('yay');\n\t});\n\n\t// extend\n\tit('should allow for objects to be extended by other objects', function () {\n\t\tvar t = {\n\t\t\tfoo: 1,\n\t\t\tbar: 2,\n\t\t\twoot: 3\n\t\t};\n\n\t\tbmoor.object.extend(\n\t\t\tt,\n\t\t\t{\n\t\t\t\tyay: 'sup',\n\t\t\t\tfoo: 'foo2'\n\t\t\t},\n\t\t\t{\n\t\t\t\twoot: '3!'\n\t\t\t}\n\t\t);\n\n\t\texpect(t.foo).to.equal('foo2');\n\t\texpect(t.woot).to.equal('3!');\n\t});\n\t// copy\n\t// TODO : yeah, need to do this one\n\n\t// equals\n\t// TODO : yeah, need to do this one\n\n\t// map\n\tit('should allow for the mapping of variables onto an object', function () {\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode(\n\t\t\t\t{\n\t\t\t\t\thello: 'world'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\teins: 1,\n\t\t\t\t\tzwei: 2,\n\t\t\t\t\tdrei: 3,\n\t\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t\t'help.me': o\n\t\t\t\t}\n\t\t\t);\n\n\t\texpect(t.eins).to.equal(1);\n\t\texpect(t.foo.bar).to.equal('woot');\n\t\texpect(t.hello).to.equal('world');\n\t\texpect(t.help.me).to.equal(o);\n\t});\n\n\tit('should allow for a new variable to be created from a map', function () {\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode(\n\t\t\t\t{},\n\t\t\t\t{\n\t\t\t\t\teins: 1,\n\t\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t\t'hello.world': o\n\t\t\t\t}\n\t\t\t);\n\n\t\texpect(t.eins, 1);\n\t\texpect(t.foo.bar, 'woot');\n\t\texpect(t.hello.world).to.equal(o);\n\t});\n\n\t/*\n\tdescribe('override', function(){\n\t\tit( 'should prune old properties', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbmoor.object.override( t, {\n\t\t\t\tdrei : 3\n\t\t\t});\n\n\t\t\texpect( t.eins ).to.not.to.exist;\n\t\t\texpect( t.zwei ).to.not.to.exist;\n\t\t\texpect( t.drei ).to.equal( 3 );\n\t\t});\n\n\t\tit( 'should handle shallow object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'woot' );\n\t\t});\n\n\t\tit( 'should handle deep object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o, true );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'world' );\n\t\t});\n\t});\n\t*/\n\tit('should allow for data to be merged', function () {\n\t\tvar t = {\n\t\t\teins: 1,\n\t\t\tzwei: {\n\t\t\t\tfoo: 1,\n\t\t\t\tbar: 2\n\t\t\t},\n\t\t\tdrei: 3\n\t\t};\n\n\t\tbmoor.object.merge(t, {\n\t\t\teins: 2,\n\t\t\tzwei: {\n\t\t\t\tfoo: 2\n\t\t\t},\n\t\t\tfier: 4\n\t\t});\n\n\t\texpect(t.eins).to.equal(2);\n\t\texpect(t.zwei).to.to.exist;\n\t\texpect(t.zwei.foo).to.equal(2);\n\t\texpect(t.drei).to.equal(3);\n\t\texpect(t.fier).to.equal(4);\n\t});\n});\n\ndescribe('Testing the test functions', function () {\n\t// isBoolean\n\tit('should be able to test booleans', function () {\n\t\texpect(bmoor.isBoolean(true)).to.equal(true);\n\t\texpect(bmoor.isBoolean(false)).to.equal(true);\n\t\texpect(bmoor.isBoolean(1)).to.equal(false);\n\t\texpect(bmoor.isBoolean(0)).to.equal(false);\n\t});\n\t// isDefined\n\tit('should be able to test for variables being defined', function () {\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect(bmoor.isDefined(true)).to.equal(true);\n\t\texpect(bmoor.isDefined(false)).to.equal(true);\n\t\texpect(bmoor.isDefined(1)).to.equal(true);\n\t\texpect(bmoor.isDefined(0)).to.equal(true);\n\t\texpect(bmoor.isDefined(n)).to.equal(true);\n\t\texpect(bmoor.isDefined(t)).to.equal(false);\n\t});\n\t// isUndefined\n\tit('should be able to test for variables being undefined', function () {\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect(bmoor.isUndefined(true)).to.equal(false);\n\t\texpect(bmoor.isUndefined(false)).to.equal(false);\n\t\texpect(bmoor.isUndefined(1)).to.equal(false);\n\t\texpect(bmoor.isUndefined(0)).to.equal(false);\n\t\texpect(bmoor.isUndefined(n)).to.equal(false);\n\t\texpect(bmoor.isUndefined(t)).to.equal(true);\n\t});\n\t// isArray\n\tit('should be able to test for variables being arrays', function () {\n\t\texpect(bmoor.isArray([])).to.equal(true);\n\t\texpect(bmoor.isArray({})).to.equal(false);\n\t\texpect(bmoor.isArray(1)).to.equal(false);\n\t\texpect(bmoor.isArray({length: 0})).to.equal(false);\n\t\texpect(bmoor.isArray('')).to.equal(false);\n\t});\n\t// isArrayLike\n\tit('should be able to test for variables being array like', function () {\n\t\texpect(bmoor.isArrayLike([])).to.equal(true);\n\t\texpect(bmoor.isArrayLike({})).to.equal(false);\n\t\texpect(bmoor.isArrayLike(1)).to.equal(false);\n\t\texpect(bmoor.isArrayLike({length: 0})).to.equal(true);\n\t\texpect(bmoor.isArrayLike('')).to.equal(false);\n\t});\n\t// isObject\n\tit('should be able to test for variables being an object', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isObject([])).to.equal(true);\n\t\texpect(bmoor.isObject({})).to.equal(true);\n\t\texpect(bmoor.isObject(1)).to.equal(false);\n\t\texpect(bmoor.isObject(false)).to.equal(false);\n\t\texpect(bmoor.isObject(Temp)).to.equal(false);\n\t\texpect(bmoor.isObject(t)).to.equal(true);\n\t\texpect(bmoor.isObject('')).to.equal(false);\n\t});\n\t// isFunction\n\tit('should be able to test for variables being a function', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isFunction([])).to.equal(false);\n\t\texpect(bmoor.isFunction({})).to.equal(false);\n\t\texpect(bmoor.isFunction(1)).to.equal(false);\n\t\texpect(bmoor.isFunction(false)).to.equal(false);\n\t\texpect(bmoor.isFunction(Temp)).to.equal(true);\n\t\texpect(bmoor.isFunction(t)).to.equal(false);\n\t\texpect(bmoor.isFunction('')).to.equal(false);\n\t});\n\t// isNumber\n\tit('should be able to test for variables being a number', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isNumber([])).to.equal(false);\n\t\texpect(bmoor.isNumber({})).to.equal(false);\n\t\texpect(bmoor.isNumber(1)).to.equal(true);\n\t\texpect(bmoor.isNumber(false)).to.equal(false);\n\t\texpect(bmoor.isNumber(Temp)).to.equal(false);\n\t\texpect(bmoor.isNumber(t)).to.equal(false);\n\t\texpect(bmoor.isNumber('')).to.equal(false);\n\t});\n\n\t// isString\n\tit('should be able to test for variables being a function', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isString([])).to.equal(false);\n\t\texpect(bmoor.isString({})).to.equal(false);\n\t\texpect(bmoor.isString(1)).to.equal(false);\n\t\texpect(bmoor.isString(false)).to.equal(false);\n\t\texpect(bmoor.isString(Temp)).to.equal(false);\n\t\texpect(bmoor.isString(t)).to.equal(false);\n\t\texpect(bmoor.isString('')).to.equal(true);\n\t});\n\n\t// isEmpty\n\tit('should be able to test for variables being a function', function () {\n\t\tvar t;\n\n\t\texpect(bmoor.isEmpty([])).to.equal(true);\n\t\texpect(bmoor.isEmpty({})).to.equal(true);\n\t\texpect(bmoor.isEmpty(0)).to.equal(false);\n\t\texpect(bmoor.isEmpty(t)).to.equal(true);\n\t\texpect(bmoor.isEmpty(null)).to.equal(false);\n\t\texpect(bmoor.isEmpty([0])).to.equal(false);\n\t\texpect(bmoor.isEmpty({v: 0})).to.equal(false);\n\t});\n});\n"], "fixing_code": ["{\r\n  \"name\": \"bmoor\",\r\n  \"version\": \"0.10.1\",\r\n  \"author\": \"Brian Heilman <das.ist.junk@gmail.com>\",\r\n  \"description\": \"A basic foundation for other libraries, establishing useful patterbs, and letting them be more.\",\r\n  \"license\": \"MIT\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git://github.com/b-heilman/bmoor.git\"\r\n  },\r\n  \"main\": \"src/index.js\",\r\n  \"dependencies\": {\r\n    \"uuid\": \"^3.4.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typescript-eslint/eslint-plugin\": \"^5.0.0\",\r\n    \"@typescript-eslint/parser\": \"^5.0.0\",\r\n    \"chai\": \"^4.2.0\",\r\n    \"eslint\": \"^8.0.0\",\r\n    \"eslint-config-prettier\": \"^8.3.0\",\r\n    \"eslint-plugin-prettier\": \"^4.0.0\",\r\n    \"jshint\": \"^2.13.1\",\r\n    \"jshint-stylish\": \"2.1.0\",\r\n    \"mocha\": \"^9.1.2\",\r\n    \"prettier\": \"2.4.1\",\r\n    \"sinon\": \"^7.5.0\",\r\n    \"typescript\": \"^4.4.4\",\r\n    \"yargs\": \"^15.3.1\"\r\n  },\r\n  \"scripts\": {\r\n    \"lint\": \"node ./node_modules/eslint/bin/eslint ./src\",\r\n    \"test\": \"mocha --recursive \\\"./src/**/*.spec.js\\\"\",\r\n    \"prettier\": \"npx prettier --write ./src\",\r\n    \"finalize\": \"npm run lint && npm run prettier && npm run test\"\r\n  }\r\n}\r\n", "/**\n * The core of bmoor's usefulness\n * @module bmoor\n **/\n\n/**\n * Tests if the value is undefined\n *\n * @function isUndefined\n * @param {*} value - The variable to test\n * @return {boolean}\n **/\nfunction isUndefined(value) {\n\treturn value === undefined;\n}\n\n/**\n * Tests if the value is not undefined\n *\n * @function isDefined\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isDefined(value) {\n\treturn value !== undefined;\n}\n\n/**\n * Tests if the value is a string\n *\n * @function isString\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Tests if the value is numeric\n *\n * @function isNumber\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isNumber(value) {\n\treturn typeof value === 'number';\n}\n\n/**\n * Tests if the value is a function\n *\n * @function isFuncion\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isFunction(value) {\n\treturn typeof value === 'function';\n}\n\n/**\n * Tests if the value is an object\n *\n * @function isObject\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isObject(value) {\n\treturn !!value && typeof value === 'object';\n}\n\n/**\n * Tests if the value is a boolean\n *\n * @function isBoolean\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isBoolean(value) {\n\treturn typeof value === 'boolean';\n}\n\n/**\n * Tests if the value can be used as an array\n *\n * @function isArrayLike\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isArrayLike(value) {\n\t// for me, if you have a length, I'm assuming you're array like, might change\n\tif (value) {\n\t\treturn (\n\t\t\tisObject(value) &&\n\t\t\t(value.length === 0 || (0 in value && value.length - 1 in value))\n\t\t);\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Tests if the value is an array\n *\n * @function isArray\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isArray(value) {\n\treturn value instanceof Array;\n}\n\n/**\n * Tests if the value has no content.\n * If an object, has no own properties.\n * If array, has length == 0.\n * If other, is not defined\n *\n * @function isEmpty\n * @param {*} value The variable to test\n * @return {boolean}\n **/\nfunction isEmpty(value) {\n\tvar key;\n\n\tif (isObject(value)) {\n\t\tfor (key in value) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(value, key)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else if (isArrayLike(value)) {\n\t\treturn value.length === 0;\n\t} else {\n\t\treturn isUndefined(value);\n\t}\n\n\treturn true;\n}\n\nfunction parse(path) {\n\tif (!path) {\n\t\treturn [];\n\t} else if (isString(path)) {\n\t\t// this isn't perfect, I'm making it work with arrays though\n\t\tif (path.indexOf('[') !== -1) {\n\t\t\treturn path.match(/[^\\][.]+/g).map((d) => {\n\t\t\t\tif (d[0] === '\"' || d[0] === \"'\") {\n\t\t\t\t\treturn d.substring(1, d.length - 1);\n\t\t\t\t} else {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn path.split('.');\n\t\t}\n\t} else if (isArray(path)) {\n\t\treturn path.slice(0);\n\t} else {\n\t\tthrow new Error('unable to parse path: ' + path + ' : ' + typeof path);\n\t}\n}\n\n/**\n * Sets a value to a namespace, returns the old value\n *\n * @function set\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\n * @param {string|array} space The namespace\n * @param {*} value The value to set the namespace to\n * @return {*}\n **/\nfunction set(root, space, value) {\n\tvar i,\n\t\tc,\n\t\tval,\n\t\tnextSpace,\n\t\tcurSpace = root;\n\n\tspace = parse(space);\n\n\tval = space.pop();\n\n\tfor (i = 0, c = space.length; i < c; i++) {\n\t\tnextSpace = String(space[i]);\n\n\t\tif (\n\t\t\tnextSpace === '__proto__' ||\n\t\t\tnextSpace === 'constructor' ||\n\t\t\tnextSpace === 'prototype'\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isUndefined(curSpace[nextSpace])) {\n\t\t\tcurSpace[nextSpace] = {};\n\t\t}\n\n\t\tcurSpace = curSpace[nextSpace];\n\t}\n\n\tcurSpace[val] = value;\n\n\treturn curSpace;\n}\n\nfunction _makeSetter(property, next) {\n\tproperty = String(property);\n\n\tif (\n\t\tproperty === '__proto__' ||\n\t\tproperty === 'constructor' ||\n\t\tproperty === 'prototype'\n\t) {\n\t\tthrow new Error('unable to access __proto__, constructor, prototype');\n\t}\n\n\tif (next) {\n\t\treturn function setter(ctx, value) {\n\t\t\tvar t = ctx[property];\n\n\t\t\tif (!t) {\n\t\t\t\tt = ctx[property] = {};\n\t\t\t}\n\n\t\t\treturn next(t, value);\n\t\t};\n\t} else {\n\t\treturn function (ctx, value) {\n\t\t\tctx[property] = value;\n\t\t\treturn ctx;\n\t\t};\n\t}\n}\n\nfunction makeSetter(space) {\n\tvar i,\n\t\tfn,\n\t\treadings = parse(space);\n\n\tfor (i = readings.length - 1; i > -1; i--) {\n\t\tfn = _makeSetter(readings[i], fn);\n\t}\n\n\treturn fn;\n}\n\n/**\n * get a value from a namespace, if it doesn't exist, the path will be created\n *\n * @function get\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\n * @param {string|array|function} space The namespace\n * @return {array}\n **/\nfunction get(root, path) {\n\tvar i,\n\t\tc,\n\t\tspace,\n\t\tnextSpace,\n\t\tcurSpace = root;\n\n\tif (!root) {\n\t\treturn root;\n\t}\n\n\tspace = parse(path);\n\tif (space.length) {\n\t\tfor (i = 0, c = space.length; i < c; i++) {\n\t\t\tnextSpace = String(space[i]);\n\n\t\t\tif (\n\t\t\t\tnextSpace === '__proto__' ||\n\t\t\t\tnextSpace === 'constructor' ||\n\t\t\t\tnextSpace === 'prototype'\n\t\t\t) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isUndefined(curSpace[nextSpace])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurSpace = curSpace[nextSpace];\n\t\t}\n\t}\n\n\treturn curSpace;\n}\n\nfunction _makeGetter(property, next) {\n\tproperty = String(property);\n\n\tif (\n\t\tproperty === '__proto__' ||\n\t\tproperty === 'constructor' ||\n\t\tproperty === 'prototype'\n\t) {\n\t\tthrow new Error('unable to access __proto__, constructor, prototype');\n\t}\n\n\tif (next) {\n\t\treturn function getter(obj) {\n\t\t\ttry {\n\t\t\t\treturn next(obj[property]);\n\t\t\t} catch (ex) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t};\n\t} else {\n\t\treturn function getter(obj) {\n\t\t\ttry {\n\t\t\t\treturn obj[property];\n\t\t\t} catch (ex) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t};\n\t}\n}\n\nfunction makeGetter(path) {\n\tvar i,\n\t\tfn,\n\t\tspace = parse(path);\n\n\tif (space.length) {\n\t\tfor (i = space.length - 1; i > -1; i--) {\n\t\t\tfn = _makeGetter(space[i], fn);\n\t\t}\n\t} else {\n\t\treturn function (obj) {\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\treturn fn;\n}\n\n/**\n * Delete a namespace, returns the old value\n *\n * @function del\n * @param {object} root The root of the namespace, bMoor.namespace.root if not defined\n * @param {string|array} space The namespace\n * @return {*}\n **/\nfunction del(root, space) {\n\tvar old,\n\t\tval,\n\t\tnextSpace,\n\t\tcurSpace = root;\n\n\tif (space && (isString(space) || isArrayLike(space))) {\n\t\tspace = parse(space);\n\n\t\tval = space.pop();\n\n\t\tfor (var i = 0; i < space.length; i++) {\n\t\t\tnextSpace = space[i];\n\n\t\t\tif (isUndefined(curSpace[nextSpace])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurSpace = curSpace[nextSpace];\n\t\t}\n\n\t\told = curSpace[val];\n\t\tdelete curSpace[val];\n\t}\n\n\treturn old;\n}\n\nmodule.exports = {\n\t// booleans\n\tisUndefined: isUndefined,\n\tisDefined: isDefined,\n\tisString: isString,\n\tisNumber: isNumber,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisBoolean: isBoolean,\n\tisArrayLike: isArrayLike,\n\tisArray: isArray,\n\tisEmpty: isEmpty,\n\t// access\n\tparse: parse,\n\tset: set,\n\tmakeSetter: makeSetter,\n\tget: get,\n\tmakeGetter: makeGetter,\n\tdel: del\n};\n", "const {expect} = require('chai');\n\nconst bmoor = require('./index.js');\n\ndescribe('Testing object setting/getting', function () {\n\tdescribe('::get', function () {\n\t\tit('should be working', function () {\n\t\t\tvar t = {\n\t\t\t\teins: 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t};\n\n\t\t\texpect(bmoor.get(t, 'eins')).to.equal(1);\n\t\t\texpect(bmoor.get(t, 'zwei.drei')).to.equal(3);\n\t\t});\n\n\t\tit('should be working with empty strings', function () {\n\t\t\tvar t = {\n\t\t\t\teins: 1,\n\t\t\t\tzwei: {\n\t\t\t\t\tdrei: 3\n\t\t\t\t}\n\t\t\t};\n\n\t\t\texpect(bmoor.get(t, '')).to.equal(t);\n\t\t});\n\n\t\tit('should not allow __proto__', function () {\n\t\t\tvar t = bmoor.get({}, '__proto__');\n\n\t\t\texpect(t).to.equal(null);\n\t\t});\n\t});\n\n\tdescribe('::makeGetter', function () {\n\t\tit('should be working', function () {\n\t\t\tvar t = {\n\t\t\t\t\teins: 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tf1 = bmoor.makeGetter('eins'),\n\t\t\t\tf2 = bmoor.makeGetter('zwei.drei');\n\n\t\t\texpect(f1(t)).to.equal(1);\n\t\t\texpect(f2(t)).to.equal(3);\n\t\t});\n\n\t\tit('should fail with __proto__', function () {\n\t\t\tlet failed = false;\n\n\t\t\ttry {\n\t\t\t\tbmoor.makeGetter('__proto__.polluted');\n\t\t\t} catch (ex) {\n\t\t\t\tfailed = true;\n\t\t\t}\n\n\t\t\texpect(failed).to.equal(true);\n\t\t});\n\n\t\tit('should work with empty strings', function () {\n\t\t\tvar t = {\n\t\t\t\t\teins: 1,\n\t\t\t\t\tzwei: {\n\t\t\t\t\t\tdrei: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tf1 = bmoor.makeGetter('');\n\n\t\t\texpect(f1(t)).to.equal(t);\n\t\t});\n\t});\n\n\tdescribe('::set', function () {\n\t\tit('should be working working', function () {\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t, 'eins', 1);\n\t\t\tbmoor.set(t, 'zwei.drei', 3);\n\n\t\t\texpect(t.eins).to.equal(1);\n\t\t\texpect(t.zwei.drei).to.equal(3);\n\t\t});\n\n\t\tit('should not allow __proto__', function () {\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t, '__proto__.polluted', true);\n\n\t\t\texpect(t.polluted).to.not.equal(true);\n\t\t});\n\n\t\tit('should not allow __proto__ when in array', function () {\n\t\t\tvar t = {};\n\n\t\t\tbmoor.set(t, [['__proto__'], 'polluted'], 'polluted');\n\n\t\t\texpect(t.polluted).to.not.equal('polluted');\n\t\t});\n\t});\n\n\tdescribe('::makeSetter', function () {\n\t\tit('should actually work', function () {\n\t\t\tvar t = {},\n\t\t\t\tf1 = bmoor.makeSetter('eins'),\n\t\t\t\tf2 = bmoor.makeSetter('zwei.drei');\n\n\t\t\tf1(t, 1);\n\t\t\tf2(t, 3);\n\n\t\t\texpect(t.eins).to.equal(1);\n\t\t\texpect(t.zwei.drei).to.equal(3);\n\t\t});\n\n\t\tit('should fail with __proto__', function () {\n\t\t\tlet failed = false;\n\n\t\t\ttry {\n\t\t\t\tbmoor.makeGetter('__proto__.polluted');\n\t\t\t} catch (ex) {\n\t\t\t\tfailed = true;\n\t\t\t}\n\n\t\t\texpect(failed).to.equal(true);\n\t\t});\n\t});\n\n\tit('should have del working', function () {\n\t\tvar t = {\n\t\t\teins: 1,\n\t\t\tzwei: {\n\t\t\t\tdrei: 3\n\t\t\t}\n\t\t};\n\n\t\texpect(bmoor.del(t, 'eins')).to.equal(1);\n\t\texpect(bmoor.del(t, 'zwei.drei')).to.equal(3);\n\t\texpect(t.eins).to.not.exist;\n\t\texpect(t.zwei).to.exist;\n\t\texpect(t.zwei.drei).to.not.exist;\n\t});\n\n\tdescribe('::parse', function () {\n\t\tit('should parse an array correctly', function () {\n\t\t\texpect(bmoor.parse([1, 2, 3])).to.deep.equal([1, 2, 3]);\n\t\t});\n\n\t\tit('should parse dot notation correctly', function () {\n\t\t\texpect(bmoor.parse('1.2.3')).to.deep.equal(['1', '2', '3']);\n\t\t});\n\n\t\tit('should parse brackets correctly', function () {\n\t\t\texpect(bmoor.parse('[1][2][3]')).to.deep.equal(['1', '2', '3']);\n\t\t});\n\n\t\tit('should parse brackets with quotes correctly', function () {\n\t\t\texpect(bmoor.parse('[\\'1\\'][\"2\"][3]')).to.deep.equal(['1', '2', '3']);\n\t\t});\n\n\t\tit('should parse mixed correctly', function () {\n\t\t\texpect(bmoor.parse('foo[\"bar\"].ok[hello]')).to.deep.equal([\n\t\t\t\t'foo',\n\t\t\t\t'bar',\n\t\t\t\t'ok',\n\t\t\t\t'hello'\n\t\t\t]);\n\t\t});\n\t});\n});\n\ndescribe('Testing object functions', function () {\n\t// mask\n\tit('should allow for the creation of object from a base object', function () {\n\t\tvar t, v;\n\n\t\tfunction Foo(derp) {\n\t\t\tthis.woot = derp;\n\t\t}\n\n\t\tFoo.prototype.bar = 'yay';\n\n\t\tt = new Foo();\n\n\t\tv = bmoor.object.mask(t);\n\n\t\texpect(v.bar).to.equal('yay');\n\t});\n\n\t// extend\n\tit('should allow for objects to be extended by other objects', function () {\n\t\tvar t = {\n\t\t\tfoo: 1,\n\t\t\tbar: 2,\n\t\t\twoot: 3\n\t\t};\n\n\t\tbmoor.object.extend(\n\t\t\tt,\n\t\t\t{\n\t\t\t\tyay: 'sup',\n\t\t\t\tfoo: 'foo2'\n\t\t\t},\n\t\t\t{\n\t\t\t\twoot: '3!'\n\t\t\t}\n\t\t);\n\n\t\texpect(t.foo).to.equal('foo2');\n\t\texpect(t.woot).to.equal('3!');\n\t});\n\t// copy\n\t// TODO : yeah, need to do this one\n\n\t// equals\n\t// TODO : yeah, need to do this one\n\n\t// map\n\tit('should allow for the mapping of variables onto an object', function () {\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode(\n\t\t\t\t{\n\t\t\t\t\thello: 'world'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\teins: 1,\n\t\t\t\t\tzwei: 2,\n\t\t\t\t\tdrei: 3,\n\t\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t\t'help.me': o\n\t\t\t\t}\n\t\t\t);\n\n\t\texpect(t.eins).to.equal(1);\n\t\texpect(t.foo.bar).to.equal('woot');\n\t\texpect(t.hello).to.equal('world');\n\t\texpect(t.help.me).to.equal(o);\n\t});\n\n\tit('should allow for a new variable to be created from a map', function () {\n\t\tvar o = {},\n\t\t\tt = bmoor.object.explode(\n\t\t\t\t{},\n\t\t\t\t{\n\t\t\t\t\teins: 1,\n\t\t\t\t\t'foo.bar': 'woot',\n\t\t\t\t\t'hello.world': o\n\t\t\t\t}\n\t\t\t);\n\n\t\texpect(t.eins, 1);\n\t\texpect(t.foo.bar, 'woot');\n\t\texpect(t.hello.world).to.equal(o);\n\t});\n\n\t/*\n\tdescribe('override', function(){\n\t\tit( 'should prune old properties', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbmoor.object.override( t, {\n\t\t\t\tdrei : 3\n\t\t\t});\n\n\t\t\texpect( t.eins ).to.not.to.exist;\n\t\t\texpect( t.zwei ).to.not.to.exist;\n\t\t\texpect( t.drei ).to.equal( 3 );\n\t\t});\n\n\t\tit( 'should handle shallow object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'woot' );\n\t\t});\n\n\t\tit( 'should handle deep object copy', function(){\n\t\t\tvar t = {\n\t\t\t\t\teins : 1,\n\t\t\t\t\tzwei : {\n\t\t\t\t\t\tfoo : 1,\n\t\t\t\t\t\tbar : 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\to = {\n\t\t\t\t\tdrei : {\n\t\t\t\t\t\thello: 'world'\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tbmoor.object.override( t, o, true );\n\n\t\t\to.drei.hello = 'woot';\n\n\t\t\texpect( t.drei.hello ).to.equal( 'world' );\n\t\t});\n\t});\n\t*/\n\tit('should allow for data to be merged', function () {\n\t\tvar t = {\n\t\t\teins: 1,\n\t\t\tzwei: {\n\t\t\t\tfoo: 1,\n\t\t\t\tbar: 2\n\t\t\t},\n\t\t\tdrei: 3\n\t\t};\n\n\t\tbmoor.object.merge(t, {\n\t\t\teins: 2,\n\t\t\tzwei: {\n\t\t\t\tfoo: 2\n\t\t\t},\n\t\t\tfier: 4\n\t\t});\n\n\t\texpect(t.eins).to.equal(2);\n\t\texpect(t.zwei).to.to.exist;\n\t\texpect(t.zwei.foo).to.equal(2);\n\t\texpect(t.drei).to.equal(3);\n\t\texpect(t.fier).to.equal(4);\n\t});\n});\n\ndescribe('Testing the test functions', function () {\n\t// isBoolean\n\tit('should be able to test booleans', function () {\n\t\texpect(bmoor.isBoolean(true)).to.equal(true);\n\t\texpect(bmoor.isBoolean(false)).to.equal(true);\n\t\texpect(bmoor.isBoolean(1)).to.equal(false);\n\t\texpect(bmoor.isBoolean(0)).to.equal(false);\n\t});\n\t// isDefined\n\tit('should be able to test for variables being defined', function () {\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect(bmoor.isDefined(true)).to.equal(true);\n\t\texpect(bmoor.isDefined(false)).to.equal(true);\n\t\texpect(bmoor.isDefined(1)).to.equal(true);\n\t\texpect(bmoor.isDefined(0)).to.equal(true);\n\t\texpect(bmoor.isDefined(n)).to.equal(true);\n\t\texpect(bmoor.isDefined(t)).to.equal(false);\n\t});\n\t// isUndefined\n\tit('should be able to test for variables being undefined', function () {\n\t\tvar n = {},\n\t\t\tt;\n\n\t\texpect(bmoor.isUndefined(true)).to.equal(false);\n\t\texpect(bmoor.isUndefined(false)).to.equal(false);\n\t\texpect(bmoor.isUndefined(1)).to.equal(false);\n\t\texpect(bmoor.isUndefined(0)).to.equal(false);\n\t\texpect(bmoor.isUndefined(n)).to.equal(false);\n\t\texpect(bmoor.isUndefined(t)).to.equal(true);\n\t});\n\t// isArray\n\tit('should be able to test for variables being arrays', function () {\n\t\texpect(bmoor.isArray([])).to.equal(true);\n\t\texpect(bmoor.isArray({})).to.equal(false);\n\t\texpect(bmoor.isArray(1)).to.equal(false);\n\t\texpect(bmoor.isArray({length: 0})).to.equal(false);\n\t\texpect(bmoor.isArray('')).to.equal(false);\n\t});\n\t// isArrayLike\n\tit('should be able to test for variables being array like', function () {\n\t\texpect(bmoor.isArrayLike([])).to.equal(true);\n\t\texpect(bmoor.isArrayLike({})).to.equal(false);\n\t\texpect(bmoor.isArrayLike(1)).to.equal(false);\n\t\texpect(bmoor.isArrayLike({length: 0})).to.equal(true);\n\t\texpect(bmoor.isArrayLike('')).to.equal(false);\n\t});\n\t// isObject\n\tit('should be able to test for variables being an object', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isObject([])).to.equal(true);\n\t\texpect(bmoor.isObject({})).to.equal(true);\n\t\texpect(bmoor.isObject(1)).to.equal(false);\n\t\texpect(bmoor.isObject(false)).to.equal(false);\n\t\texpect(bmoor.isObject(Temp)).to.equal(false);\n\t\texpect(bmoor.isObject(t)).to.equal(true);\n\t\texpect(bmoor.isObject('')).to.equal(false);\n\t});\n\t// isFunction\n\tit('should be able to test for variables being a function', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isFunction([])).to.equal(false);\n\t\texpect(bmoor.isFunction({})).to.equal(false);\n\t\texpect(bmoor.isFunction(1)).to.equal(false);\n\t\texpect(bmoor.isFunction(false)).to.equal(false);\n\t\texpect(bmoor.isFunction(Temp)).to.equal(true);\n\t\texpect(bmoor.isFunction(t)).to.equal(false);\n\t\texpect(bmoor.isFunction('')).to.equal(false);\n\t});\n\t// isNumber\n\tit('should be able to test for variables being a number', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isNumber([])).to.equal(false);\n\t\texpect(bmoor.isNumber({})).to.equal(false);\n\t\texpect(bmoor.isNumber(1)).to.equal(true);\n\t\texpect(bmoor.isNumber(false)).to.equal(false);\n\t\texpect(bmoor.isNumber(Temp)).to.equal(false);\n\t\texpect(bmoor.isNumber(t)).to.equal(false);\n\t\texpect(bmoor.isNumber('')).to.equal(false);\n\t});\n\n\t// isString\n\tit('should be able to test for variables being a function', function () {\n\t\tfunction Temp() {}\n\t\tvar t = new Temp();\n\n\t\texpect(bmoor.isString([])).to.equal(false);\n\t\texpect(bmoor.isString({})).to.equal(false);\n\t\texpect(bmoor.isString(1)).to.equal(false);\n\t\texpect(bmoor.isString(false)).to.equal(false);\n\t\texpect(bmoor.isString(Temp)).to.equal(false);\n\t\texpect(bmoor.isString(t)).to.equal(false);\n\t\texpect(bmoor.isString('')).to.equal(true);\n\t});\n\n\t// isEmpty\n\tit('should be able to test for variables being a function', function () {\n\t\tvar t;\n\n\t\texpect(bmoor.isEmpty([])).to.equal(true);\n\t\texpect(bmoor.isEmpty({})).to.equal(true);\n\t\texpect(bmoor.isEmpty(0)).to.equal(false);\n\t\texpect(bmoor.isEmpty(t)).to.equal(true);\n\t\texpect(bmoor.isEmpty(null)).to.equal(false);\n\t\texpect(bmoor.isEmpty([0])).to.equal(false);\n\t\texpect(bmoor.isEmpty({v: 0})).to.equal(false);\n\t});\n});\n"], "filenames": ["package.json", "src/core.js", "src/core.spec.js"], "buggy_code_start_loc": [3, 185, 93], "buggy_code_end_loc": [34, 289, 93], "fixing_code_start_loc": [3, 185, 94], "fixing_code_end_loc": [35, 294, 102], "type": "CWE-1321", "message": "The package bmoor before 0.10.1 are vulnerable to Prototype Pollution due to missing sanitization in set function. **Note:** This vulnerability derives from an incomplete fix in [CVE-2020-7736](https://security.snyk.io/vuln/SNYK-JS-BMOOR-598664)", "other": {"cve": {"id": "CVE-2021-23558", "sourceIdentifier": "report@snyk.io", "published": "2022-01-28T22:15:09.073", "lastModified": "2022-02-04T02:06:56.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package bmoor before 0.10.1 are vulnerable to Prototype Pollution due to missing sanitization in set function. **Note:** This vulnerability derives from an incomplete fix in [CVE-2020-7736](https://security.snyk.io/vuln/SNYK-JS-BMOOR-598664)"}, {"lang": "es", "value": "El paquete bmoor versiones anteriores a 0.10.1, es vulnerable a una Contaminaci\u00f3n de Prototipos debido a una falta de saneo en la funci\u00f3n set. **Nota:** Esta vulnerabilidad es derivada de una correcci\u00f3n incompleta en [CVE-2020-7736](https://security.snyk.io/vuln/SNYK-JS-BMOOR-598664)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bmoor_project:bmoor:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.10.1", "matchCriteriaId": "E0350D18-5232-4890-A30C-0D4E4946C6A7"}]}]}], "references": [{"url": "https://github.com/b-heilman/bmoor/commit/29b0162cc1dc1791fc060891f568b0ae29bc542b", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-BMOOR-2342622", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/b-heilman/bmoor/commit/29b0162cc1dc1791fc060891f568b0ae29bc542b"}}