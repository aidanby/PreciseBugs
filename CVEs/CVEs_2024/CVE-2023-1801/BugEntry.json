{"buggy_code": ["/*\n * Copyright (c) 1988-1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Copyright (c) 1998-2012  Michael Richardson <mcr@tcpdump.org>\n *      The TCPDUMP project\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifndef netdissect_h\n#define netdissect_h\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n#include <sys/types.h>\n#include <setjmp.h>\n#include \"status-exit-codes.h\"\n#include \"funcattrs.h\" /* for PRINTFLIKE_FUNCPTR() */\n#include \"diag-control.h\" /* for ND_UNREACHABLE */\n\n/*\n * Data types corresponding to multi-byte integral values within data\n * structures.  These are defined as arrays of octets, so that they're\n * not aligned on their \"natural\" boundaries, and so that you *must*\n * use the EXTRACT_ macros to extract them (which you should be doing\n * *anyway*, so as not to assume a particular byte order or alignment\n * in your code).\n *\n * We even want EXTRACT_U_1 used for 8-bit integral values, so we\n * define nd_uint8_t and nd_int8_t as arrays as well.\n */\ntypedef unsigned char nd_uint8_t[1];\ntypedef unsigned char nd_uint16_t[2];\ntypedef unsigned char nd_uint24_t[3];\ntypedef unsigned char nd_uint32_t[4];\ntypedef unsigned char nd_uint40_t[5];\ntypedef unsigned char nd_uint48_t[6];\ntypedef unsigned char nd_uint56_t[7];\ntypedef unsigned char nd_uint64_t[8];\n\ntypedef signed char nd_int8_t[1];\n\n/*\n * \"unsigned char\" so that sign extension isn't done on the\n * individual bytes while they're being assembled.\n */\ntypedef unsigned char nd_int32_t[4];\ntypedef unsigned char nd_int64_t[8];\n\n#define\tFMAXINT\t(4294967296.0)\t/* floating point rep. of MAXINT */\n\n/*\n * Use this for IPv4 addresses and netmasks.\n *\n * It's defined as an array of octets, so that it's not guaranteed to\n * be aligned on its \"natural\" boundary (in some packet formats, it\n * *isn't* so aligned).  We have separate EXTRACT_ calls for them;\n * sometimes you want the host-byte-order value, other times you want\n * the network-byte-order value.\n *\n * Don't use EXTRACT_BE_U_4() on them, use EXTRACT_IPV4_TO_HOST_ORDER()\n * if you want them in host byte order and EXTRACT_IPV4_TO_NETWORK_ORDER()\n * if you want them in network byte order (which you want with system APIs\n * that expect network-order IPv4 addresses, such as inet_ntop()).\n *\n * If, on your little-endian machine (e.g., an \"IBM-compatible PC\", no matter\n * what the OS, or an Intel Mac, no matter what the OS), you get the wrong\n * answer, and you've used EXTRACT_BE_U_4(), do *N*O*T* \"fix\" this by using\n * EXTRACT_LE_U_4(), fix it by using EXTRACT_IPV4_TO_NETWORK_ORDER(),\n * otherwise you're breaking the result on big-endian machines (e.g.,\n * most PowerPC/Power ISA machines, System/390 and z/Architecture, SPARC,\n * etc.).\n *\n * Yes, people do this; that's why Wireshark has tvb_get_ipv4(), to extract\n * an IPv4 address from a packet data buffer; it was introduced in reaction\n * to somebody who *had* done that.\n */\ntypedef unsigned char nd_ipv4[4];\n\n/*\n * Use this for IPv6 addresses and netmasks.\n */\ntypedef unsigned char nd_ipv6[16];\n\n/*\n * Use this for MAC addresses.\n */\n#define MAC_ADDR_LEN\t6U\t\t/* length of MAC addresses */\ntypedef unsigned char nd_mac_addr[MAC_ADDR_LEN];\n\n/*\n * Use this for blobs of bytes; make them arrays of nd_byte.\n */\ntypedef unsigned char nd_byte;\n\n/*\n * Round up x to a multiple of y; y must be a power of 2.\n */\n#ifndef roundup2\n#define\troundup2(x, y)\t(((x)+((u_int)((y)-1)))&(~((u_int)((y)-1))))\n#endif\n\n#include <stdarg.h>\n#include <pcap.h>\n\n#include \"ip.h\" /* struct ip for nextproto4_cksum() */\n#include \"ip6.h\" /* struct ip6 for nextproto6_cksum() */\n\n#ifndef HAVE_STRLCAT\nextern size_t strlcat (char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRLCPY\nextern size_t strlcpy (char *, const char *, size_t);\n#endif\n\n#ifndef HAVE_STRDUP\nextern char *strdup (const char *str);\n#endif\n\n#ifndef HAVE_STRSEP\nextern char *strsep(char **, const char *);\n#endif\n\nstruct tok {\n\tu_int v;\t\t/* value */\n\tconst char *s;\t\t/* string */\n};\n\n/* tok2str is deprecated */\nextern const char *tok2str(const struct tok *, const char *, u_int);\nextern char *bittok2str(const struct tok *, const char *, u_int);\nextern char *bittok2str_nosep(const struct tok *, const char *, u_int);\n\n/* Initialize netdissect. */\nextern int nd_init(char *, size_t);\n/* Clean up netdissect. */\nextern void nd_cleanup(void);\n\n/* Do we have libsmi support? */\nextern int nd_have_smi_support(void);\n/* Load an SMI module. */\nextern int nd_load_smi_module(const char *, char *, size_t);\n/* Flag indicating whether an SMI module has been loaded. */\nextern int nd_smi_module_loaded;\n/* Version number of the SMI library, or NULL if we don't have libsmi support. */\nextern const char *nd_smi_version_string(void);\n\ntypedef struct netdissect_options netdissect_options;\n\n#define IF_PRINTER_ARGS (netdissect_options *, const struct pcap_pkthdr *, const u_char *)\n\ntypedef void (*if_printer) IF_PRINTER_ARGS;\n\n/*\n * In case the data in a buffer needs to be processed by being decrypted,\n * decompressed, etc. before it's dissected, we can't process it in place,\n * we have to allocate a new buffer for the processed data.\n *\n * We keep a stack of those buffers; when we allocate a new buffer, we\n * push the current one onto a stack, and when we're done with the new\n * buffer, we free the current buffer and pop the previous one off the\n * stack.\n *\n * A buffer has a beginning and end pointer, and a link to the previous\n * buffer on the stack.\n *\n * In other cases, we temporarily adjust the snapshot end to reflect a\n * packet-length field in the packet data and, when finished dissecting\n * that part of the packet, restore the old snapshot end.  We keep that\n * on the stack with null buffer pointer, meaning there's nothing to\n * free.\n */\nstruct netdissect_saved_packet_info {\n  u_char *ndspi_buffer;\t\t\t\t\t/* pointer to allocated buffer data */\n  const u_char *ndspi_packetp;\t\t\t\t/* saved beginning of data */\n  const u_char *ndspi_snapend;\t\t\t\t/* saved end of data */\n  struct netdissect_saved_packet_info *ndspi_prev;\t/* previous buffer on the stack */\n};\n\n/* 'val' value(s) for longjmp */\n#define ND_TRUNCATED 1\n\nstruct netdissect_options {\n  int ndo_bflag;\t\t/* print 4 byte ASes in ASDOT notation */\n  int ndo_eflag;\t\t/* print ethernet header */\n  int ndo_fflag;\t\t/* don't translate \"foreign\" IP address */\n  int ndo_Kflag;\t\t/* don't check IP, TCP or UDP checksums */\n  int ndo_nflag;\t\t/* leave addresses as numbers */\n  int ndo_Nflag;\t\t/* remove domains from printed host names */\n  int ndo_qflag;\t\t/* quick (shorter) output */\n  int ndo_Sflag;\t\t/* print raw TCP sequence numbers */\n  int ndo_tflag;\t\t/* print packet arrival time */\n  int ndo_uflag;\t\t/* Print undecoded NFS handles */\n  int ndo_vflag;\t\t/* verbosity level */\n  int ndo_xflag;\t\t/* print packet in hex */\n  int ndo_Xflag;\t\t/* print packet in hex/ASCII */\n  int ndo_Aflag;\t\t/* print packet only in ASCII observing TAB,\n\t\t\t\t * LF, CR and SPACE as graphical chars\n\t\t\t\t */\n  int ndo_Hflag;\t\t/* dissect 802.11s draft mesh standard */\n  const char *ndo_protocol;\t/* protocol */\n  jmp_buf ndo_early_end;\t/* jmp_buf for setjmp()/longjmp() */\n  void *ndo_last_mem_p;\t\t/* pointer to the last allocated memory chunk */\n  int ndo_packet_number;\t/* print a packet number in the beginning of line */\n  int ndo_suppress_default_print; /* don't use default_print() for unknown packet types */\n  int ndo_tstamp_precision;\t/* requested time stamp precision */\n  const char *program_name;\t/* Name of the program using the library */\n\n  char *ndo_espsecret;\n  struct sa_list *ndo_sa_list_head;  /* used by print-esp.c */\n  struct sa_list *ndo_sa_default;\n\n  char *ndo_sigsecret;\t\t/* Signature verification secret key */\n\n  int   ndo_packettype;\t/* as specified by -T */\n\n  int   ndo_snaplen;\n  int   ndo_ll_hdr_len;\t/* link-layer header length */\n\n  /*global pointers to beginning and end of current packet (during printing) */\n  const u_char *ndo_packetp;\n  const u_char *ndo_snapend;\n\n  /* stack of saved packet boundary and buffer information */\n  struct netdissect_saved_packet_info *ndo_packet_info_stack;\n\n  /* pointer to the if_printer function */\n  if_printer ndo_if_printer;\n\n  /* pointer to void function to output stuff */\n  void (*ndo_default_print)(netdissect_options *,\n\t\t\t    const u_char *bp, u_int length);\n\n  /* pointer to function to do regular output */\n  int  (*ndo_printf)(netdissect_options *,\n\t\t     const char *fmt, ...)\n\t\t     PRINTFLIKE_FUNCPTR(2, 3);\n  /* pointer to function to output errors */\n  void NORETURN_FUNCPTR (*ndo_error)(netdissect_options *,\n\t\t\t\t     status_exit_codes_t status,\n\t\t\t\t     const char *fmt, ...)\n\t\t\t\t     PRINTFLIKE_FUNCPTR(3, 4);\n  /* pointer to function to output warnings */\n  void (*ndo_warning)(netdissect_options *,\n\t\t      const char *fmt, ...)\n\t\t      PRINTFLIKE_FUNCPTR(2, 3);\n};\n\nextern WARN_UNUSED_RESULT int nd_push_buffer(netdissect_options *, u_char *, const u_char *, const u_int);\nextern WARN_UNUSED_RESULT int nd_push_snaplen(netdissect_options *, const u_char *, const u_int);\nextern void nd_change_snaplen(netdissect_options *, const u_char *, const u_int);\nextern void nd_pop_packet_info(netdissect_options *);\nextern void nd_pop_all_packet_info(netdissect_options *);\n\nstatic inline NORETURN void\nnd_trunc_longjmp(netdissect_options *ndo)\n{\n\tlongjmp(ndo->ndo_early_end, ND_TRUNCATED);\n#ifdef _AIX\n\t/*\n\t * In AIX <setjmp.h> decorates longjmp() with \"#pragma leaves\", which tells\n\t * XL C that the function is noreturn, but GCC remains unaware of that and\n\t * yields a \"'noreturn' function does return\" warning.\n\t */\n\tND_UNREACHABLE\n#endif /* _AIX */\n}\n\n#define PT_VAT\t\t1\t/* Visual Audio Tool */\n#define PT_WB\t\t2\t/* distributed White Board */\n#define PT_RPC\t\t3\t/* Remote Procedure Call */\n#define PT_RTP\t\t4\t/* Real-Time Applications protocol */\n#define PT_RTCP\t\t5\t/* Real-Time Applications control protocol */\n#define PT_SNMP\t\t6\t/* Simple Network Management Protocol */\n#define PT_CNFP\t\t7\t/* Cisco NetFlow protocol */\n#define PT_TFTP\t\t8\t/* trivial file transfer protocol */\n#define PT_AODV\t\t9\t/* Ad-hoc On-demand Distance Vector Protocol */\n#define PT_CARP\t\t10\t/* Common Address Redundancy Protocol */\n#define PT_RADIUS\t11\t/* RADIUS authentication Protocol */\n#define PT_ZMTP1\t12\t/* ZeroMQ Message Transport Protocol 1.0 */\n#define PT_VXLAN\t13\t/* Virtual eXtensible Local Area Network */\n#define PT_PGM\t\t14\t/* [UDP-encapsulated] Pragmatic General Multicast */\n#define PT_PGM_ZMTP1\t15\t/* ZMTP/1.0 inside PGM (native or UDP-encapsulated) */\n#define PT_LMP\t\t16\t/* Link Management Protocol */\n#define PT_RESP\t\t17\t/* RESP */\n#define PT_PTP\t\t18\t/* PTP */\n#define PT_SOMEIP\t19\t/* Autosar SOME/IP Protocol */\n#define PT_DOMAIN\t20\t/* Domain Name System (DNS) */\n\n#define ND_MIN(a,b) ((a)>(b)?(b):(a))\n#define ND_MAX(a,b) ((b)>(a)?(b):(a))\n\n/* For source or destination ports tests (UDP, TCP, ...) */\n#define IS_SRC_OR_DST_PORT(p) (sport == (p) || dport == (p))\n\n/*\n * Maximum snapshot length.  This should be enough to capture the full\n * packet on most network interfaces.\n *\n *\n * Somewhat arbitrary, but chosen to be:\n *\n *    1) big enough for maximum-size Linux loopback packets (65549)\n *       and some USB packets captured with USBPcap:\n *\n *           https://desowin.org/usbpcap/\n *\n *       (> 131072, < 262144)\n *\n * and\n *\n *    2) small enough not to cause attempts to allocate huge amounts of\n *       memory; some applications might use the snapshot length in a\n *       savefile header to control the size of the buffer they allocate,\n *       so a size of, say, 2^31-1 might not work well.\n *\n * XXX - does it need to be bigger still?  Note that, for versions of\n * libpcap with pcap_create()/pcap_activate(), if no -s flag is specified\n * or -s 0 is specified, we won't set the snapshot length at all, and will\n * let libpcap choose a snapshot length; newer versions may choose a bigger\n * value than 262144 for D-Bus, for example.\n */\n#define MAXIMUM_SNAPLEN\t262144\n\n/*\n * True if \"l\" bytes from \"p\" were captured.\n *\n * The \"ndo->ndo_snapend - (l) <= ndo->ndo_snapend\" checks to make sure\n * \"l\" isn't so large that \"ndo->ndo_snapend - (l)\" underflows.\n *\n * The check is for <= rather than < because \"l\" might be 0.\n *\n * We cast the pointers to uintptr_t to make sure that the compiler\n * doesn't optimize away any of these tests (which it is allowed to\n * do, as adding an integer to, or subtracting an integer from, a\n * pointer assumes that the pointer is a pointer to an element of an\n * array and that the result of the addition or subtraction yields a\n * pointer to another member of the array, so that, for example, if\n * you subtract a positive integer from a pointer, the result is\n * guaranteed to be less than the original pointer value). See\n *\n *\thttps://www.kb.cert.org/vuls/id/162289\n */\n\n/*\n * Test in two parts to avoid these warnings:\n * comparison of unsigned expression >= 0 is always true [-Wtype-limits],\n * comparison is always true due to limited range of data type [-Wtype-limits].\n */\n#define IS_NOT_NEGATIVE(x) (((x) > 0) || ((x) == 0))\n\n#define ND_TTEST_LEN(p, l) \\\n  (IS_NOT_NEGATIVE(l) && \\\n\t((uintptr_t)ndo->ndo_snapend - (l) <= (uintptr_t)ndo->ndo_snapend && \\\n         (uintptr_t)(p) <= (uintptr_t)ndo->ndo_snapend - (l)))\n\n/* True if \"*(p)\" was captured */\n#define ND_TTEST_SIZE(p) ND_TTEST_LEN(p, sizeof(*(p)))\n\n/* Bail out if \"l\" bytes from \"p\" were not captured */\n#ifdef ND_LONGJMP_FROM_TCHECK\n#define ND_TCHECK_LEN(p, l) if (!ND_TTEST_LEN(p, l)) nd_trunc_longjmp(ndo)\n#else\n#define ND_TCHECK_LEN(p, l) if (!ND_TTEST_LEN(p, l)) goto trunc\n#endif\n\n/* Bail out if \"*(p)\" was not captured */\n#define ND_TCHECK_SIZE(p) ND_TCHECK_LEN(p, sizeof(*(p)))\n\n/*\n * Number of bytes between two pointers.\n */\n#define ND_BYTES_BETWEEN(p1, p2) ((u_int)(((const uint8_t *)(p1)) - (const uint8_t *)(p2)))\n\n/*\n * Number of bytes remaining in the captured data, starting at the\n * byte pointed to by the argument.\n */\n#define ND_BYTES_AVAILABLE_AFTER(p) ND_BYTES_BETWEEN(ndo->ndo_snapend, (p))\n\n/* Check length < minimum for invalid packet with a custom message, format %u */\n#define ND_LCHECKMSG_U(length, minimum, what) \\\nif ((length) < (minimum)) { \\\nND_PRINT(\" [%s %u < %u]\", (what), (length), (minimum)); \\\ngoto invalid; \\\n}\n\n/* Check length < minimum for invalid packet with #length message, format %u */\n#define ND_LCHECK_U(length, minimum) \\\nND_LCHECKMSG_U((length), (minimum), (#length))\n\n/* Check length < minimum for invalid packet with a custom message, format %zu */\n#define ND_LCHECKMSG_ZU(length, minimum, what) \\\nif ((length) < (minimum)) { \\\nND_PRINT(\" [%s %u < %zu]\", (what), (length), (minimum)); \\\ngoto invalid; \\\n}\n\n/* Check length < minimum for invalid packet with #length message, format %zu */\n#define ND_LCHECK_ZU(length, minimum) \\\nND_LCHECKMSG_ZU((length), (minimum), (#length))\n\n#define ND_PRINT(...) (ndo->ndo_printf)(ndo, __VA_ARGS__)\n#define ND_DEFAULTPRINT(ap, length) (*ndo->ndo_default_print)(ndo, ap, length)\n\nextern void ts_print(netdissect_options *, const struct timeval *);\nextern void signed_relts_print(netdissect_options *, int32_t);\nextern void unsigned_relts_print(netdissect_options *, uint32_t);\n\nextern void fn_print_char(netdissect_options *, u_char);\nextern void fn_print_str(netdissect_options *, const u_char *);\nextern u_int nd_printztn(netdissect_options *, const u_char *, u_int, const u_char *);\nextern int nd_printn(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void nd_printjnp(netdissect_options *, const u_char *, u_int);\n\n/*\n * Flags for txtproto_print().\n */\n#define RESP_CODE_SECOND_TOKEN\t0x00000001\t/* response code is second token in response line */\n\nextern void txtproto_print(netdissect_options *, const u_char *, u_int,\n\t\t\t   const char **, u_int);\n\n#if (defined(__i386__) || defined(_M_IX86) || defined(__X86__) || defined(__x86_64__) || defined(_M_X64)) || \\\n    (defined(__arm__) || defined(_M_ARM) || defined(__aarch64__)) || \\\n    (defined(__m68k__) && (!defined(__mc68000__) && !defined(__mc68010__))) || \\\n    (defined(__ppc__) || defined(__ppc64__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)) || \\\n    (defined(__s390__) || defined(__s390x__) || defined(__zarch__)) || \\\n    defined(__vax__)\n/*\n * The processor natively handles unaligned loads, so just use memcpy()\n * and memcmp(), to enable those optimizations.\n *\n * XXX - are those all the x86 tests we need?\n * XXX - do we need to worry about ARMv1 through ARMv5, which didn't\n * support unaligned loads, and, if so, do we need to worry about all\n * of them, or just some of them, e.g. ARMv5?\n * XXX - are those the only 68k tests we need not to generated\n * unaligned accesses if the target is the 68000 or 68010?\n * XXX - are there any tests we don't need, because some definitions are for\n * compilers that also predefine the GCC symbols?\n * XXX - do we need to test for both 32-bit and 64-bit versions of those\n * architectures in all cases?\n */\n#define UNALIGNED_MEMCPY(p, q, l)\tmemcpy((p), (q), (l))\n#define UNALIGNED_MEMCMP(p, q, l)\tmemcmp((p), (q), (l))\n#else\n/*\n * The processor doesn't natively handle unaligned loads,\n * and the compiler might \"helpfully\" optimize memcpy()\n * and memcmp(), when handed pointers that would normally\n * be properly aligned, into sequences that assume proper\n * alignment.\n *\n * Do copies and compares of possibly-unaligned data by\n * calling routines that wrap memcpy() and memcmp(), to\n * prevent that optimization.\n */\nextern void unaligned_memcpy(void *, const void *, size_t);\nextern int unaligned_memcmp(const void *, const void *, size_t);\n#define UNALIGNED_MEMCPY(p, q, l)\tunaligned_memcpy((p), (q), (l))\n#define UNALIGNED_MEMCMP(p, q, l)\tunaligned_memcmp((p), (q), (l))\n#endif\n\n#define PLURAL_SUFFIX(n) \\\n\t(((n) != 1) ? \"s\" : \"\")\n\nextern const char *tok2strary_internal(const char **, int, const char *, int);\n#define\ttok2strary(a,f,i) tok2strary_internal(a, sizeof(a)/sizeof(a[0]),f,i)\n\nstruct uint_tokary\n{\n\tu_int uintval;\n\tconst struct tok *tokary;\n};\n\nextern const struct tok *uint2tokary_internal(const struct uint_tokary[], const size_t, const u_int);\n#define uint2tokary(a, i) uint2tokary_internal(a, sizeof(a)/sizeof(a[0]), i)\n\nextern if_printer lookup_printer(int);\n\n#define ND_DEBUG {printf(\" [%s:%d %s] \", __FILE__, __LINE__, __func__); fflush(stdout);}\n\n/* The DLT printer routines */\n\nextern void ap1394_if_print IF_PRINTER_ARGS;\nextern void arcnet_if_print IF_PRINTER_ARGS;\nextern void arcnet_linux_if_print IF_PRINTER_ARGS;\nextern void atm_if_print IF_PRINTER_ARGS;\nextern void brcm_tag_if_print IF_PRINTER_ARGS;\nextern void brcm_tag_prepend_if_print IF_PRINTER_ARGS;\nextern void bt_if_print IF_PRINTER_ARGS;\nextern void chdlc_if_print IF_PRINTER_ARGS;\nextern void cip_if_print IF_PRINTER_ARGS;\nextern void dsa_if_print IF_PRINTER_ARGS;\nextern void edsa_if_print IF_PRINTER_ARGS;\nextern void enc_if_print IF_PRINTER_ARGS;\nextern void ether_if_print IF_PRINTER_ARGS;\nextern void fddi_if_print IF_PRINTER_ARGS;\nextern void fr_if_print IF_PRINTER_ARGS;\nextern void ieee802_11_if_print IF_PRINTER_ARGS;\nextern void ieee802_11_radio_avs_if_print IF_PRINTER_ARGS;\nextern void ieee802_11_radio_if_print IF_PRINTER_ARGS;\nextern void ieee802_15_4_if_print IF_PRINTER_ARGS;\nextern void ieee802_15_4_tap_if_print IF_PRINTER_ARGS;\nextern void ipfc_if_print IF_PRINTER_ARGS;\nextern void ipnet_if_print IF_PRINTER_ARGS;\nextern void ipoib_if_print IF_PRINTER_ARGS;\nextern void juniper_atm1_if_print IF_PRINTER_ARGS;\nextern void juniper_atm2_if_print IF_PRINTER_ARGS;\nextern void juniper_chdlc_if_print IF_PRINTER_ARGS;\nextern void juniper_es_if_print IF_PRINTER_ARGS;\nextern void juniper_ether_if_print IF_PRINTER_ARGS;\nextern void juniper_frelay_if_print IF_PRINTER_ARGS;\nextern void juniper_ggsn_if_print IF_PRINTER_ARGS;\nextern void juniper_mfr_if_print IF_PRINTER_ARGS;\nextern void juniper_mlfr_if_print IF_PRINTER_ARGS;\nextern void juniper_mlppp_if_print IF_PRINTER_ARGS;\nextern void juniper_monitor_if_print IF_PRINTER_ARGS;\nextern void juniper_ppp_if_print IF_PRINTER_ARGS;\nextern void juniper_pppoe_atm_if_print IF_PRINTER_ARGS;\nextern void juniper_pppoe_if_print IF_PRINTER_ARGS;\nextern void juniper_services_if_print IF_PRINTER_ARGS;\nextern void ltalk_if_print IF_PRINTER_ARGS;\nextern void mfr_if_print IF_PRINTER_ARGS;\nextern void netanalyzer_if_print IF_PRINTER_ARGS;\nextern void netanalyzer_transparent_if_print IF_PRINTER_ARGS;\nextern void nflog_if_print IF_PRINTER_ARGS;\nextern void null_if_print IF_PRINTER_ARGS;\nextern void pflog_if_print IF_PRINTER_ARGS;\nextern void pktap_if_print IF_PRINTER_ARGS;\nextern void ppi_if_print IF_PRINTER_ARGS;\nextern void ppp_bsdos_if_print IF_PRINTER_ARGS;\nextern void ppp_hdlc_if_print IF_PRINTER_ARGS;\nextern void ppp_if_print IF_PRINTER_ARGS;\nextern void pppoe_if_print IF_PRINTER_ARGS;\nextern void prism_if_print IF_PRINTER_ARGS;\nextern void raw_if_print IF_PRINTER_ARGS;\nextern void sl_bsdos_if_print IF_PRINTER_ARGS;\nextern void sl_if_print IF_PRINTER_ARGS;\nextern void sll2_if_print IF_PRINTER_ARGS;\nextern void sll_if_print IF_PRINTER_ARGS;\nextern void sunatm_if_print IF_PRINTER_ARGS;\nextern void symantec_if_print IF_PRINTER_ARGS;\nextern void token_if_print IF_PRINTER_ARGS;\nextern void unsupported_if_print IF_PRINTER_ARGS;\nextern void usb_linux_48_byte_if_print IF_PRINTER_ARGS;\nextern void usb_linux_64_byte_if_print IF_PRINTER_ARGS;\nextern void vsock_if_print IF_PRINTER_ARGS;\n\n/*\n * Structure passed to some printers to allow them to print\n * link-layer address information if ndo_eflag isn't set\n * (because they are for protocols that don't have their\n * own addresses, so that we'd want to report link-layer\n * address information).\n *\n * This contains a pointer to an address and a pointer to a routine\n * to which we pass that pointer in order to get a string.\n */\nstruct lladdr_info {\n\tconst char *(*addr_string)(netdissect_options *, const u_char *);\n\tconst u_char *addr;\n};\n\n/* The printer routines. */\n\nextern void aarp_print(netdissect_options *, const u_char *, u_int);\nextern int ah_print(netdissect_options *, const u_char *);\nextern void ahcp_print(netdissect_options *, const u_char *, u_int);\nextern void aodv_print(netdissect_options *, const u_char *, u_int, int);\nextern void aoe_print(netdissect_options *, const u_char *, const u_int);\nextern int  arista_ethertype_print(netdissect_options *,const u_char *, u_int);\nextern void arp_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void ascii_print(netdissect_options *, const u_char *, u_int);\nextern void atalk_print(netdissect_options *, const u_char *, u_int);\nextern void atm_print(netdissect_options *, u_int, u_int, u_int, const u_char *, u_int, u_int);\nextern void babel_print(netdissect_options *, const u_char *, u_int);\nextern void bcm_li_print(netdissect_options *, const u_char *, u_int);\nextern void beep_print(netdissect_options *, const u_char *, u_int);\nextern void bfd_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void bgp_print(netdissect_options *, const u_char *, u_int);\nextern const char *bgp_vpn_rd_print(netdissect_options *, const u_char *);\nextern void bootp_print(netdissect_options *, const u_char *, u_int);\nextern void calm_fast_print(netdissect_options *, const u_char *, u_int, const struct lladdr_info *);\nextern void carp_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void cdp_print(netdissect_options *, const u_char *, u_int);\nextern void cfm_print(netdissect_options *, const u_char *, u_int);\nextern u_int chdlc_print(netdissect_options *, const u_char *, u_int);\nextern void cisco_autorp_print(netdissect_options *, const u_char *, u_int);\nextern void cnfp_print(netdissect_options *, const u_char *);\nextern void dccp_print(netdissect_options *, const u_char *, const u_char *, u_int);\nextern void decnet_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void dhcp6_print(netdissect_options *, const u_char *, u_int);\nextern int dstopt_process(netdissect_options *, const u_char *);\nextern void dtp_print(netdissect_options *, const u_char *, u_int);\nextern void dvmrp_print(netdissect_options *, const u_char *, u_int);\nextern void eap_print(netdissect_options *, const u_char *, u_int);\nextern void eapol_print(netdissect_options *, const u_char *);\nextern void egp_print(netdissect_options *, const u_char *, u_int);\nextern void eigrp_print(netdissect_options *, const u_char *, u_int);\nextern void esp_print(netdissect_options *, const u_char *, u_int, const u_char *, u_int, int, u_int);\nextern u_int ether_print(netdissect_options *, const u_char *, u_int, u_int, void (*)(netdissect_options *, const u_char *), const u_char *);\nextern u_int ether_switch_tag_print(netdissect_options *, const u_char *, u_int, u_int, void (*)(netdissect_options *, const u_char *), u_int);\nextern int ethertype_print(netdissect_options *, u_short, const u_char *, u_int, u_int, const struct lladdr_info *, const struct lladdr_info *);\nextern u_int fddi_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void forces_print(netdissect_options *, const u_char *, u_int);\nextern u_int fr_print(netdissect_options *, const u_char *, u_int);\nextern int frag6_print(netdissect_options *, const u_char *, const u_char *);\nextern void ftp_print(netdissect_options *, const u_char *, u_int);\nextern void geneve_print(netdissect_options *, const u_char *, u_int);\nextern void geonet_print(netdissect_options *, const u_char *, u_int, const struct lladdr_info *);\nextern void gre_print(netdissect_options *, const u_char *, u_int);\nextern int hbhopt_process(netdissect_options *, const u_char *, int *, uint32_t *);\nextern void hex_and_ascii_print(netdissect_options *, const char *, const u_char *, u_int);\nextern void hex_print(netdissect_options *, const char *ident, const u_char *cp, u_int);\nextern void hex_print_with_offset(netdissect_options *, const char *ident, const u_char *cp, u_int, u_int);\nextern void hncp_print(netdissect_options *, const u_char *, u_int);\nextern void hsrp_print(netdissect_options *, const u_char *, u_int);\nextern void http_print(netdissect_options *, const u_char *, u_int);\nextern void icmp6_print(netdissect_options *, const u_char *, u_int, const u_char *, int);\nextern void icmp_print(netdissect_options *, const u_char *, u_int, const u_char *, int);\nextern u_int ieee802_15_4_print(netdissect_options *, const u_char *, u_int);\nextern u_int ieee802_11_radio_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void igmp_print(netdissect_options *, const u_char *, u_int);\nextern void igrp_print(netdissect_options *, const u_char *, u_int);\nextern void ip6_print(netdissect_options *, const u_char *, u_int);\nextern void ipN_print(netdissect_options *, const u_char *, u_int);\nextern void ip_print(netdissect_options *, const u_char *, u_int);\nextern void ipcomp_print(netdissect_options *, const u_char *);\nextern void ipx_netbios_print(netdissect_options *, const u_char *, u_int);\nextern void ipx_print(netdissect_options *, const u_char *, u_int);\nextern void isakmp_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void isakmp_rfc3948_print(netdissect_options *, const u_char *, u_int, const u_char *, int, int, u_int);\nextern void isoclns_print(netdissect_options *, const u_char *, u_int);\nextern void krb_print(netdissect_options *, const u_char *);\nextern void l2tp_print(netdissect_options *, const u_char *, u_int);\nextern void lane_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void ldp_print(netdissect_options *, const u_char *, u_int);\nextern void lisp_print(netdissect_options *, const u_char *, u_int);\nextern u_int llap_print(netdissect_options *, const u_char *, u_int);\nextern int llc_print(netdissect_options *, const u_char *, u_int, u_int, const struct lladdr_info *, const struct lladdr_info *);\nextern void lldp_print(netdissect_options *, const u_char *, u_int);\nextern void lmp_print(netdissect_options *, const u_char *, u_int);\nextern void loopback_print(netdissect_options *, const u_char *, u_int);\nextern void lspping_print(netdissect_options *, const u_char *, u_int);\nextern void lwapp_control_print(netdissect_options *, const u_char *, u_int, int);\nextern void lwapp_data_print(netdissect_options *, const u_char *, u_int);\nextern void lwres_print(netdissect_options *, const u_char *, u_int);\nextern void m3ua_print(netdissect_options *, const u_char *, const u_int);\nextern int macsec_print(netdissect_options *, const u_char **,\n\t\t\t u_int *, u_int *, u_int *, const struct lladdr_info *,\n\t\t\t const struct lladdr_info *);\nextern u_int mfr_print(netdissect_options *, const u_char *, u_int);\nextern void mobile_print(netdissect_options *, const u_char *, u_int);\nextern int mobility_print(netdissect_options *, const u_char *, const u_char *);\nextern void mpcp_print(netdissect_options *, const u_char *, u_int);\nextern void mpls_print(netdissect_options *, const u_char *, u_int);\nextern int mptcp_print(netdissect_options *, const u_char *, u_int, u_char);\nextern void msdp_print(netdissect_options *, const u_char *, u_int);\nextern void msnlb_print(netdissect_options *, const u_char *);\nextern void nbt_tcp_print(netdissect_options *, const u_char *, u_int);\nextern void nbt_udp137_print(netdissect_options *, const u_char *, u_int);\nextern void nbt_udp138_print(netdissect_options *, const u_char *, u_int);\nextern void netbeui_print(netdissect_options *, u_short, const u_char *, u_int);\nextern void nfsreply_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void nfsreply_noaddr_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void nfsreq_noaddr_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern const u_char *fqdn_print(netdissect_options *, const u_char *, const u_char *);\nextern void domain_print(netdissect_options *, const u_char *, u_int, int, int);\nextern void nsh_print(netdissect_options *, const u_char *, u_int);\nextern void ntp_print(netdissect_options *, const u_char *, u_int);\nextern void oam_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void olsr_print(netdissect_options *, const u_char *, u_int, int);\nextern void openflow_print(netdissect_options *, const u_char *, u_int);\nextern void ospf6_print(netdissect_options *, const u_char *, u_int);\nextern void ospf_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern int ospf_grace_lsa_print(netdissect_options *, const u_char *, u_int);\nextern int ospf_te_lsa_print(netdissect_options *, const u_char *, u_int);\nextern void otv_print(netdissect_options *, const u_char *, u_int);\nextern void pgm_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void pim_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void pimv1_print(netdissect_options *, const u_char *, u_int);\nextern u_int ppp_print(netdissect_options *, const u_char *, u_int);\nextern u_int pppoe_print(netdissect_options *, const u_char *, u_int);\nextern void pptp_print(netdissect_options *, const u_char *);\nextern void ptp_print(netdissect_options *, const u_char *, u_int);\nextern int print_unknown_data(netdissect_options *, const u_char *, const char *, u_int);\nextern const char *q922_string(netdissect_options *, const u_char *, u_int);\nextern void q933_print(netdissect_options *, const u_char *, u_int);\nextern void radius_print(netdissect_options *, const u_char *, u_int);\nextern void resp_print(netdissect_options *, const u_char *, u_int);\nextern void rip_print(netdissect_options *, const u_char *, u_int);\nextern void ripng_print(netdissect_options *, const u_char *, unsigned int);\nextern void rpki_rtr_print(netdissect_options *, const u_char *, u_int);\nextern void rsvp_print(netdissect_options *, const u_char *, u_int);\nextern int rt6_print(netdissect_options *, const u_char *, const u_char *);\nextern void rtl_print(netdissect_options *, const u_char *, u_int, const struct lladdr_info *, const struct lladdr_info *);\nextern void rtsp_print(netdissect_options *, const u_char *, u_int);\nextern void rx_print(netdissect_options *, const u_char *, u_int, uint16_t, uint16_t, const u_char *);\nextern void sctp_print(netdissect_options *, const u_char *, const u_char *, u_int);\nextern void sflow_print(netdissect_options *, const u_char *, u_int);\nextern void ssh_print(netdissect_options *, const u_char *, u_int);\nextern void sip_print(netdissect_options *, const u_char *, u_int);\nextern void slow_print(netdissect_options *, const u_char *, u_int);\nextern void smb_tcp_print(netdissect_options *, const u_char *, u_int);\nextern void smtp_print(netdissect_options *, const u_char *, u_int);\nextern int snap_print(netdissect_options *, const u_char *, u_int, u_int, const struct lladdr_info *, const struct lladdr_info *, u_int);\nextern void snmp_print(netdissect_options *, const u_char *, u_int);\nextern void stp_print(netdissect_options *, const u_char *, u_int);\nextern void sunrpc_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void syslog_print(netdissect_options *, const u_char *, u_int);\nextern void tcp_print(netdissect_options *, const u_char *, u_int, const u_char *, int);\nextern void telnet_print(netdissect_options *, const u_char *, u_int);\nextern void tftp_print(netdissect_options *, const u_char *, u_int);\nextern void timed_print(netdissect_options *, const u_char *);\nextern void tipc_print(netdissect_options *, const u_char *, u_int, u_int);\nextern u_int token_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void udld_print(netdissect_options *, const u_char *, u_int);\nextern void udp_print(netdissect_options *, const u_char *, u_int, const u_char *, int, u_int);\nextern int vjc_print(netdissect_options *, const u_char *, u_short);\nextern void vqp_print(netdissect_options *, const u_char *, u_int);\nextern void vrrp_print(netdissect_options *, const u_char *, u_int, const u_char *, int, int);\nextern void vtp_print(netdissect_options *, const u_char *, const u_int);\nextern void vxlan_gpe_print(netdissect_options *, const u_char *, u_int);\nextern void vxlan_print(netdissect_options *, const u_char *, u_int);\nextern void wb_print(netdissect_options *, const u_char *, u_int);\nextern void whois_print(netdissect_options *, const u_char *, u_int);\nextern void zep_print(netdissect_options *, const u_char *, u_int);\nextern void zephyr_print(netdissect_options *, const u_char *, u_int);\nextern void zmtp1_print(netdissect_options *, const u_char *, u_int);\nextern void zmtp1_datagram_print(netdissect_options *, const u_char *, const u_int);\nextern void someip_print(netdissect_options *, const u_char *, const u_int);\n\n/* checksum routines */\nextern void init_checksum(void);\nextern uint16_t verify_crc10_cksum(uint16_t, const u_char *, int);\nextern uint16_t create_osi_cksum(const uint8_t *, int, int);\n\nstruct cksum_vec {\n\tconst uint8_t\t*ptr;\n\tint\t\tlen;\n};\nextern uint16_t in_cksum(const struct cksum_vec *, int);\nextern uint16_t in_cksum_shouldbe(uint16_t, uint16_t);\n\n/* IP protocol demuxing routines */\nextern void ip_demux_print(netdissect_options *, const u_char *, u_int, u_int, int, u_int, uint8_t, const u_char *);\n\nextern uint16_t nextproto4_cksum(netdissect_options *, const struct ip *, const uint8_t *, u_int, u_int, uint8_t);\n\n/* in print-ip6.c */\nextern uint16_t nextproto6_cksum(netdissect_options *, const struct ip6_hdr *, const uint8_t *, u_int, u_int, uint8_t);\n\n/* Utilities */\nextern void nd_print_trunc(netdissect_options *);\nextern void nd_print_protocol(netdissect_options *);\nextern void nd_print_protocol_caps(netdissect_options *);\nextern void nd_print_invalid(netdissect_options *);\n\nextern int mask2plen(uint32_t);\nextern int mask62plen(const u_char *);\n\nextern const char *dnnum_string(netdissect_options *, u_short);\n\nextern int decode_prefix4(netdissect_options *, const u_char *, u_int, char *, size_t);\nextern int decode_prefix6(netdissect_options *, const u_char *, u_int, char *, size_t);\n\nextern void esp_decodesecret_print(netdissect_options *);\nextern int esp_decrypt_buffer_by_ikev2_print(netdissect_options *, int,\n\t\t\t\t\t     const u_char spii[8],\n\t\t\t\t\t     const u_char spir[8],\n\t\t\t\t\t     const u_char *, const u_char *);\n\n#endif  /* netdissect_h */\n", "/*\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ntp.h\"\n\n#include \"extract.h\"\n\n#define\tJAN_1970\tINT64_T_CONSTANT(2208988800)\t/* 1970 - 1900 in seconds */\n\nvoid\np_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t/* some compilers are buggy */\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t/* shift radix point by 32 bits */\n\tf = (uint32_t)(ff * 1000000000.0);\t/* treat fraction as parts per billion */\n\tND_PRINT(\"%u.%09u\", i, f);\n\n\t/*\n\t * print the UTC time in human-readable format.\n\t */\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    struct tm *tm;\n\t    char time_buf[128];\n\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\t/*\n\t\t * It doesn't fit into a time_t, so we can't hand it\n\t\t * to gmtime.\n\t\t */\n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&seconds);\n\t\tif (tm == NULL) {\n\t\t    /*\n\t\t     * gmtime() can't handle it.\n\t\t     * (Yes, that might happen with some version of\n\t\t     * Microsoft's C library.)\n\t\t     */\n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    /* use ISO 8601 (RFC3339) format */\n\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", time_buf);\n\t\t}\n\t    }\n\t}\n}\n", "/*\n * Copyright (c) 2013 The TCPDUMP project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* \\summary: Ad Hoc Configuration Protocol (AHCP) printer */\n\n/* Based on draft-chroboczek-ahcp-00 and source code of ahcpd-0.53 */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#define ND_LONGJMP_FROM_TCHECK\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n\n\n#define AHCP_MAGIC_NUMBER 43\n#define AHCP_VERSION_1 1\n#define AHCP1_HEADER_FIX_LEN 24\n#define AHCP1_BODY_MIN_LEN 4\n\n#define AHCP1_MSG_DISCOVER 0\n#define AHCP1_MSG_OFFER    1\n#define AHCP1_MSG_REQUEST  2\n#define AHCP1_MSG_ACK      3\n#define AHCP1_MSG_NACK     4\n#define AHCP1_MSG_RELEASE  5\n\nstatic const struct tok ahcp1_msg_str[] = {\n\t{ AHCP1_MSG_DISCOVER, \"Discover\" },\n\t{ AHCP1_MSG_OFFER,    \"Offer\"    },\n\t{ AHCP1_MSG_REQUEST,  \"Request\"  },\n\t{ AHCP1_MSG_ACK,      \"Ack\"      },\n\t{ AHCP1_MSG_NACK,     \"Nack\"     },\n\t{ AHCP1_MSG_RELEASE,  \"Release\"  },\n\t{ 0, NULL }\n};\n\n#define AHCP1_OPT_PAD                     0\n#define AHCP1_OPT_MANDATORY               1\n#define AHCP1_OPT_ORIGIN_TIME             2\n#define AHCP1_OPT_EXPIRES                 3\n#define AHCP1_OPT_MY_IPV6_ADDRESS         4\n#define AHCP1_OPT_MY_IPV4_ADDRESS         5\n#define AHCP1_OPT_IPV6_PREFIX             6\n#define AHCP1_OPT_IPV4_PREFIX             7\n#define AHCP1_OPT_IPV6_ADDRESS            8\n#define AHCP1_OPT_IPV4_ADDRESS            9\n#define AHCP1_OPT_IPV6_PREFIX_DELEGATION 10\n#define AHCP1_OPT_IPV4_PREFIX_DELEGATION 11\n#define AHCP1_OPT_NAME_SERVER            12\n#define AHCP1_OPT_NTP_SERVER             13\n#define AHCP1_OPT_MAX                    13\n\nstatic const struct tok ahcp1_opt_str[] = {\n\t{ AHCP1_OPT_PAD,                    \"Pad\"                    },\n\t{ AHCP1_OPT_MANDATORY,              \"Mandatory\"              },\n\t{ AHCP1_OPT_ORIGIN_TIME,            \"Origin Time\"            },\n\t{ AHCP1_OPT_EXPIRES,                \"Expires\"                },\n\t{ AHCP1_OPT_MY_IPV6_ADDRESS,        \"My-IPv6-Address\"        },\n\t{ AHCP1_OPT_MY_IPV4_ADDRESS,        \"My-IPv4-Address\"        },\n\t{ AHCP1_OPT_IPV6_PREFIX,            \"IPv6 Prefix\"            },\n\t{ AHCP1_OPT_IPV4_PREFIX,            \"IPv4 Prefix\"            },\n\t{ AHCP1_OPT_IPV6_ADDRESS,           \"IPv6 Address\"           },\n\t{ AHCP1_OPT_IPV4_ADDRESS,           \"IPv4 Address\"           },\n\t{ AHCP1_OPT_IPV6_PREFIX_DELEGATION, \"IPv6 Prefix Delegation\" },\n\t{ AHCP1_OPT_IPV4_PREFIX_DELEGATION, \"IPv4 Prefix Delegation\" },\n\t{ AHCP1_OPT_NAME_SERVER,            \"Name Server\"            },\n\t{ AHCP1_OPT_NTP_SERVER,             \"NTP Server\"             },\n\t{ 0, NULL }\n};\n\nstatic void\nahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_seconds_print(netdissect_options *ndo,\n                   const u_char *cp, uint8_t len)\n{\n\tif (len != 4)\n\t\tgoto invalid;\n\tND_PRINT(\": %us\", GET_BE_U_4(cp));\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv6_addresses_print(netdissect_options *ndo,\n                          const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 16)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s\", sep, GET_IP6ADDR_STRING(cp));\n\t\tcp += 16;\n\t\tlen -= 16;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv4_addresses_print(netdissect_options *ndo,\n                          const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 4)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s\", sep, GET_IPADDR_STRING(cp));\n\t\tcp += 4;\n\t\tlen -= 4;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv6_prefixes_print(netdissect_options *ndo,\n                         const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 17)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s/%u\", sep, GET_IP6ADDR_STRING(cp), GET_U_1(cp + 16));\n\t\tcp += 17;\n\t\tlen -= 17;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv4_prefixes_print(netdissect_options *ndo,\n                         const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 5)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s/%u\", sep, GET_IPADDR_STRING(cp), GET_U_1(cp + 4));\n\t\tcp += 5;\n\t\tlen -= 5;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\n(* const data_decoders[AHCP1_OPT_MAX + 1])(netdissect_options *, const u_char *, uint8_t) = {\n\t/* [AHCP1_OPT_PAD]                    = */  NULL,\n\t/* [AHCP1_OPT_MANDATORY]              = */  NULL,\n\t/* [AHCP1_OPT_ORIGIN_TIME]            = */  ahcp_time_print,\n\t/* [AHCP1_OPT_EXPIRES]                = */  ahcp_seconds_print,\n\t/* [AHCP1_OPT_MY_IPV6_ADDRESS]        = */  ahcp_ipv6_addresses_print,\n\t/* [AHCP1_OPT_MY_IPV4_ADDRESS]        = */  ahcp_ipv4_addresses_print,\n\t/* [AHCP1_OPT_IPV6_PREFIX]            = */  ahcp_ipv6_prefixes_print,\n\t/* [AHCP1_OPT_IPV4_PREFIX]            = */  NULL,\n\t/* [AHCP1_OPT_IPV6_ADDRESS]           = */  ahcp_ipv6_addresses_print,\n\t/* [AHCP1_OPT_IPV4_ADDRESS]           = */  ahcp_ipv4_addresses_print,\n\t/* [AHCP1_OPT_IPV6_PREFIX_DELEGATION] = */  ahcp_ipv6_prefixes_print,\n\t/* [AHCP1_OPT_IPV4_PREFIX_DELEGATION] = */  ahcp_ipv4_prefixes_print,\n\t/* [AHCP1_OPT_NAME_SERVER]            = */  ahcp_ipv6_addresses_print,\n\t/* [AHCP1_OPT_NTP_SERVER]             = */  ahcp_ipv6_addresses_print,\n};\n\nstatic void\nahcp1_options_print(netdissect_options *ndo,\n                    const u_char *cp, uint16_t len)\n{\n\twhile (len) {\n\t\tuint8_t option_no, option_len;\n\n\t\t/* Option no */\n\t\toption_no = GET_U_1(cp);\n\t\tcp += 1;\n\t\tlen -= 1;\n\t\tND_PRINT(\"\\n\\t %s\", tok2str(ahcp1_opt_str, \"Unknown-%u\", option_no));\n\t\tif (option_no == AHCP1_OPT_PAD || option_no == AHCP1_OPT_MANDATORY)\n\t\t\tcontinue;\n\t\t/* Length */\n\t\tif (!len)\n\t\t\tgoto invalid;\n\t\toption_len = GET_U_1(cp);\n\t\tcp += 1;\n\t\tlen -= 1;\n\t\tif (option_len > len)\n\t\t\tgoto invalid;\n\t\t/* Value */\n\t\tif (option_no <= AHCP1_OPT_MAX && data_decoders[option_no] != NULL) {\n\t\t\tdata_decoders[option_no](ndo, cp, option_len);\n\t\t} else {\n\t\t\tND_PRINT(\" (Length %u)\", option_len);\n\t\t\tND_TCHECK_LEN(cp, option_len);\n\t\t}\n\t\tcp += option_len;\n\t\tlen -= option_len;\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp1_body_print(netdissect_options *ndo,\n                 const u_char *cp, u_int len)\n{\n\tuint8_t type, mbz;\n\tuint16_t body_len;\n\n\tif (len < AHCP1_BODY_MIN_LEN)\n\t\tgoto invalid;\n\t/* Type */\n\ttype = GET_U_1(cp);\n\tcp += 1;\n\tlen -= 1;\n\t/* MBZ */\n\tmbz = GET_U_1(cp);\n\tcp += 1;\n\tlen -= 1;\n\t/* Length */\n\tbody_len = GET_BE_U_2(cp);\n\tcp += 2;\n\tlen -= 2;\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT(\"\\n\\t%s\", tok2str(ahcp1_msg_str, \"Unknown-%u\", type));\n\t\tif (mbz != 0)\n\t\t\tND_PRINT(\", MBZ %u\", mbz);\n\t\tND_PRINT(\", Length %u\", body_len);\n\t}\n\tif (body_len > len)\n\t\tgoto invalid;\n\n\t/* Options */\n\t/* Here use \"body_len\", not \"len\" (ignore any extra data). */\n\tif (ndo->ndo_vflag >= 2)\n\t\tahcp1_options_print(ndo, cp, body_len);\n\telse\n\t\tND_TCHECK_LEN(cp, body_len);\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n\n}\n\nvoid\nahcp_print(netdissect_options *ndo,\n           const u_char *cp, u_int len)\n{\n\tuint8_t version;\n\n\tndo->ndo_protocol = \"ahcp\";\n\tnd_print_protocol_caps(ndo);\n\tif (len < 2)\n\t\tgoto invalid;\n\t/* Magic */\n\tif (GET_U_1(cp) != AHCP_MAGIC_NUMBER)\n\t\tgoto invalid;\n\tcp += 1;\n\tlen -= 1;\n\t/* Version */\n\tversion = GET_U_1(cp);\n\tcp += 1;\n\tlen -= 1;\n\tswitch (version) {\n\t\tcase AHCP_VERSION_1: {\n\t\t\tND_PRINT(\" Version 1\");\n\t\t\tif (len < AHCP1_HEADER_FIX_LEN - 2)\n\t\t\t\tgoto invalid;\n\t\t\tif (!ndo->ndo_vflag) {\n\t\t\t\tND_TCHECK_LEN(cp, AHCP1_HEADER_FIX_LEN - 2);\n\t\t\t\tcp += AHCP1_HEADER_FIX_LEN - 2;\n\t\t\t\tlen -= AHCP1_HEADER_FIX_LEN - 2;\n\t\t\t} else {\n\t\t\t\t/* Hopcount */\n\t\t\t\tND_PRINT(\"\\n\\tHopcount %u\", GET_U_1(cp));\n\t\t\t\tcp += 1;\n\t\t\t\tlen -= 1;\n\t\t\t\t/* Original Hopcount */\n\t\t\t\tND_PRINT(\", Original Hopcount %u\", GET_U_1(cp));\n\t\t\t\tcp += 1;\n\t\t\t\tlen -= 1;\n\t\t\t\t/* Nonce */\n\t\t\t\tND_PRINT(\", Nonce 0x%08x\", GET_BE_U_4(cp));\n\t\t\t\tcp += 4;\n\t\t\t\tlen -= 4;\n\t\t\t\t/* Source Id */\n\t\t\t\tND_PRINT(\", Source Id %s\", GET_LINKADDR_STRING(cp, LINKADDR_OTHER, 8));\n\t\t\t\tcp += 8;\n\t\t\t\tlen -= 8;\n\t\t\t\t/* Destination Id */\n\t\t\t\tND_PRINT(\", Destination Id %s\", GET_LINKADDR_STRING(cp, LINKADDR_OTHER, 8));\n\t\t\t\tcp += 8;\n\t\t\t\tlen -= 8;\n\t\t\t}\n\t\t\t/* Body */\n\t\t\tahcp1_body_print(ndo, cp, len);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tND_PRINT(\" Version %u (unknown)\", version);\n\t\t\tND_TCHECK_LEN(cp, len);\n\t\t\tbreak;\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n", "// Copyright (c) 2018 Arista Networks, Inc.  All rights reserved.\n\n/* \\summary: EtherType protocol for Arista Networks printer */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n\n/*\n\nFrom Bill Fenner:\n\nThe Arista timestamp header consists of the following fields:\n1. The Arista ethertype (0xd28b)\n2. A 2-byte subtype field; 0x01 indicates the timestamp header\n3. A 2-byte version field, described below.\n4. A 48-bit or 64-bit timestamp field, depending on the contents of the version field\n\nThis header is then followed by the original ethertype and the remainder of the original packet.\n\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            dst mac                            |\n+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                            src mac                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        ethertype 0xd28b       |          subtype 0x1          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            version            |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                          timestamp...                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe two-byte version value is split into 3 fields:\n1. The timescale in use.  Currently assigned values include:\n    0 = TAI\n    1 = UTC\n2. The timestamp format and length.  Currently assigned values include:\n    1 = 64-bit timestamp\n    2 = 48-bit timestamp\n3. The hardware info\n    0 = R/R2 series\n    1 = R3 series\n\n 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   timescale   | format|hw info|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\nSee also: https://www.arista.com/assets/data/pdf/Whitepapers/Overview_Arista_Timestamps.pdf\n\n*/\n\n#define ARISTA_SUBTYPE_TIMESTAMP 0x0001\nstatic const struct tok subtype_str[] = {\n\t{ ARISTA_SUBTYPE_TIMESTAMP, \"Timestamp\" },\n\t{ 0, NULL }\n};\n\nstatic const struct tok ts_timescale_str[] = {\n\t{ 0, \"TAI\" },\n\t{ 1, \"UTC\" },\n\t{ 0, NULL }\n};\n\n#define FORMAT_64BIT 0x1\n#define FORMAT_48BIT 0x2\nstatic const struct tok ts_format_str[] = {\n\t{ FORMAT_64BIT, \"64-bit\" },\n\t{ FORMAT_48BIT, \"48-bit\" },\n\t{ 0, NULL }\n};\n\nstatic const struct tok hw_info_str[] = {\n\t{ 0, \"R/R2\" },\n\t{ 1, \"R3\" },\n\t{ 0, NULL }\n};\n\nstatic inline void\narista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}\n\nint\narista_ethertype_print(netdissect_options *ndo, const u_char *bp, u_int len _U_)\n{\n\tuint16_t subTypeId;\n\tu_short bytesConsumed = 0;\n\n\tndo->ndo_protocol = \"arista\";\n\n\tsubTypeId = GET_BE_U_2(bp);\n\tbp += 2;\n\tbytesConsumed += 2;\n\n\tND_PRINT(\"SubType %s (0x%04x), \",\n\t         tok2str(subtype_str, \"Unknown\", subTypeId),\n\t         subTypeId);\n\n\t// TapAgg Header Timestamping\n\tif (subTypeId == ARISTA_SUBTYPE_TIMESTAMP) {\n\t\tuint64_t seconds;\n\t\tuint32_t nanoseconds;\n\t\tuint8_t ts_timescale = GET_U_1(bp);\n\t\tbp += 1;\n\t\tbytesConsumed += 1;\n\t\tND_PRINT(\"Timescale %s (%u), \",\n\t\t         tok2str(ts_timescale_str, \"Unknown\", ts_timescale),\n\t\t         ts_timescale);\n\n\t\tuint8_t ts_format = GET_U_1(bp) >> 4;\n\t\tuint8_t hw_info = GET_U_1(bp) & 0x0f;\n\t\tbp += 1;\n\t\tbytesConsumed += 1;\n\n\t\t// Timestamp has 32-bit lsb in nanosec and remaining msb in sec\n\t\tND_PRINT(\"Format %s (%u), HwInfo %s (%u), Timestamp \",\n\t\t         tok2str(ts_format_str, \"Unknown\", ts_format),\n\t\t         ts_format,\n\t\t         tok2str(hw_info_str, \"Unknown\", hw_info),\n\t\t         hw_info);\n\t\tswitch (ts_format) {\n\t\tcase FORMAT_64BIT:\n\t\t\tseconds = GET_BE_U_4(bp);\n\t\t\tnanoseconds = GET_BE_U_4(bp + 4);\n\t\t\tarista_print_date_hms_time(ndo, seconds, nanoseconds);\n\t\t\tbytesConsumed += 8;\n\t\t\tbreak;\n\t\tcase FORMAT_48BIT:\n\t\t\tseconds = GET_BE_U_2(bp);\n\t\t\tnanoseconds = GET_BE_U_4(bp + 2);\n\t\t\tseconds += nanoseconds / 1000000000;\n\t\t\tnanoseconds %= 1000000000;\n\t\t\tND_PRINT(\"%\" PRIu64 \".%09u\", seconds, nanoseconds);\n\t\t\tbytesConsumed += 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\tND_PRINT(\": \");\n\treturn bytesConsumed;\n}\n", "/*\n * Copyright: (c) 2000 United States Government as represented by the\n *\tSecretary of the Navy. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   1. Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright\n *      notice, this list of conditions and the following disclaimer in\n *      the documentation and/or other materials provided with the\n *      distribution.\n *   3. The names of the authors may not be used to endorse or promote\n *      products derived from this software without specific prior\n *      written permission.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* \\summary: AFS RX printer */\n\n/*\n * This code unmangles RX packets.  RX is the mutant form of RPC that AFS\n * uses to communicate between clients and servers.\n *\n * In this code, I mainly concern myself with decoding the AFS calls, not\n * with the guts of RX, per se.\n *\n * Bah.  If I never look at rx_packet.h again, it will be too soon.\n *\n * Ken Hornstein <kenh@cmf.nrl.navy.mil>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include \"netdissect-stdinc.h\"\n\n#include \"netdissect.h\"\n#include \"addrtoname.h\"\n#include \"extract.h\"\n\n#include \"ip.h\"\n\n#define FS_RX_PORT\t7000\n#define CB_RX_PORT\t7001\n#define PROT_RX_PORT\t7002\n#define VLDB_RX_PORT\t7003\n#define KAUTH_RX_PORT\t7004\n#define VOL_RX_PORT\t7005\n#define ERROR_RX_PORT\t7006\t\t/* Doesn't seem to be used */\n#define BOS_RX_PORT\t7007\n\n#define AFSOPAQUEMAX 1024\n#define AFSNAMEMAX 256\t\t\t/* Must be >= PRNAMEMAX + 1, VLNAMEMAX + 1, and 32 + 1 */\n#define PRNAMEMAX 64\n#define VLNAMEMAX 65\n#define KANAMEMAX 64\n#define BOSNAMEMAX 256\n#define USERNAMEMAX 1024\t\t/* AFSOPAQUEMAX was used for this; does it need to be this big? */\n\n#define\tPRSFS_READ\t\t1 /* Read files */\n#define\tPRSFS_WRITE\t\t2 /* Write files */\n#define\tPRSFS_INSERT\t\t4 /* Insert files into a directory */\n#define\tPRSFS_LOOKUP\t\t8 /* Lookup files into a directory */\n#define\tPRSFS_DELETE\t\t16 /* Delete files */\n#define\tPRSFS_LOCK\t\t32 /* Lock files */\n#define\tPRSFS_ADMINISTER\t64 /* Change ACL's */\n\nstruct rx_header {\n\tnd_uint32_t epoch;\n\tnd_uint32_t cid;\n\tnd_uint32_t callNumber;\n\tnd_uint32_t seq;\n\tnd_uint32_t serial;\n\tnd_uint8_t type;\n#define RX_PACKET_TYPE_DATA\t\t1\n#define RX_PACKET_TYPE_ACK\t\t2\n#define RX_PACKET_TYPE_BUSY\t\t3\n#define RX_PACKET_TYPE_ABORT\t\t4\n#define RX_PACKET_TYPE_ACKALL\t\t5\n#define RX_PACKET_TYPE_CHALLENGE\t6\n#define RX_PACKET_TYPE_RESPONSE\t\t7\n#define RX_PACKET_TYPE_DEBUG\t\t8\n#define RX_PACKET_TYPE_PARAMS\t\t9\n#define RX_PACKET_TYPE_VERSION\t\t13\n\tnd_uint8_t flags;\n#define RX_CLIENT_INITIATED\t1\n#define RX_REQUEST_ACK\t\t2\n#define RX_LAST_PACKET\t\t4\n#define RX_MORE_PACKETS\t\t8\n#define RX_FREE_PACKET\t\t16\n#define RX_SLOW_START_OK\t32\n#define RX_JUMBO_PACKET\t\t32\n\tnd_uint8_t userStatus;\n\tnd_uint8_t securityIndex;\n\tnd_uint16_t spare;\t\t/* How clever: even though the AFS */\n\tnd_uint16_t serviceId;\t\t/* header files indicate that the */\n};\t\t\t\t\t/* serviceId is first, it's really */\n\t\t\t\t\t/* encoded _after_ the spare field */\n\t\t\t\t\t/* I wasted a day figuring that out! */\n\n#define NUM_RX_FLAGS 7\n\n#define RX_MAXACKS 255\n\nstruct rx_ackPacket {\n\tnd_uint16_t bufferSpace;\t/* Number of packet buffers available */\n\tnd_uint16_t maxSkew;\t\t/* Max diff between ack'd packet and */\n\t\t\t\t\t/* highest packet received */\n\tnd_uint32_t firstPacket;\t/* The first packet in ack list */\n\tnd_uint32_t previousPacket;\t/* Previous packet recv'd (obsolete) */\n\tnd_uint32_t serial;\t\t/* # of packet that prompted the ack */\n\tnd_uint8_t reason;\t\t/* Reason for acknowledgement */\n\tnd_uint8_t nAcks;\t\t/* Number of acknowledgements */\n\t/* Followed by nAcks acknowledgments */\n#if 0\n\tuint8_t acks[RX_MAXACKS];\t/* Up to RX_MAXACKS acknowledgements */\n#endif\n};\n\n/*\n * Values for the acks array\n */\n\n#define RX_ACK_TYPE_NACK\t0\t/* Don't have this packet */\n#define RX_ACK_TYPE_ACK\t\t1\t/* I have this packet */\n\nstatic const struct tok rx_types[] = {\n\t{ RX_PACKET_TYPE_DATA,\t\t\"data\" },\n\t{ RX_PACKET_TYPE_ACK,\t\t\"ack\" },\n\t{ RX_PACKET_TYPE_BUSY,\t\t\"busy\" },\n\t{ RX_PACKET_TYPE_ABORT,\t\t\"abort\" },\n\t{ RX_PACKET_TYPE_ACKALL,\t\"ackall\" },\n\t{ RX_PACKET_TYPE_CHALLENGE,\t\"challenge\" },\n\t{ RX_PACKET_TYPE_RESPONSE,\t\"response\" },\n\t{ RX_PACKET_TYPE_DEBUG,\t\t\"debug\" },\n\t{ RX_PACKET_TYPE_PARAMS,\t\"params\" },\n\t{ RX_PACKET_TYPE_VERSION,\t\"version\" },\n\t{ 0,\t\t\t\tNULL },\n};\n\nstatic const struct double_tok {\n\tuint32_t flag;\t\t/* Rx flag */\n\tuint32_t packetType;\t/* Packet type */\n\tconst char *s;\t\t/* Flag string */\n} rx_flags[] = {\n\t{ RX_CLIENT_INITIATED,\t0,\t\t\t\"client-init\" },\n\t{ RX_REQUEST_ACK,\t0,\t\t\t\"req-ack\" },\n\t{ RX_LAST_PACKET,\t0,\t\t\t\"last-pckt\" },\n\t{ RX_MORE_PACKETS,\t0,\t\t\t\"more-pckts\" },\n\t{ RX_FREE_PACKET,\t0,\t\t\t\"free-pckt\" },\n\t{ RX_SLOW_START_OK,\tRX_PACKET_TYPE_ACK,\t\"slow-start\" },\n\t{ RX_JUMBO_PACKET,\tRX_PACKET_TYPE_DATA,\t\"jumbogram\" }\n};\n\nstatic const struct tok fs_req[] = {\n\t{ 130,\t\t\"fetch-data\" },\n\t{ 131,\t\t\"fetch-acl\" },\n\t{ 132,\t\t\"fetch-status\" },\n\t{ 133,\t\t\"store-data\" },\n\t{ 134,\t\t\"store-acl\" },\n\t{ 135,\t\t\"store-status\" },\n\t{ 136,\t\t\"remove-file\" },\n\t{ 137,\t\t\"create-file\" },\n\t{ 138,\t\t\"rename\" },\n\t{ 139,\t\t\"symlink\" },\n\t{ 140,\t\t\"link\" },\n\t{ 141,\t\t\"makedir\" },\n\t{ 142,\t\t\"rmdir\" },\n\t{ 143,\t\t\"oldsetlock\" },\n\t{ 144,\t\t\"oldextlock\" },\n\t{ 145,\t\t\"oldrellock\" },\n\t{ 146,\t\t\"get-stats\" },\n\t{ 147,\t\t\"give-cbs\" },\n\t{ 148,\t\t\"get-vlinfo\" },\n\t{ 149,\t\t\"get-vlstats\" },\n\t{ 150,\t\t\"set-vlstats\" },\n\t{ 151,\t\t\"get-rootvl\" },\n\t{ 152,\t\t\"check-token\" },\n\t{ 153,\t\t\"get-time\" },\n\t{ 154,\t\t\"nget-vlinfo\" },\n\t{ 155,\t\t\"bulk-stat\" },\n\t{ 156,\t\t\"setlock\" },\n\t{ 157,\t\t\"extlock\" },\n\t{ 158,\t\t\"rellock\" },\n\t{ 159,\t\t\"xstat-ver\" },\n\t{ 160,\t\t\"get-xstat\" },\n\t{ 161,\t\t\"dfs-lookup\" },\n\t{ 162,\t\t\"dfs-flushcps\" },\n\t{ 163,\t\t\"dfs-symlink\" },\n\t{ 220,\t\t\"residency\" },\n\t{ 65536,        \"inline-bulk-status\" },\n\t{ 65537,        \"fetch-data-64\" },\n\t{ 65538,        \"store-data-64\" },\n\t{ 65539,        \"give-up-all-cbs\" },\n\t{ 65540,        \"get-caps\" },\n\t{ 65541,        \"cb-rx-conn-addr\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok cb_req[] = {\n\t{ 204,\t\t\"callback\" },\n\t{ 205,\t\t\"initcb\" },\n\t{ 206,\t\t\"probe\" },\n\t{ 207,\t\t\"getlock\" },\n\t{ 208,\t\t\"getce\" },\n\t{ 209,\t\t\"xstatver\" },\n\t{ 210,\t\t\"getxstat\" },\n\t{ 211,\t\t\"initcb2\" },\n\t{ 212,\t\t\"whoareyou\" },\n\t{ 213,\t\t\"initcb3\" },\n\t{ 214,\t\t\"probeuuid\" },\n\t{ 215,\t\t\"getsrvprefs\" },\n\t{ 216,\t\t\"getcellservdb\" },\n\t{ 217,\t\t\"getlocalcell\" },\n\t{ 218,\t\t\"getcacheconf\" },\n\t{ 65536,        \"getce64\" },\n\t{ 65537,        \"getcellbynum\" },\n\t{ 65538,        \"tellmeaboutyourself\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok pt_req[] = {\n\t{ 500,\t\t\"new-user\" },\n\t{ 501,\t\t\"where-is-it\" },\n\t{ 502,\t\t\"dump-entry\" },\n\t{ 503,\t\t\"add-to-group\" },\n\t{ 504,\t\t\"name-to-id\" },\n\t{ 505,\t\t\"id-to-name\" },\n\t{ 506,\t\t\"delete\" },\n\t{ 507,\t\t\"remove-from-group\" },\n\t{ 508,\t\t\"get-cps\" },\n\t{ 509,\t\t\"new-entry\" },\n\t{ 510,\t\t\"list-max\" },\n\t{ 511,\t\t\"set-max\" },\n\t{ 512,\t\t\"list-entry\" },\n\t{ 513,\t\t\"change-entry\" },\n\t{ 514,\t\t\"list-elements\" },\n\t{ 515,\t\t\"same-mbr-of\" },\n\t{ 516,\t\t\"set-fld-sentry\" },\n\t{ 517,\t\t\"list-owned\" },\n\t{ 518,\t\t\"get-cps2\" },\n\t{ 519,\t\t\"get-host-cps\" },\n\t{ 520,\t\t\"update-entry\" },\n\t{ 521,\t\t\"list-entries\" },\n\t{ 530,\t\t\"list-super-groups\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok vldb_req[] = {\n\t{ 501,\t\t\"create-entry\" },\n\t{ 502,\t\t\"delete-entry\" },\n\t{ 503,\t\t\"get-entry-by-id\" },\n\t{ 504,\t\t\"get-entry-by-name\" },\n\t{ 505,\t\t\"get-new-volume-id\" },\n\t{ 506,\t\t\"replace-entry\" },\n\t{ 507,\t\t\"update-entry\" },\n\t{ 508,\t\t\"setlock\" },\n\t{ 509,\t\t\"releaselock\" },\n\t{ 510,\t\t\"list-entry\" },\n\t{ 511,\t\t\"list-attrib\" },\n\t{ 512,\t\t\"linked-list\" },\n\t{ 513,\t\t\"get-stats\" },\n\t{ 514,\t\t\"probe\" },\n\t{ 515,\t\t\"get-addrs\" },\n\t{ 516,\t\t\"change-addr\" },\n\t{ 517,\t\t\"create-entry-n\" },\n\t{ 518,\t\t\"get-entry-by-id-n\" },\n\t{ 519,\t\t\"get-entry-by-name-n\" },\n\t{ 520,\t\t\"replace-entry-n\" },\n\t{ 521,\t\t\"list-entry-n\" },\n\t{ 522,\t\t\"list-attrib-n\" },\n\t{ 523,\t\t\"linked-list-n\" },\n\t{ 524,\t\t\"update-entry-by-name\" },\n\t{ 525,\t\t\"create-entry-u\" },\n\t{ 526,\t\t\"get-entry-by-id-u\" },\n\t{ 527,\t\t\"get-entry-by-name-u\" },\n\t{ 528,\t\t\"replace-entry-u\" },\n\t{ 529,\t\t\"list-entry-u\" },\n\t{ 530,\t\t\"list-attrib-u\" },\n\t{ 531,\t\t\"linked-list-u\" },\n\t{ 532,\t\t\"regaddr\" },\n\t{ 533,\t\t\"get-addrs-u\" },\n\t{ 534,\t\t\"list-attrib-n2\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok kauth_req[] = {\n\t{ 1,\t\t\"auth-old\" },\n\t{ 21,\t\t\"authenticate\" },\n\t{ 22,\t\t\"authenticate-v2\" },\n\t{ 2,\t\t\"change-pw\" },\n\t{ 3,\t\t\"get-ticket-old\" },\n\t{ 23,\t\t\"get-ticket\" },\n\t{ 4,\t\t\"set-pw\" },\n\t{ 5,\t\t\"set-fields\" },\n\t{ 6,\t\t\"create-user\" },\n\t{ 7,\t\t\"delete-user\" },\n\t{ 8,\t\t\"get-entry\" },\n\t{ 9,\t\t\"list-entry\" },\n\t{ 10,\t\t\"get-stats\" },\n\t{ 11,\t\t\"debug\" },\n\t{ 12,\t\t\"get-pw\" },\n\t{ 13,\t\t\"get-random-key\" },\n\t{ 14,\t\t\"unlock\" },\n\t{ 15,\t\t\"lock-status\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok vol_req[] = {\n\t{ 100,\t\t\"create-volume\" },\n\t{ 101,\t\t\"delete-volume\" },\n\t{ 102,\t\t\"restore\" },\n\t{ 103,\t\t\"forward\" },\n\t{ 104,\t\t\"end-trans\" },\n\t{ 105,\t\t\"clone\" },\n\t{ 106,\t\t\"set-flags\" },\n\t{ 107,\t\t\"get-flags\" },\n\t{ 108,\t\t\"trans-create\" },\n\t{ 109,\t\t\"dump\" },\n\t{ 110,\t\t\"get-nth-volume\" },\n\t{ 111,\t\t\"set-forwarding\" },\n\t{ 112,\t\t\"get-name\" },\n\t{ 113,\t\t\"get-status\" },\n\t{ 114,\t\t\"sig-restore\" },\n\t{ 115,\t\t\"list-partitions\" },\n\t{ 116,\t\t\"list-volumes\" },\n\t{ 117,\t\t\"set-id-types\" },\n\t{ 118,\t\t\"monitor\" },\n\t{ 119,\t\t\"partition-info\" },\n\t{ 120,\t\t\"reclone\" },\n\t{ 121,\t\t\"list-one-volume\" },\n\t{ 122,\t\t\"nuke\" },\n\t{ 123,\t\t\"set-date\" },\n\t{ 124,\t\t\"x-list-volumes\" },\n\t{ 125,\t\t\"x-list-one-volume\" },\n\t{ 126,\t\t\"set-info\" },\n\t{ 127,\t\t\"x-list-partitions\" },\n\t{ 128,\t\t\"forward-multiple\" },\n\t{ 65536,\t\"convert-ro\" },\n\t{ 65537,\t\"get-size\" },\n\t{ 65538,\t\"dump-v2\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok bos_req[] = {\n\t{ 80,\t\t\"create-bnode\" },\n\t{ 81,\t\t\"delete-bnode\" },\n\t{ 82,\t\t\"set-status\" },\n\t{ 83,\t\t\"get-status\" },\n\t{ 84,\t\t\"enumerate-instance\" },\n\t{ 85,\t\t\"get-instance-info\" },\n\t{ 86,\t\t\"get-instance-parm\" },\n\t{ 87,\t\t\"add-superuser\" },\n\t{ 88,\t\t\"delete-superuser\" },\n\t{ 89,\t\t\"list-superusers\" },\n\t{ 90,\t\t\"list-keys\" },\n\t{ 91,\t\t\"add-key\" },\n\t{ 92,\t\t\"delete-key\" },\n\t{ 93,\t\t\"set-cell-name\" },\n\t{ 94,\t\t\"get-cell-name\" },\n\t{ 95,\t\t\"get-cell-host\" },\n\t{ 96,\t\t\"add-cell-host\" },\n\t{ 97,\t\t\"delete-cell-host\" },\n\t{ 98,\t\t\"set-t-status\" },\n\t{ 99,\t\t\"shutdown-all\" },\n\t{ 100,\t\t\"restart-all\" },\n\t{ 101,\t\t\"startup-all\" },\n\t{ 102,\t\t\"set-noauth-flag\" },\n\t{ 103,\t\t\"re-bozo\" },\n\t{ 104,\t\t\"restart\" },\n\t{ 105,\t\t\"start-bozo-install\" },\n\t{ 106,\t\t\"uninstall\" },\n\t{ 107,\t\t\"get-dates\" },\n\t{ 108,\t\t\"exec\" },\n\t{ 109,\t\t\"prune\" },\n\t{ 110,\t\t\"set-restart-time\" },\n\t{ 111,\t\t\"get-restart-time\" },\n\t{ 112,\t\t\"start-bozo-log\" },\n\t{ 113,\t\t\"wait-all\" },\n\t{ 114,\t\t\"get-instance-strings\" },\n\t{ 115,\t\t\"get-restricted\" },\n\t{ 116,\t\t\"set-restricted\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok ubik_req[] = {\n\t{ 10000,\t\"vote-beacon\" },\n\t{ 10001,\t\"vote-debug-old\" },\n\t{ 10002,\t\"vote-sdebug-old\" },\n\t{ 10003,\t\"vote-getsyncsite\" },\n\t{ 10004,\t\"vote-debug\" },\n\t{ 10005,\t\"vote-sdebug\" },\n\t{ 10006,\t\"vote-xdebug\" },\n\t{ 10007,\t\"vote-xsdebug\" },\n\t{ 20000,\t\"disk-begin\" },\n\t{ 20001,\t\"disk-commit\" },\n\t{ 20002,\t\"disk-lock\" },\n\t{ 20003,\t\"disk-write\" },\n\t{ 20004,\t\"disk-getversion\" },\n\t{ 20005,\t\"disk-getfile\" },\n\t{ 20006,\t\"disk-sendfile\" },\n\t{ 20007,\t\"disk-abort\" },\n\t{ 20008,\t\"disk-releaselocks\" },\n\t{ 20009,\t\"disk-truncate\" },\n\t{ 20010,\t\"disk-probe\" },\n\t{ 20011,\t\"disk-writev\" },\n\t{ 20012,\t\"disk-interfaceaddr\" },\n\t{ 20013,\t\"disk-setversion\" },\n\t{ 0,\t\tNULL },\n};\n\n#define VOTE_LOW\t10000\n#define VOTE_HIGH\t10007\n#define DISK_LOW\t20000\n#define DISK_HIGH\t20013\n\nstatic const struct tok cb_types[] = {\n\t{ 1,\t\t\"exclusive\" },\n\t{ 2,\t\t\"shared\" },\n\t{ 3,\t\t\"dropped\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok ubik_lock_types[] = {\n\t{ 1,\t\t\"read\" },\n\t{ 2,\t\t\"write\" },\n\t{ 3,\t\t\"wait\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const char *voltype[] = { \"read-write\", \"read-only\", \"backup\" };\n\nstatic const struct tok afs_fs_errors[] = {\n\t{ 101,\t\t\"salvage volume\" },\n\t{ 102,\t\t\"no such vnode\" },\n\t{ 103,\t\t\"no such volume\" },\n\t{ 104,\t\t\"volume exist\" },\n\t{ 105,\t\t\"no service\" },\n\t{ 106,\t\t\"volume offline\" },\n\t{ 107,\t\t\"voline online\" },\n\t{ 108,\t\t\"diskfull\" },\n\t{ 109,\t\t\"diskquota exceeded\" },\n\t{ 110,\t\t\"volume busy\" },\n\t{ 111,\t\t\"volume moved\" },\n\t{ 112,\t\t\"AFS IO error\" },\n\t{ 0xffffff9c,\t\"restarting fileserver\" }, /* -100, sic! */\n\t{ 0,\t\tNULL }\n};\n\n/*\n * Reasons for acknowledging a packet\n */\n\nstatic const struct tok rx_ack_reasons[] = {\n\t{ 1,\t\t\"ack requested\" },\n\t{ 2,\t\t\"duplicate packet\" },\n\t{ 3,\t\t\"out of sequence\" },\n\t{ 4,\t\t\"exceeds window\" },\n\t{ 5,\t\t\"no buffer space\" },\n\t{ 6,\t\t\"ping\" },\n\t{ 7,\t\t\"ping response\" },\n\t{ 8,\t\t\"delay\" },\n\t{ 9,\t\t\"idle\" },\n\t{ 0,\t\tNULL },\n};\n\n/*\n * Cache entries we keep around so we can figure out the RX opcode\n * numbers for replies.  This allows us to make sense of RX reply packets.\n */\n\nstruct rx_cache_entry {\n\tuint32_t\tcallnum;\t/* Call number (net order) */\n\tuint32_t\tclient;\t\t/* client IP address (net order) */\n\tuint32_t\tserver;\t\t/* server IP address (net order) */\n\tuint16_t\tdport;\t\t/* server UDP port (host order) */\n\tuint16_t\tserviceId;\t/* Service identifier (net order) */\n\tuint32_t\topcode;\t\t/* RX opcode (host order) */\n};\n\n#define RX_CACHE_SIZE\t64\n\nstatic struct rx_cache_entry\trx_cache[RX_CACHE_SIZE];\n\nstatic uint32_t\trx_cache_next = 0;\nstatic uint32_t\trx_cache_hint = 0;\nstatic void\trx_cache_insert(netdissect_options *, const u_char *, const struct ip *, uint16_t);\nstatic int\trx_cache_find(netdissect_options *, const struct rx_header *,\n\t\t\t      const struct ip *, uint16_t, uint32_t *);\n\nstatic void fs_print(netdissect_options *, const u_char *, u_int);\nstatic void fs_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void acl_print(netdissect_options *, u_char *, const u_char *);\nstatic void cb_print(netdissect_options *, const u_char *, u_int);\nstatic void cb_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void prot_print(netdissect_options *, const u_char *, u_int);\nstatic void prot_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void vldb_print(netdissect_options *, const u_char *, u_int);\nstatic void vldb_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void kauth_print(netdissect_options *, const u_char *, u_int);\nstatic void kauth_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void vol_print(netdissect_options *, const u_char *, u_int);\nstatic void vol_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void bos_print(netdissect_options *, const u_char *, u_int);\nstatic void bos_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void ubik_print(netdissect_options *, const u_char *);\nstatic void ubik_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\n\nstatic void rx_ack_print(netdissect_options *, const u_char *, u_int);\n\nstatic int is_ubik(uint32_t);\n\n/*\n * Handle the rx-level packet.  See if we know what port it's going to so\n * we can peek at the afs call inside\n */\n\nvoid\nrx_print(netdissect_options *ndo,\n         const u_char *bp, u_int length, uint16_t sport, uint16_t dport,\n         const u_char *bp2)\n{\n\tconst struct rx_header *rxh;\n\tuint32_t i;\n\tuint8_t type, flags;\n\tuint32_t opcode;\n\n\tndo->ndo_protocol = \"rx\";\n\tif (!ND_TTEST_LEN(bp, sizeof(struct rx_header))) {\n\t\tND_PRINT(\" [|rx] (%u)\", length);\n\t\treturn;\n\t}\n\n\trxh = (const struct rx_header *) bp;\n\n\ttype = GET_U_1(rxh->type);\n\tND_PRINT(\" rx %s\", tok2str(rx_types, \"type %u\", type));\n\n\tflags = GET_U_1(rxh->flags);\n\tif (ndo->ndo_vflag) {\n\t\tint firstflag = 0;\n\n\t\tif (ndo->ndo_vflag > 1)\n\t\t\tND_PRINT(\" cid %08x call# %u\",\n\t\t\t       GET_BE_U_4(rxh->cid),\n\t\t\t       GET_BE_U_4(rxh->callNumber));\n\n\t\tND_PRINT(\" seq %u ser %u\",\n\t\t       GET_BE_U_4(rxh->seq),\n\t\t       GET_BE_U_4(rxh->serial));\n\n\t\tif (ndo->ndo_vflag > 2)\n\t\t\tND_PRINT(\" secindex %u serviceid %hu\",\n\t\t\t\tGET_U_1(rxh->securityIndex),\n\t\t\t\tGET_BE_U_2(rxh->serviceId));\n\n\t\tif (ndo->ndo_vflag > 1)\n\t\t\tfor (i = 0; i < NUM_RX_FLAGS; i++) {\n\t\t\t\tif (flags & rx_flags[i].flag &&\n\t\t\t\t    (!rx_flags[i].packetType ||\n\t\t\t\t     type == rx_flags[i].packetType)) {\n\t\t\t\t\tif (!firstflag) {\n\t\t\t\t\t\tfirstflag = 1;\n\t\t\t\t\t\tND_PRINT(\" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tND_PRINT(\",\");\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT(\"<%s>\", rx_flags[i].s);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\t/*\n\t * Try to handle AFS calls that we know about.  Check the destination\n\t * port and make sure it's a data packet.  Also, make sure the\n\t * seq number is 1 (because otherwise it's a continuation packet,\n\t * and we can't interpret that).  Also, seems that reply packets\n\t * do not have the client-init flag set, so we check for that\n\t * as well.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA &&\n\t    GET_BE_U_4(rxh->seq) == 1 &&\n\t    flags & RX_CLIENT_INITIATED) {\n\n\t\t/*\n\t\t * Insert this call into the call cache table, so we\n\t\t * have a chance to print out replies\n\t\t */\n\n\t\trx_cache_insert(ndo, bp, (const struct ip *) bp2, dport);\n\n\t\tswitch (dport) {\n\t\t\tcase FS_RX_PORT:\t/* AFS file service */\n\t\t\t\tfs_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase CB_RX_PORT:\t/* AFS callback service */\n\t\t\t\tcb_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase PROT_RX_PORT:\t/* AFS protection service */\n\t\t\t\tprot_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase VLDB_RX_PORT:\t/* AFS VLDB service */\n\t\t\t\tvldb_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase KAUTH_RX_PORT:\t/* AFS Kerberos auth service */\n\t\t\t\tkauth_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase VOL_RX_PORT:\t/* AFS Volume service */\n\t\t\t\tvol_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase BOS_RX_PORT:\t/* AFS BOS service */\n\t\t\t\tbos_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\n\t/*\n\t * If it's a reply (client-init is _not_ set, but seq is one)\n\t * then look it up in the cache.  If we find it, call the reply\n\t * printing functions  Note that we handle abort packets here,\n\t * because printing out the return code can be useful at times.\n\t */\n\n\t} else if (((type == RX_PACKET_TYPE_DATA &&\n\t\t\t\t\tGET_BE_U_4(rxh->seq) == 1) ||\n\t\t    type == RX_PACKET_TYPE_ABORT) &&\n\t\t   (flags & RX_CLIENT_INITIATED) == 0 &&\n\t\t   rx_cache_find(ndo, rxh, (const struct ip *) bp2,\n\t\t\t\t sport, &opcode)) {\n\n\t\tswitch (sport) {\n\t\t\tcase FS_RX_PORT:\t/* AFS file service */\n\t\t\t\tfs_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase CB_RX_PORT:\t/* AFS callback service */\n\t\t\t\tcb_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase PROT_RX_PORT:\t/* AFS PT service */\n\t\t\t\tprot_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase VLDB_RX_PORT:\t/* AFS VLDB service */\n\t\t\t\tvldb_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase KAUTH_RX_PORT:\t/* AFS Kerberos auth service */\n\t\t\t\tkauth_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase VOL_RX_PORT:\t/* AFS Volume service */\n\t\t\t\tvol_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase BOS_RX_PORT:\t/* AFS BOS service */\n\t\t\t\tbos_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\n\t/*\n\t * If it's an RX ack packet, then use the appropriate ack decoding\n\t * function (there isn't any service-specific information in the\n\t * ack packet, so we can use one for all AFS services)\n\t */\n\n\t} else if (type == RX_PACKET_TYPE_ACK)\n\t\trx_ack_print(ndo, bp, length);\n\n\n\tND_PRINT(\" (%u)\", length);\n}\n\n/*\n * Insert an entry into the cache.  Taken from print-nfs.c\n */\n\nstatic void\nrx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, uint16_t dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (!ND_TTEST_4(bp + sizeof(struct rx_header)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = GET_BE_U_4(rxh->callNumber);\n\trxent->client = GET_IPV4_TO_NETWORK_ORDER(ip->ip_src);\n\trxent->server = GET_IPV4_TO_NETWORK_ORDER(ip->ip_dst);\n\trxent->dport = dport;\n\trxent->serviceId = GET_BE_U_2(rxh->serviceId);\n\trxent->opcode = GET_BE_U_4(bp + sizeof(struct rx_header));\n}\n\n/*\n * Lookup an entry in the cache.  Also taken from print-nfs.c\n *\n * Note that because this is a reply, we're looking at the _source_\n * port.\n */\n\nstatic int\nrx_cache_find(netdissect_options *ndo, const struct rx_header *rxh,\n\t      const struct ip *ip, uint16_t sport, uint32_t *opcode)\n{\n\tuint32_t i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\n\tclip = GET_IPV4_TO_NETWORK_ORDER(ip->ip_dst);\n\tsip = GET_IPV4_TO_NETWORK_ORDER(ip->ip_src);\n\n\t/* Start the search where we last left off */\n\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == GET_BE_U_4(rxh->callNumber) &&\n\t\t    rxent->client == clip &&\n\t\t    rxent->server == sip &&\n\t\t    rxent->serviceId == GET_BE_U_2(rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\n\t\t\t/* We got a match! */\n\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\n\t/* Our search failed */\n\treturn(0);\n}\n\n/*\n * These extremely grody macros handle the printing of various AFS stuff.\n */\n\n#define FIDOUT() { uint32_t n1, n2, n3; \\\n\t\t\tND_TCHECK_LEN(bp, sizeof(uint32_t) * 3); \\\n\t\t\tn1 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn2 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn3 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" fid %u/%u/%u\", n1, n2, n3); \\\n\t\t}\n\n#define STROUT(MAX) { uint32_t _i; \\\n\t\t\t_i = GET_BE_U_4(bp); \\\n\t\t\tif (_i > (MAX)) \\\n\t\t\t\tgoto trunc; \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" \\\"\"); \\\n\t\t\tif (nd_printn(ndo, bp, _i, ndo->ndo_snapend)) \\\n\t\t\t\tgoto trunc; \\\n\t\t\tND_PRINT(\"\\\"\"); \\\n\t\t\tbp += ((_i + sizeof(uint32_t) - 1) / sizeof(uint32_t)) * sizeof(uint32_t); \\\n\t\t}\n\n#define INTOUT() { int32_t _i; \\\n\t\t\t_i = GET_BE_S_4(bp); \\\n\t\t\tbp += sizeof(int32_t); \\\n\t\t\tND_PRINT(\" %d\", _i); \\\n\t\t}\n\n#define UINTOUT() { uint32_t _i; \\\n\t\t\t_i = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" %u\", _i); \\\n\t\t}\n\n#define UINT64OUT() { uint64_t _i; \\\n\t\t\t_i = GET_BE_U_8(bp); \\\n\t\t\tbp += sizeof(uint64_t); \\\n\t\t\tND_PRINT(\" %\" PRIu64, _i); \\\n\t\t}\n\n#define DATEOUT() { time_t _t; struct tm *tm; char str[256]; \\\n\t\t\t_t = (time_t) GET_BE_S_4(bp); \\\n\t\t\tbp += sizeof(int32_t); \\\n\t\t\ttm = localtime(&_t); \\\n\t\t\tstrftime(str, 256, \"%Y/%m/%d %H:%M:%S\", tm); \\\n\t\t\tND_PRINT(\" %s\", str); \\\n\t\t}\n\n#define STOREATTROUT() { uint32_t mask, _i; \\\n\t\t\tND_TCHECK_LEN(bp, (sizeof(uint32_t) * 6)); \\\n\t\t\tmask = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t\tif (mask) ND_PRINT(\" StoreStatus\"); \\\n\t\t        if (mask & 1) { ND_PRINT(\" date\"); DATEOUT(); } \\\n\t\t\telse bp += sizeof(uint32_t); \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 2) ND_PRINT(\" owner %u\", _i);  \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 4) ND_PRINT(\" group %u\", _i); \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 8) ND_PRINT(\" mode %o\", _i & 07777); \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 16) ND_PRINT(\" segsize %u\", _i); \\\n\t\t\t/* undocumented in 3.3 docu */ \\\n\t\t        if (mask & 1024) ND_PRINT(\" fsync\");  \\\n\t\t}\n\n#define UBIK_VERSIONOUT() {uint32_t epoch; uint32_t counter; \\\n\t\t\tND_TCHECK_LEN(bp, sizeof(uint32_t) * 2); \\\n\t\t\tepoch = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tcounter = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" %u.%u\", epoch, counter); \\\n\t\t}\n\n#define AFSUUIDOUT() {uint32_t temp; int _i; \\\n\t\t\tND_TCHECK_LEN(bp, 11 * sizeof(uint32_t)); \\\n\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" %08x\", temp); \\\n\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\"%04x\", temp); \\\n\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\"%04x\", temp); \\\n\t\t\tfor (_i = 0; _i < 8; _i++) { \\\n\t\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\t\tbp += sizeof(uint32_t); \\\n\t\t\t\tND_PRINT(\"%02x\", (unsigned char) temp); \\\n\t\t\t} \\\n\t\t}\n\n/*\n * This is the sickest one of all\n * MAX is expected to be a constant here\n */\n\n#define VECOUT(MAX) { u_char *sp; \\\n\t\t\tu_char s[(MAX) + 1]; \\\n\t\t\tuint32_t k; \\\n\t\t\tND_TCHECK_LEN(bp, (MAX) * sizeof(uint32_t)); \\\n\t\t\tsp = s; \\\n\t\t\tfor (k = 0; k < (MAX); k++) { \\\n\t\t\t\t*sp++ = (u_char) GET_BE_U_4(bp); \\\n\t\t\t\tbp += sizeof(uint32_t); \\\n\t\t\t} \\\n\t\t\ts[(MAX)] = '\\0'; \\\n\t\t\tND_PRINT(\" \\\"\"); \\\n\t\t\tfn_print_str(ndo, s); \\\n\t\t\tND_PRINT(\"\\\"\"); \\\n\t\t}\n\n#define DESTSERVEROUT() { uint32_t n1, n2, n3; \\\n\t\t\tND_TCHECK_LEN(bp, sizeof(uint32_t) * 3); \\\n\t\t\tn1 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn2 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn3 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" server %u:%u:%u\", n1, n2, n3); \\\n\t\t}\n\n/*\n * Handle calls to the AFS file service (fs)\n */\n\nstatic void\nfs_print(netdissect_options *ndo,\n         const u_char *bp, u_int length)\n{\n\tuint32_t fs_op;\n\tuint32_t i;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afsint.xg\n\t */\n\n\tfs_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" fs call %s\", tok2str(fs_req, \"op#%u\", fs_op));\n\n\t/*\n\t * Print out arguments to some of the AFS calls.  This stuff is\n\t * all from afsint.xg\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\t/*\n\t * Sigh.  This is gross.  Ritchie forgive me.\n\t */\n\n\tswitch (fs_op) {\n\t\tcase 130:\t/* Fetch data */\n\t\t\tFIDOUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 131:\t/* Fetch ACL */\n\t\tcase 132:\t/* Fetch Status */\n\t\tcase 143:\t/* Old set lock */\n\t\tcase 144:\t/* Old extend lock */\n\t\tcase 145:\t/* Old release lock */\n\t\tcase 156:\t/* Set lock */\n\t\tcase 157:\t/* Extend lock */\n\t\tcase 158:\t/* Release lock */\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 135:\t/* Store status */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tbreak;\n\t\tcase 133:\t/* Store data */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flen\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 134:\t/* Store ACL */\n\t\t{\n\t\t\tchar a[AFSOPAQUEMAX+1];\n\t\t\tFIDOUT();\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_TCHECK_LEN(bp, i);\n\t\t\ti = ND_MIN(AFSOPAQUEMAX, i);\n\t\t\tstrncpy(a, (const char *) bp, i);\n\t\t\ta[i] = '\\0';\n\t\t\tacl_print(ndo, (u_char *) a, (u_char *) a + i);\n\t\t\tbreak;\n\t\t}\n\t\tcase 137:\t/* Create file */\n\t\tcase 141:\t/* MakeDir */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tSTOREATTROUT();\n\t\t\tbreak;\n\t\tcase 136:\t/* Remove file */\n\t\tcase 142:\t/* Remove directory */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 138:\t/* Rename file */\n\t\t\tND_PRINT(\" old\");\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" new\");\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 139:\t/* Symlink */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" link to\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 140:\t/* Link */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" link to\");\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 148:\t/* Get volume info */\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 149:\t/* Get volume stats */\n\t\tcase 150:\t/* Set volume stats */\n\t\t\tND_PRINT(\" volid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 154:\t/* New get volume info */\n\t\t\tND_PRINT(\" volname\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 155:\t/* Bulk stat */\n\t\tcase 65536:     /* Inline bulk stat */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tFIDOUT();\n\t\t\t\tif (i != j - 1)\n\t\t\t\t\tND_PRINT(\",\");\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t\tbreak;\n\t\t}\n\t\tcase 65537:\t/* Fetch data 64 */\n\t\t\tFIDOUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINT64OUT();\n\t\t\tbreak;\n\t\tcase 65538:\t/* Store data 64 */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT(\" flen\");\n\t\t\tUINT64OUT();\n\t\t\tbreak;\n\t\tcase 65541:    /* CallBack rx conn address */\n\t\t\tND_PRINT(\" addr\");\n\t\t\tUINTOUT();\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|fs]\");\n}\n\n/*\n * Handle replies to the AFS file service\n */\n\nstatic void\nfs_reply_print(netdissect_options *ndo,\n               const u_char *bp, u_int length, uint32_t opcode)\n{\n\tuint32_t i;\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afsint.xg\n\t */\n\n\tND_PRINT(\" fs reply %s\", tok2str(fs_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA) {\n\t\tswitch (opcode) {\n\t\tcase 131:\t/* Fetch ACL */\n\t\t{\n\t\t\tchar a[AFSOPAQUEMAX+1];\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_TCHECK_LEN(bp, i);\n\t\t\ti = ND_MIN(AFSOPAQUEMAX, i);\n\t\t\tstrncpy(a, (const char *) bp, i);\n\t\t\ta[i] = '\\0';\n\t\t\tacl_print(ndo, (u_char *) a, (u_char *) a + i);\n\t\t\tbreak;\n\t\t}\n\t\tcase 137:\t/* Create file */\n\t\tcase 141:\t/* MakeDir */\n\t\t\tND_PRINT(\" new\");\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 151:\t/* Get root volume */\n\t\t\tND_PRINT(\" root volume\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 153:\t/* Get time */\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t} else if (type == RX_PACKET_TYPE_ABORT) {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tint32_t errcode;\n\n\t\terrcode = GET_BE_S_4(bp);\n\t\tbp += sizeof(int32_t);\n\n\t\tND_PRINT(\" error %s\", tok2str(afs_fs_errors, \"#%d\", errcode));\n\t} else {\n\t\tND_PRINT(\" strange fs reply of type %u\", type);\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|fs]\");\n}\n\n/*\n * Print out an AFS ACL string.  An AFS ACL is a string that has the\n * following format:\n *\n * <positive> <negative>\n * <uid1> <aclbits1>\n * ....\n *\n * \"positive\" and \"negative\" are integers which contain the number of\n * positive and negative ACL's in the string.  The uid/aclbits pair are\n * ASCII strings containing the UID/PTS record and an ASCII number\n * representing a logical OR of all the ACL permission bits\n */\n\n#define XSTRINGIFY(x) #x\n#define NUMSTRINGIFY(x)\tXSTRINGIFY(x)\n\nstatic void\nacl_print(netdissect_options *ndo,\n          u_char *s, const u_char *end)\n{\n\tint pos, neg, acl;\n\tint n, i;\n\tchar user[USERNAMEMAX+1];\n\n\tif (sscanf((char *) s, \"%d %d\\n%n\", &pos, &neg, &n) != 2)\n\t\treturn;\n\n\ts += n;\n\n\tif (s > end)\n\t\treturn;\n\n\t/*\n\t * This wacky order preserves the order used by the \"fs\" command\n\t */\n\n#define ACLOUT(acl) \\\n\tND_PRINT(\"%s%s%s%s%s%s%s\", \\\n\t          acl & PRSFS_READ       ? \"r\" : \"\", \\\n\t          acl & PRSFS_LOOKUP     ? \"l\" : \"\", \\\n\t          acl & PRSFS_INSERT     ? \"i\" : \"\", \\\n\t          acl & PRSFS_DELETE     ? \"d\" : \"\", \\\n\t          acl & PRSFS_WRITE      ? \"w\" : \"\", \\\n\t          acl & PRSFS_LOCK       ? \"k\" : \"\", \\\n\t          acl & PRSFS_ADMINISTER ? \"a\" : \"\");\n\n\tfor (i = 0; i < pos; i++) {\n\t\tif (sscanf((char *) s, \"%\" NUMSTRINGIFY(USERNAMEMAX) \"s %d\\n%n\", user, &acl, &n) != 2)\n\t\t\treturn;\n\t\ts += n;\n\t\tND_PRINT(\" +{\");\n\t\tfn_print_str(ndo, (u_char *)user);\n\t\tND_PRINT(\" \");\n\t\tACLOUT(acl);\n\t\tND_PRINT(\"}\");\n\t\tif (s > end)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < neg; i++) {\n\t\tif (sscanf((char *) s, \"%\" NUMSTRINGIFY(USERNAMEMAX) \"s %d\\n%n\", user, &acl, &n) != 2)\n\t\t\treturn;\n\t\ts += n;\n\t\tND_PRINT(\" -{\");\n\t\tfn_print_str(ndo, (u_char *)user);\n\t\tND_PRINT(\" \");\n\t\tACLOUT(acl);\n\t\tND_PRINT(\"}\");\n\t\tif (s > end)\n\t\t\treturn;\n\t}\n}\n\n#undef ACLOUT\n\n/*\n * Handle calls to the AFS callback service\n */\n\nstatic void\ncb_print(netdissect_options *ndo,\n         const u_char *bp, u_int length)\n{\n\tuint32_t cb_op;\n\tuint32_t i;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afscbint.xg\n\t */\n\n\tcb_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" cb call %s\", tok2str(cb_req, \"op#%u\", cb_op));\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afscbint.xg\n\t */\n\n\tswitch (cb_op) {\n\t\tcase 204:\t\t/* Callback */\n\t\t{\n\t\t\tuint32_t j, t;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tFIDOUT();\n\t\t\t\tif (i != j - 1)\n\t\t\t\t\tND_PRINT(\",\");\n\t\t\t}\n\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\tif (j != 0)\n\t\t\t\tND_PRINT(\";\");\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tND_PRINT(\" ver\");\n\t\t\t\tINTOUT();\n\t\t\t\tND_PRINT(\" expires\");\n\t\t\t\tDATEOUT();\n\t\t\t\tt = GET_BE_U_4(bp);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t\ttok2str(cb_types, \"type %u\", t);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 214: {\n\t\t\tND_PRINT(\" afsuuid\");\n\t\t\tAFSUUIDOUT();\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|cb]\");\n}\n\n/*\n * Handle replies to the AFS Callback Service\n */\n\nstatic void\ncb_reply_print(netdissect_options *ndo,\n               const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afscbint.xg\n\t */\n\n\tND_PRINT(\" cb reply %s\", tok2str(cb_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 213:\t/* InitCallBackState3 */\n\t\t\tAFSUUIDOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t;\n\t\t}\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|cb]\");\n}\n\n/*\n * Handle calls to the AFS protection database server\n */\n\nstatic void\nprot_print(netdissect_options *ndo,\n           const u_char *bp, u_int length)\n{\n\tuint32_t i;\n\tuint32_t pt_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ptserver/ptint.xg\n\t */\n\n\tpt_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" pt\");\n\n\tif (is_ubik(pt_op)) {\n\t\tubik_print(ndo, bp);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" call %s\", tok2str(pt_req, \"op#%u\", pt_op));\n\n\t/*\n\t * Decode some of the arguments to the PT calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (pt_op) {\n\t\tcase 500:\t/* I New User */\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" oldid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 501:\t/* Where is it */\n\t\tcase 506:\t/* Delete */\n\t\tcase 508:\t/* Get CPS */\n\t\tcase 512:\t/* List entry */\n\t\tcase 514:\t/* List elements */\n\t\tcase 517:\t/* List owned */\n\t\tcase 518:\t/* Get CPS2 */\n\t\tcase 519:\t/* Get host CPS */\n\t\tcase 530:\t/* List super groups */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 502:\t/* Dump entry */\n\t\t\tND_PRINT(\" pos\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 503:\t/* Add to group */\n\t\tcase 507:\t/* Remove from group */\n\t\tcase 515:\t/* Is a member of? */\n\t\t\tND_PRINT(\" uid\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" gid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 504:\t/* Name to ID */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * Who designed this chicken-shit protocol?\n\t\t\t *\n\t\t\t * Each character is stored as a 32-bit\n\t\t\t * integer!\n\t\t\t */\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tVECOUT(PRNAMEMAX);\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t/* Id to name */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tND_PRINT(\" ids:\");\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tINTOUT();\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 509:\t/* New entry */\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tND_PRINT(\" flag\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" oid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 511:\t/* Set max */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" gflag\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 513:\t/* Change entry */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tND_PRINT(\" oldid\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" newid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 520:\t/* Update entry */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|pt]\");\n}\n\n/*\n * Handle replies to the AFS protection service\n */\n\nstatic void\nprot_reply_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\tuint32_t i;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ptserver/ptint.xg.  Check to see if it's a\n\t * Ubik call, however.\n\t */\n\n\tND_PRINT(\" pt\");\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" reply %s\", tok2str(pt_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 504:\t\t/* Name to ID */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tND_PRINT(\" ids:\");\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tINTOUT();\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t\t/* ID to name */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * Who designed this chicken-shit protocol?\n\t\t\t *\n\t\t\t * Each character is stored as a 32-bit\n\t\t\t * integer!\n\t\t\t */\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tVECOUT(PRNAMEMAX);\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 508:\t\t/* Get CPS */\n\t\tcase 514:\t\t/* List elements */\n\t\tcase 517:\t\t/* List owned */\n\t\tcase 518:\t\t/* Get CPS2 */\n\t\tcase 519:\t\t/* Get host CPS */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tINTOUT();\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 510:\t\t/* List max */\n\t\t\tND_PRINT(\" maxuid\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" maxgid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|pt]\");\n}\n\n/*\n * Handle calls to the AFS volume location database service\n */\n\nstatic void\nvldb_print(netdissect_options *ndo,\n           const u_char *bp, u_int length)\n{\n\tuint32_t vldb_op;\n\tuint32_t i;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from vlserver/vldbint.xg\n\t */\n\n\tvldb_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" vldb\");\n\n\tif (is_ubik(vldb_op)) {\n\t\tubik_print(ndo, bp);\n\t\treturn;\n\t}\n\tND_PRINT(\" call %s\", tok2str(vldb_req, \"op#%u\", vldb_op));\n\n\t/*\n\t * Decode some of the arguments to the VLDB calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (vldb_op) {\n\t\tcase 501:\t/* Create new volume */\n\t\tcase 517:\t/* Create entry N */\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 502:\t/* Delete entry */\n\t\tcase 503:\t/* Get entry by ID */\n\t\tcase 507:\t/* Update entry */\n\t\tcase 508:\t/* Set lock */\n\t\tcase 509:\t/* Release lock */\n\t\tcase 518:\t/* Get entry by ID N */\n\t\t\tND_PRINT(\" volid\");\n\t\t\tINTOUT();\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tif (i <= 2)\n\t\t\t\tND_PRINT(\" type %s\", voltype[i]);\n\t\t\tbreak;\n\t\tcase 504:\t/* Get entry by name */\n\t\tcase 519:\t/* Get entry by name N */\n\t\tcase 524:\t/* Update entry by name */\n\t\tcase 527:\t/* Get entry by name U */\n\t\t\tSTROUT(VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 505:\t/* Get new vol id */\n\t\t\tND_PRINT(\" bump\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 506:\t/* Replace entry */\n\t\tcase 520:\t/* Replace entry N */\n\t\t\tND_PRINT(\" volid\");\n\t\t\tINTOUT();\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tif (i <= 2)\n\t\t\t\tND_PRINT(\" type %s\", voltype[i]);\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 510:\t/* List entry */\n\t\tcase 521:\t/* List entry N */\n\t\t\tND_PRINT(\" index\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vldb]\");\n}\n\n/*\n * Handle replies to the AFS volume location database service\n */\n\nstatic void\nvldb_reply_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\tuint32_t i;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from vlserver/vldbint.xg.  Check to see if it's a\n\t * Ubik call, however.\n\t */\n\n\tND_PRINT(\" vldb\");\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" reply %s\", tok2str(vldb_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 510:\t/* List entry */\n\t\t\tND_PRINT(\" count\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" nextindex\");\n\t\t\tINTOUT();\n\t\t\tND_FALL_THROUGH;\n\t\tcase 503:\t/* Get entry by id */\n\t\tcase 504:\t/* Get entry by name */\n\t\t{\tuint32_t nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_TCHECK_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" numservers\");\n\t\t\tnservers = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" %u\", nservers);\n\t\t\tND_PRINT(\" servers\");\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tND_TCHECK_4(bp);\n\t\t\t\tif (i < nservers)\n\t\t\t\t\tND_PRINT(\" %s\",\n\t\t\t\t\t   intoa(GET_IPV4_TO_NETWORK_ORDER(bp)));\n\t\t\t\tbp += sizeof(nd_ipv4);\n\t\t\t}\n\t\t\tND_PRINT(\" partitions\");\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT(\" %c\", 'a' + j);\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT(\" %u\", j);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 8 * sizeof(uint32_t));\n\t\t\tbp += 8 * sizeof(uint32_t);\n\t\t\tND_PRINT(\" rwvol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" rovol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t/* Get new volume ID */\n\t\t\tND_PRINT(\" newvol\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 521:\t/* List entry */\n\t\tcase 529:\t/* List entry U */\n\t\t\tND_PRINT(\" count\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" nextindex\");\n\t\t\tINTOUT();\n\t\t\tND_FALL_THROUGH;\n\t\tcase 518:\t/* Get entry by ID N */\n\t\tcase 519:\t/* Get entry by name N */\n\t\t{\tuint32_t nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_PRINT(\" numservers\");\n\t\t\tnservers = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" %u\", nservers);\n\t\t\tND_PRINT(\" servers\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tND_TCHECK_4(bp);\n\t\t\t\tif (i < nservers)\n\t\t\t\t\tND_PRINT(\" %s\",\n\t\t\t\t\t   intoa(GET_IPV4_TO_NETWORK_ORDER(bp)));\n\t\t\t\tbp += sizeof(nd_ipv4);\n\t\t\t}\n\t\t\tND_PRINT(\" partitions\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT(\" %c\", 'a' + j);\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT(\" %u\", j);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 13 * sizeof(uint32_t));\n\t\t\tbp += 13 * sizeof(uint32_t);\n\t\t\tND_PRINT(\" rwvol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" rovol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t}\n\t\t\tbreak;\n\t\tcase 526:\t/* Get entry by ID U */\n\t\tcase 527:\t/* Get entry by name U */\n\t\t{\tuint32_t nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_PRINT(\" numservers\");\n\t\t\tnservers = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" %u\", nservers);\n\t\t\tND_PRINT(\" servers\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tif (i < nservers) {\n\t\t\t\t\tND_PRINT(\" afsuuid\");\n\t\t\t\t\tAFSUUIDOUT();\n\t\t\t\t} else {\n\t\t\t\t\tND_TCHECK_LEN(bp, 44);\n\t\t\t\t\tbp += 44;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 4 * 13);\n\t\t\tbp += 4 * 13;\n\t\t\tND_PRINT(\" partitions\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT(\" %c\", 'a' + j);\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT(\" %u\", j);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 13 * sizeof(uint32_t));\n\t\t\tbp += 13 * sizeof(uint32_t);\n\t\t\tND_PRINT(\" rwvol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" rovol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t}\n\t\tdefault:\n\t\t\t;\n\t\t}\n\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vldb]\");\n}\n\n/*\n * Handle calls to the AFS Kerberos Authentication service\n */\n\nstatic void\nkauth_print(netdissect_options *ndo,\n            const u_char *bp, u_int length)\n{\n\tuint32_t kauth_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from kauth/kauth.rg\n\t */\n\n\tkauth_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" kauth\");\n\n\tif (is_ubik(kauth_op)) {\n\t\tubik_print(ndo, bp);\n\t\treturn;\n\t}\n\n\n\tND_PRINT(\" call %s\", tok2str(kauth_req, \"op#%u\", kauth_op));\n\n\t/*\n\t * Decode some of the arguments to the KA calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (kauth_op) {\n\t\tcase 1:\t\t/* Authenticate old */\n\t\tcase 21:\t/* Authenticate */\n\t\tcase 22:\t/* Authenticate-V2 */\n\t\tcase 2:\t\t/* Change PW */\n\t\tcase 5:\t\t/* Set fields */\n\t\tcase 6:\t\t/* Create user */\n\t\tcase 7:\t\t/* Delete user */\n\t\tcase 8:\t\t/* Get entry */\n\t\tcase 14:\t/* Unlock */\n\t\tcase 15:\t/* Lock status */\n\t\t\tND_PRINT(\" principal\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* GetTicket-old */\n\t\tcase 23:\t/* GetTicket */\n\t\t{\n\t\t\tuint32_t i;\n\t\t\tND_PRINT(\" kvno\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" domain\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_TCHECK_LEN(bp, i);\n\t\t\tbp += i;\n\t\t\tND_PRINT(\" principal\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:\t\t/* Set Password */\n\t\t\tND_PRINT(\" principal\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tND_PRINT(\" kvno\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 12:\t/* Get password */\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|kauth]\");\n}\n\n/*\n * Handle replies to the AFS Kerberos Authentication Service\n */\n\nstatic void\nkauth_reply_print(netdissect_options *ndo,\n                  const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from kauth/kauth.rg\n\t */\n\n\tND_PRINT(\" kauth\");\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" reply %s\", tok2str(kauth_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\t/* Well, no, not really.  Leave this for later */\n\t\t;\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n}\n\n/*\n * Handle calls to the AFS Volume location service\n */\n\nstatic void\nvol_print(netdissect_options *ndo,\n          const u_char *bp, u_int length)\n{\n\tuint32_t vol_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from volser/volint.xg\n\t */\n\n\tvol_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" vol call %s\", tok2str(vol_req, \"op#%u\", vol_op));\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (vol_op) {\n\t\tcase 100:\t/* Create volume */\n\t\t\tND_PRINT(\" partition\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" type\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" parent\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 101:\t/* Delete volume */\n\t\tcase 107:\t/* Get flags */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 102:\t/* Restore */\n\t\t\tND_PRINT(\" totrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 103:\t/* Forward */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\tDESTSERVEROUT();\n\t\t\tND_PRINT(\" desttrans\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 104:\t/* End trans */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 105:\t/* Clone */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" purgevol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" newtype\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" newname\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 106:\t/* Set flags */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 108:\t/* Trans create */\n\t\t\tND_PRINT(\" vol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" partition\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 109:\t/* Dump */\n\t\tcase 655537:\t/* Get size */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tcase 110:\t/* Get n-th volume */\n\t\t\tND_PRINT(\" index\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 111:\t/* Set forwarding */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" newsite\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 112:\t/* Get name */\n\t\tcase 113:\t/* Get status */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tbreak;\n\t\tcase 114:\t/* Signal restore */\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" type\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" pid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" cloneid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 116:\t/* List volumes */\n\t\t\tND_PRINT(\" partition\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 117:\t/* Set id types */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" type\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" pid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" clone\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 119:\t/* Partition info */\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 120:\t/* Reclone */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 121:\t/* List one volume */\n\t\tcase 122:\t/* Nuke volume */\n\t\tcase 124:\t/* Extended List volumes */\n\t\tcase 125:\t/* Extended List one volume */\n\t\tcase 65536:\t/* Convert RO to RW volume */\n\t\t\tND_PRINT(\" partid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" volid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 123:\t/* Set date */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" date\");\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tcase 126:\t/* Set info */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 128:\t/* Forward multiple */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\t{\n\t\t\t\tuint32_t i, j;\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\t\tDESTSERVEROUT();\n\t\t\t\t\tif (i != j - 1)\n\t\t\t\t\t\tND_PRINT(\",\");\n\t\t\t\t}\n\t\t\t\tif (j == 0)\n\t\t\t\t\tND_PRINT(\" <none!>\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 65538:\t/* Dump version 2 */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vol]\");\n}\n\n/*\n * Handle replies to the AFS Volume Service\n */\n\nstatic void\nvol_reply_print(netdissect_options *ndo,\n                const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from volser/volint.xg\n\t */\n\n\tND_PRINT(\" vol reply %s\", tok2str(vol_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA) {\n\t\tswitch (opcode) {\n\t\t\tcase 100:\t/* Create volume */\n\t\t\t\tND_PRINT(\" volid\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" trans\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 104:\t/* End transaction */\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 105:\t/* Clone */\n\t\t\t\tND_PRINT(\" newvol\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 107:\t/* Get flags */\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 108:\t/* Transaction create */\n\t\t\t\tND_PRINT(\" trans\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 110:\t/* Get n-th volume */\n\t\t\t\tND_PRINT(\" volume\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" partition\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 112:\t/* Get name */\n\t\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\t\tbreak;\n\t\t\tcase 113:\t/* Get status */\n\t\t\t\tND_PRINT(\" volid\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" nextuniq\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" type\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" parentid\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" clone\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" backup\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" restore\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" maxquota\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" minquota\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" owner\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" create\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" access\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" update\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" expire\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" backup\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" copy\");\n\t\t\t\tDATEOUT();\n\t\t\t\tbreak;\n\t\t\tcase 115:\t/* Old list partitions */\n\t\t\t\tbreak;\n\t\t\tcase 116:\t/* List volumes */\n\t\t\tcase 121:\t/* List one volume */\n\t\t\t\t{\n\t\t\t\t\tuint32_t i, j;\n\t\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\t\t\tND_PRINT(\" name\");\n\t\t\t\t\t\tVECOUT(32);\n\t\t\t\t\t\tND_PRINT(\" volid\");\n\t\t\t\t\t\tUINTOUT();\n\t\t\t\t\t\tND_PRINT(\" type\");\n\t\t\t\t\t\tbp += sizeof(uint32_t) * 21;\n\t\t\t\t\t\tif (i != j - 1)\n\t\t\t\t\t\t\tND_PRINT(\",\");\n\t\t\t\t\t}\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\tND_PRINT(\" <none!>\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vol]\");\n}\n\n/*\n * Handle calls to the AFS BOS service\n */\n\nstatic void\nbos_print(netdissect_options *ndo,\n          const u_char *bp, u_int length)\n{\n\tuint32_t bos_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from bozo/bosint.xg\n\t */\n\n\tbos_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" bos call %s\", tok2str(bos_req, \"op#%u\", bos_op));\n\n\t/*\n\t * Decode some of the arguments to the BOS calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (bos_op) {\n\t\tcase 80:\t/* Create B node */\n\t\t\tND_PRINT(\" type\");\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" instance\");\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 81:\t/* Delete B node */\n\t\tcase 83:\t/* Get status */\n\t\tcase 85:\t/* Get instance info */\n\t\tcase 87:\t/* Add super user */\n\t\tcase 88:\t/* Delete super user */\n\t\tcase 93:\t/* Set cell name */\n\t\tcase 96:\t/* Add cell host */\n\t\tcase 97:\t/* Delete cell host */\n\t\tcase 104:\t/* Restart */\n\t\tcase 106:\t/* Uninstall */\n\t\tcase 108:\t/* Exec */\n\t\tcase 112:\t/* Getlog */\n\t\tcase 114:\t/* Get instance strings */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 82:\t/* Set status */\n\t\tcase 98:\t/* Set T status */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" status\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 86:\t/* Get instance parm */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" num\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 84:\t/* Enumerate instance */\n\t\tcase 89:\t/* List super users */\n\t\tcase 90:\t/* List keys */\n\t\tcase 91:\t/* Add key */\n\t\tcase 92:\t/* Delete key */\n\t\tcase 95:\t/* Get cell host */\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 105:\t/* Install */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" size\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" date\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|bos]\");\n}\n\n/*\n * Handle replies to the AFS BOS Service\n */\n\nstatic void\nbos_reply_print(netdissect_options *ndo,\n                const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from volser/volint.xg\n\t */\n\n\tND_PRINT(\" bos reply %s\", tok2str(bos_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\t/* Well, no, not really.  Leave this for later */\n\t\t;\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n}\n\n/*\n * Check to see if this is a Ubik opcode.\n */\n\nstatic int\nis_ubik(uint32_t opcode)\n{\n\tif ((opcode >= VOTE_LOW && opcode <= VOTE_HIGH) ||\n\t    (opcode >= DISK_LOW && opcode <= DISK_HIGH))\n\t\treturn(1);\n\telse\n\t\treturn(0);\n}\n\n/*\n * Handle Ubik opcodes to any one of the replicated database services\n */\n\nstatic void\nubik_print(netdissect_options *ndo,\n           const u_char *bp)\n{\n\tuint32_t ubik_op;\n\tuint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\t/* Every function that calls this function first makes a bounds check\n\t * for (sizeof(rx_header) + 4) bytes, so long as it remains this way\n\t * the line below will not over-read.\n\t */\n\tubik_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" ubik call %s\", tok2str(ubik_req, \"op#%u\", ubik_op));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\ttemp = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" syncsite %s\", temp ? \"yes\" : \"no\");\n\t\t\tND_PRINT(\" votestart\");\n\t\t\tDATEOUT();\n\t\t\tND_PRINT(\" dbversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT(\" site\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" pos\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tINTOUT();\n\t\t\ttemp = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %u\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" pos\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" dbversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" oldversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" newversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|ubik]\");\n}\n\n/*\n * Handle Ubik replies to any one of the replicated database services\n */\n\nstatic void\nubik_reply_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the ubik call we're invoking.  This table was gleaned\n\t * from ubik/ubik_int.xg\n\t */\n\n\tND_PRINT(\" ubik reply %s\", tok2str(ubik_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, print out the arguments to the Ubik calls\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_PRINT(\" vote no\");\n\t\t\tbreak;\n\t\tcase 20004:\t\t/* Get version */\n\t\t\tND_PRINT(\" dbversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\n\t/*\n\t * Otherwise, print out \"yes\" if it was a beacon packet (because\n\t * that's how yes votes are returned, go figure), otherwise\n\t * just print out the error code.\n\t */\n\n\telse\n\t\tswitch (opcode) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_PRINT(\" vote yes until\");\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT(\" errcode\");\n\t\t\tINTOUT();\n\t\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|ubik]\");\n}\n\n/*\n * Handle RX ACK packets.\n */\n\nstatic void\nrx_ack_print(netdissect_options *ndo,\n             const u_char *bp, u_int length)\n{\n\tconst struct rx_ackPacket *rxa;\n\tuint8_t nAcks;\n\tint i, start, last;\n\tuint32_t firstPacket;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\tbp += sizeof(struct rx_header);\n\n\tND_TCHECK_LEN(bp, sizeof(struct rx_ackPacket));\n\n\trxa = (const struct rx_ackPacket *) bp;\n\tbp += sizeof(struct rx_ackPacket);\n\n\t/*\n\t * Print out a few useful things from the ack packet structure\n\t */\n\n\tif (ndo->ndo_vflag > 2)\n\t\tND_PRINT(\" bufspace %u maxskew %u\",\n\t\t       GET_BE_U_2(rxa->bufferSpace),\n\t\t       GET_BE_U_2(rxa->maxSkew));\n\n\tfirstPacket = GET_BE_U_4(rxa->firstPacket);\n\tND_PRINT(\" first %u serial %u reason %s\",\n\t       firstPacket, GET_BE_U_4(rxa->serial),\n\t       tok2str(rx_ack_reasons, \"#%u\", GET_U_1(rxa->reason)));\n\n\t/*\n\t * Okay, now we print out the ack array.  The way _this_ works\n\t * is that we start at \"first\", and step through the ack array.\n\t * If we have a contiguous range of acks/nacks, try to\n\t * collapse them into a range.\n\t *\n\t * If you're really clever, you might have noticed that this\n\t * doesn't seem quite correct.  Specifically, due to structure\n\t * padding, sizeof(struct rx_ackPacket) - RX_MAXACKS won't actually\n\t * yield the start of the ack array (because RX_MAXACKS is 255\n\t * and the structure will likely get padded to a 2 or 4 byte\n\t * boundary).  However, this is the way it's implemented inside\n\t * of AFS - the start of the extra fields are at\n\t * sizeof(struct rx_ackPacket) - RX_MAXACKS + nAcks, which _isn't_\n\t * the exact start of the ack array.  Sigh.  That's why we aren't\n\t * using bp, but instead use rxa->acks[].  But nAcks gets added\n\t * to bp after this, so bp ends up at the right spot.  Go figure.\n\t */\n\n\tnAcks = GET_U_1(rxa->nAcks);\n\tif (nAcks != 0) {\n\n\t\tND_TCHECK_LEN(bp, nAcks);\n\n\t\t/*\n\t\t * Sigh, this is gross, but it seems to work to collapse\n\t\t * ranges correctly.\n\t\t */\n\n\t\tfor (i = 0, start = last = -2; i < nAcks; i++)\n\t\t\tif (GET_U_1(bp + i) == RX_ACK_TYPE_ACK) {\n\n\t\t\t\t/*\n\t\t\t\t * I figured this deserved _some_ explanation.\n\t\t\t\t * First, print \"acked\" and the packet seq\n\t\t\t\t * number if this is the first time we've\n\t\t\t\t * seen an acked packet.\n\t\t\t\t */\n\n\t\t\t\tif (last == -2) {\n\t\t\t\t\tND_PRINT(\" acked %u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, if there is a skip in\n\t\t\t\t * the range (such as an nacked packet in\n\t\t\t\t * the middle of some acked packets),\n\t\t\t\t * then print the current packet number\n\t\t\t\t * separated from the last number by\n\t\t\t\t * a comma.\n\t\t\t\t */\n\n\t\t\t\telse if (last != i - 1) {\n\t\t\t\t\tND_PRINT(\",%u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We always set last to the value of\n\t\t\t\t * the last ack we saw.  Conversely, start\n\t\t\t\t * is set to the value of the first ack\n\t\t\t\t * we saw in a range.\n\t\t\t\t */\n\n\t\t\t\tlast = i;\n\n\t\t\t\t/*\n\t\t\t\t * Okay, this bit a code gets executed when\n\t\t\t\t * we hit a nack ... in _this_ case we\n\t\t\t\t * want to print out the range of packets\n\t\t\t\t * that were acked, so we need to print\n\t\t\t\t * the _previous_ packet number separated\n\t\t\t\t * from the first by a dash (-).  Since we\n\t\t\t\t * already printed the first packet above,\n\t\t\t\t * just print the final packet.  Don't\n\t\t\t\t * do this if there will be a single-length\n\t\t\t\t * range.\n\t\t\t\t */\n\t\t\t} else if (last == i - 1 && start != last)\n\t\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\t/*\n\t\t * So, what's going on here?  We ran off the end of the\n\t\t * ack list, and if we got a range we need to finish it up.\n\t\t * So we need to determine if the last packet in the list\n\t\t * was an ack (if so, then last will be set to it) and\n\t\t * we need to see if the last range didn't start with the\n\t\t * last packet (because if it _did_, then that would mean\n\t\t * that the packet number has already been printed and\n\t\t * we don't need to print it again).\n\t\t */\n\n\t\tif (last == i - 1 && start != last)\n\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\t/*\n\t\t * Same as above, just without comments\n\t\t */\n\n\t\tfor (i = 0, start = last = -2; i < nAcks; i++)\n\t\t\tif (GET_U_1(bp + i) == RX_ACK_TYPE_NACK) {\n\t\t\t\tif (last == -2) {\n\t\t\t\t\tND_PRINT(\" nacked %u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t} else if (last != i - 1) {\n\t\t\t\t\tND_PRINT(\",%u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\t\t\t\tlast = i;\n\t\t\t} else if (last == i - 1 && start != last)\n\t\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\tif (last == i - 1 && start != last)\n\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\tbp += nAcks;\n\t}\n\n\t/* Padding. */\n\tbp += 3;\n\n\t/*\n\t * These are optional fields; depending on your version of AFS,\n\t * you may or may not see them\n\t */\n\n#define TRUNCRET(n)\tif (ndo->ndo_snapend - bp + 1 <= n) return;\n\n\tif (ndo->ndo_vflag > 1) {\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" ifmtu\");\n\t\tUINTOUT();\n\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" maxmtu\");\n\t\tUINTOUT();\n\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" rwind\");\n\t\tUINTOUT();\n\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" maxpackets\");\n\t\tUINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|ack]\");\n}\n#undef TRUNCRET\n", "/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* \\summary: ZigBee Encapsulation Protocol (ZEP) printer */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#define ND_LONGJMP_FROM_TCHECK\n#include \"netdissect.h\"\n\n#include \"extract.h\"\n\n/* From wireshark packet-zep.c:\n *\n ***********************************************************************\n *\n * ZEP Packets must be received in the following format:\n *\n * |UDP Header|  ZEP Header |IEEE 802.15.4 Packet|\n * | 8 bytes  | 16/32 bytes |    <= 127 bytes    |\n *\n ***********************************************************************\n *\n * ZEP v1 Header will have the following format:\n * |Preamble|Version|Channel ID|Device ID|CRC/LQI Mode|LQI Val|Reserved|Length|\n * |2 bytes |1 byte |  1 byte  | 2 bytes |   1 byte   |1 byte |7 bytes |1 byte|\n *\n * ZEP v2 Header will have the following format (if type=1/Data):\n * |Prmbl|Ver  |Type |ChnlID|DevID|C/L Mode|LQI|NTP TS|Seq#|Res |Len|\n * | 2   | 1   | 1   | 1    | 2   | 1      | 1 | 8    | 4  | 10 | 1 |\n *\n * ZEP v2 Header will have the following format (if type=2/Ack):\n * |Preamble|Version| Type |Sequence#|\n * |2 bytes |1 byte |1 byte| 4 bytes |\n *------------------------------------------------------------\n */\n\n#define     JAN_1970        2208988800U\n\n/* Print timestamp */\nstatic void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           /* some compilers are buggy */\n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); /* shift radix point by 32 bits */\n\tf = (uint32_t) (ff * 1000000000.0);  /* treat fraction as parts per\n\t\t\t\t\t\tbillion */\n\tND_PRINT(\"%u.%09d\", i, f);\n\n\t/*\n\t * print the time in human-readable format.\n\t */\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}\n\n/*\n * Main function to print packets.\n */\n\nvoid\nzep_print(netdissect_options *ndo,\n\t  const u_char *bp, u_int len)\n{\n\tuint8_t version, inner_len;\n\tuint32_t seq_no;\n\n\tndo->ndo_protocol = \"zep\";\n\n\tnd_print_protocol_caps(ndo);\n\n\t/* Preamble Code (must be \"EX\") */\n\tif (GET_U_1(bp) != 'E' || GET_U_1(bp + 1) != 'X') {\n\t\tND_PRINT(\" [Preamble Code: \");\n\t\tfn_print_char(ndo, GET_U_1(bp));\n\t\tfn_print_char(ndo, GET_U_1(bp + 1));\n\t\tND_PRINT(\"]\");\n\t\tnd_print_invalid(ndo);\n\t\treturn;\n\t}\n\n\tversion = GET_U_1(bp + 2);\n\tND_PRINT(\"v%u \", version);\n\n\tif (version == 1) {\n\t\t/* ZEP v1 packet. */\n\t\tND_LCHECK_U(len, 16);\n\t\tND_PRINT(\"Channel ID %u, Device ID 0x%04x, \",\n\t\t\t GET_U_1(bp + 3), GET_BE_U_2(bp + 4));\n\t\tif (GET_U_1(bp + 6))\n\t\t\tND_PRINT(\"CRC, \");\n\t\telse\n\t\t\tND_PRINT(\"LQI %u, \", GET_U_1(bp + 7));\n\t\tinner_len = GET_U_1(bp + 15);\n\t\tND_PRINT(\"inner len = %u\", inner_len);\n\n\t\tbp += 16;\n\t\tlen -= 16;\n\t} else {\n\t\t/* ZEP v2 packet. */\n\t\tif (GET_U_1(bp + 3) == 2) {\n\t\t\t/* ZEP v2 ack. */\n\t\t\tND_LCHECK_U(len, 8);\n\t\t\tseq_no = GET_BE_U_4(bp + 4);\n\t\t\tND_PRINT(\"ACK, seq# = %u\", seq_no);\n\t\t\tinner_len = 0;\n\t\t\tbp += 8;\n\t\t\tlen -= 8;\n\t\t} else {\n\t\t\t/* ZEP v2 data, or some other. */\n\t\t\tND_LCHECK_U(len, 32);\n\t\t\tND_PRINT(\"Type %u, Channel ID %u, Device ID 0x%04x, \",\n\t\t\t\t GET_U_1(bp + 3), GET_U_1(bp + 4),\n\t\t\t\t GET_BE_U_2(bp + 5));\n\t\t\tif (GET_U_1(bp + 7))\n\t\t\t\tND_PRINT(\"CRC, \");\n\t\t\telse\n\t\t\t\tND_PRINT(\"LQI %u, \", GET_U_1(bp + 8));\n\n\t\t\tzep_print_ts(ndo, bp + 9);\n\t\t\tseq_no = GET_BE_U_4(bp + 17);\n\t\t\tinner_len = GET_U_1(bp + 31);\n\t\t\tND_PRINT(\", seq# = %u, inner len = %u\",\n\t\t\t\t seq_no, inner_len);\n\t\t\tbp += 32;\n\t\t\tlen -= 32;\n\t\t}\n\t}\n\n\tif (inner_len != 0) {\n\t\t/* Call 802.15.4 dissector. */\n\t\tND_PRINT(\"\\n\\t\");\n\t\tif (ieee802_15_4_print(ndo, bp, inner_len)) {\n\t\t\tND_TCHECK_LEN(bp, len);\n\t\t\tbp += len;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(bp, len);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n}\n", "/*\n * Copyright (C) Andrew Tridgell 1995-1999\n *\n * This software may be distributed either under the terms of the\n * BSD-style license that accompanies tcpdump or the GNU GPL version 2\n * or later\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"netdissect-ctype.h\"\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"smb.h\"\n\nstatic int stringlen_is_set;\nstatic uint32_t stringlen;\nextern const u_char *startbuf;\n\n/*\n * Reset SMB state.\n */\nvoid\nsmb_reset(void)\n{\n    stringlen_is_set = 0;\n    stringlen = 0;\n}\n\n/*\n * interpret a 32 bit dos packed date/time to some parameters\n */\nstatic void\ninterpret_dos_date(uint32_t date, struct tm *tp)\n{\n    uint32_t p0, p1, p2, p3;\n\n    p0 = date & 0xFF;\n    p1 = ((date & 0xFF00) >> 8) & 0xFF;\n    p2 = ((date & 0xFF0000) >> 16) & 0xFF;\n    p3 = ((date & 0xFF000000) >> 24) & 0xFF;\n\n    tp->tm_sec = 2 * (p0 & 0x1F);\n    tp->tm_min = ((p0 >> 5) & 0xFF) + ((p1 & 0x7) << 3);\n    tp->tm_hour = (p1 >> 3) & 0xFF;\n    tp->tm_mday = (p2 & 0x1F);\n    tp->tm_mon = ((p2 >> 5) & 0xFF) + ((p3 & 0x1) << 3) - 1;\n    tp->tm_year = ((p3 >> 1) & 0xFF) + 80;\n}\n\n/*\n * common portion:\n * create a unix date from a dos date\n */\nstatic time_t\nint_unix_date(uint32_t dos_date)\n{\n    struct tm t;\n\n    if (dos_date == 0)\n\treturn(0);\n\n    interpret_dos_date(dos_date, &t);\n    t.tm_wday = 1;\n    t.tm_yday = 1;\n    t.tm_isdst = 0;\n\n    return (mktime(&t));\n}\n\n/*\n * create a unix date from a dos date\n * in network byte order\n */\nstatic time_t\nmake_unix_date(netdissect_options *ndo, const u_char *date_ptr)\n{\n    uint32_t dos_date = 0;\n\n    dos_date = GET_LE_U_4(date_ptr);\n\n    return int_unix_date(dos_date);\n}\n\n/*\n * create a unix date from a dos date\n * in halfword-swapped network byte order!\n */\nstatic time_t\nmake_unix_date2(netdissect_options *ndo, const u_char *date_ptr)\n{\n    uint32_t x, x2;\n\n    x = GET_LE_U_4(date_ptr);\n    x2 = ((x & 0xFFFF) << 16) | ((x & 0xFFFF0000) >> 16);\n    return int_unix_date(x2);\n}\n\n/*\n * interpret an 8 byte \"filetime\" structure to a time_t\n * It's originally in \"100ns units since jan 1st 1601\"\n */\nstatic time_t\ninterpret_long_date(netdissect_options *ndo, const u_char *p)\n{\n    double d;\n    time_t ret;\n\n    /* this gives us seconds since jan 1st 1601 (approx) */\n    d = (GET_LE_U_4(p + 4) * 256.0 + GET_U_1(p + 3)) * (1.0e-7 * (1 << 24));\n\n    /* now adjust by 369 years to make the secs since 1970 */\n    d -= 369.0 * 365.25 * 24 * 60 * 60;\n\n    /* and a fudge factor as we got it wrong by a few days */\n    d += (3 * 24 * 60 * 60 + 6 * 60 * 60 + 2);\n\n    if (d < 0)\n\treturn(0);\n\n    ret = (time_t)d;\n\n    return(ret);\n}\n\n/*\n * interpret the weird netbios \"name\". Return the name type, or -1 if\n * we run past the end of the buffer\n */\nstatic int\nname_interpret(netdissect_options *ndo,\n               const u_char *in, const u_char *maxbuf, char *out)\n{\n    int ret;\n    u_int len;\n\n    if (in >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    len = GET_U_1(in) / 2;\n    in++;\n\n    *out=0;\n\n    if (len > 30 || len == 0)\n\treturn(0);\n\n    while (len) {\n\tND_TCHECK_2(in);\n\tif (in + 1 >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tif (GET_U_1(in) < 'A' || GET_U_1(in) > 'P' ||\n\t    GET_U_1(in + 1) < 'A' || GET_U_1(in + 1) > 'P') {\n\t    *out = 0;\n\t    return(0);\n\t}\n\t*out = ((GET_U_1(in) - 'A') << 4) + (GET_U_1(in + 1) - 'A');\n\tin += 2;\n\tout++;\n\tlen--;\n    }\n    *out = 0;\n    ret = out[-1];\n\n    return(ret);\n\ntrunc:\n    return(-1);\n}\n\n/*\n * find a pointer to a netbios name\n */\nstatic const u_char *\nname_ptr(netdissect_options *ndo,\n         const u_char *buf, u_int ofs, const u_char *maxbuf)\n{\n    const u_char *p;\n    u_char c;\n\n    p = buf + ofs;\n    if (p >= maxbuf)\n\treturn(NULL);\t/* name goes past the end of the buffer */\n\n    c = GET_U_1(p);\n\n    /* XXX - this should use the same code that the DNS dissector does */\n    if ((c & 0xC0) == 0xC0) {\n\tuint16_t l;\n\n\tND_TCHECK_2(p);\n\tif ((p + 1) >= maxbuf)\n\t    return(NULL);\t/* name goes past the end of the buffer */\n\tl = GET_BE_U_2(p) & 0x3FFF;\n\tif (l == 0) {\n\t    /* We have a pointer that points to itself. */\n\t    return(NULL);\n\t}\n\tp = buf + l;\n\tif (p >= maxbuf)\n\t    return(NULL);\t/* name goes past the end of the buffer */\n\tND_TCHECK_1(p);\n    }\n    return(p);\n\ntrunc:\n    return(NULL);\t/* name goes past the end of the buffer */\n}\n\n/*\n * extract a netbios name from a buf\n */\nstatic int\nname_extract(netdissect_options *ndo,\n             const u_char *buf, u_int ofs, const u_char *maxbuf, char *name)\n{\n    const u_char *p = name_ptr(ndo, buf, ofs, maxbuf);\n    if (p == NULL)\n\treturn(-1);\t/* error (probably name going past end of buffer) */\n    name[0] = '\\0';\n    return(name_interpret(ndo, p, maxbuf, name));\n}\n\n\n/*\n * return the total storage length of a mangled name\n */\nstatic int\nname_len(netdissect_options *ndo,\n         const u_char *s, const u_char *maxbuf)\n{\n    const u_char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    c = GET_U_1(s);\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (GET_U_1(s)) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\ts += GET_U_1(s) + 1;\n\tND_TCHECK_1(s);\n    }\n    return(ND_BYTES_BETWEEN(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n\nstatic void\nprint_asc(netdissect_options *ndo,\n          const u_char *buf, u_int len)\n{\n    u_int i;\n    for (i = 0; i < len; i++)\n        fn_print_char(ndo, GET_U_1(buf + i));\n}\n\nstatic const char *\nname_type_str(int name_type)\n{\n    const char *f = NULL;\n\n    switch (name_type) {\n    case 0:    f = \"Workstation\"; break;\n    case 0x03: f = \"Client?\"; break;\n    case 0x20: f = \"Server\"; break;\n    case 0x1d: f = \"Master Browser\"; break;\n    case 0x1b: f = \"Domain Controller\"; break;\n    case 0x1e: f = \"Browser Server\"; break;\n    default:   f = \"Unknown\"; break;\n    }\n    return(f);\n}\n\nvoid\nsmb_data_print(netdissect_options *ndo, const u_char *buf, u_int len)\n{\n    u_int i = 0;\n\n    if (len == 0)\n\treturn;\n    ND_PRINT(\"[%03X] \", i);\n    for (i = 0; i < len; /*nothing*/) {\n\tND_PRINT(\"%02X \", GET_U_1(buf + i) & 0xff);\n\ti++;\n\tif (i%8 == 0)\n\t    ND_PRINT(\" \");\n\tif (i % 16 == 0) {\n\t    print_asc(ndo, buf + i - 16, 8);\n\t    ND_PRINT(\" \");\n\t    print_asc(ndo, buf + i - 8, 8);\n\t    ND_PRINT(\"\\n\");\n\t    if (i < len)\n\t\tND_PRINT(\"[%03X] \", i);\n\t}\n    }\n    if (i % 16) {\n\tint n;\n\n\tn = 16 - (i % 16);\n\tND_PRINT(\" \");\n\tif (n>8)\n\t    ND_PRINT(\" \");\n\twhile (n--)\n\t    ND_PRINT(\"   \");\n\n\tn = ND_MIN(8, i % 16);\n\tprint_asc(ndo, buf + i - (i % 16), n);\n\tND_PRINT(\" \");\n\tn = (i % 16) - n;\n\tif (n > 0)\n\t    print_asc(ndo, buf + i - n, n);\n\tND_PRINT(\"\\n\");\n    }\n}\n\n\nstatic void\nwrite_bits(netdissect_options *ndo,\n           unsigned int val, const char *fmt)\n{\n    const char *p = fmt;\n    u_int i = 0;\n\n    while ((p = strchr(fmt, '|'))) {\n\tu_int l = ND_BYTES_BETWEEN(p, fmt);\n\tif (l && (val & (1 << i)))\n\t    ND_PRINT(\"%.*s \", (int)l, fmt);\n\tfmt = p + 1;\n\ti++;\n    }\n}\n\n/* convert a UCS-2 string into an ASCII string */\n#define MAX_UNISTR_SIZE\t1000\nstatic const u_char *\nunistr(netdissect_options *ndo, char (*buf)[MAX_UNISTR_SIZE+1],\n       const u_char *s, uint32_t strsize, int is_null_terminated,\n       int use_unicode)\n{\n    u_int c;\n    size_t l = 0;\n    const u_char *sp;\n\n    if (use_unicode) {\n\t/*\n\t * Skip padding that puts the string on an even boundary.\n\t */\n\tif (((s - startbuf) % 2) != 0) {\n\t    ND_TCHECK_1(s);\n\t    s++;\n\t}\n    }\n    if (is_null_terminated) {\n\t/*\n\t * Null-terminated string.\n\t * Find the length, counting the terminating NUL.\n\t */\n\tstrsize = 0;\n\tsp = s;\n\tif (!use_unicode) {\n\t    for (;;) {\n\t\tc = GET_U_1(sp);\n\t\tsp++;\n\t\tstrsize++;\n\t\tif (c == '\\0')\n\t\t    break;\n\t    }\n\t} else {\n\t    for (;;) {\n\t\tc = GET_LE_U_2(sp);\n\t\tsp += 2;\n\t\tstrsize += 2;\n\t\tif (c == '\\0')\n\t\t    break;\n\t    }\n\t}\n    }\n    if (!use_unicode) {\n\twhile (strsize != 0) {\n\t    c = GET_U_1(s);\n\t    s++;\n\t    strsize--;\n\t    if (c == 0) {\n\t\t/*\n\t\t * Even counted strings may have embedded null\n\t\t * terminators, so quit here, and skip past\n\t\t * the rest of the data.\n\t\t *\n\t\t * Make sure, however, that the rest of the data\n\t\t * is there, so we don't overflow the buffer when\n\t\t * skipping past it.\n\t\t */\n\t\tND_TCHECK_LEN(s, strsize);\n\t\ts += strsize;\n\t\tstrsize = 0;\n\t\tbreak;\n\t    }\n\t    if (l < MAX_UNISTR_SIZE) {\n\t\tif (ND_ASCII_ISPRINT(c)) {\n\t\t    /* It's a printable ASCII character */\n\t\t    (*buf)[l] = (char)c;\n\t\t} else {\n\t\t    /* It's a non-ASCII character or a non-printable ASCII character */\n\t\t    (*buf)[l] = '.';\n\t\t}\n\t\tl++;\n\t    }\n\t}\n    } else {\n\twhile (strsize > 1) {\n\t    c = GET_LE_U_2(s);\n\t    s += 2;\n\t    strsize -= 2;\n\t    if (c == 0) {\n\t\t/*\n\t\t * Even counted strings may have embedded null\n\t\t * terminators, so quit here, and skip past\n\t\t * the rest of the data.\n\t\t *\n\t\t * Make sure, however, that the rest of the data\n\t\t * is there, so we don't overflow the buffer when\n\t\t * skipping past it.\n\t\t */\n\t\tND_TCHECK_LEN(s, strsize);\n\t\ts += strsize;\n\t\tstrsize = 0;\n\t\tbreak;\n\t    }\n\t    if (l < MAX_UNISTR_SIZE) {\n\t\tif (ND_ASCII_ISPRINT(c)) {\n\t\t    /* It's a printable ASCII character */\n\t\t    (*buf)[l] = (char)c;\n\t\t} else {\n\t\t    /* It's a non-ASCII character or a non-printable ASCII character */\n\t\t    (*buf)[l] = '.';\n\t\t}\n\t\tl++;\n\t    }\n\t}\n\tif (strsize == 1) {\n\t    /* We have half of a code point; skip past it */\n\t    ND_TCHECK_1(s);\n\t    s++;\n\t}\n    }\n    (*buf)[l] = 0;\n    return s;\n\ntrunc:\n    (*buf)[l] = 0;\n    return NULL;\n}\n\nstatic const u_char *\nsmb_fdata1(netdissect_options *ndo,\n           const u_char *buf, const char *fmt, const u_char *maxbuf,\n           int unicodestr)\n{\n    int reverse = 0;\n    const char *attrib_fmt = \"READONLY|HIDDEN|SYSTEM|VOLUME|DIR|ARCHIVE|\";\n    char strbuf[MAX_UNISTR_SIZE+1];\n\n    while (*fmt && buf<maxbuf) {\n\tswitch (*fmt) {\n\tcase 'a':\n\t    write_bits(ndo, GET_U_1(buf), attrib_fmt);\n\t    buf++;\n\t    fmt++;\n\t    break;\n\n\tcase 'A':\n\t    write_bits(ndo, GET_LE_U_2(buf), attrib_fmt);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\n\tcase '{':\n\t  {\n\t    char bitfmt[128];\n\t    char *p;\n\t    u_int l;\n\n\t    p = strchr(++fmt, '}');\n\t    l = ND_BYTES_BETWEEN(p, fmt);\n\n\t    if (l > sizeof(bitfmt) - 1)\n\t\tl = sizeof(bitfmt)-1;\n\n\t    strncpy(bitfmt, fmt, l);\n\t    bitfmt[l] = '\\0';\n\t    fmt = p + 1;\n\t    write_bits(ndo, GET_U_1(buf), bitfmt);\n\t    buf++;\n\t    break;\n\t  }\n\n\tcase 'P':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'r':\n\t    reverse = !reverse;\n\t    fmt++;\n\t    break;\n\tcase 'b':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'd':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_2(buf) :\n\t\t\t  GET_LE_S_2(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'D':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_4(buf) :\n\t\t\t  GET_LE_S_4(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'L':\n\t  {\n\t    uint64_t x;\n\t    x = reverse ? GET_BE_U_8(buf) :\n\t\t\t  GET_LE_U_8(buf);\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'u':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'U':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'M':\n\t  {\n\t    /* Weird mixed-endian length values in 64-bit locks */\n\t    uint32_t x1, x2;\n\t    uint64_t x;\n\t    ND_TCHECK_8(buf);\n\t    x1 = reverse ? GET_BE_U_4(buf) :\n\t\t\t   GET_LE_U_4(buf);\n\t    x2 = reverse ? GET_BE_U_4(buf + 4) :\n\t\t\t   GET_LE_U_4(buf + 4);\n\t    x = (((uint64_t)x1) << 32) | x2;\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'B':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'w':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'W':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'l':\n\t  {\n\t    fmt++;\n\t    switch (*fmt) {\n\n\t    case 'b':\n\t\tstringlen = GET_U_1(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 1;\n\t\tbreak;\n\n\t    case 'd':\n\t    case 'u':\n\t\tstringlen = reverse ? GET_BE_U_2(buf) :\n\t\t\t\t      GET_LE_U_2(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 2;\n\t\tbreak;\n\n\t    case 'D':\n\t    case 'U':\n\t\tstringlen = reverse ? GET_BE_U_4(buf) :\n\t\t\t\t      GET_LE_U_4(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 4;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'S':\n\tcase 'R':\t/* like 'S', but always ASCII */\n\t  {\n\t    /*XXX unistr() */\n\t    buf = unistr(ndo, &strbuf, buf, 0, 1, (*fmt == 'R') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'Z':\n\tcase 'Y':\t/* like 'Z', but always ASCII */\n\t  {\n\t    if (GET_U_1(buf) != 4 && GET_U_1(buf) != 2) {\n\t\tND_PRINT(\"Error! ASCIIZ buffer of type %u\", GET_U_1(buf));\n\t\treturn maxbuf;\t/* give up */\n\t    }\n\t    buf = unistr(ndo, &strbuf, buf + 1, 0, 1, (*fmt == 'Y') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 's':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    ND_PRINT(\"%-*.*s\", l, l, buf);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'c':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    ND_TCHECK_LEN(buf, stringlen);\n\t    ND_PRINT(\"%-*.*s\", (int)stringlen, (int)stringlen, buf);\n\t    buf += stringlen;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'C':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    buf = unistr(ndo, &strbuf, buf, stringlen, 0, unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'h':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    while (l--) {\n\t\tND_PRINT(\"%02x\", GET_U_1(buf));\n\t\tbuf++;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'n':\n\t  {\n\t    int t = atoi(fmt+1);\n\t    char nbuf[255];\n\t    int name_type;\n\t    int len;\n\n\t    switch (t) {\n\t    case 1:\n\t\tname_type = name_extract(ndo, startbuf, ND_BYTES_BETWEEN(buf, startbuf),\n\t\t    maxbuf, nbuf);\n\t\tif (name_type < 0)\n\t\t    goto trunc;\n\t\tlen = name_len(ndo, buf, maxbuf);\n\t\tif (len < 0)\n\t\t    goto trunc;\n\t\tbuf += len;\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", nbuf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbreak;\n\t    case 2:\n\t\tname_type = GET_U_1(buf + 15);\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", buf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbuf += 16;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    struct tm *lt;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 2:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date2(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 3:\n\t\tND_TCHECK_8(buf);\n\t\tt = interpret_long_date(ndo, buf);\n\t\tbuf += 8;\n\t\tbreak;\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\tlt = localtime(&t);\n\t\tif (lt != NULL) {\n\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T %Y%n\", lt);\n\t\t    tstring = buffer;\n\t\t}\n\t\telse\n\t\t    tstring = \"(Can't convert time)\\n\";\n\t    } else\n\t\ttstring = \"NULL\\n\";\n\t    ND_PRINT(\"%s\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}\n    }\n\n    if (buf >= maxbuf && *fmt)\n\tND_PRINT(\"END OF BUFFER\\n\");\n\n    return(buf);\n\ntrunc:\n    nd_print_trunc(ndo);\n    return(NULL);\n}\n\nconst u_char *\nsmb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    /*\n\t     * List of multiple instances of something described by the\n\t     * remainder of the string (which may itself include a list\n\t     * of multiple instances of something, so we recurse).\n\t     */\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\t/*\n\t\t * In order to avoid stack exhaustion recurse at most 10\n\t\t * levels; that \"should not happen\", as no SMB structure\n\t\t * should be nested *that* deeply, and we thus shouldn't\n\t\t * have format strings with that level of nesting.\n\t\t */\n\t\tif (depth == 10) {\n\t\t\tND_PRINT(\"(too many nested levels, not recursing)\");\n\t\t\tbuf2 = buf;\n\t\t} else\n\t\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\n\tcase '|':\n\t    /*\n\t     * Just do a bounds check.\n\t     */\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\n\tcase '%':\n\t    /*\n\t     * XXX - unused?\n\t     */\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\n\tcase '#':\n\t    /*\n\t     * Done?\n\t     */\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\n\tcase '[':\n\t    /*\n\t     * Format of an item, enclosed in square brackets; dissect\n\t     * the item with smb_fdata1().\n\t     */\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\t/* overrun */\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL) {\n\t\t/*\n\t\t * Truncated.\n\t\t * Is the next character a newline?\n\t\t * If so, print it before quitting, so we don't\n\t\t * get stuff in the middle of the line.\n\t\t */\n\t\tif (*fmt == '\\n')\n\t\t    ND_PRINT(\"\\n\");\n\t\treturn(NULL);\n\t    }\n\t    break;\n\n\tdefault:\n\t    /*\n\t     * Not a formatting character, so just print it.\n\t     */\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tu_int len = ND_BYTES_BETWEEN(maxbuf, buf);\n\tND_PRINT(\"Data: (%u bytes)\\n\", len);\n\tsmb_data_print(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}\n\ntypedef struct {\n    const char *name;\n    int code;\n    const char *message;\n} err_code_struct;\n\n/* DOS Error Messages */\nstatic const err_code_struct dos_msgs[] = {\n    { \"ERRbadfunc\", 1, \"Invalid function.\" },\n    { \"ERRbadfile\", 2, \"File not found.\" },\n    { \"ERRbadpath\", 3, \"Directory invalid.\" },\n    { \"ERRnofids\", 4, \"No file descriptors available\" },\n    { \"ERRnoaccess\", 5, \"Access denied.\" },\n    { \"ERRbadfid\", 6, \"Invalid file handle.\" },\n    { \"ERRbadmcb\", 7, \"Memory control blocks destroyed.\" },\n    { \"ERRnomem\", 8, \"Insufficient server memory to perform the requested function.\" },\n    { \"ERRbadmem\", 9, \"Invalid memory block address.\" },\n    { \"ERRbadenv\", 10, \"Invalid environment.\" },\n    { \"ERRbadformat\", 11, \"Invalid format.\" },\n    { \"ERRbadaccess\", 12, \"Invalid open mode.\" },\n    { \"ERRbaddata\", 13, \"Invalid data.\" },\n    { \"ERR\", 14, \"reserved.\" },\n    { \"ERRbaddrive\", 15, \"Invalid drive specified.\" },\n    { \"ERRremcd\", 16, \"A Delete Directory request attempted to remove the server's current directory.\" },\n    { \"ERRdiffdevice\", 17, \"Not same device.\" },\n    { \"ERRnofiles\", 18, \"A File Search command can find no more files matching the specified criteria.\" },\n    { \"ERRbadshare\", 32, \"The sharing mode specified for an Open conflicts with existing FIDs on the file.\" },\n    { \"ERRlock\", 33, \"A Lock request conflicted with an existing lock or specified an invalid mode, or an Unlock requested attempted to remove a lock held by another process.\" },\n    { \"ERRfilexists\", 80, \"The file named in a Create Directory, Make New File or Link request already exists.\" },\n    { \"ERRbadpipe\", 230, \"Pipe invalid.\" },\n    { \"ERRpipebusy\", 231, \"All instances of the requested pipe are busy.\" },\n    { \"ERRpipeclosing\", 232, \"Pipe close in progress.\" },\n    { \"ERRnotconnected\", 233, \"No process on other end of pipe.\" },\n    { \"ERRmoredata\", 234, \"There is more data to be returned.\" },\n    { NULL, -1, NULL }\n };\n\n/* Server Error Messages */\nstatic const err_code_struct server_msgs[] = {\n    { \"ERRerror\", 1, \"Non-specific error code.\" },\n    { \"ERRbadpw\", 2, \"Bad password - name/password pair in a Tree Connect or Session Setup are invalid.\" },\n    { \"ERRbadtype\", 3, \"reserved.\" },\n    { \"ERRaccess\", 4, \"The requester does not have the necessary access rights within the specified context for the requested function. The context is defined by the TID or the UID.\" },\n    { \"ERRinvnid\", 5, \"The tree ID (TID) specified in a command was invalid.\" },\n    { \"ERRinvnetname\", 6, \"Invalid network name in tree connect.\" },\n    { \"ERRinvdevice\", 7, \"Invalid device - printer request made to non-printer connection or non-printer request made to printer connection.\" },\n    { \"ERRqfull\", 49, \"Print queue full (files) -- returned by open print file.\" },\n    { \"ERRqtoobig\", 50, \"Print queue full -- no space.\" },\n    { \"ERRqeof\", 51, \"EOF on print queue dump.\" },\n    { \"ERRinvpfid\", 52, \"Invalid print file FID.\" },\n    { \"ERRsmbcmd\", 64, \"The server did not recognize the command received.\" },\n    { \"ERRsrverror\", 65, \"The server encountered an internal error, e.g., system file unavailable.\" },\n    { \"ERRfilespecs\", 67, \"The file handle (FID) and pathname parameters contained an invalid combination of values.\" },\n    { \"ERRreserved\", 68, \"reserved.\" },\n    { \"ERRbadpermits\", 69, \"The access permissions specified for a file or directory are not a valid combination.  The server cannot set the requested attribute.\" },\n    { \"ERRreserved\", 70, \"reserved.\" },\n    { \"ERRsetattrmode\", 71, \"The attribute mode in the Set File Attribute request is invalid.\" },\n    { \"ERRpaused\", 81, \"Server is paused.\" },\n    { \"ERRmsgoff\", 82, \"Not receiving messages.\" },\n    { \"ERRnoroom\", 83, \"No room to buffer message.\" },\n    { \"ERRrmuns\", 87, \"Too many remote user names.\" },\n    { \"ERRtimeout\", 88, \"Operation timed out.\" },\n    { \"ERRnoresource\", 89, \"No resources currently available for request.\" },\n    { \"ERRtoomanyuids\", 90, \"Too many UIDs active on this session.\" },\n    { \"ERRbaduid\", 91, \"The UID is not known as a valid ID on this session.\" },\n    { \"ERRusempx\", 250, \"Temp unable to support Raw, use MPX mode.\" },\n    { \"ERRusestd\", 251, \"Temp unable to support Raw, use standard read/write.\" },\n    { \"ERRcontmpx\", 252, \"Continue in MPX mode.\" },\n    { \"ERRreserved\", 253, \"reserved.\" },\n    { \"ERRreserved\", 254, \"reserved.\" },\n    { \"ERRnosupport\", 0xFFFF, \"Function not supported.\" },\n    { NULL, -1, NULL }\n};\n\n/* Hard Error Messages */\nstatic const err_code_struct hard_msgs[] = {\n    { \"ERRnowrite\", 19, \"Attempt to write on write-protected diskette.\" },\n    { \"ERRbadunit\", 20, \"Unknown unit.\" },\n    { \"ERRnotready\", 21, \"Drive not ready.\" },\n    { \"ERRbadcmd\", 22, \"Unknown command.\" },\n    { \"ERRdata\", 23, \"Data error (CRC).\" },\n    { \"ERRbadreq\", 24, \"Bad request structure length.\" },\n    { \"ERRseek\", 25 , \"Seek error.\" },\n    { \"ERRbadmedia\", 26, \"Unknown media type.\" },\n    { \"ERRbadsector\", 27, \"Sector not found.\" },\n    { \"ERRnopaper\", 28, \"Printer out of paper.\" },\n    { \"ERRwrite\", 29, \"Write fault.\" },\n    { \"ERRread\", 30, \"Read fault.\" },\n    { \"ERRgeneral\", 31, \"General failure.\" },\n    { \"ERRbadshare\", 32, \"A open conflicts with an existing open.\" },\n    { \"ERRlock\", 33, \"A Lock request conflicted with an existing lock or specified an invalid mode, or an Unlock requested attempted to remove a lock held by another process.\" },\n    { \"ERRwrongdisk\", 34, \"The wrong disk was found in a drive.\" },\n    { \"ERRFCBUnavail\", 35, \"No FCBs are available to process request.\" },\n    { \"ERRsharebufexc\", 36, \"A sharing buffer has been exceeded.\" },\n    { NULL, -1, NULL }\n};\n\nstatic const struct {\n    int code;\n    const char *class;\n    const err_code_struct *err_msgs;\n} err_classes[] = {\n    { 0, \"SUCCESS\", NULL },\n    { 0x01, \"ERRDOS\", dos_msgs },\n    { 0x02, \"ERRSRV\", server_msgs },\n    { 0x03, \"ERRHRD\", hard_msgs },\n    { 0x04, \"ERRXOS\", NULL },\n    { 0xE1, \"ERRRMX1\", NULL },\n    { 0xE2, \"ERRRMX2\", NULL },\n    { 0xE3, \"ERRRMX3\", NULL },\n    { 0xFF, \"ERRCMD\", NULL },\n    { -1, NULL, NULL }\n};\n\n/*\n * return a SMB error string from a SMB buffer\n */\nconst char *\nsmb_errstr(int class, int num)\n{\n    static char ret[128];\n    int i, j;\n\n    ret[0] = 0;\n\n    for (i = 0; err_classes[i].class; i++)\n\tif (err_classes[i].code == class) {\n\t    if (err_classes[i].err_msgs) {\n\t\tconst err_code_struct *err = err_classes[i].err_msgs;\n\t\tfor (j = 0; err[j].name; j++)\n\t\t    if (num == err[j].code) {\n\t\t\tsnprintf(ret, sizeof(ret), \"%s - %s (%s)\",\n\t\t\t    err_classes[i].class, err[j].name, err[j].message);\n\t\t\treturn ret;\n\t\t    }\n\t    }\n\n\t    snprintf(ret, sizeof(ret), \"%s - %d\", err_classes[i].class, num);\n\t    return ret;\n\t}\n\n    snprintf(ret, sizeof(ret), \"ERROR: Unknown error (%d,%d)\", class, num);\n    return(ret);\n}\n\ntypedef struct {\n    uint32_t code;\n    const char *name;\n} nt_err_code_struct;\n\n/*\n * NT Error codes\n */\nstatic const nt_err_code_struct nt_errors[] = {\n  { 0x00000000, \"STATUS_SUCCESS\" },\n  { 0x00000000, \"STATUS_WAIT_0\" },\n  { 0x00000001, \"STATUS_WAIT_1\" },\n  { 0x00000002, \"STATUS_WAIT_2\" },\n  { 0x00000003, \"STATUS_WAIT_3\" },\n  { 0x0000003F, \"STATUS_WAIT_63\" },\n  { 0x00000080, \"STATUS_ABANDONED\" },\n  { 0x00000080, \"STATUS_ABANDONED_WAIT_0\" },\n  { 0x000000BF, \"STATUS_ABANDONED_WAIT_63\" },\n  { 0x000000C0, \"STATUS_USER_APC\" },\n  { 0x00000100, \"STATUS_KERNEL_APC\" },\n  { 0x00000101, \"STATUS_ALERTED\" },\n  { 0x00000102, \"STATUS_TIMEOUT\" },\n  { 0x00000103, \"STATUS_PENDING\" },\n  { 0x00000104, \"STATUS_REPARSE\" },\n  { 0x00000105, \"STATUS_MORE_ENTRIES\" },\n  { 0x00000106, \"STATUS_NOT_ALL_ASSIGNED\" },\n  { 0x00000107, \"STATUS_SOME_NOT_MAPPED\" },\n  { 0x00000108, \"STATUS_OPLOCK_BREAK_IN_PROGRESS\" },\n  { 0x00000109, \"STATUS_VOLUME_MOUNTED\" },\n  { 0x0000010A, \"STATUS_RXACT_COMMITTED\" },\n  { 0x0000010B, \"STATUS_NOTIFY_CLEANUP\" },\n  { 0x0000010C, \"STATUS_NOTIFY_ENUM_DIR\" },\n  { 0x0000010D, \"STATUS_NO_QUOTAS_FOR_ACCOUNT\" },\n  { 0x0000010E, \"STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED\" },\n  { 0x00000110, \"STATUS_PAGE_FAULT_TRANSITION\" },\n  { 0x00000111, \"STATUS_PAGE_FAULT_DEMAND_ZERO\" },\n  { 0x00000112, \"STATUS_PAGE_FAULT_COPY_ON_WRITE\" },\n  { 0x00000113, \"STATUS_PAGE_FAULT_GUARD_PAGE\" },\n  { 0x00000114, \"STATUS_PAGE_FAULT_PAGING_FILE\" },\n  { 0x00000115, \"STATUS_CACHE_PAGE_LOCKED\" },\n  { 0x00000116, \"STATUS_CRASH_DUMP\" },\n  { 0x00000117, \"STATUS_BUFFER_ALL_ZEROS\" },\n  { 0x00000118, \"STATUS_REPARSE_OBJECT\" },\n  { 0x0000045C, \"STATUS_NO_SHUTDOWN_IN_PROGRESS\" },\n  { 0x40000000, \"STATUS_OBJECT_NAME_EXISTS\" },\n  { 0x40000001, \"STATUS_THREAD_WAS_SUSPENDED\" },\n  { 0x40000002, \"STATUS_WORKING_SET_LIMIT_RANGE\" },\n  { 0x40000003, \"STATUS_IMAGE_NOT_AT_BASE\" },\n  { 0x40000004, \"STATUS_RXACT_STATE_CREATED\" },\n  { 0x40000005, \"STATUS_SEGMENT_NOTIFICATION\" },\n  { 0x40000006, \"STATUS_LOCAL_USER_SESSION_KEY\" },\n  { 0x40000007, \"STATUS_BAD_CURRENT_DIRECTORY\" },\n  { 0x40000008, \"STATUS_SERIAL_MORE_WRITES\" },\n  { 0x40000009, \"STATUS_REGISTRY_RECOVERED\" },\n  { 0x4000000A, \"STATUS_FT_READ_RECOVERY_FROM_BACKUP\" },\n  { 0x4000000B, \"STATUS_FT_WRITE_RECOVERY\" },\n  { 0x4000000C, \"STATUS_SERIAL_COUNTER_TIMEOUT\" },\n  { 0x4000000D, \"STATUS_NULL_LM_PASSWORD\" },\n  { 0x4000000E, \"STATUS_IMAGE_MACHINE_TYPE_MISMATCH\" },\n  { 0x4000000F, \"STATUS_RECEIVE_PARTIAL\" },\n  { 0x40000010, \"STATUS_RECEIVE_EXPEDITED\" },\n  { 0x40000011, \"STATUS_RECEIVE_PARTIAL_EXPEDITED\" },\n  { 0x40000012, \"STATUS_EVENT_DONE\" },\n  { 0x40000013, \"STATUS_EVENT_PENDING\" },\n  { 0x40000014, \"STATUS_CHECKING_FILE_SYSTEM\" },\n  { 0x40000015, \"STATUS_FATAL_APP_EXIT\" },\n  { 0x40000016, \"STATUS_PREDEFINED_HANDLE\" },\n  { 0x40000017, \"STATUS_WAS_UNLOCKED\" },\n  { 0x40000018, \"STATUS_SERVICE_NOTIFICATION\" },\n  { 0x40000019, \"STATUS_WAS_LOCKED\" },\n  { 0x4000001A, \"STATUS_LOG_HARD_ERROR\" },\n  { 0x4000001B, \"STATUS_ALREADY_WIN32\" },\n  { 0x4000001C, \"STATUS_WX86_UNSIMULATE\" },\n  { 0x4000001D, \"STATUS_WX86_CONTINUE\" },\n  { 0x4000001E, \"STATUS_WX86_SINGLE_STEP\" },\n  { 0x4000001F, \"STATUS_WX86_BREAKPOINT\" },\n  { 0x40000020, \"STATUS_WX86_EXCEPTION_CONTINUE\" },\n  { 0x40000021, \"STATUS_WX86_EXCEPTION_LASTCHANCE\" },\n  { 0x40000022, \"STATUS_WX86_EXCEPTION_CHAIN\" },\n  { 0x40000023, \"STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE\" },\n  { 0x40000024, \"STATUS_NO_YIELD_PERFORMED\" },\n  { 0x40000025, \"STATUS_TIMER_RESUME_IGNORED\" },\n  { 0x80000001, \"STATUS_GUARD_PAGE_VIOLATION\" },\n  { 0x80000002, \"STATUS_DATATYPE_MISALIGNMENT\" },\n  { 0x80000003, \"STATUS_BREAKPOINT\" },\n  { 0x80000004, \"STATUS_SINGLE_STEP\" },\n  { 0x80000005, \"STATUS_BUFFER_OVERFLOW\" },\n  { 0x80000006, \"STATUS_NO_MORE_FILES\" },\n  { 0x80000007, \"STATUS_WAKE_SYSTEM_DEBUGGER\" },\n  { 0x8000000A, \"STATUS_HANDLES_CLOSED\" },\n  { 0x8000000B, \"STATUS_NO_INHERITANCE\" },\n  { 0x8000000C, \"STATUS_GUID_SUBSTITUTION_MADE\" },\n  { 0x8000000D, \"STATUS_PARTIAL_COPY\" },\n  { 0x8000000E, \"STATUS_DEVICE_PAPER_EMPTY\" },\n  { 0x8000000F, \"STATUS_DEVICE_POWERED_OFF\" },\n  { 0x80000010, \"STATUS_DEVICE_OFF_LINE\" },\n  { 0x80000011, \"STATUS_DEVICE_BUSY\" },\n  { 0x80000012, \"STATUS_NO_MORE_EAS\" },\n  { 0x80000013, \"STATUS_INVALID_EA_NAME\" },\n  { 0x80000014, \"STATUS_EA_LIST_INCONSISTENT\" },\n  { 0x80000015, \"STATUS_INVALID_EA_FLAG\" },\n  { 0x80000016, \"STATUS_VERIFY_REQUIRED\" },\n  { 0x80000017, \"STATUS_EXTRANEOUS_INFORMATION\" },\n  { 0x80000018, \"STATUS_RXACT_COMMIT_NECESSARY\" },\n  { 0x8000001A, \"STATUS_NO_MORE_ENTRIES\" },\n  { 0x8000001B, \"STATUS_FILEMARK_DETECTED\" },\n  { 0x8000001C, \"STATUS_MEDIA_CHANGED\" },\n  { 0x8000001D, \"STATUS_BUS_RESET\" },\n  { 0x8000001E, \"STATUS_END_OF_MEDIA\" },\n  { 0x8000001F, \"STATUS_BEGINNING_OF_MEDIA\" },\n  { 0x80000020, \"STATUS_MEDIA_CHECK\" },\n  { 0x80000021, \"STATUS_SETMARK_DETECTED\" },\n  { 0x80000022, \"STATUS_NO_DATA_DETECTED\" },\n  { 0x80000023, \"STATUS_REDIRECTOR_HAS_OPEN_HANDLES\" },\n  { 0x80000024, \"STATUS_SERVER_HAS_OPEN_HANDLES\" },\n  { 0x80000025, \"STATUS_ALREADY_DISCONNECTED\" },\n  { 0x80000026, \"STATUS_LONGJUMP\" },\n  { 0x80040111, \"MAPI_E_LOGON_FAILED\" },\n  { 0x80090300, \"SEC_E_INSUFFICIENT_MEMORY\" },\n  { 0x80090301, \"SEC_E_INVALID_HANDLE\" },\n  { 0x80090302, \"SEC_E_UNSUPPORTED_FUNCTION\" },\n  { 0x8009030B, \"SEC_E_NO_IMPERSONATION\" },\n  { 0x8009030D, \"SEC_E_UNKNOWN_CREDENTIALS\" },\n  { 0x8009030E, \"SEC_E_NO_CREDENTIALS\" },\n  { 0x8009030F, \"SEC_E_MESSAGE_ALTERED\" },\n  { 0x80090310, \"SEC_E_OUT_OF_SEQUENCE\" },\n  { 0x80090311, \"SEC_E_NO_AUTHENTICATING_AUTHORITY\" },\n  { 0xC0000001, \"STATUS_UNSUCCESSFUL\" },\n  { 0xC0000002, \"STATUS_NOT_IMPLEMENTED\" },\n  { 0xC0000003, \"STATUS_INVALID_INFO_CLASS\" },\n  { 0xC0000004, \"STATUS_INFO_LENGTH_MISMATCH\" },\n  { 0xC0000005, \"STATUS_ACCESS_VIOLATION\" },\n  { 0xC0000006, \"STATUS_IN_PAGE_ERROR\" },\n  { 0xC0000007, \"STATUS_PAGEFILE_QUOTA\" },\n  { 0xC0000008, \"STATUS_INVALID_HANDLE\" },\n  { 0xC0000009, \"STATUS_BAD_INITIAL_STACK\" },\n  { 0xC000000A, \"STATUS_BAD_INITIAL_PC\" },\n  { 0xC000000B, \"STATUS_INVALID_CID\" },\n  { 0xC000000C, \"STATUS_TIMER_NOT_CANCELED\" },\n  { 0xC000000D, \"STATUS_INVALID_PARAMETER\" },\n  { 0xC000000E, \"STATUS_NO_SUCH_DEVICE\" },\n  { 0xC000000F, \"STATUS_NO_SUCH_FILE\" },\n  { 0xC0000010, \"STATUS_INVALID_DEVICE_REQUEST\" },\n  { 0xC0000011, \"STATUS_END_OF_FILE\" },\n  { 0xC0000012, \"STATUS_WRONG_VOLUME\" },\n  { 0xC0000013, \"STATUS_NO_MEDIA_IN_DEVICE\" },\n  { 0xC0000014, \"STATUS_UNRECOGNIZED_MEDIA\" },\n  { 0xC0000015, \"STATUS_NONEXISTENT_SECTOR\" },\n  { 0xC0000016, \"STATUS_MORE_PROCESSING_REQUIRED\" },\n  { 0xC0000017, \"STATUS_NO_MEMORY\" },\n  { 0xC0000018, \"STATUS_CONFLICTING_ADDRESSES\" },\n  { 0xC0000019, \"STATUS_NOT_MAPPED_VIEW\" },\n  { 0xC000001A, \"STATUS_UNABLE_TO_FREE_VM\" },\n  { 0xC000001B, \"STATUS_UNABLE_TO_DELETE_SECTION\" },\n  { 0xC000001C, \"STATUS_INVALID_SYSTEM_SERVICE\" },\n  { 0xC000001D, \"STATUS_ILLEGAL_INSTRUCTION\" },\n  { 0xC000001E, \"STATUS_INVALID_LOCK_SEQUENCE\" },\n  { 0xC000001F, \"STATUS_INVALID_VIEW_SIZE\" },\n  { 0xC0000020, \"STATUS_INVALID_FILE_FOR_SECTION\" },\n  { 0xC0000021, \"STATUS_ALREADY_COMMITTED\" },\n  { 0xC0000022, \"STATUS_ACCESS_DENIED\" },\n  { 0xC0000023, \"STATUS_BUFFER_TOO_SMALL\" },\n  { 0xC0000024, \"STATUS_OBJECT_TYPE_MISMATCH\" },\n  { 0xC0000025, \"STATUS_NONCONTINUABLE_EXCEPTION\" },\n  { 0xC0000026, \"STATUS_INVALID_DISPOSITION\" },\n  { 0xC0000027, \"STATUS_UNWIND\" },\n  { 0xC0000028, \"STATUS_BAD_STACK\" },\n  { 0xC0000029, \"STATUS_INVALID_UNWIND_TARGET\" },\n  { 0xC000002A, \"STATUS_NOT_LOCKED\" },\n  { 0xC000002B, \"STATUS_PARITY_ERROR\" },\n  { 0xC000002C, \"STATUS_UNABLE_TO_DECOMMIT_VM\" },\n  { 0xC000002D, \"STATUS_NOT_COMMITTED\" },\n  { 0xC000002E, \"STATUS_INVALID_PORT_ATTRIBUTES\" },\n  { 0xC000002F, \"STATUS_PORT_MESSAGE_TOO_LONG\" },\n  { 0xC0000030, \"STATUS_INVALID_PARAMETER_MIX\" },\n  { 0xC0000031, \"STATUS_INVALID_QUOTA_LOWER\" },\n  { 0xC0000032, \"STATUS_DISK_CORRUPT_ERROR\" },\n  { 0xC0000033, \"STATUS_OBJECT_NAME_INVALID\" },\n  { 0xC0000034, \"STATUS_OBJECT_NAME_NOT_FOUND\" },\n  { 0xC0000035, \"STATUS_OBJECT_NAME_COLLISION\" },\n  { 0xC0000037, \"STATUS_PORT_DISCONNECTED\" },\n  { 0xC0000038, \"STATUS_DEVICE_ALREADY_ATTACHED\" },\n  { 0xC0000039, \"STATUS_OBJECT_PATH_INVALID\" },\n  { 0xC000003A, \"STATUS_OBJECT_PATH_NOT_FOUND\" },\n  { 0xC000003B, \"STATUS_OBJECT_PATH_SYNTAX_BAD\" },\n  { 0xC000003C, \"STATUS_DATA_OVERRUN\" },\n  { 0xC000003D, \"STATUS_DATA_LATE_ERROR\" },\n  { 0xC000003E, \"STATUS_DATA_ERROR\" },\n  { 0xC000003F, \"STATUS_CRC_ERROR\" },\n  { 0xC0000040, \"STATUS_SECTION_TOO_BIG\" },\n  { 0xC0000041, \"STATUS_PORT_CONNECTION_REFUSED\" },\n  { 0xC0000042, \"STATUS_INVALID_PORT_HANDLE\" },\n  { 0xC0000043, \"STATUS_SHARING_VIOLATION\" },\n  { 0xC0000044, \"STATUS_QUOTA_EXCEEDED\" },\n  { 0xC0000045, \"STATUS_INVALID_PAGE_PROTECTION\" },\n  { 0xC0000046, \"STATUS_MUTANT_NOT_OWNED\" },\n  { 0xC0000047, \"STATUS_SEMAPHORE_LIMIT_EXCEEDED\" },\n  { 0xC0000048, \"STATUS_PORT_ALREADY_SET\" },\n  { 0xC0000049, \"STATUS_SECTION_NOT_IMAGE\" },\n  { 0xC000004A, \"STATUS_SUSPEND_COUNT_EXCEEDED\" },\n  { 0xC000004B, \"STATUS_THREAD_IS_TERMINATING\" },\n  { 0xC000004C, \"STATUS_BAD_WORKING_SET_LIMIT\" },\n  { 0xC000004D, \"STATUS_INCOMPATIBLE_FILE_MAP\" },\n  { 0xC000004E, \"STATUS_SECTION_PROTECTION\" },\n  { 0xC000004F, \"STATUS_EAS_NOT_SUPPORTED\" },\n  { 0xC0000050, \"STATUS_EA_TOO_LARGE\" },\n  { 0xC0000051, \"STATUS_NONEXISTENT_EA_ENTRY\" },\n  { 0xC0000052, \"STATUS_NO_EAS_ON_FILE\" },\n  { 0xC0000053, \"STATUS_EA_CORRUPT_ERROR\" },\n  { 0xC0000054, \"STATUS_FILE_LOCK_CONFLICT\" },\n  { 0xC0000055, \"STATUS_LOCK_NOT_GRANTED\" },\n  { 0xC0000056, \"STATUS_DELETE_PENDING\" },\n  { 0xC0000057, \"STATUS_CTL_FILE_NOT_SUPPORTED\" },\n  { 0xC0000058, \"STATUS_UNKNOWN_REVISION\" },\n  { 0xC0000059, \"STATUS_REVISION_MISMATCH\" },\n  { 0xC000005A, \"STATUS_INVALID_OWNER\" },\n  { 0xC000005B, \"STATUS_INVALID_PRIMARY_GROUP\" },\n  { 0xC000005C, \"STATUS_NO_IMPERSONATION_TOKEN\" },\n  { 0xC000005D, \"STATUS_CANT_DISABLE_MANDATORY\" },\n  { 0xC000005E, \"STATUS_NO_LOGON_SERVERS\" },\n  { 0xC000005F, \"STATUS_NO_SUCH_LOGON_SESSION\" },\n  { 0xC0000060, \"STATUS_NO_SUCH_PRIVILEGE\" },\n  { 0xC0000061, \"STATUS_PRIVILEGE_NOT_HELD\" },\n  { 0xC0000062, \"STATUS_INVALID_ACCOUNT_NAME\" },\n  { 0xC0000063, \"STATUS_USER_EXISTS\" },\n  { 0xC0000064, \"STATUS_NO_SUCH_USER\" },\n  { 0xC0000065, \"STATUS_GROUP_EXISTS\" },\n  { 0xC0000066, \"STATUS_NO_SUCH_GROUP\" },\n  { 0xC0000067, \"STATUS_MEMBER_IN_GROUP\" },\n  { 0xC0000068, \"STATUS_MEMBER_NOT_IN_GROUP\" },\n  { 0xC0000069, \"STATUS_LAST_ADMIN\" },\n  { 0xC000006A, \"STATUS_WRONG_PASSWORD\" },\n  { 0xC000006B, \"STATUS_ILL_FORMED_PASSWORD\" },\n  { 0xC000006C, \"STATUS_PASSWORD_RESTRICTION\" },\n  { 0xC000006D, \"STATUS_LOGON_FAILURE\" },\n  { 0xC000006E, \"STATUS_ACCOUNT_RESTRICTION\" },\n  { 0xC000006F, \"STATUS_INVALID_LOGON_HOURS\" },\n  { 0xC0000070, \"STATUS_INVALID_WORKSTATION\" },\n  { 0xC0000071, \"STATUS_PASSWORD_EXPIRED\" },\n  { 0xC0000072, \"STATUS_ACCOUNT_DISABLED\" },\n  { 0xC0000073, \"STATUS_NONE_MAPPED\" },\n  { 0xC0000074, \"STATUS_TOO_MANY_LUIDS_REQUESTED\" },\n  { 0xC0000075, \"STATUS_LUIDS_EXHAUSTED\" },\n  { 0xC0000076, \"STATUS_INVALID_SUB_AUTHORITY\" },\n  { 0xC0000077, \"STATUS_INVALID_ACL\" },\n  { 0xC0000078, \"STATUS_INVALID_SID\" },\n  { 0xC0000079, \"STATUS_INVALID_SECURITY_DESCR\" },\n  { 0xC000007A, \"STATUS_PROCEDURE_NOT_FOUND\" },\n  { 0xC000007B, \"STATUS_INVALID_IMAGE_FORMAT\" },\n  { 0xC000007C, \"STATUS_NO_TOKEN\" },\n  { 0xC000007D, \"STATUS_BAD_INHERITANCE_ACL\" },\n  { 0xC000007E, \"STATUS_RANGE_NOT_LOCKED\" },\n  { 0xC000007F, \"STATUS_DISK_FULL\" },\n  { 0xC0000080, \"STATUS_SERVER_DISABLED\" },\n  { 0xC0000081, \"STATUS_SERVER_NOT_DISABLED\" },\n  { 0xC0000082, \"STATUS_TOO_MANY_GUIDS_REQUESTED\" },\n  { 0xC0000083, \"STATUS_GUIDS_EXHAUSTED\" },\n  { 0xC0000084, \"STATUS_INVALID_ID_AUTHORITY\" },\n  { 0xC0000085, \"STATUS_AGENTS_EXHAUSTED\" },\n  { 0xC0000086, \"STATUS_INVALID_VOLUME_LABEL\" },\n  { 0xC0000087, \"STATUS_SECTION_NOT_EXTENDED\" },\n  { 0xC0000088, \"STATUS_NOT_MAPPED_DATA\" },\n  { 0xC0000089, \"STATUS_RESOURCE_DATA_NOT_FOUND\" },\n  { 0xC000008A, \"STATUS_RESOURCE_TYPE_NOT_FOUND\" },\n  { 0xC000008B, \"STATUS_RESOURCE_NAME_NOT_FOUND\" },\n  { 0xC000008C, \"STATUS_ARRAY_BOUNDS_EXCEEDED\" },\n  { 0xC000008D, \"STATUS_FLOAT_DENORMAL_OPERAND\" },\n  { 0xC000008E, \"STATUS_FLOAT_DIVIDE_BY_ZERO\" },\n  { 0xC000008F, \"STATUS_FLOAT_INEXACT_RESULT\" },\n  { 0xC0000090, \"STATUS_FLOAT_INVALID_OPERATION\" },\n  { 0xC0000091, \"STATUS_FLOAT_OVERFLOW\" },\n  { 0xC0000092, \"STATUS_FLOAT_STACK_CHECK\" },\n  { 0xC0000093, \"STATUS_FLOAT_UNDERFLOW\" },\n  { 0xC0000094, \"STATUS_INTEGER_DIVIDE_BY_ZERO\" },\n  { 0xC0000095, \"STATUS_INTEGER_OVERFLOW\" },\n  { 0xC0000096, \"STATUS_PRIVILEGED_INSTRUCTION\" },\n  { 0xC0000097, \"STATUS_TOO_MANY_PAGING_FILES\" },\n  { 0xC0000098, \"STATUS_FILE_INVALID\" },\n  { 0xC0000099, \"STATUS_ALLOTTED_SPACE_EXCEEDED\" },\n  { 0xC000009A, \"STATUS_INSUFFICIENT_RESOURCES\" },\n  { 0xC000009B, \"STATUS_DFS_EXIT_PATH_FOUND\" },\n  { 0xC000009C, \"STATUS_DEVICE_DATA_ERROR\" },\n  { 0xC000009D, \"STATUS_DEVICE_NOT_CONNECTED\" },\n  { 0xC000009E, \"STATUS_DEVICE_POWER_FAILURE\" },\n  { 0xC000009F, \"STATUS_FREE_VM_NOT_AT_BASE\" },\n  { 0xC00000A0, \"STATUS_MEMORY_NOT_ALLOCATED\" },\n  { 0xC00000A1, \"STATUS_WORKING_SET_QUOTA\" },\n  { 0xC00000A2, \"STATUS_MEDIA_WRITE_PROTECTED\" },\n  { 0xC00000A3, \"STATUS_DEVICE_NOT_READY\" },\n  { 0xC00000A4, \"STATUS_INVALID_GROUP_ATTRIBUTES\" },\n  { 0xC00000A5, \"STATUS_BAD_IMPERSONATION_LEVEL\" },\n  { 0xC00000A6, \"STATUS_CANT_OPEN_ANONYMOUS\" },\n  { 0xC00000A7, \"STATUS_BAD_VALIDATION_CLASS\" },\n  { 0xC00000A8, \"STATUS_BAD_TOKEN_TYPE\" },\n  { 0xC00000A9, \"STATUS_BAD_MASTER_BOOT_RECORD\" },\n  { 0xC00000AA, \"STATUS_INSTRUCTION_MISALIGNMENT\" },\n  { 0xC00000AB, \"STATUS_INSTANCE_NOT_AVAILABLE\" },\n  { 0xC00000AC, \"STATUS_PIPE_NOT_AVAILABLE\" },\n  { 0xC00000AD, \"STATUS_INVALID_PIPE_STATE\" },\n  { 0xC00000AE, \"STATUS_PIPE_BUSY\" },\n  { 0xC00000AF, \"STATUS_ILLEGAL_FUNCTION\" },\n  { 0xC00000B0, \"STATUS_PIPE_DISCONNECTED\" },\n  { 0xC00000B1, \"STATUS_PIPE_CLOSING\" },\n  { 0xC00000B2, \"STATUS_PIPE_CONNECTED\" },\n  { 0xC00000B3, \"STATUS_PIPE_LISTENING\" },\n  { 0xC00000B4, \"STATUS_INVALID_READ_MODE\" },\n  { 0xC00000B5, \"STATUS_IO_TIMEOUT\" },\n  { 0xC00000B6, \"STATUS_FILE_FORCED_CLOSED\" },\n  { 0xC00000B7, \"STATUS_PROFILING_NOT_STARTED\" },\n  { 0xC00000B8, \"STATUS_PROFILING_NOT_STOPPED\" },\n  { 0xC00000B9, \"STATUS_COULD_NOT_INTERPRET\" },\n  { 0xC00000BA, \"STATUS_FILE_IS_A_DIRECTORY\" },\n  { 0xC00000BB, \"STATUS_NOT_SUPPORTED\" },\n  { 0xC00000BC, \"STATUS_REMOTE_NOT_LISTENING\" },\n  { 0xC00000BD, \"STATUS_DUPLICATE_NAME\" },\n  { 0xC00000BE, \"STATUS_BAD_NETWORK_PATH\" },\n  { 0xC00000BF, \"STATUS_NETWORK_BUSY\" },\n  { 0xC00000C0, \"STATUS_DEVICE_DOES_NOT_EXIST\" },\n  { 0xC00000C1, \"STATUS_TOO_MANY_COMMANDS\" },\n  { 0xC00000C2, \"STATUS_ADAPTER_HARDWARE_ERROR\" },\n  { 0xC00000C3, \"STATUS_INVALID_NETWORK_RESPONSE\" },\n  { 0xC00000C4, \"STATUS_UNEXPECTED_NETWORK_ERROR\" },\n  { 0xC00000C5, \"STATUS_BAD_REMOTE_ADAPTER\" },\n  { 0xC00000C6, \"STATUS_PRINT_QUEUE_FULL\" },\n  { 0xC00000C7, \"STATUS_NO_SPOOL_SPACE\" },\n  { 0xC00000C8, \"STATUS_PRINT_CANCELLED\" },\n  { 0xC00000C9, \"STATUS_NETWORK_NAME_DELETED\" },\n  { 0xC00000CA, \"STATUS_NETWORK_ACCESS_DENIED\" },\n  { 0xC00000CB, \"STATUS_BAD_DEVICE_TYPE\" },\n  { 0xC00000CC, \"STATUS_BAD_NETWORK_NAME\" },\n  { 0xC00000CD, \"STATUS_TOO_MANY_NAMES\" },\n  { 0xC00000CE, \"STATUS_TOO_MANY_SESSIONS\" },\n  { 0xC00000CF, \"STATUS_SHARING_PAUSED\" },\n  { 0xC00000D0, \"STATUS_REQUEST_NOT_ACCEPTED\" },\n  { 0xC00000D1, \"STATUS_REDIRECTOR_PAUSED\" },\n  { 0xC00000D2, \"STATUS_NET_WRITE_FAULT\" },\n  { 0xC00000D3, \"STATUS_PROFILING_AT_LIMIT\" },\n  { 0xC00000D4, \"STATUS_NOT_SAME_DEVICE\" },\n  { 0xC00000D5, \"STATUS_FILE_RENAMED\" },\n  { 0xC00000D6, \"STATUS_VIRTUAL_CIRCUIT_CLOSED\" },\n  { 0xC00000D7, \"STATUS_NO_SECURITY_ON_OBJECT\" },\n  { 0xC00000D8, \"STATUS_CANT_WAIT\" },\n  { 0xC00000D9, \"STATUS_PIPE_EMPTY\" },\n  { 0xC00000DA, \"STATUS_CANT_ACCESS_DOMAIN_INFO\" },\n  { 0xC00000DB, \"STATUS_CANT_TERMINATE_SELF\" },\n  { 0xC00000DC, \"STATUS_INVALID_SERVER_STATE\" },\n  { 0xC00000DD, \"STATUS_INVALID_DOMAIN_STATE\" },\n  { 0xC00000DE, \"STATUS_INVALID_DOMAIN_ROLE\" },\n  { 0xC00000DF, \"STATUS_NO_SUCH_DOMAIN\" },\n  { 0xC00000E0, \"STATUS_DOMAIN_EXISTS\" },\n  { 0xC00000E1, \"STATUS_DOMAIN_LIMIT_EXCEEDED\" },\n  { 0xC00000E2, \"STATUS_OPLOCK_NOT_GRANTED\" },\n  { 0xC00000E3, \"STATUS_INVALID_OPLOCK_PROTOCOL\" },\n  { 0xC00000E4, \"STATUS_INTERNAL_DB_CORRUPTION\" },\n  { 0xC00000E5, \"STATUS_INTERNAL_ERROR\" },\n  { 0xC00000E6, \"STATUS_GENERIC_NOT_MAPPED\" },\n  { 0xC00000E7, \"STATUS_BAD_DESCRIPTOR_FORMAT\" },\n  { 0xC00000E8, \"STATUS_INVALID_USER_BUFFER\" },\n  { 0xC00000E9, \"STATUS_UNEXPECTED_IO_ERROR\" },\n  { 0xC00000EA, \"STATUS_UNEXPECTED_MM_CREATE_ERR\" },\n  { 0xC00000EB, \"STATUS_UNEXPECTED_MM_MAP_ERROR\" },\n  { 0xC00000EC, \"STATUS_UNEXPECTED_MM_EXTEND_ERR\" },\n  { 0xC00000ED, \"STATUS_NOT_LOGON_PROCESS\" },\n  { 0xC00000EE, \"STATUS_LOGON_SESSION_EXISTS\" },\n  { 0xC00000EF, \"STATUS_INVALID_PARAMETER_1\" },\n  { 0xC00000F0, \"STATUS_INVALID_PARAMETER_2\" },\n  { 0xC00000F1, \"STATUS_INVALID_PARAMETER_3\" },\n  { 0xC00000F2, \"STATUS_INVALID_PARAMETER_4\" },\n  { 0xC00000F3, \"STATUS_INVALID_PARAMETER_5\" },\n  { 0xC00000F4, \"STATUS_INVALID_PARAMETER_6\" },\n  { 0xC00000F5, \"STATUS_INVALID_PARAMETER_7\" },\n  { 0xC00000F6, \"STATUS_INVALID_PARAMETER_8\" },\n  { 0xC00000F7, \"STATUS_INVALID_PARAMETER_9\" },\n  { 0xC00000F8, \"STATUS_INVALID_PARAMETER_10\" },\n  { 0xC00000F9, \"STATUS_INVALID_PARAMETER_11\" },\n  { 0xC00000FA, \"STATUS_INVALID_PARAMETER_12\" },\n  { 0xC00000FB, \"STATUS_REDIRECTOR_NOT_STARTED\" },\n  { 0xC00000FC, \"STATUS_REDIRECTOR_STARTED\" },\n  { 0xC00000FD, \"STATUS_STACK_OVERFLOW\" },\n  { 0xC00000FE, \"STATUS_NO_SUCH_PACKAGE\" },\n  { 0xC00000FF, \"STATUS_BAD_FUNCTION_TABLE\" },\n  { 0xC0000100, \"STATUS_VARIABLE_NOT_FOUND\" },\n  { 0xC0000101, \"STATUS_DIRECTORY_NOT_EMPTY\" },\n  { 0xC0000102, \"STATUS_FILE_CORRUPT_ERROR\" },\n  { 0xC0000103, \"STATUS_NOT_A_DIRECTORY\" },\n  { 0xC0000104, \"STATUS_BAD_LOGON_SESSION_STATE\" },\n  { 0xC0000105, \"STATUS_LOGON_SESSION_COLLISION\" },\n  { 0xC0000106, \"STATUS_NAME_TOO_LONG\" },\n  { 0xC0000107, \"STATUS_FILES_OPEN\" },\n  { 0xC0000108, \"STATUS_CONNECTION_IN_USE\" },\n  { 0xC0000109, \"STATUS_MESSAGE_NOT_FOUND\" },\n  { 0xC000010A, \"STATUS_PROCESS_IS_TERMINATING\" },\n  { 0xC000010B, \"STATUS_INVALID_LOGON_TYPE\" },\n  { 0xC000010C, \"STATUS_NO_GUID_TRANSLATION\" },\n  { 0xC000010D, \"STATUS_CANNOT_IMPERSONATE\" },\n  { 0xC000010E, \"STATUS_IMAGE_ALREADY_LOADED\" },\n  { 0xC000010F, \"STATUS_ABIOS_NOT_PRESENT\" },\n  { 0xC0000110, \"STATUS_ABIOS_LID_NOT_EXIST\" },\n  { 0xC0000111, \"STATUS_ABIOS_LID_ALREADY_OWNED\" },\n  { 0xC0000112, \"STATUS_ABIOS_NOT_LID_OWNER\" },\n  { 0xC0000113, \"STATUS_ABIOS_INVALID_COMMAND\" },\n  { 0xC0000114, \"STATUS_ABIOS_INVALID_LID\" },\n  { 0xC0000115, \"STATUS_ABIOS_SELECTOR_NOT_AVAILABLE\" },\n  { 0xC0000116, \"STATUS_ABIOS_INVALID_SELECTOR\" },\n  { 0xC0000117, \"STATUS_NO_LDT\" },\n  { 0xC0000118, \"STATUS_INVALID_LDT_SIZE\" },\n  { 0xC0000119, \"STATUS_INVALID_LDT_OFFSET\" },\n  { 0xC000011A, \"STATUS_INVALID_LDT_DESCRIPTOR\" },\n  { 0xC000011B, \"STATUS_INVALID_IMAGE_NE_FORMAT\" },\n  { 0xC000011C, \"STATUS_RXACT_INVALID_STATE\" },\n  { 0xC000011D, \"STATUS_RXACT_COMMIT_FAILURE\" },\n  { 0xC000011E, \"STATUS_MAPPED_FILE_SIZE_ZERO\" },\n  { 0xC000011F, \"STATUS_TOO_MANY_OPENED_FILES\" },\n  { 0xC0000120, \"STATUS_CANCELLED\" },\n  { 0xC0000121, \"STATUS_CANNOT_DELETE\" },\n  { 0xC0000122, \"STATUS_INVALID_COMPUTER_NAME\" },\n  { 0xC0000123, \"STATUS_FILE_DELETED\" },\n  { 0xC0000124, \"STATUS_SPECIAL_ACCOUNT\" },\n  { 0xC0000125, \"STATUS_SPECIAL_GROUP\" },\n  { 0xC0000126, \"STATUS_SPECIAL_USER\" },\n  { 0xC0000127, \"STATUS_MEMBERS_PRIMARY_GROUP\" },\n  { 0xC0000128, \"STATUS_FILE_CLOSED\" },\n  { 0xC0000129, \"STATUS_TOO_MANY_THREADS\" },\n  { 0xC000012A, \"STATUS_THREAD_NOT_IN_PROCESS\" },\n  { 0xC000012B, \"STATUS_TOKEN_ALREADY_IN_USE\" },\n  { 0xC000012C, \"STATUS_PAGEFILE_QUOTA_EXCEEDED\" },\n  { 0xC000012D, \"STATUS_COMMITMENT_LIMIT\" },\n  { 0xC000012E, \"STATUS_INVALID_IMAGE_LE_FORMAT\" },\n  { 0xC000012F, \"STATUS_INVALID_IMAGE_NOT_MZ\" },\n  { 0xC0000130, \"STATUS_INVALID_IMAGE_PROTECT\" },\n  { 0xC0000131, \"STATUS_INVALID_IMAGE_WIN_16\" },\n  { 0xC0000132, \"STATUS_LOGON_SERVER_CONFLICT\" },\n  { 0xC0000133, \"STATUS_TIME_DIFFERENCE_AT_DC\" },\n  { 0xC0000134, \"STATUS_SYNCHRONIZATION_REQUIRED\" },\n  { 0xC0000135, \"STATUS_DLL_NOT_FOUND\" },\n  { 0xC0000136, \"STATUS_OPEN_FAILED\" },\n  { 0xC0000137, \"STATUS_IO_PRIVILEGE_FAILED\" },\n  { 0xC0000138, \"STATUS_ORDINAL_NOT_FOUND\" },\n  { 0xC0000139, \"STATUS_ENTRYPOINT_NOT_FOUND\" },\n  { 0xC000013A, \"STATUS_CONTROL_C_EXIT\" },\n  { 0xC000013B, \"STATUS_LOCAL_DISCONNECT\" },\n  { 0xC000013C, \"STATUS_REMOTE_DISCONNECT\" },\n  { 0xC000013D, \"STATUS_REMOTE_RESOURCES\" },\n  { 0xC000013E, \"STATUS_LINK_FAILED\" },\n  { 0xC000013F, \"STATUS_LINK_TIMEOUT\" },\n  { 0xC0000140, \"STATUS_INVALID_CONNECTION\" },\n  { 0xC0000141, \"STATUS_INVALID_ADDRESS\" },\n  { 0xC0000142, \"STATUS_DLL_INIT_FAILED\" },\n  { 0xC0000143, \"STATUS_MISSING_SYSTEMFILE\" },\n  { 0xC0000144, \"STATUS_UNHANDLED_EXCEPTION\" },\n  { 0xC0000145, \"STATUS_APP_INIT_FAILURE\" },\n  { 0xC0000146, \"STATUS_PAGEFILE_CREATE_FAILED\" },\n  { 0xC0000147, \"STATUS_NO_PAGEFILE\" },\n  { 0xC0000148, \"STATUS_INVALID_LEVEL\" },\n  { 0xC0000149, \"STATUS_WRONG_PASSWORD_CORE\" },\n  { 0xC000014A, \"STATUS_ILLEGAL_FLOAT_CONTEXT\" },\n  { 0xC000014B, \"STATUS_PIPE_BROKEN\" },\n  { 0xC000014C, \"STATUS_REGISTRY_CORRUPT\" },\n  { 0xC000014D, \"STATUS_REGISTRY_IO_FAILED\" },\n  { 0xC000014E, \"STATUS_NO_EVENT_PAIR\" },\n  { 0xC000014F, \"STATUS_UNRECOGNIZED_VOLUME\" },\n  { 0xC0000150, \"STATUS_SERIAL_NO_DEVICE_INITED\" },\n  { 0xC0000151, \"STATUS_NO_SUCH_ALIAS\" },\n  { 0xC0000152, \"STATUS_MEMBER_NOT_IN_ALIAS\" },\n  { 0xC0000153, \"STATUS_MEMBER_IN_ALIAS\" },\n  { 0xC0000154, \"STATUS_ALIAS_EXISTS\" },\n  { 0xC0000155, \"STATUS_LOGON_NOT_GRANTED\" },\n  { 0xC0000156, \"STATUS_TOO_MANY_SECRETS\" },\n  { 0xC0000157, \"STATUS_SECRET_TOO_LONG\" },\n  { 0xC0000158, \"STATUS_INTERNAL_DB_ERROR\" },\n  { 0xC0000159, \"STATUS_FULLSCREEN_MODE\" },\n  { 0xC000015A, \"STATUS_TOO_MANY_CONTEXT_IDS\" },\n  { 0xC000015B, \"STATUS_LOGON_TYPE_NOT_GRANTED\" },\n  { 0xC000015C, \"STATUS_NOT_REGISTRY_FILE\" },\n  { 0xC000015D, \"STATUS_NT_CROSS_ENCRYPTION_REQUIRED\" },\n  { 0xC000015E, \"STATUS_DOMAIN_CTRLR_CONFIG_ERROR\" },\n  { 0xC000015F, \"STATUS_FT_MISSING_MEMBER\" },\n  { 0xC0000160, \"STATUS_ILL_FORMED_SERVICE_ENTRY\" },\n  { 0xC0000161, \"STATUS_ILLEGAL_CHARACTER\" },\n  { 0xC0000162, \"STATUS_UNMAPPABLE_CHARACTER\" },\n  { 0xC0000163, \"STATUS_UNDEFINED_CHARACTER\" },\n  { 0xC0000164, \"STATUS_FLOPPY_VOLUME\" },\n  { 0xC0000165, \"STATUS_FLOPPY_ID_MARK_NOT_FOUND\" },\n  { 0xC0000166, \"STATUS_FLOPPY_WRONG_CYLINDER\" },\n  { 0xC0000167, \"STATUS_FLOPPY_UNKNOWN_ERROR\" },\n  { 0xC0000168, \"STATUS_FLOPPY_BAD_REGISTERS\" },\n  { 0xC0000169, \"STATUS_DISK_RECALIBRATE_FAILED\" },\n  { 0xC000016A, \"STATUS_DISK_OPERATION_FAILED\" },\n  { 0xC000016B, \"STATUS_DISK_RESET_FAILED\" },\n  { 0xC000016C, \"STATUS_SHARED_IRQ_BUSY\" },\n  { 0xC000016D, \"STATUS_FT_ORPHANING\" },\n  { 0xC000016E, \"STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT\" },\n  { 0xC0000172, \"STATUS_PARTITION_FAILURE\" },\n  { 0xC0000173, \"STATUS_INVALID_BLOCK_LENGTH\" },\n  { 0xC0000174, \"STATUS_DEVICE_NOT_PARTITIONED\" },\n  { 0xC0000175, \"STATUS_UNABLE_TO_LOCK_MEDIA\" },\n  { 0xC0000176, \"STATUS_UNABLE_TO_UNLOAD_MEDIA\" },\n  { 0xC0000177, \"STATUS_EOM_OVERFLOW\" },\n  { 0xC0000178, \"STATUS_NO_MEDIA\" },\n  { 0xC000017A, \"STATUS_NO_SUCH_MEMBER\" },\n  { 0xC000017B, \"STATUS_INVALID_MEMBER\" },\n  { 0xC000017C, \"STATUS_KEY_DELETED\" },\n  { 0xC000017D, \"STATUS_NO_LOG_SPACE\" },\n  { 0xC000017E, \"STATUS_TOO_MANY_SIDS\" },\n  { 0xC000017F, \"STATUS_LM_CROSS_ENCRYPTION_REQUIRED\" },\n  { 0xC0000180, \"STATUS_KEY_HAS_CHILDREN\" },\n  { 0xC0000181, \"STATUS_CHILD_MUST_BE_VOLATILE\" },\n  { 0xC0000182, \"STATUS_DEVICE_CONFIGURATION_ERROR\" },\n  { 0xC0000183, \"STATUS_DRIVER_INTERNAL_ERROR\" },\n  { 0xC0000184, \"STATUS_INVALID_DEVICE_STATE\" },\n  { 0xC0000185, \"STATUS_IO_DEVICE_ERROR\" },\n  { 0xC0000186, \"STATUS_DEVICE_PROTOCOL_ERROR\" },\n  { 0xC0000187, \"STATUS_BACKUP_CONTROLLER\" },\n  { 0xC0000188, \"STATUS_LOG_FILE_FULL\" },\n  { 0xC0000189, \"STATUS_TOO_LATE\" },\n  { 0xC000018A, \"STATUS_NO_TRUST_LSA_SECRET\" },\n  { 0xC000018B, \"STATUS_NO_TRUST_SAM_ACCOUNT\" },\n  { 0xC000018C, \"STATUS_TRUSTED_DOMAIN_FAILURE\" },\n  { 0xC000018D, \"STATUS_TRUSTED_RELATIONSHIP_FAILURE\" },\n  { 0xC000018E, \"STATUS_EVENTLOG_FILE_CORRUPT\" },\n  { 0xC000018F, \"STATUS_EVENTLOG_CANT_START\" },\n  { 0xC0000190, \"STATUS_TRUST_FAILURE\" },\n  { 0xC0000191, \"STATUS_MUTANT_LIMIT_EXCEEDED\" },\n  { 0xC0000192, \"STATUS_NETLOGON_NOT_STARTED\" },\n  { 0xC0000193, \"STATUS_ACCOUNT_EXPIRED\" },\n  { 0xC0000194, \"STATUS_POSSIBLE_DEADLOCK\" },\n  { 0xC0000195, \"STATUS_NETWORK_CREDENTIAL_CONFLICT\" },\n  { 0xC0000196, \"STATUS_REMOTE_SESSION_LIMIT\" },\n  { 0xC0000197, \"STATUS_EVENTLOG_FILE_CHANGED\" },\n  { 0xC0000198, \"STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT\" },\n  { 0xC0000199, \"STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT\" },\n  { 0xC000019A, \"STATUS_NOLOGON_SERVER_TRUST_ACCOUNT\" },\n  { 0xC000019B, \"STATUS_DOMAIN_TRUST_INCONSISTENT\" },\n  { 0xC000019C, \"STATUS_FS_DRIVER_REQUIRED\" },\n  { 0xC0000202, \"STATUS_NO_USER_SESSION_KEY\" },\n  { 0xC0000203, \"STATUS_USER_SESSION_DELETED\" },\n  { 0xC0000204, \"STATUS_RESOURCE_LANG_NOT_FOUND\" },\n  { 0xC0000205, \"STATUS_INSUFF_SERVER_RESOURCES\" },\n  { 0xC0000206, \"STATUS_INVALID_BUFFER_SIZE\" },\n  { 0xC0000207, \"STATUS_INVALID_ADDRESS_COMPONENT\" },\n  { 0xC0000208, \"STATUS_INVALID_ADDRESS_WILDCARD\" },\n  { 0xC0000209, \"STATUS_TOO_MANY_ADDRESSES\" },\n  { 0xC000020A, \"STATUS_ADDRESS_ALREADY_EXISTS\" },\n  { 0xC000020B, \"STATUS_ADDRESS_CLOSED\" },\n  { 0xC000020C, \"STATUS_CONNECTION_DISCONNECTED\" },\n  { 0xC000020D, \"STATUS_CONNECTION_RESET\" },\n  { 0xC000020E, \"STATUS_TOO_MANY_NODES\" },\n  { 0xC000020F, \"STATUS_TRANSACTION_ABORTED\" },\n  { 0xC0000210, \"STATUS_TRANSACTION_TIMED_OUT\" },\n  { 0xC0000211, \"STATUS_TRANSACTION_NO_RELEASE\" },\n  { 0xC0000212, \"STATUS_TRANSACTION_NO_MATCH\" },\n  { 0xC0000213, \"STATUS_TRANSACTION_RESPONDED\" },\n  { 0xC0000214, \"STATUS_TRANSACTION_INVALID_ID\" },\n  { 0xC0000215, \"STATUS_TRANSACTION_INVALID_TYPE\" },\n  { 0xC0000216, \"STATUS_NOT_SERVER_SESSION\" },\n  { 0xC0000217, \"STATUS_NOT_CLIENT_SESSION\" },\n  { 0xC0000218, \"STATUS_CANNOT_LOAD_REGISTRY_FILE\" },\n  { 0xC0000219, \"STATUS_DEBUG_ATTACH_FAILED\" },\n  { 0xC000021A, \"STATUS_SYSTEM_PROCESS_TERMINATED\" },\n  { 0xC000021B, \"STATUS_DATA_NOT_ACCEPTED\" },\n  { 0xC000021C, \"STATUS_NO_BROWSER_SERVERS_FOUND\" },\n  { 0xC000021D, \"STATUS_VDM_HARD_ERROR\" },\n  { 0xC000021E, \"STATUS_DRIVER_CANCEL_TIMEOUT\" },\n  { 0xC000021F, \"STATUS_REPLY_MESSAGE_MISMATCH\" },\n  { 0xC0000220, \"STATUS_MAPPED_ALIGNMENT\" },\n  { 0xC0000221, \"STATUS_IMAGE_CHECKSUM_MISMATCH\" },\n  { 0xC0000222, \"STATUS_LOST_WRITEBEHIND_DATA\" },\n  { 0xC0000223, \"STATUS_CLIENT_SERVER_PARAMETERS_INVALID\" },\n  { 0xC0000224, \"STATUS_PASSWORD_MUST_CHANGE\" },\n  { 0xC0000225, \"STATUS_NOT_FOUND\" },\n  { 0xC0000226, \"STATUS_NOT_TINY_STREAM\" },\n  { 0xC0000227, \"STATUS_RECOVERY_FAILURE\" },\n  { 0xC0000228, \"STATUS_STACK_OVERFLOW_READ\" },\n  { 0xC0000229, \"STATUS_FAIL_CHECK\" },\n  { 0xC000022A, \"STATUS_DUPLICATE_OBJECTID\" },\n  { 0xC000022B, \"STATUS_OBJECTID_EXISTS\" },\n  { 0xC000022C, \"STATUS_CONVERT_TO_LARGE\" },\n  { 0xC000022D, \"STATUS_RETRY\" },\n  { 0xC000022E, \"STATUS_FOUND_OUT_OF_SCOPE\" },\n  { 0xC000022F, \"STATUS_ALLOCATE_BUCKET\" },\n  { 0xC0000230, \"STATUS_PROPSET_NOT_FOUND\" },\n  { 0xC0000231, \"STATUS_MARSHALL_OVERFLOW\" },\n  { 0xC0000232, \"STATUS_INVALID_VARIANT\" },\n  { 0xC0000233, \"STATUS_DOMAIN_CONTROLLER_NOT_FOUND\" },\n  { 0xC0000234, \"STATUS_ACCOUNT_LOCKED_OUT\" },\n  { 0xC0000235, \"STATUS_HANDLE_NOT_CLOSABLE\" },\n  { 0xC0000236, \"STATUS_CONNECTION_REFUSED\" },\n  { 0xC0000237, \"STATUS_GRACEFUL_DISCONNECT\" },\n  { 0xC0000238, \"STATUS_ADDRESS_ALREADY_ASSOCIATED\" },\n  { 0xC0000239, \"STATUS_ADDRESS_NOT_ASSOCIATED\" },\n  { 0xC000023A, \"STATUS_CONNECTION_INVALID\" },\n  { 0xC000023B, \"STATUS_CONNECTION_ACTIVE\" },\n  { 0xC000023C, \"STATUS_NETWORK_UNREACHABLE\" },\n  { 0xC000023D, \"STATUS_HOST_UNREACHABLE\" },\n  { 0xC000023E, \"STATUS_PROTOCOL_UNREACHABLE\" },\n  { 0xC000023F, \"STATUS_PORT_UNREACHABLE\" },\n  { 0xC0000240, \"STATUS_REQUEST_ABORTED\" },\n  { 0xC0000241, \"STATUS_CONNECTION_ABORTED\" },\n  { 0xC0000242, \"STATUS_BAD_COMPRESSION_BUFFER\" },\n  { 0xC0000243, \"STATUS_USER_MAPPED_FILE\" },\n  { 0xC0000244, \"STATUS_AUDIT_FAILED\" },\n  { 0xC0000245, \"STATUS_TIMER_RESOLUTION_NOT_SET\" },\n  { 0xC0000246, \"STATUS_CONNECTION_COUNT_LIMIT\" },\n  { 0xC0000247, \"STATUS_LOGIN_TIME_RESTRICTION\" },\n  { 0xC0000248, \"STATUS_LOGIN_WKSTA_RESTRICTION\" },\n  { 0xC0000249, \"STATUS_IMAGE_MP_UP_MISMATCH\" },\n  { 0xC0000250, \"STATUS_INSUFFICIENT_LOGON_INFO\" },\n  { 0xC0000251, \"STATUS_BAD_DLL_ENTRYPOINT\" },\n  { 0xC0000252, \"STATUS_BAD_SERVICE_ENTRYPOINT\" },\n  { 0xC0000253, \"STATUS_LPC_REPLY_LOST\" },\n  { 0xC0000254, \"STATUS_IP_ADDRESS_CONFLICT1\" },\n  { 0xC0000255, \"STATUS_IP_ADDRESS_CONFLICT2\" },\n  { 0xC0000256, \"STATUS_REGISTRY_QUOTA_LIMIT\" },\n  { 0xC0000257, \"STATUS_PATH_NOT_COVERED\" },\n  { 0xC0000258, \"STATUS_NO_CALLBACK_ACTIVE\" },\n  { 0xC0000259, \"STATUS_LICENSE_QUOTA_EXCEEDED\" },\n  { 0xC000025A, \"STATUS_PWD_TOO_SHORT\" },\n  { 0xC000025B, \"STATUS_PWD_TOO_RECENT\" },\n  { 0xC000025C, \"STATUS_PWD_HISTORY_CONFLICT\" },\n  { 0xC000025E, \"STATUS_PLUGPLAY_NO_DEVICE\" },\n  { 0xC000025F, \"STATUS_UNSUPPORTED_COMPRESSION\" },\n  { 0xC0000260, \"STATUS_INVALID_HW_PROFILE\" },\n  { 0xC0000261, \"STATUS_INVALID_PLUGPLAY_DEVICE_PATH\" },\n  { 0xC0000262, \"STATUS_DRIVER_ORDINAL_NOT_FOUND\" },\n  { 0xC0000263, \"STATUS_DRIVER_ENTRYPOINT_NOT_FOUND\" },\n  { 0xC0000264, \"STATUS_RESOURCE_NOT_OWNED\" },\n  { 0xC0000265, \"STATUS_TOO_MANY_LINKS\" },\n  { 0xC0000266, \"STATUS_QUOTA_LIST_INCONSISTENT\" },\n  { 0xC0000267, \"STATUS_FILE_IS_OFFLINE\" },\n  { 0xC0000268, \"STATUS_EVALUATION_EXPIRATION\" },\n  { 0xC0000269, \"STATUS_ILLEGAL_DLL_RELOCATION\" },\n  { 0xC000026A, \"STATUS_LICENSE_VIOLATION\" },\n  { 0xC000026B, \"STATUS_DLL_INIT_FAILED_LOGOFF\" },\n  { 0xC000026C, \"STATUS_DRIVER_UNABLE_TO_LOAD\" },\n  { 0xC000026D, \"STATUS_DFS_UNAVAILABLE\" },\n  { 0xC000026E, \"STATUS_VOLUME_DISMOUNTED\" },\n  { 0xC000026F, \"STATUS_WX86_INTERNAL_ERROR\" },\n  { 0xC0000270, \"STATUS_WX86_FLOAT_STACK_CHECK\" },\n  { 0xC0000271, \"STATUS_VALIDATE_CONTINUE\" },\n  { 0xC0000272, \"STATUS_NO_MATCH\" },\n  { 0xC0000273, \"STATUS_NO_MORE_MATCHES\" },\n  { 0xC0000275, \"STATUS_NOT_A_REPARSE_POINT\" },\n  { 0xC0000276, \"STATUS_IO_REPARSE_TAG_INVALID\" },\n  { 0xC0000277, \"STATUS_IO_REPARSE_TAG_MISMATCH\" },\n  { 0xC0000278, \"STATUS_IO_REPARSE_DATA_INVALID\" },\n  { 0xC0000279, \"STATUS_IO_REPARSE_TAG_NOT_HANDLED\" },\n  { 0xC0000280, \"STATUS_REPARSE_POINT_NOT_RESOLVED\" },\n  { 0xC0000281, \"STATUS_DIRECTORY_IS_A_REPARSE_POINT\" },\n  { 0xC0000282, \"STATUS_RANGE_LIST_CONFLICT\" },\n  { 0xC0000283, \"STATUS_SOURCE_ELEMENT_EMPTY\" },\n  { 0xC0000284, \"STATUS_DESTINATION_ELEMENT_FULL\" },\n  { 0xC0000285, \"STATUS_ILLEGAL_ELEMENT_ADDRESS\" },\n  { 0xC0000286, \"STATUS_MAGAZINE_NOT_PRESENT\" },\n  { 0xC0000287, \"STATUS_REINITIALIZATION_NEEDED\" },\n  { 0x80000288, \"STATUS_DEVICE_REQUIRES_CLEANING\" },\n  { 0x80000289, \"STATUS_DEVICE_DOOR_OPEN\" },\n  { 0xC000028A, \"STATUS_ENCRYPTION_FAILED\" },\n  { 0xC000028B, \"STATUS_DECRYPTION_FAILED\" },\n  { 0xC000028C, \"STATUS_RANGE_NOT_FOUND\" },\n  { 0xC000028D, \"STATUS_NO_RECOVERY_POLICY\" },\n  { 0xC000028E, \"STATUS_NO_EFS\" },\n  { 0xC000028F, \"STATUS_WRONG_EFS\" },\n  { 0xC0000290, \"STATUS_NO_USER_KEYS\" },\n  { 0xC0000291, \"STATUS_FILE_NOT_ENCRYPTED\" },\n  { 0xC0000292, \"STATUS_NOT_EXPORT_FORMAT\" },\n  { 0xC0000293, \"STATUS_FILE_ENCRYPTED\" },\n  { 0x40000294, \"STATUS_WAKE_SYSTEM\" },\n  { 0xC0000295, \"STATUS_WMI_GUID_NOT_FOUND\" },\n  { 0xC0000296, \"STATUS_WMI_INSTANCE_NOT_FOUND\" },\n  { 0xC0000297, \"STATUS_WMI_ITEMID_NOT_FOUND\" },\n  { 0xC0000298, \"STATUS_WMI_TRY_AGAIN\" },\n  { 0xC0000299, \"STATUS_SHARED_POLICY\" },\n  { 0xC000029A, \"STATUS_POLICY_OBJECT_NOT_FOUND\" },\n  { 0xC000029B, \"STATUS_POLICY_ONLY_IN_DS\" },\n  { 0xC000029C, \"STATUS_VOLUME_NOT_UPGRADED\" },\n  { 0xC000029D, \"STATUS_REMOTE_STORAGE_NOT_ACTIVE\" },\n  { 0xC000029E, \"STATUS_REMOTE_STORAGE_MEDIA_ERROR\" },\n  { 0xC000029F, \"STATUS_NO_TRACKING_SERVICE\" },\n  { 0xC00002A0, \"STATUS_SERVER_SID_MISMATCH\" },\n  { 0xC00002A1, \"STATUS_DS_NO_ATTRIBUTE_OR_VALUE\" },\n  { 0xC00002A2, \"STATUS_DS_INVALID_ATTRIBUTE_SYNTAX\" },\n  { 0xC00002A3, \"STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED\" },\n  { 0xC00002A4, \"STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS\" },\n  { 0xC00002A5, \"STATUS_DS_BUSY\" },\n  { 0xC00002A6, \"STATUS_DS_UNAVAILABLE\" },\n  { 0xC00002A7, \"STATUS_DS_NO_RIDS_ALLOCATED\" },\n  { 0xC00002A8, \"STATUS_DS_NO_MORE_RIDS\" },\n  { 0xC00002A9, \"STATUS_DS_INCORRECT_ROLE_OWNER\" },\n  { 0xC00002AA, \"STATUS_DS_RIDMGR_INIT_ERROR\" },\n  { 0xC00002AB, \"STATUS_DS_OBJ_CLASS_VIOLATION\" },\n  { 0xC00002AC, \"STATUS_DS_CANT_ON_NON_LEAF\" },\n  { 0xC00002AD, \"STATUS_DS_CANT_ON_RDN\" },\n  { 0xC00002AE, \"STATUS_DS_CANT_MOD_OBJ_CLASS\" },\n  { 0xC00002AF, \"STATUS_DS_CROSS_DOM_MOVE_FAILED\" },\n  { 0xC00002B0, \"STATUS_DS_GC_NOT_AVAILABLE\" },\n  { 0xC00002B1, \"STATUS_DIRECTORY_SERVICE_REQUIRED\" },\n  { 0xC00002B2, \"STATUS_REPARSE_ATTRIBUTE_CONFLICT\" },\n  { 0xC00002B3, \"STATUS_CANT_ENABLE_DENY_ONLY\" },\n  { 0xC00002B4, \"STATUS_FLOAT_MULTIPLE_FAULTS\" },\n  { 0xC00002B5, \"STATUS_FLOAT_MULTIPLE_TRAPS\" },\n  { 0xC00002B6, \"STATUS_DEVICE_REMOVED\" },\n  { 0xC00002B7, \"STATUS_JOURNAL_DELETE_IN_PROGRESS\" },\n  { 0xC00002B8, \"STATUS_JOURNAL_NOT_ACTIVE\" },\n  { 0xC00002B9, \"STATUS_NOINTERFACE\" },\n  { 0xC00002C1, \"STATUS_DS_ADMIN_LIMIT_EXCEEDED\" },\n  { 0xC00002C2, \"STATUS_DRIVER_FAILED_SLEEP\" },\n  { 0xC00002C3, \"STATUS_MUTUAL_AUTHENTICATION_FAILED\" },\n  { 0xC00002C4, \"STATUS_CORRUPT_SYSTEM_FILE\" },\n  { 0xC00002C5, \"STATUS_DATATYPE_MISALIGNMENT_ERROR\" },\n  { 0xC00002C6, \"STATUS_WMI_READ_ONLY\" },\n  { 0xC00002C7, \"STATUS_WMI_SET_FAILURE\" },\n  { 0xC00002C8, \"STATUS_COMMITMENT_MINIMUM\" },\n  { 0xC00002C9, \"STATUS_REG_NAT_CONSUMPTION\" },\n  { 0xC00002CA, \"STATUS_TRANSPORT_FULL\" },\n  { 0xC00002CB, \"STATUS_DS_SAM_INIT_FAILURE\" },\n  { 0xC00002CC, \"STATUS_ONLY_IF_CONNECTED\" },\n  { 0xC00002CD, \"STATUS_DS_SENSITIVE_GROUP_VIOLATION\" },\n  { 0xC00002CE, \"STATUS_PNP_RESTART_ENUMERATION\" },\n  { 0xC00002CF, \"STATUS_JOURNAL_ENTRY_DELETED\" },\n  { 0xC00002D0, \"STATUS_DS_CANT_MOD_PRIMARYGROUPID\" },\n  { 0xC00002D1, \"STATUS_SYSTEM_IMAGE_BAD_SIGNATURE\" },\n  { 0xC00002D2, \"STATUS_PNP_REBOOT_REQUIRED\" },\n  { 0xC00002D3, \"STATUS_POWER_STATE_INVALID\" },\n  { 0xC00002D4, \"STATUS_DS_INVALID_GROUP_TYPE\" },\n  { 0xC00002D5, \"STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN\" },\n  { 0xC00002D6, \"STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN\" },\n  { 0xC00002D7, \"STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER\" },\n  { 0xC00002D8, \"STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER\" },\n  { 0xC00002D9, \"STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER\" },\n  { 0xC00002DA, \"STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER\" },\n  { 0xC00002DB, \"STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER\" },\n  { 0xC00002DC, \"STATUS_DS_HAVE_PRIMARY_MEMBERS\" },\n  { 0xC00002DD, \"STATUS_WMI_NOT_SUPPORTED\" },\n  { 0xC00002DE, \"STATUS_INSUFFICIENT_POWER\" },\n  { 0xC00002DF, \"STATUS_SAM_NEED_BOOTKEY_PASSWORD\" },\n  { 0xC00002E0, \"STATUS_SAM_NEED_BOOTKEY_FLOPPY\" },\n  { 0xC00002E1, \"STATUS_DS_CANT_START\" },\n  { 0xC00002E2, \"STATUS_DS_INIT_FAILURE\" },\n  { 0xC00002E3, \"STATUS_SAM_INIT_FAILURE\" },\n  { 0xC00002E4, \"STATUS_DS_GC_REQUIRED\" },\n  { 0xC00002E5, \"STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY\" },\n  { 0xC00002E6, \"STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS\" },\n  { 0xC00002E7, \"STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED\" },\n  { 0xC00002E8, \"STATUS_MULTIPLE_FAULT_VIOLATION\" },\n  { 0xC0000300, \"STATUS_NOT_SUPPORTED_ON_SBS\" },\n  { 0xC0009898, \"STATUS_WOW_ASSERTION\" },\n  { 0xC0020001, \"RPC_NT_INVALID_STRING_BINDING\" },\n  { 0xC0020002, \"RPC_NT_WRONG_KIND_OF_BINDING\" },\n  { 0xC0020003, \"RPC_NT_INVALID_BINDING\" },\n  { 0xC0020004, \"RPC_NT_PROTSEQ_NOT_SUPPORTED\" },\n  { 0xC0020005, \"RPC_NT_INVALID_RPC_PROTSEQ\" },\n  { 0xC0020006, \"RPC_NT_INVALID_STRING_UUID\" },\n  { 0xC0020007, \"RPC_NT_INVALID_ENDPOINT_FORMAT\" },\n  { 0xC0020008, \"RPC_NT_INVALID_NET_ADDR\" },\n  { 0xC0020009, \"RPC_NT_NO_ENDPOINT_FOUND\" },\n  { 0xC002000A, \"RPC_NT_INVALID_TIMEOUT\" },\n  { 0xC002000B, \"RPC_NT_OBJECT_NOT_FOUND\" },\n  { 0xC002000C, \"RPC_NT_ALREADY_REGISTERED\" },\n  { 0xC002000D, \"RPC_NT_TYPE_ALREADY_REGISTERED\" },\n  { 0xC002000E, \"RPC_NT_ALREADY_LISTENING\" },\n  { 0xC002000F, \"RPC_NT_NO_PROTSEQS_REGISTERED\" },\n  { 0xC0020010, \"RPC_NT_NOT_LISTENING\" },\n  { 0xC0020011, \"RPC_NT_UNKNOWN_MGR_TYPE\" },\n  { 0xC0020012, \"RPC_NT_UNKNOWN_IF\" },\n  { 0xC0020013, \"RPC_NT_NO_BINDINGS\" },\n  { 0xC0020014, \"RPC_NT_NO_PROTSEQS\" },\n  { 0xC0020015, \"RPC_NT_CANT_CREATE_ENDPOINT\" },\n  { 0xC0020016, \"RPC_NT_OUT_OF_RESOURCES\" },\n  { 0xC0020017, \"RPC_NT_SERVER_UNAVAILABLE\" },\n  { 0xC0020018, \"RPC_NT_SERVER_TOO_BUSY\" },\n  { 0xC0020019, \"RPC_NT_INVALID_NETWORK_OPTIONS\" },\n  { 0xC002001A, \"RPC_NT_NO_CALL_ACTIVE\" },\n  { 0xC002001B, \"RPC_NT_CALL_FAILED\" },\n  { 0xC002001C, \"RPC_NT_CALL_FAILED_DNE\" },\n  { 0xC002001D, \"RPC_NT_PROTOCOL_ERROR\" },\n  { 0xC002001F, \"RPC_NT_UNSUPPORTED_TRANS_SYN\" },\n  { 0xC0020021, \"RPC_NT_UNSUPPORTED_TYPE\" },\n  { 0xC0020022, \"RPC_NT_INVALID_TAG\" },\n  { 0xC0020023, \"RPC_NT_INVALID_BOUND\" },\n  { 0xC0020024, \"RPC_NT_NO_ENTRY_NAME\" },\n  { 0xC0020025, \"RPC_NT_INVALID_NAME_SYNTAX\" },\n  { 0xC0020026, \"RPC_NT_UNSUPPORTED_NAME_SYNTAX\" },\n  { 0xC0020028, \"RPC_NT_UUID_NO_ADDRESS\" },\n  { 0xC0020029, \"RPC_NT_DUPLICATE_ENDPOINT\" },\n  { 0xC002002A, \"RPC_NT_UNKNOWN_AUTHN_TYPE\" },\n  { 0xC002002B, \"RPC_NT_MAX_CALLS_TOO_SMALL\" },\n  { 0xC002002C, \"RPC_NT_STRING_TOO_LONG\" },\n  { 0xC002002D, \"RPC_NT_PROTSEQ_NOT_FOUND\" },\n  { 0xC002002E, \"RPC_NT_PROCNUM_OUT_OF_RANGE\" },\n  { 0xC002002F, \"RPC_NT_BINDING_HAS_NO_AUTH\" },\n  { 0xC0020030, \"RPC_NT_UNKNOWN_AUTHN_SERVICE\" },\n  { 0xC0020031, \"RPC_NT_UNKNOWN_AUTHN_LEVEL\" },\n  { 0xC0020032, \"RPC_NT_INVALID_AUTH_IDENTITY\" },\n  { 0xC0020033, \"RPC_NT_UNKNOWN_AUTHZ_SERVICE\" },\n  { 0xC0020034, \"EPT_NT_INVALID_ENTRY\" },\n  { 0xC0020035, \"EPT_NT_CANT_PERFORM_OP\" },\n  { 0xC0020036, \"EPT_NT_NOT_REGISTERED\" },\n  { 0xC0020037, \"RPC_NT_NOTHING_TO_EXPORT\" },\n  { 0xC0020038, \"RPC_NT_INCOMPLETE_NAME\" },\n  { 0xC0020039, \"RPC_NT_INVALID_VERS_OPTION\" },\n  { 0xC002003A, \"RPC_NT_NO_MORE_MEMBERS\" },\n  { 0xC002003B, \"RPC_NT_NOT_ALL_OBJS_UNEXPORTED\" },\n  { 0xC002003C, \"RPC_NT_INTERFACE_NOT_FOUND\" },\n  { 0xC002003D, \"RPC_NT_ENTRY_ALREADY_EXISTS\" },\n  { 0xC002003E, \"RPC_NT_ENTRY_NOT_FOUND\" },\n  { 0xC002003F, \"RPC_NT_NAME_SERVICE_UNAVAILABLE\" },\n  { 0xC0020040, \"RPC_NT_INVALID_NAF_ID\" },\n  { 0xC0020041, \"RPC_NT_CANNOT_SUPPORT\" },\n  { 0xC0020042, \"RPC_NT_NO_CONTEXT_AVAILABLE\" },\n  { 0xC0020043, \"RPC_NT_INTERNAL_ERROR\" },\n  { 0xC0020044, \"RPC_NT_ZERO_DIVIDE\" },\n  { 0xC0020045, \"RPC_NT_ADDRESS_ERROR\" },\n  { 0xC0020046, \"RPC_NT_FP_DIV_ZERO\" },\n  { 0xC0020047, \"RPC_NT_FP_UNDERFLOW\" },\n  { 0xC0020048, \"RPC_NT_FP_OVERFLOW\" },\n  { 0xC0021007, \"RPC_P_RECEIVE_ALERTED\" },\n  { 0xC0021008, \"RPC_P_CONNECTION_CLOSED\" },\n  { 0xC0021009, \"RPC_P_RECEIVE_FAILED\" },\n  { 0xC002100A, \"RPC_P_SEND_FAILED\" },\n  { 0xC002100B, \"RPC_P_TIMEOUT\" },\n  { 0xC002100C, \"RPC_P_SERVER_TRANSPORT_ERROR\" },\n  { 0xC002100E, \"RPC_P_EXCEPTION_OCCURRED\" },\n  { 0xC0021012, \"RPC_P_CONNECTION_SHUTDOWN\" },\n  { 0xC0021015, \"RPC_P_THREAD_LISTENING\" },\n  { 0xC0030001, \"RPC_NT_NO_MORE_ENTRIES\" },\n  { 0xC0030002, \"RPC_NT_SS_CHAR_TRANS_OPEN_FAIL\" },\n  { 0xC0030003, \"RPC_NT_SS_CHAR_TRANS_SHORT_FILE\" },\n  { 0xC0030004, \"RPC_NT_SS_IN_NULL_CONTEXT\" },\n  { 0xC0030005, \"RPC_NT_SS_CONTEXT_MISMATCH\" },\n  { 0xC0030006, \"RPC_NT_SS_CONTEXT_DAMAGED\" },\n  { 0xC0030007, \"RPC_NT_SS_HANDLES_MISMATCH\" },\n  { 0xC0030008, \"RPC_NT_SS_CANNOT_GET_CALL_HANDLE\" },\n  { 0xC0030009, \"RPC_NT_NULL_REF_POINTER\" },\n  { 0xC003000A, \"RPC_NT_ENUM_VALUE_OUT_OF_RANGE\" },\n  { 0xC003000B, \"RPC_NT_BYTE_COUNT_TOO_SMALL\" },\n  { 0xC003000C, \"RPC_NT_BAD_STUB_DATA\" },\n  { 0xC0020049, \"RPC_NT_CALL_IN_PROGRESS\" },\n  { 0xC002004A, \"RPC_NT_NO_MORE_BINDINGS\" },\n  { 0xC002004B, \"RPC_NT_GROUP_MEMBER_NOT_FOUND\" },\n  { 0xC002004C, \"EPT_NT_CANT_CREATE\" },\n  { 0xC002004D, \"RPC_NT_INVALID_OBJECT\" },\n  { 0xC002004F, \"RPC_NT_NO_INTERFACES\" },\n  { 0xC0020050, \"RPC_NT_CALL_CANCELLED\" },\n  { 0xC0020051, \"RPC_NT_BINDING_INCOMPLETE\" },\n  { 0xC0020052, \"RPC_NT_COMM_FAILURE\" },\n  { 0xC0020053, \"RPC_NT_UNSUPPORTED_AUTHN_LEVEL\" },\n  { 0xC0020054, \"RPC_NT_NO_PRINC_NAME\" },\n  { 0xC0020055, \"RPC_NT_NOT_RPC_ERROR\" },\n  { 0x40020056, \"RPC_NT_UUID_LOCAL_ONLY\" },\n  { 0xC0020057, \"RPC_NT_SEC_PKG_ERROR\" },\n  { 0xC0020058, \"RPC_NT_NOT_CANCELLED\" },\n  { 0xC0030059, \"RPC_NT_INVALID_ES_ACTION\" },\n  { 0xC003005A, \"RPC_NT_WRONG_ES_VERSION\" },\n  { 0xC003005B, \"RPC_NT_WRONG_STUB_VERSION\" },\n  { 0xC003005C, \"RPC_NT_INVALID_PIPE_OBJECT\" },\n  { 0xC003005D, \"RPC_NT_INVALID_PIPE_OPERATION\" },\n  { 0xC003005E, \"RPC_NT_WRONG_PIPE_VERSION\" },\n  { 0x400200AF, \"RPC_NT_SEND_INCOMPLETE\" },\n  { 0,          NULL }\n};\n\n/*\n * return an NT error string from a SMB buffer\n */\nconst char *\nnt_errstr(uint32_t err)\n{\n    static char ret[128];\n    int i;\n\n    ret[0] = 0;\n\n    for (i = 0; nt_errors[i].name; i++) {\n\tif (err == nt_errors[i].code)\n\t    return nt_errors[i].name;\n    }\n\n    snprintf(ret, sizeof(ret), \"0x%08x\", err);\n    return ret;\n}\n", "/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Support for splitting captures into multiple files with a maximum\n * file size:\n *\n * Copyright (c) 2001\n *\tSeth Webster <swebster@sst.ll.mit.edu>\n */\n\n/*\n * tcpdump - dump traffic on a network\n *\n * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.\n * Mercilessly hacked and occasionally improved since then via the\n * combined efforts of Van, Steve McCanne and Craig Leres of LBL.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n/*\n * Some older versions of Mac OS X may ship pcap.h from libpcap 0.6 with a\n * libpcap based on 0.8.  That means it has pcap_findalldevs() but the\n * header doesn't define pcap_if_t, meaning that we can't actually *use*\n * pcap_findalldevs().\n */\n#ifdef HAVE_PCAP_FINDALLDEVS\n#ifndef HAVE_PCAP_IF_T\n#undef HAVE_PCAP_FINDALLDEVS\n#endif\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n/*\n * This must appear after including netdissect-stdinc.h, so that _U_ is\n * defined.\n */\n#ifndef lint\nstatic const char copyright[] _U_ =\n    \"@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\\n\\\nThe Regents of the University of California.  All rights reserved.\\n\";\n#endif\n\n#include <sys/stat.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef HAVE_LIBCRYPTO\n#include <openssl/crypto.h>\n#endif\n\n#ifdef HAVE_GETOPT_LONG\n#include <getopt.h>\n#else\n#include \"missing/getopt_long.h\"\n#endif\n/* Capsicum-specific code requires macros from <net/bpf.h>, which will fail\n * to compile if <pcap.h> has already been included; including the headers\n * in the opposite order works fine. For the most part anyway, because in\n * FreeBSD <pcap/pcap.h> declares bpf_dump() instead of <net/bpf.h>. Thus\n * interface.h takes care of it later to avoid a compiler warning.\n */\n#ifdef HAVE_CAPSICUM\n#include <sys/capsicum.h>\n#include <sys/ioccom.h>\n#include <net/bpf.h>\n#include <libgen.h>\n#ifdef HAVE_CASPER\n#include <libcasper.h>\n#include <casper/cap_dns.h>\n#include <sys/nv.h>\n#endif\t/* HAVE_CASPER */\n#endif\t/* HAVE_CAPSICUM */\n#ifdef HAVE_PCAP_OPEN\n/*\n * We found pcap_open() in the capture library, so we'll be using\n * the remote capture APIs; define PCAP_REMOTE before we include pcap.h,\n * so we get those APIs declared, and the types and #defines that they\n * use defined.\n *\n * WinPcap's headers require that PCAP_REMOTE be defined in order to get\n * remote-capture APIs declared and types and #defines that they use\n * defined.\n *\n * (Versions of libpcap with those APIs, and thus Npcap, which is based on\n * those versions of libpcap, don't require it.)\n */\n#define HAVE_REMOTE\n#endif\n#include <pcap.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <pwd.h>\n#include <grp.h>\n#endif /* _WIN32 */\n\n/*\n * Pathname separator.\n * Use this in pathnames, but do *not* use it in URLs.\n */\n#ifdef _WIN32\n#define PATH_SEPARATOR\t'\\\\'\n#else\n#define PATH_SEPARATOR\t'/'\n#endif\n\n/* capabilities convenience library */\n/* If a code depends on HAVE_LIBCAP_NG, it depends also on HAVE_CAP_NG_H.\n * If HAVE_CAP_NG_H is not defined, undefine HAVE_LIBCAP_NG.\n * Thus, the later tests are done only on HAVE_LIBCAP_NG.\n */\n#ifdef HAVE_LIBCAP_NG\n#ifdef HAVE_CAP_NG_H\n#include <cap-ng.h>\n#else\n#undef HAVE_LIBCAP_NG\n#endif /* HAVE_CAP_NG_H */\n#endif /* HAVE_LIBCAP_NG */\n\n#ifdef __FreeBSD__\n#include <sys/sysctl.h>\n#endif /* __FreeBSD__ */\n\n#include \"netdissect-stdinc.h\"\n#include \"netdissect.h\"\n#include \"interface.h\"\n#include \"addrtoname.h\"\n#include \"machdep.h\"\n#include \"pcap-missing.h\"\n#include \"ascii_strcasecmp.h\"\n\n#include \"print.h\"\n\n#include \"diag-control.h\"\n\n#include \"fptype.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#if defined(SIGINFO)\n#define SIGNAL_REQ_INFO SIGINFO\n#elif defined(SIGUSR1)\n#define SIGNAL_REQ_INFO SIGUSR1\n#endif\n\n#if defined(HAVE_PCAP_DUMP_FLUSH) && defined(SIGUSR2)\n#define SIGNAL_FLUSH_PCAP SIGUSR2\n#endif\n\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\nstatic int Bflag;\t\t\t/* buffer size */\n#endif\n#ifdef HAVE_PCAP_DUMP_FTELL64\nstatic int64_t Cflag;\t\t\t/* rotate dump files after this many bytes */\n#else\nstatic long Cflag;\t\t\t/* rotate dump files after this many bytes */\n#endif\nstatic int Cflag_count;\t\t\t/* Keep track of which file number we're writing */\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic int Dflag;\t\t\t/* list available devices and exit */\n#endif\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\nstatic char *remote_interfaces_source;\t/* list available devices from this source and exit */\n#endif\n\n/*\n * This is exported because, in some versions of libpcap, if libpcap\n * is built with optimizer debugging code (which is *NOT* the default\n * configuration!), the library *imports*(!) a variable named dflag,\n * under the expectation that tcpdump is exporting it, to govern\n * how much debugging information to print when optimizing\n * the generated BPF code.\n *\n * This is a horrible hack; newer versions of libpcap don't import\n * dflag but, instead, *if* built with optimizer debugging code,\n * *export* a routine to set that flag.\n */\nextern int dflag;\nint dflag;\t\t\t\t/* print filter code */\nstatic int Gflag;\t\t\t/* rotate dump files after this many seconds */\nstatic int Gflag_count;\t\t\t/* number of files created with Gflag rotation */\nstatic time_t Gflag_time;\t\t/* The last time_t the dump file was rotated. */\nstatic int Lflag;\t\t\t/* list available data link types and exit */\nstatic int Iflag;\t\t\t/* rfmon (monitor) mode */\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic int Jflag;\t\t\t/* list available time stamp types */\nstatic int jflag = -1;\t\t\t/* packet time stamp source */\n#endif\nstatic int lflag;\t\t\t/* line-buffered output */\nstatic int pflag;\t\t\t/* don't go promiscuous */\n#ifdef HAVE_PCAP_SETDIRECTION\nstatic int Qflag = -1;\t\t\t/* restrict captured packet by send/receive direction */\n#endif\n#ifdef HAVE_PCAP_DUMP_FLUSH\nstatic int Uflag;\t\t\t/* \"unbuffered\" output of dump files */\n#endif\nstatic int Wflag;\t\t\t/* recycle output files after this number of files */\nstatic int WflagChars;\nstatic char *zflag = NULL;\t\t/* compress each savefile using a specified command (like gzip or bzip2) */\nstatic int timeout = 1000;\t\t/* default timeout = 1000 ms = 1 s */\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\nstatic int immediate_mode;\n#endif\nstatic int count_mode;\n\nstatic int infodelay;\nstatic int infoprint;\n\nchar *program_name;\n\n/* Forwards */\nstatic NORETURN void error(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);\nstatic void warning(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);\nstatic NORETURN void exit_tcpdump(int);\nstatic void (*setsignal (int sig, void (*func)(int)))(int);\nstatic void cleanup(int);\nstatic void child_cleanup(int);\nstatic void print_version(FILE *);\nstatic void print_usage(FILE *);\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic NORETURN void show_tstamp_types_and_exit(pcap_t *, const char *device);\n#endif\nstatic NORETURN void show_dlts_and_exit(pcap_t *, const char *device);\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic NORETURN void show_devices_and_exit(void);\n#endif\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\nstatic NORETURN void show_remote_devices_and_exit(void);\n#endif\n\nstatic void print_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet_and_trunc(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void droproot(const char *, const char *);\n\n#ifdef SIGNAL_REQ_INFO\nstatic void requestinfo(int);\n#endif\n\n#ifdef SIGNAL_FLUSH_PCAP\nstatic void flushpcap(int);\n#endif\n\n#ifdef _WIN32\n    static HANDLE timer_handle = INVALID_HANDLE_VALUE;\n    static void CALLBACK verbose_stats_dump(PVOID param, BOOLEAN timer_fired);\n#else /* _WIN32 */\n  static void verbose_stats_dump(int sig);\n#endif /* _WIN32 */\n\nstatic void info(int);\nstatic u_int packets_captured;\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic const struct tok status_flags[] = {\n#ifdef PCAP_IF_UP\n\t{ PCAP_IF_UP,       \"Up\"       },\n#endif\n#ifdef PCAP_IF_RUNNING\n\t{ PCAP_IF_RUNNING,  \"Running\"  },\n#endif\n\t{ PCAP_IF_LOOPBACK, \"Loopback\" },\n#ifdef PCAP_IF_WIRELESS\n\t{ PCAP_IF_WIRELESS, \"Wireless\" },\n#endif\n\t{ 0, NULL }\n};\n#endif\n\nstatic pcap_t *pd;\nstatic pcap_dumper_t *pdd = NULL;\n\nstatic int supports_monitor_mode;\n\nextern int optind;\nextern int opterr;\nextern char *optarg;\n\nstruct dump_info {\n\tchar\t*WFileName;\n\tchar\t*CurrentFileName;\n\tpcap_t\t*pd;\n\tpcap_dumper_t *pdd;\n\tnetdissect_options *ndo;\n#ifdef HAVE_CAPSICUM\n\tint\tdirfd;\n#endif\n};\n\n#if defined(HAVE_PCAP_SET_PARSER_DEBUG)\n/*\n * We have pcap_set_parser_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the parser for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_parser_debug(int);\n#elif defined(HAVE_PCAP_DEBUG) || defined(HAVE_YYDEBUG)\n/*\n * We don't have pcap_set_parser_debug() in libpcap, but we do have\n * pcap_debug or yydebug.  Make a local version of pcap_set_parser_debug()\n * to set the flag, and define HAVE_PCAP_SET_PARSER_DEBUG.\n */\nstatic void\npcap_set_parser_debug(int value)\n{\n#ifdef HAVE_PCAP_DEBUG\n\textern int pcap_debug;\n\n\tpcap_debug = value;\n#else /* HAVE_PCAP_DEBUG */\n\textern int yydebug;\n\n\tyydebug = value;\n#endif /* HAVE_PCAP_DEBUG */\n}\n\n#define HAVE_PCAP_SET_PARSER_DEBUG\n#endif\n\n#if defined(HAVE_PCAP_SET_OPTIMIZER_DEBUG)\n/*\n * We have pcap_set_optimizer_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the optimizer for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_optimizer_debug(int);\n#endif\n\n/* VARARGS */\nstatic void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit_tcpdump(S_ERR_HOST_PROGRAM);\n\t/* NOTREACHED */\n}\n\n/* VARARGS */\nstatic void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}\n\nstatic void\nexit_tcpdump(int status)\n{\n\tnd_cleanup();\n\texit(status);\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic void\nshow_tstamp_types_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_tstamp_types;\n\tint *tstamp_types = 0;\n\tconst char *tstamp_type_name;\n\tint i;\n\n\tn_tstamp_types = pcap_list_tstamp_types(pc, &tstamp_types);\n\tif (n_tstamp_types < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\n\tif (n_tstamp_types == 0) {\n\t\tfprintf(stderr, \"Time stamp type cannot be set for %s\\n\",\n\t\t    device);\n\t\texit_tcpdump(S_SUCCESS);\n\t}\n\tfprintf(stderr, \"Time stamp types for %s (use option -j to set):\\n\",\n\t    device);\n\tfor (i = 0; i < n_tstamp_types; i++) {\n\t\ttstamp_type_name = pcap_tstamp_type_val_to_name(tstamp_types[i]);\n\t\tif (tstamp_type_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\\n\", tstamp_type_name,\n\t\t\t    pcap_tstamp_type_val_to_description(tstamp_types[i]));\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  %d\\n\", tstamp_types[i]);\n\t\t}\n\t}\n\tpcap_free_tstamp_types(tstamp_types);\n\texit_tcpdump(S_SUCCESS);\n}\n#endif\n\nstatic void\nshow_dlts_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_dlts, i;\n\tint *dlts = 0;\n\tconst char *dlt_name;\n\n\tn_dlts = pcap_list_datalinks(pc, &dlts);\n\tif (n_dlts < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\telse if (n_dlts == 0 || !dlts)\n\t\terror(\"No data link types.\");\n\n\t/*\n\t * If the interface is known to support monitor mode, indicate\n\t * whether these are the data link types available when not in\n\t * monitor mode, if -I wasn't specified, or when in monitor mode,\n\t * when -I was specified (the link-layer types available in\n\t * monitor mode might be different from the ones available when\n\t * not in monitor mode).\n\t */\n\tif (supports_monitor_mode)\n\t\t(void) fprintf(stderr, \"Data link types for %s %s (use option -y to set):\\n\",\n\t\t    device,\n\t\t    Iflag ? \"when in monitor mode\" : \"when not in monitor mode\");\n\telse\n\t\t(void) fprintf(stderr, \"Data link types for %s (use option -y to set):\\n\",\n\t\t    device);\n\n\tfor (i = 0; i < n_dlts; i++) {\n\t\tdlt_name = pcap_datalink_val_to_name(dlts[i]);\n\t\tif (dlt_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\", dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlts[i]));\n\n\t\t\t/*\n\t\t\t * OK, does tcpdump handle that type?\n\t\t\t */\n\t\t\tif (!has_printer(dlts[i]))\n\t\t\t\t(void) fprintf(stderr, \" (printing not supported)\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  DLT %d (printing not supported)\\n\",\n\t\t\t    dlts[i]);\n\t\t}\n\t}\n#ifdef HAVE_PCAP_FREE_DATALINKS\n\tpcap_free_datalinks(dlts);\n#endif\n\texit_tcpdump(S_SUCCESS);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic void\nshow_devices_and_exit(void)\n{\n\tpcap_if_t *dev, *devlist;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint i;\n\n\tif (pcap_findalldevs(&devlist, ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\tfor (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {\n\t\tprintf(\"%d.%s\", i+1, dev->name);\n\t\tif (dev->description != NULL)\n\t\t\tprintf(\" (%s)\", dev->description);\n\t\tif (dev->flags != 0) {\n\t\t\tprintf(\" [\");\n\t\t\tprintf(\"%s\", bittok2str(status_flags, \"none\", dev->flags));\n#ifdef PCAP_IF_WIRELESS\n\t\t\tif (dev->flags & PCAP_IF_WIRELESS) {\n\t\t\t\tswitch (dev->flags & PCAP_IF_CONNECTION_STATUS) {\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_UNKNOWN:\n\t\t\t\t\tprintf(\", Association status unknown\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_CONNECTED:\n\t\t\t\t\tprintf(\", Associated\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_DISCONNECTED:\n\t\t\t\t\tprintf(\", Not associated\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (dev->flags & PCAP_IF_CONNECTION_STATUS) {\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_UNKNOWN:\n\t\t\t\t\tprintf(\", Connection status unknown\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_CONNECTED:\n\t\t\t\t\tprintf(\", Connected\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_DISCONNECTED:\n\t\t\t\t\tprintf(\", Disconnected\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tprintf(\"]\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tpcap_freealldevs(devlist);\n\texit_tcpdump(S_SUCCESS);\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\nstatic void\nshow_remote_devices_and_exit(void)\n{\n\tpcap_if_t *dev, *devlist;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint i;\n\n\tif (pcap_findalldevs_ex(remote_interfaces_source, NULL, &devlist,\n\t    ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\tfor (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {\n\t\tprintf(\"%d.%s\", i+1, dev->name);\n\t\tif (dev->description != NULL)\n\t\t\tprintf(\" (%s)\", dev->description);\n\t\tif (dev->flags != 0)\n\t\t\tprintf(\" [%s]\", bittok2str(status_flags, \"none\", dev->flags));\n\t\tprintf(\"\\n\");\n\t}\n\tpcap_freealldevs(devlist);\n\texit_tcpdump(S_SUCCESS);\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n/*\n * Short options.\n *\n * Note that there we use all letters for short options except for g, k,\n * o, and P, and those are used by other versions of tcpdump, and we should\n * only use them for the same purposes that the other versions of tcpdump\n * use them:\n *\n * macOS tcpdump uses -g to force non--v output for IP to be on one\n * line, making it more \"g\"repable;\n *\n * macOS tcpdump uses -k to specify that packet comments in pcapng files\n * should be printed;\n *\n * OpenBSD tcpdump uses -o to indicate that OS fingerprinting should be done\n * for hosts sending TCP SYN packets;\n *\n * macOS tcpdump uses -P to indicate that -w should write pcapng rather\n * than pcap files.\n *\n * macOS tcpdump also uses -Q to specify expressions that match packet\n * metadata, including but not limited to the packet direction.\n * The expression syntax is different from a simple \"in|out|inout\",\n * and those expressions aren't accepted by macOS tcpdump, but the\n * equivalents would be \"in\" = \"dir=in\", \"out\" = \"dir=out\", and\n * \"inout\" = \"dir=in or dir=out\", and the parser could conceivably\n * special-case \"in\", \"out\", and \"inout\" as expressions for backwards\n * compatibility, so all is not (yet) lost.\n */\n\n/*\n * Set up flags that might or might not be supported depending on the\n * version of libpcap we're using.\n */\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n#define B_FLAG\t\t\"B:\"\n#define B_FLAG_USAGE\t\" [ -B size ]\"\n#else /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n#define B_FLAG\n#define B_FLAG_USAGE\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n#define D_FLAG\t\"D\"\n#else\n#define D_FLAG\n#endif\n\n#ifdef HAVE_PCAP_CREATE\n#define I_FLAG\t\t\"I\"\n#else /* HAVE_PCAP_CREATE */\n#define I_FLAG\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n#define j_FLAG\t\t\"j:\"\n#define j_FLAG_USAGE\t\" [ -j tstamptype ]\"\n#define J_FLAG\t\t\"J\"\n#else /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n#define j_FLAG\n#define j_FLAG_USAGE\n#define J_FLAG\n#endif /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n\n#ifdef USE_LIBSMI\n#define m_FLAG_USAGE \"[ -m module ] ...\"\n#endif\n\n#ifdef HAVE_PCAP_SETDIRECTION\n#define Q_FLAG \"Q:\"\n#define Q_FLAG_USAGE \" [ -Q in|out|inout ]\"\n#else\n#define Q_FLAG\n#define Q_FLAG_USAGE\n#endif\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n#define U_FLAG\t\"U\"\n#else\n#define U_FLAG\n#endif\n\n#define SHORTOPTS \"aAb\" B_FLAG \"c:C:d\" D_FLAG \"eE:fF:G:hHi:\" I_FLAG j_FLAG J_FLAG \"KlLm:M:nNOpq\" Q_FLAG \"r:s:StT:u\" U_FLAG \"vV:w:W:xXy:Yz:Z:#\"\n\n/*\n * Long options.\n *\n * We do not currently have long options corresponding to all short\n * options; we should probably pick appropriate option names for them.\n *\n * However, the short options where the number of times the option is\n * specified matters, such as -v and -d and -t, should probably not\n * just map to a long option, as saying\n *\n *  tcpdump --verbose --verbose\n *\n * doesn't make sense; it should be --verbosity={N} or something such\n * as that.\n *\n * For long options with no corresponding short options, we define values\n * outside the range of ASCII graphic characters, make that the last\n * component of the entry for the long option, and have a case for that\n * option in the switch statement.\n */\n#define OPTION_VERSION\t\t\t128\n#define OPTION_TSTAMP_PRECISION\t\t129\n#define OPTION_IMMEDIATE_MODE\t\t130\n#define OPTION_PRINT\t\t\t131\n#define OPTION_LIST_REMOTE_INTERFACES\t132\n#define OPTION_TSTAMP_MICRO\t\t133\n#define OPTION_TSTAMP_NANO\t\t134\n#define OPTION_FP_TYPE\t\t\t135\n#define OPTION_COUNT\t\t\t136\n\nstatic const struct option longopts[] = {\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t{ \"buffer-size\", required_argument, NULL, 'B' },\n#endif\n\t{ \"list-interfaces\", no_argument, NULL, 'D' },\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t{ \"list-remote-interfaces\", required_argument, NULL, OPTION_LIST_REMOTE_INTERFACES },\n#endif\n\t{ \"help\", no_argument, NULL, 'h' },\n\t{ \"interface\", required_argument, NULL, 'i' },\n#ifdef HAVE_PCAP_CREATE\n\t{ \"monitor-mode\", no_argument, NULL, 'I' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t{ \"time-stamp-type\", required_argument, NULL, 'j' },\n\t{ \"list-time-stamp-types\", no_argument, NULL, 'J' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t{ \"micro\", no_argument, NULL, OPTION_TSTAMP_MICRO},\n\t{ \"nano\", no_argument, NULL, OPTION_TSTAMP_NANO},\n\t{ \"time-stamp-precision\", required_argument, NULL, OPTION_TSTAMP_PRECISION},\n#endif\n\t{ \"dont-verify-checksums\", no_argument, NULL, 'K' },\n\t{ \"list-data-link-types\", no_argument, NULL, 'L' },\n\t{ \"no-optimize\", no_argument, NULL, 'O' },\n\t{ \"no-promiscuous-mode\", no_argument, NULL, 'p' },\n#ifdef HAVE_PCAP_SETDIRECTION\n\t{ \"direction\", required_argument, NULL, 'Q' },\n#endif\n\t{ \"snapshot-length\", required_argument, NULL, 's' },\n\t{ \"absolute-tcp-sequence-numbers\", no_argument, NULL, 'S' },\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t{ \"packet-buffered\", no_argument, NULL, 'U' },\n#endif\n\t{ \"linktype\", required_argument, NULL, 'y' },\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t{ \"immediate-mode\", no_argument, NULL, OPTION_IMMEDIATE_MODE },\n#endif\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t{ \"debug-filter-parser\", no_argument, NULL, 'Y' },\n#endif\n\t{ \"relinquish-privileges\", required_argument, NULL, 'Z' },\n\t{ \"count\", no_argument, NULL, OPTION_COUNT },\n\t{ \"fp-type\", no_argument, NULL, OPTION_FP_TYPE },\n\t{ \"number\", no_argument, NULL, '#' },\n\t{ \"print\", no_argument, NULL, OPTION_PRINT },\n\t{ \"version\", no_argument, NULL, OPTION_VERSION },\n\t{ NULL, 0, NULL, 0 }\n};\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n#define LIST_REMOTE_INTERFACES_USAGE \"[ --list-remote-interfaces remote-source ]\"\n#else\n#define LIST_REMOTE_INTERFACES_USAGE\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n#define IMMEDIATE_MODE_USAGE \" [ --immediate-mode ]\"\n#else\n#define IMMEDIATE_MODE_USAGE \"\"\n#endif\n\n#ifndef _WIN32\n/* Drop root privileges and chroot if necessary */\nstatic void\ndroproot(const char *username, const char *chroot_dir)\n{\n\tstruct passwd *pw = NULL;\n\n\tif (chroot_dir && !username)\n\t\terror(\"Chroot without dropping root is insecure\");\n\n\tpw = getpwnam(username);\n\tif (pw) {\n\t\tif (chroot_dir) {\n\t\t\tif (chroot(chroot_dir) != 0 || chdir (\"/\") != 0)\n\t\t\t\terror(\"Couldn't chroot/chdir to '%.64s': %s\",\n\t\t\t\t      chroot_dir, pcap_strerror(errno));\n\t\t}\n#ifdef HAVE_LIBCAP_NG\n\t\t{\n\t\t\tint ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);\n\t\t\tif (ret < 0)\n\t\t\t\terror(\"capng_change_id(): return %d\\n\", ret);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#else\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) != 0 ||\n\t\t    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0)\n\t\t\terror(\"Couldn't change to '%.32s' uid=%lu gid=%lu: %s\",\n\t\t\t\tusername,\n\t\t\t\t(unsigned long)pw->pw_uid,\n\t\t\t\t(unsigned long)pw->pw_gid,\n\t\t\t\tpcap_strerror(errno));\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#endif /* HAVE_LIBCAP_NG */\n\t} else\n\t\terror(\"Couldn't find user '%.32s'\", username);\n#ifdef HAVE_LIBCAP_NG\n\t/* We don't need CAP_SETUID, CAP_SETGID and CAP_SYS_CHROOT any more. */\nDIAG_OFF_ASSIGN_ENUM\n\tcapng_updatev(\n\t\tCAPNG_DROP,\n\t\tCAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t\tCAP_SETUID,\n\t\tCAP_SETGID,\n\t\tCAP_SYS_CHROOT,\n\t\t-1);\nDIAG_ON_ASSIGN_ENUM\n\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\n}\n#endif /* _WIN32 */\n\nstatic int\ngetWflagChars(int x)\n{\n\tint c = 0;\n\n\tx -= 1;\n\twhile (x > 0) {\n\t\tc += 1;\n\t\tx /= 10;\n\t}\n\n\treturn c;\n}\n\n\nstatic void\nMakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n\n        /* Process with strftime if Gflag is set. */\n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          /* Convert Gflag_time to a usable format */\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n\n          /* There's no good way to detect an error in strftime since a return\n           * value of 0 isn't necessarily failure.\n           */\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  /* Report an error if the filename is too large */\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}\n\nstatic char *\nget_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tsize_t len;\n\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\n\tlen = strlen (ptr);\n\tif (len > 0 && ptr[len - 1] == '\\n')\n\t\tptr[len - 1] = '\\0';\n\n\treturn ret;\n}\n\n#ifdef HAVE_CASPER\nstatic cap_channel_t *\ncapdns_setup(void)\n{\n\tcap_channel_t *capcas, *capdnsloc;\n\tconst char *types[1];\n\tint families[2];\n\n\tcapcas = cap_init();\n\tif (capcas == NULL)\n\t\terror(\"unable to create casper process\");\n\tcapdnsloc = cap_service_open(capcas, \"system.dns\");\n\t/* Casper capability no longer needed. */\n\tcap_close(capcas);\n\tif (capdnsloc == NULL)\n\t\terror(\"unable to open system.dns service\");\n\t/* Limit system.dns to reverse DNS lookups. */\n\ttypes[0] = \"ADDR\";\n\tif (cap_dns_type_limit(capdnsloc, types, 1) < 0)\n\t\terror(\"unable to limit access to system.dns service\");\n\tfamilies[0] = AF_INET;\n\tfamilies[1] = AF_INET6;\n\tif (cap_dns_family_limit(capdnsloc, families, 2) < 0)\n\t\terror(\"unable to limit access to system.dns service\");\n\n\treturn (capdnsloc);\n}\n#endif\t/* HAVE_CASPER */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\nstatic int\ntstamp_precision_from_string(const char *precision)\n{\n\tif (strncmp(precision, \"nano\", strlen(\"nano\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_NANO;\n\n\tif (strncmp(precision, \"micro\", strlen(\"micro\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn -EINVAL;\n}\n\nstatic const char *\ntstamp_precision_to_string(int precision)\n{\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\treturn \"micro\";\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\treturn \"nano\";\n\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n#endif\n\n#ifdef HAVE_CAPSICUM\n/*\n * Ensure that, on a dump file's descriptor, we have all the rights\n * necessary to make the standard I/O library work with an fdopen()ed\n * FILE * from that descriptor.\n *\n * A long time ago in a galaxy far, far away, AT&T decided that, instead\n * of providing separate APIs for getting and setting the FD_ flags on a\n * descriptor, getting and setting the O_ flags on a descriptor, and\n * locking files, they'd throw them all into a kitchen-sink fcntl() call\n * along the lines of ioctl(), the fact that ioctl() operations are\n * largely specific to particular character devices but fcntl() operations\n * are either generic to all descriptors or generic to all descriptors for\n * regular files nonwithstanding.\n *\n * The Capsicum people decided that fine-grained control of descriptor\n * operations was required, so that you need to grant permission for\n * reading, writing, seeking, and fcntl-ing.  The latter, courtesy of\n * AT&T's decision, means that \"fcntl-ing\" isn't a thing, but a motley\n * collection of things, so there are *individual* fcntls for which\n * permission needs to be granted.\n *\n * The FreeBSD standard I/O people implemented some optimizations that\n * requires that the standard I/O routines be able to determine whether\n * the descriptor for the FILE * is open append-only or not; as that\n * descriptor could have come from an open() rather than an fopen(),\n * that requires that it be able to do an F_GETFL fcntl() to read\n * the O_ flags.\n *\n * Tcpdump uses ftell() to determine how much data has been written\n * to a file in order to, when used with -C, determine when it's time\n * to rotate capture files.  ftell() therefore needs to do an lseek()\n * to find out the file offset and must, thanks to the aforementioned\n * optimization, also know whether the descriptor is open append-only\n * or not.\n *\n * The net result of all the above is that we need to grant CAP_SEEK,\n * CAP_WRITE, and CAP_FCNTL with the CAP_FCNTL_GETFL subcapability.\n *\n * Perhaps this is the universe's way of saying that either\n *\n *\t1) there needs to be an fopenat() call and a pcap_dump_openat() call\n *\t   using it, so that Capsicum-capable tcpdump wouldn't need to do\n *\t   an fdopen()\n *\n * or\n *\n *\t2) there needs to be a cap_fdopen() call in the FreeBSD standard\n *\t   I/O library that knows what rights are needed by the standard\n *\t   I/O library, based on the open mode, and assigns them, perhaps\n *\t   with an additional argument indicating, for example, whether\n *\t   seeking should be allowed, so that tcpdump doesn't need to know\n *\t   what the standard I/O library happens to require this week.\n */\nstatic void\nset_dumper_capsicum_rights(pcap_dumper_t *p)\n{\n\tint fd = fileno(pcap_dump_file(p));\n\tcap_rights_t rights;\n\n\tcap_rights_init(&rights, CAP_SEEK, CAP_WRITE, CAP_FCNTL);\n\tif (cap_rights_limit(fd, &rights) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor\");\n\t}\n\tif (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor fcntls\");\n\t}\n}\n#endif\n\n/*\n * Copy arg vector into a new buffer, concatenating arguments with spaces.\n */\nstatic char *\ncopy_argv(char **argv)\n{\n\tchar **p;\n\tsize_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == NULL)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"%s: malloc\", __func__);\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}\n\n/*\n * On Windows, we need to open the file in binary mode, so that\n * we get all the bytes specified by the size we get from \"fstat()\".\n * On UNIX, that's not necessary.  O_BINARY is defined on Windows;\n * we define it as 0 if it's not defined, so it does nothing.\n */\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\nstatic char *\nread_infile(char *fname)\n{\n\tint i, fd;\n\tssize_t cc;\n\tchar *cp;\n\tour_statb buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (our_fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\t/*\n\t * Reject files whose size doesn't fit into an int; a filter\n\t * *that* large will probably be too big.\n\t */\n\tif (buf.st_size > INT_MAX)\n\t\terror(\"%s is too large\", fname);\n\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, (int) cc,\n\t\t    (int)buf.st_size);\n\n\tclose(fd);\n\t/* replace \"# comment\" with spaces */\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic long\nparse_interface_number(const char *device)\n{\n\tconst char *p;\n\tlong devnum;\n\tchar *end;\n\n\t/*\n\t * Search for a colon, terminating any scheme at the beginning\n\t * of the device.\n\t */\n\tp = strchr(device, ':');\n\tif (p != NULL) {\n\t\t/*\n\t\t * We found it.  Is it followed by \"//\"?\n\t\t */\n\t\tp++;\t/* skip the : */\n\t\tif (strncmp(p, \"//\", 2) == 0) {\n\t\t\t/*\n\t\t\t * Yes.  Search for the next /, at the end of the\n\t\t\t * authority part of the URL.\n\t\t\t */\n\t\t\tp += 2;\t/* skip the // */\n\t\t\tp = strchr(p, '/');\n\t\t\tif (p != NULL) {\n\t\t\t\t/*\n\t\t\t\t * OK, past the / is the path.\n\t\t\t\t */\n\t\t\t\tdevice = p + 1;\n\t\t\t}\n\t\t}\n\t}\n\tdevnum = strtol(device, &end, 10);\n\tif (device != end && *end == '\\0') {\n\t\t/*\n\t\t * It's all-numeric, but is it a valid number?\n\t\t */\n\t\tif (devnum <= 0) {\n\t\t\t/*\n\t\t\t * No, it's not an ordinal.\n\t\t\t */\n\t\t\terror(\"Invalid adapter index\");\n\t\t}\n\t\treturn (devnum);\n\t} else {\n\t\t/*\n\t\t * It's not all-numeric; return -1, so our caller\n\t\t * knows that.\n\t\t */\n\t\treturn (-1);\n\t}\n}\n\nstatic char *\nfind_interface_by_number(const char *url\n#ifndef HAVE_PCAP_FINDALLDEVS_EX\n_U_\n#endif\n, long devnum)\n{\n\tpcap_if_t *dev, *devlist;\n\tlong i;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar *device;\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\tconst char *endp;\n\tchar *host_url;\n#endif\n\tint status;\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t/*\n\t * Search for a colon, terminating any scheme at the beginning\n\t * of the URL.\n\t */\n\tendp = strchr(url, ':');\n\tif (endp != NULL) {\n\t\t/*\n\t\t * We found it.  Is it followed by \"//\"?\n\t\t */\n\t\tendp++;\t/* skip the : */\n\t\tif (strncmp(endp, \"//\", 2) == 0) {\n\t\t\t/*\n\t\t\t * Yes.  Search for the next /, at the end of the\n\t\t\t * authority part of the URL.\n\t\t\t */\n\t\t\tendp += 2;\t/* skip the // */\n\t\t\tendp = strchr(endp, '/');\n\t\t} else\n\t\t\tendp = NULL;\n\t}\n\tif (endp != NULL) {\n\t\t/*\n\t\t * OK, everything from device to endp is a URL to hand\n\t\t * to pcap_findalldevs_ex().\n\t\t */\n\t\tendp++;\t/* Include the trailing / in the URL; pcap_findalldevs_ex() requires it */\n\t\thost_url = malloc(endp - url + 1);\n\t\tif (host_url == NULL && (endp - url + 1) > 0)\n\t\t\terror(\"Invalid allocation for host\");\n\n\t\tmemcpy(host_url, url, endp - url);\n\t\thost_url[endp - url] = '\\0';\n\t\tstatus = pcap_findalldevs_ex(host_url, NULL, &devlist, ebuf);\n\t\tfree(host_url);\n\t} else\n#endif\n\tstatus = pcap_findalldevs(&devlist, ebuf);\n\tif (status < 0)\n\t\terror(\"%s\", ebuf);\n\t/*\n\t * Look for the devnum-th entry in the list of devices (1-based).\n\t */\n\tfor (i = 0, dev = devlist; i < devnum-1 && dev != NULL;\n\t    i++, dev = dev->next)\n\t\t;\n\tif (dev == NULL)\n\t\terror(\"Invalid adapter index\");\n\tdevice = strdup(dev->name);\n\tpcap_freealldevs(devlist);\n\treturn (device);\n}\n#endif\n\n#ifdef HAVE_PCAP_OPEN\n/*\n * Prefixes for rpcap URLs.\n */\nstatic char rpcap_prefix[] = \"rpcap://\";\nstatic char rpcap_ssl_prefix[] = \"rpcaps://\";\n#endif\n\nstatic pcap_t *\nopen_interface(const char *device, netdissect_options *ndo, char *ebuf)\n{\n\tpcap_t *pc;\n#ifdef HAVE_PCAP_CREATE\n\tint status;\n\tchar *cp;\n#endif\n\n#ifdef HAVE_PCAP_OPEN\n\t/*\n\t * Is this an rpcap URL?\n\t */\n\tif (strncmp(device, rpcap_prefix, sizeof(rpcap_prefix) - 1) == 0 ||\n\t    strncmp(device, rpcap_ssl_prefix, sizeof(rpcap_ssl_prefix) - 1) == 0) {\n\t\t/*\n\t\t * Yes.  Open it with pcap_open().\n\t\t */\n\t\t*ebuf = '\\0';\n\t\tpc = pcap_open(device, ndo->ndo_snaplen,\n\t\t    pflag ? 0 : PCAP_OPENFLAG_PROMISCUOUS, timeout, NULL,\n\t\t    ebuf);\n\t\tif (pc == NULL) {\n\t\t\t/*\n\t\t\t * If this failed with \"No such device\" or \"The system\n\t\t\t * cannot find the device specified\", that means\n\t\t\t * the interface doesn't exist; return NULL, so that\n\t\t\t * the caller can see whether the device name is\n\t\t\t * actually an interface index.\n\t\t\t */\n\t\t\tif (strstr(ebuf, \"No such device\") != NULL ||\n\t\t\t    strstr(ebuf, \"The system cannot find the device specified\") != NULL)\n\t\t\t\treturn (NULL);\n\t\t\terror(\"%s\", ebuf);\n\t\t}\n\t\tif (*ebuf)\n\t\t\twarning(\"%s\", ebuf);\n\t\treturn (pc);\n\t}\n#endif /* HAVE_PCAP_OPEN */\n\n#ifdef HAVE_PCAP_CREATE\n\tpc = pcap_create(device, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (Jflag)\n\t\tshow_tstamp_types_and_exit(pc, device);\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tstatus = pcap_set_tstamp_precision(pc, ndo->ndo_tstamp_precision);\n\tif (status != 0)\n\t\terror(\"%s: Can't set %ssecond time stamp precision: %s\",\n\t\t    device,\n\t\t    tstamp_precision_to_string(ndo->ndo_tstamp_precision),\n\t\t    pcap_statustostr(status));\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\tif (immediate_mode) {\n\t\tstatus = pcap_set_immediate_mode(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set immediate mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#endif\n\t/*\n\t * Is this an interface that supports monitor mode?\n\t */\n\tif (pcap_can_set_rfmon(pc) == 1)\n\t\tsupports_monitor_mode = 1;\n\telse\n\t\tsupports_monitor_mode = 0;\n\tif (ndo->ndo_snaplen != 0) {\n\t\t/*\n\t\t * A snapshot length was explicitly specified;\n\t\t * use it.\n\t\t */\n\t\tstatus = pcap_set_snaplen(pc, ndo->ndo_snaplen);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set snapshot length: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_promisc(pc, !pflag);\n\tif (status != 0)\n\t\terror(\"%s: Can't set promiscuous mode: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Iflag) {\n\t\tstatus = pcap_set_rfmon(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set monitor mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pc, timeout);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Bflag != 0) {\n\t\tstatus = pcap_set_buffer_size(pc, Bflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set buffer size: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (jflag != -1) {\n\t\tstatus = pcap_set_tstamp_type(pc, jflag);\n\t\tif (status < 0)\n\t\t\terror(\"%s: Can't set time stamp type: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\telse if (status > 0)\n\t\t\twarning(\"When trying to set timestamp type '%s' on %s: %s\",\n\t\t\t    pcap_tstamp_type_val_to_name(jflag), device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#endif\n\tstatus = pcap_activate(pc);\n\tif (status < 0) {\n\t\t/*\n\t\t * pcap_activate() failed.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_ERROR)\n\t\t\terror(\"%s\", cp);\n\t\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Return an error for our caller to handle.\n\t\t\t */\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s: %s\\n(%s)\",\n\t\t\t    device, pcap_statustostr(status), cp);\n\t\t} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\\0')\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n#ifdef __FreeBSD__\n\t\telse if (status == PCAP_ERROR_RFMON_NOTSUP &&\n\t\t    strncmp(device, \"wlan\", 4) == 0) {\n\t\t\tchar parent[8], newdev[8];\n\t\t\tchar sysctl[32];\n\t\t\tsize_t s = sizeof(parent);\n\n\t\t\tsnprintf(sysctl, sizeof(sysctl),\n\t\t\t    \"net.wlan.%d.%%parent\", atoi(device + 4));\n\t\t\tsysctlbyname(sysctl, parent, &s, NULL, 0);\n\t\t\tstrlcpy(newdev, device, sizeof(newdev));\n\t\t\t/* Suggest a new wlan device. */\n\t\t\t/* FIXME: incrementing the index this way is not going to work well\n\t\t\t * when the index is 9 or greater but the only consequence in this\n\t\t\t * specific case would be an error message that looks a bit odd.\n\t\t\t */\n\t\t\tnewdev[strlen(newdev)-1]++;\n\t\t\terror(\"%s is not a monitor mode VAP\\n\"\n\t\t\t    \"To create a new monitor mode VAP use:\\n\"\n\t\t\t    \"  ifconfig %s create wlandev %s wlanmode monitor\\n\"\n\t\t\t    \"and use %s as the tcpdump interface\",\n\t\t\t    device, newdev, parent, newdev);\n\t\t}\n#endif\n\t\telse\n\t\t\terror(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t\tpcap_close(pc);\n\t\treturn (NULL);\n\t} else if (status > 0) {\n\t\t/*\n\t\t * pcap_activate() succeeded, but it's warning us\n\t\t * of a problem it had.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_WARNING)\n\t\t\twarning(\"%s\", cp);\n\t\telse if (status == PCAP_WARNING_PROMISC_NOTSUP &&\n\t\t         *cp != '\\0')\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\twarning(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SETDIRECTION\n\tif (Qflag != -1) {\n\t\tstatus = pcap_setdirection(pc, Qflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_setdirection() failed: %s\",\n\t\t\t      device,  pcap_geterr(pc));\n\t\t}\n#endif /* HAVE_PCAP_SETDIRECTION */\n#else /* HAVE_PCAP_CREATE */\n\t*ebuf = '\\0';\n\t/*\n\t * If no snapshot length was specified, or a length of 0 was\n\t * specified, default to 256KB.\n\t */\n\tif (ndo->ndo_snaplen == 0)\n\t\tndo->ndo_snaplen = MAXIMUM_SNAPLEN;\n\tpc = pcap_open_live(device, ndo->ndo_snaplen, !pflag, timeout, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n\tif (*ebuf)\n\t\twarning(\"%s\", ebuf);\n#endif /* HAVE_PCAP_CREATE */\n\n\treturn (pc);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint cnt, op, i;\n\tbpf_u_int32 localnet = 0, netmask = 0;\n\tchar *cp, *infile, *cmdbuf, *device, *RFileName, *VFileName, *WFileName;\n\tchar *endp;\n\tpcap_handler callback;\n\tint dlt;\n\tconst char *dlt_name;\n\tstruct bpf_program fcode;\n#ifndef _WIN32\n\tvoid (*oldhandler)(int);\n#endif\n\tstruct dump_info dumpinfo;\n\tu_char *pcap_userdata;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar VFileLine[PATH_MAX + 1];\n\tconst char *username = NULL;\n#ifndef _WIN32\n\tconst char *chroot_dir = NULL;\n#endif\n\tchar *ret = NULL;\n\tchar *end;\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tpcap_if_t *devlist;\n\tlong devnum;\n#endif\n\tint status;\n\tFILE *VFile;\n#ifdef HAVE_CAPSICUM\n\tcap_rights_t rights;\n\tint cansandbox;\n#endif\t/* HAVE_CAPSICUM */\n\tint Oflag = 1;\t\t\t/* run filter code optimizer */\n\tint yflag_dlt = -1;\n\tconst char *yflag_dlt_name = NULL;\n\tint print = 0;\n\n\tnetdissect_options Ndo;\n\tnetdissect_options *ndo = &Ndo;\n\n\t/*\n\t * Initialize the netdissect code.\n\t */\n\tif (nd_init(ebuf, sizeof(ebuf)) == -1)\n\t\terror(\"%s\", ebuf);\n\n\tmemset(ndo, 0, sizeof(*ndo));\n\tndo_set_function_pointers(ndo);\n\n\tcnt = -1;\n\tdevice = NULL;\n\tinfile = NULL;\n\tRFileName = NULL;\n\tVFileName = NULL;\n\tVFile = NULL;\n\tWFileName = NULL;\n\tdlt = -1;\n\tif ((cp = strrchr(argv[0], PATH_SEPARATOR)) != NULL)\n\t\tndo->program_name = program_name = cp + 1;\n\telse\n\t\tndo->program_name = program_name = argv[0];\n\n#if defined(HAVE_PCAP_WSOCKINIT)\n\tif (pcap_wsockinit() != 0)\n\t\terror(\"Attempting to initialize Winsock failed\");\n#elif defined(HAVE_WSOCKINIT)\n\tif (wsockinit() != 0)\n\t\terror(\"Attempting to initialize Winsock failed\");\n#endif\n\n\t/*\n\t * On platforms where the CPU doesn't support unaligned loads,\n\t * force unaligned accesses to abort with SIGBUS, rather than\n\t * being fixed up (slowly) by the OS kernel; on those platforms,\n\t * misaligned accesses are bugs, and we want tcpdump to crash so\n\t * that the bugs are reported.\n\t */\n\tif (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)\n\t\terror(\"%s\", ebuf);\n\n\twhile (\n\t    (op = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != -1)\n\t\tswitch (op) {\n\n\t\tcase 'a':\n\t\t\t/* compatibility for old -a */\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t\t++ndo->ndo_Aflag;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\t++ndo->ndo_bflag;\n\t\t\tbreak;\n\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t\tcase 'B':\n\t\t\tBflag = atoi(optarg)*1024;\n\t\t\tif (Bflag <= 0)\n\t\t\t\terror(\"invalid packet buffer size %s\", optarg);\n\t\t\tbreak;\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n\t\tcase 'c':\n\t\t\tcnt = atoi(optarg);\n\t\t\tif (cnt <= 0)\n\t\t\t\terror(\"invalid packet count %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\terrno = 0;\n#ifdef HAVE_PCAP_DUMP_FTELL64\n\t\t\tCflag = strtoint64_t(optarg, &endp, 10);\n#else\n\t\t\tCflag = strtol(optarg, &endp, 10);\n#endif\n\t\t\tif (endp == optarg || *endp != '\\0' || errno != 0\n\t\t\t    || Cflag <= 0)\n\t\t\t\terror(\"invalid file size %s\", optarg);\n\t\t\t/*\n\t\t\t * Will multiplying it by 1000000 overflow?\n\t\t\t */\n#ifdef HAVE_PCAP_DUMP_FTELL64\n\t\t\tif (Cflag > INT64_T_CONSTANT(0x7fffffffffffffff) / 1000000)\n#else\n\t\t\tif (Cflag > LONG_MAX / 1000000)\n#endif\n\t\t\t\terror(\"file size %s is too large\", optarg);\n\t\t\tCflag *= 1000000;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\t++dflag;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\tcase 'D':\n\t\t\tDflag++;\n\t\t\tbreak;\n#endif\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t\tcase OPTION_LIST_REMOTE_INTERFACES:\n\t\t\tremote_interfaces_source = optarg;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'L':\n\t\t\tLflag++;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\t++ndo->ndo_eflag;\n\t\t\tbreak;\n\n\t\tcase 'E':\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_espsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\t++ndo->ndo_fflag;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'G':\n\t\t\tGflag = atoi(optarg);\n\t\t\tif (Gflag < 0)\n\t\t\t\terror(\"invalid number of seconds %s\", optarg);\n\n                        /* We will create one file initially. */\n                        Gflag_count = 0;\n\n\t\t\t/* Grab the current time for rotation use. */\n\t\t\tif ((Gflag_time = time(NULL)) == (time_t)-1) {\n\t\t\t\terror(\"%s: can't get current time: %s\",\n\t\t\t\t    __func__, pcap_strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tprint_usage(stdout);\n\t\t\texit_tcpdump(S_SUCCESS);\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\t++ndo->ndo_Hflag;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_CREATE\n\t\tcase 'I':\n\t\t\t++Iflag;\n\t\t\tbreak;\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t\tcase 'j':\n\t\t\tjflag = pcap_tstamp_type_name_to_val(optarg);\n\t\t\tif (jflag < 0)\n\t\t\t\terror(\"invalid time stamp type %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'J':\n\t\t\tJflag++;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'l':\n#ifdef _WIN32\n\t\t\t/*\n\t\t\t * _IOLBF is the same as _IOFBF in Microsoft's C\n\t\t\t * libraries; the only alternative they offer\n\t\t\t * is _IONBF.\n\t\t\t *\n\t\t\t * XXX - this should really be checking for MSVC++,\n\t\t\t * not _WIN32, if, for example, MinGW has its own\n\t\t\t * C library that is more UNIX-compatible.\n\t\t\t */\n\t\t\tsetvbuf(stdout, NULL, _IONBF, 0);\n#else /* _WIN32 */\n#ifdef HAVE_SETLINEBUF\n\t\t\tsetlinebuf(stdout);\n#else\n\t\t\tsetvbuf(stdout, NULL, _IOLBF, 0);\n#endif\n#endif /* _WIN32 */\n\t\t\tlflag = 1;\n\t\t\tbreak;\n\n\t\tcase 'K':\n\t\t\t++ndo->ndo_Kflag;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (nd_have_smi_support()) {\n\t\t\t\tif (nd_load_smi_module(optarg, ebuf, sizeof(ebuf)) == -1)\n\t\t\t\t\terror(\"%s\", ebuf);\n\t\t\t} else {\n\t\t\t\t(void)fprintf(stderr, \"%s: ignoring option `-m %s' \",\n\t\t\t\t\t      program_name, optarg);\n\t\t\t\t(void)fprintf(stderr, \"(no libsmi support)\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\t/* TCP-MD5 shared secret */\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_sigsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\t++ndo->ndo_nflag;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\t++ndo->ndo_Nflag;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tOflag = 0;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t++pflag;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\t++ndo->ndo_qflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SETDIRECTION\n\t\tcase 'Q':\n\t\t\tif (ascii_strcasecmp(optarg, \"in\") == 0)\n\t\t\t\tQflag = PCAP_D_IN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"out\") == 0)\n\t\t\t\tQflag = PCAP_D_OUT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"inout\") == 0)\n\t\t\t\tQflag = PCAP_D_INOUT;\n\t\t\telse\n\t\t\t\terror(\"unknown capture direction `%s'\", optarg);\n\t\t\tbreak;\n#endif /* HAVE_PCAP_SETDIRECTION */\n\n\t\tcase 'r':\n\t\t\tRFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tndo->ndo_snaplen = (int)strtol(optarg, &end, 0);\n\t\t\tif (optarg == end || *end != '\\0'\n\t\t\t    || ndo->ndo_snaplen < 0 || ndo->ndo_snaplen > MAXIMUM_SNAPLEN)\n\t\t\t\terror(\"invalid snaplen %s (must be >= 0 and <= %d)\",\n\t\t\t\t      optarg, MAXIMUM_SNAPLEN);\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t++ndo->ndo_Sflag;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t++ndo->ndo_tflag;\n\t\t\tbreak;\n\n\t\tcase 'T':\n\t\t\tif (ascii_strcasecmp(optarg, \"vat\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VAT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"wb\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_WB;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rpc\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RPC;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtcp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTCP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"snmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_SNMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"cnfp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CNFP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"tftp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_TFTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"aodv\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_AODV;\n\t\t\telse if (ascii_strcasecmp(optarg, \"carp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CARP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"radius\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RADIUS;\n\t\t\telse if (ascii_strcasecmp(optarg, \"zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"vxlan\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VXLAN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm_zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"lmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_LMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"resp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RESP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"ptp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"someip\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_SOMEIP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"domain\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_DOMAIN;\n\t\t\telse\n\t\t\t\terror(\"unknown packet type `%s'\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t\t++ndo->ndo_uflag;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tcase 'U':\n\t\t\t++Uflag;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'v':\n\t\t\t++ndo->ndo_vflag;\n\t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tVFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tWFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'W':\n\t\t\tWflag = atoi(optarg);\n\t\t\tif (Wflag <= 0)\n\t\t\t\terror(\"invalid number of output files %s\", optarg);\n\t\t\tWflagChars = getWflagChars(Wflag);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\t++ndo->ndo_xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\t++ndo->ndo_Xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tyflag_dlt_name = optarg;\n\t\t\tyflag_dlt =\n\t\t\t\tpcap_datalink_name_to_val(yflag_dlt_name);\n\t\t\tif (yflag_dlt < 0)\n\t\t\t\terror(\"invalid data link type %s\", yflag_dlt_name);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t\tcase 'Y':\n\t\t\t{\n\t\t\t/* Undocumented flag */\n\t\t\tpcap_set_parser_debug(1);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tcase 'z':\n\t\t\tzflag = optarg;\n\t\t\tbreak;\n\n\t\tcase 'Z':\n\t\t\tusername = optarg;\n\t\t\tbreak;\n\n\t\tcase '#':\n\t\t\tndo->ndo_packet_number = 1;\n\t\t\tbreak;\n\n\t\tcase OPTION_VERSION:\n\t\t\tprint_version(stdout);\n\t\t\texit_tcpdump(S_SUCCESS);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tcase OPTION_TSTAMP_PRECISION:\n\t\t\tndo->ndo_tstamp_precision = tstamp_precision_from_string(optarg);\n\t\t\tif (ndo->ndo_tstamp_precision < 0)\n\t\t\t\terror(\"unsupported time stamp precision\");\n\t\t\tbreak;\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t\tcase OPTION_IMMEDIATE_MODE:\n\t\t\timmediate_mode = 1;\n\t\t\tbreak;\n#endif\n\n\t\tcase OPTION_PRINT:\n\t\t\tprint = 1;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tcase OPTION_TSTAMP_MICRO:\n\t\t\tndo->ndo_tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\t\t\tbreak;\n\n\t\tcase OPTION_TSTAMP_NANO:\n\t\t\tndo->ndo_tstamp_precision = PCAP_TSTAMP_PRECISION_NANO;\n\t\t\tbreak;\n#endif\n\n\t\tcase OPTION_FP_TYPE:\n\t\t\t/*\n\t\t\t * Print out the type of floating-point arithmetic\n\t\t\t * we're doing; it's probably IEEE, unless somebody\n\t\t\t * tries to run this on a VAX, but the precision\n\t\t\t * may differ (e.g., it might be 32-bit, 64-bit,\n\t\t\t * or 80-bit).\n\t\t\t */\n\t\t\tfloat_type_check(0x4e93312d);\n\t\t\treturn 0;\n\n\t\tcase OPTION_COUNT:\n\t\t\tcount_mode = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprint_usage(stderr);\n\t\t\texit_tcpdump(S_ERR_HOST_PROGRAM);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tif (Dflag)\n\t\tshow_devices_and_exit();\n#endif\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\tif (remote_interfaces_source != NULL)\n\t\tshow_remote_devices_and_exit();\n#endif\n\n#if defined(DLT_LINUX_SLL2) && defined(HAVE_PCAP_SET_DATALINK)\n/* Set default linktype DLT_LINUX_SLL2 when capturing on the \"any\" device */\n\t\tif (device != NULL &&\n\t\t    strncmp (device, \"any\", strlen(\"any\")) == 0\n\t\t    && yflag_dlt == -1)\n\t\t\tyflag_dlt = DLT_LINUX_SLL2;\n#endif\n\n\tswitch (ndo->ndo_tflag) {\n\n\tcase 0: /* Default */\n\tcase 1: /* No time stamp */\n\tcase 2: /* Unix timeval style */\n\tcase 3: /* Microseconds/nanoseconds since previous packet */\n\tcase 4: /* Date + Default */\n\tcase 5: /* Microseconds/nanoseconds since first packet */\n\t\tbreak;\n\n\tdefault: /* Not supported */\n\t\terror(\"only -t, -tt, -ttt, -tttt and -ttttt are supported\");\n\t\tbreak;\n\t}\n\n\tif (ndo->ndo_fflag != 0 && (VFileName != NULL || RFileName != NULL))\n\t\terror(\"-f can not be used with -V or -r\");\n\n\tif (VFileName != NULL && RFileName != NULL)\n\t\terror(\"-V and -r are mutually exclusive.\");\n\n\t/*\n\t * If we're printing dissected packets to the standard output,\n\t * and either the standard output is a terminal or we're doing\n\t * \"line\" buffering, set the capture timeout to .1 second rather\n\t * than 1 second, as the user's probably expecting to see packets\n\t * pop up immediately shortly after they arrive.\n\t *\n\t * XXX - would there be some value appropriate for all cases,\n\t * based on, say, the buffer size and packet input rate?\n\t */\n\tif ((WFileName == NULL || print) && (isatty(1) || lflag))\n\t\ttimeout = 100;\n\n#ifdef WITH_CHROOT\n\t/* if run as root, prepare for chrooting */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* future extensibility for cmd-line arguments */\n\t\tif (!chroot_dir)\n\t\t\tchroot_dir = WITH_CHROOT;\n\t}\n#endif\n\n#ifdef WITH_USER\n\t/* if run as root, prepare for dropping root privileges */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* Run with '-Z root' to restore old behaviour */\n\t\tif (!username)\n\t\t\tusername = WITH_USER;\n\t}\n#endif\n\n\tif (RFileName != NULL || VFileName != NULL) {\n\t\t/*\n\t\t * If RFileName is non-null, it's the pathname of a\n\t\t * savefile to read.  If VFileName is non-null, it's\n\t\t * the pathname of a file containing a list of pathnames\n\t\t * (one per line) of savefiles to read.\n\t\t *\n\t\t * In either case, we're reading a savefile, not doing\n\t\t * a live capture.\n\t\t */\n#ifndef _WIN32\n\t\t/*\n\t\t * We don't need network access, so relinquish any set-UID\n\t\t * or set-GID privileges we have (if any).\n\t\t *\n\t\t * We do *not* want set-UID privileges when opening a\n\t\t * trace file, as that might let the user read other\n\t\t * people's trace files (especially if we're set-UID\n\t\t * root).\n\t\t */\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0 )\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n\t\tif (VFileName != NULL) {\n\t\t\tif (VFileName[0] == '-' && VFileName[1] == '\\0')\n\t\t\t\tVFile = stdin;\n\t\t\telse\n\t\t\t\tVFile = fopen(VFileName, \"r\");\n\n\t\t\tif (VFile == NULL)\n\t\t\t\terror(\"Unable to open file: %s\\n\", pcap_strerror(errno));\n\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (!ret)\n\t\t\t\terror(\"Nothing in %s\\n\", VFileName);\n\t\t\tRFileName = VFileLine;\n\t\t}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tpd = pcap_open_offline_with_tstamp_precision(RFileName,\n\t\t    ndo->ndo_tstamp_precision, ebuf);\n#else\n\t\tpd = pcap_open_offline(RFileName, ebuf);\n#endif\n\n\t\tif (pd == NULL)\n\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\tcap_rights_init(&rights, CAP_READ);\n\t\tif (cap_rights_limit(fileno(pcap_file(pd)), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n#endif\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\tfprintf(stderr, \"reading from file %s\", RFileName);\n\t\tif (dlt_name == NULL) {\n\t\t\tfprintf(stderr, \", link-type %u\", dlt);\n\t\t} else {\n\t\t\tfprintf(stderr, \", link-type %s (%s)\", dlt_name,\n\t\t\t\tpcap_datalink_val_to_description(dlt));\n\t\t}\n\t\tfprintf(stderr, \", snapshot length %d\\n\", pcap_snapshot(pd));\n#ifdef DLT_LINUX_SLL2\n\t\tif (dlt == DLT_LINUX_SLL2)\n\t\t\tfprintf(stderr, \"Warning: interface names might be incorrect\\n\");\n#endif\n\t} else if (dflag && !device) {\n\t\tint dump_dlt = DLT_EN10MB;\n\t\t/*\n\t\t * We're dumping the compiled code without an explicit\n\t\t * device specification.  (If a device is specified, we\n\t\t * definitely want to open it to use the DLT of that device.)\n\t\t * Either default to DLT_EN10MB with a warning, or use\n\t\t * the user-specified value if supplied.\n\t\t */\n\t\t/*\n\t\t * If no snapshot length was specified, or a length of 0 was\n\t\t * specified, default to 256KB.\n\t\t */\n\t\tif (ndo->ndo_snaplen == 0)\n\t\t\tndo->ndo_snaplen = MAXIMUM_SNAPLEN;\n\t\t/*\n\t\t * If a DLT was specified with the -y flag, use that instead.\n\t\t */\n\t\tif (yflag_dlt != -1)\n\t\t\tdump_dlt = yflag_dlt;\n\t\telse\n\t\t\tfprintf(stderr, \"Warning: assuming Ethernet\\n\");\n\t        pd = pcap_open_dead(dump_dlt, ndo->ndo_snaplen);\n\t} else {\n\t\t/*\n\t\t * We're doing a live capture.\n\t\t */\n\t\tif (device == NULL) {\n\t\t\t/*\n\t\t\t * No interface was specified.  Pick one.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\t/*\n\t\t\t * Find the list of interfaces, and pick\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\t\terror(\"%s\", ebuf);\n\t\t\tif (devlist == NULL)\n\t\t\t\terror(\"no interfaces available for capture\");\n\t\t\tdevice = strdup(devlist->name);\n\t\t\tpcap_freealldevs(devlist);\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * Use whatever interface pcap_lookupdev()\n\t\t\t * chooses.\n\t\t\t */\n\t\t\tdevice = pcap_lookupdev(ebuf);\n\t\t\tif (device == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Try to open the interface with the specified name.\n\t\t */\n\t\tpd = open_interface(device, ndo, ebuf);\n\t\tif (pd == NULL) {\n\t\t\t/*\n\t\t\t * That failed.  If we can get a list of\n\t\t\t * interfaces, and the interface name\n\t\t\t * is purely numeric, try to use it as\n\t\t\t * a 1-based index in the list of\n\t\t\t * interfaces.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\tdevnum = parse_interface_number(device);\n\t\t\tif (devnum == -1) {\n\t\t\t\t/*\n\t\t\t\t * It's not a number; just report\n\t\t\t\t * the open error and fail.\n\t\t\t\t */\n\t\t\t\terror(\"%s\", ebuf);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, it's a number; try to find the\n\t\t\t * interface with that index, and try\n\t\t\t * to open it.\n\t\t\t *\n\t\t\t * find_interface_by_number() exits if it\n\t\t\t * couldn't be found.\n\t\t\t */\n\t\t\tdevice = find_interface_by_number(device, devnum);\n\t\t\tpd = open_interface(device, ndo, ebuf);\n\t\t\tif (pd == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * We can't get a list of interfaces; just\n\t\t\t * fail.\n\t\t\t */\n\t\t\terror(\"%s\", ebuf);\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\t\t}\n\n\t\t/*\n\t\t * Let user own process after capture device has\n\t\t * been opened.\n\t\t */\n#ifndef _WIN32\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0)\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n#if !defined(HAVE_PCAP_CREATE) && defined(_WIN32)\n\t\tif(Bflag != 0)\n\t\t\tif(pcap_setbuff(pd, Bflag)==-1){\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t}\n#endif /* !defined(HAVE_PCAP_CREATE) && defined(_WIN32) */\n\t\tif (Lflag)\n\t\t\tshow_dlts_and_exit(pd, device);\n\t\tif (yflag_dlt >= 0) {\n#ifdef HAVE_PCAP_SET_DATALINK\n\t\t\tif (pcap_set_datalink(pd, yflag_dlt) < 0)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#else\n\t\t\t/*\n\t\t\t * We don't actually support changing the\n\t\t\t * data link type, so we only let them\n\t\t\t * set it to what it already is.\n\t\t\t */\n\t\t\tif (yflag_dlt != pcap_datalink(pd)) {\n\t\t\t\terror(\"%s is not one of the DLTs supported by this device\\n\",\n\t\t\t\t      yflag_dlt_name);\n\t\t\t}\n#endif\n\t\t\t(void)fprintf(stderr, \"%s: data link type %s\\n\",\n\t\t\t\t      program_name,\n\t\t\t\t      pcap_datalink_val_to_name(yflag_dlt));\n\t\t\t(void)fflush(stderr);\n\t\t}\n\t\ti = pcap_snapshot(pd);\n\t\tif (ndo->ndo_snaplen < i) {\n\t\t\tif (ndo->ndo_snaplen != 0)\n\t\t\t\twarning(\"snaplen raised from %d to %d\", ndo->ndo_snaplen, i);\n\t\t\tndo->ndo_snaplen = i;\n\t\t} else if (ndo->ndo_snaplen > i) {\n\t\t\twarning(\"snaplen lowered from %d to %d\", ndo->ndo_snaplen, i);\n\t\t\tndo->ndo_snaplen = i;\n\t\t}\n                if(ndo->ndo_fflag != 0) {\n                        if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n                                warning(\"foreign (-f) flag used but: %s\", ebuf);\n                        }\n                }\n\n\t}\n\tif (infile)\n\t\tcmdbuf = read_infile(infile);\n\telse\n\t\tcmdbuf = copy_argv(&argv[optind]);\n\n#ifdef HAVE_PCAP_SET_OPTIMIZER_DEBUG\n\tpcap_set_optimizer_debug(dflag);\n#endif\n\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\tif (dflag) {\n\t\tbpf_dump(&fcode, dflag);\n\t\tpcap_close(pd);\n\t\tfree(cmdbuf);\n\t\tpcap_freecode(&fcode);\n\t\texit_tcpdump(S_SUCCESS);\n\t}\n\n#ifdef HAVE_CASPER\n\tif (!ndo->ndo_nflag)\n\t\tcapdns = capdns_setup();\n#endif\t/* HAVE_CASPER */\n\n\tinit_print(ndo, localnet, netmask);\n\n#ifndef _WIN32\n\t(void)setsignal(SIGPIPE, cleanup);\n\t(void)setsignal(SIGTERM, cleanup);\n#endif /* _WIN32 */\n\t(void)setsignal(SIGINT, cleanup);\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n\t(void)setsignal(SIGCHLD, child_cleanup);\n#endif\n\t/* Cooperate with nohup(1) */\n#ifndef _WIN32\n\tif ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)\n\t\t(void)setsignal(SIGHUP, oldhandler);\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\t/*\n\t * If a user name was specified with \"-Z\", attempt to switch to\n\t * that user's UID.  This would probably be used with sudo,\n\t * to allow tcpdump to be run in a special restricted\n\t * account (if you just want to allow users to open capture\n\t * devices, and can't just give users that permission,\n\t * you'd make tcpdump set-UID or set-GID).\n\t *\n\t * Tcpdump doesn't necessarily write only to one savefile;\n\t * the general only way to allow a -Z instance to write to\n\t * savefiles as the user under whose UID it's run, rather\n\t * than as the user specified with -Z, would thus be to switch\n\t * to the original user ID before opening a capture file and\n\t * then switch back to the -Z user ID after opening the savefile.\n\t * Switching to the -Z user ID only after opening the first\n\t * savefile doesn't handle the general case.\n\t */\n\n\tif (getuid() == 0 || geteuid() == 0) {\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Initialize capng */\n\t\tcapng_clear(CAPNG_SELECT_BOTH);\n\t\tif (username) {\nDIAG_OFF_ASSIGN_ENUM\n\t\t\tcapng_updatev(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SETUID,\n\t\t\t\tCAP_SETGID,\n\t\t\t\t-1);\nDIAG_ON_ASSIGN_ENUM\n\t\t}\n\t\tif (chroot_dir) {\nDIAG_OFF_ASSIGN_ENUM\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SYS_CHROOT\n\t\t\t\t);\nDIAG_ON_ASSIGN_ENUM\n\t\t}\n\n\t\tif (WFileName) {\nDIAG_OFF_ASSIGN_ENUM\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_DAC_OVERRIDE\n\t\t\t\t);\nDIAG_ON_ASSIGN_ENUM\n\t\t}\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (username || chroot_dir)\n\t\t\tdroproot(username, chroot_dir);\n\n\t}\n#endif /* _WIN32 */\n\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\tif (RFileName == NULL && VFileName == NULL && pcap_fileno(pd) != -1) {\n\t\tstatic const unsigned long cmds[] = { BIOCGSTATS, BIOCROTZBUF };\n\n\t\t/*\n\t\t * The various libpcap devices use a combination of\n\t\t * read (bpf), ioctl (bpf, netmap), poll (netmap)\n\t\t * so we add the relevant access rights.\n\t\t */\n\t\tcap_rights_init(&rights, CAP_IOCTL, CAP_READ, CAP_EVENT);\n\t\tif (cap_rights_limit(pcap_fileno(pd), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n\t\tif (cap_ioctls_limit(pcap_fileno(pd), cmds,\n\t\t    sizeof(cmds) / sizeof(cmds[0])) < 0 && errno != ENOSYS) {\n\t\t\terror(\"unable to limit ioctls on pcap descriptor\");\n\t\t}\n\t}\n#endif\n\tif (WFileName) {\n\t\t/* Do not exceed the default PATH_MAX for files. */\n\t\tdumpinfo.CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\n\t\tif (dumpinfo.CurrentFileName == NULL)\n\t\t\terror(\"malloc of dumpinfo.CurrentFileName\");\n\n\t\t/* We do not need numbering for dumpfiles if Cflag isn't set. */\n\t\tif (Cflag != 0)\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, WflagChars);\n\t\telse\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, 0);\n\n\t\tpdd = pcap_dump_open(pd, dumpinfo.CurrentFileName);\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Give up CAP_DAC_OVERRIDE capability.\n\t\t * Only allow it to be restored if the -C or -G flag have been\n\t\t * set since we may need to create more files later on.\n\t\t */\n\t\tcapng_update(\n\t\t\tCAPNG_DROP,\n\t\t\t(Cflag || Gflag ? 0 : CAPNG_PERMITTED)\n\t\t\t\t| CAPNG_EFFECTIVE,\n\t\t\tCAP_DAC_OVERRIDE\n\t\t\t);\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (pdd == NULL)\n\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\tset_dumper_capsicum_rights(pdd);\n#endif\n\t\tif (Cflag != 0 || Gflag != 0) {\n#ifdef HAVE_CAPSICUM\n\t\t\t/*\n\t\t\t * basename() and dirname() may modify their input buffer\n\t\t\t * and they do since FreeBSD 12.0, but they didn't before.\n\t\t\t * Hence use the return value only, but always assume the\n\t\t\t * input buffer has been modified and would need to be\n\t\t\t * reset before the next use.\n\t\t\t */\n\t\t\tchar *WFileName_copy;\n\n\t\t\tif ((WFileName_copy = strdup(WFileName)) == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tDIAG_OFF_C11_EXTENSIONS\n\t\t\tdumpinfo.WFileName = strdup(basename(WFileName_copy));\n\t\t\tDIAG_ON_C11_EXTENSIONS\n\t\t\tif (dumpinfo.WFileName == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tfree(WFileName_copy);\n\n\t\t\tif ((WFileName_copy = strdup(WFileName)) == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tDIAG_OFF_C11_EXTENSIONS\n\t\t\tchar *WFileName_dirname = dirname(WFileName_copy);\n\t\t\tDIAG_ON_C11_EXTENSIONS\n\t\t\tdumpinfo.dirfd = open(WFileName_dirname,\n\t\t\t    O_DIRECTORY | O_RDONLY);\n\t\t\tif (dumpinfo.dirfd < 0) {\n\t\t\t\terror(\"unable to open directory %s\",\n\t\t\t\t    WFileName_dirname);\n\t\t\t}\n\t\t\tfree(WFileName_dirname);\n\t\t\tfree(WFileName_copy);\n\n\t\t\tcap_rights_init(&rights, CAP_CREATE, CAP_FCNTL,\n\t\t\t    CAP_FTRUNCATE, CAP_LOOKUP, CAP_SEEK, CAP_WRITE);\n\t\t\tif (cap_rights_limit(dumpinfo.dirfd, &rights) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit directory rights\");\n\t\t\t}\n\t\t\tif (cap_fcntls_limit(dumpinfo.dirfd, CAP_FCNTL_GETFL) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit dump descriptor fcntls\");\n\t\t\t}\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdumpinfo.WFileName = WFileName;\n#endif\n\t\t\tcallback = dump_packet_and_trunc;\n\t\t\tdumpinfo.pd = pd;\n\t\t\tdumpinfo.pdd = pdd;\n\t\t\tpcap_userdata = (u_char *)&dumpinfo;\n\t\t} else {\n\t\t\tcallback = dump_packet;\n\t\t\tdumpinfo.WFileName = WFileName;\n\t\t\tdumpinfo.pd = pd;\n\t\t\tdumpinfo.pdd = pdd;\n\t\t\tpcap_userdata = (u_char *)&dumpinfo;\n\t\t}\n\t\tif (print) {\n\t\t\tdlt = pcap_datalink(pd);\n\t\t\tndo->ndo_if_printer = get_if_printer(dlt);\n\t\t\tdumpinfo.ndo = ndo;\n\t\t} else\n\t\t\tdumpinfo.ndo = NULL;\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tif (Uflag)\n\t\t\tpcap_dump_flush(pdd);\n#endif\n\t} else {\n\t\tdlt = pcap_datalink(pd);\n\t\tndo->ndo_if_printer = get_if_printer(dlt);\n\t\tcallback = print_packet;\n\t\tpcap_userdata = (u_char *)ndo;\n\t}\n\n#ifdef SIGNAL_REQ_INFO\n\t/*\n\t * We can't get statistics when reading from a file rather\n\t * than capturing from a device.\n\t */\n\tif (RFileName == NULL)\n\t\t(void)setsignal(SIGNAL_REQ_INFO, requestinfo);\n#endif\n#ifdef SIGNAL_FLUSH_PCAP\n\t(void)setsignal(SIGNAL_FLUSH_PCAP, flushpcap);\n#endif\n\n\tif (ndo->ndo_vflag > 0 && WFileName && RFileName == NULL && !print) {\n\t\t/*\n\t\t * When capturing to a file, if \"--print\" wasn't specified,\n\t\t *\"-v\" means tcpdump should, once per second,\n\t\t * \"v\"erbosely report the number of packets captured.\n\t\t * Except when reading from a file, because -r, -w and -v\n\t\t * together used to make a corner case, in which pcap_loop()\n\t\t * errored due to EINTR (see GH #155 for details).\n\t\t */\n#ifdef _WIN32\n\t\t/*\n\t\t * https://blogs.msdn.microsoft.com/oldnewthing/20151230-00/?p=92741\n\t\t *\n\t\t * suggests that this dates back to W2K.\n\t\t *\n\t\t * I don't know what a \"long wait\" is, but we'll assume\n\t\t * that printing the stats could be a \"long wait\".\n\t\t */\n\t\tCreateTimerQueueTimer(&timer_handle, NULL,\n\t\t    verbose_stats_dump, NULL, 1000, 1000,\n\t\t    WT_EXECUTEDEFAULT|WT_EXECUTELONGFUNCTION);\n\t\tsetvbuf(stderr, NULL, _IONBF, 0);\n#else /* _WIN32 */\n\t\t/*\n\t\t * Assume this is UN*X, and that it has setitimer(); that\n\t\t * dates back to UNIX 95.\n\t\t */\n\t\tstruct itimerval timer;\n\t\t(void)setsignal(SIGALRM, verbose_stats_dump);\n\t\ttimer.it_interval.tv_sec = 1;\n\t\ttimer.it_interval.tv_usec = 0;\n\t\ttimer.it_value.tv_sec = 1;\n\t\ttimer.it_value.tv_usec = 1;\n\t\tsetitimer(ITIMER_REAL, &timer, NULL);\n#endif /* _WIN32 */\n\t}\n\n\tif (RFileName == NULL) {\n\t\t/*\n\t\t * Live capture (if -V was specified, we set RFileName\n\t\t * to a file from the -V file).  Print a message to\n\t\t * the standard error on UN*X.\n\t\t */\n\t\tif (!ndo->ndo_vflag && !WFileName) {\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"%s: verbose output suppressed, use -v[v]... for full protocol decode\\n\",\n\t\t\t    program_name);\n\t\t} else\n\t\t\t(void)fprintf(stderr, \"%s: \", program_name);\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\t(void)fprintf(stderr, \"listening on %s\", device);\n\t\tif (dlt_name == NULL) {\n\t\t\t(void)fprintf(stderr, \", link-type %u\", dlt);\n\t\t} else {\n\t\t\t(void)fprintf(stderr, \", link-type %s (%s)\", dlt_name,\n\t\t\t\t      pcap_datalink_val_to_description(dlt));\n\t\t}\n\t\t(void)fprintf(stderr, \", snapshot length %d bytes\\n\", ndo->ndo_snaplen);\n\t\t(void)fflush(stderr);\n\t}\n\n#ifdef HAVE_CAPSICUM\n\tcansandbox = (VFileName == NULL && zflag == NULL);\n#ifdef HAVE_CASPER\n\tcansandbox = (cansandbox && (ndo->ndo_nflag || capdns != NULL));\n#else\n\tcansandbox = (cansandbox && ndo->ndo_nflag);\n#endif /* HAVE_CASPER */\n\tif (cansandbox && cap_enter() < 0 && errno != ENOSYS)\n\t\terror(\"unable to enter the capability mode\");\n#endif\t/* HAVE_CAPSICUM */\n\n\tdo {\n\t\tstatus = pcap_loop(pd, cnt, callback, pcap_userdata);\n\t\tif (WFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're printing packets.  Flush the printed output,\n\t\t\t * so it doesn't get intermingled with error output.\n\t\t\t */\n\t\t\tif (status == -2) {\n\t\t\t\t/*\n\t\t\t\t * We got interrupted, so perhaps we didn't\n\t\t\t\t * manage to finish a line we were printing.\n\t\t\t\t * Print an extra newline, just in case.\n\t\t\t\t */\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t\t(void)fflush(stdout);\n\t\t}\n                if (status == -2) {\n\t\t\t/*\n\t\t\t * We got interrupted. If we are reading multiple\n\t\t\t * files (via -V) set these so that we stop.\n\t\t\t */\n\t\t\tVFileName = NULL;\n\t\t\tret = NULL;\n\t\t}\n\t\tif (status == -1) {\n\t\t\t/*\n\t\t\t * Error.  Report it.\n\t\t\t */\n\t\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t\t    program_name, pcap_geterr(pd));\n\t\t}\n\t\tif (RFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're doing a live capture.  Report the capture\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tinfo(1);\n\t\t}\n\t\tpcap_close(pd);\n\t\tif (VFileName != NULL) {\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (ret) {\n\t\t\t\tint new_dlt;\n\n\t\t\t\tRFileName = VFileLine;\n\t\t\t\tpd = pcap_open_offline(RFileName, ebuf);\n\t\t\t\tif (pd == NULL)\n\t\t\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\t\t\tcap_rights_init(&rights, CAP_READ);\n\t\t\t\tif (cap_rights_limit(fileno(pcap_file(pd)),\n\t\t\t\t    &rights) < 0 && errno != ENOSYS) {\n\t\t\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t\t\t}\n#endif\n\t\t\t\tnew_dlt = pcap_datalink(pd);\n\t\t\t\tif (new_dlt != dlt) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The new file has a different\n\t\t\t\t\t * link-layer header type from the\n\t\t\t\t\t * previous one.\n\t\t\t\t\t */\n\t\t\t\t\tif (WFileName != NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We're writing raw packets\n\t\t\t\t\t\t * that match the filter to\n\t\t\t\t\t\t * a pcap file.  pcap files\n\t\t\t\t\t\t * don't support multiple\n\t\t\t\t\t\t * different link-layer\n\t\t\t\t\t\t * header types, so we fail\n\t\t\t\t\t\t * here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\terror(\"%s: new dlt does not match original\", RFileName);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We're printing the decoded packets;\n\t\t\t\t\t * switch to the new DLT.\n\t\t\t\t\t *\n\t\t\t\t\t * To do that, we need to change\n\t\t\t\t\t * the printer, change the DLT name,\n\t\t\t\t\t * and recompile the filter with\n\t\t\t\t\t * the new DLT.\n\t\t\t\t\t */\n\t\t\t\t\tdlt = new_dlt;\n\t\t\t\t\tndo->ndo_if_printer = get_if_printer(dlt);\n\t\t\t\t\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the filter on the new file.\n\t\t\t\t */\n\t\t\t\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\n\t\t\t\t/*\n\t\t\t\t * Report the new file.\n\t\t\t\t */\n\t\t\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\t\t\tfprintf(stderr, \"reading from file %s\", RFileName);\n\t\t\t\tif (dlt_name == NULL) {\n\t\t\t\t\tfprintf(stderr, \", link-type %u\", dlt);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \", link-type %s (%s)\",\n\t\t\t\t\t\tdlt_name,\n\t\t\t\t\t\tpcap_datalink_val_to_description(dlt));\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \", snapshot length %d\\n\", pcap_snapshot(pd));\n\t\t\t}\n\t\t}\n\t}\n\twhile (ret != NULL);\n\n\tif (count_mode && RFileName != NULL)\n\t\tfprintf(stdout, \"%u packet%s\\n\", packets_captured,\n\t\t\tPLURAL_SUFFIX(packets_captured));\n\n\tfree(cmdbuf);\n\tpcap_freecode(&fcode);\n\texit_tcpdump(status == -1 ? S_ERR_HOST_PROGRAM : S_SUCCESS);\n}\n\n/*\n * Catch a signal.\n */\nstatic void\n(*setsignal (int sig, void (*func)(int)))(int)\n{\n#ifdef _WIN32\n\treturn (signal(sig, func));\n#else\n\tstruct sigaction old, new;\n\n\tmemset(&new, 0, sizeof(new));\n\tnew.sa_handler = func;\n\tif ((sig == SIGCHLD)\n# ifdef SIGNAL_REQ_INFO\n\t\t|| (sig == SIGNAL_REQ_INFO)\n# endif\n# ifdef SIGNAL_FLUSH_PCAP\n\t\t|| (sig == SIGNAL_FLUSH_PCAP)\n# endif\n\t\t)\n\t\tnew.sa_flags = SA_RESTART;\n\tif (sigaction(sig, &new, &old) < 0)\n\t\treturn (SIG_ERR);\n\treturn (old.sa_handler);\n#endif\n}\n\n/* make a clean exit on interrupts */\nstatic void\ncleanup(int signo _U_)\n{\n#ifdef _WIN32\n\tif (timer_handle != INVALID_HANDLE_VALUE) {\n\t\tDeleteTimerQueueTimer(NULL, timer_handle, NULL);\n\t\tCloseHandle(timer_handle);\n\t\ttimer_handle = INVALID_HANDLE_VALUE;\n        }\n#else /* _WIN32 */\n\tstruct itimerval timer;\n\n\ttimer.it_interval.tv_sec = 0;\n\ttimer.it_interval.tv_usec = 0;\n\ttimer.it_value.tv_sec = 0;\n\ttimer.it_value.tv_usec = 0;\n\tsetitimer(ITIMER_REAL, &timer, NULL);\n#endif /* _WIN32 */\n\n#ifdef HAVE_PCAP_BREAKLOOP\n\t/*\n\t * We have \"pcap_breakloop()\"; use it, so that we do as little\n\t * as possible in the signal handler (it's probably not safe\n\t * to do anything with standard I/O streams in a signal handler -\n\t * the ANSI C standard doesn't say it is).\n\t */\n\tpcap_breakloop(pd);\n#else\n\t/*\n\t * We don't have \"pcap_breakloop()\"; this isn't safe, but\n\t * it's the best we can do.  Print the summary if we're\n\t * not reading from a savefile - i.e., if we're doing a\n\t * live capture - and exit.\n\t */\n\tif (pd != NULL && pcap_file(pd) == NULL) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t\t(void)fflush(stdout);\n\t\tinfo(1);\n\t}\n\texit_tcpdump(S_SUCCESS);\n#endif\n}\n\n/*\n  On windows, we do not use a fork, so we do not care less about\n  waiting a child processes to die\n */\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\nstatic void\nchild_cleanup(int signo _U_)\n{\n  wait(NULL);\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ninfo(int verbose)\n{\n\tstruct pcap_stat stats;\n\n\t/*\n\t * Older versions of libpcap didn't set ps_ifdrop on some\n\t * platforms; initialize it to 0 to handle that.\n\t */\n\tstats.ps_ifdrop = 0;\n\tif (pcap_stats(pd, &stats) < 0) {\n\t\t(void)fprintf(stderr, \"pcap_stats: %s\\n\", pcap_geterr(pd));\n\t\tinfoprint = 0;\n\t\treturn;\n\t}\n\n\tif (!verbose)\n\t\tfprintf(stderr, \"%s: \", program_name);\n\n\t(void)fprintf(stderr, \"%u packet%s captured\", packets_captured,\n\t    PLURAL_SUFFIX(packets_captured));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s received by filter\", stats.ps_recv,\n\t    PLURAL_SUFFIX(stats.ps_recv));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s dropped by kernel\", stats.ps_drop,\n\t    PLURAL_SUFFIX(stats.ps_drop));\n\tif (stats.ps_ifdrop != 0) {\n\t\tif (!verbose)\n\t\t\tfputs(\", \", stderr);\n\t\telse\n\t\t\tputc('\\n', stderr);\n\t\t(void)fprintf(stderr, \"%u packet%s dropped by interface\\n\",\n\t\t    stats.ps_ifdrop, PLURAL_SUFFIX(stats.ps_ifdrop));\n\t} else\n\t\tputc('\\n', stderr);\n\tinfoprint = 0;\n}\n\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n#ifdef HAVE_FORK\n#define fork_subprocess() fork()\n#else\n#define fork_subprocess() vfork()\n#endif\nstatic void\ncompress_savefile(const char *filename)\n{\n\tpid_t child;\n\n\tchild = fork_subprocess();\n\tif (child == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: fork failed: %s\\n\",\n\t\t\tpcap_strerror(errno));\n\t\treturn;\n\t}\n\tif (child != 0) {\n\t\t/* Parent process. */\n\t\treturn;\n\t}\n\n\t/*\n\t * Child process.\n\t * Set to lowest priority so that this doesn't disturb the capture.\n\t */\n#ifdef NZERO\n\tsetpriority(PRIO_PROCESS, 0, NZERO - 1);\n#else\n\tsetpriority(PRIO_PROCESS, 0, 19);\n#endif\n\tif (execlp(zflag, zflag, filename, (char *)NULL) == -1)\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: execlp(%s, %s) failed: %s\\n\",\n\t\t\tzflag,\n\t\t\tfilename,\n\t\t\tpcap_strerror(errno));\n#ifdef HAVE_FORK\n\texit(S_ERR_HOST_PROGRAM);\n#else\n\t_exit(S_ERR_HOST_PROGRAM);\n#endif\n}\n#else  /* HAVE_FORK && HAVE_VFORK */\nstatic void\ncompress_savefile(const char *filename)\n{\n\tfprintf(stderr,\n\t\t\"compress_savefile failed. Functionality not implemented under your system\\n\");\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ndump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\t/*\n\t * XXX - this won't force the file to rotate on the specified time\n\t * boundary, but it will rotate on the first packet received after the\n\t * specified Gflag number of seconds. Note: if a Gflag time boundary\n\t * and a Cflag size boundary coincide, the time rotation will occur\n\t * first thereby cancelling the Cflag boundary (since the file should\n\t * be 0).\n\t */\n\tif (Gflag != 0) {\n\t\t/* Check if it is time to rotate */\n\t\ttime_t t;\n\n\t\t/* Get the current time */\n\t\tif ((t = time(NULL)) == (time_t)-1) {\n\t\t\terror(\"%s: can't get current_time: %s\",\n\t\t\t    __func__, pcap_strerror(errno));\n\t\t}\n\n\n\t\t/* If the time is greater than the specified window, rotate */\n\t\tif (t - Gflag_time >= Gflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/* Update the Gflag_time */\n\t\t\tGflag_time = t;\n\t\t\t/* Update Gflag_count */\n\t\t\tGflag_count++;\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->pdd);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user asked for it\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\t/*\n\t\t\t * Check to see if we've exceeded the Wflag (when\n\t\t\t * not using Cflag).\n\t\t\t */\n\t\t\tif (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {\n\t\t\t\t(void)fprintf(stderr, \"Maximum file limit reached: %d\\n\",\n\t\t\t\t    Wflag);\n\t\t\t\tinfo(1);\n\t\t\t\texit_tcpdump(S_SUCCESS);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\t/* Allocate space for max filename + \\0. */\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\t/*\n\t\t\t * Gflag was set otherwise we wouldn't be here. Reset the count\n\t\t\t * so multiple files would end with 1,2,3 in the filename.\n\t\t\t * The counting is handled with the -C flow after this.\n\t\t\t */\n\t\t\tCflag_count = 0;\n\n\t\t\t/*\n\t\t\t * This is always the first file in the Cflag\n\t\t\t * rotation: e.g. 0\n\t\t\t * We also don't need numbering if Cflag is not set.\n\t\t\t */\n\t\t\tif (Cflag != 0)\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,\n\t\t\t\t    WflagChars);\n\t\t\telse\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);\n\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd,\n\t\t\t    dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->pdd = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->pdd = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->pdd == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->pdd);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * XXX - this won't prevent capture files from getting\n\t * larger than Cflag - the last packet written to the\n\t * file could put it over Cflag.\n\t */\n\tif (Cflag != 0) {\n#ifdef HAVE_PCAP_DUMP_FTELL64\n\t\tint64_t size = pcap_dump_ftell64(dump_info->pdd);\n#else\n\t\t/*\n\t\t * XXX - this only handles a Cflag value > 2^31-1 on\n\t\t * LP64 platforms; to handle ILP32 (32-bit UN*X and\n\t\t * Windows) or LLP64 (64-bit Windows) would require\n\t\t * a version of libpcap with pcap_dump_ftell64().\n\t\t */\n\t\tlong size = pcap_dump_ftell(dump_info->pdd);\n#endif\n\n\t\tif (size == -1)\n\t\t\terror(\"ftell fails on output file\");\n\t\tif (size > Cflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->pdd);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user\n\t\t\t * asked for it.\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\tCflag_count++;\n\t\t\tif (Wflag > 0) {\n\t\t\t\tif (Cflag_count >= Wflag)\n\t\t\t\t\tCflag_count = 0;\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"%s: malloc\", __func__);\n\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd, dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->pdd = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->pdd = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->pdd == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->pdd);\n#endif\n\t\t}\n\t}\n\n\tpcap_dump((u_char *)dump_info->pdd, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->pdd);\n#endif\n\n\tif (dump_info->ndo != NULL)\n\t\tpretty_print_packet(dump_info->ndo, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\ndump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\tpcap_dump((u_char *)dump_info->pdd, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->pdd);\n#endif\n\n\tif (dump_info->ndo != NULL)\n\t\tpretty_print_packet(dump_info->ndo, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\nprint_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\t++packets_captured;\n\n\t++infodelay;\n\n\tif (!count_mode)\n\t\tpretty_print_packet((netdissect_options *)user, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\n#ifdef SIGNAL_REQ_INFO\nstatic void\nrequestinfo(int signo _U_)\n{\n\tif (infodelay)\n\t\t++infoprint;\n\telse\n\t\tinfo(0);\n}\n#endif\n\n#ifdef SIGNAL_FLUSH_PCAP\nstatic void\nflushpcap(int signo _U_)\n{\n\tif (pdd != NULL)\n\t\tpcap_dump_flush(pdd);\n}\n#endif\n\nstatic void\nprint_packets_captured (void)\n{\n\tstatic u_int prev_packets_captured, first = 1;\n\n\tif (infodelay == 0 && (first || packets_captured != prev_packets_captured)) {\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n\t\tfirst = 0;\n\t\tprev_packets_captured = packets_captured;\n\t}\n}\n\n/*\n * Called once each second in verbose mode while dumping to file\n */\n#ifdef _WIN32\nstatic void CALLBACK verbose_stats_dump(PVOID param _U_,\n    BOOLEAN timer_fired _U_)\n{\n\tprint_packets_captured();\n}\n#else /* _WIN32 */\nstatic void verbose_stats_dump(int sig _U_)\n{\n\tprint_packets_captured();\n}\n#endif /* _WIN32 */\n\nDIAG_OFF_DEPRECATION\nstatic void\nprint_version(FILE *f)\n{\n#ifndef HAVE_PCAP_LIB_VERSION\n  #ifdef HAVE_PCAP_VERSION\n\textern char pcap_version[];\n  #else /* HAVE_PCAP_VERSION */\n\tstatic char pcap_version[] = \"unknown\";\n  #endif /* HAVE_PCAP_VERSION */\n#endif /* HAVE_PCAP_LIB_VERSION */\n\tconst char *smi_version_string;\n\n\t(void)fprintf(f, \"%s version \" PACKAGE_VERSION \"\\n\", program_name);\n#ifdef HAVE_PCAP_LIB_VERSION\n\t(void)fprintf(f, \"%s\\n\", pcap_lib_version());\n#else /* HAVE_PCAP_LIB_VERSION */\n\t(void)fprintf(f, \"libpcap version %s\\n\", pcap_version);\n#endif /* HAVE_PCAP_LIB_VERSION */\n\n#if defined(HAVE_LIBCRYPTO) && defined(SSLEAY_VERSION)\n\t(void)fprintf (f, \"%s\\n\", SSLeay_version(SSLEAY_VERSION));\n#endif\n\n\tsmi_version_string = nd_smi_version_string();\n\tif (smi_version_string != NULL)\n\t\t(void)fprintf (f, \"SMI-library: %s\\n\", smi_version_string);\n\n#if defined(__SANITIZE_ADDRESS__)\n\t(void)fprintf (f, \"Compiled with AddressSanitizer/GCC.\\n\");\n#elif defined(__has_feature)\n#  if __has_feature(address_sanitizer)\n\t(void)fprintf (f, \"Compiled with AddressSanitizer/Clang.\\n\");\n#  elif __has_feature(memory_sanitizer)\n\t(void)fprintf (f, \"Compiled with MemorySanitizer/Clang.\\n\");\n#  endif\n#endif /* __SANITIZE_ADDRESS__ or __has_feature */\n}\nDIAG_ON_DEPRECATION\n\nstatic void\nprint_usage(FILE *f)\n{\n\tprint_version(f);\n\t(void)fprintf(f,\n\"Usage: %s [-Abd\" D_FLAG \"efhH\" I_FLAG J_FLAG \"KlLnNOpqStu\" U_FLAG \"vxX#]\" B_FLAG_USAGE \" [ -c count ] [--count]\\n\", program_name);\n\t(void)fprintf(f,\n\"\\t\\t[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\\n\");\n\t(void)fprintf(f,\n\"\\t\\t[ -i interface ]\" IMMEDIATE_MODE_USAGE j_FLAG_USAGE \"\\n\");\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t(void)fprintf(f,\n\"\\t\\t\" LIST_REMOTE_INTERFACES_USAGE \"\\n\");\n#endif\n#ifdef USE_LIBSMI\n\t(void)fprintf(f,\n\"\\t\\t\" m_FLAG_USAGE \"\\n\");\n#endif\n\t(void)fprintf(f,\n\"\\t\\t[ -M secret ] [ --number ] [ --print ]\" Q_FLAG_USAGE \"\\n\");\n\t(void)fprintf(f,\n\"\\t\\t[ -r file ] [ -s snaplen ] [ -T type ] [ --version ]\\n\");\n\t(void)fprintf(f,\n\"\\t\\t[ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]\\n\");\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t(void)fprintf(f,\n\"\\t\\t[ --time-stamp-precision precision ] [ --micro ] [ --nano ]\\n\");\n#endif\n\t(void)fprintf(f,\n\"\\t\\t[ -z postrotate-command ] [ -Z user ] [ expression ]\\n\");\n}\n", "/*\n * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/*\n * txtproto_print() derived from original code by Hannes Gredler\n * (hannes@gredler.at):\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code\n * distributions retain the above copyright notice and this paragraph\n * in its entirety, and (2) distributions including binary code include\n * the above copyright notice and this paragraph in its entirety in\n * the documentation or other materials provided with the distribution.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND\n * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\n * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#include <sys/stat.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"netdissect-ctype.h\"\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"ascii_strcasecmp.h\"\n#include \"timeval-operations.h\"\n\n#define TOKBUFSIZE 128\n\nenum date_flag { WITHOUT_DATE = 0, WITH_DATE = 1 };\nenum time_flag { UTC_TIME = 0, LOCAL_TIME = 1 };\n\n/*\n * Print out a character, filtering out the non-printable ones\n */\nvoid\nfn_print_char(netdissect_options *ndo, u_char c)\n{\n\tif (!ND_ISASCII(c)) {\n\t\tc = ND_TOASCII(c);\n\t\tND_PRINT(\"M-\");\n\t}\n\tif (!ND_ASCII_ISPRINT(c)) {\n\t\tc ^= 0x40;\t/* DEL to ?, others to alpha */\n\t\tND_PRINT(\"^\");\n\t}\n\tND_PRINT(\"%c\", c);\n}\n\n/*\n * Print a null-terminated string, filtering out non-printable characters.\n * DON'T USE IT with a pointer on the packet buffer because there is no\n * truncation check. For this use, see the nd_printX() functions below.\n */\nvoid\nfn_print_str(netdissect_options *ndo, const u_char *s)\n{\n\twhile (*s != '\\0') {\n\t\tfn_print_char(ndo, *s);\n\t\ts++;\n       }\n}\n\n/*\n * Print out a null-terminated filename (or other ASCII string) from\n * a fixed-length field in the packet buffer, or from what remains of\n * the packet.\n *\n * n is the length of the fixed-length field, or the number of bytes\n * remaining in the packet based on its on-the-network length.\n *\n * If ep is non-null, it should point just past the last captured byte\n * of the packet, e.g. ndo->ndo_snapend.  If ep is NULL, we assume no\n * truncation check, other than the checks of the field length/remaining\n * packet data length, is needed.\n *\n * Return the number of bytes of string processed, including the\n * terminating null, if not truncated; as the terminating null is\n * included in the count, and as there must be a terminating null,\n * this will always be non-zero.  Return 0 if truncated.\n */\nu_int\nnd_printztn(netdissect_options *ndo,\n         const u_char *s, u_int n, const u_char *ep)\n{\n\tu_int bytes;\n\tu_char c;\n\n\tbytes = 0;\n\tfor (;;) {\n\t\tif (n == 0 || (ep != NULL && s >= ep)) {\n\t\t\t/*\n\t\t\t * Truncated.  This includes \"no null before we\n\t\t\t * got to the end of the fixed-length buffer or\n\t\t\t * the end of the packet\".\n\t\t\t *\n\t\t\t * XXX - BOOTP says \"null-terminated\", which\n\t\t\t * means the maximum length of the string, in\n\t\t\t * bytes, is 1 less than the size of the buffer,\n\t\t\t * as there must always be a terminating null.\n\t\t\t */\n\t\t\tbytes = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tbytes++;\n\t\tn--;\n\t\tif (c == '\\0') {\n\t\t\t/* End of string */\n\t\t\tbreak;\n\t\t}\n\t\tfn_print_char(ndo, c);\n\t}\n\treturn(bytes);\n}\n\n/*\n * Print out a counted filename (or other ASCII string), part of\n * the packet buffer.\n * If ep is NULL, assume no truncation check is needed.\n * Return true if truncated.\n * Stop at ep (if given) or after n bytes, whichever is first.\n */\nint\nnd_printn(netdissect_options *ndo,\n          const u_char *s, u_int n, const u_char *ep)\n{\n\tu_char c;\n\n\twhile (n > 0 && (ep == NULL || s < ep)) {\n\t\tn--;\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tfn_print_char(ndo, c);\n\t}\n\treturn (n == 0) ? 0 : 1;\n}\n\n/*\n * Print a null-padded filename (or other ASCII string), part of\n * the packet buffer, filtering out non-printable characters.\n * Stop if truncated (via GET_U_1/longjmp) or after n bytes or before\n * the null char, whichever occurs first.\n * The suffix comes from: j:longJmp, n:after N bytes, p:null-Padded.\n */\nvoid\nnd_printjnp(netdissect_options *ndo, const u_char *s, u_int n)\n{\n\tu_char c;\n\n\twhile (n > 0) {\n\t\tc = GET_U_1(s);\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\t\tfn_print_char(ndo, c);\n\t\tn--;\n\t\ts++;\n\t}\n}\n\n/*\n * Print the timestamp .FRAC part (Microseconds/nanoseconds)\n */\nstatic void\nts_frac_print(netdissect_options *ndo, long usec)\n{\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tswitch (ndo->ndo_tstamp_precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tND_PRINT(\".%06u\", (unsigned)usec);\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tND_PRINT(\".%09u\", (unsigned)usec);\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT(\".{unknown}\");\n\t\tbreak;\n\t}\n#else\n\tND_PRINT(\".%06u\", (unsigned)usec);\n#endif\n}\n\n/*\n * Print the timestamp as [YY:MM:DD] HH:MM:SS.FRAC.\n *   if time_flag == LOCAL_TIME print local time else UTC/GMT time\n *   if date_flag == WITH_DATE print YY:MM:DD before HH:MM:SS.FRAC\n */\nstatic void\nts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timestr[32];\n\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\n\tif (!tm) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (date_flag == WITH_DATE)\n\t\tstrftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", tm);\n\telse\n\t\tstrftime(timestr, sizeof(timestr), \"%H:%M:%S\", tm);\n\tND_PRINT(\"%s\", timestr);\n\n\tts_frac_print(ndo, usec);\n}\n\n/*\n * Print the timestamp - Unix timeval style, as SECS.FRAC.\n */\nstatic void\nts_unix_print(netdissect_options *ndo, long sec, long usec)\n{\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\n\tND_PRINT(\"%u\", (unsigned)sec);\n\tts_frac_print(ndo, usec);\n}\n\n/*\n * Print the timestamp\n */\nvoid\nts_print(netdissect_options *ndo,\n         const struct timeval *tvp)\n{\n\tstatic struct timeval tv_ref;\n\tstruct timeval tv_result;\n\tint negative_offset;\n\tint nano_prec;\n\n\tswitch (ndo->ndo_tflag) {\n\n\tcase 0: /* Default */\n\t\tts_date_hmsfrac_print(ndo, tvp->tv_sec, tvp->tv_usec,\n\t\t\t\t      WITHOUT_DATE, LOCAL_TIME);\n\t\tND_PRINT(\" \");\n\t\tbreak;\n\n\tcase 1: /* No time stamp */\n\t\tbreak;\n\n\tcase 2: /* Unix timeval style */\n\t\tts_unix_print(ndo, tvp->tv_sec, tvp->tv_usec);\n\t\tND_PRINT(\" \");\n\t\tbreak;\n\n\tcase 3: /* Microseconds/nanoseconds since previous packet */\n        case 5: /* Microseconds/nanoseconds since first packet */\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tswitch (ndo->ndo_tstamp_precision) {\n\t\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\t\tnano_prec = 0;\n\t\t\tbreak;\n\t\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\t\tnano_prec = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnano_prec = 0;\n\t\t\tbreak;\n\t\t}\n#else\n\t\tnano_prec = 0;\n#endif\n\t\tif (!(netdissect_timevalisset(&tv_ref)))\n\t\t\ttv_ref = *tvp; /* set timestamp for first packet */\n\n\t\tnegative_offset = netdissect_timevalcmp(tvp, &tv_ref, <);\n\t\tif (negative_offset)\n\t\t\tnetdissect_timevalsub(&tv_ref, tvp, &tv_result, nano_prec);\n\t\telse\n\t\t\tnetdissect_timevalsub(tvp, &tv_ref, &tv_result, nano_prec);\n\n\t\tND_PRINT((negative_offset ? \"-\" : \" \"));\n\t\tts_date_hmsfrac_print(ndo, tv_result.tv_sec, tv_result.tv_usec,\n\t\t\t\t      WITHOUT_DATE, UTC_TIME);\n\t\tND_PRINT(\" \");\n\n                if (ndo->ndo_tflag == 3)\n\t\t\ttv_ref = *tvp; /* set timestamp for previous packet */\n\t\tbreak;\n\n\tcase 4: /* Date + Default */\n\t\tts_date_hmsfrac_print(ndo, tvp->tv_sec, tvp->tv_usec,\n\t\t\t\t      WITH_DATE, LOCAL_TIME);\n\t\tND_PRINT(\" \");\n\t\tbreak;\n\t}\n}\n\n/*\n * Print an unsigned relative number of seconds (e.g. hold time, prune timer)\n * in the form 5m1s.  This does no truncation, so 32230861 seconds\n * is represented as 1y1w1d1h1m1s.\n */\nvoid\nunsigned_relts_print(netdissect_options *ndo,\n                     uint32_t secs)\n{\n\tstatic const char *lengths[] = {\"y\", \"w\", \"d\", \"h\", \"m\", \"s\"};\n\tstatic const u_int seconds[] = {31536000, 604800, 86400, 3600, 60, 1};\n\tconst char **l = lengths;\n\tconst u_int *s = seconds;\n\n\tif (secs == 0) {\n\t\tND_PRINT(\"0s\");\n\t\treturn;\n\t}\n\twhile (secs > 0) {\n\t\tif (secs >= *s) {\n\t\t\tND_PRINT(\"%u%s\", secs / *s, *l);\n\t\t\tsecs -= (secs / *s) * *s;\n\t\t}\n\t\ts++;\n\t\tl++;\n\t}\n}\n\n/*\n * Print a signed relative number of seconds (e.g. hold time, prune timer)\n * in the form 5m1s.  This does no truncation, so 32230861 seconds\n * is represented as 1y1w1d1h1m1s.\n */\nvoid\nsigned_relts_print(netdissect_options *ndo,\n                   int32_t secs)\n{\n\tif (secs < 0) {\n\t\tND_PRINT(\"-\");\n\t\tif (secs == INT32_MIN) {\n\t\t\t/*\n\t\t\t * -2^31; you can't fit its absolute value into\n\t\t\t * a 32-bit signed integer.\n\t\t\t *\n\t\t\t * Just directly pass said absolute value to\n\t\t\t * unsigned_relts_print() directly.\n\t\t\t *\n\t\t\t * (XXX - does ISO C guarantee that -(-2^n),\n\t\t\t * when calculated and cast to an n-bit unsigned\n\t\t\t * integer type, will have the value 2^n?)\n\t\t\t */\n\t\t\tunsigned_relts_print(ndo, 2147483648U);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We now know -secs will fit into an int32_t;\n\t\t\t * negate it and pass that to unsigned_relts_print().\n\t\t\t */\n\t\t\tunsigned_relts_print(ndo, -secs);\n\t\t}\n\t\treturn;\n\t}\n\tunsigned_relts_print(ndo, secs);\n}\n\n/* Print the truncated string */\nvoid nd_print_trunc(netdissect_options *ndo)\n{\n\tND_PRINT(\" [|%s]\", ndo->ndo_protocol);\n}\n\n/* Print the protocol name */\nvoid nd_print_protocol(netdissect_options *ndo)\n{\n\tND_PRINT(\"%s\", ndo->ndo_protocol);\n}\n\n/* Print the protocol name in caps (uppercases) */\nvoid nd_print_protocol_caps(netdissect_options *ndo)\n{\n\tconst char *p;\n        for (p = ndo->ndo_protocol; *p != '\\0'; p++)\n                ND_PRINT(\"%c\", ND_ASCII_TOUPPER(*p));\n}\n\n/* Print the invalid string */\nvoid nd_print_invalid(netdissect_options *ndo)\n{\n\tND_PRINT(\" (invalid)\");\n}\n\n/*\n *  this is a generic routine for printing unknown data;\n *  we pass on the linefeed plus indentation string to\n *  get a proper output - returns 0 on error\n */\n\nint\nprint_unknown_data(netdissect_options *ndo, const u_char *cp,\n                   const char *ident, u_int len)\n{\n\tu_int len_to_print;\n\n\tlen_to_print = len;\n\tif (!ND_TTEST_LEN(cp, 0)) {\n\t\tND_PRINT(\"%sDissector error: print_unknown_data called with pointer past end of packet\",\n\t\t    ident);\n\t\treturn(0);\n\t}\n\tif (ND_BYTES_AVAILABLE_AFTER(cp) < len_to_print)\n\t\tlen_to_print = ND_BYTES_AVAILABLE_AFTER(cp);\n\thex_print(ndo, ident, cp, len_to_print);\n\treturn(1); /* everything is ok */\n}\n\n/*\n * Convert a token value to a string; use \"fmt\" if not found.\n */\nstatic const char *\ntok2strbuf(const struct tok *lp, const char *fmt,\n\t   u_int v, char *buf, size_t bufsize)\n{\n\tif (lp != NULL) {\n\t\twhile (lp->s != NULL) {\n\t\t\tif (lp->v == v)\n\t\t\t\treturn (lp->s);\n\t\t\t++lp;\n\t\t}\n\t}\n\tif (fmt == NULL)\n\t\tfmt = \"#%d\";\n\n\t(void)snprintf(buf, bufsize, fmt, v);\n\treturn (const char *)buf;\n}\n\n/*\n * Convert a token value to a string; use \"fmt\" if not found.\n * Uses tok2strbuf() on one of four local static buffers of size TOKBUFSIZE\n * in round-robin fashion.\n */\nconst char *\ntok2str(const struct tok *lp, const char *fmt,\n\tu_int v)\n{\n\tstatic char buf[4][TOKBUFSIZE];\n\tstatic int idx = 0;\n\tchar *ret;\n\n\tret = buf[idx];\n\tidx = (idx+1) & 3;\n\treturn tok2strbuf(lp, fmt, v, ret, sizeof(buf[0]));\n}\n\n/*\n * Convert a bit token value to a string; use \"fmt\" if not found.\n * this is useful for parsing bitfields, the output strings are separated\n * if the s field is positive.\n *\n * A token matches iff it has one or more bits set and every bit that is set\n * in the token is set in v. Consequently, a 0 token never matches.\n */\nstatic char *\nbittok2str_internal(const struct tok *lp, const char *fmt,\n\t   u_int v, const char *sep)\n{\n        static char buf[1024+1]; /* our string buffer */\n        char *bufp = buf;\n        size_t space_left = sizeof(buf), string_size;\n        const char * sepstr = \"\";\n\n        while (lp != NULL && lp->s != NULL) {\n            if (lp->v && (v & lp->v) == lp->v) {\n                /* ok we have found something */\n                if (space_left <= 1)\n                    return (buf); /* only enough room left for NUL, if that */\n                string_size = strlcpy(bufp, sepstr, space_left);\n                if (string_size >= space_left)\n                    return (buf);    /* we ran out of room */\n                bufp += string_size;\n                space_left -= string_size;\n                if (space_left <= 1)\n                    return (buf); /* only enough room left for NUL, if that */\n                string_size = strlcpy(bufp, lp->s, space_left);\n                if (string_size >= space_left)\n                    return (buf);    /* we ran out of room */\n                bufp += string_size;\n                space_left -= string_size;\n                sepstr = sep;\n            }\n            lp++;\n        }\n\n        if (bufp == buf)\n            /* bummer - lets print the \"unknown\" message as advised in the fmt string if we got one */\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}\n\n/*\n * Convert a bit token value to a string; use \"fmt\" if not found.\n * this is useful for parsing bitfields, the output strings are not separated.\n */\nchar *\nbittok2str_nosep(const struct tok *lp, const char *fmt,\n\t   u_int v)\n{\n    return (bittok2str_internal(lp, fmt, v, \"\"));\n}\n\n/*\n * Convert a bit token value to a string; use \"fmt\" if not found.\n * this is useful for parsing bitfields, the output strings are comma separated.\n */\nchar *\nbittok2str(const struct tok *lp, const char *fmt,\n\t   u_int v)\n{\n    return (bittok2str_internal(lp, fmt, v, \", \"));\n}\n\n/*\n * Convert a value to a string using an array; the macro\n * tok2strary() in <netdissect.h> is the public interface to\n * this function and ensures that the second argument is\n * correct for bounds-checking.\n */\nconst char *\ntok2strary_internal(const char **lp, int n, const char *fmt,\n\tint v)\n{\n\tstatic char buf[TOKBUFSIZE];\n\n\tif (v >= 0 && v < n && lp[v] != NULL)\n\t\treturn lp[v];\n\tif (fmt == NULL)\n\t\tfmt = \"#%d\";\n\t(void)snprintf(buf, sizeof(buf), fmt, v);\n\treturn (buf);\n}\n\nconst struct tok *\nuint2tokary_internal(const struct uint_tokary dict[], const size_t size,\n                     const u_int val)\n{\n\tsize_t i;\n\t/* Try a direct lookup before the full scan. */\n\tif (val < size && dict[val].uintval == val)\n\t\treturn dict[val].tokary; /* OK if NULL */\n\tfor (i = 0; i < size; i++)\n\t\tif (dict[i].uintval == val)\n\t\t\treturn dict[i].tokary; /* OK if NULL */\n\treturn NULL;\n}\n\n/*\n * Convert a 32-bit netmask to prefixlen if possible\n * the function returns the prefix-len; if plen == -1\n * then conversion was not possible;\n */\n\nint\nmask2plen(uint32_t mask)\n{\n\tconst uint32_t bitmasks[33] = {\n\t\t0x00000000,\n\t\t0x80000000, 0xc0000000, 0xe0000000, 0xf0000000,\n\t\t0xf8000000, 0xfc000000, 0xfe000000, 0xff000000,\n\t\t0xff800000, 0xffc00000, 0xffe00000, 0xfff00000,\n\t\t0xfff80000, 0xfffc0000, 0xfffe0000, 0xffff0000,\n\t\t0xffff8000, 0xffffc000, 0xffffe000, 0xfffff000,\n\t\t0xfffff800, 0xfffffc00, 0xfffffe00, 0xffffff00,\n\t\t0xffffff80, 0xffffffc0, 0xffffffe0, 0xfffffff0,\n\t\t0xfffffff8, 0xfffffffc, 0xfffffffe, 0xffffffff\n\t};\n\tint prefix_len = 32;\n\n\t/* let's see if we can transform the mask into a prefixlen */\n\twhile (prefix_len >= 0) {\n\t\tif (bitmasks[prefix_len] == mask)\n\t\t\tbreak;\n\t\tprefix_len--;\n\t}\n\treturn (prefix_len);\n}\n\nint\nmask62plen(const u_char *mask)\n{\n\tu_char bitmasks[9] = {\n\t\t0x00,\n\t\t0x80, 0xc0, 0xe0, 0xf0,\n\t\t0xf8, 0xfc, 0xfe, 0xff\n\t};\n\tint byte;\n\tint cidr_len = 0;\n\n\tfor (byte = 0; byte < 16; byte++) {\n\t\tu_int bits;\n\n\t\tfor (bits = 0; bits < (sizeof (bitmasks) / sizeof (bitmasks[0])); bits++) {\n\t\t\tif (mask[byte] == bitmasks[bits]) {\n\t\t\t\tcidr_len += bits;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mask[byte] != 0xff)\n\t\t\tbreak;\n\t}\n\treturn (cidr_len);\n}\n\n/*\n * Routine to print out information for text-based protocols such as FTP,\n * HTTP, SMTP, RTSP, SIP, ....\n */\n#define MAX_TOKEN\t128\n\n/*\n * Fetch a token from a packet, starting at the specified index,\n * and return the length of the token.\n *\n * Returns 0 on error; yes, this is indistinguishable from an empty\n * token, but an \"empty token\" isn't a valid token - it just means\n * either a space character at the beginning of the line (this\n * includes a blank line) or no more tokens remaining on the line.\n */\nstatic int\nfetch_token(netdissect_options *ndo, const u_char *pptr, u_int idx, u_int len,\n    u_char *tbuf, size_t tbuflen)\n{\n\tsize_t toklen = 0;\n\tu_char c;\n\n\tfor (; idx < len; idx++) {\n\t\tif (!ND_TTEST_1(pptr + idx)) {\n\t\t\t/* ran past end of captured data */\n\t\t\treturn (0);\n\t\t}\n\t\tc = GET_U_1(pptr + idx);\n\t\tif (!ND_ISASCII(c)) {\n\t\t\t/* not an ASCII character */\n\t\t\treturn (0);\n\t\t}\n\t\tif (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n\t\t\t/* end of token */\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ASCII_ISPRINT(c)) {\n\t\t\t/* not part of a command token or response code */\n\t\t\treturn (0);\n\t\t}\n\t\tif (toklen + 2 > tbuflen) {\n\t\t\t/* no room for this character and terminating '\\0' */\n\t\t\treturn (0);\n\t\t}\n\t\ttbuf[toklen] = c;\n\t\ttoklen++;\n\t}\n\tif (toklen == 0) {\n\t\t/* no token */\n\t\treturn (0);\n\t}\n\ttbuf[toklen] = '\\0';\n\n\t/*\n\t * Skip past any white space after the token, until we see\n\t * an end-of-line (CR or LF).\n\t */\n\tfor (; idx < len; idx++) {\n\t\tif (!ND_TTEST_1(pptr + idx)) {\n\t\t\t/* ran past end of captured data */\n\t\t\tbreak;\n\t\t}\n\t\tc = GET_U_1(pptr + idx);\n\t\tif (c == '\\r' || c == '\\n') {\n\t\t\t/* end of line */\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ASCII_ISPRINT(c)) {\n\t\t\t/* not a printable ASCII character */\n\t\t\tbreak;\n\t\t}\n\t\tif (c != ' ' && c != '\\t' && c != '\\r' && c != '\\n') {\n\t\t\t/* beginning of next token */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (idx);\n}\n\n/*\n * Scan a buffer looking for a line ending - LF or CR-LF.\n * Return the index of the character after the line ending or 0 if\n * we encounter a non-ASCII or non-printable character or don't find\n * the line ending.\n */\nstatic u_int\nprint_txt_line(netdissect_options *ndo, const char *prefix,\n\t       const u_char *pptr, u_int idx, u_int len)\n{\n\tu_int startidx;\n\tu_int linelen;\n\tu_char c;\n\n\tstartidx = idx;\n\twhile (idx < len) {\n\t\tc = GET_U_1(pptr + idx);\n\t\tif (c == '\\n') {\n\t\t\t/*\n\t\t\t * LF without CR; end of line.\n\t\t\t * Skip the LF and print the line, with the\n\t\t\t * exception of the LF.\n\t\t\t */\n\t\t\tlinelen = idx - startidx;\n\t\t\tidx++;\n\t\t\tgoto print;\n\t\t} else if (c == '\\r') {\n\t\t\t/* CR - any LF? */\n\t\t\tif ((idx+1) >= len) {\n\t\t\t\t/* not in this packet */\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (GET_U_1(pptr + idx + 1) == '\\n') {\n\t\t\t\t/*\n\t\t\t\t * CR-LF; end of line.\n\t\t\t\t * Skip the CR-LF and print the line, with\n\t\t\t\t * the exception of the CR-LF.\n\t\t\t\t */\n\t\t\t\tlinelen = idx - startidx;\n\t\t\t\tidx += 2;\n\t\t\t\tgoto print;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * CR followed by something else; treat this\n\t\t\t * as if it were binary data, and don't print\n\t\t\t * it.\n\t\t\t */\n\t\t\treturn (0);\n\t\t} else if (!ND_ASCII_ISPRINT(c) && c != '\\t') {\n\t\t\t/*\n\t\t\t * Not a printable ASCII character and not a tab;\n\t\t\t * treat this as if it were binary data, and\n\t\t\t * don't print it.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\tidx++;\n\t}\n\n\t/*\n\t * All printable ASCII, but no line ending after that point\n\t * in the buffer; treat this as if it were truncated.\n\t */\n\tlinelen = idx - startidx;\n\tND_PRINT(\"%s%.*s\", prefix, (int)linelen, pptr + startidx);\n\tnd_print_trunc(ndo);\n\treturn (0);\n\nprint:\n\tND_PRINT(\"%s%.*s\", prefix, (int)linelen, pptr + startidx);\n\treturn (idx);\n}\n\n/* Assign needed before calling txtproto_print(): ndo->ndo_protocol = \"proto\" */\nvoid\ntxtproto_print(netdissect_options *ndo, const u_char *pptr, u_int len,\n\t       const char **cmds, u_int flags)\n{\n\tu_int idx, eol;\n\tu_char token[MAX_TOKEN+1];\n\tconst char *cmd;\n\tint print_this = 0;\n\n\tif (cmds != NULL) {\n\t\t/*\n\t\t * This protocol has more than just request and\n\t\t * response lines; see whether this looks like a\n\t\t * request or response and, if so, print it and,\n\t\t * in verbose mode, print everything after it.\n\t\t *\n\t\t * This is for HTTP-like protocols, where we\n\t\t * want to print requests and responses, but\n\t\t * don't want to print continuations of request\n\t\t * or response bodies in packets that don't\n\t\t * contain the request or response line.\n\t\t */\n\t\tidx = fetch_token(ndo, pptr, 0, len, token, sizeof(token));\n\t\tif (idx != 0) {\n\t\t\t/* Is this a valid request name? */\n\t\t\twhile ((cmd = *cmds++) != NULL) {\n\t\t\t\tif (ascii_strcasecmp((const char *)token, cmd) == 0) {\n\t\t\t\t\t/* Yes. */\n\t\t\t\t\tprint_this = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * No - is this a valid response code (3 digits)?\n\t\t\t *\n\t\t\t * Is this token the response code, or is the next\n\t\t\t * token the response code?\n\t\t\t */\n\t\t\tif (flags & RESP_CODE_SECOND_TOKEN) {\n\t\t\t\t/*\n\t\t\t\t * Next token - get it.\n\t\t\t\t */\n\t\t\t\tidx = fetch_token(ndo, pptr, idx, len, token,\n\t\t\t\t    sizeof(token));\n\t\t\t}\n\t\t\tif (idx != 0) {\n\t\t\t\tif (ND_ASCII_ISDIGIT(token[0]) && ND_ASCII_ISDIGIT(token[1]) &&\n\t\t\t\t    ND_ASCII_ISDIGIT(token[2]) && token[3] == '\\0') {\n\t\t\t\t\t/* Yes. */\n\t\t\t\t\tprint_this = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Either:\n\t\t *\n\t\t * 1) This protocol has only request and response lines\n\t\t *    (e.g., FTP, where all the data goes over a different\n\t\t *    connection); assume the payload is a request or\n\t\t *    response.\n\t\t *\n\t\t * or\n\t\t *\n\t\t * 2) This protocol is just text, so that we should\n\t\t *    always, at minimum, print the first line and,\n\t\t *    in verbose mode, print all lines.\n\t\t */\n\t\tprint_this = 1;\n\t}\n\n\tnd_print_protocol_caps(ndo);\n\n\tif (print_this) {\n\t\t/*\n\t\t * In non-verbose mode, just print the protocol, followed\n\t\t * by the first line.\n\t\t *\n\t\t * In verbose mode, print lines as text until we run out\n\t\t * of characters or see something that's not a\n\t\t * printable-ASCII line.\n\t\t */\n\t\tif (ndo->ndo_vflag) {\n\t\t\t/*\n\t\t\t * We're going to print all the text lines in the\n\t\t\t * request or response; just print the length\n\t\t\t * on the first line of the output.\n\t\t\t */\n\t\t\tND_PRINT(\", length: %u\", len);\n\t\t\tfor (idx = 0;\n\t\t\t    idx < len && (eol = print_txt_line(ndo, \"\\n\\t\", pptr, idx, len)) != 0;\n\t\t\t    idx = eol)\n\t\t\t\t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Just print the first text line.\n\t\t\t */\n\t\t\tprint_txt_line(ndo, \": \", pptr, 0, len);\n\t\t}\n\t}\n}\n\n#if (defined(__i386__) || defined(_M_IX86) || defined(__X86__) || defined(__x86_64__) || defined(_M_X64)) || \\\n    (defined(__arm__) || defined(_M_ARM) || defined(__aarch64__)) || \\\n    (defined(__m68k__) && (!defined(__mc68000__) && !defined(__mc68010__))) || \\\n    (defined(__ppc__) || defined(__ppc64__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)) || \\\n    (defined(__s390__) || defined(__s390x__) || defined(__zarch__)) || \\\n    defined(__vax__)\n/*\n * The processor natively handles unaligned loads, so just use memcpy()\n * and memcmp(), to enable those optimizations.\n *\n * XXX - are those all the x86 tests we need?\n * XXX - do we need to worry about ARMv1 through ARMv5, which didn't\n * support unaligned loads, and, if so, do we need to worry about all\n * of them, or just some of them, e.g. ARMv5?\n * XXX - are those the only 68k tests we need not to generated\n * unaligned accesses if the target is the 68000 or 68010?\n * XXX - are there any tests we don't need, because some definitions are for\n * compilers that also predefine the GCC symbols?\n * XXX - do we need to test for both 32-bit and 64-bit versions of those\n * architectures in all cases?\n */\n#else\n/*\n * The processor doesn't natively handle unaligned loads,\n * and the compiler might \"helpfully\" optimize memcpy()\n * and memcmp(), when handed pointers that would normally\n * be properly aligned, into sequences that assume proper\n * alignment.\n *\n * Do copies and compares of possibly-unaligned data by\n * calling routines that wrap memcpy() and memcmp(), to\n * prevent that optimization.\n */\nvoid\nunaligned_memcpy(void *p, const void *q, size_t l)\n{\n\tmemcpy(p, q, l);\n}\n\n/* As with memcpy(), so with memcmp(). */\nint\nunaligned_memcmp(const void *p, const void *q, size_t l)\n{\n\treturn (memcmp(p, q, l));\n}\n#endif\n\n"], "fixing_code": ["/*\n * Copyright (c) 1988-1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Copyright (c) 1998-2012  Michael Richardson <mcr@tcpdump.org>\n *      The TCPDUMP project\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n#ifndef netdissect_h\n#define netdissect_h\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n#include <sys/types.h>\n#include <setjmp.h>\n#include \"status-exit-codes.h\"\n#include \"funcattrs.h\" /* for PRINTFLIKE_FUNCPTR() */\n#include \"diag-control.h\" /* for ND_UNREACHABLE */\n\n/*\n * Data types corresponding to multi-byte integral values within data\n * structures.  These are defined as arrays of octets, so that they're\n * not aligned on their \"natural\" boundaries, and so that you *must*\n * use the EXTRACT_ macros to extract them (which you should be doing\n * *anyway*, so as not to assume a particular byte order or alignment\n * in your code).\n *\n * We even want EXTRACT_U_1 used for 8-bit integral values, so we\n * define nd_uint8_t and nd_int8_t as arrays as well.\n */\ntypedef unsigned char nd_uint8_t[1];\ntypedef unsigned char nd_uint16_t[2];\ntypedef unsigned char nd_uint24_t[3];\ntypedef unsigned char nd_uint32_t[4];\ntypedef unsigned char nd_uint40_t[5];\ntypedef unsigned char nd_uint48_t[6];\ntypedef unsigned char nd_uint56_t[7];\ntypedef unsigned char nd_uint64_t[8];\n\ntypedef signed char nd_int8_t[1];\n\n/*\n * \"unsigned char\" so that sign extension isn't done on the\n * individual bytes while they're being assembled.\n */\ntypedef unsigned char nd_int32_t[4];\ntypedef unsigned char nd_int64_t[8];\n\n#define\tFMAXINT\t(4294967296.0)\t/* floating point rep. of MAXINT */\n\n/*\n * Use this for IPv4 addresses and netmasks.\n *\n * It's defined as an array of octets, so that it's not guaranteed to\n * be aligned on its \"natural\" boundary (in some packet formats, it\n * *isn't* so aligned).  We have separate EXTRACT_ calls for them;\n * sometimes you want the host-byte-order value, other times you want\n * the network-byte-order value.\n *\n * Don't use EXTRACT_BE_U_4() on them, use EXTRACT_IPV4_TO_HOST_ORDER()\n * if you want them in host byte order and EXTRACT_IPV4_TO_NETWORK_ORDER()\n * if you want them in network byte order (which you want with system APIs\n * that expect network-order IPv4 addresses, such as inet_ntop()).\n *\n * If, on your little-endian machine (e.g., an \"IBM-compatible PC\", no matter\n * what the OS, or an Intel Mac, no matter what the OS), you get the wrong\n * answer, and you've used EXTRACT_BE_U_4(), do *N*O*T* \"fix\" this by using\n * EXTRACT_LE_U_4(), fix it by using EXTRACT_IPV4_TO_NETWORK_ORDER(),\n * otherwise you're breaking the result on big-endian machines (e.g.,\n * most PowerPC/Power ISA machines, System/390 and z/Architecture, SPARC,\n * etc.).\n *\n * Yes, people do this; that's why Wireshark has tvb_get_ipv4(), to extract\n * an IPv4 address from a packet data buffer; it was introduced in reaction\n * to somebody who *had* done that.\n */\ntypedef unsigned char nd_ipv4[4];\n\n/*\n * Use this for IPv6 addresses and netmasks.\n */\ntypedef unsigned char nd_ipv6[16];\n\n/*\n * Use this for MAC addresses.\n */\n#define MAC_ADDR_LEN\t6U\t\t/* length of MAC addresses */\ntypedef unsigned char nd_mac_addr[MAC_ADDR_LEN];\n\n/*\n * Use this for blobs of bytes; make them arrays of nd_byte.\n */\ntypedef unsigned char nd_byte;\n\n/*\n * Round up x to a multiple of y; y must be a power of 2.\n */\n#ifndef roundup2\n#define\troundup2(x, y)\t(((x)+((u_int)((y)-1)))&(~((u_int)((y)-1))))\n#endif\n\n#include <stdarg.h>\n#include <pcap.h>\n\n#include \"ip.h\" /* struct ip for nextproto4_cksum() */\n#include \"ip6.h\" /* struct ip6 for nextproto6_cksum() */\n\n#ifndef HAVE_STRLCAT\nextern size_t strlcat (char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRLCPY\nextern size_t strlcpy (char *, const char *, size_t);\n#endif\n\n#ifndef HAVE_STRDUP\nextern char *strdup (const char *str);\n#endif\n\n#ifndef HAVE_STRSEP\nextern char *strsep(char **, const char *);\n#endif\n\nstruct tok {\n\tu_int v;\t\t/* value */\n\tconst char *s;\t\t/* string */\n};\n\n/* tok2str is deprecated */\nextern const char *tok2str(const struct tok *, const char *, u_int);\nextern char *bittok2str(const struct tok *, const char *, u_int);\nextern char *bittok2str_nosep(const struct tok *, const char *, u_int);\n\n/* Initialize netdissect. */\nextern int nd_init(char *, size_t);\n/* Clean up netdissect. */\nextern void nd_cleanup(void);\n\n/* Do we have libsmi support? */\nextern int nd_have_smi_support(void);\n/* Load an SMI module. */\nextern int nd_load_smi_module(const char *, char *, size_t);\n/* Flag indicating whether an SMI module has been loaded. */\nextern int nd_smi_module_loaded;\n/* Version number of the SMI library, or NULL if we don't have libsmi support. */\nextern const char *nd_smi_version_string(void);\n\ntypedef struct netdissect_options netdissect_options;\n\n#define IF_PRINTER_ARGS (netdissect_options *, const struct pcap_pkthdr *, const u_char *)\n\ntypedef void (*if_printer) IF_PRINTER_ARGS;\n\n/*\n * In case the data in a buffer needs to be processed by being decrypted,\n * decompressed, etc. before it's dissected, we can't process it in place,\n * we have to allocate a new buffer for the processed data.\n *\n * We keep a stack of those buffers; when we allocate a new buffer, we\n * push the current one onto a stack, and when we're done with the new\n * buffer, we free the current buffer and pop the previous one off the\n * stack.\n *\n * A buffer has a beginning and end pointer, and a link to the previous\n * buffer on the stack.\n *\n * In other cases, we temporarily adjust the snapshot end to reflect a\n * packet-length field in the packet data and, when finished dissecting\n * that part of the packet, restore the old snapshot end.  We keep that\n * on the stack with null buffer pointer, meaning there's nothing to\n * free.\n */\nstruct netdissect_saved_packet_info {\n  u_char *ndspi_buffer;\t\t\t\t\t/* pointer to allocated buffer data */\n  const u_char *ndspi_packetp;\t\t\t\t/* saved beginning of data */\n  const u_char *ndspi_snapend;\t\t\t\t/* saved end of data */\n  struct netdissect_saved_packet_info *ndspi_prev;\t/* previous buffer on the stack */\n};\n\n/* 'val' value(s) for longjmp */\n#define ND_TRUNCATED 1\n\nstruct netdissect_options {\n  int ndo_bflag;\t\t/* print 4 byte ASes in ASDOT notation */\n  int ndo_eflag;\t\t/* print ethernet header */\n  int ndo_fflag;\t\t/* don't translate \"foreign\" IP address */\n  int ndo_Kflag;\t\t/* don't check IP, TCP or UDP checksums */\n  int ndo_nflag;\t\t/* leave addresses as numbers */\n  int ndo_Nflag;\t\t/* remove domains from printed host names */\n  int ndo_qflag;\t\t/* quick (shorter) output */\n  int ndo_Sflag;\t\t/* print raw TCP sequence numbers */\n  int ndo_tflag;\t\t/* print packet arrival time */\n  int ndo_uflag;\t\t/* Print undecoded NFS handles */\n  int ndo_vflag;\t\t/* verbosity level */\n  int ndo_xflag;\t\t/* print packet in hex */\n  int ndo_Xflag;\t\t/* print packet in hex/ASCII */\n  int ndo_Aflag;\t\t/* print packet only in ASCII observing TAB,\n\t\t\t\t * LF, CR and SPACE as graphical chars\n\t\t\t\t */\n  int ndo_Hflag;\t\t/* dissect 802.11s draft mesh standard */\n  const char *ndo_protocol;\t/* protocol */\n  jmp_buf ndo_early_end;\t/* jmp_buf for setjmp()/longjmp() */\n  void *ndo_last_mem_p;\t\t/* pointer to the last allocated memory chunk */\n  int ndo_packet_number;\t/* print a packet number in the beginning of line */\n  int ndo_suppress_default_print; /* don't use default_print() for unknown packet types */\n  int ndo_tstamp_precision;\t/* requested time stamp precision */\n  const char *program_name;\t/* Name of the program using the library */\n\n  char *ndo_espsecret;\n  struct sa_list *ndo_sa_list_head;  /* used by print-esp.c */\n  struct sa_list *ndo_sa_default;\n\n  char *ndo_sigsecret;\t\t/* Signature verification secret key */\n\n  int   ndo_packettype;\t/* as specified by -T */\n\n  int   ndo_snaplen;\n  int   ndo_ll_hdr_len;\t/* link-layer header length */\n\n  /*global pointers to beginning and end of current packet (during printing) */\n  const u_char *ndo_packetp;\n  const u_char *ndo_snapend;\n\n  /* stack of saved packet boundary and buffer information */\n  struct netdissect_saved_packet_info *ndo_packet_info_stack;\n\n  /* pointer to the if_printer function */\n  if_printer ndo_if_printer;\n\n  /* pointer to void function to output stuff */\n  void (*ndo_default_print)(netdissect_options *,\n\t\t\t    const u_char *bp, u_int length);\n\n  /* pointer to function to do regular output */\n  int  (*ndo_printf)(netdissect_options *,\n\t\t     const char *fmt, ...)\n\t\t     PRINTFLIKE_FUNCPTR(2, 3);\n  /* pointer to function to output errors */\n  void NORETURN_FUNCPTR (*ndo_error)(netdissect_options *,\n\t\t\t\t     status_exit_codes_t status,\n\t\t\t\t     const char *fmt, ...)\n\t\t\t\t     PRINTFLIKE_FUNCPTR(3, 4);\n  /* pointer to function to output warnings */\n  void (*ndo_warning)(netdissect_options *,\n\t\t      const char *fmt, ...)\n\t\t      PRINTFLIKE_FUNCPTR(2, 3);\n};\n\nextern WARN_UNUSED_RESULT int nd_push_buffer(netdissect_options *, u_char *, const u_char *, const u_int);\nextern WARN_UNUSED_RESULT int nd_push_snaplen(netdissect_options *, const u_char *, const u_int);\nextern void nd_change_snaplen(netdissect_options *, const u_char *, const u_int);\nextern void nd_pop_packet_info(netdissect_options *);\nextern void nd_pop_all_packet_info(netdissect_options *);\n\nstatic inline NORETURN void\nnd_trunc_longjmp(netdissect_options *ndo)\n{\n\tlongjmp(ndo->ndo_early_end, ND_TRUNCATED);\n#ifdef _AIX\n\t/*\n\t * In AIX <setjmp.h> decorates longjmp() with \"#pragma leaves\", which tells\n\t * XL C that the function is noreturn, but GCC remains unaware of that and\n\t * yields a \"'noreturn' function does return\" warning.\n\t */\n\tND_UNREACHABLE\n#endif /* _AIX */\n}\n\n#define PT_VAT\t\t1\t/* Visual Audio Tool */\n#define PT_WB\t\t2\t/* distributed White Board */\n#define PT_RPC\t\t3\t/* Remote Procedure Call */\n#define PT_RTP\t\t4\t/* Real-Time Applications protocol */\n#define PT_RTCP\t\t5\t/* Real-Time Applications control protocol */\n#define PT_SNMP\t\t6\t/* Simple Network Management Protocol */\n#define PT_CNFP\t\t7\t/* Cisco NetFlow protocol */\n#define PT_TFTP\t\t8\t/* trivial file transfer protocol */\n#define PT_AODV\t\t9\t/* Ad-hoc On-demand Distance Vector Protocol */\n#define PT_CARP\t\t10\t/* Common Address Redundancy Protocol */\n#define PT_RADIUS\t11\t/* RADIUS authentication Protocol */\n#define PT_ZMTP1\t12\t/* ZeroMQ Message Transport Protocol 1.0 */\n#define PT_VXLAN\t13\t/* Virtual eXtensible Local Area Network */\n#define PT_PGM\t\t14\t/* [UDP-encapsulated] Pragmatic General Multicast */\n#define PT_PGM_ZMTP1\t15\t/* ZMTP/1.0 inside PGM (native or UDP-encapsulated) */\n#define PT_LMP\t\t16\t/* Link Management Protocol */\n#define PT_RESP\t\t17\t/* RESP */\n#define PT_PTP\t\t18\t/* PTP */\n#define PT_SOMEIP\t19\t/* Autosar SOME/IP Protocol */\n#define PT_DOMAIN\t20\t/* Domain Name System (DNS) */\n\n#define ND_MIN(a,b) ((a)>(b)?(b):(a))\n#define ND_MAX(a,b) ((b)>(a)?(b):(a))\n\n/* For source or destination ports tests (UDP, TCP, ...) */\n#define IS_SRC_OR_DST_PORT(p) (sport == (p) || dport == (p))\n\n/*\n * Maximum snapshot length.  This should be enough to capture the full\n * packet on most network interfaces.\n *\n *\n * Somewhat arbitrary, but chosen to be:\n *\n *    1) big enough for maximum-size Linux loopback packets (65549)\n *       and some USB packets captured with USBPcap:\n *\n *           https://desowin.org/usbpcap/\n *\n *       (> 131072, < 262144)\n *\n * and\n *\n *    2) small enough not to cause attempts to allocate huge amounts of\n *       memory; some applications might use the snapshot length in a\n *       savefile header to control the size of the buffer they allocate,\n *       so a size of, say, 2^31-1 might not work well.\n *\n * XXX - does it need to be bigger still?  Note that, for versions of\n * libpcap with pcap_create()/pcap_activate(), if no -s flag is specified\n * or -s 0 is specified, we won't set the snapshot length at all, and will\n * let libpcap choose a snapshot length; newer versions may choose a bigger\n * value than 262144 for D-Bus, for example.\n */\n#define MAXIMUM_SNAPLEN\t262144\n\n/*\n * True if \"l\" bytes from \"p\" were captured.\n *\n * The \"ndo->ndo_snapend - (l) <= ndo->ndo_snapend\" checks to make sure\n * \"l\" isn't so large that \"ndo->ndo_snapend - (l)\" underflows.\n *\n * The check is for <= rather than < because \"l\" might be 0.\n *\n * We cast the pointers to uintptr_t to make sure that the compiler\n * doesn't optimize away any of these tests (which it is allowed to\n * do, as adding an integer to, or subtracting an integer from, a\n * pointer assumes that the pointer is a pointer to an element of an\n * array and that the result of the addition or subtraction yields a\n * pointer to another member of the array, so that, for example, if\n * you subtract a positive integer from a pointer, the result is\n * guaranteed to be less than the original pointer value). See\n *\n *\thttps://www.kb.cert.org/vuls/id/162289\n */\n\n/*\n * Test in two parts to avoid these warnings:\n * comparison of unsigned expression >= 0 is always true [-Wtype-limits],\n * comparison is always true due to limited range of data type [-Wtype-limits].\n */\n#define IS_NOT_NEGATIVE(x) (((x) > 0) || ((x) == 0))\n\n#define ND_TTEST_LEN(p, l) \\\n  (IS_NOT_NEGATIVE(l) && \\\n\t((uintptr_t)ndo->ndo_snapend - (l) <= (uintptr_t)ndo->ndo_snapend && \\\n         (uintptr_t)(p) <= (uintptr_t)ndo->ndo_snapend - (l)))\n\n/* True if \"*(p)\" was captured */\n#define ND_TTEST_SIZE(p) ND_TTEST_LEN(p, sizeof(*(p)))\n\n/* Bail out if \"l\" bytes from \"p\" were not captured */\n#ifdef ND_LONGJMP_FROM_TCHECK\n#define ND_TCHECK_LEN(p, l) if (!ND_TTEST_LEN(p, l)) nd_trunc_longjmp(ndo)\n#else\n#define ND_TCHECK_LEN(p, l) if (!ND_TTEST_LEN(p, l)) goto trunc\n#endif\n\n/* Bail out if \"*(p)\" was not captured */\n#define ND_TCHECK_SIZE(p) ND_TCHECK_LEN(p, sizeof(*(p)))\n\n/*\n * Number of bytes between two pointers.\n */\n#define ND_BYTES_BETWEEN(p1, p2) ((u_int)(((const uint8_t *)(p1)) - (const uint8_t *)(p2)))\n\n/*\n * Number of bytes remaining in the captured data, starting at the\n * byte pointed to by the argument.\n */\n#define ND_BYTES_AVAILABLE_AFTER(p) ND_BYTES_BETWEEN(ndo->ndo_snapend, (p))\n\n/* Check length < minimum for invalid packet with a custom message, format %u */\n#define ND_LCHECKMSG_U(length, minimum, what) \\\nif ((length) < (minimum)) { \\\nND_PRINT(\" [%s %u < %u]\", (what), (length), (minimum)); \\\ngoto invalid; \\\n}\n\n/* Check length < minimum for invalid packet with #length message, format %u */\n#define ND_LCHECK_U(length, minimum) \\\nND_LCHECKMSG_U((length), (minimum), (#length))\n\n/* Check length < minimum for invalid packet with a custom message, format %zu */\n#define ND_LCHECKMSG_ZU(length, minimum, what) \\\nif ((length) < (minimum)) { \\\nND_PRINT(\" [%s %u < %zu]\", (what), (length), (minimum)); \\\ngoto invalid; \\\n}\n\n/* Check length < minimum for invalid packet with #length message, format %zu */\n#define ND_LCHECK_ZU(length, minimum) \\\nND_LCHECKMSG_ZU((length), (minimum), (#length))\n\n#define ND_PRINT(...) (ndo->ndo_printf)(ndo, __VA_ARGS__)\n#define ND_DEFAULTPRINT(ap, length) (*ndo->ndo_default_print)(ndo, ap, length)\n\nextern void ts_print(netdissect_options *, const struct timeval *);\nextern void signed_relts_print(netdissect_options *, int32_t);\nextern void unsigned_relts_print(netdissect_options *, uint32_t);\n\nextern const char *nd_format_time(char *buf, size_t bufsize,\n    const char *format, const struct tm *timeptr);\n\nextern void fn_print_char(netdissect_options *, u_char);\nextern void fn_print_str(netdissect_options *, const u_char *);\nextern u_int nd_printztn(netdissect_options *, const u_char *, u_int, const u_char *);\nextern int nd_printn(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void nd_printjnp(netdissect_options *, const u_char *, u_int);\n\n/*\n * Flags for txtproto_print().\n */\n#define RESP_CODE_SECOND_TOKEN\t0x00000001\t/* response code is second token in response line */\n\nextern void txtproto_print(netdissect_options *, const u_char *, u_int,\n\t\t\t   const char **, u_int);\n\n#if (defined(__i386__) || defined(_M_IX86) || defined(__X86__) || defined(__x86_64__) || defined(_M_X64)) || \\\n    (defined(__arm__) || defined(_M_ARM) || defined(__aarch64__)) || \\\n    (defined(__m68k__) && (!defined(__mc68000__) && !defined(__mc68010__))) || \\\n    (defined(__ppc__) || defined(__ppc64__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)) || \\\n    (defined(__s390__) || defined(__s390x__) || defined(__zarch__)) || \\\n    defined(__vax__)\n/*\n * The processor natively handles unaligned loads, so just use memcpy()\n * and memcmp(), to enable those optimizations.\n *\n * XXX - are those all the x86 tests we need?\n * XXX - do we need to worry about ARMv1 through ARMv5, which didn't\n * support unaligned loads, and, if so, do we need to worry about all\n * of them, or just some of them, e.g. ARMv5?\n * XXX - are those the only 68k tests we need not to generated\n * unaligned accesses if the target is the 68000 or 68010?\n * XXX - are there any tests we don't need, because some definitions are for\n * compilers that also predefine the GCC symbols?\n * XXX - do we need to test for both 32-bit and 64-bit versions of those\n * architectures in all cases?\n */\n#define UNALIGNED_MEMCPY(p, q, l)\tmemcpy((p), (q), (l))\n#define UNALIGNED_MEMCMP(p, q, l)\tmemcmp((p), (q), (l))\n#else\n/*\n * The processor doesn't natively handle unaligned loads,\n * and the compiler might \"helpfully\" optimize memcpy()\n * and memcmp(), when handed pointers that would normally\n * be properly aligned, into sequences that assume proper\n * alignment.\n *\n * Do copies and compares of possibly-unaligned data by\n * calling routines that wrap memcpy() and memcmp(), to\n * prevent that optimization.\n */\nextern void unaligned_memcpy(void *, const void *, size_t);\nextern int unaligned_memcmp(const void *, const void *, size_t);\n#define UNALIGNED_MEMCPY(p, q, l)\tunaligned_memcpy((p), (q), (l))\n#define UNALIGNED_MEMCMP(p, q, l)\tunaligned_memcmp((p), (q), (l))\n#endif\n\n#define PLURAL_SUFFIX(n) \\\n\t(((n) != 1) ? \"s\" : \"\")\n\nextern const char *tok2strary_internal(const char **, int, const char *, int);\n#define\ttok2strary(a,f,i) tok2strary_internal(a, sizeof(a)/sizeof(a[0]),f,i)\n\nstruct uint_tokary\n{\n\tu_int uintval;\n\tconst struct tok *tokary;\n};\n\nextern const struct tok *uint2tokary_internal(const struct uint_tokary[], const size_t, const u_int);\n#define uint2tokary(a, i) uint2tokary_internal(a, sizeof(a)/sizeof(a[0]), i)\n\nextern if_printer lookup_printer(int);\n\n#define ND_DEBUG {printf(\" [%s:%d %s] \", __FILE__, __LINE__, __func__); fflush(stdout);}\n\n/* The DLT printer routines */\n\nextern void ap1394_if_print IF_PRINTER_ARGS;\nextern void arcnet_if_print IF_PRINTER_ARGS;\nextern void arcnet_linux_if_print IF_PRINTER_ARGS;\nextern void atm_if_print IF_PRINTER_ARGS;\nextern void brcm_tag_if_print IF_PRINTER_ARGS;\nextern void brcm_tag_prepend_if_print IF_PRINTER_ARGS;\nextern void bt_if_print IF_PRINTER_ARGS;\nextern void chdlc_if_print IF_PRINTER_ARGS;\nextern void cip_if_print IF_PRINTER_ARGS;\nextern void dsa_if_print IF_PRINTER_ARGS;\nextern void edsa_if_print IF_PRINTER_ARGS;\nextern void enc_if_print IF_PRINTER_ARGS;\nextern void ether_if_print IF_PRINTER_ARGS;\nextern void fddi_if_print IF_PRINTER_ARGS;\nextern void fr_if_print IF_PRINTER_ARGS;\nextern void ieee802_11_if_print IF_PRINTER_ARGS;\nextern void ieee802_11_radio_avs_if_print IF_PRINTER_ARGS;\nextern void ieee802_11_radio_if_print IF_PRINTER_ARGS;\nextern void ieee802_15_4_if_print IF_PRINTER_ARGS;\nextern void ieee802_15_4_tap_if_print IF_PRINTER_ARGS;\nextern void ipfc_if_print IF_PRINTER_ARGS;\nextern void ipnet_if_print IF_PRINTER_ARGS;\nextern void ipoib_if_print IF_PRINTER_ARGS;\nextern void juniper_atm1_if_print IF_PRINTER_ARGS;\nextern void juniper_atm2_if_print IF_PRINTER_ARGS;\nextern void juniper_chdlc_if_print IF_PRINTER_ARGS;\nextern void juniper_es_if_print IF_PRINTER_ARGS;\nextern void juniper_ether_if_print IF_PRINTER_ARGS;\nextern void juniper_frelay_if_print IF_PRINTER_ARGS;\nextern void juniper_ggsn_if_print IF_PRINTER_ARGS;\nextern void juniper_mfr_if_print IF_PRINTER_ARGS;\nextern void juniper_mlfr_if_print IF_PRINTER_ARGS;\nextern void juniper_mlppp_if_print IF_PRINTER_ARGS;\nextern void juniper_monitor_if_print IF_PRINTER_ARGS;\nextern void juniper_ppp_if_print IF_PRINTER_ARGS;\nextern void juniper_pppoe_atm_if_print IF_PRINTER_ARGS;\nextern void juniper_pppoe_if_print IF_PRINTER_ARGS;\nextern void juniper_services_if_print IF_PRINTER_ARGS;\nextern void ltalk_if_print IF_PRINTER_ARGS;\nextern void mfr_if_print IF_PRINTER_ARGS;\nextern void netanalyzer_if_print IF_PRINTER_ARGS;\nextern void netanalyzer_transparent_if_print IF_PRINTER_ARGS;\nextern void nflog_if_print IF_PRINTER_ARGS;\nextern void null_if_print IF_PRINTER_ARGS;\nextern void pflog_if_print IF_PRINTER_ARGS;\nextern void pktap_if_print IF_PRINTER_ARGS;\nextern void ppi_if_print IF_PRINTER_ARGS;\nextern void ppp_bsdos_if_print IF_PRINTER_ARGS;\nextern void ppp_hdlc_if_print IF_PRINTER_ARGS;\nextern void ppp_if_print IF_PRINTER_ARGS;\nextern void pppoe_if_print IF_PRINTER_ARGS;\nextern void prism_if_print IF_PRINTER_ARGS;\nextern void raw_if_print IF_PRINTER_ARGS;\nextern void sl_bsdos_if_print IF_PRINTER_ARGS;\nextern void sl_if_print IF_PRINTER_ARGS;\nextern void sll2_if_print IF_PRINTER_ARGS;\nextern void sll_if_print IF_PRINTER_ARGS;\nextern void sunatm_if_print IF_PRINTER_ARGS;\nextern void symantec_if_print IF_PRINTER_ARGS;\nextern void token_if_print IF_PRINTER_ARGS;\nextern void unsupported_if_print IF_PRINTER_ARGS;\nextern void usb_linux_48_byte_if_print IF_PRINTER_ARGS;\nextern void usb_linux_64_byte_if_print IF_PRINTER_ARGS;\nextern void vsock_if_print IF_PRINTER_ARGS;\n\n/*\n * Structure passed to some printers to allow them to print\n * link-layer address information if ndo_eflag isn't set\n * (because they are for protocols that don't have their\n * own addresses, so that we'd want to report link-layer\n * address information).\n *\n * This contains a pointer to an address and a pointer to a routine\n * to which we pass that pointer in order to get a string.\n */\nstruct lladdr_info {\n\tconst char *(*addr_string)(netdissect_options *, const u_char *);\n\tconst u_char *addr;\n};\n\n/* The printer routines. */\n\nextern void aarp_print(netdissect_options *, const u_char *, u_int);\nextern int ah_print(netdissect_options *, const u_char *);\nextern void ahcp_print(netdissect_options *, const u_char *, u_int);\nextern void aodv_print(netdissect_options *, const u_char *, u_int, int);\nextern void aoe_print(netdissect_options *, const u_char *, const u_int);\nextern int  arista_ethertype_print(netdissect_options *,const u_char *, u_int);\nextern void arp_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void ascii_print(netdissect_options *, const u_char *, u_int);\nextern void atalk_print(netdissect_options *, const u_char *, u_int);\nextern void atm_print(netdissect_options *, u_int, u_int, u_int, const u_char *, u_int, u_int);\nextern void babel_print(netdissect_options *, const u_char *, u_int);\nextern void bcm_li_print(netdissect_options *, const u_char *, u_int);\nextern void beep_print(netdissect_options *, const u_char *, u_int);\nextern void bfd_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void bgp_print(netdissect_options *, const u_char *, u_int);\nextern const char *bgp_vpn_rd_print(netdissect_options *, const u_char *);\nextern void bootp_print(netdissect_options *, const u_char *, u_int);\nextern void calm_fast_print(netdissect_options *, const u_char *, u_int, const struct lladdr_info *);\nextern void carp_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void cdp_print(netdissect_options *, const u_char *, u_int);\nextern void cfm_print(netdissect_options *, const u_char *, u_int);\nextern u_int chdlc_print(netdissect_options *, const u_char *, u_int);\nextern void cisco_autorp_print(netdissect_options *, const u_char *, u_int);\nextern void cnfp_print(netdissect_options *, const u_char *);\nextern void dccp_print(netdissect_options *, const u_char *, const u_char *, u_int);\nextern void decnet_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void dhcp6_print(netdissect_options *, const u_char *, u_int);\nextern int dstopt_process(netdissect_options *, const u_char *);\nextern void dtp_print(netdissect_options *, const u_char *, u_int);\nextern void dvmrp_print(netdissect_options *, const u_char *, u_int);\nextern void eap_print(netdissect_options *, const u_char *, u_int);\nextern void eapol_print(netdissect_options *, const u_char *);\nextern void egp_print(netdissect_options *, const u_char *, u_int);\nextern void eigrp_print(netdissect_options *, const u_char *, u_int);\nextern void esp_print(netdissect_options *, const u_char *, u_int, const u_char *, u_int, int, u_int);\nextern u_int ether_print(netdissect_options *, const u_char *, u_int, u_int, void (*)(netdissect_options *, const u_char *), const u_char *);\nextern u_int ether_switch_tag_print(netdissect_options *, const u_char *, u_int, u_int, void (*)(netdissect_options *, const u_char *), u_int);\nextern int ethertype_print(netdissect_options *, u_short, const u_char *, u_int, u_int, const struct lladdr_info *, const struct lladdr_info *);\nextern u_int fddi_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void forces_print(netdissect_options *, const u_char *, u_int);\nextern u_int fr_print(netdissect_options *, const u_char *, u_int);\nextern int frag6_print(netdissect_options *, const u_char *, const u_char *);\nextern void ftp_print(netdissect_options *, const u_char *, u_int);\nextern void geneve_print(netdissect_options *, const u_char *, u_int);\nextern void geonet_print(netdissect_options *, const u_char *, u_int, const struct lladdr_info *);\nextern void gre_print(netdissect_options *, const u_char *, u_int);\nextern int hbhopt_process(netdissect_options *, const u_char *, int *, uint32_t *);\nextern void hex_and_ascii_print(netdissect_options *, const char *, const u_char *, u_int);\nextern void hex_print(netdissect_options *, const char *ident, const u_char *cp, u_int);\nextern void hex_print_with_offset(netdissect_options *, const char *ident, const u_char *cp, u_int, u_int);\nextern void hncp_print(netdissect_options *, const u_char *, u_int);\nextern void hsrp_print(netdissect_options *, const u_char *, u_int);\nextern void http_print(netdissect_options *, const u_char *, u_int);\nextern void icmp6_print(netdissect_options *, const u_char *, u_int, const u_char *, int);\nextern void icmp_print(netdissect_options *, const u_char *, u_int, const u_char *, int);\nextern u_int ieee802_15_4_print(netdissect_options *, const u_char *, u_int);\nextern u_int ieee802_11_radio_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void igmp_print(netdissect_options *, const u_char *, u_int);\nextern void igrp_print(netdissect_options *, const u_char *, u_int);\nextern void ip6_print(netdissect_options *, const u_char *, u_int);\nextern void ipN_print(netdissect_options *, const u_char *, u_int);\nextern void ip_print(netdissect_options *, const u_char *, u_int);\nextern void ipcomp_print(netdissect_options *, const u_char *);\nextern void ipx_netbios_print(netdissect_options *, const u_char *, u_int);\nextern void ipx_print(netdissect_options *, const u_char *, u_int);\nextern void isakmp_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void isakmp_rfc3948_print(netdissect_options *, const u_char *, u_int, const u_char *, int, int, u_int);\nextern void isoclns_print(netdissect_options *, const u_char *, u_int);\nextern void krb_print(netdissect_options *, const u_char *);\nextern void l2tp_print(netdissect_options *, const u_char *, u_int);\nextern void lane_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void ldp_print(netdissect_options *, const u_char *, u_int);\nextern void lisp_print(netdissect_options *, const u_char *, u_int);\nextern u_int llap_print(netdissect_options *, const u_char *, u_int);\nextern int llc_print(netdissect_options *, const u_char *, u_int, u_int, const struct lladdr_info *, const struct lladdr_info *);\nextern void lldp_print(netdissect_options *, const u_char *, u_int);\nextern void lmp_print(netdissect_options *, const u_char *, u_int);\nextern void loopback_print(netdissect_options *, const u_char *, u_int);\nextern void lspping_print(netdissect_options *, const u_char *, u_int);\nextern void lwapp_control_print(netdissect_options *, const u_char *, u_int, int);\nextern void lwapp_data_print(netdissect_options *, const u_char *, u_int);\nextern void lwres_print(netdissect_options *, const u_char *, u_int);\nextern void m3ua_print(netdissect_options *, const u_char *, const u_int);\nextern int macsec_print(netdissect_options *, const u_char **,\n\t\t\t u_int *, u_int *, u_int *, const struct lladdr_info *,\n\t\t\t const struct lladdr_info *);\nextern u_int mfr_print(netdissect_options *, const u_char *, u_int);\nextern void mobile_print(netdissect_options *, const u_char *, u_int);\nextern int mobility_print(netdissect_options *, const u_char *, const u_char *);\nextern void mpcp_print(netdissect_options *, const u_char *, u_int);\nextern void mpls_print(netdissect_options *, const u_char *, u_int);\nextern int mptcp_print(netdissect_options *, const u_char *, u_int, u_char);\nextern void msdp_print(netdissect_options *, const u_char *, u_int);\nextern void msnlb_print(netdissect_options *, const u_char *);\nextern void nbt_tcp_print(netdissect_options *, const u_char *, u_int);\nextern void nbt_udp137_print(netdissect_options *, const u_char *, u_int);\nextern void nbt_udp138_print(netdissect_options *, const u_char *, u_int);\nextern void netbeui_print(netdissect_options *, u_short, const u_char *, u_int);\nextern void nfsreply_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void nfsreply_noaddr_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void nfsreq_noaddr_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern const u_char *fqdn_print(netdissect_options *, const u_char *, const u_char *);\nextern void domain_print(netdissect_options *, const u_char *, u_int, int, int);\nextern void nsh_print(netdissect_options *, const u_char *, u_int);\nextern void ntp_print(netdissect_options *, const u_char *, u_int);\nextern void oam_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void olsr_print(netdissect_options *, const u_char *, u_int, int);\nextern void openflow_print(netdissect_options *, const u_char *, u_int);\nextern void ospf6_print(netdissect_options *, const u_char *, u_int);\nextern void ospf_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern int ospf_grace_lsa_print(netdissect_options *, const u_char *, u_int);\nextern int ospf_te_lsa_print(netdissect_options *, const u_char *, u_int);\nextern void otv_print(netdissect_options *, const u_char *, u_int);\nextern void pgm_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void pim_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void pimv1_print(netdissect_options *, const u_char *, u_int);\nextern u_int ppp_print(netdissect_options *, const u_char *, u_int);\nextern u_int pppoe_print(netdissect_options *, const u_char *, u_int);\nextern void pptp_print(netdissect_options *, const u_char *);\nextern void ptp_print(netdissect_options *, const u_char *, u_int);\nextern int print_unknown_data(netdissect_options *, const u_char *, const char *, u_int);\nextern const char *q922_string(netdissect_options *, const u_char *, u_int);\nextern void q933_print(netdissect_options *, const u_char *, u_int);\nextern void radius_print(netdissect_options *, const u_char *, u_int);\nextern void resp_print(netdissect_options *, const u_char *, u_int);\nextern void rip_print(netdissect_options *, const u_char *, u_int);\nextern void ripng_print(netdissect_options *, const u_char *, unsigned int);\nextern void rpki_rtr_print(netdissect_options *, const u_char *, u_int);\nextern void rsvp_print(netdissect_options *, const u_char *, u_int);\nextern int rt6_print(netdissect_options *, const u_char *, const u_char *);\nextern void rtl_print(netdissect_options *, const u_char *, u_int, const struct lladdr_info *, const struct lladdr_info *);\nextern void rtsp_print(netdissect_options *, const u_char *, u_int);\nextern void rx_print(netdissect_options *, const u_char *, u_int, uint16_t, uint16_t, const u_char *);\nextern void sctp_print(netdissect_options *, const u_char *, const u_char *, u_int);\nextern void sflow_print(netdissect_options *, const u_char *, u_int);\nextern void ssh_print(netdissect_options *, const u_char *, u_int);\nextern void sip_print(netdissect_options *, const u_char *, u_int);\nextern void slow_print(netdissect_options *, const u_char *, u_int);\nextern void smb_tcp_print(netdissect_options *, const u_char *, u_int);\nextern void smtp_print(netdissect_options *, const u_char *, u_int);\nextern int snap_print(netdissect_options *, const u_char *, u_int, u_int, const struct lladdr_info *, const struct lladdr_info *, u_int);\nextern void snmp_print(netdissect_options *, const u_char *, u_int);\nextern void stp_print(netdissect_options *, const u_char *, u_int);\nextern void sunrpc_print(netdissect_options *, const u_char *, u_int, const u_char *);\nextern void syslog_print(netdissect_options *, const u_char *, u_int);\nextern void tcp_print(netdissect_options *, const u_char *, u_int, const u_char *, int);\nextern void telnet_print(netdissect_options *, const u_char *, u_int);\nextern void tftp_print(netdissect_options *, const u_char *, u_int);\nextern void timed_print(netdissect_options *, const u_char *);\nextern void tipc_print(netdissect_options *, const u_char *, u_int, u_int);\nextern u_int token_print(netdissect_options *, const u_char *, u_int, u_int);\nextern void udld_print(netdissect_options *, const u_char *, u_int);\nextern void udp_print(netdissect_options *, const u_char *, u_int, const u_char *, int, u_int);\nextern int vjc_print(netdissect_options *, const u_char *, u_short);\nextern void vqp_print(netdissect_options *, const u_char *, u_int);\nextern void vrrp_print(netdissect_options *, const u_char *, u_int, const u_char *, int, int);\nextern void vtp_print(netdissect_options *, const u_char *, const u_int);\nextern void vxlan_gpe_print(netdissect_options *, const u_char *, u_int);\nextern void vxlan_print(netdissect_options *, const u_char *, u_int);\nextern void wb_print(netdissect_options *, const u_char *, u_int);\nextern void whois_print(netdissect_options *, const u_char *, u_int);\nextern void zep_print(netdissect_options *, const u_char *, u_int);\nextern void zephyr_print(netdissect_options *, const u_char *, u_int);\nextern void zmtp1_print(netdissect_options *, const u_char *, u_int);\nextern void zmtp1_datagram_print(netdissect_options *, const u_char *, const u_int);\nextern void someip_print(netdissect_options *, const u_char *, const u_int);\n\n/* checksum routines */\nextern void init_checksum(void);\nextern uint16_t verify_crc10_cksum(uint16_t, const u_char *, int);\nextern uint16_t create_osi_cksum(const uint8_t *, int, int);\n\nstruct cksum_vec {\n\tconst uint8_t\t*ptr;\n\tint\t\tlen;\n};\nextern uint16_t in_cksum(const struct cksum_vec *, int);\nextern uint16_t in_cksum_shouldbe(uint16_t, uint16_t);\n\n/* IP protocol demuxing routines */\nextern void ip_demux_print(netdissect_options *, const u_char *, u_int, u_int, int, u_int, uint8_t, const u_char *);\n\nextern uint16_t nextproto4_cksum(netdissect_options *, const struct ip *, const uint8_t *, u_int, u_int, uint8_t);\n\n/* in print-ip6.c */\nextern uint16_t nextproto6_cksum(netdissect_options *, const struct ip6_hdr *, const uint8_t *, u_int, u_int, uint8_t);\n\n/* Utilities */\nextern void nd_print_trunc(netdissect_options *);\nextern void nd_print_protocol(netdissect_options *);\nextern void nd_print_protocol_caps(netdissect_options *);\nextern void nd_print_invalid(netdissect_options *);\n\nextern int mask2plen(uint32_t);\nextern int mask62plen(const u_char *);\n\nextern const char *dnnum_string(netdissect_options *, u_short);\n\nextern int decode_prefix4(netdissect_options *, const u_char *, u_int, char *, size_t);\nextern int decode_prefix6(netdissect_options *, const u_char *, u_int, char *, size_t);\n\nextern void esp_decodesecret_print(netdissect_options *);\nextern int esp_decrypt_buffer_by_ikev2_print(netdissect_options *, int,\n\t\t\t\t\t     const u_char spii[8],\n\t\t\t\t\t     const u_char spir[8],\n\t\t\t\t\t     const u_char *, const u_char *);\n\n#endif  /* netdissect_h */\n", "/*\n * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ntp.h\"\n\n#include \"extract.h\"\n\n#define\tJAN_1970\tINT64_T_CONSTANT(2208988800)\t/* 1970 - 1900 in seconds */\n\nvoid\np_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t/* some compilers are buggy */\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t/* shift radix point by 32 bits */\n\tf = (uint32_t)(ff * 1000000000.0);\t/* treat fraction as parts per billion */\n\tND_PRINT(\"%u.%09u\", i, f);\n\n\t/*\n\t * print the UTC time in human-readable format.\n\t */\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    char time_buf[128];\n\t    const char *time_string;\n\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\t/*\n\t\t * It doesn't fit into a time_t, so we can't hand it\n\t\t * to gmtime.\n\t\t */\n\t\ttime_string = \"[Time is too large to fit into a time_t]\";\n\t    } else {\n\t\t/* use ISO 8601 (RFC3339) format */\n\t\ttime_string = nd_format_time(time_buf, sizeof (time_buf),\n\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&seconds));\n\t    }\n\t    ND_PRINT(\" (%s)\", time_string);\n\t}\n}\n", "/*\n * Copyright (c) 2013 The TCPDUMP project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* \\summary: Ad Hoc Configuration Protocol (AHCP) printer */\n\n/* Based on draft-chroboczek-ahcp-00 and source code of ahcpd-0.53 */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#define ND_LONGJMP_FROM_TCHECK\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n\n\n#define AHCP_MAGIC_NUMBER 43\n#define AHCP_VERSION_1 1\n#define AHCP1_HEADER_FIX_LEN 24\n#define AHCP1_BODY_MIN_LEN 4\n\n#define AHCP1_MSG_DISCOVER 0\n#define AHCP1_MSG_OFFER    1\n#define AHCP1_MSG_REQUEST  2\n#define AHCP1_MSG_ACK      3\n#define AHCP1_MSG_NACK     4\n#define AHCP1_MSG_RELEASE  5\n\nstatic const struct tok ahcp1_msg_str[] = {\n\t{ AHCP1_MSG_DISCOVER, \"Discover\" },\n\t{ AHCP1_MSG_OFFER,    \"Offer\"    },\n\t{ AHCP1_MSG_REQUEST,  \"Request\"  },\n\t{ AHCP1_MSG_ACK,      \"Ack\"      },\n\t{ AHCP1_MSG_NACK,     \"Nack\"     },\n\t{ AHCP1_MSG_RELEASE,  \"Release\"  },\n\t{ 0, NULL }\n};\n\n#define AHCP1_OPT_PAD                     0\n#define AHCP1_OPT_MANDATORY               1\n#define AHCP1_OPT_ORIGIN_TIME             2\n#define AHCP1_OPT_EXPIRES                 3\n#define AHCP1_OPT_MY_IPV6_ADDRESS         4\n#define AHCP1_OPT_MY_IPV4_ADDRESS         5\n#define AHCP1_OPT_IPV6_PREFIX             6\n#define AHCP1_OPT_IPV4_PREFIX             7\n#define AHCP1_OPT_IPV6_ADDRESS            8\n#define AHCP1_OPT_IPV4_ADDRESS            9\n#define AHCP1_OPT_IPV6_PREFIX_DELEGATION 10\n#define AHCP1_OPT_IPV4_PREFIX_DELEGATION 11\n#define AHCP1_OPT_NAME_SERVER            12\n#define AHCP1_OPT_NTP_SERVER             13\n#define AHCP1_OPT_MAX                    13\n\nstatic const struct tok ahcp1_opt_str[] = {\n\t{ AHCP1_OPT_PAD,                    \"Pad\"                    },\n\t{ AHCP1_OPT_MANDATORY,              \"Mandatory\"              },\n\t{ AHCP1_OPT_ORIGIN_TIME,            \"Origin Time\"            },\n\t{ AHCP1_OPT_EXPIRES,                \"Expires\"                },\n\t{ AHCP1_OPT_MY_IPV6_ADDRESS,        \"My-IPv6-Address\"        },\n\t{ AHCP1_OPT_MY_IPV4_ADDRESS,        \"My-IPv4-Address\"        },\n\t{ AHCP1_OPT_IPV6_PREFIX,            \"IPv6 Prefix\"            },\n\t{ AHCP1_OPT_IPV4_PREFIX,            \"IPv4 Prefix\"            },\n\t{ AHCP1_OPT_IPV6_ADDRESS,           \"IPv6 Address\"           },\n\t{ AHCP1_OPT_IPV4_ADDRESS,           \"IPv4 Address\"           },\n\t{ AHCP1_OPT_IPV6_PREFIX_DELEGATION, \"IPv6 Prefix Delegation\" },\n\t{ AHCP1_OPT_IPV4_PREFIX_DELEGATION, \"IPv4 Prefix Delegation\" },\n\t{ AHCP1_OPT_NAME_SERVER,            \"Name Server\"            },\n\t{ AHCP1_OPT_NTP_SERVER,             \"NTP Server\"             },\n\t{ 0, NULL }\n};\n\nstatic void\nahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd hh:mm:ss UTC\")];\n\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tND_PRINT(\": %s\",\n\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S UTC\",\n\t      gmtime(&t)));\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_seconds_print(netdissect_options *ndo,\n                   const u_char *cp, uint8_t len)\n{\n\tif (len != 4)\n\t\tgoto invalid;\n\tND_PRINT(\": %us\", GET_BE_U_4(cp));\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv6_addresses_print(netdissect_options *ndo,\n                          const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 16)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s\", sep, GET_IP6ADDR_STRING(cp));\n\t\tcp += 16;\n\t\tlen -= 16;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv4_addresses_print(netdissect_options *ndo,\n                          const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 4)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s\", sep, GET_IPADDR_STRING(cp));\n\t\tcp += 4;\n\t\tlen -= 4;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv6_prefixes_print(netdissect_options *ndo,\n                         const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 17)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s/%u\", sep, GET_IP6ADDR_STRING(cp), GET_U_1(cp + 16));\n\t\tcp += 17;\n\t\tlen -= 17;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp_ipv4_prefixes_print(netdissect_options *ndo,\n                         const u_char *cp, uint8_t len)\n{\n\tconst char *sep = \": \";\n\n\twhile (len) {\n\t\tif (len < 5)\n\t\t\tgoto invalid;\n\t\tND_PRINT(\"%s%s/%u\", sep, GET_IPADDR_STRING(cp), GET_U_1(cp + 4));\n\t\tcp += 5;\n\t\tlen -= 5;\n\t\tsep = \", \";\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\n(* const data_decoders[AHCP1_OPT_MAX + 1])(netdissect_options *, const u_char *, uint8_t) = {\n\t/* [AHCP1_OPT_PAD]                    = */  NULL,\n\t/* [AHCP1_OPT_MANDATORY]              = */  NULL,\n\t/* [AHCP1_OPT_ORIGIN_TIME]            = */  ahcp_time_print,\n\t/* [AHCP1_OPT_EXPIRES]                = */  ahcp_seconds_print,\n\t/* [AHCP1_OPT_MY_IPV6_ADDRESS]        = */  ahcp_ipv6_addresses_print,\n\t/* [AHCP1_OPT_MY_IPV4_ADDRESS]        = */  ahcp_ipv4_addresses_print,\n\t/* [AHCP1_OPT_IPV6_PREFIX]            = */  ahcp_ipv6_prefixes_print,\n\t/* [AHCP1_OPT_IPV4_PREFIX]            = */  NULL,\n\t/* [AHCP1_OPT_IPV6_ADDRESS]           = */  ahcp_ipv6_addresses_print,\n\t/* [AHCP1_OPT_IPV4_ADDRESS]           = */  ahcp_ipv4_addresses_print,\n\t/* [AHCP1_OPT_IPV6_PREFIX_DELEGATION] = */  ahcp_ipv6_prefixes_print,\n\t/* [AHCP1_OPT_IPV4_PREFIX_DELEGATION] = */  ahcp_ipv4_prefixes_print,\n\t/* [AHCP1_OPT_NAME_SERVER]            = */  ahcp_ipv6_addresses_print,\n\t/* [AHCP1_OPT_NTP_SERVER]             = */  ahcp_ipv6_addresses_print,\n};\n\nstatic void\nahcp1_options_print(netdissect_options *ndo,\n                    const u_char *cp, uint16_t len)\n{\n\twhile (len) {\n\t\tuint8_t option_no, option_len;\n\n\t\t/* Option no */\n\t\toption_no = GET_U_1(cp);\n\t\tcp += 1;\n\t\tlen -= 1;\n\t\tND_PRINT(\"\\n\\t %s\", tok2str(ahcp1_opt_str, \"Unknown-%u\", option_no));\n\t\tif (option_no == AHCP1_OPT_PAD || option_no == AHCP1_OPT_MANDATORY)\n\t\t\tcontinue;\n\t\t/* Length */\n\t\tif (!len)\n\t\t\tgoto invalid;\n\t\toption_len = GET_U_1(cp);\n\t\tcp += 1;\n\t\tlen -= 1;\n\t\tif (option_len > len)\n\t\t\tgoto invalid;\n\t\t/* Value */\n\t\tif (option_no <= AHCP1_OPT_MAX && data_decoders[option_no] != NULL) {\n\t\t\tdata_decoders[option_no](ndo, cp, option_len);\n\t\t} else {\n\t\t\tND_PRINT(\" (Length %u)\", option_len);\n\t\t\tND_TCHECK_LEN(cp, option_len);\n\t\t}\n\t\tcp += option_len;\n\t\tlen -= option_len;\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n\nstatic void\nahcp1_body_print(netdissect_options *ndo,\n                 const u_char *cp, u_int len)\n{\n\tuint8_t type, mbz;\n\tuint16_t body_len;\n\n\tif (len < AHCP1_BODY_MIN_LEN)\n\t\tgoto invalid;\n\t/* Type */\n\ttype = GET_U_1(cp);\n\tcp += 1;\n\tlen -= 1;\n\t/* MBZ */\n\tmbz = GET_U_1(cp);\n\tcp += 1;\n\tlen -= 1;\n\t/* Length */\n\tbody_len = GET_BE_U_2(cp);\n\tcp += 2;\n\tlen -= 2;\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT(\"\\n\\t%s\", tok2str(ahcp1_msg_str, \"Unknown-%u\", type));\n\t\tif (mbz != 0)\n\t\t\tND_PRINT(\", MBZ %u\", mbz);\n\t\tND_PRINT(\", Length %u\", body_len);\n\t}\n\tif (body_len > len)\n\t\tgoto invalid;\n\n\t/* Options */\n\t/* Here use \"body_len\", not \"len\" (ignore any extra data). */\n\tif (ndo->ndo_vflag >= 2)\n\t\tahcp1_options_print(ndo, cp, body_len);\n\telse\n\t\tND_TCHECK_LEN(cp, body_len);\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n\n}\n\nvoid\nahcp_print(netdissect_options *ndo,\n           const u_char *cp, u_int len)\n{\n\tuint8_t version;\n\n\tndo->ndo_protocol = \"ahcp\";\n\tnd_print_protocol_caps(ndo);\n\tif (len < 2)\n\t\tgoto invalid;\n\t/* Magic */\n\tif (GET_U_1(cp) != AHCP_MAGIC_NUMBER)\n\t\tgoto invalid;\n\tcp += 1;\n\tlen -= 1;\n\t/* Version */\n\tversion = GET_U_1(cp);\n\tcp += 1;\n\tlen -= 1;\n\tswitch (version) {\n\t\tcase AHCP_VERSION_1: {\n\t\t\tND_PRINT(\" Version 1\");\n\t\t\tif (len < AHCP1_HEADER_FIX_LEN - 2)\n\t\t\t\tgoto invalid;\n\t\t\tif (!ndo->ndo_vflag) {\n\t\t\t\tND_TCHECK_LEN(cp, AHCP1_HEADER_FIX_LEN - 2);\n\t\t\t\tcp += AHCP1_HEADER_FIX_LEN - 2;\n\t\t\t\tlen -= AHCP1_HEADER_FIX_LEN - 2;\n\t\t\t} else {\n\t\t\t\t/* Hopcount */\n\t\t\t\tND_PRINT(\"\\n\\tHopcount %u\", GET_U_1(cp));\n\t\t\t\tcp += 1;\n\t\t\t\tlen -= 1;\n\t\t\t\t/* Original Hopcount */\n\t\t\t\tND_PRINT(\", Original Hopcount %u\", GET_U_1(cp));\n\t\t\t\tcp += 1;\n\t\t\t\tlen -= 1;\n\t\t\t\t/* Nonce */\n\t\t\t\tND_PRINT(\", Nonce 0x%08x\", GET_BE_U_4(cp));\n\t\t\t\tcp += 4;\n\t\t\t\tlen -= 4;\n\t\t\t\t/* Source Id */\n\t\t\t\tND_PRINT(\", Source Id %s\", GET_LINKADDR_STRING(cp, LINKADDR_OTHER, 8));\n\t\t\t\tcp += 8;\n\t\t\t\tlen -= 8;\n\t\t\t\t/* Destination Id */\n\t\t\t\tND_PRINT(\", Destination Id %s\", GET_LINKADDR_STRING(cp, LINKADDR_OTHER, 8));\n\t\t\t\tcp += 8;\n\t\t\t\tlen -= 8;\n\t\t\t}\n\t\t\t/* Body */\n\t\t\tahcp1_body_print(ndo, cp, len);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tND_PRINT(\" Version %u (unknown)\", version);\n\t\t\tND_TCHECK_LEN(cp, len);\n\t\t\tbreak;\n\t}\n\treturn;\n\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}\n", "// Copyright (c) 2018 Arista Networks, Inc.  All rights reserved.\n\n/* \\summary: EtherType protocol for Arista Networks printer */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n\n/*\n\nFrom Bill Fenner:\n\nThe Arista timestamp header consists of the following fields:\n1. The Arista ethertype (0xd28b)\n2. A 2-byte subtype field; 0x01 indicates the timestamp header\n3. A 2-byte version field, described below.\n4. A 48-bit or 64-bit timestamp field, depending on the contents of the version field\n\nThis header is then followed by the original ethertype and the remainder of the original packet.\n\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            dst mac                            |\n+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                            src mac                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        ethertype 0xd28b       |          subtype 0x1          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            version            |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                          timestamp...                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe two-byte version value is split into 3 fields:\n1. The timescale in use.  Currently assigned values include:\n    0 = TAI\n    1 = UTC\n2. The timestamp format and length.  Currently assigned values include:\n    1 = 64-bit timestamp\n    2 = 48-bit timestamp\n3. The hardware info\n    0 = R/R2 series\n    1 = R3 series\n\n 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   timescale   | format|hw info|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\nSee also: https://www.arista.com/assets/data/pdf/Whitepapers/Overview_Arista_Timestamps.pdf\n\n*/\n\n#define ARISTA_SUBTYPE_TIMESTAMP 0x0001\nstatic const struct tok subtype_str[] = {\n\t{ ARISTA_SUBTYPE_TIMESTAMP, \"Timestamp\" },\n\t{ 0, NULL }\n};\n\nstatic const struct tok ts_timescale_str[] = {\n\t{ 0, \"TAI\" },\n\t{ 1, \"UTC\" },\n\t{ 0, NULL }\n};\n\n#define FORMAT_64BIT 0x1\n#define FORMAT_48BIT 0x2\nstatic const struct tok ts_format_str[] = {\n\t{ FORMAT_64BIT, \"64-bit\" },\n\t{ FORMAT_48BIT, \"48-bit\" },\n\t{ 0, NULL }\n};\n\nstatic const struct tok hw_info_str[] = {\n\t{ 0, \"R/R2\" },\n\t{ 1, \"R3\" },\n\t{ 0, NULL }\n};\n\nstatic inline void\narista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd hh:mm:ss\")];\n\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tND_PRINT(\"%s.%09u\",\n\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\",\n\t       gmtime(&ts)), nanoseconds);\n}\n\nint\narista_ethertype_print(netdissect_options *ndo, const u_char *bp, u_int len _U_)\n{\n\tuint16_t subTypeId;\n\tu_short bytesConsumed = 0;\n\n\tndo->ndo_protocol = \"arista\";\n\n\tsubTypeId = GET_BE_U_2(bp);\n\tbp += 2;\n\tbytesConsumed += 2;\n\n\tND_PRINT(\"SubType %s (0x%04x), \",\n\t         tok2str(subtype_str, \"Unknown\", subTypeId),\n\t         subTypeId);\n\n\t// TapAgg Header Timestamping\n\tif (subTypeId == ARISTA_SUBTYPE_TIMESTAMP) {\n\t\tuint64_t seconds;\n\t\tuint32_t nanoseconds;\n\t\tuint8_t ts_timescale = GET_U_1(bp);\n\t\tbp += 1;\n\t\tbytesConsumed += 1;\n\t\tND_PRINT(\"Timescale %s (%u), \",\n\t\t         tok2str(ts_timescale_str, \"Unknown\", ts_timescale),\n\t\t         ts_timescale);\n\n\t\tuint8_t ts_format = GET_U_1(bp) >> 4;\n\t\tuint8_t hw_info = GET_U_1(bp) & 0x0f;\n\t\tbp += 1;\n\t\tbytesConsumed += 1;\n\n\t\t// Timestamp has 32-bit lsb in nanosec and remaining msb in sec\n\t\tND_PRINT(\"Format %s (%u), HwInfo %s (%u), Timestamp \",\n\t\t         tok2str(ts_format_str, \"Unknown\", ts_format),\n\t\t         ts_format,\n\t\t         tok2str(hw_info_str, \"Unknown\", hw_info),\n\t\t         hw_info);\n\t\tswitch (ts_format) {\n\t\tcase FORMAT_64BIT:\n\t\t\tseconds = GET_BE_U_4(bp);\n\t\t\tnanoseconds = GET_BE_U_4(bp + 4);\n\t\t\tarista_print_date_hms_time(ndo, seconds, nanoseconds);\n\t\t\tbytesConsumed += 8;\n\t\t\tbreak;\n\t\tcase FORMAT_48BIT:\n\t\t\tseconds = GET_BE_U_2(bp);\n\t\t\tnanoseconds = GET_BE_U_4(bp + 2);\n\t\t\tseconds += nanoseconds / 1000000000;\n\t\t\tnanoseconds %= 1000000000;\n\t\t\tND_PRINT(\"%\" PRIu64 \".%09u\", seconds, nanoseconds);\n\t\t\tbytesConsumed += 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\tND_PRINT(\": \");\n\treturn bytesConsumed;\n}\n", "/*\n * Copyright: (c) 2000 United States Government as represented by the\n *\tSecretary of the Navy. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   1. Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.\n *   2. Redistributions in binary form must reproduce the above copyright\n *      notice, this list of conditions and the following disclaimer in\n *      the documentation and/or other materials provided with the\n *      distribution.\n *   3. The names of the authors may not be used to endorse or promote\n *      products derived from this software without specific prior\n *      written permission.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* \\summary: AFS RX printer */\n\n/*\n * This code unmangles RX packets.  RX is the mutant form of RPC that AFS\n * uses to communicate between clients and servers.\n *\n * In this code, I mainly concern myself with decoding the AFS calls, not\n * with the guts of RX, per se.\n *\n * Bah.  If I never look at rx_packet.h again, it will be too soon.\n *\n * Ken Hornstein <kenh@cmf.nrl.navy.mil>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include \"netdissect-stdinc.h\"\n\n#include \"netdissect.h\"\n#include \"addrtoname.h\"\n#include \"extract.h\"\n\n#include \"ip.h\"\n\n#define FS_RX_PORT\t7000\n#define CB_RX_PORT\t7001\n#define PROT_RX_PORT\t7002\n#define VLDB_RX_PORT\t7003\n#define KAUTH_RX_PORT\t7004\n#define VOL_RX_PORT\t7005\n#define ERROR_RX_PORT\t7006\t\t/* Doesn't seem to be used */\n#define BOS_RX_PORT\t7007\n\n#define AFSOPAQUEMAX 1024\n#define AFSNAMEMAX 256\t\t\t/* Must be >= PRNAMEMAX + 1, VLNAMEMAX + 1, and 32 + 1 */\n#define PRNAMEMAX 64\n#define VLNAMEMAX 65\n#define KANAMEMAX 64\n#define BOSNAMEMAX 256\n#define USERNAMEMAX 1024\t\t/* AFSOPAQUEMAX was used for this; does it need to be this big? */\n\n#define\tPRSFS_READ\t\t1 /* Read files */\n#define\tPRSFS_WRITE\t\t2 /* Write files */\n#define\tPRSFS_INSERT\t\t4 /* Insert files into a directory */\n#define\tPRSFS_LOOKUP\t\t8 /* Lookup files into a directory */\n#define\tPRSFS_DELETE\t\t16 /* Delete files */\n#define\tPRSFS_LOCK\t\t32 /* Lock files */\n#define\tPRSFS_ADMINISTER\t64 /* Change ACL's */\n\nstruct rx_header {\n\tnd_uint32_t epoch;\n\tnd_uint32_t cid;\n\tnd_uint32_t callNumber;\n\tnd_uint32_t seq;\n\tnd_uint32_t serial;\n\tnd_uint8_t type;\n#define RX_PACKET_TYPE_DATA\t\t1\n#define RX_PACKET_TYPE_ACK\t\t2\n#define RX_PACKET_TYPE_BUSY\t\t3\n#define RX_PACKET_TYPE_ABORT\t\t4\n#define RX_PACKET_TYPE_ACKALL\t\t5\n#define RX_PACKET_TYPE_CHALLENGE\t6\n#define RX_PACKET_TYPE_RESPONSE\t\t7\n#define RX_PACKET_TYPE_DEBUG\t\t8\n#define RX_PACKET_TYPE_PARAMS\t\t9\n#define RX_PACKET_TYPE_VERSION\t\t13\n\tnd_uint8_t flags;\n#define RX_CLIENT_INITIATED\t1\n#define RX_REQUEST_ACK\t\t2\n#define RX_LAST_PACKET\t\t4\n#define RX_MORE_PACKETS\t\t8\n#define RX_FREE_PACKET\t\t16\n#define RX_SLOW_START_OK\t32\n#define RX_JUMBO_PACKET\t\t32\n\tnd_uint8_t userStatus;\n\tnd_uint8_t securityIndex;\n\tnd_uint16_t spare;\t\t/* How clever: even though the AFS */\n\tnd_uint16_t serviceId;\t\t/* header files indicate that the */\n};\t\t\t\t\t/* serviceId is first, it's really */\n\t\t\t\t\t/* encoded _after_ the spare field */\n\t\t\t\t\t/* I wasted a day figuring that out! */\n\n#define NUM_RX_FLAGS 7\n\n#define RX_MAXACKS 255\n\nstruct rx_ackPacket {\n\tnd_uint16_t bufferSpace;\t/* Number of packet buffers available */\n\tnd_uint16_t maxSkew;\t\t/* Max diff between ack'd packet and */\n\t\t\t\t\t/* highest packet received */\n\tnd_uint32_t firstPacket;\t/* The first packet in ack list */\n\tnd_uint32_t previousPacket;\t/* Previous packet recv'd (obsolete) */\n\tnd_uint32_t serial;\t\t/* # of packet that prompted the ack */\n\tnd_uint8_t reason;\t\t/* Reason for acknowledgement */\n\tnd_uint8_t nAcks;\t\t/* Number of acknowledgements */\n\t/* Followed by nAcks acknowledgments */\n#if 0\n\tuint8_t acks[RX_MAXACKS];\t/* Up to RX_MAXACKS acknowledgements */\n#endif\n};\n\n/*\n * Values for the acks array\n */\n\n#define RX_ACK_TYPE_NACK\t0\t/* Don't have this packet */\n#define RX_ACK_TYPE_ACK\t\t1\t/* I have this packet */\n\nstatic const struct tok rx_types[] = {\n\t{ RX_PACKET_TYPE_DATA,\t\t\"data\" },\n\t{ RX_PACKET_TYPE_ACK,\t\t\"ack\" },\n\t{ RX_PACKET_TYPE_BUSY,\t\t\"busy\" },\n\t{ RX_PACKET_TYPE_ABORT,\t\t\"abort\" },\n\t{ RX_PACKET_TYPE_ACKALL,\t\"ackall\" },\n\t{ RX_PACKET_TYPE_CHALLENGE,\t\"challenge\" },\n\t{ RX_PACKET_TYPE_RESPONSE,\t\"response\" },\n\t{ RX_PACKET_TYPE_DEBUG,\t\t\"debug\" },\n\t{ RX_PACKET_TYPE_PARAMS,\t\"params\" },\n\t{ RX_PACKET_TYPE_VERSION,\t\"version\" },\n\t{ 0,\t\t\t\tNULL },\n};\n\nstatic const struct double_tok {\n\tuint32_t flag;\t\t/* Rx flag */\n\tuint32_t packetType;\t/* Packet type */\n\tconst char *s;\t\t/* Flag string */\n} rx_flags[] = {\n\t{ RX_CLIENT_INITIATED,\t0,\t\t\t\"client-init\" },\n\t{ RX_REQUEST_ACK,\t0,\t\t\t\"req-ack\" },\n\t{ RX_LAST_PACKET,\t0,\t\t\t\"last-pckt\" },\n\t{ RX_MORE_PACKETS,\t0,\t\t\t\"more-pckts\" },\n\t{ RX_FREE_PACKET,\t0,\t\t\t\"free-pckt\" },\n\t{ RX_SLOW_START_OK,\tRX_PACKET_TYPE_ACK,\t\"slow-start\" },\n\t{ RX_JUMBO_PACKET,\tRX_PACKET_TYPE_DATA,\t\"jumbogram\" }\n};\n\nstatic const struct tok fs_req[] = {\n\t{ 130,\t\t\"fetch-data\" },\n\t{ 131,\t\t\"fetch-acl\" },\n\t{ 132,\t\t\"fetch-status\" },\n\t{ 133,\t\t\"store-data\" },\n\t{ 134,\t\t\"store-acl\" },\n\t{ 135,\t\t\"store-status\" },\n\t{ 136,\t\t\"remove-file\" },\n\t{ 137,\t\t\"create-file\" },\n\t{ 138,\t\t\"rename\" },\n\t{ 139,\t\t\"symlink\" },\n\t{ 140,\t\t\"link\" },\n\t{ 141,\t\t\"makedir\" },\n\t{ 142,\t\t\"rmdir\" },\n\t{ 143,\t\t\"oldsetlock\" },\n\t{ 144,\t\t\"oldextlock\" },\n\t{ 145,\t\t\"oldrellock\" },\n\t{ 146,\t\t\"get-stats\" },\n\t{ 147,\t\t\"give-cbs\" },\n\t{ 148,\t\t\"get-vlinfo\" },\n\t{ 149,\t\t\"get-vlstats\" },\n\t{ 150,\t\t\"set-vlstats\" },\n\t{ 151,\t\t\"get-rootvl\" },\n\t{ 152,\t\t\"check-token\" },\n\t{ 153,\t\t\"get-time\" },\n\t{ 154,\t\t\"nget-vlinfo\" },\n\t{ 155,\t\t\"bulk-stat\" },\n\t{ 156,\t\t\"setlock\" },\n\t{ 157,\t\t\"extlock\" },\n\t{ 158,\t\t\"rellock\" },\n\t{ 159,\t\t\"xstat-ver\" },\n\t{ 160,\t\t\"get-xstat\" },\n\t{ 161,\t\t\"dfs-lookup\" },\n\t{ 162,\t\t\"dfs-flushcps\" },\n\t{ 163,\t\t\"dfs-symlink\" },\n\t{ 220,\t\t\"residency\" },\n\t{ 65536,        \"inline-bulk-status\" },\n\t{ 65537,        \"fetch-data-64\" },\n\t{ 65538,        \"store-data-64\" },\n\t{ 65539,        \"give-up-all-cbs\" },\n\t{ 65540,        \"get-caps\" },\n\t{ 65541,        \"cb-rx-conn-addr\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok cb_req[] = {\n\t{ 204,\t\t\"callback\" },\n\t{ 205,\t\t\"initcb\" },\n\t{ 206,\t\t\"probe\" },\n\t{ 207,\t\t\"getlock\" },\n\t{ 208,\t\t\"getce\" },\n\t{ 209,\t\t\"xstatver\" },\n\t{ 210,\t\t\"getxstat\" },\n\t{ 211,\t\t\"initcb2\" },\n\t{ 212,\t\t\"whoareyou\" },\n\t{ 213,\t\t\"initcb3\" },\n\t{ 214,\t\t\"probeuuid\" },\n\t{ 215,\t\t\"getsrvprefs\" },\n\t{ 216,\t\t\"getcellservdb\" },\n\t{ 217,\t\t\"getlocalcell\" },\n\t{ 218,\t\t\"getcacheconf\" },\n\t{ 65536,        \"getce64\" },\n\t{ 65537,        \"getcellbynum\" },\n\t{ 65538,        \"tellmeaboutyourself\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok pt_req[] = {\n\t{ 500,\t\t\"new-user\" },\n\t{ 501,\t\t\"where-is-it\" },\n\t{ 502,\t\t\"dump-entry\" },\n\t{ 503,\t\t\"add-to-group\" },\n\t{ 504,\t\t\"name-to-id\" },\n\t{ 505,\t\t\"id-to-name\" },\n\t{ 506,\t\t\"delete\" },\n\t{ 507,\t\t\"remove-from-group\" },\n\t{ 508,\t\t\"get-cps\" },\n\t{ 509,\t\t\"new-entry\" },\n\t{ 510,\t\t\"list-max\" },\n\t{ 511,\t\t\"set-max\" },\n\t{ 512,\t\t\"list-entry\" },\n\t{ 513,\t\t\"change-entry\" },\n\t{ 514,\t\t\"list-elements\" },\n\t{ 515,\t\t\"same-mbr-of\" },\n\t{ 516,\t\t\"set-fld-sentry\" },\n\t{ 517,\t\t\"list-owned\" },\n\t{ 518,\t\t\"get-cps2\" },\n\t{ 519,\t\t\"get-host-cps\" },\n\t{ 520,\t\t\"update-entry\" },\n\t{ 521,\t\t\"list-entries\" },\n\t{ 530,\t\t\"list-super-groups\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok vldb_req[] = {\n\t{ 501,\t\t\"create-entry\" },\n\t{ 502,\t\t\"delete-entry\" },\n\t{ 503,\t\t\"get-entry-by-id\" },\n\t{ 504,\t\t\"get-entry-by-name\" },\n\t{ 505,\t\t\"get-new-volume-id\" },\n\t{ 506,\t\t\"replace-entry\" },\n\t{ 507,\t\t\"update-entry\" },\n\t{ 508,\t\t\"setlock\" },\n\t{ 509,\t\t\"releaselock\" },\n\t{ 510,\t\t\"list-entry\" },\n\t{ 511,\t\t\"list-attrib\" },\n\t{ 512,\t\t\"linked-list\" },\n\t{ 513,\t\t\"get-stats\" },\n\t{ 514,\t\t\"probe\" },\n\t{ 515,\t\t\"get-addrs\" },\n\t{ 516,\t\t\"change-addr\" },\n\t{ 517,\t\t\"create-entry-n\" },\n\t{ 518,\t\t\"get-entry-by-id-n\" },\n\t{ 519,\t\t\"get-entry-by-name-n\" },\n\t{ 520,\t\t\"replace-entry-n\" },\n\t{ 521,\t\t\"list-entry-n\" },\n\t{ 522,\t\t\"list-attrib-n\" },\n\t{ 523,\t\t\"linked-list-n\" },\n\t{ 524,\t\t\"update-entry-by-name\" },\n\t{ 525,\t\t\"create-entry-u\" },\n\t{ 526,\t\t\"get-entry-by-id-u\" },\n\t{ 527,\t\t\"get-entry-by-name-u\" },\n\t{ 528,\t\t\"replace-entry-u\" },\n\t{ 529,\t\t\"list-entry-u\" },\n\t{ 530,\t\t\"list-attrib-u\" },\n\t{ 531,\t\t\"linked-list-u\" },\n\t{ 532,\t\t\"regaddr\" },\n\t{ 533,\t\t\"get-addrs-u\" },\n\t{ 534,\t\t\"list-attrib-n2\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok kauth_req[] = {\n\t{ 1,\t\t\"auth-old\" },\n\t{ 21,\t\t\"authenticate\" },\n\t{ 22,\t\t\"authenticate-v2\" },\n\t{ 2,\t\t\"change-pw\" },\n\t{ 3,\t\t\"get-ticket-old\" },\n\t{ 23,\t\t\"get-ticket\" },\n\t{ 4,\t\t\"set-pw\" },\n\t{ 5,\t\t\"set-fields\" },\n\t{ 6,\t\t\"create-user\" },\n\t{ 7,\t\t\"delete-user\" },\n\t{ 8,\t\t\"get-entry\" },\n\t{ 9,\t\t\"list-entry\" },\n\t{ 10,\t\t\"get-stats\" },\n\t{ 11,\t\t\"debug\" },\n\t{ 12,\t\t\"get-pw\" },\n\t{ 13,\t\t\"get-random-key\" },\n\t{ 14,\t\t\"unlock\" },\n\t{ 15,\t\t\"lock-status\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok vol_req[] = {\n\t{ 100,\t\t\"create-volume\" },\n\t{ 101,\t\t\"delete-volume\" },\n\t{ 102,\t\t\"restore\" },\n\t{ 103,\t\t\"forward\" },\n\t{ 104,\t\t\"end-trans\" },\n\t{ 105,\t\t\"clone\" },\n\t{ 106,\t\t\"set-flags\" },\n\t{ 107,\t\t\"get-flags\" },\n\t{ 108,\t\t\"trans-create\" },\n\t{ 109,\t\t\"dump\" },\n\t{ 110,\t\t\"get-nth-volume\" },\n\t{ 111,\t\t\"set-forwarding\" },\n\t{ 112,\t\t\"get-name\" },\n\t{ 113,\t\t\"get-status\" },\n\t{ 114,\t\t\"sig-restore\" },\n\t{ 115,\t\t\"list-partitions\" },\n\t{ 116,\t\t\"list-volumes\" },\n\t{ 117,\t\t\"set-id-types\" },\n\t{ 118,\t\t\"monitor\" },\n\t{ 119,\t\t\"partition-info\" },\n\t{ 120,\t\t\"reclone\" },\n\t{ 121,\t\t\"list-one-volume\" },\n\t{ 122,\t\t\"nuke\" },\n\t{ 123,\t\t\"set-date\" },\n\t{ 124,\t\t\"x-list-volumes\" },\n\t{ 125,\t\t\"x-list-one-volume\" },\n\t{ 126,\t\t\"set-info\" },\n\t{ 127,\t\t\"x-list-partitions\" },\n\t{ 128,\t\t\"forward-multiple\" },\n\t{ 65536,\t\"convert-ro\" },\n\t{ 65537,\t\"get-size\" },\n\t{ 65538,\t\"dump-v2\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok bos_req[] = {\n\t{ 80,\t\t\"create-bnode\" },\n\t{ 81,\t\t\"delete-bnode\" },\n\t{ 82,\t\t\"set-status\" },\n\t{ 83,\t\t\"get-status\" },\n\t{ 84,\t\t\"enumerate-instance\" },\n\t{ 85,\t\t\"get-instance-info\" },\n\t{ 86,\t\t\"get-instance-parm\" },\n\t{ 87,\t\t\"add-superuser\" },\n\t{ 88,\t\t\"delete-superuser\" },\n\t{ 89,\t\t\"list-superusers\" },\n\t{ 90,\t\t\"list-keys\" },\n\t{ 91,\t\t\"add-key\" },\n\t{ 92,\t\t\"delete-key\" },\n\t{ 93,\t\t\"set-cell-name\" },\n\t{ 94,\t\t\"get-cell-name\" },\n\t{ 95,\t\t\"get-cell-host\" },\n\t{ 96,\t\t\"add-cell-host\" },\n\t{ 97,\t\t\"delete-cell-host\" },\n\t{ 98,\t\t\"set-t-status\" },\n\t{ 99,\t\t\"shutdown-all\" },\n\t{ 100,\t\t\"restart-all\" },\n\t{ 101,\t\t\"startup-all\" },\n\t{ 102,\t\t\"set-noauth-flag\" },\n\t{ 103,\t\t\"re-bozo\" },\n\t{ 104,\t\t\"restart\" },\n\t{ 105,\t\t\"start-bozo-install\" },\n\t{ 106,\t\t\"uninstall\" },\n\t{ 107,\t\t\"get-dates\" },\n\t{ 108,\t\t\"exec\" },\n\t{ 109,\t\t\"prune\" },\n\t{ 110,\t\t\"set-restart-time\" },\n\t{ 111,\t\t\"get-restart-time\" },\n\t{ 112,\t\t\"start-bozo-log\" },\n\t{ 113,\t\t\"wait-all\" },\n\t{ 114,\t\t\"get-instance-strings\" },\n\t{ 115,\t\t\"get-restricted\" },\n\t{ 116,\t\t\"set-restricted\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok ubik_req[] = {\n\t{ 10000,\t\"vote-beacon\" },\n\t{ 10001,\t\"vote-debug-old\" },\n\t{ 10002,\t\"vote-sdebug-old\" },\n\t{ 10003,\t\"vote-getsyncsite\" },\n\t{ 10004,\t\"vote-debug\" },\n\t{ 10005,\t\"vote-sdebug\" },\n\t{ 10006,\t\"vote-xdebug\" },\n\t{ 10007,\t\"vote-xsdebug\" },\n\t{ 20000,\t\"disk-begin\" },\n\t{ 20001,\t\"disk-commit\" },\n\t{ 20002,\t\"disk-lock\" },\n\t{ 20003,\t\"disk-write\" },\n\t{ 20004,\t\"disk-getversion\" },\n\t{ 20005,\t\"disk-getfile\" },\n\t{ 20006,\t\"disk-sendfile\" },\n\t{ 20007,\t\"disk-abort\" },\n\t{ 20008,\t\"disk-releaselocks\" },\n\t{ 20009,\t\"disk-truncate\" },\n\t{ 20010,\t\"disk-probe\" },\n\t{ 20011,\t\"disk-writev\" },\n\t{ 20012,\t\"disk-interfaceaddr\" },\n\t{ 20013,\t\"disk-setversion\" },\n\t{ 0,\t\tNULL },\n};\n\n#define VOTE_LOW\t10000\n#define VOTE_HIGH\t10007\n#define DISK_LOW\t20000\n#define DISK_HIGH\t20013\n\nstatic const struct tok cb_types[] = {\n\t{ 1,\t\t\"exclusive\" },\n\t{ 2,\t\t\"shared\" },\n\t{ 3,\t\t\"dropped\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const struct tok ubik_lock_types[] = {\n\t{ 1,\t\t\"read\" },\n\t{ 2,\t\t\"write\" },\n\t{ 3,\t\t\"wait\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const char *voltype[] = { \"read-write\", \"read-only\", \"backup\" };\n\nstatic const struct tok afs_fs_errors[] = {\n\t{ 101,\t\t\"salvage volume\" },\n\t{ 102,\t\t\"no such vnode\" },\n\t{ 103,\t\t\"no such volume\" },\n\t{ 104,\t\t\"volume exist\" },\n\t{ 105,\t\t\"no service\" },\n\t{ 106,\t\t\"volume offline\" },\n\t{ 107,\t\t\"voline online\" },\n\t{ 108,\t\t\"diskfull\" },\n\t{ 109,\t\t\"diskquota exceeded\" },\n\t{ 110,\t\t\"volume busy\" },\n\t{ 111,\t\t\"volume moved\" },\n\t{ 112,\t\t\"AFS IO error\" },\n\t{ 0xffffff9c,\t\"restarting fileserver\" }, /* -100, sic! */\n\t{ 0,\t\tNULL }\n};\n\n/*\n * Reasons for acknowledging a packet\n */\n\nstatic const struct tok rx_ack_reasons[] = {\n\t{ 1,\t\t\"ack requested\" },\n\t{ 2,\t\t\"duplicate packet\" },\n\t{ 3,\t\t\"out of sequence\" },\n\t{ 4,\t\t\"exceeds window\" },\n\t{ 5,\t\t\"no buffer space\" },\n\t{ 6,\t\t\"ping\" },\n\t{ 7,\t\t\"ping response\" },\n\t{ 8,\t\t\"delay\" },\n\t{ 9,\t\t\"idle\" },\n\t{ 0,\t\tNULL },\n};\n\n/*\n * Cache entries we keep around so we can figure out the RX opcode\n * numbers for replies.  This allows us to make sense of RX reply packets.\n */\n\nstruct rx_cache_entry {\n\tuint32_t\tcallnum;\t/* Call number (net order) */\n\tuint32_t\tclient;\t\t/* client IP address (net order) */\n\tuint32_t\tserver;\t\t/* server IP address (net order) */\n\tuint16_t\tdport;\t\t/* server UDP port (host order) */\n\tuint16_t\tserviceId;\t/* Service identifier (net order) */\n\tuint32_t\topcode;\t\t/* RX opcode (host order) */\n};\n\n#define RX_CACHE_SIZE\t64\n\nstatic struct rx_cache_entry\trx_cache[RX_CACHE_SIZE];\n\nstatic uint32_t\trx_cache_next = 0;\nstatic uint32_t\trx_cache_hint = 0;\nstatic void\trx_cache_insert(netdissect_options *, const u_char *, const struct ip *, uint16_t);\nstatic int\trx_cache_find(netdissect_options *, const struct rx_header *,\n\t\t\t      const struct ip *, uint16_t, uint32_t *);\n\nstatic void fs_print(netdissect_options *, const u_char *, u_int);\nstatic void fs_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void acl_print(netdissect_options *, u_char *, const u_char *);\nstatic void cb_print(netdissect_options *, const u_char *, u_int);\nstatic void cb_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void prot_print(netdissect_options *, const u_char *, u_int);\nstatic void prot_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void vldb_print(netdissect_options *, const u_char *, u_int);\nstatic void vldb_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void kauth_print(netdissect_options *, const u_char *, u_int);\nstatic void kauth_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void vol_print(netdissect_options *, const u_char *, u_int);\nstatic void vol_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void bos_print(netdissect_options *, const u_char *, u_int);\nstatic void bos_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\nstatic void ubik_print(netdissect_options *, const u_char *);\nstatic void ubik_reply_print(netdissect_options *, const u_char *, u_int, uint32_t);\n\nstatic void rx_ack_print(netdissect_options *, const u_char *, u_int);\n\nstatic int is_ubik(uint32_t);\n\n/*\n * Handle the rx-level packet.  See if we know what port it's going to so\n * we can peek at the afs call inside\n */\n\nvoid\nrx_print(netdissect_options *ndo,\n         const u_char *bp, u_int length, uint16_t sport, uint16_t dport,\n         const u_char *bp2)\n{\n\tconst struct rx_header *rxh;\n\tuint32_t i;\n\tuint8_t type, flags;\n\tuint32_t opcode;\n\n\tndo->ndo_protocol = \"rx\";\n\tif (!ND_TTEST_LEN(bp, sizeof(struct rx_header))) {\n\t\tND_PRINT(\" [|rx] (%u)\", length);\n\t\treturn;\n\t}\n\n\trxh = (const struct rx_header *) bp;\n\n\ttype = GET_U_1(rxh->type);\n\tND_PRINT(\" rx %s\", tok2str(rx_types, \"type %u\", type));\n\n\tflags = GET_U_1(rxh->flags);\n\tif (ndo->ndo_vflag) {\n\t\tint firstflag = 0;\n\n\t\tif (ndo->ndo_vflag > 1)\n\t\t\tND_PRINT(\" cid %08x call# %u\",\n\t\t\t       GET_BE_U_4(rxh->cid),\n\t\t\t       GET_BE_U_4(rxh->callNumber));\n\n\t\tND_PRINT(\" seq %u ser %u\",\n\t\t       GET_BE_U_4(rxh->seq),\n\t\t       GET_BE_U_4(rxh->serial));\n\n\t\tif (ndo->ndo_vflag > 2)\n\t\t\tND_PRINT(\" secindex %u serviceid %hu\",\n\t\t\t\tGET_U_1(rxh->securityIndex),\n\t\t\t\tGET_BE_U_2(rxh->serviceId));\n\n\t\tif (ndo->ndo_vflag > 1)\n\t\t\tfor (i = 0; i < NUM_RX_FLAGS; i++) {\n\t\t\t\tif (flags & rx_flags[i].flag &&\n\t\t\t\t    (!rx_flags[i].packetType ||\n\t\t\t\t     type == rx_flags[i].packetType)) {\n\t\t\t\t\tif (!firstflag) {\n\t\t\t\t\t\tfirstflag = 1;\n\t\t\t\t\t\tND_PRINT(\" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tND_PRINT(\",\");\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT(\"<%s>\", rx_flags[i].s);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\t/*\n\t * Try to handle AFS calls that we know about.  Check the destination\n\t * port and make sure it's a data packet.  Also, make sure the\n\t * seq number is 1 (because otherwise it's a continuation packet,\n\t * and we can't interpret that).  Also, seems that reply packets\n\t * do not have the client-init flag set, so we check for that\n\t * as well.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA &&\n\t    GET_BE_U_4(rxh->seq) == 1 &&\n\t    flags & RX_CLIENT_INITIATED) {\n\n\t\t/*\n\t\t * Insert this call into the call cache table, so we\n\t\t * have a chance to print out replies\n\t\t */\n\n\t\trx_cache_insert(ndo, bp, (const struct ip *) bp2, dport);\n\n\t\tswitch (dport) {\n\t\t\tcase FS_RX_PORT:\t/* AFS file service */\n\t\t\t\tfs_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase CB_RX_PORT:\t/* AFS callback service */\n\t\t\t\tcb_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase PROT_RX_PORT:\t/* AFS protection service */\n\t\t\t\tprot_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase VLDB_RX_PORT:\t/* AFS VLDB service */\n\t\t\t\tvldb_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase KAUTH_RX_PORT:\t/* AFS Kerberos auth service */\n\t\t\t\tkauth_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase VOL_RX_PORT:\t/* AFS Volume service */\n\t\t\t\tvol_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tcase BOS_RX_PORT:\t/* AFS BOS service */\n\t\t\t\tbos_print(ndo, bp, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\n\t/*\n\t * If it's a reply (client-init is _not_ set, but seq is one)\n\t * then look it up in the cache.  If we find it, call the reply\n\t * printing functions  Note that we handle abort packets here,\n\t * because printing out the return code can be useful at times.\n\t */\n\n\t} else if (((type == RX_PACKET_TYPE_DATA &&\n\t\t\t\t\tGET_BE_U_4(rxh->seq) == 1) ||\n\t\t    type == RX_PACKET_TYPE_ABORT) &&\n\t\t   (flags & RX_CLIENT_INITIATED) == 0 &&\n\t\t   rx_cache_find(ndo, rxh, (const struct ip *) bp2,\n\t\t\t\t sport, &opcode)) {\n\n\t\tswitch (sport) {\n\t\t\tcase FS_RX_PORT:\t/* AFS file service */\n\t\t\t\tfs_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase CB_RX_PORT:\t/* AFS callback service */\n\t\t\t\tcb_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase PROT_RX_PORT:\t/* AFS PT service */\n\t\t\t\tprot_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase VLDB_RX_PORT:\t/* AFS VLDB service */\n\t\t\t\tvldb_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase KAUTH_RX_PORT:\t/* AFS Kerberos auth service */\n\t\t\t\tkauth_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase VOL_RX_PORT:\t/* AFS Volume service */\n\t\t\t\tvol_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tcase BOS_RX_PORT:\t/* AFS BOS service */\n\t\t\t\tbos_reply_print(ndo, bp, length, opcode);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\n\t/*\n\t * If it's an RX ack packet, then use the appropriate ack decoding\n\t * function (there isn't any service-specific information in the\n\t * ack packet, so we can use one for all AFS services)\n\t */\n\n\t} else if (type == RX_PACKET_TYPE_ACK)\n\t\trx_ack_print(ndo, bp, length);\n\n\n\tND_PRINT(\" (%u)\", length);\n}\n\n/*\n * Insert an entry into the cache.  Taken from print-nfs.c\n */\n\nstatic void\nrx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, uint16_t dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (!ND_TTEST_4(bp + sizeof(struct rx_header)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = GET_BE_U_4(rxh->callNumber);\n\trxent->client = GET_IPV4_TO_NETWORK_ORDER(ip->ip_src);\n\trxent->server = GET_IPV4_TO_NETWORK_ORDER(ip->ip_dst);\n\trxent->dport = dport;\n\trxent->serviceId = GET_BE_U_2(rxh->serviceId);\n\trxent->opcode = GET_BE_U_4(bp + sizeof(struct rx_header));\n}\n\n/*\n * Lookup an entry in the cache.  Also taken from print-nfs.c\n *\n * Note that because this is a reply, we're looking at the _source_\n * port.\n */\n\nstatic int\nrx_cache_find(netdissect_options *ndo, const struct rx_header *rxh,\n\t      const struct ip *ip, uint16_t sport, uint32_t *opcode)\n{\n\tuint32_t i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\n\tclip = GET_IPV4_TO_NETWORK_ORDER(ip->ip_dst);\n\tsip = GET_IPV4_TO_NETWORK_ORDER(ip->ip_src);\n\n\t/* Start the search where we last left off */\n\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == GET_BE_U_4(rxh->callNumber) &&\n\t\t    rxent->client == clip &&\n\t\t    rxent->server == sip &&\n\t\t    rxent->serviceId == GET_BE_U_2(rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\n\t\t\t/* We got a match! */\n\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\n\t/* Our search failed */\n\treturn(0);\n}\n\n/*\n * These extremely grody macros handle the printing of various AFS stuff.\n */\n\n#define FIDOUT() { uint32_t n1, n2, n3; \\\n\t\t\tND_TCHECK_LEN(bp, sizeof(uint32_t) * 3); \\\n\t\t\tn1 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn2 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn3 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" fid %u/%u/%u\", n1, n2, n3); \\\n\t\t}\n\n#define STROUT(MAX) { uint32_t _i; \\\n\t\t\t_i = GET_BE_U_4(bp); \\\n\t\t\tif (_i > (MAX)) \\\n\t\t\t\tgoto trunc; \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" \\\"\"); \\\n\t\t\tif (nd_printn(ndo, bp, _i, ndo->ndo_snapend)) \\\n\t\t\t\tgoto trunc; \\\n\t\t\tND_PRINT(\"\\\"\"); \\\n\t\t\tbp += ((_i + sizeof(uint32_t) - 1) / sizeof(uint32_t)) * sizeof(uint32_t); \\\n\t\t}\n\n#define INTOUT() { int32_t _i; \\\n\t\t\t_i = GET_BE_S_4(bp); \\\n\t\t\tbp += sizeof(int32_t); \\\n\t\t\tND_PRINT(\" %d\", _i); \\\n\t\t}\n\n#define UINTOUT() { uint32_t _i; \\\n\t\t\t_i = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" %u\", _i); \\\n\t\t}\n\n#define UINT64OUT() { uint64_t _i; \\\n\t\t\t_i = GET_BE_U_8(bp); \\\n\t\t\tbp += sizeof(uint64_t); \\\n\t\t\tND_PRINT(\" %\" PRIu64, _i); \\\n\t\t}\n\n#define DATEOUT() { time_t _t; char str[256]; \\\n\t\t\t_t = (time_t) GET_BE_S_4(bp); \\\n\t\t\tbp += sizeof(int32_t); \\\n\t\t\tND_PRINT(\" %s\", \\\n\t\t\t    nd_format_time(str, sizeof(str), \\\n\t\t\t      \"%Y/%m/%d %H:%M:%S\", localtime(&_t))); \\\n\t\t}\n\n#define STOREATTROUT() { uint32_t mask, _i; \\\n\t\t\tND_TCHECK_LEN(bp, (sizeof(uint32_t) * 6)); \\\n\t\t\tmask = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t\tif (mask) ND_PRINT(\" StoreStatus\"); \\\n\t\t        if (mask & 1) { ND_PRINT(\" date\"); DATEOUT(); } \\\n\t\t\telse bp += sizeof(uint32_t); \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 2) ND_PRINT(\" owner %u\", _i);  \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 4) ND_PRINT(\" group %u\", _i); \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 8) ND_PRINT(\" mode %o\", _i & 07777); \\\n\t\t\t_i = GET_BE_U_4(bp); bp += sizeof(uint32_t); \\\n\t\t        if (mask & 16) ND_PRINT(\" segsize %u\", _i); \\\n\t\t\t/* undocumented in 3.3 docu */ \\\n\t\t        if (mask & 1024) ND_PRINT(\" fsync\");  \\\n\t\t}\n\n#define UBIK_VERSIONOUT() {uint32_t epoch; uint32_t counter; \\\n\t\t\tND_TCHECK_LEN(bp, sizeof(uint32_t) * 2); \\\n\t\t\tepoch = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tcounter = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" %u.%u\", epoch, counter); \\\n\t\t}\n\n#define AFSUUIDOUT() {uint32_t temp; int _i; \\\n\t\t\tND_TCHECK_LEN(bp, 11 * sizeof(uint32_t)); \\\n\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" %08x\", temp); \\\n\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\"%04x\", temp); \\\n\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\"%04x\", temp); \\\n\t\t\tfor (_i = 0; _i < 8; _i++) { \\\n\t\t\t\ttemp = GET_BE_U_4(bp); \\\n\t\t\t\tbp += sizeof(uint32_t); \\\n\t\t\t\tND_PRINT(\"%02x\", (unsigned char) temp); \\\n\t\t\t} \\\n\t\t}\n\n/*\n * This is the sickest one of all\n * MAX is expected to be a constant here\n */\n\n#define VECOUT(MAX) { u_char *sp; \\\n\t\t\tu_char s[(MAX) + 1]; \\\n\t\t\tuint32_t k; \\\n\t\t\tND_TCHECK_LEN(bp, (MAX) * sizeof(uint32_t)); \\\n\t\t\tsp = s; \\\n\t\t\tfor (k = 0; k < (MAX); k++) { \\\n\t\t\t\t*sp++ = (u_char) GET_BE_U_4(bp); \\\n\t\t\t\tbp += sizeof(uint32_t); \\\n\t\t\t} \\\n\t\t\ts[(MAX)] = '\\0'; \\\n\t\t\tND_PRINT(\" \\\"\"); \\\n\t\t\tfn_print_str(ndo, s); \\\n\t\t\tND_PRINT(\"\\\"\"); \\\n\t\t}\n\n#define DESTSERVEROUT() { uint32_t n1, n2, n3; \\\n\t\t\tND_TCHECK_LEN(bp, sizeof(uint32_t) * 3); \\\n\t\t\tn1 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn2 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tn3 = GET_BE_U_4(bp); \\\n\t\t\tbp += sizeof(uint32_t); \\\n\t\t\tND_PRINT(\" server %u:%u:%u\", n1, n2, n3); \\\n\t\t}\n\n/*\n * Handle calls to the AFS file service (fs)\n */\n\nstatic void\nfs_print(netdissect_options *ndo,\n         const u_char *bp, u_int length)\n{\n\tuint32_t fs_op;\n\tuint32_t i;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afsint.xg\n\t */\n\n\tfs_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" fs call %s\", tok2str(fs_req, \"op#%u\", fs_op));\n\n\t/*\n\t * Print out arguments to some of the AFS calls.  This stuff is\n\t * all from afsint.xg\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\t/*\n\t * Sigh.  This is gross.  Ritchie forgive me.\n\t */\n\n\tswitch (fs_op) {\n\t\tcase 130:\t/* Fetch data */\n\t\t\tFIDOUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 131:\t/* Fetch ACL */\n\t\tcase 132:\t/* Fetch Status */\n\t\tcase 143:\t/* Old set lock */\n\t\tcase 144:\t/* Old extend lock */\n\t\tcase 145:\t/* Old release lock */\n\t\tcase 156:\t/* Set lock */\n\t\tcase 157:\t/* Extend lock */\n\t\tcase 158:\t/* Release lock */\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 135:\t/* Store status */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tbreak;\n\t\tcase 133:\t/* Store data */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flen\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 134:\t/* Store ACL */\n\t\t{\n\t\t\tchar a[AFSOPAQUEMAX+1];\n\t\t\tFIDOUT();\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_TCHECK_LEN(bp, i);\n\t\t\ti = ND_MIN(AFSOPAQUEMAX, i);\n\t\t\tstrncpy(a, (const char *) bp, i);\n\t\t\ta[i] = '\\0';\n\t\t\tacl_print(ndo, (u_char *) a, (u_char *) a + i);\n\t\t\tbreak;\n\t\t}\n\t\tcase 137:\t/* Create file */\n\t\tcase 141:\t/* MakeDir */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tSTOREATTROUT();\n\t\t\tbreak;\n\t\tcase 136:\t/* Remove file */\n\t\tcase 142:\t/* Remove directory */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 138:\t/* Rename file */\n\t\t\tND_PRINT(\" old\");\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" new\");\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 139:\t/* Symlink */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" link to\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 140:\t/* Link */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" link to\");\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 148:\t/* Get volume info */\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 149:\t/* Get volume stats */\n\t\tcase 150:\t/* Set volume stats */\n\t\t\tND_PRINT(\" volid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 154:\t/* New get volume info */\n\t\t\tND_PRINT(\" volname\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 155:\t/* Bulk stat */\n\t\tcase 65536:     /* Inline bulk stat */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tFIDOUT();\n\t\t\t\tif (i != j - 1)\n\t\t\t\t\tND_PRINT(\",\");\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t\tbreak;\n\t\t}\n\t\tcase 65537:\t/* Fetch data 64 */\n\t\t\tFIDOUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINT64OUT();\n\t\t\tbreak;\n\t\tcase 65538:\t/* Store data 64 */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tND_PRINT(\" offset\");\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT(\" flen\");\n\t\t\tUINT64OUT();\n\t\t\tbreak;\n\t\tcase 65541:    /* CallBack rx conn address */\n\t\t\tND_PRINT(\" addr\");\n\t\t\tUINTOUT();\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|fs]\");\n}\n\n/*\n * Handle replies to the AFS file service\n */\n\nstatic void\nfs_reply_print(netdissect_options *ndo,\n               const u_char *bp, u_int length, uint32_t opcode)\n{\n\tuint32_t i;\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afsint.xg\n\t */\n\n\tND_PRINT(\" fs reply %s\", tok2str(fs_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA) {\n\t\tswitch (opcode) {\n\t\tcase 131:\t/* Fetch ACL */\n\t\t{\n\t\t\tchar a[AFSOPAQUEMAX+1];\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_TCHECK_LEN(bp, i);\n\t\t\ti = ND_MIN(AFSOPAQUEMAX, i);\n\t\t\tstrncpy(a, (const char *) bp, i);\n\t\t\ta[i] = '\\0';\n\t\t\tacl_print(ndo, (u_char *) a, (u_char *) a + i);\n\t\t\tbreak;\n\t\t}\n\t\tcase 137:\t/* Create file */\n\t\tcase 141:\t/* MakeDir */\n\t\t\tND_PRINT(\" new\");\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 151:\t/* Get root volume */\n\t\t\tND_PRINT(\" root volume\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 153:\t/* Get time */\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t} else if (type == RX_PACKET_TYPE_ABORT) {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tint32_t errcode;\n\n\t\terrcode = GET_BE_S_4(bp);\n\t\tbp += sizeof(int32_t);\n\n\t\tND_PRINT(\" error %s\", tok2str(afs_fs_errors, \"#%d\", errcode));\n\t} else {\n\t\tND_PRINT(\" strange fs reply of type %u\", type);\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|fs]\");\n}\n\n/*\n * Print out an AFS ACL string.  An AFS ACL is a string that has the\n * following format:\n *\n * <positive> <negative>\n * <uid1> <aclbits1>\n * ....\n *\n * \"positive\" and \"negative\" are integers which contain the number of\n * positive and negative ACL's in the string.  The uid/aclbits pair are\n * ASCII strings containing the UID/PTS record and an ASCII number\n * representing a logical OR of all the ACL permission bits\n */\n\n#define XSTRINGIFY(x) #x\n#define NUMSTRINGIFY(x)\tXSTRINGIFY(x)\n\nstatic void\nacl_print(netdissect_options *ndo,\n          u_char *s, const u_char *end)\n{\n\tint pos, neg, acl;\n\tint n, i;\n\tchar user[USERNAMEMAX+1];\n\n\tif (sscanf((char *) s, \"%d %d\\n%n\", &pos, &neg, &n) != 2)\n\t\treturn;\n\n\ts += n;\n\n\tif (s > end)\n\t\treturn;\n\n\t/*\n\t * This wacky order preserves the order used by the \"fs\" command\n\t */\n\n#define ACLOUT(acl) \\\n\tND_PRINT(\"%s%s%s%s%s%s%s\", \\\n\t          acl & PRSFS_READ       ? \"r\" : \"\", \\\n\t          acl & PRSFS_LOOKUP     ? \"l\" : \"\", \\\n\t          acl & PRSFS_INSERT     ? \"i\" : \"\", \\\n\t          acl & PRSFS_DELETE     ? \"d\" : \"\", \\\n\t          acl & PRSFS_WRITE      ? \"w\" : \"\", \\\n\t          acl & PRSFS_LOCK       ? \"k\" : \"\", \\\n\t          acl & PRSFS_ADMINISTER ? \"a\" : \"\");\n\n\tfor (i = 0; i < pos; i++) {\n\t\tif (sscanf((char *) s, \"%\" NUMSTRINGIFY(USERNAMEMAX) \"s %d\\n%n\", user, &acl, &n) != 2)\n\t\t\treturn;\n\t\ts += n;\n\t\tND_PRINT(\" +{\");\n\t\tfn_print_str(ndo, (u_char *)user);\n\t\tND_PRINT(\" \");\n\t\tACLOUT(acl);\n\t\tND_PRINT(\"}\");\n\t\tif (s > end)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < neg; i++) {\n\t\tif (sscanf((char *) s, \"%\" NUMSTRINGIFY(USERNAMEMAX) \"s %d\\n%n\", user, &acl, &n) != 2)\n\t\t\treturn;\n\t\ts += n;\n\t\tND_PRINT(\" -{\");\n\t\tfn_print_str(ndo, (u_char *)user);\n\t\tND_PRINT(\" \");\n\t\tACLOUT(acl);\n\t\tND_PRINT(\"}\");\n\t\tif (s > end)\n\t\t\treturn;\n\t}\n}\n\n#undef ACLOUT\n\n/*\n * Handle calls to the AFS callback service\n */\n\nstatic void\ncb_print(netdissect_options *ndo,\n         const u_char *bp, u_int length)\n{\n\tuint32_t cb_op;\n\tuint32_t i;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afscbint.xg\n\t */\n\n\tcb_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" cb call %s\", tok2str(cb_req, \"op#%u\", cb_op));\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afscbint.xg\n\t */\n\n\tswitch (cb_op) {\n\t\tcase 204:\t\t/* Callback */\n\t\t{\n\t\t\tuint32_t j, t;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tFIDOUT();\n\t\t\t\tif (i != j - 1)\n\t\t\t\t\tND_PRINT(\",\");\n\t\t\t}\n\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\tif (j != 0)\n\t\t\t\tND_PRINT(\";\");\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tND_PRINT(\" ver\");\n\t\t\t\tINTOUT();\n\t\t\t\tND_PRINT(\" expires\");\n\t\t\t\tDATEOUT();\n\t\t\t\tt = GET_BE_U_4(bp);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t\ttok2str(cb_types, \"type %u\", t);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 214: {\n\t\t\tND_PRINT(\" afsuuid\");\n\t\t\tAFSUUIDOUT();\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|cb]\");\n}\n\n/*\n * Handle replies to the AFS Callback Service\n */\n\nstatic void\ncb_reply_print(netdissect_options *ndo,\n               const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afscbint.xg\n\t */\n\n\tND_PRINT(\" cb reply %s\", tok2str(cb_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 213:\t/* InitCallBackState3 */\n\t\t\tAFSUUIDOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t;\n\t\t}\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|cb]\");\n}\n\n/*\n * Handle calls to the AFS protection database server\n */\n\nstatic void\nprot_print(netdissect_options *ndo,\n           const u_char *bp, u_int length)\n{\n\tuint32_t i;\n\tuint32_t pt_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ptserver/ptint.xg\n\t */\n\n\tpt_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" pt\");\n\n\tif (is_ubik(pt_op)) {\n\t\tubik_print(ndo, bp);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" call %s\", tok2str(pt_req, \"op#%u\", pt_op));\n\n\t/*\n\t * Decode some of the arguments to the PT calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (pt_op) {\n\t\tcase 500:\t/* I New User */\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" oldid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 501:\t/* Where is it */\n\t\tcase 506:\t/* Delete */\n\t\tcase 508:\t/* Get CPS */\n\t\tcase 512:\t/* List entry */\n\t\tcase 514:\t/* List elements */\n\t\tcase 517:\t/* List owned */\n\t\tcase 518:\t/* Get CPS2 */\n\t\tcase 519:\t/* Get host CPS */\n\t\tcase 530:\t/* List super groups */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 502:\t/* Dump entry */\n\t\t\tND_PRINT(\" pos\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 503:\t/* Add to group */\n\t\tcase 507:\t/* Remove from group */\n\t\tcase 515:\t/* Is a member of? */\n\t\t\tND_PRINT(\" uid\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" gid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 504:\t/* Name to ID */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * Who designed this chicken-shit protocol?\n\t\t\t *\n\t\t\t * Each character is stored as a 32-bit\n\t\t\t * integer!\n\t\t\t */\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tVECOUT(PRNAMEMAX);\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t/* Id to name */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tND_PRINT(\" ids:\");\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tINTOUT();\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 509:\t/* New entry */\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tND_PRINT(\" flag\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" oid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 511:\t/* Set max */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" gflag\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 513:\t/* Change entry */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tND_PRINT(\" oldid\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" newid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 520:\t/* Update entry */\n\t\t\tND_PRINT(\" id\");\n\t\t\tINTOUT();\n\t\t\tSTROUT(PRNAMEMAX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|pt]\");\n}\n\n/*\n * Handle replies to the AFS protection service\n */\n\nstatic void\nprot_reply_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\tuint32_t i;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ptserver/ptint.xg.  Check to see if it's a\n\t * Ubik call, however.\n\t */\n\n\tND_PRINT(\" pt\");\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" reply %s\", tok2str(pt_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 504:\t\t/* Name to ID */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tND_PRINT(\" ids:\");\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tINTOUT();\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t\t/* ID to name */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * Who designed this chicken-shit protocol?\n\t\t\t *\n\t\t\t * Each character is stored as a 32-bit\n\t\t\t * integer!\n\t\t\t */\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tVECOUT(PRNAMEMAX);\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 508:\t\t/* Get CPS */\n\t\tcase 514:\t\t/* List elements */\n\t\tcase 517:\t\t/* List owned */\n\t\tcase 518:\t\t/* Get CPS2 */\n\t\tcase 519:\t\t/* Get host CPS */\n\t\t{\n\t\t\tuint32_t j;\n\t\t\tj = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tINTOUT();\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT(\" <none!>\");\n\t\t}\n\t\t\tbreak;\n\t\tcase 510:\t\t/* List max */\n\t\t\tND_PRINT(\" maxuid\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" maxgid\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|pt]\");\n}\n\n/*\n * Handle calls to the AFS volume location database service\n */\n\nstatic void\nvldb_print(netdissect_options *ndo,\n           const u_char *bp, u_int length)\n{\n\tuint32_t vldb_op;\n\tuint32_t i;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from vlserver/vldbint.xg\n\t */\n\n\tvldb_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" vldb\");\n\n\tif (is_ubik(vldb_op)) {\n\t\tubik_print(ndo, bp);\n\t\treturn;\n\t}\n\tND_PRINT(\" call %s\", tok2str(vldb_req, \"op#%u\", vldb_op));\n\n\t/*\n\t * Decode some of the arguments to the VLDB calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (vldb_op) {\n\t\tcase 501:\t/* Create new volume */\n\t\tcase 517:\t/* Create entry N */\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 502:\t/* Delete entry */\n\t\tcase 503:\t/* Get entry by ID */\n\t\tcase 507:\t/* Update entry */\n\t\tcase 508:\t/* Set lock */\n\t\tcase 509:\t/* Release lock */\n\t\tcase 518:\t/* Get entry by ID N */\n\t\t\tND_PRINT(\" volid\");\n\t\t\tINTOUT();\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tif (i <= 2)\n\t\t\t\tND_PRINT(\" type %s\", voltype[i]);\n\t\t\tbreak;\n\t\tcase 504:\t/* Get entry by name */\n\t\tcase 519:\t/* Get entry by name N */\n\t\tcase 524:\t/* Update entry by name */\n\t\tcase 527:\t/* Get entry by name U */\n\t\t\tSTROUT(VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 505:\t/* Get new vol id */\n\t\t\tND_PRINT(\" bump\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 506:\t/* Replace entry */\n\t\tcase 520:\t/* Replace entry N */\n\t\t\tND_PRINT(\" volid\");\n\t\t\tINTOUT();\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tif (i <= 2)\n\t\t\t\tND_PRINT(\" type %s\", voltype[i]);\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 510:\t/* List entry */\n\t\tcase 521:\t/* List entry N */\n\t\t\tND_PRINT(\" index\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vldb]\");\n}\n\n/*\n * Handle replies to the AFS volume location database service\n */\n\nstatic void\nvldb_reply_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\tuint32_t i;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from vlserver/vldbint.xg.  Check to see if it's a\n\t * Ubik call, however.\n\t */\n\n\tND_PRINT(\" vldb\");\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" reply %s\", tok2str(vldb_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 510:\t/* List entry */\n\t\t\tND_PRINT(\" count\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" nextindex\");\n\t\t\tINTOUT();\n\t\t\tND_FALL_THROUGH;\n\t\tcase 503:\t/* Get entry by id */\n\t\tcase 504:\t/* Get entry by name */\n\t\t{\tuint32_t nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_TCHECK_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" numservers\");\n\t\t\tnservers = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" %u\", nservers);\n\t\t\tND_PRINT(\" servers\");\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tND_TCHECK_4(bp);\n\t\t\t\tif (i < nservers)\n\t\t\t\t\tND_PRINT(\" %s\",\n\t\t\t\t\t   intoa(GET_IPV4_TO_NETWORK_ORDER(bp)));\n\t\t\t\tbp += sizeof(nd_ipv4);\n\t\t\t}\n\t\t\tND_PRINT(\" partitions\");\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT(\" %c\", 'a' + j);\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT(\" %u\", j);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 8 * sizeof(uint32_t));\n\t\t\tbp += 8 * sizeof(uint32_t);\n\t\t\tND_PRINT(\" rwvol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" rovol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t/* Get new volume ID */\n\t\t\tND_PRINT(\" newvol\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 521:\t/* List entry */\n\t\tcase 529:\t/* List entry U */\n\t\t\tND_PRINT(\" count\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" nextindex\");\n\t\t\tINTOUT();\n\t\t\tND_FALL_THROUGH;\n\t\tcase 518:\t/* Get entry by ID N */\n\t\tcase 519:\t/* Get entry by name N */\n\t\t{\tuint32_t nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_PRINT(\" numservers\");\n\t\t\tnservers = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" %u\", nservers);\n\t\t\tND_PRINT(\" servers\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tND_TCHECK_4(bp);\n\t\t\t\tif (i < nservers)\n\t\t\t\t\tND_PRINT(\" %s\",\n\t\t\t\t\t   intoa(GET_IPV4_TO_NETWORK_ORDER(bp)));\n\t\t\t\tbp += sizeof(nd_ipv4);\n\t\t\t}\n\t\t\tND_PRINT(\" partitions\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT(\" %c\", 'a' + j);\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT(\" %u\", j);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 13 * sizeof(uint32_t));\n\t\t\tbp += 13 * sizeof(uint32_t);\n\t\t\tND_PRINT(\" rwvol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" rovol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t}\n\t\t\tbreak;\n\t\tcase 526:\t/* Get entry by ID U */\n\t\tcase 527:\t/* Get entry by name U */\n\t\t{\tuint32_t nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_PRINT(\" numservers\");\n\t\t\tnservers = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" %u\", nservers);\n\t\t\tND_PRINT(\" servers\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tif (i < nservers) {\n\t\t\t\t\tND_PRINT(\" afsuuid\");\n\t\t\t\t\tAFSUUIDOUT();\n\t\t\t\t} else {\n\t\t\t\t\tND_TCHECK_LEN(bp, 44);\n\t\t\t\t\tbp += 44;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 4 * 13);\n\t\t\tbp += 4 * 13;\n\t\t\tND_PRINT(\" partitions\");\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT(\" %c\", 'a' + j);\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT(\" %u\", j);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t}\n\t\t\tND_TCHECK_LEN(bp, 13 * sizeof(uint32_t));\n\t\t\tbp += 13 * sizeof(uint32_t);\n\t\t\tND_PRINT(\" rwvol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" rovol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t}\n\t\tdefault:\n\t\t\t;\n\t\t}\n\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vldb]\");\n}\n\n/*\n * Handle calls to the AFS Kerberos Authentication service\n */\n\nstatic void\nkauth_print(netdissect_options *ndo,\n            const u_char *bp, u_int length)\n{\n\tuint32_t kauth_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from kauth/kauth.rg\n\t */\n\n\tkauth_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" kauth\");\n\n\tif (is_ubik(kauth_op)) {\n\t\tubik_print(ndo, bp);\n\t\treturn;\n\t}\n\n\n\tND_PRINT(\" call %s\", tok2str(kauth_req, \"op#%u\", kauth_op));\n\n\t/*\n\t * Decode some of the arguments to the KA calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (kauth_op) {\n\t\tcase 1:\t\t/* Authenticate old */\n\t\tcase 21:\t/* Authenticate */\n\t\tcase 22:\t/* Authenticate-V2 */\n\t\tcase 2:\t\t/* Change PW */\n\t\tcase 5:\t\t/* Set fields */\n\t\tcase 6:\t\t/* Create user */\n\t\tcase 7:\t\t/* Delete user */\n\t\tcase 8:\t\t/* Get entry */\n\t\tcase 14:\t/* Unlock */\n\t\tcase 15:\t/* Lock status */\n\t\t\tND_PRINT(\" principal\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* GetTicket-old */\n\t\tcase 23:\t/* GetTicket */\n\t\t{\n\t\t\tuint32_t i;\n\t\t\tND_PRINT(\" kvno\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" domain\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\ti = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_TCHECK_LEN(bp, i);\n\t\t\tbp += i;\n\t\t\tND_PRINT(\" principal\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:\t\t/* Set Password */\n\t\t\tND_PRINT(\" principal\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tND_PRINT(\" kvno\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 12:\t/* Get password */\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(KANAMEMAX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|kauth]\");\n}\n\n/*\n * Handle replies to the AFS Kerberos Authentication Service\n */\n\nstatic void\nkauth_reply_print(netdissect_options *ndo,\n                  const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from kauth/kauth.rg\n\t */\n\n\tND_PRINT(\" kauth\");\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT(\" reply %s\", tok2str(kauth_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\t/* Well, no, not really.  Leave this for later */\n\t\t;\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n}\n\n/*\n * Handle calls to the AFS Volume location service\n */\n\nstatic void\nvol_print(netdissect_options *ndo,\n          const u_char *bp, u_int length)\n{\n\tuint32_t vol_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from volser/volint.xg\n\t */\n\n\tvol_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" vol call %s\", tok2str(vol_req, \"op#%u\", vol_op));\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (vol_op) {\n\t\tcase 100:\t/* Create volume */\n\t\t\tND_PRINT(\" partition\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" type\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" parent\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 101:\t/* Delete volume */\n\t\tcase 107:\t/* Get flags */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 102:\t/* Restore */\n\t\t\tND_PRINT(\" totrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 103:\t/* Forward */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\tDESTSERVEROUT();\n\t\t\tND_PRINT(\" desttrans\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 104:\t/* End trans */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 105:\t/* Clone */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" purgevol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" newtype\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" newname\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 106:\t/* Set flags */\n\t\t\tND_PRINT(\" trans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 108:\t/* Trans create */\n\t\t\tND_PRINT(\" vol\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" partition\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 109:\t/* Dump */\n\t\tcase 655537:\t/* Get size */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tcase 110:\t/* Get n-th volume */\n\t\t\tND_PRINT(\" index\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 111:\t/* Set forwarding */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" newsite\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 112:\t/* Get name */\n\t\tcase 113:\t/* Get status */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tbreak;\n\t\tcase 114:\t/* Signal restore */\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" type\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" pid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" cloneid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 116:\t/* List volumes */\n\t\t\tND_PRINT(\" partition\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 117:\t/* Set id types */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT(\" type\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" pid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" clone\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" backup\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 119:\t/* Partition info */\n\t\t\tND_PRINT(\" name\");\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 120:\t/* Reclone */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 121:\t/* List one volume */\n\t\tcase 122:\t/* Nuke volume */\n\t\tcase 124:\t/* Extended List volumes */\n\t\tcase 125:\t/* Extended List one volume */\n\t\tcase 65536:\t/* Convert RO to RW volume */\n\t\t\tND_PRINT(\" partid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" volid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 123:\t/* Set date */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" date\");\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tcase 126:\t/* Set info */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 128:\t/* Forward multiple */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\t{\n\t\t\t\tuint32_t i, j;\n\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\t\tDESTSERVEROUT();\n\t\t\t\t\tif (i != j - 1)\n\t\t\t\t\t\tND_PRINT(\",\");\n\t\t\t\t}\n\t\t\t\tif (j == 0)\n\t\t\t\t\tND_PRINT(\" <none!>\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 65538:\t/* Dump version 2 */\n\t\t\tND_PRINT(\" fromtrans\");\n\t\t\tUINTOUT();\n\t\t\tND_PRINT(\" fromdate\");\n\t\t\tDATEOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vol]\");\n}\n\n/*\n * Handle replies to the AFS Volume Service\n */\n\nstatic void\nvol_reply_print(netdissect_options *ndo,\n                const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from volser/volint.xg\n\t */\n\n\tND_PRINT(\" vol reply %s\", tok2str(vol_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA) {\n\t\tswitch (opcode) {\n\t\t\tcase 100:\t/* Create volume */\n\t\t\t\tND_PRINT(\" volid\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" trans\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 104:\t/* End transaction */\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 105:\t/* Clone */\n\t\t\t\tND_PRINT(\" newvol\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 107:\t/* Get flags */\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 108:\t/* Transaction create */\n\t\t\t\tND_PRINT(\" trans\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 110:\t/* Get n-th volume */\n\t\t\t\tND_PRINT(\" volume\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" partition\");\n\t\t\t\tUINTOUT();\n\t\t\t\tbreak;\n\t\t\tcase 112:\t/* Get name */\n\t\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\t\tbreak;\n\t\t\tcase 113:\t/* Get status */\n\t\t\t\tND_PRINT(\" volid\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" nextuniq\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" type\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" parentid\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" clone\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" backup\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" restore\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" maxquota\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" minquota\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" owner\");\n\t\t\t\tUINTOUT();\n\t\t\t\tND_PRINT(\" create\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" access\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" update\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" expire\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" backup\");\n\t\t\t\tDATEOUT();\n\t\t\t\tND_PRINT(\" copy\");\n\t\t\t\tDATEOUT();\n\t\t\t\tbreak;\n\t\t\tcase 115:\t/* Old list partitions */\n\t\t\t\tbreak;\n\t\t\tcase 116:\t/* List volumes */\n\t\t\tcase 121:\t/* List one volume */\n\t\t\t\t{\n\t\t\t\t\tuint32_t i, j;\n\t\t\t\t\tj = GET_BE_U_4(bp);\n\t\t\t\t\tbp += sizeof(uint32_t);\n\t\t\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\t\t\tND_PRINT(\" name\");\n\t\t\t\t\t\tVECOUT(32);\n\t\t\t\t\t\tND_PRINT(\" volid\");\n\t\t\t\t\t\tUINTOUT();\n\t\t\t\t\t\tND_PRINT(\" type\");\n\t\t\t\t\t\tbp += sizeof(uint32_t) * 21;\n\t\t\t\t\t\tif (i != j - 1)\n\t\t\t\t\t\t\tND_PRINT(\",\");\n\t\t\t\t\t}\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\tND_PRINT(\" <none!>\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|vol]\");\n}\n\n/*\n * Handle calls to the AFS BOS service\n */\n\nstatic void\nbos_print(netdissect_options *ndo,\n          const u_char *bp, u_int length)\n{\n\tuint32_t bos_op;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from bozo/bosint.xg\n\t */\n\n\tbos_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" bos call %s\", tok2str(bos_req, \"op#%u\", bos_op));\n\n\t/*\n\t * Decode some of the arguments to the BOS calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (bos_op) {\n\t\tcase 80:\t/* Create B node */\n\t\t\tND_PRINT(\" type\");\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" instance\");\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 81:\t/* Delete B node */\n\t\tcase 83:\t/* Get status */\n\t\tcase 85:\t/* Get instance info */\n\t\tcase 87:\t/* Add super user */\n\t\tcase 88:\t/* Delete super user */\n\t\tcase 93:\t/* Set cell name */\n\t\tcase 96:\t/* Add cell host */\n\t\tcase 97:\t/* Delete cell host */\n\t\tcase 104:\t/* Restart */\n\t\tcase 106:\t/* Uninstall */\n\t\tcase 108:\t/* Exec */\n\t\tcase 112:\t/* Getlog */\n\t\tcase 114:\t/* Get instance strings */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 82:\t/* Set status */\n\t\tcase 98:\t/* Set T status */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" status\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 86:\t/* Get instance parm */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" num\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 84:\t/* Enumerate instance */\n\t\tcase 89:\t/* List super users */\n\t\tcase 90:\t/* List keys */\n\t\tcase 91:\t/* Add key */\n\t\tcase 92:\t/* Delete key */\n\t\tcase 95:\t/* Get cell host */\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 105:\t/* Install */\n\t\t\tSTROUT(BOSNAMEMAX);\n\t\t\tND_PRINT(\" size\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" flags\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" date\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|bos]\");\n}\n\n/*\n * Handle replies to the AFS BOS Service\n */\n\nstatic void\nbos_reply_print(netdissect_options *ndo,\n                const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length <= sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from volser/volint.xg\n\t */\n\n\tND_PRINT(\" bos reply %s\", tok2str(bos_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response.\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\t/* Well, no, not really.  Leave this for later */\n\t\t;\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT(\" errcode\");\n\t\tINTOUT();\n\t}\n}\n\n/*\n * Check to see if this is a Ubik opcode.\n */\n\nstatic int\nis_ubik(uint32_t opcode)\n{\n\tif ((opcode >= VOTE_LOW && opcode <= VOTE_HIGH) ||\n\t    (opcode >= DISK_LOW && opcode <= DISK_HIGH))\n\t\treturn(1);\n\telse\n\t\treturn(0);\n}\n\n/*\n * Handle Ubik opcodes to any one of the replicated database services\n */\n\nstatic void\nubik_print(netdissect_options *ndo,\n           const u_char *bp)\n{\n\tuint32_t ubik_op;\n\tuint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\t/* Every function that calls this function first makes a bounds check\n\t * for (sizeof(rx_header) + 4) bytes, so long as it remains this way\n\t * the line below will not over-read.\n\t */\n\tubik_op = GET_BE_U_4(bp + sizeof(struct rx_header));\n\n\tND_PRINT(\" ubik call %s\", tok2str(ubik_req, \"op#%u\", ubik_op));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\ttemp = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\tND_PRINT(\" syncsite %s\", temp ? \"yes\" : \"no\");\n\t\t\tND_PRINT(\" votestart\");\n\t\t\tDATEOUT();\n\t\t\tND_PRINT(\" dbversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT(\" site\");\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" pos\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tINTOUT();\n\t\t\ttemp = GET_BE_U_4(bp);\n\t\t\tbp += sizeof(uint32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %u\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" pos\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" dbversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" file\");\n\t\t\tINTOUT();\n\t\t\tND_PRINT(\" length\");\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT(\" tid\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" oldversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT(\" newversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|ubik]\");\n}\n\n/*\n * Handle Ubik replies to any one of the replicated database services\n */\n\nstatic void\nubik_reply_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length, uint32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tuint8_t type;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the ubik call we're invoking.  This table was gleaned\n\t * from ubik/ubik_int.xg\n\t */\n\n\tND_PRINT(\" ubik reply %s\", tok2str(ubik_req, \"op#%u\", opcode));\n\n\ttype = GET_U_1(rxh->type);\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, print out the arguments to the Ubik calls\n\t */\n\n\tif (type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_PRINT(\" vote no\");\n\t\t\tbreak;\n\t\tcase 20004:\t\t/* Get version */\n\t\t\tND_PRINT(\" dbversion\");\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\n\t/*\n\t * Otherwise, print out \"yes\" if it was a beacon packet (because\n\t * that's how yes votes are returned, go figure), otherwise\n\t * just print out the error code.\n\t */\n\n\telse\n\t\tswitch (opcode) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_PRINT(\" vote yes until\");\n\t\t\tDATEOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT(\" errcode\");\n\t\t\tINTOUT();\n\t\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|ubik]\");\n}\n\n/*\n * Handle RX ACK packets.\n */\n\nstatic void\nrx_ack_print(netdissect_options *ndo,\n             const u_char *bp, u_int length)\n{\n\tconst struct rx_ackPacket *rxa;\n\tuint8_t nAcks;\n\tint i, start, last;\n\tuint32_t firstPacket;\n\n\tif (length < sizeof(struct rx_header))\n\t\treturn;\n\n\tbp += sizeof(struct rx_header);\n\n\tND_TCHECK_LEN(bp, sizeof(struct rx_ackPacket));\n\n\trxa = (const struct rx_ackPacket *) bp;\n\tbp += sizeof(struct rx_ackPacket);\n\n\t/*\n\t * Print out a few useful things from the ack packet structure\n\t */\n\n\tif (ndo->ndo_vflag > 2)\n\t\tND_PRINT(\" bufspace %u maxskew %u\",\n\t\t       GET_BE_U_2(rxa->bufferSpace),\n\t\t       GET_BE_U_2(rxa->maxSkew));\n\n\tfirstPacket = GET_BE_U_4(rxa->firstPacket);\n\tND_PRINT(\" first %u serial %u reason %s\",\n\t       firstPacket, GET_BE_U_4(rxa->serial),\n\t       tok2str(rx_ack_reasons, \"#%u\", GET_U_1(rxa->reason)));\n\n\t/*\n\t * Okay, now we print out the ack array.  The way _this_ works\n\t * is that we start at \"first\", and step through the ack array.\n\t * If we have a contiguous range of acks/nacks, try to\n\t * collapse them into a range.\n\t *\n\t * If you're really clever, you might have noticed that this\n\t * doesn't seem quite correct.  Specifically, due to structure\n\t * padding, sizeof(struct rx_ackPacket) - RX_MAXACKS won't actually\n\t * yield the start of the ack array (because RX_MAXACKS is 255\n\t * and the structure will likely get padded to a 2 or 4 byte\n\t * boundary).  However, this is the way it's implemented inside\n\t * of AFS - the start of the extra fields are at\n\t * sizeof(struct rx_ackPacket) - RX_MAXACKS + nAcks, which _isn't_\n\t * the exact start of the ack array.  Sigh.  That's why we aren't\n\t * using bp, but instead use rxa->acks[].  But nAcks gets added\n\t * to bp after this, so bp ends up at the right spot.  Go figure.\n\t */\n\n\tnAcks = GET_U_1(rxa->nAcks);\n\tif (nAcks != 0) {\n\n\t\tND_TCHECK_LEN(bp, nAcks);\n\n\t\t/*\n\t\t * Sigh, this is gross, but it seems to work to collapse\n\t\t * ranges correctly.\n\t\t */\n\n\t\tfor (i = 0, start = last = -2; i < nAcks; i++)\n\t\t\tif (GET_U_1(bp + i) == RX_ACK_TYPE_ACK) {\n\n\t\t\t\t/*\n\t\t\t\t * I figured this deserved _some_ explanation.\n\t\t\t\t * First, print \"acked\" and the packet seq\n\t\t\t\t * number if this is the first time we've\n\t\t\t\t * seen an acked packet.\n\t\t\t\t */\n\n\t\t\t\tif (last == -2) {\n\t\t\t\t\tND_PRINT(\" acked %u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, if there is a skip in\n\t\t\t\t * the range (such as an nacked packet in\n\t\t\t\t * the middle of some acked packets),\n\t\t\t\t * then print the current packet number\n\t\t\t\t * separated from the last number by\n\t\t\t\t * a comma.\n\t\t\t\t */\n\n\t\t\t\telse if (last != i - 1) {\n\t\t\t\t\tND_PRINT(\",%u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We always set last to the value of\n\t\t\t\t * the last ack we saw.  Conversely, start\n\t\t\t\t * is set to the value of the first ack\n\t\t\t\t * we saw in a range.\n\t\t\t\t */\n\n\t\t\t\tlast = i;\n\n\t\t\t\t/*\n\t\t\t\t * Okay, this bit a code gets executed when\n\t\t\t\t * we hit a nack ... in _this_ case we\n\t\t\t\t * want to print out the range of packets\n\t\t\t\t * that were acked, so we need to print\n\t\t\t\t * the _previous_ packet number separated\n\t\t\t\t * from the first by a dash (-).  Since we\n\t\t\t\t * already printed the first packet above,\n\t\t\t\t * just print the final packet.  Don't\n\t\t\t\t * do this if there will be a single-length\n\t\t\t\t * range.\n\t\t\t\t */\n\t\t\t} else if (last == i - 1 && start != last)\n\t\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\t/*\n\t\t * So, what's going on here?  We ran off the end of the\n\t\t * ack list, and if we got a range we need to finish it up.\n\t\t * So we need to determine if the last packet in the list\n\t\t * was an ack (if so, then last will be set to it) and\n\t\t * we need to see if the last range didn't start with the\n\t\t * last packet (because if it _did_, then that would mean\n\t\t * that the packet number has already been printed and\n\t\t * we don't need to print it again).\n\t\t */\n\n\t\tif (last == i - 1 && start != last)\n\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\t/*\n\t\t * Same as above, just without comments\n\t\t */\n\n\t\tfor (i = 0, start = last = -2; i < nAcks; i++)\n\t\t\tif (GET_U_1(bp + i) == RX_ACK_TYPE_NACK) {\n\t\t\t\tif (last == -2) {\n\t\t\t\t\tND_PRINT(\" nacked %u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t} else if (last != i - 1) {\n\t\t\t\t\tND_PRINT(\",%u\", firstPacket + i);\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\t\t\t\tlast = i;\n\t\t\t} else if (last == i - 1 && start != last)\n\t\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\tif (last == i - 1 && start != last)\n\t\t\tND_PRINT(\"-%u\", firstPacket + i - 1);\n\n\t\tbp += nAcks;\n\t}\n\n\t/* Padding. */\n\tbp += 3;\n\n\t/*\n\t * These are optional fields; depending on your version of AFS,\n\t * you may or may not see them\n\t */\n\n#define TRUNCRET(n)\tif (ndo->ndo_snapend - bp + 1 <= n) return;\n\n\tif (ndo->ndo_vflag > 1) {\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" ifmtu\");\n\t\tUINTOUT();\n\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" maxmtu\");\n\t\tUINTOUT();\n\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" rwind\");\n\t\tUINTOUT();\n\n\t\tTRUNCRET(4);\n\t\tND_PRINT(\" maxpackets\");\n\t\tUINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT(\" [|ack]\");\n}\n#undef TRUNCRET\n", "/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/* \\summary: ZigBee Encapsulation Protocol (ZEP) printer */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#define ND_LONGJMP_FROM_TCHECK\n#include \"netdissect.h\"\n\n#include \"extract.h\"\n\n/* From wireshark packet-zep.c:\n *\n ***********************************************************************\n *\n * ZEP Packets must be received in the following format:\n *\n * |UDP Header|  ZEP Header |IEEE 802.15.4 Packet|\n * | 8 bytes  | 16/32 bytes |    <= 127 bytes    |\n *\n ***********************************************************************\n *\n * ZEP v1 Header will have the following format:\n * |Preamble|Version|Channel ID|Device ID|CRC/LQI Mode|LQI Val|Reserved|Length|\n * |2 bytes |1 byte |  1 byte  | 2 bytes |   1 byte   |1 byte |7 bytes |1 byte|\n *\n * ZEP v2 Header will have the following format (if type=1/Data):\n * |Prmbl|Ver  |Type |ChnlID|DevID|C/L Mode|LQI|NTP TS|Seq#|Res |Len|\n * | 2   | 1   | 1   | 1    | 2   | 1      | 1 | 8    | 4  | 10 | 1 |\n *\n * ZEP v2 Header will have the following format (if type=2/Ack):\n * |Preamble|Version| Type |Sequence#|\n * |2 bytes |1 byte |1 byte| 4 bytes |\n *------------------------------------------------------------\n */\n\n#define     JAN_1970        2208988800U\n\n/* Print timestamp */\nstatic void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           /* some compilers are buggy */\n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); /* shift radix point by 32 bits */\n\tf = (uint32_t) (ff * 1000000000.0);  /* treat fraction as parts per\n\t\t\t\t\t\tbillion */\n\tND_PRINT(\"%u.%09d\", i, f);\n\n\t/*\n\t * print the time in human-readable format.\n\t */\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tchar time_buf[128];\n\n\t\tND_PRINT(\" (%s)\",\n\t\t    nd_format_time(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\",\n\t\t      localtime(&seconds)));\n\t}\n}\n\n/*\n * Main function to print packets.\n */\n\nvoid\nzep_print(netdissect_options *ndo,\n\t  const u_char *bp, u_int len)\n{\n\tuint8_t version, inner_len;\n\tuint32_t seq_no;\n\n\tndo->ndo_protocol = \"zep\";\n\n\tnd_print_protocol_caps(ndo);\n\n\t/* Preamble Code (must be \"EX\") */\n\tif (GET_U_1(bp) != 'E' || GET_U_1(bp + 1) != 'X') {\n\t\tND_PRINT(\" [Preamble Code: \");\n\t\tfn_print_char(ndo, GET_U_1(bp));\n\t\tfn_print_char(ndo, GET_U_1(bp + 1));\n\t\tND_PRINT(\"]\");\n\t\tnd_print_invalid(ndo);\n\t\treturn;\n\t}\n\n\tversion = GET_U_1(bp + 2);\n\tND_PRINT(\"v%u \", version);\n\n\tif (version == 1) {\n\t\t/* ZEP v1 packet. */\n\t\tND_LCHECK_U(len, 16);\n\t\tND_PRINT(\"Channel ID %u, Device ID 0x%04x, \",\n\t\t\t GET_U_1(bp + 3), GET_BE_U_2(bp + 4));\n\t\tif (GET_U_1(bp + 6))\n\t\t\tND_PRINT(\"CRC, \");\n\t\telse\n\t\t\tND_PRINT(\"LQI %u, \", GET_U_1(bp + 7));\n\t\tinner_len = GET_U_1(bp + 15);\n\t\tND_PRINT(\"inner len = %u\", inner_len);\n\n\t\tbp += 16;\n\t\tlen -= 16;\n\t} else {\n\t\t/* ZEP v2 packet. */\n\t\tif (GET_U_1(bp + 3) == 2) {\n\t\t\t/* ZEP v2 ack. */\n\t\t\tND_LCHECK_U(len, 8);\n\t\t\tseq_no = GET_BE_U_4(bp + 4);\n\t\t\tND_PRINT(\"ACK, seq# = %u\", seq_no);\n\t\t\tinner_len = 0;\n\t\t\tbp += 8;\n\t\t\tlen -= 8;\n\t\t} else {\n\t\t\t/* ZEP v2 data, or some other. */\n\t\t\tND_LCHECK_U(len, 32);\n\t\t\tND_PRINT(\"Type %u, Channel ID %u, Device ID 0x%04x, \",\n\t\t\t\t GET_U_1(bp + 3), GET_U_1(bp + 4),\n\t\t\t\t GET_BE_U_2(bp + 5));\n\t\t\tif (GET_U_1(bp + 7))\n\t\t\t\tND_PRINT(\"CRC, \");\n\t\t\telse\n\t\t\t\tND_PRINT(\"LQI %u, \", GET_U_1(bp + 8));\n\n\t\t\tzep_print_ts(ndo, bp + 9);\n\t\t\tseq_no = GET_BE_U_4(bp + 17);\n\t\t\tinner_len = GET_U_1(bp + 31);\n\t\t\tND_PRINT(\", seq# = %u, inner len = %u\",\n\t\t\t\t seq_no, inner_len);\n\t\t\tbp += 32;\n\t\t\tlen -= 32;\n\t\t}\n\t}\n\n\tif (inner_len != 0) {\n\t\t/* Call 802.15.4 dissector. */\n\t\tND_PRINT(\"\\n\\t\");\n\t\tif (ieee802_15_4_print(ndo, bp, inner_len)) {\n\t\t\tND_TCHECK_LEN(bp, len);\n\t\t\tbp += len;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(bp, len);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n}\n", "/*\n * Copyright (C) Andrew Tridgell 1995-1999\n *\n * This software may be distributed either under the terms of the\n * BSD-style license that accompanies tcpdump or the GNU GPL version 2\n * or later\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"netdissect-ctype.h\"\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"smb.h\"\n\nstatic int stringlen_is_set;\nstatic uint32_t stringlen;\nextern const u_char *startbuf;\n\n/*\n * Reset SMB state.\n */\nvoid\nsmb_reset(void)\n{\n    stringlen_is_set = 0;\n    stringlen = 0;\n}\n\n/*\n * interpret a 32 bit dos packed date/time to some parameters\n */\nstatic void\ninterpret_dos_date(uint32_t date, struct tm *tp)\n{\n    uint32_t p0, p1, p2, p3;\n\n    p0 = date & 0xFF;\n    p1 = ((date & 0xFF00) >> 8) & 0xFF;\n    p2 = ((date & 0xFF0000) >> 16) & 0xFF;\n    p3 = ((date & 0xFF000000) >> 24) & 0xFF;\n\n    tp->tm_sec = 2 * (p0 & 0x1F);\n    tp->tm_min = ((p0 >> 5) & 0xFF) + ((p1 & 0x7) << 3);\n    tp->tm_hour = (p1 >> 3) & 0xFF;\n    tp->tm_mday = (p2 & 0x1F);\n    tp->tm_mon = ((p2 >> 5) & 0xFF) + ((p3 & 0x1) << 3) - 1;\n    tp->tm_year = ((p3 >> 1) & 0xFF) + 80;\n}\n\n/*\n * common portion:\n * create a unix date from a dos date\n */\nstatic time_t\nint_unix_date(uint32_t dos_date)\n{\n    struct tm t;\n\n    if (dos_date == 0)\n\treturn(0);\n\n    interpret_dos_date(dos_date, &t);\n    t.tm_wday = 1;\n    t.tm_yday = 1;\n    t.tm_isdst = 0;\n\n    return (mktime(&t));\n}\n\n/*\n * create a unix date from a dos date\n * in network byte order\n */\nstatic time_t\nmake_unix_date(netdissect_options *ndo, const u_char *date_ptr)\n{\n    uint32_t dos_date = 0;\n\n    dos_date = GET_LE_U_4(date_ptr);\n\n    return int_unix_date(dos_date);\n}\n\n/*\n * create a unix date from a dos date\n * in halfword-swapped network byte order!\n */\nstatic time_t\nmake_unix_date2(netdissect_options *ndo, const u_char *date_ptr)\n{\n    uint32_t x, x2;\n\n    x = GET_LE_U_4(date_ptr);\n    x2 = ((x & 0xFFFF) << 16) | ((x & 0xFFFF0000) >> 16);\n    return int_unix_date(x2);\n}\n\n/*\n * interpret an 8 byte \"filetime\" structure to a time_t\n * It's originally in \"100ns units since jan 1st 1601\"\n */\nstatic time_t\ninterpret_long_date(netdissect_options *ndo, const u_char *p)\n{\n    double d;\n    time_t ret;\n\n    /* this gives us seconds since jan 1st 1601 (approx) */\n    d = (GET_LE_U_4(p + 4) * 256.0 + GET_U_1(p + 3)) * (1.0e-7 * (1 << 24));\n\n    /* now adjust by 369 years to make the secs since 1970 */\n    d -= 369.0 * 365.25 * 24 * 60 * 60;\n\n    /* and a fudge factor as we got it wrong by a few days */\n    d += (3 * 24 * 60 * 60 + 6 * 60 * 60 + 2);\n\n    if (d < 0)\n\treturn(0);\n\n    ret = (time_t)d;\n\n    return(ret);\n}\n\n/*\n * interpret the weird netbios \"name\". Return the name type, or -1 if\n * we run past the end of the buffer\n */\nstatic int\nname_interpret(netdissect_options *ndo,\n               const u_char *in, const u_char *maxbuf, char *out)\n{\n    int ret;\n    u_int len;\n\n    if (in >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    len = GET_U_1(in) / 2;\n    in++;\n\n    *out=0;\n\n    if (len > 30 || len == 0)\n\treturn(0);\n\n    while (len) {\n\tND_TCHECK_2(in);\n\tif (in + 1 >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tif (GET_U_1(in) < 'A' || GET_U_1(in) > 'P' ||\n\t    GET_U_1(in + 1) < 'A' || GET_U_1(in + 1) > 'P') {\n\t    *out = 0;\n\t    return(0);\n\t}\n\t*out = ((GET_U_1(in) - 'A') << 4) + (GET_U_1(in + 1) - 'A');\n\tin += 2;\n\tout++;\n\tlen--;\n    }\n    *out = 0;\n    ret = out[-1];\n\n    return(ret);\n\ntrunc:\n    return(-1);\n}\n\n/*\n * find a pointer to a netbios name\n */\nstatic const u_char *\nname_ptr(netdissect_options *ndo,\n         const u_char *buf, u_int ofs, const u_char *maxbuf)\n{\n    const u_char *p;\n    u_char c;\n\n    p = buf + ofs;\n    if (p >= maxbuf)\n\treturn(NULL);\t/* name goes past the end of the buffer */\n\n    c = GET_U_1(p);\n\n    /* XXX - this should use the same code that the DNS dissector does */\n    if ((c & 0xC0) == 0xC0) {\n\tuint16_t l;\n\n\tND_TCHECK_2(p);\n\tif ((p + 1) >= maxbuf)\n\t    return(NULL);\t/* name goes past the end of the buffer */\n\tl = GET_BE_U_2(p) & 0x3FFF;\n\tif (l == 0) {\n\t    /* We have a pointer that points to itself. */\n\t    return(NULL);\n\t}\n\tp = buf + l;\n\tif (p >= maxbuf)\n\t    return(NULL);\t/* name goes past the end of the buffer */\n\tND_TCHECK_1(p);\n    }\n    return(p);\n\ntrunc:\n    return(NULL);\t/* name goes past the end of the buffer */\n}\n\n/*\n * extract a netbios name from a buf\n */\nstatic int\nname_extract(netdissect_options *ndo,\n             const u_char *buf, u_int ofs, const u_char *maxbuf, char *name)\n{\n    const u_char *p = name_ptr(ndo, buf, ofs, maxbuf);\n    if (p == NULL)\n\treturn(-1);\t/* error (probably name going past end of buffer) */\n    name[0] = '\\0';\n    return(name_interpret(ndo, p, maxbuf, name));\n}\n\n\n/*\n * return the total storage length of a mangled name\n */\nstatic int\nname_len(netdissect_options *ndo,\n         const u_char *s, const u_char *maxbuf)\n{\n    const u_char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    c = GET_U_1(s);\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (GET_U_1(s)) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\ts += GET_U_1(s) + 1;\n\tND_TCHECK_1(s);\n    }\n    return(ND_BYTES_BETWEEN(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n\nstatic void\nprint_asc(netdissect_options *ndo,\n          const u_char *buf, u_int len)\n{\n    u_int i;\n    for (i = 0; i < len; i++)\n        fn_print_char(ndo, GET_U_1(buf + i));\n}\n\nstatic const char *\nname_type_str(int name_type)\n{\n    const char *f = NULL;\n\n    switch (name_type) {\n    case 0:    f = \"Workstation\"; break;\n    case 0x03: f = \"Client?\"; break;\n    case 0x20: f = \"Server\"; break;\n    case 0x1d: f = \"Master Browser\"; break;\n    case 0x1b: f = \"Domain Controller\"; break;\n    case 0x1e: f = \"Browser Server\"; break;\n    default:   f = \"Unknown\"; break;\n    }\n    return(f);\n}\n\nvoid\nsmb_data_print(netdissect_options *ndo, const u_char *buf, u_int len)\n{\n    u_int i = 0;\n\n    if (len == 0)\n\treturn;\n    ND_PRINT(\"[%03X] \", i);\n    for (i = 0; i < len; /*nothing*/) {\n\tND_PRINT(\"%02X \", GET_U_1(buf + i) & 0xff);\n\ti++;\n\tif (i%8 == 0)\n\t    ND_PRINT(\" \");\n\tif (i % 16 == 0) {\n\t    print_asc(ndo, buf + i - 16, 8);\n\t    ND_PRINT(\" \");\n\t    print_asc(ndo, buf + i - 8, 8);\n\t    ND_PRINT(\"\\n\");\n\t    if (i < len)\n\t\tND_PRINT(\"[%03X] \", i);\n\t}\n    }\n    if (i % 16) {\n\tint n;\n\n\tn = 16 - (i % 16);\n\tND_PRINT(\" \");\n\tif (n>8)\n\t    ND_PRINT(\" \");\n\twhile (n--)\n\t    ND_PRINT(\"   \");\n\n\tn = ND_MIN(8, i % 16);\n\tprint_asc(ndo, buf + i - (i % 16), n);\n\tND_PRINT(\" \");\n\tn = (i % 16) - n;\n\tif (n > 0)\n\t    print_asc(ndo, buf + i - n, n);\n\tND_PRINT(\"\\n\");\n    }\n}\n\n\nstatic void\nwrite_bits(netdissect_options *ndo,\n           unsigned int val, const char *fmt)\n{\n    const char *p = fmt;\n    u_int i = 0;\n\n    while ((p = strchr(fmt, '|'))) {\n\tu_int l = ND_BYTES_BETWEEN(p, fmt);\n\tif (l && (val & (1 << i)))\n\t    ND_PRINT(\"%.*s \", (int)l, fmt);\n\tfmt = p + 1;\n\ti++;\n    }\n}\n\n/* convert a UCS-2 string into an ASCII string */\n#define MAX_UNISTR_SIZE\t1000\nstatic const u_char *\nunistr(netdissect_options *ndo, char (*buf)[MAX_UNISTR_SIZE+1],\n       const u_char *s, uint32_t strsize, int is_null_terminated,\n       int use_unicode)\n{\n    u_int c;\n    size_t l = 0;\n    const u_char *sp;\n\n    if (use_unicode) {\n\t/*\n\t * Skip padding that puts the string on an even boundary.\n\t */\n\tif (((s - startbuf) % 2) != 0) {\n\t    ND_TCHECK_1(s);\n\t    s++;\n\t}\n    }\n    if (is_null_terminated) {\n\t/*\n\t * Null-terminated string.\n\t * Find the length, counting the terminating NUL.\n\t */\n\tstrsize = 0;\n\tsp = s;\n\tif (!use_unicode) {\n\t    for (;;) {\n\t\tc = GET_U_1(sp);\n\t\tsp++;\n\t\tstrsize++;\n\t\tif (c == '\\0')\n\t\t    break;\n\t    }\n\t} else {\n\t    for (;;) {\n\t\tc = GET_LE_U_2(sp);\n\t\tsp += 2;\n\t\tstrsize += 2;\n\t\tif (c == '\\0')\n\t\t    break;\n\t    }\n\t}\n    }\n    if (!use_unicode) {\n\twhile (strsize != 0) {\n\t    c = GET_U_1(s);\n\t    s++;\n\t    strsize--;\n\t    if (c == 0) {\n\t\t/*\n\t\t * Even counted strings may have embedded null\n\t\t * terminators, so quit here, and skip past\n\t\t * the rest of the data.\n\t\t *\n\t\t * Make sure, however, that the rest of the data\n\t\t * is there, so we don't overflow the buffer when\n\t\t * skipping past it.\n\t\t */\n\t\tND_TCHECK_LEN(s, strsize);\n\t\ts += strsize;\n\t\tstrsize = 0;\n\t\tbreak;\n\t    }\n\t    if (l < MAX_UNISTR_SIZE) {\n\t\tif (ND_ASCII_ISPRINT(c)) {\n\t\t    /* It's a printable ASCII character */\n\t\t    (*buf)[l] = (char)c;\n\t\t} else {\n\t\t    /* It's a non-ASCII character or a non-printable ASCII character */\n\t\t    (*buf)[l] = '.';\n\t\t}\n\t\tl++;\n\t    }\n\t}\n    } else {\n\twhile (strsize > 1) {\n\t    c = GET_LE_U_2(s);\n\t    s += 2;\n\t    strsize -= 2;\n\t    if (c == 0) {\n\t\t/*\n\t\t * Even counted strings may have embedded null\n\t\t * terminators, so quit here, and skip past\n\t\t * the rest of the data.\n\t\t *\n\t\t * Make sure, however, that the rest of the data\n\t\t * is there, so we don't overflow the buffer when\n\t\t * skipping past it.\n\t\t */\n\t\tND_TCHECK_LEN(s, strsize);\n\t\ts += strsize;\n\t\tstrsize = 0;\n\t\tbreak;\n\t    }\n\t    if (l < MAX_UNISTR_SIZE) {\n\t\tif (ND_ASCII_ISPRINT(c)) {\n\t\t    /* It's a printable ASCII character */\n\t\t    (*buf)[l] = (char)c;\n\t\t} else {\n\t\t    /* It's a non-ASCII character or a non-printable ASCII character */\n\t\t    (*buf)[l] = '.';\n\t\t}\n\t\tl++;\n\t    }\n\t}\n\tif (strsize == 1) {\n\t    /* We have half of a code point; skip past it */\n\t    ND_TCHECK_1(s);\n\t    s++;\n\t}\n    }\n    (*buf)[l] = 0;\n    return s;\n\ntrunc:\n    (*buf)[l] = 0;\n    return NULL;\n}\n\nstatic const u_char *\nsmb_fdata1(netdissect_options *ndo,\n           const u_char *buf, const char *fmt, const u_char *maxbuf,\n           int unicodestr)\n{\n    int reverse = 0;\n    const char *attrib_fmt = \"READONLY|HIDDEN|SYSTEM|VOLUME|DIR|ARCHIVE|\";\n    char strbuf[MAX_UNISTR_SIZE+1];\n\n    while (*fmt && buf<maxbuf) {\n\tswitch (*fmt) {\n\tcase 'a':\n\t    write_bits(ndo, GET_U_1(buf), attrib_fmt);\n\t    buf++;\n\t    fmt++;\n\t    break;\n\n\tcase 'A':\n\t    write_bits(ndo, GET_LE_U_2(buf), attrib_fmt);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\n\tcase '{':\n\t  {\n\t    char bitfmt[128];\n\t    char *p;\n\t    u_int l;\n\n\t    p = strchr(++fmt, '}');\n\t    l = ND_BYTES_BETWEEN(p, fmt);\n\n\t    if (l > sizeof(bitfmt) - 1)\n\t\tl = sizeof(bitfmt)-1;\n\n\t    strncpy(bitfmt, fmt, l);\n\t    bitfmt[l] = '\\0';\n\t    fmt = p + 1;\n\t    write_bits(ndo, GET_U_1(buf), bitfmt);\n\t    buf++;\n\t    break;\n\t  }\n\n\tcase 'P':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'r':\n\t    reverse = !reverse;\n\t    fmt++;\n\t    break;\n\tcase 'b':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'd':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_2(buf) :\n\t\t\t  GET_LE_S_2(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'D':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_4(buf) :\n\t\t\t  GET_LE_S_4(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'L':\n\t  {\n\t    uint64_t x;\n\t    x = reverse ? GET_BE_U_8(buf) :\n\t\t\t  GET_LE_U_8(buf);\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'u':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'U':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'M':\n\t  {\n\t    /* Weird mixed-endian length values in 64-bit locks */\n\t    uint32_t x1, x2;\n\t    uint64_t x;\n\t    ND_TCHECK_8(buf);\n\t    x1 = reverse ? GET_BE_U_4(buf) :\n\t\t\t   GET_LE_U_4(buf);\n\t    x2 = reverse ? GET_BE_U_4(buf + 4) :\n\t\t\t   GET_LE_U_4(buf + 4);\n\t    x = (((uint64_t)x1) << 32) | x2;\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'B':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'w':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'W':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'l':\n\t  {\n\t    fmt++;\n\t    switch (*fmt) {\n\n\t    case 'b':\n\t\tstringlen = GET_U_1(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 1;\n\t\tbreak;\n\n\t    case 'd':\n\t    case 'u':\n\t\tstringlen = reverse ? GET_BE_U_2(buf) :\n\t\t\t\t      GET_LE_U_2(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 2;\n\t\tbreak;\n\n\t    case 'D':\n\t    case 'U':\n\t\tstringlen = reverse ? GET_BE_U_4(buf) :\n\t\t\t\t      GET_LE_U_4(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 4;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'S':\n\tcase 'R':\t/* like 'S', but always ASCII */\n\t  {\n\t    /*XXX unistr() */\n\t    buf = unistr(ndo, &strbuf, buf, 0, 1, (*fmt == 'R') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'Z':\n\tcase 'Y':\t/* like 'Z', but always ASCII */\n\t  {\n\t    if (GET_U_1(buf) != 4 && GET_U_1(buf) != 2) {\n\t\tND_PRINT(\"Error! ASCIIZ buffer of type %u\", GET_U_1(buf));\n\t\treturn maxbuf;\t/* give up */\n\t    }\n\t    buf = unistr(ndo, &strbuf, buf + 1, 0, 1, (*fmt == 'Y') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 's':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    ND_PRINT(\"%-*.*s\", l, l, buf);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'c':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    ND_TCHECK_LEN(buf, stringlen);\n\t    ND_PRINT(\"%-*.*s\", (int)stringlen, (int)stringlen, buf);\n\t    buf += stringlen;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'C':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    buf = unistr(ndo, &strbuf, buf, stringlen, 0, unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'h':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    while (l--) {\n\t\tND_PRINT(\"%02x\", GET_U_1(buf));\n\t\tbuf++;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'n':\n\t  {\n\t    int t = atoi(fmt+1);\n\t    char nbuf[255];\n\t    int name_type;\n\t    int len;\n\n\t    switch (t) {\n\t    case 1:\n\t\tname_type = name_extract(ndo, startbuf, ND_BYTES_BETWEEN(buf, startbuf),\n\t\t    maxbuf, nbuf);\n\t\tif (name_type < 0)\n\t\t    goto trunc;\n\t\tlen = name_len(ndo, buf, maxbuf);\n\t\tif (len < 0)\n\t\t    goto trunc;\n\t\tbuf += len;\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", nbuf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbreak;\n\t    case 2:\n\t\tname_type = GET_U_1(buf + 15);\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", buf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbuf += 16;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 2:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date2(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 3:\n\t\tND_TCHECK_8(buf);\n\t\tt = interpret_long_date(ndo, buf);\n\t\tbuf += 8;\n\t\tbreak;\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\t    tstring = nd_format_time(buffer, sizeof(buffer), \"%a %b %e %T %Y\",\n\t\t    localtime(&t));\n\t    } else\n\t\ttstring = \"NULL\";\n\t    ND_PRINT(\"%s\\n\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}\n    }\n\n    if (buf >= maxbuf && *fmt)\n\tND_PRINT(\"END OF BUFFER\\n\");\n\n    return(buf);\n\ntrunc:\n    nd_print_trunc(ndo);\n    return(NULL);\n}\n\nconst u_char *\nsmb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    /*\n\t     * List of multiple instances of something described by the\n\t     * remainder of the string (which may itself include a list\n\t     * of multiple instances of something, so we recurse).\n\t     */\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\t/*\n\t\t * In order to avoid stack exhaustion recurse at most 10\n\t\t * levels; that \"should not happen\", as no SMB structure\n\t\t * should be nested *that* deeply, and we thus shouldn't\n\t\t * have format strings with that level of nesting.\n\t\t */\n\t\tif (depth == 10) {\n\t\t\tND_PRINT(\"(too many nested levels, not recursing)\");\n\t\t\tbuf2 = buf;\n\t\t} else\n\t\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\n\tcase '|':\n\t    /*\n\t     * Just do a bounds check.\n\t     */\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\n\tcase '%':\n\t    /*\n\t     * XXX - unused?\n\t     */\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\n\tcase '#':\n\t    /*\n\t     * Done?\n\t     */\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\n\tcase '[':\n\t    /*\n\t     * Format of an item, enclosed in square brackets; dissect\n\t     * the item with smb_fdata1().\n\t     */\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\t/* overrun */\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL) {\n\t\t/*\n\t\t * Truncated.\n\t\t * Is the next character a newline?\n\t\t * If so, print it before quitting, so we don't\n\t\t * get stuff in the middle of the line.\n\t\t */\n\t\tif (*fmt == '\\n')\n\t\t    ND_PRINT(\"\\n\");\n\t\treturn(NULL);\n\t    }\n\t    break;\n\n\tdefault:\n\t    /*\n\t     * Not a formatting character, so just print it.\n\t     */\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tu_int len = ND_BYTES_BETWEEN(maxbuf, buf);\n\tND_PRINT(\"Data: (%u bytes)\\n\", len);\n\tsmb_data_print(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}\n\ntypedef struct {\n    const char *name;\n    int code;\n    const char *message;\n} err_code_struct;\n\n/* DOS Error Messages */\nstatic const err_code_struct dos_msgs[] = {\n    { \"ERRbadfunc\", 1, \"Invalid function.\" },\n    { \"ERRbadfile\", 2, \"File not found.\" },\n    { \"ERRbadpath\", 3, \"Directory invalid.\" },\n    { \"ERRnofids\", 4, \"No file descriptors available\" },\n    { \"ERRnoaccess\", 5, \"Access denied.\" },\n    { \"ERRbadfid\", 6, \"Invalid file handle.\" },\n    { \"ERRbadmcb\", 7, \"Memory control blocks destroyed.\" },\n    { \"ERRnomem\", 8, \"Insufficient server memory to perform the requested function.\" },\n    { \"ERRbadmem\", 9, \"Invalid memory block address.\" },\n    { \"ERRbadenv\", 10, \"Invalid environment.\" },\n    { \"ERRbadformat\", 11, \"Invalid format.\" },\n    { \"ERRbadaccess\", 12, \"Invalid open mode.\" },\n    { \"ERRbaddata\", 13, \"Invalid data.\" },\n    { \"ERR\", 14, \"reserved.\" },\n    { \"ERRbaddrive\", 15, \"Invalid drive specified.\" },\n    { \"ERRremcd\", 16, \"A Delete Directory request attempted to remove the server's current directory.\" },\n    { \"ERRdiffdevice\", 17, \"Not same device.\" },\n    { \"ERRnofiles\", 18, \"A File Search command can find no more files matching the specified criteria.\" },\n    { \"ERRbadshare\", 32, \"The sharing mode specified for an Open conflicts with existing FIDs on the file.\" },\n    { \"ERRlock\", 33, \"A Lock request conflicted with an existing lock or specified an invalid mode, or an Unlock requested attempted to remove a lock held by another process.\" },\n    { \"ERRfilexists\", 80, \"The file named in a Create Directory, Make New File or Link request already exists.\" },\n    { \"ERRbadpipe\", 230, \"Pipe invalid.\" },\n    { \"ERRpipebusy\", 231, \"All instances of the requested pipe are busy.\" },\n    { \"ERRpipeclosing\", 232, \"Pipe close in progress.\" },\n    { \"ERRnotconnected\", 233, \"No process on other end of pipe.\" },\n    { \"ERRmoredata\", 234, \"There is more data to be returned.\" },\n    { NULL, -1, NULL }\n };\n\n/* Server Error Messages */\nstatic const err_code_struct server_msgs[] = {\n    { \"ERRerror\", 1, \"Non-specific error code.\" },\n    { \"ERRbadpw\", 2, \"Bad password - name/password pair in a Tree Connect or Session Setup are invalid.\" },\n    { \"ERRbadtype\", 3, \"reserved.\" },\n    { \"ERRaccess\", 4, \"The requester does not have the necessary access rights within the specified context for the requested function. The context is defined by the TID or the UID.\" },\n    { \"ERRinvnid\", 5, \"The tree ID (TID) specified in a command was invalid.\" },\n    { \"ERRinvnetname\", 6, \"Invalid network name in tree connect.\" },\n    { \"ERRinvdevice\", 7, \"Invalid device - printer request made to non-printer connection or non-printer request made to printer connection.\" },\n    { \"ERRqfull\", 49, \"Print queue full (files) -- returned by open print file.\" },\n    { \"ERRqtoobig\", 50, \"Print queue full -- no space.\" },\n    { \"ERRqeof\", 51, \"EOF on print queue dump.\" },\n    { \"ERRinvpfid\", 52, \"Invalid print file FID.\" },\n    { \"ERRsmbcmd\", 64, \"The server did not recognize the command received.\" },\n    { \"ERRsrverror\", 65, \"The server encountered an internal error, e.g., system file unavailable.\" },\n    { \"ERRfilespecs\", 67, \"The file handle (FID) and pathname parameters contained an invalid combination of values.\" },\n    { \"ERRreserved\", 68, \"reserved.\" },\n    { \"ERRbadpermits\", 69, \"The access permissions specified for a file or directory are not a valid combination.  The server cannot set the requested attribute.\" },\n    { \"ERRreserved\", 70, \"reserved.\" },\n    { \"ERRsetattrmode\", 71, \"The attribute mode in the Set File Attribute request is invalid.\" },\n    { \"ERRpaused\", 81, \"Server is paused.\" },\n    { \"ERRmsgoff\", 82, \"Not receiving messages.\" },\n    { \"ERRnoroom\", 83, \"No room to buffer message.\" },\n    { \"ERRrmuns\", 87, \"Too many remote user names.\" },\n    { \"ERRtimeout\", 88, \"Operation timed out.\" },\n    { \"ERRnoresource\", 89, \"No resources currently available for request.\" },\n    { \"ERRtoomanyuids\", 90, \"Too many UIDs active on this session.\" },\n    { \"ERRbaduid\", 91, \"The UID is not known as a valid ID on this session.\" },\n    { \"ERRusempx\", 250, \"Temp unable to support Raw, use MPX mode.\" },\n    { \"ERRusestd\", 251, \"Temp unable to support Raw, use standard read/write.\" },\n    { \"ERRcontmpx\", 252, \"Continue in MPX mode.\" },\n    { \"ERRreserved\", 253, \"reserved.\" },\n    { \"ERRreserved\", 254, \"reserved.\" },\n    { \"ERRnosupport\", 0xFFFF, \"Function not supported.\" },\n    { NULL, -1, NULL }\n};\n\n/* Hard Error Messages */\nstatic const err_code_struct hard_msgs[] = {\n    { \"ERRnowrite\", 19, \"Attempt to write on write-protected diskette.\" },\n    { \"ERRbadunit\", 20, \"Unknown unit.\" },\n    { \"ERRnotready\", 21, \"Drive not ready.\" },\n    { \"ERRbadcmd\", 22, \"Unknown command.\" },\n    { \"ERRdata\", 23, \"Data error (CRC).\" },\n    { \"ERRbadreq\", 24, \"Bad request structure length.\" },\n    { \"ERRseek\", 25 , \"Seek error.\" },\n    { \"ERRbadmedia\", 26, \"Unknown media type.\" },\n    { \"ERRbadsector\", 27, \"Sector not found.\" },\n    { \"ERRnopaper\", 28, \"Printer out of paper.\" },\n    { \"ERRwrite\", 29, \"Write fault.\" },\n    { \"ERRread\", 30, \"Read fault.\" },\n    { \"ERRgeneral\", 31, \"General failure.\" },\n    { \"ERRbadshare\", 32, \"A open conflicts with an existing open.\" },\n    { \"ERRlock\", 33, \"A Lock request conflicted with an existing lock or specified an invalid mode, or an Unlock requested attempted to remove a lock held by another process.\" },\n    { \"ERRwrongdisk\", 34, \"The wrong disk was found in a drive.\" },\n    { \"ERRFCBUnavail\", 35, \"No FCBs are available to process request.\" },\n    { \"ERRsharebufexc\", 36, \"A sharing buffer has been exceeded.\" },\n    { NULL, -1, NULL }\n};\n\nstatic const struct {\n    int code;\n    const char *class;\n    const err_code_struct *err_msgs;\n} err_classes[] = {\n    { 0, \"SUCCESS\", NULL },\n    { 0x01, \"ERRDOS\", dos_msgs },\n    { 0x02, \"ERRSRV\", server_msgs },\n    { 0x03, \"ERRHRD\", hard_msgs },\n    { 0x04, \"ERRXOS\", NULL },\n    { 0xE1, \"ERRRMX1\", NULL },\n    { 0xE2, \"ERRRMX2\", NULL },\n    { 0xE3, \"ERRRMX3\", NULL },\n    { 0xFF, \"ERRCMD\", NULL },\n    { -1, NULL, NULL }\n};\n\n/*\n * return a SMB error string from a SMB buffer\n */\nconst char *\nsmb_errstr(int class, int num)\n{\n    static char ret[128];\n    int i, j;\n\n    ret[0] = 0;\n\n    for (i = 0; err_classes[i].class; i++)\n\tif (err_classes[i].code == class) {\n\t    if (err_classes[i].err_msgs) {\n\t\tconst err_code_struct *err = err_classes[i].err_msgs;\n\t\tfor (j = 0; err[j].name; j++)\n\t\t    if (num == err[j].code) {\n\t\t\tsnprintf(ret, sizeof(ret), \"%s - %s (%s)\",\n\t\t\t    err_classes[i].class, err[j].name, err[j].message);\n\t\t\treturn ret;\n\t\t    }\n\t    }\n\n\t    snprintf(ret, sizeof(ret), \"%s - %d\", err_classes[i].class, num);\n\t    return ret;\n\t}\n\n    snprintf(ret, sizeof(ret), \"ERROR: Unknown error (%d,%d)\", class, num);\n    return(ret);\n}\n\ntypedef struct {\n    uint32_t code;\n    const char *name;\n} nt_err_code_struct;\n\n/*\n * NT Error codes\n */\nstatic const nt_err_code_struct nt_errors[] = {\n  { 0x00000000, \"STATUS_SUCCESS\" },\n  { 0x00000000, \"STATUS_WAIT_0\" },\n  { 0x00000001, \"STATUS_WAIT_1\" },\n  { 0x00000002, \"STATUS_WAIT_2\" },\n  { 0x00000003, \"STATUS_WAIT_3\" },\n  { 0x0000003F, \"STATUS_WAIT_63\" },\n  { 0x00000080, \"STATUS_ABANDONED\" },\n  { 0x00000080, \"STATUS_ABANDONED_WAIT_0\" },\n  { 0x000000BF, \"STATUS_ABANDONED_WAIT_63\" },\n  { 0x000000C0, \"STATUS_USER_APC\" },\n  { 0x00000100, \"STATUS_KERNEL_APC\" },\n  { 0x00000101, \"STATUS_ALERTED\" },\n  { 0x00000102, \"STATUS_TIMEOUT\" },\n  { 0x00000103, \"STATUS_PENDING\" },\n  { 0x00000104, \"STATUS_REPARSE\" },\n  { 0x00000105, \"STATUS_MORE_ENTRIES\" },\n  { 0x00000106, \"STATUS_NOT_ALL_ASSIGNED\" },\n  { 0x00000107, \"STATUS_SOME_NOT_MAPPED\" },\n  { 0x00000108, \"STATUS_OPLOCK_BREAK_IN_PROGRESS\" },\n  { 0x00000109, \"STATUS_VOLUME_MOUNTED\" },\n  { 0x0000010A, \"STATUS_RXACT_COMMITTED\" },\n  { 0x0000010B, \"STATUS_NOTIFY_CLEANUP\" },\n  { 0x0000010C, \"STATUS_NOTIFY_ENUM_DIR\" },\n  { 0x0000010D, \"STATUS_NO_QUOTAS_FOR_ACCOUNT\" },\n  { 0x0000010E, \"STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED\" },\n  { 0x00000110, \"STATUS_PAGE_FAULT_TRANSITION\" },\n  { 0x00000111, \"STATUS_PAGE_FAULT_DEMAND_ZERO\" },\n  { 0x00000112, \"STATUS_PAGE_FAULT_COPY_ON_WRITE\" },\n  { 0x00000113, \"STATUS_PAGE_FAULT_GUARD_PAGE\" },\n  { 0x00000114, \"STATUS_PAGE_FAULT_PAGING_FILE\" },\n  { 0x00000115, \"STATUS_CACHE_PAGE_LOCKED\" },\n  { 0x00000116, \"STATUS_CRASH_DUMP\" },\n  { 0x00000117, \"STATUS_BUFFER_ALL_ZEROS\" },\n  { 0x00000118, \"STATUS_REPARSE_OBJECT\" },\n  { 0x0000045C, \"STATUS_NO_SHUTDOWN_IN_PROGRESS\" },\n  { 0x40000000, \"STATUS_OBJECT_NAME_EXISTS\" },\n  { 0x40000001, \"STATUS_THREAD_WAS_SUSPENDED\" },\n  { 0x40000002, \"STATUS_WORKING_SET_LIMIT_RANGE\" },\n  { 0x40000003, \"STATUS_IMAGE_NOT_AT_BASE\" },\n  { 0x40000004, \"STATUS_RXACT_STATE_CREATED\" },\n  { 0x40000005, \"STATUS_SEGMENT_NOTIFICATION\" },\n  { 0x40000006, \"STATUS_LOCAL_USER_SESSION_KEY\" },\n  { 0x40000007, \"STATUS_BAD_CURRENT_DIRECTORY\" },\n  { 0x40000008, \"STATUS_SERIAL_MORE_WRITES\" },\n  { 0x40000009, \"STATUS_REGISTRY_RECOVERED\" },\n  { 0x4000000A, \"STATUS_FT_READ_RECOVERY_FROM_BACKUP\" },\n  { 0x4000000B, \"STATUS_FT_WRITE_RECOVERY\" },\n  { 0x4000000C, \"STATUS_SERIAL_COUNTER_TIMEOUT\" },\n  { 0x4000000D, \"STATUS_NULL_LM_PASSWORD\" },\n  { 0x4000000E, \"STATUS_IMAGE_MACHINE_TYPE_MISMATCH\" },\n  { 0x4000000F, \"STATUS_RECEIVE_PARTIAL\" },\n  { 0x40000010, \"STATUS_RECEIVE_EXPEDITED\" },\n  { 0x40000011, \"STATUS_RECEIVE_PARTIAL_EXPEDITED\" },\n  { 0x40000012, \"STATUS_EVENT_DONE\" },\n  { 0x40000013, \"STATUS_EVENT_PENDING\" },\n  { 0x40000014, \"STATUS_CHECKING_FILE_SYSTEM\" },\n  { 0x40000015, \"STATUS_FATAL_APP_EXIT\" },\n  { 0x40000016, \"STATUS_PREDEFINED_HANDLE\" },\n  { 0x40000017, \"STATUS_WAS_UNLOCKED\" },\n  { 0x40000018, \"STATUS_SERVICE_NOTIFICATION\" },\n  { 0x40000019, \"STATUS_WAS_LOCKED\" },\n  { 0x4000001A, \"STATUS_LOG_HARD_ERROR\" },\n  { 0x4000001B, \"STATUS_ALREADY_WIN32\" },\n  { 0x4000001C, \"STATUS_WX86_UNSIMULATE\" },\n  { 0x4000001D, \"STATUS_WX86_CONTINUE\" },\n  { 0x4000001E, \"STATUS_WX86_SINGLE_STEP\" },\n  { 0x4000001F, \"STATUS_WX86_BREAKPOINT\" },\n  { 0x40000020, \"STATUS_WX86_EXCEPTION_CONTINUE\" },\n  { 0x40000021, \"STATUS_WX86_EXCEPTION_LASTCHANCE\" },\n  { 0x40000022, \"STATUS_WX86_EXCEPTION_CHAIN\" },\n  { 0x40000023, \"STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE\" },\n  { 0x40000024, \"STATUS_NO_YIELD_PERFORMED\" },\n  { 0x40000025, \"STATUS_TIMER_RESUME_IGNORED\" },\n  { 0x80000001, \"STATUS_GUARD_PAGE_VIOLATION\" },\n  { 0x80000002, \"STATUS_DATATYPE_MISALIGNMENT\" },\n  { 0x80000003, \"STATUS_BREAKPOINT\" },\n  { 0x80000004, \"STATUS_SINGLE_STEP\" },\n  { 0x80000005, \"STATUS_BUFFER_OVERFLOW\" },\n  { 0x80000006, \"STATUS_NO_MORE_FILES\" },\n  { 0x80000007, \"STATUS_WAKE_SYSTEM_DEBUGGER\" },\n  { 0x8000000A, \"STATUS_HANDLES_CLOSED\" },\n  { 0x8000000B, \"STATUS_NO_INHERITANCE\" },\n  { 0x8000000C, \"STATUS_GUID_SUBSTITUTION_MADE\" },\n  { 0x8000000D, \"STATUS_PARTIAL_COPY\" },\n  { 0x8000000E, \"STATUS_DEVICE_PAPER_EMPTY\" },\n  { 0x8000000F, \"STATUS_DEVICE_POWERED_OFF\" },\n  { 0x80000010, \"STATUS_DEVICE_OFF_LINE\" },\n  { 0x80000011, \"STATUS_DEVICE_BUSY\" },\n  { 0x80000012, \"STATUS_NO_MORE_EAS\" },\n  { 0x80000013, \"STATUS_INVALID_EA_NAME\" },\n  { 0x80000014, \"STATUS_EA_LIST_INCONSISTENT\" },\n  { 0x80000015, \"STATUS_INVALID_EA_FLAG\" },\n  { 0x80000016, \"STATUS_VERIFY_REQUIRED\" },\n  { 0x80000017, \"STATUS_EXTRANEOUS_INFORMATION\" },\n  { 0x80000018, \"STATUS_RXACT_COMMIT_NECESSARY\" },\n  { 0x8000001A, \"STATUS_NO_MORE_ENTRIES\" },\n  { 0x8000001B, \"STATUS_FILEMARK_DETECTED\" },\n  { 0x8000001C, \"STATUS_MEDIA_CHANGED\" },\n  { 0x8000001D, \"STATUS_BUS_RESET\" },\n  { 0x8000001E, \"STATUS_END_OF_MEDIA\" },\n  { 0x8000001F, \"STATUS_BEGINNING_OF_MEDIA\" },\n  { 0x80000020, \"STATUS_MEDIA_CHECK\" },\n  { 0x80000021, \"STATUS_SETMARK_DETECTED\" },\n  { 0x80000022, \"STATUS_NO_DATA_DETECTED\" },\n  { 0x80000023, \"STATUS_REDIRECTOR_HAS_OPEN_HANDLES\" },\n  { 0x80000024, \"STATUS_SERVER_HAS_OPEN_HANDLES\" },\n  { 0x80000025, \"STATUS_ALREADY_DISCONNECTED\" },\n  { 0x80000026, \"STATUS_LONGJUMP\" },\n  { 0x80040111, \"MAPI_E_LOGON_FAILED\" },\n  { 0x80090300, \"SEC_E_INSUFFICIENT_MEMORY\" },\n  { 0x80090301, \"SEC_E_INVALID_HANDLE\" },\n  { 0x80090302, \"SEC_E_UNSUPPORTED_FUNCTION\" },\n  { 0x8009030B, \"SEC_E_NO_IMPERSONATION\" },\n  { 0x8009030D, \"SEC_E_UNKNOWN_CREDENTIALS\" },\n  { 0x8009030E, \"SEC_E_NO_CREDENTIALS\" },\n  { 0x8009030F, \"SEC_E_MESSAGE_ALTERED\" },\n  { 0x80090310, \"SEC_E_OUT_OF_SEQUENCE\" },\n  { 0x80090311, \"SEC_E_NO_AUTHENTICATING_AUTHORITY\" },\n  { 0xC0000001, \"STATUS_UNSUCCESSFUL\" },\n  { 0xC0000002, \"STATUS_NOT_IMPLEMENTED\" },\n  { 0xC0000003, \"STATUS_INVALID_INFO_CLASS\" },\n  { 0xC0000004, \"STATUS_INFO_LENGTH_MISMATCH\" },\n  { 0xC0000005, \"STATUS_ACCESS_VIOLATION\" },\n  { 0xC0000006, \"STATUS_IN_PAGE_ERROR\" },\n  { 0xC0000007, \"STATUS_PAGEFILE_QUOTA\" },\n  { 0xC0000008, \"STATUS_INVALID_HANDLE\" },\n  { 0xC0000009, \"STATUS_BAD_INITIAL_STACK\" },\n  { 0xC000000A, \"STATUS_BAD_INITIAL_PC\" },\n  { 0xC000000B, \"STATUS_INVALID_CID\" },\n  { 0xC000000C, \"STATUS_TIMER_NOT_CANCELED\" },\n  { 0xC000000D, \"STATUS_INVALID_PARAMETER\" },\n  { 0xC000000E, \"STATUS_NO_SUCH_DEVICE\" },\n  { 0xC000000F, \"STATUS_NO_SUCH_FILE\" },\n  { 0xC0000010, \"STATUS_INVALID_DEVICE_REQUEST\" },\n  { 0xC0000011, \"STATUS_END_OF_FILE\" },\n  { 0xC0000012, \"STATUS_WRONG_VOLUME\" },\n  { 0xC0000013, \"STATUS_NO_MEDIA_IN_DEVICE\" },\n  { 0xC0000014, \"STATUS_UNRECOGNIZED_MEDIA\" },\n  { 0xC0000015, \"STATUS_NONEXISTENT_SECTOR\" },\n  { 0xC0000016, \"STATUS_MORE_PROCESSING_REQUIRED\" },\n  { 0xC0000017, \"STATUS_NO_MEMORY\" },\n  { 0xC0000018, \"STATUS_CONFLICTING_ADDRESSES\" },\n  { 0xC0000019, \"STATUS_NOT_MAPPED_VIEW\" },\n  { 0xC000001A, \"STATUS_UNABLE_TO_FREE_VM\" },\n  { 0xC000001B, \"STATUS_UNABLE_TO_DELETE_SECTION\" },\n  { 0xC000001C, \"STATUS_INVALID_SYSTEM_SERVICE\" },\n  { 0xC000001D, \"STATUS_ILLEGAL_INSTRUCTION\" },\n  { 0xC000001E, \"STATUS_INVALID_LOCK_SEQUENCE\" },\n  { 0xC000001F, \"STATUS_INVALID_VIEW_SIZE\" },\n  { 0xC0000020, \"STATUS_INVALID_FILE_FOR_SECTION\" },\n  { 0xC0000021, \"STATUS_ALREADY_COMMITTED\" },\n  { 0xC0000022, \"STATUS_ACCESS_DENIED\" },\n  { 0xC0000023, \"STATUS_BUFFER_TOO_SMALL\" },\n  { 0xC0000024, \"STATUS_OBJECT_TYPE_MISMATCH\" },\n  { 0xC0000025, \"STATUS_NONCONTINUABLE_EXCEPTION\" },\n  { 0xC0000026, \"STATUS_INVALID_DISPOSITION\" },\n  { 0xC0000027, \"STATUS_UNWIND\" },\n  { 0xC0000028, \"STATUS_BAD_STACK\" },\n  { 0xC0000029, \"STATUS_INVALID_UNWIND_TARGET\" },\n  { 0xC000002A, \"STATUS_NOT_LOCKED\" },\n  { 0xC000002B, \"STATUS_PARITY_ERROR\" },\n  { 0xC000002C, \"STATUS_UNABLE_TO_DECOMMIT_VM\" },\n  { 0xC000002D, \"STATUS_NOT_COMMITTED\" },\n  { 0xC000002E, \"STATUS_INVALID_PORT_ATTRIBUTES\" },\n  { 0xC000002F, \"STATUS_PORT_MESSAGE_TOO_LONG\" },\n  { 0xC0000030, \"STATUS_INVALID_PARAMETER_MIX\" },\n  { 0xC0000031, \"STATUS_INVALID_QUOTA_LOWER\" },\n  { 0xC0000032, \"STATUS_DISK_CORRUPT_ERROR\" },\n  { 0xC0000033, \"STATUS_OBJECT_NAME_INVALID\" },\n  { 0xC0000034, \"STATUS_OBJECT_NAME_NOT_FOUND\" },\n  { 0xC0000035, \"STATUS_OBJECT_NAME_COLLISION\" },\n  { 0xC0000037, \"STATUS_PORT_DISCONNECTED\" },\n  { 0xC0000038, \"STATUS_DEVICE_ALREADY_ATTACHED\" },\n  { 0xC0000039, \"STATUS_OBJECT_PATH_INVALID\" },\n  { 0xC000003A, \"STATUS_OBJECT_PATH_NOT_FOUND\" },\n  { 0xC000003B, \"STATUS_OBJECT_PATH_SYNTAX_BAD\" },\n  { 0xC000003C, \"STATUS_DATA_OVERRUN\" },\n  { 0xC000003D, \"STATUS_DATA_LATE_ERROR\" },\n  { 0xC000003E, \"STATUS_DATA_ERROR\" },\n  { 0xC000003F, \"STATUS_CRC_ERROR\" },\n  { 0xC0000040, \"STATUS_SECTION_TOO_BIG\" },\n  { 0xC0000041, \"STATUS_PORT_CONNECTION_REFUSED\" },\n  { 0xC0000042, \"STATUS_INVALID_PORT_HANDLE\" },\n  { 0xC0000043, \"STATUS_SHARING_VIOLATION\" },\n  { 0xC0000044, \"STATUS_QUOTA_EXCEEDED\" },\n  { 0xC0000045, \"STATUS_INVALID_PAGE_PROTECTION\" },\n  { 0xC0000046, \"STATUS_MUTANT_NOT_OWNED\" },\n  { 0xC0000047, \"STATUS_SEMAPHORE_LIMIT_EXCEEDED\" },\n  { 0xC0000048, \"STATUS_PORT_ALREADY_SET\" },\n  { 0xC0000049, \"STATUS_SECTION_NOT_IMAGE\" },\n  { 0xC000004A, \"STATUS_SUSPEND_COUNT_EXCEEDED\" },\n  { 0xC000004B, \"STATUS_THREAD_IS_TERMINATING\" },\n  { 0xC000004C, \"STATUS_BAD_WORKING_SET_LIMIT\" },\n  { 0xC000004D, \"STATUS_INCOMPATIBLE_FILE_MAP\" },\n  { 0xC000004E, \"STATUS_SECTION_PROTECTION\" },\n  { 0xC000004F, \"STATUS_EAS_NOT_SUPPORTED\" },\n  { 0xC0000050, \"STATUS_EA_TOO_LARGE\" },\n  { 0xC0000051, \"STATUS_NONEXISTENT_EA_ENTRY\" },\n  { 0xC0000052, \"STATUS_NO_EAS_ON_FILE\" },\n  { 0xC0000053, \"STATUS_EA_CORRUPT_ERROR\" },\n  { 0xC0000054, \"STATUS_FILE_LOCK_CONFLICT\" },\n  { 0xC0000055, \"STATUS_LOCK_NOT_GRANTED\" },\n  { 0xC0000056, \"STATUS_DELETE_PENDING\" },\n  { 0xC0000057, \"STATUS_CTL_FILE_NOT_SUPPORTED\" },\n  { 0xC0000058, \"STATUS_UNKNOWN_REVISION\" },\n  { 0xC0000059, \"STATUS_REVISION_MISMATCH\" },\n  { 0xC000005A, \"STATUS_INVALID_OWNER\" },\n  { 0xC000005B, \"STATUS_INVALID_PRIMARY_GROUP\" },\n  { 0xC000005C, \"STATUS_NO_IMPERSONATION_TOKEN\" },\n  { 0xC000005D, \"STATUS_CANT_DISABLE_MANDATORY\" },\n  { 0xC000005E, \"STATUS_NO_LOGON_SERVERS\" },\n  { 0xC000005F, \"STATUS_NO_SUCH_LOGON_SESSION\" },\n  { 0xC0000060, \"STATUS_NO_SUCH_PRIVILEGE\" },\n  { 0xC0000061, \"STATUS_PRIVILEGE_NOT_HELD\" },\n  { 0xC0000062, \"STATUS_INVALID_ACCOUNT_NAME\" },\n  { 0xC0000063, \"STATUS_USER_EXISTS\" },\n  { 0xC0000064, \"STATUS_NO_SUCH_USER\" },\n  { 0xC0000065, \"STATUS_GROUP_EXISTS\" },\n  { 0xC0000066, \"STATUS_NO_SUCH_GROUP\" },\n  { 0xC0000067, \"STATUS_MEMBER_IN_GROUP\" },\n  { 0xC0000068, \"STATUS_MEMBER_NOT_IN_GROUP\" },\n  { 0xC0000069, \"STATUS_LAST_ADMIN\" },\n  { 0xC000006A, \"STATUS_WRONG_PASSWORD\" },\n  { 0xC000006B, \"STATUS_ILL_FORMED_PASSWORD\" },\n  { 0xC000006C, \"STATUS_PASSWORD_RESTRICTION\" },\n  { 0xC000006D, \"STATUS_LOGON_FAILURE\" },\n  { 0xC000006E, \"STATUS_ACCOUNT_RESTRICTION\" },\n  { 0xC000006F, \"STATUS_INVALID_LOGON_HOURS\" },\n  { 0xC0000070, \"STATUS_INVALID_WORKSTATION\" },\n  { 0xC0000071, \"STATUS_PASSWORD_EXPIRED\" },\n  { 0xC0000072, \"STATUS_ACCOUNT_DISABLED\" },\n  { 0xC0000073, \"STATUS_NONE_MAPPED\" },\n  { 0xC0000074, \"STATUS_TOO_MANY_LUIDS_REQUESTED\" },\n  { 0xC0000075, \"STATUS_LUIDS_EXHAUSTED\" },\n  { 0xC0000076, \"STATUS_INVALID_SUB_AUTHORITY\" },\n  { 0xC0000077, \"STATUS_INVALID_ACL\" },\n  { 0xC0000078, \"STATUS_INVALID_SID\" },\n  { 0xC0000079, \"STATUS_INVALID_SECURITY_DESCR\" },\n  { 0xC000007A, \"STATUS_PROCEDURE_NOT_FOUND\" },\n  { 0xC000007B, \"STATUS_INVALID_IMAGE_FORMAT\" },\n  { 0xC000007C, \"STATUS_NO_TOKEN\" },\n  { 0xC000007D, \"STATUS_BAD_INHERITANCE_ACL\" },\n  { 0xC000007E, \"STATUS_RANGE_NOT_LOCKED\" },\n  { 0xC000007F, \"STATUS_DISK_FULL\" },\n  { 0xC0000080, \"STATUS_SERVER_DISABLED\" },\n  { 0xC0000081, \"STATUS_SERVER_NOT_DISABLED\" },\n  { 0xC0000082, \"STATUS_TOO_MANY_GUIDS_REQUESTED\" },\n  { 0xC0000083, \"STATUS_GUIDS_EXHAUSTED\" },\n  { 0xC0000084, \"STATUS_INVALID_ID_AUTHORITY\" },\n  { 0xC0000085, \"STATUS_AGENTS_EXHAUSTED\" },\n  { 0xC0000086, \"STATUS_INVALID_VOLUME_LABEL\" },\n  { 0xC0000087, \"STATUS_SECTION_NOT_EXTENDED\" },\n  { 0xC0000088, \"STATUS_NOT_MAPPED_DATA\" },\n  { 0xC0000089, \"STATUS_RESOURCE_DATA_NOT_FOUND\" },\n  { 0xC000008A, \"STATUS_RESOURCE_TYPE_NOT_FOUND\" },\n  { 0xC000008B, \"STATUS_RESOURCE_NAME_NOT_FOUND\" },\n  { 0xC000008C, \"STATUS_ARRAY_BOUNDS_EXCEEDED\" },\n  { 0xC000008D, \"STATUS_FLOAT_DENORMAL_OPERAND\" },\n  { 0xC000008E, \"STATUS_FLOAT_DIVIDE_BY_ZERO\" },\n  { 0xC000008F, \"STATUS_FLOAT_INEXACT_RESULT\" },\n  { 0xC0000090, \"STATUS_FLOAT_INVALID_OPERATION\" },\n  { 0xC0000091, \"STATUS_FLOAT_OVERFLOW\" },\n  { 0xC0000092, \"STATUS_FLOAT_STACK_CHECK\" },\n  { 0xC0000093, \"STATUS_FLOAT_UNDERFLOW\" },\n  { 0xC0000094, \"STATUS_INTEGER_DIVIDE_BY_ZERO\" },\n  { 0xC0000095, \"STATUS_INTEGER_OVERFLOW\" },\n  { 0xC0000096, \"STATUS_PRIVILEGED_INSTRUCTION\" },\n  { 0xC0000097, \"STATUS_TOO_MANY_PAGING_FILES\" },\n  { 0xC0000098, \"STATUS_FILE_INVALID\" },\n  { 0xC0000099, \"STATUS_ALLOTTED_SPACE_EXCEEDED\" },\n  { 0xC000009A, \"STATUS_INSUFFICIENT_RESOURCES\" },\n  { 0xC000009B, \"STATUS_DFS_EXIT_PATH_FOUND\" },\n  { 0xC000009C, \"STATUS_DEVICE_DATA_ERROR\" },\n  { 0xC000009D, \"STATUS_DEVICE_NOT_CONNECTED\" },\n  { 0xC000009E, \"STATUS_DEVICE_POWER_FAILURE\" },\n  { 0xC000009F, \"STATUS_FREE_VM_NOT_AT_BASE\" },\n  { 0xC00000A0, \"STATUS_MEMORY_NOT_ALLOCATED\" },\n  { 0xC00000A1, \"STATUS_WORKING_SET_QUOTA\" },\n  { 0xC00000A2, \"STATUS_MEDIA_WRITE_PROTECTED\" },\n  { 0xC00000A3, \"STATUS_DEVICE_NOT_READY\" },\n  { 0xC00000A4, \"STATUS_INVALID_GROUP_ATTRIBUTES\" },\n  { 0xC00000A5, \"STATUS_BAD_IMPERSONATION_LEVEL\" },\n  { 0xC00000A6, \"STATUS_CANT_OPEN_ANONYMOUS\" },\n  { 0xC00000A7, \"STATUS_BAD_VALIDATION_CLASS\" },\n  { 0xC00000A8, \"STATUS_BAD_TOKEN_TYPE\" },\n  { 0xC00000A9, \"STATUS_BAD_MASTER_BOOT_RECORD\" },\n  { 0xC00000AA, \"STATUS_INSTRUCTION_MISALIGNMENT\" },\n  { 0xC00000AB, \"STATUS_INSTANCE_NOT_AVAILABLE\" },\n  { 0xC00000AC, \"STATUS_PIPE_NOT_AVAILABLE\" },\n  { 0xC00000AD, \"STATUS_INVALID_PIPE_STATE\" },\n  { 0xC00000AE, \"STATUS_PIPE_BUSY\" },\n  { 0xC00000AF, \"STATUS_ILLEGAL_FUNCTION\" },\n  { 0xC00000B0, \"STATUS_PIPE_DISCONNECTED\" },\n  { 0xC00000B1, \"STATUS_PIPE_CLOSING\" },\n  { 0xC00000B2, \"STATUS_PIPE_CONNECTED\" },\n  { 0xC00000B3, \"STATUS_PIPE_LISTENING\" },\n  { 0xC00000B4, \"STATUS_INVALID_READ_MODE\" },\n  { 0xC00000B5, \"STATUS_IO_TIMEOUT\" },\n  { 0xC00000B6, \"STATUS_FILE_FORCED_CLOSED\" },\n  { 0xC00000B7, \"STATUS_PROFILING_NOT_STARTED\" },\n  { 0xC00000B8, \"STATUS_PROFILING_NOT_STOPPED\" },\n  { 0xC00000B9, \"STATUS_COULD_NOT_INTERPRET\" },\n  { 0xC00000BA, \"STATUS_FILE_IS_A_DIRECTORY\" },\n  { 0xC00000BB, \"STATUS_NOT_SUPPORTED\" },\n  { 0xC00000BC, \"STATUS_REMOTE_NOT_LISTENING\" },\n  { 0xC00000BD, \"STATUS_DUPLICATE_NAME\" },\n  { 0xC00000BE, \"STATUS_BAD_NETWORK_PATH\" },\n  { 0xC00000BF, \"STATUS_NETWORK_BUSY\" },\n  { 0xC00000C0, \"STATUS_DEVICE_DOES_NOT_EXIST\" },\n  { 0xC00000C1, \"STATUS_TOO_MANY_COMMANDS\" },\n  { 0xC00000C2, \"STATUS_ADAPTER_HARDWARE_ERROR\" },\n  { 0xC00000C3, \"STATUS_INVALID_NETWORK_RESPONSE\" },\n  { 0xC00000C4, \"STATUS_UNEXPECTED_NETWORK_ERROR\" },\n  { 0xC00000C5, \"STATUS_BAD_REMOTE_ADAPTER\" },\n  { 0xC00000C6, \"STATUS_PRINT_QUEUE_FULL\" },\n  { 0xC00000C7, \"STATUS_NO_SPOOL_SPACE\" },\n  { 0xC00000C8, \"STATUS_PRINT_CANCELLED\" },\n  { 0xC00000C9, \"STATUS_NETWORK_NAME_DELETED\" },\n  { 0xC00000CA, \"STATUS_NETWORK_ACCESS_DENIED\" },\n  { 0xC00000CB, \"STATUS_BAD_DEVICE_TYPE\" },\n  { 0xC00000CC, \"STATUS_BAD_NETWORK_NAME\" },\n  { 0xC00000CD, \"STATUS_TOO_MANY_NAMES\" },\n  { 0xC00000CE, \"STATUS_TOO_MANY_SESSIONS\" },\n  { 0xC00000CF, \"STATUS_SHARING_PAUSED\" },\n  { 0xC00000D0, \"STATUS_REQUEST_NOT_ACCEPTED\" },\n  { 0xC00000D1, \"STATUS_REDIRECTOR_PAUSED\" },\n  { 0xC00000D2, \"STATUS_NET_WRITE_FAULT\" },\n  { 0xC00000D3, \"STATUS_PROFILING_AT_LIMIT\" },\n  { 0xC00000D4, \"STATUS_NOT_SAME_DEVICE\" },\n  { 0xC00000D5, \"STATUS_FILE_RENAMED\" },\n  { 0xC00000D6, \"STATUS_VIRTUAL_CIRCUIT_CLOSED\" },\n  { 0xC00000D7, \"STATUS_NO_SECURITY_ON_OBJECT\" },\n  { 0xC00000D8, \"STATUS_CANT_WAIT\" },\n  { 0xC00000D9, \"STATUS_PIPE_EMPTY\" },\n  { 0xC00000DA, \"STATUS_CANT_ACCESS_DOMAIN_INFO\" },\n  { 0xC00000DB, \"STATUS_CANT_TERMINATE_SELF\" },\n  { 0xC00000DC, \"STATUS_INVALID_SERVER_STATE\" },\n  { 0xC00000DD, \"STATUS_INVALID_DOMAIN_STATE\" },\n  { 0xC00000DE, \"STATUS_INVALID_DOMAIN_ROLE\" },\n  { 0xC00000DF, \"STATUS_NO_SUCH_DOMAIN\" },\n  { 0xC00000E0, \"STATUS_DOMAIN_EXISTS\" },\n  { 0xC00000E1, \"STATUS_DOMAIN_LIMIT_EXCEEDED\" },\n  { 0xC00000E2, \"STATUS_OPLOCK_NOT_GRANTED\" },\n  { 0xC00000E3, \"STATUS_INVALID_OPLOCK_PROTOCOL\" },\n  { 0xC00000E4, \"STATUS_INTERNAL_DB_CORRUPTION\" },\n  { 0xC00000E5, \"STATUS_INTERNAL_ERROR\" },\n  { 0xC00000E6, \"STATUS_GENERIC_NOT_MAPPED\" },\n  { 0xC00000E7, \"STATUS_BAD_DESCRIPTOR_FORMAT\" },\n  { 0xC00000E8, \"STATUS_INVALID_USER_BUFFER\" },\n  { 0xC00000E9, \"STATUS_UNEXPECTED_IO_ERROR\" },\n  { 0xC00000EA, \"STATUS_UNEXPECTED_MM_CREATE_ERR\" },\n  { 0xC00000EB, \"STATUS_UNEXPECTED_MM_MAP_ERROR\" },\n  { 0xC00000EC, \"STATUS_UNEXPECTED_MM_EXTEND_ERR\" },\n  { 0xC00000ED, \"STATUS_NOT_LOGON_PROCESS\" },\n  { 0xC00000EE, \"STATUS_LOGON_SESSION_EXISTS\" },\n  { 0xC00000EF, \"STATUS_INVALID_PARAMETER_1\" },\n  { 0xC00000F0, \"STATUS_INVALID_PARAMETER_2\" },\n  { 0xC00000F1, \"STATUS_INVALID_PARAMETER_3\" },\n  { 0xC00000F2, \"STATUS_INVALID_PARAMETER_4\" },\n  { 0xC00000F3, \"STATUS_INVALID_PARAMETER_5\" },\n  { 0xC00000F4, \"STATUS_INVALID_PARAMETER_6\" },\n  { 0xC00000F5, \"STATUS_INVALID_PARAMETER_7\" },\n  { 0xC00000F6, \"STATUS_INVALID_PARAMETER_8\" },\n  { 0xC00000F7, \"STATUS_INVALID_PARAMETER_9\" },\n  { 0xC00000F8, \"STATUS_INVALID_PARAMETER_10\" },\n  { 0xC00000F9, \"STATUS_INVALID_PARAMETER_11\" },\n  { 0xC00000FA, \"STATUS_INVALID_PARAMETER_12\" },\n  { 0xC00000FB, \"STATUS_REDIRECTOR_NOT_STARTED\" },\n  { 0xC00000FC, \"STATUS_REDIRECTOR_STARTED\" },\n  { 0xC00000FD, \"STATUS_STACK_OVERFLOW\" },\n  { 0xC00000FE, \"STATUS_NO_SUCH_PACKAGE\" },\n  { 0xC00000FF, \"STATUS_BAD_FUNCTION_TABLE\" },\n  { 0xC0000100, \"STATUS_VARIABLE_NOT_FOUND\" },\n  { 0xC0000101, \"STATUS_DIRECTORY_NOT_EMPTY\" },\n  { 0xC0000102, \"STATUS_FILE_CORRUPT_ERROR\" },\n  { 0xC0000103, \"STATUS_NOT_A_DIRECTORY\" },\n  { 0xC0000104, \"STATUS_BAD_LOGON_SESSION_STATE\" },\n  { 0xC0000105, \"STATUS_LOGON_SESSION_COLLISION\" },\n  { 0xC0000106, \"STATUS_NAME_TOO_LONG\" },\n  { 0xC0000107, \"STATUS_FILES_OPEN\" },\n  { 0xC0000108, \"STATUS_CONNECTION_IN_USE\" },\n  { 0xC0000109, \"STATUS_MESSAGE_NOT_FOUND\" },\n  { 0xC000010A, \"STATUS_PROCESS_IS_TERMINATING\" },\n  { 0xC000010B, \"STATUS_INVALID_LOGON_TYPE\" },\n  { 0xC000010C, \"STATUS_NO_GUID_TRANSLATION\" },\n  { 0xC000010D, \"STATUS_CANNOT_IMPERSONATE\" },\n  { 0xC000010E, \"STATUS_IMAGE_ALREADY_LOADED\" },\n  { 0xC000010F, \"STATUS_ABIOS_NOT_PRESENT\" },\n  { 0xC0000110, \"STATUS_ABIOS_LID_NOT_EXIST\" },\n  { 0xC0000111, \"STATUS_ABIOS_LID_ALREADY_OWNED\" },\n  { 0xC0000112, \"STATUS_ABIOS_NOT_LID_OWNER\" },\n  { 0xC0000113, \"STATUS_ABIOS_INVALID_COMMAND\" },\n  { 0xC0000114, \"STATUS_ABIOS_INVALID_LID\" },\n  { 0xC0000115, \"STATUS_ABIOS_SELECTOR_NOT_AVAILABLE\" },\n  { 0xC0000116, \"STATUS_ABIOS_INVALID_SELECTOR\" },\n  { 0xC0000117, \"STATUS_NO_LDT\" },\n  { 0xC0000118, \"STATUS_INVALID_LDT_SIZE\" },\n  { 0xC0000119, \"STATUS_INVALID_LDT_OFFSET\" },\n  { 0xC000011A, \"STATUS_INVALID_LDT_DESCRIPTOR\" },\n  { 0xC000011B, \"STATUS_INVALID_IMAGE_NE_FORMAT\" },\n  { 0xC000011C, \"STATUS_RXACT_INVALID_STATE\" },\n  { 0xC000011D, \"STATUS_RXACT_COMMIT_FAILURE\" },\n  { 0xC000011E, \"STATUS_MAPPED_FILE_SIZE_ZERO\" },\n  { 0xC000011F, \"STATUS_TOO_MANY_OPENED_FILES\" },\n  { 0xC0000120, \"STATUS_CANCELLED\" },\n  { 0xC0000121, \"STATUS_CANNOT_DELETE\" },\n  { 0xC0000122, \"STATUS_INVALID_COMPUTER_NAME\" },\n  { 0xC0000123, \"STATUS_FILE_DELETED\" },\n  { 0xC0000124, \"STATUS_SPECIAL_ACCOUNT\" },\n  { 0xC0000125, \"STATUS_SPECIAL_GROUP\" },\n  { 0xC0000126, \"STATUS_SPECIAL_USER\" },\n  { 0xC0000127, \"STATUS_MEMBERS_PRIMARY_GROUP\" },\n  { 0xC0000128, \"STATUS_FILE_CLOSED\" },\n  { 0xC0000129, \"STATUS_TOO_MANY_THREADS\" },\n  { 0xC000012A, \"STATUS_THREAD_NOT_IN_PROCESS\" },\n  { 0xC000012B, \"STATUS_TOKEN_ALREADY_IN_USE\" },\n  { 0xC000012C, \"STATUS_PAGEFILE_QUOTA_EXCEEDED\" },\n  { 0xC000012D, \"STATUS_COMMITMENT_LIMIT\" },\n  { 0xC000012E, \"STATUS_INVALID_IMAGE_LE_FORMAT\" },\n  { 0xC000012F, \"STATUS_INVALID_IMAGE_NOT_MZ\" },\n  { 0xC0000130, \"STATUS_INVALID_IMAGE_PROTECT\" },\n  { 0xC0000131, \"STATUS_INVALID_IMAGE_WIN_16\" },\n  { 0xC0000132, \"STATUS_LOGON_SERVER_CONFLICT\" },\n  { 0xC0000133, \"STATUS_TIME_DIFFERENCE_AT_DC\" },\n  { 0xC0000134, \"STATUS_SYNCHRONIZATION_REQUIRED\" },\n  { 0xC0000135, \"STATUS_DLL_NOT_FOUND\" },\n  { 0xC0000136, \"STATUS_OPEN_FAILED\" },\n  { 0xC0000137, \"STATUS_IO_PRIVILEGE_FAILED\" },\n  { 0xC0000138, \"STATUS_ORDINAL_NOT_FOUND\" },\n  { 0xC0000139, \"STATUS_ENTRYPOINT_NOT_FOUND\" },\n  { 0xC000013A, \"STATUS_CONTROL_C_EXIT\" },\n  { 0xC000013B, \"STATUS_LOCAL_DISCONNECT\" },\n  { 0xC000013C, \"STATUS_REMOTE_DISCONNECT\" },\n  { 0xC000013D, \"STATUS_REMOTE_RESOURCES\" },\n  { 0xC000013E, \"STATUS_LINK_FAILED\" },\n  { 0xC000013F, \"STATUS_LINK_TIMEOUT\" },\n  { 0xC0000140, \"STATUS_INVALID_CONNECTION\" },\n  { 0xC0000141, \"STATUS_INVALID_ADDRESS\" },\n  { 0xC0000142, \"STATUS_DLL_INIT_FAILED\" },\n  { 0xC0000143, \"STATUS_MISSING_SYSTEMFILE\" },\n  { 0xC0000144, \"STATUS_UNHANDLED_EXCEPTION\" },\n  { 0xC0000145, \"STATUS_APP_INIT_FAILURE\" },\n  { 0xC0000146, \"STATUS_PAGEFILE_CREATE_FAILED\" },\n  { 0xC0000147, \"STATUS_NO_PAGEFILE\" },\n  { 0xC0000148, \"STATUS_INVALID_LEVEL\" },\n  { 0xC0000149, \"STATUS_WRONG_PASSWORD_CORE\" },\n  { 0xC000014A, \"STATUS_ILLEGAL_FLOAT_CONTEXT\" },\n  { 0xC000014B, \"STATUS_PIPE_BROKEN\" },\n  { 0xC000014C, \"STATUS_REGISTRY_CORRUPT\" },\n  { 0xC000014D, \"STATUS_REGISTRY_IO_FAILED\" },\n  { 0xC000014E, \"STATUS_NO_EVENT_PAIR\" },\n  { 0xC000014F, \"STATUS_UNRECOGNIZED_VOLUME\" },\n  { 0xC0000150, \"STATUS_SERIAL_NO_DEVICE_INITED\" },\n  { 0xC0000151, \"STATUS_NO_SUCH_ALIAS\" },\n  { 0xC0000152, \"STATUS_MEMBER_NOT_IN_ALIAS\" },\n  { 0xC0000153, \"STATUS_MEMBER_IN_ALIAS\" },\n  { 0xC0000154, \"STATUS_ALIAS_EXISTS\" },\n  { 0xC0000155, \"STATUS_LOGON_NOT_GRANTED\" },\n  { 0xC0000156, \"STATUS_TOO_MANY_SECRETS\" },\n  { 0xC0000157, \"STATUS_SECRET_TOO_LONG\" },\n  { 0xC0000158, \"STATUS_INTERNAL_DB_ERROR\" },\n  { 0xC0000159, \"STATUS_FULLSCREEN_MODE\" },\n  { 0xC000015A, \"STATUS_TOO_MANY_CONTEXT_IDS\" },\n  { 0xC000015B, \"STATUS_LOGON_TYPE_NOT_GRANTED\" },\n  { 0xC000015C, \"STATUS_NOT_REGISTRY_FILE\" },\n  { 0xC000015D, \"STATUS_NT_CROSS_ENCRYPTION_REQUIRED\" },\n  { 0xC000015E, \"STATUS_DOMAIN_CTRLR_CONFIG_ERROR\" },\n  { 0xC000015F, \"STATUS_FT_MISSING_MEMBER\" },\n  { 0xC0000160, \"STATUS_ILL_FORMED_SERVICE_ENTRY\" },\n  { 0xC0000161, \"STATUS_ILLEGAL_CHARACTER\" },\n  { 0xC0000162, \"STATUS_UNMAPPABLE_CHARACTER\" },\n  { 0xC0000163, \"STATUS_UNDEFINED_CHARACTER\" },\n  { 0xC0000164, \"STATUS_FLOPPY_VOLUME\" },\n  { 0xC0000165, \"STATUS_FLOPPY_ID_MARK_NOT_FOUND\" },\n  { 0xC0000166, \"STATUS_FLOPPY_WRONG_CYLINDER\" },\n  { 0xC0000167, \"STATUS_FLOPPY_UNKNOWN_ERROR\" },\n  { 0xC0000168, \"STATUS_FLOPPY_BAD_REGISTERS\" },\n  { 0xC0000169, \"STATUS_DISK_RECALIBRATE_FAILED\" },\n  { 0xC000016A, \"STATUS_DISK_OPERATION_FAILED\" },\n  { 0xC000016B, \"STATUS_DISK_RESET_FAILED\" },\n  { 0xC000016C, \"STATUS_SHARED_IRQ_BUSY\" },\n  { 0xC000016D, \"STATUS_FT_ORPHANING\" },\n  { 0xC000016E, \"STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT\" },\n  { 0xC0000172, \"STATUS_PARTITION_FAILURE\" },\n  { 0xC0000173, \"STATUS_INVALID_BLOCK_LENGTH\" },\n  { 0xC0000174, \"STATUS_DEVICE_NOT_PARTITIONED\" },\n  { 0xC0000175, \"STATUS_UNABLE_TO_LOCK_MEDIA\" },\n  { 0xC0000176, \"STATUS_UNABLE_TO_UNLOAD_MEDIA\" },\n  { 0xC0000177, \"STATUS_EOM_OVERFLOW\" },\n  { 0xC0000178, \"STATUS_NO_MEDIA\" },\n  { 0xC000017A, \"STATUS_NO_SUCH_MEMBER\" },\n  { 0xC000017B, \"STATUS_INVALID_MEMBER\" },\n  { 0xC000017C, \"STATUS_KEY_DELETED\" },\n  { 0xC000017D, \"STATUS_NO_LOG_SPACE\" },\n  { 0xC000017E, \"STATUS_TOO_MANY_SIDS\" },\n  { 0xC000017F, \"STATUS_LM_CROSS_ENCRYPTION_REQUIRED\" },\n  { 0xC0000180, \"STATUS_KEY_HAS_CHILDREN\" },\n  { 0xC0000181, \"STATUS_CHILD_MUST_BE_VOLATILE\" },\n  { 0xC0000182, \"STATUS_DEVICE_CONFIGURATION_ERROR\" },\n  { 0xC0000183, \"STATUS_DRIVER_INTERNAL_ERROR\" },\n  { 0xC0000184, \"STATUS_INVALID_DEVICE_STATE\" },\n  { 0xC0000185, \"STATUS_IO_DEVICE_ERROR\" },\n  { 0xC0000186, \"STATUS_DEVICE_PROTOCOL_ERROR\" },\n  { 0xC0000187, \"STATUS_BACKUP_CONTROLLER\" },\n  { 0xC0000188, \"STATUS_LOG_FILE_FULL\" },\n  { 0xC0000189, \"STATUS_TOO_LATE\" },\n  { 0xC000018A, \"STATUS_NO_TRUST_LSA_SECRET\" },\n  { 0xC000018B, \"STATUS_NO_TRUST_SAM_ACCOUNT\" },\n  { 0xC000018C, \"STATUS_TRUSTED_DOMAIN_FAILURE\" },\n  { 0xC000018D, \"STATUS_TRUSTED_RELATIONSHIP_FAILURE\" },\n  { 0xC000018E, \"STATUS_EVENTLOG_FILE_CORRUPT\" },\n  { 0xC000018F, \"STATUS_EVENTLOG_CANT_START\" },\n  { 0xC0000190, \"STATUS_TRUST_FAILURE\" },\n  { 0xC0000191, \"STATUS_MUTANT_LIMIT_EXCEEDED\" },\n  { 0xC0000192, \"STATUS_NETLOGON_NOT_STARTED\" },\n  { 0xC0000193, \"STATUS_ACCOUNT_EXPIRED\" },\n  { 0xC0000194, \"STATUS_POSSIBLE_DEADLOCK\" },\n  { 0xC0000195, \"STATUS_NETWORK_CREDENTIAL_CONFLICT\" },\n  { 0xC0000196, \"STATUS_REMOTE_SESSION_LIMIT\" },\n  { 0xC0000197, \"STATUS_EVENTLOG_FILE_CHANGED\" },\n  { 0xC0000198, \"STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT\" },\n  { 0xC0000199, \"STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT\" },\n  { 0xC000019A, \"STATUS_NOLOGON_SERVER_TRUST_ACCOUNT\" },\n  { 0xC000019B, \"STATUS_DOMAIN_TRUST_INCONSISTENT\" },\n  { 0xC000019C, \"STATUS_FS_DRIVER_REQUIRED\" },\n  { 0xC0000202, \"STATUS_NO_USER_SESSION_KEY\" },\n  { 0xC0000203, \"STATUS_USER_SESSION_DELETED\" },\n  { 0xC0000204, \"STATUS_RESOURCE_LANG_NOT_FOUND\" },\n  { 0xC0000205, \"STATUS_INSUFF_SERVER_RESOURCES\" },\n  { 0xC0000206, \"STATUS_INVALID_BUFFER_SIZE\" },\n  { 0xC0000207, \"STATUS_INVALID_ADDRESS_COMPONENT\" },\n  { 0xC0000208, \"STATUS_INVALID_ADDRESS_WILDCARD\" },\n  { 0xC0000209, \"STATUS_TOO_MANY_ADDRESSES\" },\n  { 0xC000020A, \"STATUS_ADDRESS_ALREADY_EXISTS\" },\n  { 0xC000020B, \"STATUS_ADDRESS_CLOSED\" },\n  { 0xC000020C, \"STATUS_CONNECTION_DISCONNECTED\" },\n  { 0xC000020D, \"STATUS_CONNECTION_RESET\" },\n  { 0xC000020E, \"STATUS_TOO_MANY_NODES\" },\n  { 0xC000020F, \"STATUS_TRANSACTION_ABORTED\" },\n  { 0xC0000210, \"STATUS_TRANSACTION_TIMED_OUT\" },\n  { 0xC0000211, \"STATUS_TRANSACTION_NO_RELEASE\" },\n  { 0xC0000212, \"STATUS_TRANSACTION_NO_MATCH\" },\n  { 0xC0000213, \"STATUS_TRANSACTION_RESPONDED\" },\n  { 0xC0000214, \"STATUS_TRANSACTION_INVALID_ID\" },\n  { 0xC0000215, \"STATUS_TRANSACTION_INVALID_TYPE\" },\n  { 0xC0000216, \"STATUS_NOT_SERVER_SESSION\" },\n  { 0xC0000217, \"STATUS_NOT_CLIENT_SESSION\" },\n  { 0xC0000218, \"STATUS_CANNOT_LOAD_REGISTRY_FILE\" },\n  { 0xC0000219, \"STATUS_DEBUG_ATTACH_FAILED\" },\n  { 0xC000021A, \"STATUS_SYSTEM_PROCESS_TERMINATED\" },\n  { 0xC000021B, \"STATUS_DATA_NOT_ACCEPTED\" },\n  { 0xC000021C, \"STATUS_NO_BROWSER_SERVERS_FOUND\" },\n  { 0xC000021D, \"STATUS_VDM_HARD_ERROR\" },\n  { 0xC000021E, \"STATUS_DRIVER_CANCEL_TIMEOUT\" },\n  { 0xC000021F, \"STATUS_REPLY_MESSAGE_MISMATCH\" },\n  { 0xC0000220, \"STATUS_MAPPED_ALIGNMENT\" },\n  { 0xC0000221, \"STATUS_IMAGE_CHECKSUM_MISMATCH\" },\n  { 0xC0000222, \"STATUS_LOST_WRITEBEHIND_DATA\" },\n  { 0xC0000223, \"STATUS_CLIENT_SERVER_PARAMETERS_INVALID\" },\n  { 0xC0000224, \"STATUS_PASSWORD_MUST_CHANGE\" },\n  { 0xC0000225, \"STATUS_NOT_FOUND\" },\n  { 0xC0000226, \"STATUS_NOT_TINY_STREAM\" },\n  { 0xC0000227, \"STATUS_RECOVERY_FAILURE\" },\n  { 0xC0000228, \"STATUS_STACK_OVERFLOW_READ\" },\n  { 0xC0000229, \"STATUS_FAIL_CHECK\" },\n  { 0xC000022A, \"STATUS_DUPLICATE_OBJECTID\" },\n  { 0xC000022B, \"STATUS_OBJECTID_EXISTS\" },\n  { 0xC000022C, \"STATUS_CONVERT_TO_LARGE\" },\n  { 0xC000022D, \"STATUS_RETRY\" },\n  { 0xC000022E, \"STATUS_FOUND_OUT_OF_SCOPE\" },\n  { 0xC000022F, \"STATUS_ALLOCATE_BUCKET\" },\n  { 0xC0000230, \"STATUS_PROPSET_NOT_FOUND\" },\n  { 0xC0000231, \"STATUS_MARSHALL_OVERFLOW\" },\n  { 0xC0000232, \"STATUS_INVALID_VARIANT\" },\n  { 0xC0000233, \"STATUS_DOMAIN_CONTROLLER_NOT_FOUND\" },\n  { 0xC0000234, \"STATUS_ACCOUNT_LOCKED_OUT\" },\n  { 0xC0000235, \"STATUS_HANDLE_NOT_CLOSABLE\" },\n  { 0xC0000236, \"STATUS_CONNECTION_REFUSED\" },\n  { 0xC0000237, \"STATUS_GRACEFUL_DISCONNECT\" },\n  { 0xC0000238, \"STATUS_ADDRESS_ALREADY_ASSOCIATED\" },\n  { 0xC0000239, \"STATUS_ADDRESS_NOT_ASSOCIATED\" },\n  { 0xC000023A, \"STATUS_CONNECTION_INVALID\" },\n  { 0xC000023B, \"STATUS_CONNECTION_ACTIVE\" },\n  { 0xC000023C, \"STATUS_NETWORK_UNREACHABLE\" },\n  { 0xC000023D, \"STATUS_HOST_UNREACHABLE\" },\n  { 0xC000023E, \"STATUS_PROTOCOL_UNREACHABLE\" },\n  { 0xC000023F, \"STATUS_PORT_UNREACHABLE\" },\n  { 0xC0000240, \"STATUS_REQUEST_ABORTED\" },\n  { 0xC0000241, \"STATUS_CONNECTION_ABORTED\" },\n  { 0xC0000242, \"STATUS_BAD_COMPRESSION_BUFFER\" },\n  { 0xC0000243, \"STATUS_USER_MAPPED_FILE\" },\n  { 0xC0000244, \"STATUS_AUDIT_FAILED\" },\n  { 0xC0000245, \"STATUS_TIMER_RESOLUTION_NOT_SET\" },\n  { 0xC0000246, \"STATUS_CONNECTION_COUNT_LIMIT\" },\n  { 0xC0000247, \"STATUS_LOGIN_TIME_RESTRICTION\" },\n  { 0xC0000248, \"STATUS_LOGIN_WKSTA_RESTRICTION\" },\n  { 0xC0000249, \"STATUS_IMAGE_MP_UP_MISMATCH\" },\n  { 0xC0000250, \"STATUS_INSUFFICIENT_LOGON_INFO\" },\n  { 0xC0000251, \"STATUS_BAD_DLL_ENTRYPOINT\" },\n  { 0xC0000252, \"STATUS_BAD_SERVICE_ENTRYPOINT\" },\n  { 0xC0000253, \"STATUS_LPC_REPLY_LOST\" },\n  { 0xC0000254, \"STATUS_IP_ADDRESS_CONFLICT1\" },\n  { 0xC0000255, \"STATUS_IP_ADDRESS_CONFLICT2\" },\n  { 0xC0000256, \"STATUS_REGISTRY_QUOTA_LIMIT\" },\n  { 0xC0000257, \"STATUS_PATH_NOT_COVERED\" },\n  { 0xC0000258, \"STATUS_NO_CALLBACK_ACTIVE\" },\n  { 0xC0000259, \"STATUS_LICENSE_QUOTA_EXCEEDED\" },\n  { 0xC000025A, \"STATUS_PWD_TOO_SHORT\" },\n  { 0xC000025B, \"STATUS_PWD_TOO_RECENT\" },\n  { 0xC000025C, \"STATUS_PWD_HISTORY_CONFLICT\" },\n  { 0xC000025E, \"STATUS_PLUGPLAY_NO_DEVICE\" },\n  { 0xC000025F, \"STATUS_UNSUPPORTED_COMPRESSION\" },\n  { 0xC0000260, \"STATUS_INVALID_HW_PROFILE\" },\n  { 0xC0000261, \"STATUS_INVALID_PLUGPLAY_DEVICE_PATH\" },\n  { 0xC0000262, \"STATUS_DRIVER_ORDINAL_NOT_FOUND\" },\n  { 0xC0000263, \"STATUS_DRIVER_ENTRYPOINT_NOT_FOUND\" },\n  { 0xC0000264, \"STATUS_RESOURCE_NOT_OWNED\" },\n  { 0xC0000265, \"STATUS_TOO_MANY_LINKS\" },\n  { 0xC0000266, \"STATUS_QUOTA_LIST_INCONSISTENT\" },\n  { 0xC0000267, \"STATUS_FILE_IS_OFFLINE\" },\n  { 0xC0000268, \"STATUS_EVALUATION_EXPIRATION\" },\n  { 0xC0000269, \"STATUS_ILLEGAL_DLL_RELOCATION\" },\n  { 0xC000026A, \"STATUS_LICENSE_VIOLATION\" },\n  { 0xC000026B, \"STATUS_DLL_INIT_FAILED_LOGOFF\" },\n  { 0xC000026C, \"STATUS_DRIVER_UNABLE_TO_LOAD\" },\n  { 0xC000026D, \"STATUS_DFS_UNAVAILABLE\" },\n  { 0xC000026E, \"STATUS_VOLUME_DISMOUNTED\" },\n  { 0xC000026F, \"STATUS_WX86_INTERNAL_ERROR\" },\n  { 0xC0000270, \"STATUS_WX86_FLOAT_STACK_CHECK\" },\n  { 0xC0000271, \"STATUS_VALIDATE_CONTINUE\" },\n  { 0xC0000272, \"STATUS_NO_MATCH\" },\n  { 0xC0000273, \"STATUS_NO_MORE_MATCHES\" },\n  { 0xC0000275, \"STATUS_NOT_A_REPARSE_POINT\" },\n  { 0xC0000276, \"STATUS_IO_REPARSE_TAG_INVALID\" },\n  { 0xC0000277, \"STATUS_IO_REPARSE_TAG_MISMATCH\" },\n  { 0xC0000278, \"STATUS_IO_REPARSE_DATA_INVALID\" },\n  { 0xC0000279, \"STATUS_IO_REPARSE_TAG_NOT_HANDLED\" },\n  { 0xC0000280, \"STATUS_REPARSE_POINT_NOT_RESOLVED\" },\n  { 0xC0000281, \"STATUS_DIRECTORY_IS_A_REPARSE_POINT\" },\n  { 0xC0000282, \"STATUS_RANGE_LIST_CONFLICT\" },\n  { 0xC0000283, \"STATUS_SOURCE_ELEMENT_EMPTY\" },\n  { 0xC0000284, \"STATUS_DESTINATION_ELEMENT_FULL\" },\n  { 0xC0000285, \"STATUS_ILLEGAL_ELEMENT_ADDRESS\" },\n  { 0xC0000286, \"STATUS_MAGAZINE_NOT_PRESENT\" },\n  { 0xC0000287, \"STATUS_REINITIALIZATION_NEEDED\" },\n  { 0x80000288, \"STATUS_DEVICE_REQUIRES_CLEANING\" },\n  { 0x80000289, \"STATUS_DEVICE_DOOR_OPEN\" },\n  { 0xC000028A, \"STATUS_ENCRYPTION_FAILED\" },\n  { 0xC000028B, \"STATUS_DECRYPTION_FAILED\" },\n  { 0xC000028C, \"STATUS_RANGE_NOT_FOUND\" },\n  { 0xC000028D, \"STATUS_NO_RECOVERY_POLICY\" },\n  { 0xC000028E, \"STATUS_NO_EFS\" },\n  { 0xC000028F, \"STATUS_WRONG_EFS\" },\n  { 0xC0000290, \"STATUS_NO_USER_KEYS\" },\n  { 0xC0000291, \"STATUS_FILE_NOT_ENCRYPTED\" },\n  { 0xC0000292, \"STATUS_NOT_EXPORT_FORMAT\" },\n  { 0xC0000293, \"STATUS_FILE_ENCRYPTED\" },\n  { 0x40000294, \"STATUS_WAKE_SYSTEM\" },\n  { 0xC0000295, \"STATUS_WMI_GUID_NOT_FOUND\" },\n  { 0xC0000296, \"STATUS_WMI_INSTANCE_NOT_FOUND\" },\n  { 0xC0000297, \"STATUS_WMI_ITEMID_NOT_FOUND\" },\n  { 0xC0000298, \"STATUS_WMI_TRY_AGAIN\" },\n  { 0xC0000299, \"STATUS_SHARED_POLICY\" },\n  { 0xC000029A, \"STATUS_POLICY_OBJECT_NOT_FOUND\" },\n  { 0xC000029B, \"STATUS_POLICY_ONLY_IN_DS\" },\n  { 0xC000029C, \"STATUS_VOLUME_NOT_UPGRADED\" },\n  { 0xC000029D, \"STATUS_REMOTE_STORAGE_NOT_ACTIVE\" },\n  { 0xC000029E, \"STATUS_REMOTE_STORAGE_MEDIA_ERROR\" },\n  { 0xC000029F, \"STATUS_NO_TRACKING_SERVICE\" },\n  { 0xC00002A0, \"STATUS_SERVER_SID_MISMATCH\" },\n  { 0xC00002A1, \"STATUS_DS_NO_ATTRIBUTE_OR_VALUE\" },\n  { 0xC00002A2, \"STATUS_DS_INVALID_ATTRIBUTE_SYNTAX\" },\n  { 0xC00002A3, \"STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED\" },\n  { 0xC00002A4, \"STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS\" },\n  { 0xC00002A5, \"STATUS_DS_BUSY\" },\n  { 0xC00002A6, \"STATUS_DS_UNAVAILABLE\" },\n  { 0xC00002A7, \"STATUS_DS_NO_RIDS_ALLOCATED\" },\n  { 0xC00002A8, \"STATUS_DS_NO_MORE_RIDS\" },\n  { 0xC00002A9, \"STATUS_DS_INCORRECT_ROLE_OWNER\" },\n  { 0xC00002AA, \"STATUS_DS_RIDMGR_INIT_ERROR\" },\n  { 0xC00002AB, \"STATUS_DS_OBJ_CLASS_VIOLATION\" },\n  { 0xC00002AC, \"STATUS_DS_CANT_ON_NON_LEAF\" },\n  { 0xC00002AD, \"STATUS_DS_CANT_ON_RDN\" },\n  { 0xC00002AE, \"STATUS_DS_CANT_MOD_OBJ_CLASS\" },\n  { 0xC00002AF, \"STATUS_DS_CROSS_DOM_MOVE_FAILED\" },\n  { 0xC00002B0, \"STATUS_DS_GC_NOT_AVAILABLE\" },\n  { 0xC00002B1, \"STATUS_DIRECTORY_SERVICE_REQUIRED\" },\n  { 0xC00002B2, \"STATUS_REPARSE_ATTRIBUTE_CONFLICT\" },\n  { 0xC00002B3, \"STATUS_CANT_ENABLE_DENY_ONLY\" },\n  { 0xC00002B4, \"STATUS_FLOAT_MULTIPLE_FAULTS\" },\n  { 0xC00002B5, \"STATUS_FLOAT_MULTIPLE_TRAPS\" },\n  { 0xC00002B6, \"STATUS_DEVICE_REMOVED\" },\n  { 0xC00002B7, \"STATUS_JOURNAL_DELETE_IN_PROGRESS\" },\n  { 0xC00002B8, \"STATUS_JOURNAL_NOT_ACTIVE\" },\n  { 0xC00002B9, \"STATUS_NOINTERFACE\" },\n  { 0xC00002C1, \"STATUS_DS_ADMIN_LIMIT_EXCEEDED\" },\n  { 0xC00002C2, \"STATUS_DRIVER_FAILED_SLEEP\" },\n  { 0xC00002C3, \"STATUS_MUTUAL_AUTHENTICATION_FAILED\" },\n  { 0xC00002C4, \"STATUS_CORRUPT_SYSTEM_FILE\" },\n  { 0xC00002C5, \"STATUS_DATATYPE_MISALIGNMENT_ERROR\" },\n  { 0xC00002C6, \"STATUS_WMI_READ_ONLY\" },\n  { 0xC00002C7, \"STATUS_WMI_SET_FAILURE\" },\n  { 0xC00002C8, \"STATUS_COMMITMENT_MINIMUM\" },\n  { 0xC00002C9, \"STATUS_REG_NAT_CONSUMPTION\" },\n  { 0xC00002CA, \"STATUS_TRANSPORT_FULL\" },\n  { 0xC00002CB, \"STATUS_DS_SAM_INIT_FAILURE\" },\n  { 0xC00002CC, \"STATUS_ONLY_IF_CONNECTED\" },\n  { 0xC00002CD, \"STATUS_DS_SENSITIVE_GROUP_VIOLATION\" },\n  { 0xC00002CE, \"STATUS_PNP_RESTART_ENUMERATION\" },\n  { 0xC00002CF, \"STATUS_JOURNAL_ENTRY_DELETED\" },\n  { 0xC00002D0, \"STATUS_DS_CANT_MOD_PRIMARYGROUPID\" },\n  { 0xC00002D1, \"STATUS_SYSTEM_IMAGE_BAD_SIGNATURE\" },\n  { 0xC00002D2, \"STATUS_PNP_REBOOT_REQUIRED\" },\n  { 0xC00002D3, \"STATUS_POWER_STATE_INVALID\" },\n  { 0xC00002D4, \"STATUS_DS_INVALID_GROUP_TYPE\" },\n  { 0xC00002D5, \"STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN\" },\n  { 0xC00002D6, \"STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN\" },\n  { 0xC00002D7, \"STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER\" },\n  { 0xC00002D8, \"STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER\" },\n  { 0xC00002D9, \"STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER\" },\n  { 0xC00002DA, \"STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER\" },\n  { 0xC00002DB, \"STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER\" },\n  { 0xC00002DC, \"STATUS_DS_HAVE_PRIMARY_MEMBERS\" },\n  { 0xC00002DD, \"STATUS_WMI_NOT_SUPPORTED\" },\n  { 0xC00002DE, \"STATUS_INSUFFICIENT_POWER\" },\n  { 0xC00002DF, \"STATUS_SAM_NEED_BOOTKEY_PASSWORD\" },\n  { 0xC00002E0, \"STATUS_SAM_NEED_BOOTKEY_FLOPPY\" },\n  { 0xC00002E1, \"STATUS_DS_CANT_START\" },\n  { 0xC00002E2, \"STATUS_DS_INIT_FAILURE\" },\n  { 0xC00002E3, \"STATUS_SAM_INIT_FAILURE\" },\n  { 0xC00002E4, \"STATUS_DS_GC_REQUIRED\" },\n  { 0xC00002E5, \"STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY\" },\n  { 0xC00002E6, \"STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS\" },\n  { 0xC00002E7, \"STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED\" },\n  { 0xC00002E8, \"STATUS_MULTIPLE_FAULT_VIOLATION\" },\n  { 0xC0000300, \"STATUS_NOT_SUPPORTED_ON_SBS\" },\n  { 0xC0009898, \"STATUS_WOW_ASSERTION\" },\n  { 0xC0020001, \"RPC_NT_INVALID_STRING_BINDING\" },\n  { 0xC0020002, \"RPC_NT_WRONG_KIND_OF_BINDING\" },\n  { 0xC0020003, \"RPC_NT_INVALID_BINDING\" },\n  { 0xC0020004, \"RPC_NT_PROTSEQ_NOT_SUPPORTED\" },\n  { 0xC0020005, \"RPC_NT_INVALID_RPC_PROTSEQ\" },\n  { 0xC0020006, \"RPC_NT_INVALID_STRING_UUID\" },\n  { 0xC0020007, \"RPC_NT_INVALID_ENDPOINT_FORMAT\" },\n  { 0xC0020008, \"RPC_NT_INVALID_NET_ADDR\" },\n  { 0xC0020009, \"RPC_NT_NO_ENDPOINT_FOUND\" },\n  { 0xC002000A, \"RPC_NT_INVALID_TIMEOUT\" },\n  { 0xC002000B, \"RPC_NT_OBJECT_NOT_FOUND\" },\n  { 0xC002000C, \"RPC_NT_ALREADY_REGISTERED\" },\n  { 0xC002000D, \"RPC_NT_TYPE_ALREADY_REGISTERED\" },\n  { 0xC002000E, \"RPC_NT_ALREADY_LISTENING\" },\n  { 0xC002000F, \"RPC_NT_NO_PROTSEQS_REGISTERED\" },\n  { 0xC0020010, \"RPC_NT_NOT_LISTENING\" },\n  { 0xC0020011, \"RPC_NT_UNKNOWN_MGR_TYPE\" },\n  { 0xC0020012, \"RPC_NT_UNKNOWN_IF\" },\n  { 0xC0020013, \"RPC_NT_NO_BINDINGS\" },\n  { 0xC0020014, \"RPC_NT_NO_PROTSEQS\" },\n  { 0xC0020015, \"RPC_NT_CANT_CREATE_ENDPOINT\" },\n  { 0xC0020016, \"RPC_NT_OUT_OF_RESOURCES\" },\n  { 0xC0020017, \"RPC_NT_SERVER_UNAVAILABLE\" },\n  { 0xC0020018, \"RPC_NT_SERVER_TOO_BUSY\" },\n  { 0xC0020019, \"RPC_NT_INVALID_NETWORK_OPTIONS\" },\n  { 0xC002001A, \"RPC_NT_NO_CALL_ACTIVE\" },\n  { 0xC002001B, \"RPC_NT_CALL_FAILED\" },\n  { 0xC002001C, \"RPC_NT_CALL_FAILED_DNE\" },\n  { 0xC002001D, \"RPC_NT_PROTOCOL_ERROR\" },\n  { 0xC002001F, \"RPC_NT_UNSUPPORTED_TRANS_SYN\" },\n  { 0xC0020021, \"RPC_NT_UNSUPPORTED_TYPE\" },\n  { 0xC0020022, \"RPC_NT_INVALID_TAG\" },\n  { 0xC0020023, \"RPC_NT_INVALID_BOUND\" },\n  { 0xC0020024, \"RPC_NT_NO_ENTRY_NAME\" },\n  { 0xC0020025, \"RPC_NT_INVALID_NAME_SYNTAX\" },\n  { 0xC0020026, \"RPC_NT_UNSUPPORTED_NAME_SYNTAX\" },\n  { 0xC0020028, \"RPC_NT_UUID_NO_ADDRESS\" },\n  { 0xC0020029, \"RPC_NT_DUPLICATE_ENDPOINT\" },\n  { 0xC002002A, \"RPC_NT_UNKNOWN_AUTHN_TYPE\" },\n  { 0xC002002B, \"RPC_NT_MAX_CALLS_TOO_SMALL\" },\n  { 0xC002002C, \"RPC_NT_STRING_TOO_LONG\" },\n  { 0xC002002D, \"RPC_NT_PROTSEQ_NOT_FOUND\" },\n  { 0xC002002E, \"RPC_NT_PROCNUM_OUT_OF_RANGE\" },\n  { 0xC002002F, \"RPC_NT_BINDING_HAS_NO_AUTH\" },\n  { 0xC0020030, \"RPC_NT_UNKNOWN_AUTHN_SERVICE\" },\n  { 0xC0020031, \"RPC_NT_UNKNOWN_AUTHN_LEVEL\" },\n  { 0xC0020032, \"RPC_NT_INVALID_AUTH_IDENTITY\" },\n  { 0xC0020033, \"RPC_NT_UNKNOWN_AUTHZ_SERVICE\" },\n  { 0xC0020034, \"EPT_NT_INVALID_ENTRY\" },\n  { 0xC0020035, \"EPT_NT_CANT_PERFORM_OP\" },\n  { 0xC0020036, \"EPT_NT_NOT_REGISTERED\" },\n  { 0xC0020037, \"RPC_NT_NOTHING_TO_EXPORT\" },\n  { 0xC0020038, \"RPC_NT_INCOMPLETE_NAME\" },\n  { 0xC0020039, \"RPC_NT_INVALID_VERS_OPTION\" },\n  { 0xC002003A, \"RPC_NT_NO_MORE_MEMBERS\" },\n  { 0xC002003B, \"RPC_NT_NOT_ALL_OBJS_UNEXPORTED\" },\n  { 0xC002003C, \"RPC_NT_INTERFACE_NOT_FOUND\" },\n  { 0xC002003D, \"RPC_NT_ENTRY_ALREADY_EXISTS\" },\n  { 0xC002003E, \"RPC_NT_ENTRY_NOT_FOUND\" },\n  { 0xC002003F, \"RPC_NT_NAME_SERVICE_UNAVAILABLE\" },\n  { 0xC0020040, \"RPC_NT_INVALID_NAF_ID\" },\n  { 0xC0020041, \"RPC_NT_CANNOT_SUPPORT\" },\n  { 0xC0020042, \"RPC_NT_NO_CONTEXT_AVAILABLE\" },\n  { 0xC0020043, \"RPC_NT_INTERNAL_ERROR\" },\n  { 0xC0020044, \"RPC_NT_ZERO_DIVIDE\" },\n  { 0xC0020045, \"RPC_NT_ADDRESS_ERROR\" },\n  { 0xC0020046, \"RPC_NT_FP_DIV_ZERO\" },\n  { 0xC0020047, \"RPC_NT_FP_UNDERFLOW\" },\n  { 0xC0020048, \"RPC_NT_FP_OVERFLOW\" },\n  { 0xC0021007, \"RPC_P_RECEIVE_ALERTED\" },\n  { 0xC0021008, \"RPC_P_CONNECTION_CLOSED\" },\n  { 0xC0021009, \"RPC_P_RECEIVE_FAILED\" },\n  { 0xC002100A, \"RPC_P_SEND_FAILED\" },\n  { 0xC002100B, \"RPC_P_TIMEOUT\" },\n  { 0xC002100C, \"RPC_P_SERVER_TRANSPORT_ERROR\" },\n  { 0xC002100E, \"RPC_P_EXCEPTION_OCCURRED\" },\n  { 0xC0021012, \"RPC_P_CONNECTION_SHUTDOWN\" },\n  { 0xC0021015, \"RPC_P_THREAD_LISTENING\" },\n  { 0xC0030001, \"RPC_NT_NO_MORE_ENTRIES\" },\n  { 0xC0030002, \"RPC_NT_SS_CHAR_TRANS_OPEN_FAIL\" },\n  { 0xC0030003, \"RPC_NT_SS_CHAR_TRANS_SHORT_FILE\" },\n  { 0xC0030004, \"RPC_NT_SS_IN_NULL_CONTEXT\" },\n  { 0xC0030005, \"RPC_NT_SS_CONTEXT_MISMATCH\" },\n  { 0xC0030006, \"RPC_NT_SS_CONTEXT_DAMAGED\" },\n  { 0xC0030007, \"RPC_NT_SS_HANDLES_MISMATCH\" },\n  { 0xC0030008, \"RPC_NT_SS_CANNOT_GET_CALL_HANDLE\" },\n  { 0xC0030009, \"RPC_NT_NULL_REF_POINTER\" },\n  { 0xC003000A, \"RPC_NT_ENUM_VALUE_OUT_OF_RANGE\" },\n  { 0xC003000B, \"RPC_NT_BYTE_COUNT_TOO_SMALL\" },\n  { 0xC003000C, \"RPC_NT_BAD_STUB_DATA\" },\n  { 0xC0020049, \"RPC_NT_CALL_IN_PROGRESS\" },\n  { 0xC002004A, \"RPC_NT_NO_MORE_BINDINGS\" },\n  { 0xC002004B, \"RPC_NT_GROUP_MEMBER_NOT_FOUND\" },\n  { 0xC002004C, \"EPT_NT_CANT_CREATE\" },\n  { 0xC002004D, \"RPC_NT_INVALID_OBJECT\" },\n  { 0xC002004F, \"RPC_NT_NO_INTERFACES\" },\n  { 0xC0020050, \"RPC_NT_CALL_CANCELLED\" },\n  { 0xC0020051, \"RPC_NT_BINDING_INCOMPLETE\" },\n  { 0xC0020052, \"RPC_NT_COMM_FAILURE\" },\n  { 0xC0020053, \"RPC_NT_UNSUPPORTED_AUTHN_LEVEL\" },\n  { 0xC0020054, \"RPC_NT_NO_PRINC_NAME\" },\n  { 0xC0020055, \"RPC_NT_NOT_RPC_ERROR\" },\n  { 0x40020056, \"RPC_NT_UUID_LOCAL_ONLY\" },\n  { 0xC0020057, \"RPC_NT_SEC_PKG_ERROR\" },\n  { 0xC0020058, \"RPC_NT_NOT_CANCELLED\" },\n  { 0xC0030059, \"RPC_NT_INVALID_ES_ACTION\" },\n  { 0xC003005A, \"RPC_NT_WRONG_ES_VERSION\" },\n  { 0xC003005B, \"RPC_NT_WRONG_STUB_VERSION\" },\n  { 0xC003005C, \"RPC_NT_INVALID_PIPE_OBJECT\" },\n  { 0xC003005D, \"RPC_NT_INVALID_PIPE_OPERATION\" },\n  { 0xC003005E, \"RPC_NT_WRONG_PIPE_VERSION\" },\n  { 0x400200AF, \"RPC_NT_SEND_INCOMPLETE\" },\n  { 0,          NULL }\n};\n\n/*\n * return an NT error string from a SMB buffer\n */\nconst char *\nnt_errstr(uint32_t err)\n{\n    static char ret[128];\n    int i;\n\n    ret[0] = 0;\n\n    for (i = 0; nt_errors[i].name; i++) {\n\tif (err == nt_errors[i].code)\n\t    return nt_errors[i].name;\n    }\n\n    snprintf(ret, sizeof(ret), \"0x%08x\", err);\n    return ret;\n}\n", "/*\n * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Support for splitting captures into multiple files with a maximum\n * file size:\n *\n * Copyright (c) 2001\n *\tSeth Webster <swebster@sst.ll.mit.edu>\n */\n\n/*\n * tcpdump - dump traffic on a network\n *\n * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.\n * Mercilessly hacked and occasionally improved since then via the\n * combined efforts of Van, Steve McCanne and Craig Leres of LBL.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n/*\n * Some older versions of Mac OS X may ship pcap.h from libpcap 0.6 with a\n * libpcap based on 0.8.  That means it has pcap_findalldevs() but the\n * header doesn't define pcap_if_t, meaning that we can't actually *use*\n * pcap_findalldevs().\n */\n#ifdef HAVE_PCAP_FINDALLDEVS\n#ifndef HAVE_PCAP_IF_T\n#undef HAVE_PCAP_FINDALLDEVS\n#endif\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n/*\n * This must appear after including netdissect-stdinc.h, so that _U_ is\n * defined.\n */\n#ifndef lint\nstatic const char copyright[] _U_ =\n    \"@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\\n\\\nThe Regents of the University of California.  All rights reserved.\\n\";\n#endif\n\n#include <sys/stat.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef HAVE_LIBCRYPTO\n#include <openssl/crypto.h>\n#endif\n\n#ifdef HAVE_GETOPT_LONG\n#include <getopt.h>\n#else\n#include \"missing/getopt_long.h\"\n#endif\n/* Capsicum-specific code requires macros from <net/bpf.h>, which will fail\n * to compile if <pcap.h> has already been included; including the headers\n * in the opposite order works fine. For the most part anyway, because in\n * FreeBSD <pcap/pcap.h> declares bpf_dump() instead of <net/bpf.h>. Thus\n * interface.h takes care of it later to avoid a compiler warning.\n */\n#ifdef HAVE_CAPSICUM\n#include <sys/capsicum.h>\n#include <sys/ioccom.h>\n#include <net/bpf.h>\n#include <libgen.h>\n#ifdef HAVE_CASPER\n#include <libcasper.h>\n#include <casper/cap_dns.h>\n#include <sys/nv.h>\n#endif\t/* HAVE_CASPER */\n#endif\t/* HAVE_CAPSICUM */\n#ifdef HAVE_PCAP_OPEN\n/*\n * We found pcap_open() in the capture library, so we'll be using\n * the remote capture APIs; define PCAP_REMOTE before we include pcap.h,\n * so we get those APIs declared, and the types and #defines that they\n * use defined.\n *\n * WinPcap's headers require that PCAP_REMOTE be defined in order to get\n * remote-capture APIs declared and types and #defines that they use\n * defined.\n *\n * (Versions of libpcap with those APIs, and thus Npcap, which is based on\n * those versions of libpcap, don't require it.)\n */\n#define HAVE_REMOTE\n#endif\n#include <pcap.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <pwd.h>\n#include <grp.h>\n#endif /* _WIN32 */\n\n/*\n * Pathname separator.\n * Use this in pathnames, but do *not* use it in URLs.\n */\n#ifdef _WIN32\n#define PATH_SEPARATOR\t'\\\\'\n#else\n#define PATH_SEPARATOR\t'/'\n#endif\n\n/* capabilities convenience library */\n/* If a code depends on HAVE_LIBCAP_NG, it depends also on HAVE_CAP_NG_H.\n * If HAVE_CAP_NG_H is not defined, undefine HAVE_LIBCAP_NG.\n * Thus, the later tests are done only on HAVE_LIBCAP_NG.\n */\n#ifdef HAVE_LIBCAP_NG\n#ifdef HAVE_CAP_NG_H\n#include <cap-ng.h>\n#else\n#undef HAVE_LIBCAP_NG\n#endif /* HAVE_CAP_NG_H */\n#endif /* HAVE_LIBCAP_NG */\n\n#ifdef __FreeBSD__\n#include <sys/sysctl.h>\n#endif /* __FreeBSD__ */\n\n#include \"netdissect-stdinc.h\"\n#include \"netdissect.h\"\n#include \"interface.h\"\n#include \"addrtoname.h\"\n#include \"machdep.h\"\n#include \"pcap-missing.h\"\n#include \"ascii_strcasecmp.h\"\n\n#include \"print.h\"\n\n#include \"diag-control.h\"\n\n#include \"fptype.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#if defined(SIGINFO)\n#define SIGNAL_REQ_INFO SIGINFO\n#elif defined(SIGUSR1)\n#define SIGNAL_REQ_INFO SIGUSR1\n#endif\n\n#if defined(HAVE_PCAP_DUMP_FLUSH) && defined(SIGUSR2)\n#define SIGNAL_FLUSH_PCAP SIGUSR2\n#endif\n\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\nstatic int Bflag;\t\t\t/* buffer size */\n#endif\n#ifdef HAVE_PCAP_DUMP_FTELL64\nstatic int64_t Cflag;\t\t\t/* rotate dump files after this many bytes */\n#else\nstatic long Cflag;\t\t\t/* rotate dump files after this many bytes */\n#endif\nstatic int Cflag_count;\t\t\t/* Keep track of which file number we're writing */\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic int Dflag;\t\t\t/* list available devices and exit */\n#endif\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\nstatic char *remote_interfaces_source;\t/* list available devices from this source and exit */\n#endif\n\n/*\n * This is exported because, in some versions of libpcap, if libpcap\n * is built with optimizer debugging code (which is *NOT* the default\n * configuration!), the library *imports*(!) a variable named dflag,\n * under the expectation that tcpdump is exporting it, to govern\n * how much debugging information to print when optimizing\n * the generated BPF code.\n *\n * This is a horrible hack; newer versions of libpcap don't import\n * dflag but, instead, *if* built with optimizer debugging code,\n * *export* a routine to set that flag.\n */\nextern int dflag;\nint dflag;\t\t\t\t/* print filter code */\nstatic int Gflag;\t\t\t/* rotate dump files after this many seconds */\nstatic int Gflag_count;\t\t\t/* number of files created with Gflag rotation */\nstatic time_t Gflag_time;\t\t/* The last time_t the dump file was rotated. */\nstatic int Lflag;\t\t\t/* list available data link types and exit */\nstatic int Iflag;\t\t\t/* rfmon (monitor) mode */\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic int Jflag;\t\t\t/* list available time stamp types */\nstatic int jflag = -1;\t\t\t/* packet time stamp source */\n#endif\nstatic int lflag;\t\t\t/* line-buffered output */\nstatic int pflag;\t\t\t/* don't go promiscuous */\n#ifdef HAVE_PCAP_SETDIRECTION\nstatic int Qflag = -1;\t\t\t/* restrict captured packet by send/receive direction */\n#endif\n#ifdef HAVE_PCAP_DUMP_FLUSH\nstatic int Uflag;\t\t\t/* \"unbuffered\" output of dump files */\n#endif\nstatic int Wflag;\t\t\t/* recycle output files after this number of files */\nstatic int WflagChars;\nstatic char *zflag = NULL;\t\t/* compress each savefile using a specified command (like gzip or bzip2) */\nstatic int timeout = 1000;\t\t/* default timeout = 1000 ms = 1 s */\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\nstatic int immediate_mode;\n#endif\nstatic int count_mode;\n\nstatic int infodelay;\nstatic int infoprint;\n\nchar *program_name;\n\n/* Forwards */\nstatic NORETURN void error(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);\nstatic void warning(FORMAT_STRING(const char *), ...) PRINTFLIKE(1, 2);\nstatic NORETURN void exit_tcpdump(int);\nstatic void (*setsignal (int sig, void (*func)(int)))(int);\nstatic void cleanup(int);\nstatic void child_cleanup(int);\nstatic void print_version(FILE *);\nstatic void print_usage(FILE *);\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic NORETURN void show_tstamp_types_and_exit(pcap_t *, const char *device);\n#endif\nstatic NORETURN void show_dlts_and_exit(pcap_t *, const char *device);\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic NORETURN void show_devices_and_exit(void);\n#endif\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\nstatic NORETURN void show_remote_devices_and_exit(void);\n#endif\n\nstatic void print_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet_and_trunc(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void dump_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nstatic void droproot(const char *, const char *);\n\n#ifdef SIGNAL_REQ_INFO\nstatic void requestinfo(int);\n#endif\n\n#ifdef SIGNAL_FLUSH_PCAP\nstatic void flushpcap(int);\n#endif\n\n#ifdef _WIN32\n    static HANDLE timer_handle = INVALID_HANDLE_VALUE;\n    static void CALLBACK verbose_stats_dump(PVOID param, BOOLEAN timer_fired);\n#else /* _WIN32 */\n  static void verbose_stats_dump(int sig);\n#endif /* _WIN32 */\n\nstatic void info(int);\nstatic u_int packets_captured;\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic const struct tok status_flags[] = {\n#ifdef PCAP_IF_UP\n\t{ PCAP_IF_UP,       \"Up\"       },\n#endif\n#ifdef PCAP_IF_RUNNING\n\t{ PCAP_IF_RUNNING,  \"Running\"  },\n#endif\n\t{ PCAP_IF_LOOPBACK, \"Loopback\" },\n#ifdef PCAP_IF_WIRELESS\n\t{ PCAP_IF_WIRELESS, \"Wireless\" },\n#endif\n\t{ 0, NULL }\n};\n#endif\n\nstatic pcap_t *pd;\nstatic pcap_dumper_t *pdd = NULL;\n\nstatic int supports_monitor_mode;\n\nextern int optind;\nextern int opterr;\nextern char *optarg;\n\nstruct dump_info {\n\tchar\t*WFileName;\n\tchar\t*CurrentFileName;\n\tpcap_t\t*pd;\n\tpcap_dumper_t *pdd;\n\tnetdissect_options *ndo;\n#ifdef HAVE_CAPSICUM\n\tint\tdirfd;\n#endif\n};\n\n#if defined(HAVE_PCAP_SET_PARSER_DEBUG)\n/*\n * We have pcap_set_parser_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the parser for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_parser_debug(int);\n#elif defined(HAVE_PCAP_DEBUG) || defined(HAVE_YYDEBUG)\n/*\n * We don't have pcap_set_parser_debug() in libpcap, but we do have\n * pcap_debug or yydebug.  Make a local version of pcap_set_parser_debug()\n * to set the flag, and define HAVE_PCAP_SET_PARSER_DEBUG.\n */\nstatic void\npcap_set_parser_debug(int value)\n{\n#ifdef HAVE_PCAP_DEBUG\n\textern int pcap_debug;\n\n\tpcap_debug = value;\n#else /* HAVE_PCAP_DEBUG */\n\textern int yydebug;\n\n\tyydebug = value;\n#endif /* HAVE_PCAP_DEBUG */\n}\n\n#define HAVE_PCAP_SET_PARSER_DEBUG\n#endif\n\n#if defined(HAVE_PCAP_SET_OPTIMIZER_DEBUG)\n/*\n * We have pcap_set_optimizer_debug() in libpcap; declare it (it's not declared\n * by any libpcap header, because it's a special hack, only available if\n * libpcap was configured to include it, and only intended for use by\n * libpcap developers trying to debug the optimizer for filter expressions).\n */\n#ifdef _WIN32\n__declspec(dllimport)\n#else /* _WIN32 */\nextern\n#endif /* _WIN32 */\nvoid pcap_set_optimizer_debug(int);\n#endif\n\n/* VARARGS */\nstatic void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit_tcpdump(S_ERR_HOST_PROGRAM);\n\t/* NOTREACHED */\n}\n\n/* VARARGS */\nstatic void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}\n\nstatic void\nexit_tcpdump(int status)\n{\n\tnd_cleanup();\n\texit(status);\n}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\nstatic void\nshow_tstamp_types_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_tstamp_types;\n\tint *tstamp_types = 0;\n\tconst char *tstamp_type_name;\n\tint i;\n\n\tn_tstamp_types = pcap_list_tstamp_types(pc, &tstamp_types);\n\tif (n_tstamp_types < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\n\tif (n_tstamp_types == 0) {\n\t\tfprintf(stderr, \"Time stamp type cannot be set for %s\\n\",\n\t\t    device);\n\t\texit_tcpdump(S_SUCCESS);\n\t}\n\tfprintf(stderr, \"Time stamp types for %s (use option -j to set):\\n\",\n\t    device);\n\tfor (i = 0; i < n_tstamp_types; i++) {\n\t\ttstamp_type_name = pcap_tstamp_type_val_to_name(tstamp_types[i]);\n\t\tif (tstamp_type_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\\n\", tstamp_type_name,\n\t\t\t    pcap_tstamp_type_val_to_description(tstamp_types[i]));\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  %d\\n\", tstamp_types[i]);\n\t\t}\n\t}\n\tpcap_free_tstamp_types(tstamp_types);\n\texit_tcpdump(S_SUCCESS);\n}\n#endif\n\nstatic void\nshow_dlts_and_exit(pcap_t *pc, const char *device)\n{\n\tint n_dlts, i;\n\tint *dlts = 0;\n\tconst char *dlt_name;\n\n\tn_dlts = pcap_list_datalinks(pc, &dlts);\n\tif (n_dlts < 0)\n\t\terror(\"%s\", pcap_geterr(pc));\n\telse if (n_dlts == 0 || !dlts)\n\t\terror(\"No data link types.\");\n\n\t/*\n\t * If the interface is known to support monitor mode, indicate\n\t * whether these are the data link types available when not in\n\t * monitor mode, if -I wasn't specified, or when in monitor mode,\n\t * when -I was specified (the link-layer types available in\n\t * monitor mode might be different from the ones available when\n\t * not in monitor mode).\n\t */\n\tif (supports_monitor_mode)\n\t\t(void) fprintf(stderr, \"Data link types for %s %s (use option -y to set):\\n\",\n\t\t    device,\n\t\t    Iflag ? \"when in monitor mode\" : \"when not in monitor mode\");\n\telse\n\t\t(void) fprintf(stderr, \"Data link types for %s (use option -y to set):\\n\",\n\t\t    device);\n\n\tfor (i = 0; i < n_dlts; i++) {\n\t\tdlt_name = pcap_datalink_val_to_name(dlts[i]);\n\t\tif (dlt_name != NULL) {\n\t\t\t(void) fprintf(stderr, \"  %s (%s)\", dlt_name,\n\t\t\t    pcap_datalink_val_to_description(dlts[i]));\n\n\t\t\t/*\n\t\t\t * OK, does tcpdump handle that type?\n\t\t\t */\n\t\t\tif (!has_printer(dlts[i]))\n\t\t\t\t(void) fprintf(stderr, \" (printing not supported)\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"  DLT %d (printing not supported)\\n\",\n\t\t\t    dlts[i]);\n\t\t}\n\t}\n#ifdef HAVE_PCAP_FREE_DATALINKS\n\tpcap_free_datalinks(dlts);\n#endif\n\texit_tcpdump(S_SUCCESS);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic void\nshow_devices_and_exit(void)\n{\n\tpcap_if_t *dev, *devlist;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint i;\n\n\tif (pcap_findalldevs(&devlist, ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\tfor (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {\n\t\tprintf(\"%d.%s\", i+1, dev->name);\n\t\tif (dev->description != NULL)\n\t\t\tprintf(\" (%s)\", dev->description);\n\t\tif (dev->flags != 0) {\n\t\t\tprintf(\" [\");\n\t\t\tprintf(\"%s\", bittok2str(status_flags, \"none\", dev->flags));\n#ifdef PCAP_IF_WIRELESS\n\t\t\tif (dev->flags & PCAP_IF_WIRELESS) {\n\t\t\t\tswitch (dev->flags & PCAP_IF_CONNECTION_STATUS) {\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_UNKNOWN:\n\t\t\t\t\tprintf(\", Association status unknown\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_CONNECTED:\n\t\t\t\t\tprintf(\", Associated\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_DISCONNECTED:\n\t\t\t\t\tprintf(\", Not associated\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (dev->flags & PCAP_IF_CONNECTION_STATUS) {\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_UNKNOWN:\n\t\t\t\t\tprintf(\", Connection status unknown\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_CONNECTED:\n\t\t\t\t\tprintf(\", Connected\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_DISCONNECTED:\n\t\t\t\t\tprintf(\", Disconnected\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tprintf(\"]\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tpcap_freealldevs(devlist);\n\texit_tcpdump(S_SUCCESS);\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\nstatic void\nshow_remote_devices_and_exit(void)\n{\n\tpcap_if_t *dev, *devlist;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint i;\n\n\tif (pcap_findalldevs_ex(remote_interfaces_source, NULL, &devlist,\n\t    ebuf) < 0)\n\t\terror(\"%s\", ebuf);\n\tfor (i = 0, dev = devlist; dev != NULL; i++, dev = dev->next) {\n\t\tprintf(\"%d.%s\", i+1, dev->name);\n\t\tif (dev->description != NULL)\n\t\t\tprintf(\" (%s)\", dev->description);\n\t\tif (dev->flags != 0)\n\t\t\tprintf(\" [%s]\", bittok2str(status_flags, \"none\", dev->flags));\n\t\tprintf(\"\\n\");\n\t}\n\tpcap_freealldevs(devlist);\n\texit_tcpdump(S_SUCCESS);\n}\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\n/*\n * Short options.\n *\n * Note that there we use all letters for short options except for g, k,\n * o, and P, and those are used by other versions of tcpdump, and we should\n * only use them for the same purposes that the other versions of tcpdump\n * use them:\n *\n * macOS tcpdump uses -g to force non--v output for IP to be on one\n * line, making it more \"g\"repable;\n *\n * macOS tcpdump uses -k to specify that packet comments in pcapng files\n * should be printed;\n *\n * OpenBSD tcpdump uses -o to indicate that OS fingerprinting should be done\n * for hosts sending TCP SYN packets;\n *\n * macOS tcpdump uses -P to indicate that -w should write pcapng rather\n * than pcap files.\n *\n * macOS tcpdump also uses -Q to specify expressions that match packet\n * metadata, including but not limited to the packet direction.\n * The expression syntax is different from a simple \"in|out|inout\",\n * and those expressions aren't accepted by macOS tcpdump, but the\n * equivalents would be \"in\" = \"dir=in\", \"out\" = \"dir=out\", and\n * \"inout\" = \"dir=in or dir=out\", and the parser could conceivably\n * special-case \"in\", \"out\", and \"inout\" as expressions for backwards\n * compatibility, so all is not (yet) lost.\n */\n\n/*\n * Set up flags that might or might not be supported depending on the\n * version of libpcap we're using.\n */\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n#define B_FLAG\t\t\"B:\"\n#define B_FLAG_USAGE\t\" [ -B size ]\"\n#else /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n#define B_FLAG\n#define B_FLAG_USAGE\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n#define D_FLAG\t\"D\"\n#else\n#define D_FLAG\n#endif\n\n#ifdef HAVE_PCAP_CREATE\n#define I_FLAG\t\t\"I\"\n#else /* HAVE_PCAP_CREATE */\n#define I_FLAG\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n#define j_FLAG\t\t\"j:\"\n#define j_FLAG_USAGE\t\" [ -j tstamptype ]\"\n#define J_FLAG\t\t\"J\"\n#else /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n#define j_FLAG\n#define j_FLAG_USAGE\n#define J_FLAG\n#endif /* PCAP_ERROR_TSTAMP_TYPE_NOTSUP */\n\n#ifdef USE_LIBSMI\n#define m_FLAG_USAGE \"[ -m module ] ...\"\n#endif\n\n#ifdef HAVE_PCAP_SETDIRECTION\n#define Q_FLAG \"Q:\"\n#define Q_FLAG_USAGE \" [ -Q in|out|inout ]\"\n#else\n#define Q_FLAG\n#define Q_FLAG_USAGE\n#endif\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n#define U_FLAG\t\"U\"\n#else\n#define U_FLAG\n#endif\n\n#define SHORTOPTS \"aAb\" B_FLAG \"c:C:d\" D_FLAG \"eE:fF:G:hHi:\" I_FLAG j_FLAG J_FLAG \"KlLm:M:nNOpq\" Q_FLAG \"r:s:StT:u\" U_FLAG \"vV:w:W:xXy:Yz:Z:#\"\n\n/*\n * Long options.\n *\n * We do not currently have long options corresponding to all short\n * options; we should probably pick appropriate option names for them.\n *\n * However, the short options where the number of times the option is\n * specified matters, such as -v and -d and -t, should probably not\n * just map to a long option, as saying\n *\n *  tcpdump --verbose --verbose\n *\n * doesn't make sense; it should be --verbosity={N} or something such\n * as that.\n *\n * For long options with no corresponding short options, we define values\n * outside the range of ASCII graphic characters, make that the last\n * component of the entry for the long option, and have a case for that\n * option in the switch statement.\n */\n#define OPTION_VERSION\t\t\t128\n#define OPTION_TSTAMP_PRECISION\t\t129\n#define OPTION_IMMEDIATE_MODE\t\t130\n#define OPTION_PRINT\t\t\t131\n#define OPTION_LIST_REMOTE_INTERFACES\t132\n#define OPTION_TSTAMP_MICRO\t\t133\n#define OPTION_TSTAMP_NANO\t\t134\n#define OPTION_FP_TYPE\t\t\t135\n#define OPTION_COUNT\t\t\t136\n\nstatic const struct option longopts[] = {\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t{ \"buffer-size\", required_argument, NULL, 'B' },\n#endif\n\t{ \"list-interfaces\", no_argument, NULL, 'D' },\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t{ \"list-remote-interfaces\", required_argument, NULL, OPTION_LIST_REMOTE_INTERFACES },\n#endif\n\t{ \"help\", no_argument, NULL, 'h' },\n\t{ \"interface\", required_argument, NULL, 'i' },\n#ifdef HAVE_PCAP_CREATE\n\t{ \"monitor-mode\", no_argument, NULL, 'I' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t{ \"time-stamp-type\", required_argument, NULL, 'j' },\n\t{ \"list-time-stamp-types\", no_argument, NULL, 'J' },\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t{ \"micro\", no_argument, NULL, OPTION_TSTAMP_MICRO},\n\t{ \"nano\", no_argument, NULL, OPTION_TSTAMP_NANO},\n\t{ \"time-stamp-precision\", required_argument, NULL, OPTION_TSTAMP_PRECISION},\n#endif\n\t{ \"dont-verify-checksums\", no_argument, NULL, 'K' },\n\t{ \"list-data-link-types\", no_argument, NULL, 'L' },\n\t{ \"no-optimize\", no_argument, NULL, 'O' },\n\t{ \"no-promiscuous-mode\", no_argument, NULL, 'p' },\n#ifdef HAVE_PCAP_SETDIRECTION\n\t{ \"direction\", required_argument, NULL, 'Q' },\n#endif\n\t{ \"snapshot-length\", required_argument, NULL, 's' },\n\t{ \"absolute-tcp-sequence-numbers\", no_argument, NULL, 'S' },\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t{ \"packet-buffered\", no_argument, NULL, 'U' },\n#endif\n\t{ \"linktype\", required_argument, NULL, 'y' },\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t{ \"immediate-mode\", no_argument, NULL, OPTION_IMMEDIATE_MODE },\n#endif\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t{ \"debug-filter-parser\", no_argument, NULL, 'Y' },\n#endif\n\t{ \"relinquish-privileges\", required_argument, NULL, 'Z' },\n\t{ \"count\", no_argument, NULL, OPTION_COUNT },\n\t{ \"fp-type\", no_argument, NULL, OPTION_FP_TYPE },\n\t{ \"number\", no_argument, NULL, '#' },\n\t{ \"print\", no_argument, NULL, OPTION_PRINT },\n\t{ \"version\", no_argument, NULL, OPTION_VERSION },\n\t{ NULL, 0, NULL, 0 }\n};\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n#define LIST_REMOTE_INTERFACES_USAGE \"[ --list-remote-interfaces remote-source ]\"\n#else\n#define LIST_REMOTE_INTERFACES_USAGE\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n#define IMMEDIATE_MODE_USAGE \" [ --immediate-mode ]\"\n#else\n#define IMMEDIATE_MODE_USAGE \"\"\n#endif\n\n#ifndef _WIN32\n/* Drop root privileges and chroot if necessary */\nstatic void\ndroproot(const char *username, const char *chroot_dir)\n{\n\tstruct passwd *pw = NULL;\n\n\tif (chroot_dir && !username)\n\t\terror(\"Chroot without dropping root is insecure\");\n\n\tpw = getpwnam(username);\n\tif (pw) {\n\t\tif (chroot_dir) {\n\t\t\tif (chroot(chroot_dir) != 0 || chdir (\"/\") != 0)\n\t\t\t\terror(\"Couldn't chroot/chdir to '%.64s': %s\",\n\t\t\t\t      chroot_dir, pcap_strerror(errno));\n\t\t}\n#ifdef HAVE_LIBCAP_NG\n\t\t{\n\t\t\tint ret = capng_change_id(pw->pw_uid, pw->pw_gid, CAPNG_NO_FLAG);\n\t\t\tif (ret < 0)\n\t\t\t\terror(\"capng_change_id(): return %d\\n\", ret);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#else\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) != 0 ||\n\t\t    setgid(pw->pw_gid) != 0 || setuid(pw->pw_uid) != 0)\n\t\t\terror(\"Couldn't change to '%.32s' uid=%lu gid=%lu: %s\",\n\t\t\t\tusername,\n\t\t\t\t(unsigned long)pw->pw_uid,\n\t\t\t\t(unsigned long)pw->pw_gid,\n\t\t\t\tpcap_strerror(errno));\n\t\telse {\n\t\t\tfprintf(stderr, \"dropped privs to %s\\n\", username);\n\t\t}\n#endif /* HAVE_LIBCAP_NG */\n\t} else\n\t\terror(\"Couldn't find user '%.32s'\", username);\n#ifdef HAVE_LIBCAP_NG\n\t/* We don't need CAP_SETUID, CAP_SETGID and CAP_SYS_CHROOT any more. */\nDIAG_OFF_ASSIGN_ENUM\n\tcapng_updatev(\n\t\tCAPNG_DROP,\n\t\tCAPNG_EFFECTIVE | CAPNG_PERMITTED,\n\t\tCAP_SETUID,\n\t\tCAP_SETGID,\n\t\tCAP_SYS_CHROOT,\n\t\t-1);\nDIAG_ON_ASSIGN_ENUM\n\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\n}\n#endif /* _WIN32 */\n\nstatic int\ngetWflagChars(int x)\n{\n\tint c = 0;\n\n\tx -= 1;\n\twhile (x > 0) {\n\t\tc += 1;\n\t\tx /= 10;\n\t}\n\n\treturn c;\n}\n\n\nstatic void\nMakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n        if (strlen(orig_name) == 0)\n            error(\"an empty string is not a valid file name\");\n\n        /* Process with strftime if Gflag is set. */\n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          /* Convert Gflag_time to a usable format */\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n\n          /* There's no good way to detect an error in strftime since a return\n           * value of 0 isn't necessarily failure; if orig_name is an empty\n           * string, the formatted string will be empty.\n           *\n           * However, the C90 standard says that, if there *is* a\n           * buffer overflow, the content of the buffer is undefined,\n           * so we must check for a buffer overflow.\n           *\n           * So we check above for an empty orig_name, and only call\n           * strftime() if it's non-empty, in which case the return\n           * value will only be 0 if the formatted date doesn't fit\n           * in the buffer.\n           *\n           * (We check above because, even if we don't use -G, we\n           * want a better error message than \"tcpdump: : No such\n           * file or directory\" for this case.)\n           */\n          if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {\n            error(\"%s: strftime\", __func__);\n          }\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  /* Report an error if the filename is too large */\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}\n\nstatic char *\nget_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tsize_t len;\n\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\n\tlen = strlen (ptr);\n\tif (len > 0 && ptr[len - 1] == '\\n')\n\t\tptr[len - 1] = '\\0';\n\n\treturn ret;\n}\n\n#ifdef HAVE_CASPER\nstatic cap_channel_t *\ncapdns_setup(void)\n{\n\tcap_channel_t *capcas, *capdnsloc;\n\tconst char *types[1];\n\tint families[2];\n\n\tcapcas = cap_init();\n\tif (capcas == NULL)\n\t\terror(\"unable to create casper process\");\n\tcapdnsloc = cap_service_open(capcas, \"system.dns\");\n\t/* Casper capability no longer needed. */\n\tcap_close(capcas);\n\tif (capdnsloc == NULL)\n\t\terror(\"unable to open system.dns service\");\n\t/* Limit system.dns to reverse DNS lookups. */\n\ttypes[0] = \"ADDR\";\n\tif (cap_dns_type_limit(capdnsloc, types, 1) < 0)\n\t\terror(\"unable to limit access to system.dns service\");\n\tfamilies[0] = AF_INET;\n\tfamilies[1] = AF_INET6;\n\tif (cap_dns_family_limit(capdnsloc, families, 2) < 0)\n\t\terror(\"unable to limit access to system.dns service\");\n\n\treturn (capdnsloc);\n}\n#endif\t/* HAVE_CASPER */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\nstatic int\ntstamp_precision_from_string(const char *precision)\n{\n\tif (strncmp(precision, \"nano\", strlen(\"nano\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_NANO;\n\n\tif (strncmp(precision, \"micro\", strlen(\"micro\")) == 0)\n\t\treturn PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn -EINVAL;\n}\n\nstatic const char *\ntstamp_precision_to_string(int precision)\n{\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\treturn \"micro\";\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\treturn \"nano\";\n\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n#endif\n\n#ifdef HAVE_CAPSICUM\n/*\n * Ensure that, on a dump file's descriptor, we have all the rights\n * necessary to make the standard I/O library work with an fdopen()ed\n * FILE * from that descriptor.\n *\n * A long time ago in a galaxy far, far away, AT&T decided that, instead\n * of providing separate APIs for getting and setting the FD_ flags on a\n * descriptor, getting and setting the O_ flags on a descriptor, and\n * locking files, they'd throw them all into a kitchen-sink fcntl() call\n * along the lines of ioctl(), the fact that ioctl() operations are\n * largely specific to particular character devices but fcntl() operations\n * are either generic to all descriptors or generic to all descriptors for\n * regular files nonwithstanding.\n *\n * The Capsicum people decided that fine-grained control of descriptor\n * operations was required, so that you need to grant permission for\n * reading, writing, seeking, and fcntl-ing.  The latter, courtesy of\n * AT&T's decision, means that \"fcntl-ing\" isn't a thing, but a motley\n * collection of things, so there are *individual* fcntls for which\n * permission needs to be granted.\n *\n * The FreeBSD standard I/O people implemented some optimizations that\n * requires that the standard I/O routines be able to determine whether\n * the descriptor for the FILE * is open append-only or not; as that\n * descriptor could have come from an open() rather than an fopen(),\n * that requires that it be able to do an F_GETFL fcntl() to read\n * the O_ flags.\n *\n * Tcpdump uses ftell() to determine how much data has been written\n * to a file in order to, when used with -C, determine when it's time\n * to rotate capture files.  ftell() therefore needs to do an lseek()\n * to find out the file offset and must, thanks to the aforementioned\n * optimization, also know whether the descriptor is open append-only\n * or not.\n *\n * The net result of all the above is that we need to grant CAP_SEEK,\n * CAP_WRITE, and CAP_FCNTL with the CAP_FCNTL_GETFL subcapability.\n *\n * Perhaps this is the universe's way of saying that either\n *\n *\t1) there needs to be an fopenat() call and a pcap_dump_openat() call\n *\t   using it, so that Capsicum-capable tcpdump wouldn't need to do\n *\t   an fdopen()\n *\n * or\n *\n *\t2) there needs to be a cap_fdopen() call in the FreeBSD standard\n *\t   I/O library that knows what rights are needed by the standard\n *\t   I/O library, based on the open mode, and assigns them, perhaps\n *\t   with an additional argument indicating, for example, whether\n *\t   seeking should be allowed, so that tcpdump doesn't need to know\n *\t   what the standard I/O library happens to require this week.\n */\nstatic void\nset_dumper_capsicum_rights(pcap_dumper_t *p)\n{\n\tint fd = fileno(pcap_dump_file(p));\n\tcap_rights_t rights;\n\n\tcap_rights_init(&rights, CAP_SEEK, CAP_WRITE, CAP_FCNTL);\n\tif (cap_rights_limit(fd, &rights) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor\");\n\t}\n\tif (cap_fcntls_limit(fd, CAP_FCNTL_GETFL) < 0 && errno != ENOSYS) {\n\t\terror(\"unable to limit dump descriptor fcntls\");\n\t}\n}\n#endif\n\n/*\n * Copy arg vector into a new buffer, concatenating arguments with spaces.\n */\nstatic char *\ncopy_argv(char **argv)\n{\n\tchar **p;\n\tsize_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == NULL)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"%s: malloc\", __func__);\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}\n\n/*\n * On Windows, we need to open the file in binary mode, so that\n * we get all the bytes specified by the size we get from \"fstat()\".\n * On UNIX, that's not necessary.  O_BINARY is defined on Windows;\n * we define it as 0 if it's not defined, so it does nothing.\n */\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\nstatic char *\nread_infile(char *fname)\n{\n\tint i, fd;\n\tssize_t cc;\n\tchar *cp;\n\tour_statb buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (our_fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\t/*\n\t * Reject files whose size doesn't fit into an int; a filter\n\t * *that* large will probably be too big.\n\t */\n\tif (buf.st_size > INT_MAX)\n\t\terror(\"%s is too large\", fname);\n\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, (int) cc,\n\t\t    (int)buf.st_size);\n\n\tclose(fd);\n\t/* replace \"# comment\" with spaces */\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\nstatic long\nparse_interface_number(const char *device)\n{\n\tconst char *p;\n\tlong devnum;\n\tchar *end;\n\n\t/*\n\t * Search for a colon, terminating any scheme at the beginning\n\t * of the device.\n\t */\n\tp = strchr(device, ':');\n\tif (p != NULL) {\n\t\t/*\n\t\t * We found it.  Is it followed by \"//\"?\n\t\t */\n\t\tp++;\t/* skip the : */\n\t\tif (strncmp(p, \"//\", 2) == 0) {\n\t\t\t/*\n\t\t\t * Yes.  Search for the next /, at the end of the\n\t\t\t * authority part of the URL.\n\t\t\t */\n\t\t\tp += 2;\t/* skip the // */\n\t\t\tp = strchr(p, '/');\n\t\t\tif (p != NULL) {\n\t\t\t\t/*\n\t\t\t\t * OK, past the / is the path.\n\t\t\t\t */\n\t\t\t\tdevice = p + 1;\n\t\t\t}\n\t\t}\n\t}\n\tdevnum = strtol(device, &end, 10);\n\tif (device != end && *end == '\\0') {\n\t\t/*\n\t\t * It's all-numeric, but is it a valid number?\n\t\t */\n\t\tif (devnum <= 0) {\n\t\t\t/*\n\t\t\t * No, it's not an ordinal.\n\t\t\t */\n\t\t\terror(\"Invalid adapter index\");\n\t\t}\n\t\treturn (devnum);\n\t} else {\n\t\t/*\n\t\t * It's not all-numeric; return -1, so our caller\n\t\t * knows that.\n\t\t */\n\t\treturn (-1);\n\t}\n}\n\nstatic char *\nfind_interface_by_number(const char *url\n#ifndef HAVE_PCAP_FINDALLDEVS_EX\n_U_\n#endif\n, long devnum)\n{\n\tpcap_if_t *dev, *devlist;\n\tlong i;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar *device;\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\tconst char *endp;\n\tchar *host_url;\n#endif\n\tint status;\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t/*\n\t * Search for a colon, terminating any scheme at the beginning\n\t * of the URL.\n\t */\n\tendp = strchr(url, ':');\n\tif (endp != NULL) {\n\t\t/*\n\t\t * We found it.  Is it followed by \"//\"?\n\t\t */\n\t\tendp++;\t/* skip the : */\n\t\tif (strncmp(endp, \"//\", 2) == 0) {\n\t\t\t/*\n\t\t\t * Yes.  Search for the next /, at the end of the\n\t\t\t * authority part of the URL.\n\t\t\t */\n\t\t\tendp += 2;\t/* skip the // */\n\t\t\tendp = strchr(endp, '/');\n\t\t} else\n\t\t\tendp = NULL;\n\t}\n\tif (endp != NULL) {\n\t\t/*\n\t\t * OK, everything from device to endp is a URL to hand\n\t\t * to pcap_findalldevs_ex().\n\t\t */\n\t\tendp++;\t/* Include the trailing / in the URL; pcap_findalldevs_ex() requires it */\n\t\thost_url = malloc(endp - url + 1);\n\t\tif (host_url == NULL && (endp - url + 1) > 0)\n\t\t\terror(\"Invalid allocation for host\");\n\n\t\tmemcpy(host_url, url, endp - url);\n\t\thost_url[endp - url] = '\\0';\n\t\tstatus = pcap_findalldevs_ex(host_url, NULL, &devlist, ebuf);\n\t\tfree(host_url);\n\t} else\n#endif\n\tstatus = pcap_findalldevs(&devlist, ebuf);\n\tif (status < 0)\n\t\terror(\"%s\", ebuf);\n\t/*\n\t * Look for the devnum-th entry in the list of devices (1-based).\n\t */\n\tfor (i = 0, dev = devlist; i < devnum-1 && dev != NULL;\n\t    i++, dev = dev->next)\n\t\t;\n\tif (dev == NULL)\n\t\terror(\"Invalid adapter index\");\n\tdevice = strdup(dev->name);\n\tpcap_freealldevs(devlist);\n\treturn (device);\n}\n#endif\n\n#ifdef HAVE_PCAP_OPEN\n/*\n * Prefixes for rpcap URLs.\n */\nstatic char rpcap_prefix[] = \"rpcap://\";\nstatic char rpcap_ssl_prefix[] = \"rpcaps://\";\n#endif\n\nstatic pcap_t *\nopen_interface(const char *device, netdissect_options *ndo, char *ebuf)\n{\n\tpcap_t *pc;\n#ifdef HAVE_PCAP_CREATE\n\tint status;\n\tchar *cp;\n#endif\n\n#ifdef HAVE_PCAP_OPEN\n\t/*\n\t * Is this an rpcap URL?\n\t */\n\tif (strncmp(device, rpcap_prefix, sizeof(rpcap_prefix) - 1) == 0 ||\n\t    strncmp(device, rpcap_ssl_prefix, sizeof(rpcap_ssl_prefix) - 1) == 0) {\n\t\t/*\n\t\t * Yes.  Open it with pcap_open().\n\t\t */\n\t\t*ebuf = '\\0';\n\t\tpc = pcap_open(device, ndo->ndo_snaplen,\n\t\t    pflag ? 0 : PCAP_OPENFLAG_PROMISCUOUS, timeout, NULL,\n\t\t    ebuf);\n\t\tif (pc == NULL) {\n\t\t\t/*\n\t\t\t * If this failed with \"No such device\" or \"The system\n\t\t\t * cannot find the device specified\", that means\n\t\t\t * the interface doesn't exist; return NULL, so that\n\t\t\t * the caller can see whether the device name is\n\t\t\t * actually an interface index.\n\t\t\t */\n\t\t\tif (strstr(ebuf, \"No such device\") != NULL ||\n\t\t\t    strstr(ebuf, \"The system cannot find the device specified\") != NULL)\n\t\t\t\treturn (NULL);\n\t\t\terror(\"%s\", ebuf);\n\t\t}\n\t\tif (*ebuf)\n\t\t\twarning(\"%s\", ebuf);\n\t\treturn (pc);\n\t}\n#endif /* HAVE_PCAP_OPEN */\n\n#ifdef HAVE_PCAP_CREATE\n\tpc = pcap_create(device, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (Jflag)\n\t\tshow_tstamp_types_and_exit(pc, device);\n#endif\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tstatus = pcap_set_tstamp_precision(pc, ndo->ndo_tstamp_precision);\n\tif (status != 0)\n\t\terror(\"%s: Can't set %ssecond time stamp precision: %s\",\n\t\t    device,\n\t\t    tstamp_precision_to_string(ndo->ndo_tstamp_precision),\n\t\t    pcap_statustostr(status));\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\tif (immediate_mode) {\n\t\tstatus = pcap_set_immediate_mode(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set immediate mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#endif\n\t/*\n\t * Is this an interface that supports monitor mode?\n\t */\n\tif (pcap_can_set_rfmon(pc) == 1)\n\t\tsupports_monitor_mode = 1;\n\telse\n\t\tsupports_monitor_mode = 0;\n\tif (ndo->ndo_snaplen != 0) {\n\t\t/*\n\t\t * A snapshot length was explicitly specified;\n\t\t * use it.\n\t\t */\n\t\tstatus = pcap_set_snaplen(pc, ndo->ndo_snaplen);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set snapshot length: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_promisc(pc, !pflag);\n\tif (status != 0)\n\t\terror(\"%s: Can't set promiscuous mode: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Iflag) {\n\t\tstatus = pcap_set_rfmon(pc, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set monitor mode: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pc, timeout);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tif (Bflag != 0) {\n\t\tstatus = pcap_set_buffer_size(pc, Bflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: Can't set buffer size: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\tif (jflag != -1) {\n\t\tstatus = pcap_set_tstamp_type(pc, jflag);\n\t\tif (status < 0)\n\t\t\terror(\"%s: Can't set time stamp type: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\telse if (status > 0)\n\t\t\twarning(\"When trying to set timestamp type '%s' on %s: %s\",\n\t\t\t    pcap_tstamp_type_val_to_name(jflag), device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#endif\n\tstatus = pcap_activate(pc);\n\tif (status < 0) {\n\t\t/*\n\t\t * pcap_activate() failed.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_ERROR)\n\t\t\terror(\"%s\", cp);\n\t\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Return an error for our caller to handle.\n\t\t\t */\n\t\t\tsnprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s: %s\\n(%s)\",\n\t\t\t    device, pcap_statustostr(status), cp);\n\t\t} else if (status == PCAP_ERROR_PERM_DENIED && *cp != '\\0')\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n#ifdef __FreeBSD__\n\t\telse if (status == PCAP_ERROR_RFMON_NOTSUP &&\n\t\t    strncmp(device, \"wlan\", 4) == 0) {\n\t\t\tchar parent[8], newdev[8];\n\t\t\tchar sysctl[32];\n\t\t\tsize_t s = sizeof(parent);\n\n\t\t\tsnprintf(sysctl, sizeof(sysctl),\n\t\t\t    \"net.wlan.%d.%%parent\", atoi(device + 4));\n\t\t\tsysctlbyname(sysctl, parent, &s, NULL, 0);\n\t\t\tstrlcpy(newdev, device, sizeof(newdev));\n\t\t\t/* Suggest a new wlan device. */\n\t\t\t/* FIXME: incrementing the index this way is not going to work well\n\t\t\t * when the index is 9 or greater but the only consequence in this\n\t\t\t * specific case would be an error message that looks a bit odd.\n\t\t\t */\n\t\t\tnewdev[strlen(newdev)-1]++;\n\t\t\terror(\"%s is not a monitor mode VAP\\n\"\n\t\t\t    \"To create a new monitor mode VAP use:\\n\"\n\t\t\t    \"  ifconfig %s create wlandev %s wlanmode monitor\\n\"\n\t\t\t    \"and use %s as the tcpdump interface\",\n\t\t\t    device, newdev, parent, newdev);\n\t\t}\n#endif\n\t\telse\n\t\t\terror(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t\tpcap_close(pc);\n\t\treturn (NULL);\n\t} else if (status > 0) {\n\t\t/*\n\t\t * pcap_activate() succeeded, but it's warning us\n\t\t * of a problem it had.\n\t\t */\n\t\tcp = pcap_geterr(pc);\n\t\tif (status == PCAP_WARNING)\n\t\t\twarning(\"%s\", cp);\n\t\telse if (status == PCAP_WARNING_PROMISC_NOTSUP &&\n\t\t         *cp != '\\0')\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), cp);\n\t\telse\n\t\t\twarning(\"%s: %s\", device,\n\t\t\t    pcap_statustostr(status));\n\t}\n#ifdef HAVE_PCAP_SETDIRECTION\n\tif (Qflag != -1) {\n\t\tstatus = pcap_setdirection(pc, Qflag);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_setdirection() failed: %s\",\n\t\t\t      device,  pcap_geterr(pc));\n\t\t}\n#endif /* HAVE_PCAP_SETDIRECTION */\n#else /* HAVE_PCAP_CREATE */\n\t*ebuf = '\\0';\n\t/*\n\t * If no snapshot length was specified, or a length of 0 was\n\t * specified, default to 256KB.\n\t */\n\tif (ndo->ndo_snaplen == 0)\n\t\tndo->ndo_snaplen = MAXIMUM_SNAPLEN;\n\tpc = pcap_open_live(device, ndo->ndo_snaplen, !pflag, timeout, ebuf);\n\tif (pc == NULL) {\n\t\t/*\n\t\t * If this failed with \"No such device\", that means\n\t\t * the interface doesn't exist; return NULL, so that\n\t\t * the caller can see whether the device name is\n\t\t * actually an interface index.\n\t\t */\n\t\tif (strstr(ebuf, \"No such device\") != NULL)\n\t\t\treturn (NULL);\n\t\terror(\"%s\", ebuf);\n\t}\n\tif (*ebuf)\n\t\twarning(\"%s\", ebuf);\n#endif /* HAVE_PCAP_CREATE */\n\n\treturn (pc);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint cnt, op, i;\n\tbpf_u_int32 localnet = 0, netmask = 0;\n\tchar *cp, *infile, *cmdbuf, *device, *RFileName, *VFileName, *WFileName;\n\tchar *endp;\n\tpcap_handler callback;\n\tint dlt;\n\tconst char *dlt_name;\n\tstruct bpf_program fcode;\n#ifndef _WIN32\n\tvoid (*oldhandler)(int);\n#endif\n\tstruct dump_info dumpinfo;\n\tu_char *pcap_userdata;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar VFileLine[PATH_MAX + 1];\n\tconst char *username = NULL;\n#ifndef _WIN32\n\tconst char *chroot_dir = NULL;\n#endif\n\tchar *ret = NULL;\n\tchar *end;\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tpcap_if_t *devlist;\n\tlong devnum;\n#endif\n\tint status;\n\tFILE *VFile;\n#ifdef HAVE_CAPSICUM\n\tcap_rights_t rights;\n\tint cansandbox;\n#endif\t/* HAVE_CAPSICUM */\n\tint Oflag = 1;\t\t\t/* run filter code optimizer */\n\tint yflag_dlt = -1;\n\tconst char *yflag_dlt_name = NULL;\n\tint print = 0;\n\n\tnetdissect_options Ndo;\n\tnetdissect_options *ndo = &Ndo;\n\n\t/*\n\t * Initialize the netdissect code.\n\t */\n\tif (nd_init(ebuf, sizeof(ebuf)) == -1)\n\t\terror(\"%s\", ebuf);\n\n\tmemset(ndo, 0, sizeof(*ndo));\n\tndo_set_function_pointers(ndo);\n\n\tcnt = -1;\n\tdevice = NULL;\n\tinfile = NULL;\n\tRFileName = NULL;\n\tVFileName = NULL;\n\tVFile = NULL;\n\tWFileName = NULL;\n\tdlt = -1;\n\tif ((cp = strrchr(argv[0], PATH_SEPARATOR)) != NULL)\n\t\tndo->program_name = program_name = cp + 1;\n\telse\n\t\tndo->program_name = program_name = argv[0];\n\n#if defined(HAVE_PCAP_WSOCKINIT)\n\tif (pcap_wsockinit() != 0)\n\t\terror(\"Attempting to initialize Winsock failed\");\n#elif defined(HAVE_WSOCKINIT)\n\tif (wsockinit() != 0)\n\t\terror(\"Attempting to initialize Winsock failed\");\n#endif\n\n\t/*\n\t * On platforms where the CPU doesn't support unaligned loads,\n\t * force unaligned accesses to abort with SIGBUS, rather than\n\t * being fixed up (slowly) by the OS kernel; on those platforms,\n\t * misaligned accesses are bugs, and we want tcpdump to crash so\n\t * that the bugs are reported.\n\t */\n\tif (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)\n\t\terror(\"%s\", ebuf);\n\n\twhile (\n\t    (op = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != -1)\n\t\tswitch (op) {\n\n\t\tcase 'a':\n\t\t\t/* compatibility for old -a */\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t\t++ndo->ndo_Aflag;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\t++ndo->ndo_bflag;\n\t\t\tbreak;\n\n#if defined(HAVE_PCAP_CREATE) || defined(_WIN32)\n\t\tcase 'B':\n\t\t\tBflag = atoi(optarg)*1024;\n\t\t\tif (Bflag <= 0)\n\t\t\t\terror(\"invalid packet buffer size %s\", optarg);\n\t\t\tbreak;\n#endif /* defined(HAVE_PCAP_CREATE) || defined(_WIN32) */\n\n\t\tcase 'c':\n\t\t\tcnt = atoi(optarg);\n\t\t\tif (cnt <= 0)\n\t\t\t\terror(\"invalid packet count %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\terrno = 0;\n#ifdef HAVE_PCAP_DUMP_FTELL64\n\t\t\tCflag = strtoint64_t(optarg, &endp, 10);\n#else\n\t\t\tCflag = strtol(optarg, &endp, 10);\n#endif\n\t\t\tif (endp == optarg || *endp != '\\0' || errno != 0\n\t\t\t    || Cflag <= 0)\n\t\t\t\terror(\"invalid file size %s\", optarg);\n\t\t\t/*\n\t\t\t * Will multiplying it by 1000000 overflow?\n\t\t\t */\n#ifdef HAVE_PCAP_DUMP_FTELL64\n\t\t\tif (Cflag > INT64_T_CONSTANT(0x7fffffffffffffff) / 1000000)\n#else\n\t\t\tif (Cflag > LONG_MAX / 1000000)\n#endif\n\t\t\t\terror(\"file size %s is too large\", optarg);\n\t\t\tCflag *= 1000000;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\t++dflag;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\tcase 'D':\n\t\t\tDflag++;\n\t\t\tbreak;\n#endif\n\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t\tcase OPTION_LIST_REMOTE_INTERFACES:\n\t\t\tremote_interfaces_source = optarg;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'L':\n\t\t\tLflag++;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\t++ndo->ndo_eflag;\n\t\t\tbreak;\n\n\t\tcase 'E':\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_espsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\t++ndo->ndo_fflag;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'G':\n\t\t\tGflag = atoi(optarg);\n\t\t\tif (Gflag < 0)\n\t\t\t\terror(\"invalid number of seconds %s\", optarg);\n\n                        /* We will create one file initially. */\n                        Gflag_count = 0;\n\n\t\t\t/* Grab the current time for rotation use. */\n\t\t\tif ((Gflag_time = time(NULL)) == (time_t)-1) {\n\t\t\t\terror(\"%s: can't get current time: %s\",\n\t\t\t\t    __func__, pcap_strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tprint_usage(stdout);\n\t\t\texit_tcpdump(S_SUCCESS);\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\t++ndo->ndo_Hflag;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_CREATE\n\t\tcase 'I':\n\t\t\t++Iflag;\n\t\t\tbreak;\n#endif /* HAVE_PCAP_CREATE */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n\t\tcase 'j':\n\t\t\tjflag = pcap_tstamp_type_name_to_val(optarg);\n\t\t\tif (jflag < 0)\n\t\t\t\terror(\"invalid time stamp type %s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'J':\n\t\t\tJflag++;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'l':\n#ifdef _WIN32\n\t\t\t/*\n\t\t\t * _IOLBF is the same as _IOFBF in Microsoft's C\n\t\t\t * libraries; the only alternative they offer\n\t\t\t * is _IONBF.\n\t\t\t *\n\t\t\t * XXX - this should really be checking for MSVC++,\n\t\t\t * not _WIN32, if, for example, MinGW has its own\n\t\t\t * C library that is more UNIX-compatible.\n\t\t\t */\n\t\t\tsetvbuf(stdout, NULL, _IONBF, 0);\n#else /* _WIN32 */\n#ifdef HAVE_SETLINEBUF\n\t\t\tsetlinebuf(stdout);\n#else\n\t\t\tsetvbuf(stdout, NULL, _IOLBF, 0);\n#endif\n#endif /* _WIN32 */\n\t\t\tlflag = 1;\n\t\t\tbreak;\n\n\t\tcase 'K':\n\t\t\t++ndo->ndo_Kflag;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (nd_have_smi_support()) {\n\t\t\t\tif (nd_load_smi_module(optarg, ebuf, sizeof(ebuf)) == -1)\n\t\t\t\t\terror(\"%s\", ebuf);\n\t\t\t} else {\n\t\t\t\t(void)fprintf(stderr, \"%s: ignoring option `-m %s' \",\n\t\t\t\t\t      program_name, optarg);\n\t\t\t\t(void)fprintf(stderr, \"(no libsmi support)\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\t/* TCP-MD5 shared secret */\n#ifndef HAVE_LIBCRYPTO\n\t\t\twarning(\"crypto code not compiled in\");\n#endif\n\t\t\tndo->ndo_sigsecret = optarg;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\t++ndo->ndo_nflag;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\t++ndo->ndo_Nflag;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tOflag = 0;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t++pflag;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\t++ndo->ndo_qflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SETDIRECTION\n\t\tcase 'Q':\n\t\t\tif (ascii_strcasecmp(optarg, \"in\") == 0)\n\t\t\t\tQflag = PCAP_D_IN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"out\") == 0)\n\t\t\t\tQflag = PCAP_D_OUT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"inout\") == 0)\n\t\t\t\tQflag = PCAP_D_INOUT;\n\t\t\telse\n\t\t\t\terror(\"unknown capture direction `%s'\", optarg);\n\t\t\tbreak;\n#endif /* HAVE_PCAP_SETDIRECTION */\n\n\t\tcase 'r':\n\t\t\tRFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tndo->ndo_snaplen = (int)strtol(optarg, &end, 0);\n\t\t\tif (optarg == end || *end != '\\0'\n\t\t\t    || ndo->ndo_snaplen < 0 || ndo->ndo_snaplen > MAXIMUM_SNAPLEN)\n\t\t\t\terror(\"invalid snaplen %s (must be >= 0 and <= %d)\",\n\t\t\t\t      optarg, MAXIMUM_SNAPLEN);\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\t++ndo->ndo_Sflag;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\t++ndo->ndo_tflag;\n\t\t\tbreak;\n\n\t\tcase 'T':\n\t\t\tif (ascii_strcasecmp(optarg, \"vat\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VAT;\n\t\t\telse if (ascii_strcasecmp(optarg, \"wb\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_WB;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rpc\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RPC;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"rtcp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RTCP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"snmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_SNMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"cnfp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CNFP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"tftp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_TFTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"aodv\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_AODV;\n\t\t\telse if (ascii_strcasecmp(optarg, \"carp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_CARP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"radius\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RADIUS;\n\t\t\telse if (ascii_strcasecmp(optarg, \"zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"vxlan\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_VXLAN;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM;\n\t\t\telse if (ascii_strcasecmp(optarg, \"pgm_zmtp1\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PGM_ZMTP1;\n\t\t\telse if (ascii_strcasecmp(optarg, \"lmp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_LMP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"resp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_RESP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"ptp\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_PTP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"someip\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_SOMEIP;\n\t\t\telse if (ascii_strcasecmp(optarg, \"domain\") == 0)\n\t\t\t\tndo->ndo_packettype = PT_DOMAIN;\n\t\t\telse\n\t\t\t\terror(\"unknown packet type `%s'\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t\t++ndo->ndo_uflag;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tcase 'U':\n\t\t\t++Uflag;\n\t\t\tbreak;\n#endif\n\n\t\tcase 'v':\n\t\t\t++ndo->ndo_vflag;\n\t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tVFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tWFileName = optarg;\n\t\t\tbreak;\n\n\t\tcase 'W':\n\t\t\tWflag = atoi(optarg);\n\t\t\tif (Wflag <= 0)\n\t\t\t\terror(\"invalid number of output files %s\", optarg);\n\t\t\tWflagChars = getWflagChars(Wflag);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\t++ndo->ndo_xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\t++ndo->ndo_Xflag;\n\t\t\t++ndo->ndo_suppress_default_print;\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tyflag_dlt_name = optarg;\n\t\t\tyflag_dlt =\n\t\t\t\tpcap_datalink_name_to_val(yflag_dlt_name);\n\t\t\tif (yflag_dlt < 0)\n\t\t\t\terror(\"invalid data link type %s\", yflag_dlt_name);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_PARSER_DEBUG\n\t\tcase 'Y':\n\t\t\t{\n\t\t\t/* Undocumented flag */\n\t\t\tpcap_set_parser_debug(1);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tcase 'z':\n\t\t\tzflag = optarg;\n\t\t\tbreak;\n\n\t\tcase 'Z':\n\t\t\tusername = optarg;\n\t\t\tbreak;\n\n\t\tcase '#':\n\t\t\tndo->ndo_packet_number = 1;\n\t\t\tbreak;\n\n\t\tcase OPTION_VERSION:\n\t\t\tprint_version(stdout);\n\t\t\texit_tcpdump(S_SUCCESS);\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tcase OPTION_TSTAMP_PRECISION:\n\t\t\tndo->ndo_tstamp_precision = tstamp_precision_from_string(optarg);\n\t\t\tif (ndo->ndo_tstamp_precision < 0)\n\t\t\t\terror(\"unsupported time stamp precision\");\n\t\t\tbreak;\n#endif\n\n#ifdef HAVE_PCAP_SET_IMMEDIATE_MODE\n\t\tcase OPTION_IMMEDIATE_MODE:\n\t\t\timmediate_mode = 1;\n\t\t\tbreak;\n#endif\n\n\t\tcase OPTION_PRINT:\n\t\t\tprint = 1;\n\t\t\tbreak;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tcase OPTION_TSTAMP_MICRO:\n\t\t\tndo->ndo_tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\t\t\tbreak;\n\n\t\tcase OPTION_TSTAMP_NANO:\n\t\t\tndo->ndo_tstamp_precision = PCAP_TSTAMP_PRECISION_NANO;\n\t\t\tbreak;\n#endif\n\n\t\tcase OPTION_FP_TYPE:\n\t\t\t/*\n\t\t\t * Print out the type of floating-point arithmetic\n\t\t\t * we're doing; it's probably IEEE, unless somebody\n\t\t\t * tries to run this on a VAX, but the precision\n\t\t\t * may differ (e.g., it might be 32-bit, 64-bit,\n\t\t\t * or 80-bit).\n\t\t\t */\n\t\t\tfloat_type_check(0x4e93312d);\n\t\t\treturn 0;\n\n\t\tcase OPTION_COUNT:\n\t\t\tcount_mode = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprint_usage(stderr);\n\t\t\texit_tcpdump(S_ERR_HOST_PROGRAM);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n#ifdef HAVE_PCAP_FINDALLDEVS\n\tif (Dflag)\n\t\tshow_devices_and_exit();\n#endif\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\tif (remote_interfaces_source != NULL)\n\t\tshow_remote_devices_and_exit();\n#endif\n\n#if defined(DLT_LINUX_SLL2) && defined(HAVE_PCAP_SET_DATALINK)\n/* Set default linktype DLT_LINUX_SLL2 when capturing on the \"any\" device */\n\t\tif (device != NULL &&\n\t\t    strncmp (device, \"any\", strlen(\"any\")) == 0\n\t\t    && yflag_dlt == -1)\n\t\t\tyflag_dlt = DLT_LINUX_SLL2;\n#endif\n\n\tswitch (ndo->ndo_tflag) {\n\n\tcase 0: /* Default */\n\tcase 1: /* No time stamp */\n\tcase 2: /* Unix timeval style */\n\tcase 3: /* Microseconds/nanoseconds since previous packet */\n\tcase 4: /* Date + Default */\n\tcase 5: /* Microseconds/nanoseconds since first packet */\n\t\tbreak;\n\n\tdefault: /* Not supported */\n\t\terror(\"only -t, -tt, -ttt, -tttt and -ttttt are supported\");\n\t\tbreak;\n\t}\n\n\tif (ndo->ndo_fflag != 0 && (VFileName != NULL || RFileName != NULL))\n\t\terror(\"-f can not be used with -V or -r\");\n\n\tif (VFileName != NULL && RFileName != NULL)\n\t\terror(\"-V and -r are mutually exclusive.\");\n\n\t/*\n\t * If we're printing dissected packets to the standard output,\n\t * and either the standard output is a terminal or we're doing\n\t * \"line\" buffering, set the capture timeout to .1 second rather\n\t * than 1 second, as the user's probably expecting to see packets\n\t * pop up immediately shortly after they arrive.\n\t *\n\t * XXX - would there be some value appropriate for all cases,\n\t * based on, say, the buffer size and packet input rate?\n\t */\n\tif ((WFileName == NULL || print) && (isatty(1) || lflag))\n\t\ttimeout = 100;\n\n#ifdef WITH_CHROOT\n\t/* if run as root, prepare for chrooting */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* future extensibility for cmd-line arguments */\n\t\tif (!chroot_dir)\n\t\t\tchroot_dir = WITH_CHROOT;\n\t}\n#endif\n\n#ifdef WITH_USER\n\t/* if run as root, prepare for dropping root privileges */\n\tif (getuid() == 0 || geteuid() == 0) {\n\t\t/* Run with '-Z root' to restore old behaviour */\n\t\tif (!username)\n\t\t\tusername = WITH_USER;\n\t}\n#endif\n\n\tif (RFileName != NULL || VFileName != NULL) {\n\t\t/*\n\t\t * If RFileName is non-null, it's the pathname of a\n\t\t * savefile to read.  If VFileName is non-null, it's\n\t\t * the pathname of a file containing a list of pathnames\n\t\t * (one per line) of savefiles to read.\n\t\t *\n\t\t * In either case, we're reading a savefile, not doing\n\t\t * a live capture.\n\t\t */\n#ifndef _WIN32\n\t\t/*\n\t\t * We don't need network access, so relinquish any set-UID\n\t\t * or set-GID privileges we have (if any).\n\t\t *\n\t\t * We do *not* want set-UID privileges when opening a\n\t\t * trace file, as that might let the user read other\n\t\t * people's trace files (especially if we're set-UID\n\t\t * root).\n\t\t */\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0 )\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n\t\tif (VFileName != NULL) {\n\t\t\tif (VFileName[0] == '-' && VFileName[1] == '\\0')\n\t\t\t\tVFile = stdin;\n\t\t\telse\n\t\t\t\tVFile = fopen(VFileName, \"r\");\n\n\t\t\tif (VFile == NULL)\n\t\t\t\terror(\"Unable to open file: %s\\n\", pcap_strerror(errno));\n\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (!ret)\n\t\t\t\terror(\"Nothing in %s\\n\", VFileName);\n\t\t\tRFileName = VFileLine;\n\t\t}\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tpd = pcap_open_offline_with_tstamp_precision(RFileName,\n\t\t    ndo->ndo_tstamp_precision, ebuf);\n#else\n\t\tpd = pcap_open_offline(RFileName, ebuf);\n#endif\n\n\t\tif (pd == NULL)\n\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\tcap_rights_init(&rights, CAP_READ);\n\t\tif (cap_rights_limit(fileno(pcap_file(pd)), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n#endif\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\tfprintf(stderr, \"reading from file %s\", RFileName);\n\t\tif (dlt_name == NULL) {\n\t\t\tfprintf(stderr, \", link-type %u\", dlt);\n\t\t} else {\n\t\t\tfprintf(stderr, \", link-type %s (%s)\", dlt_name,\n\t\t\t\tpcap_datalink_val_to_description(dlt));\n\t\t}\n\t\tfprintf(stderr, \", snapshot length %d\\n\", pcap_snapshot(pd));\n#ifdef DLT_LINUX_SLL2\n\t\tif (dlt == DLT_LINUX_SLL2)\n\t\t\tfprintf(stderr, \"Warning: interface names might be incorrect\\n\");\n#endif\n\t} else if (dflag && !device) {\n\t\tint dump_dlt = DLT_EN10MB;\n\t\t/*\n\t\t * We're dumping the compiled code without an explicit\n\t\t * device specification.  (If a device is specified, we\n\t\t * definitely want to open it to use the DLT of that device.)\n\t\t * Either default to DLT_EN10MB with a warning, or use\n\t\t * the user-specified value if supplied.\n\t\t */\n\t\t/*\n\t\t * If no snapshot length was specified, or a length of 0 was\n\t\t * specified, default to 256KB.\n\t\t */\n\t\tif (ndo->ndo_snaplen == 0)\n\t\t\tndo->ndo_snaplen = MAXIMUM_SNAPLEN;\n\t\t/*\n\t\t * If a DLT was specified with the -y flag, use that instead.\n\t\t */\n\t\tif (yflag_dlt != -1)\n\t\t\tdump_dlt = yflag_dlt;\n\t\telse\n\t\t\tfprintf(stderr, \"Warning: assuming Ethernet\\n\");\n\t        pd = pcap_open_dead(dump_dlt, ndo->ndo_snaplen);\n\t} else {\n\t\t/*\n\t\t * We're doing a live capture.\n\t\t */\n\t\tif (device == NULL) {\n\t\t\t/*\n\t\t\t * No interface was specified.  Pick one.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\t/*\n\t\t\t * Find the list of interfaces, and pick\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\t\terror(\"%s\", ebuf);\n\t\t\tif (devlist == NULL)\n\t\t\t\terror(\"no interfaces available for capture\");\n\t\t\tdevice = strdup(devlist->name);\n\t\t\tpcap_freealldevs(devlist);\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * Use whatever interface pcap_lookupdev()\n\t\t\t * chooses.\n\t\t\t */\n\t\t\tdevice = pcap_lookupdev(ebuf);\n\t\t\tif (device == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Try to open the interface with the specified name.\n\t\t */\n\t\tpd = open_interface(device, ndo, ebuf);\n\t\tif (pd == NULL) {\n\t\t\t/*\n\t\t\t * That failed.  If we can get a list of\n\t\t\t * interfaces, and the interface name\n\t\t\t * is purely numeric, try to use it as\n\t\t\t * a 1-based index in the list of\n\t\t\t * interfaces.\n\t\t\t */\n#ifdef HAVE_PCAP_FINDALLDEVS\n\t\t\tdevnum = parse_interface_number(device);\n\t\t\tif (devnum == -1) {\n\t\t\t\t/*\n\t\t\t\t * It's not a number; just report\n\t\t\t\t * the open error and fail.\n\t\t\t\t */\n\t\t\t\terror(\"%s\", ebuf);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, it's a number; try to find the\n\t\t\t * interface with that index, and try\n\t\t\t * to open it.\n\t\t\t *\n\t\t\t * find_interface_by_number() exits if it\n\t\t\t * couldn't be found.\n\t\t\t */\n\t\t\tdevice = find_interface_by_number(device, devnum);\n\t\t\tpd = open_interface(device, ndo, ebuf);\n\t\t\tif (pd == NULL)\n\t\t\t\terror(\"%s\", ebuf);\n#else /* HAVE_PCAP_FINDALLDEVS */\n\t\t\t/*\n\t\t\t * We can't get a list of interfaces; just\n\t\t\t * fail.\n\t\t\t */\n\t\t\terror(\"%s\", ebuf);\n#endif /* HAVE_PCAP_FINDALLDEVS */\n\t\t}\n\n\t\t/*\n\t\t * Let user own process after capture device has\n\t\t * been opened.\n\t\t */\n#ifndef _WIN32\n\t\tif (setgid(getgid()) != 0 || setuid(getuid()) != 0)\n\t\t\tfprintf(stderr, \"Warning: setgid/setuid failed !\\n\");\n#endif /* _WIN32 */\n#if !defined(HAVE_PCAP_CREATE) && defined(_WIN32)\n\t\tif(Bflag != 0)\n\t\t\tif(pcap_setbuff(pd, Bflag)==-1){\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t}\n#endif /* !defined(HAVE_PCAP_CREATE) && defined(_WIN32) */\n\t\tif (Lflag)\n\t\t\tshow_dlts_and_exit(pd, device);\n\t\tif (yflag_dlt >= 0) {\n#ifdef HAVE_PCAP_SET_DATALINK\n\t\t\tif (pcap_set_datalink(pd, yflag_dlt) < 0)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#else\n\t\t\t/*\n\t\t\t * We don't actually support changing the\n\t\t\t * data link type, so we only let them\n\t\t\t * set it to what it already is.\n\t\t\t */\n\t\t\tif (yflag_dlt != pcap_datalink(pd)) {\n\t\t\t\terror(\"%s is not one of the DLTs supported by this device\\n\",\n\t\t\t\t      yflag_dlt_name);\n\t\t\t}\n#endif\n\t\t\t(void)fprintf(stderr, \"%s: data link type %s\\n\",\n\t\t\t\t      program_name,\n\t\t\t\t      pcap_datalink_val_to_name(yflag_dlt));\n\t\t\t(void)fflush(stderr);\n\t\t}\n\t\ti = pcap_snapshot(pd);\n\t\tif (ndo->ndo_snaplen < i) {\n\t\t\tif (ndo->ndo_snaplen != 0)\n\t\t\t\twarning(\"snaplen raised from %d to %d\", ndo->ndo_snaplen, i);\n\t\t\tndo->ndo_snaplen = i;\n\t\t} else if (ndo->ndo_snaplen > i) {\n\t\t\twarning(\"snaplen lowered from %d to %d\", ndo->ndo_snaplen, i);\n\t\t\tndo->ndo_snaplen = i;\n\t\t}\n                if(ndo->ndo_fflag != 0) {\n                        if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n                                warning(\"foreign (-f) flag used but: %s\", ebuf);\n                        }\n                }\n\n\t}\n\tif (infile)\n\t\tcmdbuf = read_infile(infile);\n\telse\n\t\tcmdbuf = copy_argv(&argv[optind]);\n\n#ifdef HAVE_PCAP_SET_OPTIMIZER_DEBUG\n\tpcap_set_optimizer_debug(dflag);\n#endif\n\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\tif (dflag) {\n\t\tbpf_dump(&fcode, dflag);\n\t\tpcap_close(pd);\n\t\tfree(cmdbuf);\n\t\tpcap_freecode(&fcode);\n\t\texit_tcpdump(S_SUCCESS);\n\t}\n\n#ifdef HAVE_CASPER\n\tif (!ndo->ndo_nflag)\n\t\tcapdns = capdns_setup();\n#endif\t/* HAVE_CASPER */\n\n\tinit_print(ndo, localnet, netmask);\n\n#ifndef _WIN32\n\t(void)setsignal(SIGPIPE, cleanup);\n\t(void)setsignal(SIGTERM, cleanup);\n#endif /* _WIN32 */\n\t(void)setsignal(SIGINT, cleanup);\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n\t(void)setsignal(SIGCHLD, child_cleanup);\n#endif\n\t/* Cooperate with nohup(1) */\n#ifndef _WIN32\n\tif ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)\n\t\t(void)setsignal(SIGHUP, oldhandler);\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\t/*\n\t * If a user name was specified with \"-Z\", attempt to switch to\n\t * that user's UID.  This would probably be used with sudo,\n\t * to allow tcpdump to be run in a special restricted\n\t * account (if you just want to allow users to open capture\n\t * devices, and can't just give users that permission,\n\t * you'd make tcpdump set-UID or set-GID).\n\t *\n\t * Tcpdump doesn't necessarily write only to one savefile;\n\t * the general only way to allow a -Z instance to write to\n\t * savefiles as the user under whose UID it's run, rather\n\t * than as the user specified with -Z, would thus be to switch\n\t * to the original user ID before opening a capture file and\n\t * then switch back to the -Z user ID after opening the savefile.\n\t * Switching to the -Z user ID only after opening the first\n\t * savefile doesn't handle the general case.\n\t */\n\n\tif (getuid() == 0 || geteuid() == 0) {\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Initialize capng */\n\t\tcapng_clear(CAPNG_SELECT_BOTH);\n\t\tif (username) {\nDIAG_OFF_ASSIGN_ENUM\n\t\t\tcapng_updatev(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SETUID,\n\t\t\t\tCAP_SETGID,\n\t\t\t\t-1);\nDIAG_ON_ASSIGN_ENUM\n\t\t}\n\t\tif (chroot_dir) {\nDIAG_OFF_ASSIGN_ENUM\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_SYS_CHROOT\n\t\t\t\t);\nDIAG_ON_ASSIGN_ENUM\n\t\t}\n\n\t\tif (WFileName) {\nDIAG_OFF_ASSIGN_ENUM\n\t\t\tcapng_update(\n\t\t\t\tCAPNG_ADD,\n\t\t\t\tCAPNG_PERMITTED | CAPNG_EFFECTIVE,\n\t\t\t\tCAP_DAC_OVERRIDE\n\t\t\t\t);\nDIAG_ON_ASSIGN_ENUM\n\t\t}\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (username || chroot_dir)\n\t\t\tdroproot(username, chroot_dir);\n\n\t}\n#endif /* _WIN32 */\n\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\tif (RFileName == NULL && VFileName == NULL && pcap_fileno(pd) != -1) {\n\t\tstatic const unsigned long cmds[] = { BIOCGSTATS, BIOCROTZBUF };\n\n\t\t/*\n\t\t * The various libpcap devices use a combination of\n\t\t * read (bpf), ioctl (bpf, netmap), poll (netmap)\n\t\t * so we add the relevant access rights.\n\t\t */\n\t\tcap_rights_init(&rights, CAP_IOCTL, CAP_READ, CAP_EVENT);\n\t\tif (cap_rights_limit(pcap_fileno(pd), &rights) < 0 &&\n\t\t    errno != ENOSYS) {\n\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t}\n\t\tif (cap_ioctls_limit(pcap_fileno(pd), cmds,\n\t\t    sizeof(cmds) / sizeof(cmds[0])) < 0 && errno != ENOSYS) {\n\t\t\terror(\"unable to limit ioctls on pcap descriptor\");\n\t\t}\n\t}\n#endif\n\tif (WFileName) {\n\t\t/* Do not exceed the default PATH_MAX for files. */\n\t\tdumpinfo.CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\n\t\tif (dumpinfo.CurrentFileName == NULL)\n\t\t\terror(\"malloc of dumpinfo.CurrentFileName\");\n\n\t\t/* We do not need numbering for dumpfiles if Cflag isn't set. */\n\t\tif (Cflag != 0)\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, WflagChars);\n\t\telse\n\t\t  MakeFilename(dumpinfo.CurrentFileName, WFileName, 0, 0);\n\n\t\tpdd = pcap_dump_open(pd, dumpinfo.CurrentFileName);\n#ifdef HAVE_LIBCAP_NG\n\t\t/* Give up CAP_DAC_OVERRIDE capability.\n\t\t * Only allow it to be restored if the -C or -G flag have been\n\t\t * set since we may need to create more files later on.\n\t\t */\n\t\tcapng_update(\n\t\t\tCAPNG_DROP,\n\t\t\t(Cflag || Gflag ? 0 : CAPNG_PERMITTED)\n\t\t\t\t| CAPNG_EFFECTIVE,\n\t\t\tCAP_DAC_OVERRIDE\n\t\t\t);\n\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\tif (pdd == NULL)\n\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\tset_dumper_capsicum_rights(pdd);\n#endif\n\t\tif (Cflag != 0 || Gflag != 0) {\n#ifdef HAVE_CAPSICUM\n\t\t\t/*\n\t\t\t * basename() and dirname() may modify their input buffer\n\t\t\t * and they do since FreeBSD 12.0, but they didn't before.\n\t\t\t * Hence use the return value only, but always assume the\n\t\t\t * input buffer has been modified and would need to be\n\t\t\t * reset before the next use.\n\t\t\t */\n\t\t\tchar *WFileName_copy;\n\n\t\t\tif ((WFileName_copy = strdup(WFileName)) == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tDIAG_OFF_C11_EXTENSIONS\n\t\t\tdumpinfo.WFileName = strdup(basename(WFileName_copy));\n\t\t\tDIAG_ON_C11_EXTENSIONS\n\t\t\tif (dumpinfo.WFileName == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tfree(WFileName_copy);\n\n\t\t\tif ((WFileName_copy = strdup(WFileName)) == NULL) {\n\t\t\t\terror(\"Unable to allocate memory for file %s\",\n\t\t\t\t    WFileName);\n\t\t\t}\n\t\t\tDIAG_OFF_C11_EXTENSIONS\n\t\t\tchar *WFileName_dirname = dirname(WFileName_copy);\n\t\t\tDIAG_ON_C11_EXTENSIONS\n\t\t\tdumpinfo.dirfd = open(WFileName_dirname,\n\t\t\t    O_DIRECTORY | O_RDONLY);\n\t\t\tif (dumpinfo.dirfd < 0) {\n\t\t\t\terror(\"unable to open directory %s\",\n\t\t\t\t    WFileName_dirname);\n\t\t\t}\n\t\t\tfree(WFileName_dirname);\n\t\t\tfree(WFileName_copy);\n\n\t\t\tcap_rights_init(&rights, CAP_CREATE, CAP_FCNTL,\n\t\t\t    CAP_FTRUNCATE, CAP_LOOKUP, CAP_SEEK, CAP_WRITE);\n\t\t\tif (cap_rights_limit(dumpinfo.dirfd, &rights) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit directory rights\");\n\t\t\t}\n\t\t\tif (cap_fcntls_limit(dumpinfo.dirfd, CAP_FCNTL_GETFL) < 0 &&\n\t\t\t    errno != ENOSYS) {\n\t\t\t\terror(\"unable to limit dump descriptor fcntls\");\n\t\t\t}\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdumpinfo.WFileName = WFileName;\n#endif\n\t\t\tcallback = dump_packet_and_trunc;\n\t\t\tdumpinfo.pd = pd;\n\t\t\tdumpinfo.pdd = pdd;\n\t\t\tpcap_userdata = (u_char *)&dumpinfo;\n\t\t} else {\n\t\t\tcallback = dump_packet;\n\t\t\tdumpinfo.WFileName = WFileName;\n\t\t\tdumpinfo.pd = pd;\n\t\t\tdumpinfo.pdd = pdd;\n\t\t\tpcap_userdata = (u_char *)&dumpinfo;\n\t\t}\n\t\tif (print) {\n\t\t\tdlt = pcap_datalink(pd);\n\t\t\tndo->ndo_if_printer = get_if_printer(dlt);\n\t\t\tdumpinfo.ndo = ndo;\n\t\t} else\n\t\t\tdumpinfo.ndo = NULL;\n\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\t\tif (Uflag)\n\t\t\tpcap_dump_flush(pdd);\n#endif\n\t} else {\n\t\tdlt = pcap_datalink(pd);\n\t\tndo->ndo_if_printer = get_if_printer(dlt);\n\t\tcallback = print_packet;\n\t\tpcap_userdata = (u_char *)ndo;\n\t}\n\n#ifdef SIGNAL_REQ_INFO\n\t/*\n\t * We can't get statistics when reading from a file rather\n\t * than capturing from a device.\n\t */\n\tif (RFileName == NULL)\n\t\t(void)setsignal(SIGNAL_REQ_INFO, requestinfo);\n#endif\n#ifdef SIGNAL_FLUSH_PCAP\n\t(void)setsignal(SIGNAL_FLUSH_PCAP, flushpcap);\n#endif\n\n\tif (ndo->ndo_vflag > 0 && WFileName && RFileName == NULL && !print) {\n\t\t/*\n\t\t * When capturing to a file, if \"--print\" wasn't specified,\n\t\t *\"-v\" means tcpdump should, once per second,\n\t\t * \"v\"erbosely report the number of packets captured.\n\t\t * Except when reading from a file, because -r, -w and -v\n\t\t * together used to make a corner case, in which pcap_loop()\n\t\t * errored due to EINTR (see GH #155 for details).\n\t\t */\n#ifdef _WIN32\n\t\t/*\n\t\t * https://blogs.msdn.microsoft.com/oldnewthing/20151230-00/?p=92741\n\t\t *\n\t\t * suggests that this dates back to W2K.\n\t\t *\n\t\t * I don't know what a \"long wait\" is, but we'll assume\n\t\t * that printing the stats could be a \"long wait\".\n\t\t */\n\t\tCreateTimerQueueTimer(&timer_handle, NULL,\n\t\t    verbose_stats_dump, NULL, 1000, 1000,\n\t\t    WT_EXECUTEDEFAULT|WT_EXECUTELONGFUNCTION);\n\t\tsetvbuf(stderr, NULL, _IONBF, 0);\n#else /* _WIN32 */\n\t\t/*\n\t\t * Assume this is UN*X, and that it has setitimer(); that\n\t\t * dates back to UNIX 95.\n\t\t */\n\t\tstruct itimerval timer;\n\t\t(void)setsignal(SIGALRM, verbose_stats_dump);\n\t\ttimer.it_interval.tv_sec = 1;\n\t\ttimer.it_interval.tv_usec = 0;\n\t\ttimer.it_value.tv_sec = 1;\n\t\ttimer.it_value.tv_usec = 1;\n\t\tsetitimer(ITIMER_REAL, &timer, NULL);\n#endif /* _WIN32 */\n\t}\n\n\tif (RFileName == NULL) {\n\t\t/*\n\t\t * Live capture (if -V was specified, we set RFileName\n\t\t * to a file from the -V file).  Print a message to\n\t\t * the standard error on UN*X.\n\t\t */\n\t\tif (!ndo->ndo_vflag && !WFileName) {\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"%s: verbose output suppressed, use -v[v]... for full protocol decode\\n\",\n\t\t\t    program_name);\n\t\t} else\n\t\t\t(void)fprintf(stderr, \"%s: \", program_name);\n\t\tdlt = pcap_datalink(pd);\n\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\t(void)fprintf(stderr, \"listening on %s\", device);\n\t\tif (dlt_name == NULL) {\n\t\t\t(void)fprintf(stderr, \", link-type %u\", dlt);\n\t\t} else {\n\t\t\t(void)fprintf(stderr, \", link-type %s (%s)\", dlt_name,\n\t\t\t\t      pcap_datalink_val_to_description(dlt));\n\t\t}\n\t\t(void)fprintf(stderr, \", snapshot length %d bytes\\n\", ndo->ndo_snaplen);\n\t\t(void)fflush(stderr);\n\t}\n\n#ifdef HAVE_CAPSICUM\n\tcansandbox = (VFileName == NULL && zflag == NULL);\n#ifdef HAVE_CASPER\n\tcansandbox = (cansandbox && (ndo->ndo_nflag || capdns != NULL));\n#else\n\tcansandbox = (cansandbox && ndo->ndo_nflag);\n#endif /* HAVE_CASPER */\n\tif (cansandbox && cap_enter() < 0 && errno != ENOSYS)\n\t\terror(\"unable to enter the capability mode\");\n#endif\t/* HAVE_CAPSICUM */\n\n\tdo {\n\t\tstatus = pcap_loop(pd, cnt, callback, pcap_userdata);\n\t\tif (WFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're printing packets.  Flush the printed output,\n\t\t\t * so it doesn't get intermingled with error output.\n\t\t\t */\n\t\t\tif (status == -2) {\n\t\t\t\t/*\n\t\t\t\t * We got interrupted, so perhaps we didn't\n\t\t\t\t * manage to finish a line we were printing.\n\t\t\t\t * Print an extra newline, just in case.\n\t\t\t\t */\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t\t(void)fflush(stdout);\n\t\t}\n                if (status == -2) {\n\t\t\t/*\n\t\t\t * We got interrupted. If we are reading multiple\n\t\t\t * files (via -V) set these so that we stop.\n\t\t\t */\n\t\t\tVFileName = NULL;\n\t\t\tret = NULL;\n\t\t}\n\t\tif (status == -1) {\n\t\t\t/*\n\t\t\t * Error.  Report it.\n\t\t\t */\n\t\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t\t    program_name, pcap_geterr(pd));\n\t\t}\n\t\tif (RFileName == NULL) {\n\t\t\t/*\n\t\t\t * We're doing a live capture.  Report the capture\n\t\t\t * statistics.\n\t\t\t */\n\t\t\tinfo(1);\n\t\t}\n\t\tpcap_close(pd);\n\t\tif (VFileName != NULL) {\n\t\t\tret = get_next_file(VFile, VFileLine);\n\t\t\tif (ret) {\n\t\t\t\tint new_dlt;\n\n\t\t\t\tRFileName = VFileLine;\n\t\t\t\tpd = pcap_open_offline(RFileName, ebuf);\n\t\t\t\tif (pd == NULL)\n\t\t\t\t\terror(\"%s\", ebuf);\n#ifdef HAVE_CAPSICUM\n\t\t\t\tcap_rights_init(&rights, CAP_READ);\n\t\t\t\tif (cap_rights_limit(fileno(pcap_file(pd)),\n\t\t\t\t    &rights) < 0 && errno != ENOSYS) {\n\t\t\t\t\terror(\"unable to limit pcap descriptor\");\n\t\t\t\t}\n#endif\n\t\t\t\tnew_dlt = pcap_datalink(pd);\n\t\t\t\tif (new_dlt != dlt) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The new file has a different\n\t\t\t\t\t * link-layer header type from the\n\t\t\t\t\t * previous one.\n\t\t\t\t\t */\n\t\t\t\t\tif (WFileName != NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We're writing raw packets\n\t\t\t\t\t\t * that match the filter to\n\t\t\t\t\t\t * a pcap file.  pcap files\n\t\t\t\t\t\t * don't support multiple\n\t\t\t\t\t\t * different link-layer\n\t\t\t\t\t\t * header types, so we fail\n\t\t\t\t\t\t * here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\terror(\"%s: new dlt does not match original\", RFileName);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We're printing the decoded packets;\n\t\t\t\t\t * switch to the new DLT.\n\t\t\t\t\t *\n\t\t\t\t\t * To do that, we need to change\n\t\t\t\t\t * the printer, change the DLT name,\n\t\t\t\t\t * and recompile the filter with\n\t\t\t\t\t * the new DLT.\n\t\t\t\t\t */\n\t\t\t\t\tdlt = new_dlt;\n\t\t\t\t\tndo->ndo_if_printer = get_if_printer(dlt);\n\t\t\t\t\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Set the filter on the new file.\n\t\t\t\t */\n\t\t\t\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\t\t\t\terror(\"%s\", pcap_geterr(pd));\n\n\t\t\t\t/*\n\t\t\t\t * Report the new file.\n\t\t\t\t */\n\t\t\t\tdlt_name = pcap_datalink_val_to_name(dlt);\n\t\t\t\tfprintf(stderr, \"reading from file %s\", RFileName);\n\t\t\t\tif (dlt_name == NULL) {\n\t\t\t\t\tfprintf(stderr, \", link-type %u\", dlt);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \", link-type %s (%s)\",\n\t\t\t\t\t\tdlt_name,\n\t\t\t\t\t\tpcap_datalink_val_to_description(dlt));\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \", snapshot length %d\\n\", pcap_snapshot(pd));\n\t\t\t}\n\t\t}\n\t}\n\twhile (ret != NULL);\n\n\tif (count_mode && RFileName != NULL)\n\t\tfprintf(stdout, \"%u packet%s\\n\", packets_captured,\n\t\t\tPLURAL_SUFFIX(packets_captured));\n\n\tfree(cmdbuf);\n\tpcap_freecode(&fcode);\n\texit_tcpdump(status == -1 ? S_ERR_HOST_PROGRAM : S_SUCCESS);\n}\n\n/*\n * Catch a signal.\n */\nstatic void\n(*setsignal (int sig, void (*func)(int)))(int)\n{\n#ifdef _WIN32\n\treturn (signal(sig, func));\n#else\n\tstruct sigaction old, new;\n\n\tmemset(&new, 0, sizeof(new));\n\tnew.sa_handler = func;\n\tif ((sig == SIGCHLD)\n# ifdef SIGNAL_REQ_INFO\n\t\t|| (sig == SIGNAL_REQ_INFO)\n# endif\n# ifdef SIGNAL_FLUSH_PCAP\n\t\t|| (sig == SIGNAL_FLUSH_PCAP)\n# endif\n\t\t)\n\t\tnew.sa_flags = SA_RESTART;\n\tif (sigaction(sig, &new, &old) < 0)\n\t\treturn (SIG_ERR);\n\treturn (old.sa_handler);\n#endif\n}\n\n/* make a clean exit on interrupts */\nstatic void\ncleanup(int signo _U_)\n{\n#ifdef _WIN32\n\tif (timer_handle != INVALID_HANDLE_VALUE) {\n\t\tDeleteTimerQueueTimer(NULL, timer_handle, NULL);\n\t\tCloseHandle(timer_handle);\n\t\ttimer_handle = INVALID_HANDLE_VALUE;\n        }\n#else /* _WIN32 */\n\tstruct itimerval timer;\n\n\ttimer.it_interval.tv_sec = 0;\n\ttimer.it_interval.tv_usec = 0;\n\ttimer.it_value.tv_sec = 0;\n\ttimer.it_value.tv_usec = 0;\n\tsetitimer(ITIMER_REAL, &timer, NULL);\n#endif /* _WIN32 */\n\n#ifdef HAVE_PCAP_BREAKLOOP\n\t/*\n\t * We have \"pcap_breakloop()\"; use it, so that we do as little\n\t * as possible in the signal handler (it's probably not safe\n\t * to do anything with standard I/O streams in a signal handler -\n\t * the ANSI C standard doesn't say it is).\n\t */\n\tpcap_breakloop(pd);\n#else\n\t/*\n\t * We don't have \"pcap_breakloop()\"; this isn't safe, but\n\t * it's the best we can do.  Print the summary if we're\n\t * not reading from a savefile - i.e., if we're doing a\n\t * live capture - and exit.\n\t */\n\tif (pd != NULL && pcap_file(pd) == NULL) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t\t(void)fflush(stdout);\n\t\tinfo(1);\n\t}\n\texit_tcpdump(S_SUCCESS);\n#endif\n}\n\n/*\n  On windows, we do not use a fork, so we do not care less about\n  waiting a child processes to die\n */\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\nstatic void\nchild_cleanup(int signo _U_)\n{\n  wait(NULL);\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ninfo(int verbose)\n{\n\tstruct pcap_stat stats;\n\n\t/*\n\t * Older versions of libpcap didn't set ps_ifdrop on some\n\t * platforms; initialize it to 0 to handle that.\n\t */\n\tstats.ps_ifdrop = 0;\n\tif (pcap_stats(pd, &stats) < 0) {\n\t\t(void)fprintf(stderr, \"pcap_stats: %s\\n\", pcap_geterr(pd));\n\t\tinfoprint = 0;\n\t\treturn;\n\t}\n\n\tif (!verbose)\n\t\tfprintf(stderr, \"%s: \", program_name);\n\n\t(void)fprintf(stderr, \"%u packet%s captured\", packets_captured,\n\t    PLURAL_SUFFIX(packets_captured));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s received by filter\", stats.ps_recv,\n\t    PLURAL_SUFFIX(stats.ps_recv));\n\tif (!verbose)\n\t\tfputs(\", \", stderr);\n\telse\n\t\tputc('\\n', stderr);\n\t(void)fprintf(stderr, \"%u packet%s dropped by kernel\", stats.ps_drop,\n\t    PLURAL_SUFFIX(stats.ps_drop));\n\tif (stats.ps_ifdrop != 0) {\n\t\tif (!verbose)\n\t\t\tfputs(\", \", stderr);\n\t\telse\n\t\t\tputc('\\n', stderr);\n\t\t(void)fprintf(stderr, \"%u packet%s dropped by interface\\n\",\n\t\t    stats.ps_ifdrop, PLURAL_SUFFIX(stats.ps_ifdrop));\n\t} else\n\t\tputc('\\n', stderr);\n\tinfoprint = 0;\n}\n\n#if defined(HAVE_FORK) || defined(HAVE_VFORK)\n#ifdef HAVE_FORK\n#define fork_subprocess() fork()\n#else\n#define fork_subprocess() vfork()\n#endif\nstatic void\ncompress_savefile(const char *filename)\n{\n\tpid_t child;\n\n\tchild = fork_subprocess();\n\tif (child == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: fork failed: %s\\n\",\n\t\t\tpcap_strerror(errno));\n\t\treturn;\n\t}\n\tif (child != 0) {\n\t\t/* Parent process. */\n\t\treturn;\n\t}\n\n\t/*\n\t * Child process.\n\t * Set to lowest priority so that this doesn't disturb the capture.\n\t */\n#ifdef NZERO\n\tsetpriority(PRIO_PROCESS, 0, NZERO - 1);\n#else\n\tsetpriority(PRIO_PROCESS, 0, 19);\n#endif\n\tif (execlp(zflag, zflag, filename, (char *)NULL) == -1)\n\t\tfprintf(stderr,\n\t\t\t\"compress_savefile: execlp(%s, %s) failed: %s\\n\",\n\t\t\tzflag,\n\t\t\tfilename,\n\t\t\tpcap_strerror(errno));\n#ifdef HAVE_FORK\n\texit(S_ERR_HOST_PROGRAM);\n#else\n\t_exit(S_ERR_HOST_PROGRAM);\n#endif\n}\n#else  /* HAVE_FORK && HAVE_VFORK */\nstatic void\ncompress_savefile(const char *filename)\n{\n\tfprintf(stderr,\n\t\t\"compress_savefile failed. Functionality not implemented under your system\\n\");\n}\n#endif /* HAVE_FORK && HAVE_VFORK */\n\nstatic void\ndump_packet_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\t/*\n\t * XXX - this won't force the file to rotate on the specified time\n\t * boundary, but it will rotate on the first packet received after the\n\t * specified Gflag number of seconds. Note: if a Gflag time boundary\n\t * and a Cflag size boundary coincide, the time rotation will occur\n\t * first thereby cancelling the Cflag boundary (since the file should\n\t * be 0).\n\t */\n\tif (Gflag != 0) {\n\t\t/* Check if it is time to rotate */\n\t\ttime_t t;\n\n\t\t/* Get the current time */\n\t\tif ((t = time(NULL)) == (time_t)-1) {\n\t\t\terror(\"%s: can't get current_time: %s\",\n\t\t\t    __func__, pcap_strerror(errno));\n\t\t}\n\n\n\t\t/* If the time is greater than the specified window, rotate */\n\t\tif (t - Gflag_time >= Gflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/* Update the Gflag_time */\n\t\t\tGflag_time = t;\n\t\t\t/* Update Gflag_count */\n\t\t\tGflag_count++;\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->pdd);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user asked for it\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\t/*\n\t\t\t * Check to see if we've exceeded the Wflag (when\n\t\t\t * not using Cflag).\n\t\t\t */\n\t\t\tif (Cflag == 0 && Wflag > 0 && Gflag_count >= Wflag) {\n\t\t\t\t(void)fprintf(stderr, \"Maximum file limit reached: %d\\n\",\n\t\t\t\t    Wflag);\n\t\t\t\tinfo(1);\n\t\t\t\texit_tcpdump(S_SUCCESS);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\t/* Allocate space for max filename + \\0. */\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"dump_packet_and_trunc: malloc\");\n\t\t\t/*\n\t\t\t * Gflag was set otherwise we wouldn't be here. Reset the count\n\t\t\t * so multiple files would end with 1,2,3 in the filename.\n\t\t\t * The counting is handled with the -C flow after this.\n\t\t\t */\n\t\t\tCflag_count = 0;\n\n\t\t\t/*\n\t\t\t * This is always the first file in the Cflag\n\t\t\t * rotation: e.g. 0\n\t\t\t * We also don't need numbering if Cflag is not set.\n\t\t\t */\n\t\t\tif (Cflag != 0)\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0,\n\t\t\t\t    WflagChars);\n\t\t\telse\n\t\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, 0, 0);\n\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd,\n\t\t\t    dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->pdd = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->pdd = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->pdd == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->pdd);\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * XXX - this won't prevent capture files from getting\n\t * larger than Cflag - the last packet written to the\n\t * file could put it over Cflag.\n\t */\n\tif (Cflag != 0) {\n#ifdef HAVE_PCAP_DUMP_FTELL64\n\t\tint64_t size = pcap_dump_ftell64(dump_info->pdd);\n#else\n\t\t/*\n\t\t * XXX - this only handles a Cflag value > 2^31-1 on\n\t\t * LP64 platforms; to handle ILP32 (32-bit UN*X and\n\t\t * Windows) or LLP64 (64-bit Windows) would require\n\t\t * a version of libpcap with pcap_dump_ftell64().\n\t\t */\n\t\tlong size = pcap_dump_ftell(dump_info->pdd);\n#endif\n\n\t\tif (size == -1)\n\t\t\terror(\"ftell fails on output file\");\n\t\tif (size > Cflag) {\n#ifdef HAVE_CAPSICUM\n\t\t\tFILE *fp;\n\t\t\tint fd;\n#endif\n\n\t\t\t/*\n\t\t\t * Close the current file and open a new one.\n\t\t\t */\n\t\t\tpcap_dump_close(dump_info->pdd);\n\n\t\t\t/*\n\t\t\t * Compress the file we just closed, if the user\n\t\t\t * asked for it.\n\t\t\t */\n\t\t\tif (zflag != NULL)\n\t\t\t\tcompress_savefile(dump_info->CurrentFileName);\n\n\t\t\tCflag_count++;\n\t\t\tif (Wflag > 0) {\n\t\t\t\tif (Cflag_count >= Wflag)\n\t\t\t\t\tCflag_count = 0;\n\t\t\t}\n\t\t\tif (dump_info->CurrentFileName != NULL)\n\t\t\t\tfree(dump_info->CurrentFileName);\n\t\t\tdump_info->CurrentFileName = (char *)malloc(PATH_MAX + 1);\n\t\t\tif (dump_info->CurrentFileName == NULL)\n\t\t\t\terror(\"%s: malloc\", __func__);\n\t\t\tMakeFilename(dump_info->CurrentFileName, dump_info->WFileName, Cflag_count, WflagChars);\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_ADD, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n#ifdef HAVE_CAPSICUM\n\t\t\tfd = openat(dump_info->dirfd, dump_info->CurrentFileName,\n\t\t\t    O_CREAT | O_WRONLY | O_TRUNC, 0644);\n\t\t\tif (fd < 0) {\n\t\t\t\terror(\"unable to open file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (fp == NULL) {\n\t\t\t\terror(\"unable to fdopen file %s\",\n\t\t\t\t    dump_info->CurrentFileName);\n\t\t\t}\n\t\t\tdump_info->pdd = pcap_dump_fopen(dump_info->pd, fp);\n#else\t/* !HAVE_CAPSICUM */\n\t\t\tdump_info->pdd = pcap_dump_open(dump_info->pd, dump_info->CurrentFileName);\n#endif\n#ifdef HAVE_LIBCAP_NG\n\t\t\tcapng_update(CAPNG_DROP, CAPNG_EFFECTIVE, CAP_DAC_OVERRIDE);\n\t\t\tcapng_apply(CAPNG_SELECT_BOTH);\n#endif /* HAVE_LIBCAP_NG */\n\t\t\tif (dump_info->pdd == NULL)\n\t\t\t\terror(\"%s\", pcap_geterr(pd));\n#ifdef HAVE_CAPSICUM\n\t\t\tset_dumper_capsicum_rights(dump_info->pdd);\n#endif\n\t\t}\n\t}\n\n\tpcap_dump((u_char *)dump_info->pdd, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->pdd);\n#endif\n\n\tif (dump_info->ndo != NULL)\n\t\tpretty_print_packet(dump_info->ndo, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\ndump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tstruct dump_info *dump_info;\n\n\t++packets_captured;\n\n\t++infodelay;\n\n\tdump_info = (struct dump_info *)user;\n\n\tpcap_dump((u_char *)dump_info->pdd, h, sp);\n#ifdef HAVE_PCAP_DUMP_FLUSH\n\tif (Uflag)\n\t\tpcap_dump_flush(dump_info->pdd);\n#endif\n\n\tif (dump_info->ndo != NULL)\n\t\tpretty_print_packet(dump_info->ndo, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\nstatic void\nprint_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\t++packets_captured;\n\n\t++infodelay;\n\n\tif (!count_mode)\n\t\tpretty_print_packet((netdissect_options *)user, h, sp, packets_captured);\n\n\t--infodelay;\n\tif (infoprint)\n\t\tinfo(0);\n}\n\n#ifdef SIGNAL_REQ_INFO\nstatic void\nrequestinfo(int signo _U_)\n{\n\tif (infodelay)\n\t\t++infoprint;\n\telse\n\t\tinfo(0);\n}\n#endif\n\n#ifdef SIGNAL_FLUSH_PCAP\nstatic void\nflushpcap(int signo _U_)\n{\n\tif (pdd != NULL)\n\t\tpcap_dump_flush(pdd);\n}\n#endif\n\nstatic void\nprint_packets_captured (void)\n{\n\tstatic u_int prev_packets_captured, first = 1;\n\n\tif (infodelay == 0 && (first || packets_captured != prev_packets_captured)) {\n\t\tfprintf(stderr, \"Got %u\\r\", packets_captured);\n\t\tfirst = 0;\n\t\tprev_packets_captured = packets_captured;\n\t}\n}\n\n/*\n * Called once each second in verbose mode while dumping to file\n */\n#ifdef _WIN32\nstatic void CALLBACK verbose_stats_dump(PVOID param _U_,\n    BOOLEAN timer_fired _U_)\n{\n\tprint_packets_captured();\n}\n#else /* _WIN32 */\nstatic void verbose_stats_dump(int sig _U_)\n{\n\tprint_packets_captured();\n}\n#endif /* _WIN32 */\n\nDIAG_OFF_DEPRECATION\nstatic void\nprint_version(FILE *f)\n{\n#ifndef HAVE_PCAP_LIB_VERSION\n  #ifdef HAVE_PCAP_VERSION\n\textern char pcap_version[];\n  #else /* HAVE_PCAP_VERSION */\n\tstatic char pcap_version[] = \"unknown\";\n  #endif /* HAVE_PCAP_VERSION */\n#endif /* HAVE_PCAP_LIB_VERSION */\n\tconst char *smi_version_string;\n\n\t(void)fprintf(f, \"%s version \" PACKAGE_VERSION \"\\n\", program_name);\n#ifdef HAVE_PCAP_LIB_VERSION\n\t(void)fprintf(f, \"%s\\n\", pcap_lib_version());\n#else /* HAVE_PCAP_LIB_VERSION */\n\t(void)fprintf(f, \"libpcap version %s\\n\", pcap_version);\n#endif /* HAVE_PCAP_LIB_VERSION */\n\n#if defined(HAVE_LIBCRYPTO) && defined(SSLEAY_VERSION)\n\t(void)fprintf (f, \"%s\\n\", SSLeay_version(SSLEAY_VERSION));\n#endif\n\n\tsmi_version_string = nd_smi_version_string();\n\tif (smi_version_string != NULL)\n\t\t(void)fprintf (f, \"SMI-library: %s\\n\", smi_version_string);\n\n#if defined(__SANITIZE_ADDRESS__)\n\t(void)fprintf (f, \"Compiled with AddressSanitizer/GCC.\\n\");\n#elif defined(__has_feature)\n#  if __has_feature(address_sanitizer)\n\t(void)fprintf (f, \"Compiled with AddressSanitizer/Clang.\\n\");\n#  elif __has_feature(memory_sanitizer)\n\t(void)fprintf (f, \"Compiled with MemorySanitizer/Clang.\\n\");\n#  endif\n#endif /* __SANITIZE_ADDRESS__ or __has_feature */\n}\nDIAG_ON_DEPRECATION\n\nstatic void\nprint_usage(FILE *f)\n{\n\tprint_version(f);\n\t(void)fprintf(f,\n\"Usage: %s [-Abd\" D_FLAG \"efhH\" I_FLAG J_FLAG \"KlLnNOpqStu\" U_FLAG \"vxX#]\" B_FLAG_USAGE \" [ -c count ] [--count]\\n\", program_name);\n\t(void)fprintf(f,\n\"\\t\\t[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\\n\");\n\t(void)fprintf(f,\n\"\\t\\t[ -i interface ]\" IMMEDIATE_MODE_USAGE j_FLAG_USAGE \"\\n\");\n#ifdef HAVE_PCAP_FINDALLDEVS_EX\n\t(void)fprintf(f,\n\"\\t\\t\" LIST_REMOTE_INTERFACES_USAGE \"\\n\");\n#endif\n#ifdef USE_LIBSMI\n\t(void)fprintf(f,\n\"\\t\\t\" m_FLAG_USAGE \"\\n\");\n#endif\n\t(void)fprintf(f,\n\"\\t\\t[ -M secret ] [ --number ] [ --print ]\" Q_FLAG_USAGE \"\\n\");\n\t(void)fprintf(f,\n\"\\t\\t[ -r file ] [ -s snaplen ] [ -T type ] [ --version ]\\n\");\n\t(void)fprintf(f,\n\"\\t\\t[ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]\\n\");\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t(void)fprintf(f,\n\"\\t\\t[ --time-stamp-precision precision ] [ --micro ] [ --nano ]\\n\");\n#endif\n\t(void)fprintf(f,\n\"\\t\\t[ -z postrotate-command ] [ -Z user ] [ expression ]\\n\");\n}\n", "/*\n * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/*\n * txtproto_print() derived from original code by Hannes Gredler\n * (hannes@gredler.at):\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code\n * distributions retain the above copyright notice and this paragraph\n * in its entirety, and (2) distributions including binary code include\n * the above copyright notice and this paragraph in its entirety in\n * the documentation or other materials provided with the distribution.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND\n * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\n * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"netdissect-stdinc.h\"\n\n#include <sys/stat.h>\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"netdissect-ctype.h\"\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"ascii_strcasecmp.h\"\n#include \"timeval-operations.h\"\n\n#define TOKBUFSIZE 128\n\nenum date_flag { WITHOUT_DATE = 0, WITH_DATE = 1 };\nenum time_flag { UTC_TIME = 0, LOCAL_TIME = 1 };\n\n/*\n * Print out a character, filtering out the non-printable ones\n */\nvoid\nfn_print_char(netdissect_options *ndo, u_char c)\n{\n\tif (!ND_ISASCII(c)) {\n\t\tc = ND_TOASCII(c);\n\t\tND_PRINT(\"M-\");\n\t}\n\tif (!ND_ASCII_ISPRINT(c)) {\n\t\tc ^= 0x40;\t/* DEL to ?, others to alpha */\n\t\tND_PRINT(\"^\");\n\t}\n\tND_PRINT(\"%c\", c);\n}\n\n/*\n * Print a null-terminated string, filtering out non-printable characters.\n * DON'T USE IT with a pointer on the packet buffer because there is no\n * truncation check. For this use, see the nd_printX() functions below.\n */\nvoid\nfn_print_str(netdissect_options *ndo, const u_char *s)\n{\n\twhile (*s != '\\0') {\n\t\tfn_print_char(ndo, *s);\n\t\ts++;\n       }\n}\n\n/*\n * Print out a null-terminated filename (or other ASCII string) from\n * a fixed-length field in the packet buffer, or from what remains of\n * the packet.\n *\n * n is the length of the fixed-length field, or the number of bytes\n * remaining in the packet based on its on-the-network length.\n *\n * If ep is non-null, it should point just past the last captured byte\n * of the packet, e.g. ndo->ndo_snapend.  If ep is NULL, we assume no\n * truncation check, other than the checks of the field length/remaining\n * packet data length, is needed.\n *\n * Return the number of bytes of string processed, including the\n * terminating null, if not truncated; as the terminating null is\n * included in the count, and as there must be a terminating null,\n * this will always be non-zero.  Return 0 if truncated.\n */\nu_int\nnd_printztn(netdissect_options *ndo,\n         const u_char *s, u_int n, const u_char *ep)\n{\n\tu_int bytes;\n\tu_char c;\n\n\tbytes = 0;\n\tfor (;;) {\n\t\tif (n == 0 || (ep != NULL && s >= ep)) {\n\t\t\t/*\n\t\t\t * Truncated.  This includes \"no null before we\n\t\t\t * got to the end of the fixed-length buffer or\n\t\t\t * the end of the packet\".\n\t\t\t *\n\t\t\t * XXX - BOOTP says \"null-terminated\", which\n\t\t\t * means the maximum length of the string, in\n\t\t\t * bytes, is 1 less than the size of the buffer,\n\t\t\t * as there must always be a terminating null.\n\t\t\t */\n\t\t\tbytes = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tbytes++;\n\t\tn--;\n\t\tif (c == '\\0') {\n\t\t\t/* End of string */\n\t\t\tbreak;\n\t\t}\n\t\tfn_print_char(ndo, c);\n\t}\n\treturn(bytes);\n}\n\n/*\n * Print out a counted filename (or other ASCII string), part of\n * the packet buffer.\n * If ep is NULL, assume no truncation check is needed.\n * Return true if truncated.\n * Stop at ep (if given) or after n bytes, whichever is first.\n */\nint\nnd_printn(netdissect_options *ndo,\n          const u_char *s, u_int n, const u_char *ep)\n{\n\tu_char c;\n\n\twhile (n > 0 && (ep == NULL || s < ep)) {\n\t\tn--;\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tfn_print_char(ndo, c);\n\t}\n\treturn (n == 0) ? 0 : 1;\n}\n\n/*\n * Print a null-padded filename (or other ASCII string), part of\n * the packet buffer, filtering out non-printable characters.\n * Stop if truncated (via GET_U_1/longjmp) or after n bytes or before\n * the null char, whichever occurs first.\n * The suffix comes from: j:longJmp, n:after N bytes, p:null-Padded.\n */\nvoid\nnd_printjnp(netdissect_options *ndo, const u_char *s, u_int n)\n{\n\tu_char c;\n\n\twhile (n > 0) {\n\t\tc = GET_U_1(s);\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\t\tfn_print_char(ndo, c);\n\t\tn--;\n\t\ts++;\n\t}\n}\n\n/*\n * Print the timestamp .FRAC part (Microseconds/nanoseconds)\n */\nstatic void\nts_frac_print(netdissect_options *ndo, long usec)\n{\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tswitch (ndo->ndo_tstamp_precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tND_PRINT(\".%06u\", (unsigned)usec);\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tND_PRINT(\".%09u\", (unsigned)usec);\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT(\".{unknown}\");\n\t\tbreak;\n\t}\n#else\n\tND_PRINT(\".%06u\", (unsigned)usec);\n#endif\n}\n\n/*\n * Print the timestamp as [YY:MM:DD] HH:MM:SS.FRAC.\n *   if time_flag == LOCAL_TIME print local time else UTC/GMT time\n *   if date_flag == WITH_DATE print YY:MM:DD before HH:MM:SS.FRAC\n */\nstatic void\nts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timebuf[32];\n\tconst char *timestr;\n\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\n\tif (date_flag == WITH_DATE) {\n\t\ttimestr = nd_format_time(timebuf, sizeof(timebuf),\n\t\t    \"%Y-%m-%d %H:%M:%S\", tm);\n\t} else {\n\t\ttimestr = nd_format_time(timebuf, sizeof(timebuf),\n\t\t    \"%H:%M:%S\", tm);\n\t}\n\tND_PRINT(\"%s\", timestr);\n\n\tts_frac_print(ndo, usec);\n}\n\n/*\n * Print the timestamp - Unix timeval style, as SECS.FRAC.\n */\nstatic void\nts_unix_print(netdissect_options *ndo, long sec, long usec)\n{\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\n\tND_PRINT(\"%u\", (unsigned)sec);\n\tts_frac_print(ndo, usec);\n}\n\n/*\n * Print the timestamp\n */\nvoid\nts_print(netdissect_options *ndo,\n         const struct timeval *tvp)\n{\n\tstatic struct timeval tv_ref;\n\tstruct timeval tv_result;\n\tint negative_offset;\n\tint nano_prec;\n\n\tswitch (ndo->ndo_tflag) {\n\n\tcase 0: /* Default */\n\t\tts_date_hmsfrac_print(ndo, tvp->tv_sec, tvp->tv_usec,\n\t\t\t\t      WITHOUT_DATE, LOCAL_TIME);\n\t\tND_PRINT(\" \");\n\t\tbreak;\n\n\tcase 1: /* No time stamp */\n\t\tbreak;\n\n\tcase 2: /* Unix timeval style */\n\t\tts_unix_print(ndo, tvp->tv_sec, tvp->tv_usec);\n\t\tND_PRINT(\" \");\n\t\tbreak;\n\n\tcase 3: /* Microseconds/nanoseconds since previous packet */\n        case 5: /* Microseconds/nanoseconds since first packet */\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\t\tswitch (ndo->ndo_tstamp_precision) {\n\t\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\t\tnano_prec = 0;\n\t\t\tbreak;\n\t\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\t\tnano_prec = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnano_prec = 0;\n\t\t\tbreak;\n\t\t}\n#else\n\t\tnano_prec = 0;\n#endif\n\t\tif (!(netdissect_timevalisset(&tv_ref)))\n\t\t\ttv_ref = *tvp; /* set timestamp for first packet */\n\n\t\tnegative_offset = netdissect_timevalcmp(tvp, &tv_ref, <);\n\t\tif (negative_offset)\n\t\t\tnetdissect_timevalsub(&tv_ref, tvp, &tv_result, nano_prec);\n\t\telse\n\t\t\tnetdissect_timevalsub(tvp, &tv_ref, &tv_result, nano_prec);\n\n\t\tND_PRINT((negative_offset ? \"-\" : \" \"));\n\t\tts_date_hmsfrac_print(ndo, tv_result.tv_sec, tv_result.tv_usec,\n\t\t\t\t      WITHOUT_DATE, UTC_TIME);\n\t\tND_PRINT(\" \");\n\n                if (ndo->ndo_tflag == 3)\n\t\t\ttv_ref = *tvp; /* set timestamp for previous packet */\n\t\tbreak;\n\n\tcase 4: /* Date + Default */\n\t\tts_date_hmsfrac_print(ndo, tvp->tv_sec, tvp->tv_usec,\n\t\t\t\t      WITH_DATE, LOCAL_TIME);\n\t\tND_PRINT(\" \");\n\t\tbreak;\n\t}\n}\n\n/*\n * Print an unsigned relative number of seconds (e.g. hold time, prune timer)\n * in the form 5m1s.  This does no truncation, so 32230861 seconds\n * is represented as 1y1w1d1h1m1s.\n */\nvoid\nunsigned_relts_print(netdissect_options *ndo,\n                     uint32_t secs)\n{\n\tstatic const char *lengths[] = {\"y\", \"w\", \"d\", \"h\", \"m\", \"s\"};\n\tstatic const u_int seconds[] = {31536000, 604800, 86400, 3600, 60, 1};\n\tconst char **l = lengths;\n\tconst u_int *s = seconds;\n\n\tif (secs == 0) {\n\t\tND_PRINT(\"0s\");\n\t\treturn;\n\t}\n\twhile (secs > 0) {\n\t\tif (secs >= *s) {\n\t\t\tND_PRINT(\"%u%s\", secs / *s, *l);\n\t\t\tsecs -= (secs / *s) * *s;\n\t\t}\n\t\ts++;\n\t\tl++;\n\t}\n}\n\n/*\n * Print a signed relative number of seconds (e.g. hold time, prune timer)\n * in the form 5m1s.  This does no truncation, so 32230861 seconds\n * is represented as 1y1w1d1h1m1s.\n */\nvoid\nsigned_relts_print(netdissect_options *ndo,\n                   int32_t secs)\n{\n\tif (secs < 0) {\n\t\tND_PRINT(\"-\");\n\t\tif (secs == INT32_MIN) {\n\t\t\t/*\n\t\t\t * -2^31; you can't fit its absolute value into\n\t\t\t * a 32-bit signed integer.\n\t\t\t *\n\t\t\t * Just directly pass said absolute value to\n\t\t\t * unsigned_relts_print() directly.\n\t\t\t *\n\t\t\t * (XXX - does ISO C guarantee that -(-2^n),\n\t\t\t * when calculated and cast to an n-bit unsigned\n\t\t\t * integer type, will have the value 2^n?)\n\t\t\t */\n\t\t\tunsigned_relts_print(ndo, 2147483648U);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We now know -secs will fit into an int32_t;\n\t\t\t * negate it and pass that to unsigned_relts_print().\n\t\t\t */\n\t\t\tunsigned_relts_print(ndo, -secs);\n\t\t}\n\t\treturn;\n\t}\n\tunsigned_relts_print(ndo, secs);\n}\n\n/*\n * Format a struct tm with strftime().\n * If the pointer to the struct tm is null, that means that the\n * routine to convert a time_t to a struct tm failed; the localtime()\n * and gmtime() in the Microsoft Visual Studio C library will fail,\n * returning null, if the value is before the UNIX Epoch.\n */\nconst char *\nnd_format_time(char *buf, size_t bufsize, const char *format,\n         const struct tm *timeptr)\n{\n\tif (timeptr != NULL) {\n\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n\t\t\treturn (buf);\n\t\telse\n\t\t\treturn (\"[nd_format_time() buffer is too small]\");\n\t} else\n\t\treturn (\"[localtime() or gmtime() couldn't convert the date and time]\");\n}\n\n/* Print the truncated string */\nvoid nd_print_trunc(netdissect_options *ndo)\n{\n\tND_PRINT(\" [|%s]\", ndo->ndo_protocol);\n}\n\n/* Print the protocol name */\nvoid nd_print_protocol(netdissect_options *ndo)\n{\n\tND_PRINT(\"%s\", ndo->ndo_protocol);\n}\n\n/* Print the protocol name in caps (uppercases) */\nvoid nd_print_protocol_caps(netdissect_options *ndo)\n{\n\tconst char *p;\n        for (p = ndo->ndo_protocol; *p != '\\0'; p++)\n                ND_PRINT(\"%c\", ND_ASCII_TOUPPER(*p));\n}\n\n/* Print the invalid string */\nvoid nd_print_invalid(netdissect_options *ndo)\n{\n\tND_PRINT(\" (invalid)\");\n}\n\n/*\n *  this is a generic routine for printing unknown data;\n *  we pass on the linefeed plus indentation string to\n *  get a proper output - returns 0 on error\n */\n\nint\nprint_unknown_data(netdissect_options *ndo, const u_char *cp,\n                   const char *ident, u_int len)\n{\n\tu_int len_to_print;\n\n\tlen_to_print = len;\n\tif (!ND_TTEST_LEN(cp, 0)) {\n\t\tND_PRINT(\"%sDissector error: print_unknown_data called with pointer past end of packet\",\n\t\t    ident);\n\t\treturn(0);\n\t}\n\tif (ND_BYTES_AVAILABLE_AFTER(cp) < len_to_print)\n\t\tlen_to_print = ND_BYTES_AVAILABLE_AFTER(cp);\n\thex_print(ndo, ident, cp, len_to_print);\n\treturn(1); /* everything is ok */\n}\n\n/*\n * Convert a token value to a string; use \"fmt\" if not found.\n */\nstatic const char *\ntok2strbuf(const struct tok *lp, const char *fmt,\n\t   u_int v, char *buf, size_t bufsize)\n{\n\tif (lp != NULL) {\n\t\twhile (lp->s != NULL) {\n\t\t\tif (lp->v == v)\n\t\t\t\treturn (lp->s);\n\t\t\t++lp;\n\t\t}\n\t}\n\tif (fmt == NULL)\n\t\tfmt = \"#%d\";\n\n\t(void)snprintf(buf, bufsize, fmt, v);\n\treturn (const char *)buf;\n}\n\n/*\n * Convert a token value to a string; use \"fmt\" if not found.\n * Uses tok2strbuf() on one of four local static buffers of size TOKBUFSIZE\n * in round-robin fashion.\n */\nconst char *\ntok2str(const struct tok *lp, const char *fmt,\n\tu_int v)\n{\n\tstatic char buf[4][TOKBUFSIZE];\n\tstatic int idx = 0;\n\tchar *ret;\n\n\tret = buf[idx];\n\tidx = (idx+1) & 3;\n\treturn tok2strbuf(lp, fmt, v, ret, sizeof(buf[0]));\n}\n\n/*\n * Convert a bit token value to a string; use \"fmt\" if not found.\n * this is useful for parsing bitfields, the output strings are separated\n * if the s field is positive.\n *\n * A token matches iff it has one or more bits set and every bit that is set\n * in the token is set in v. Consequently, a 0 token never matches.\n */\nstatic char *\nbittok2str_internal(const struct tok *lp, const char *fmt,\n\t   u_int v, const char *sep)\n{\n        static char buf[1024+1]; /* our string buffer */\n        char *bufp = buf;\n        size_t space_left = sizeof(buf), string_size;\n        const char * sepstr = \"\";\n\n        while (lp != NULL && lp->s != NULL) {\n            if (lp->v && (v & lp->v) == lp->v) {\n                /* ok we have found something */\n                if (space_left <= 1)\n                    return (buf); /* only enough room left for NUL, if that */\n                string_size = strlcpy(bufp, sepstr, space_left);\n                if (string_size >= space_left)\n                    return (buf);    /* we ran out of room */\n                bufp += string_size;\n                space_left -= string_size;\n                if (space_left <= 1)\n                    return (buf); /* only enough room left for NUL, if that */\n                string_size = strlcpy(bufp, lp->s, space_left);\n                if (string_size >= space_left)\n                    return (buf);    /* we ran out of room */\n                bufp += string_size;\n                space_left -= string_size;\n                sepstr = sep;\n            }\n            lp++;\n        }\n\n        if (bufp == buf)\n            /* bummer - lets print the \"unknown\" message as advised in the fmt string if we got one */\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}\n\n/*\n * Convert a bit token value to a string; use \"fmt\" if not found.\n * this is useful for parsing bitfields, the output strings are not separated.\n */\nchar *\nbittok2str_nosep(const struct tok *lp, const char *fmt,\n\t   u_int v)\n{\n    return (bittok2str_internal(lp, fmt, v, \"\"));\n}\n\n/*\n * Convert a bit token value to a string; use \"fmt\" if not found.\n * this is useful for parsing bitfields, the output strings are comma separated.\n */\nchar *\nbittok2str(const struct tok *lp, const char *fmt,\n\t   u_int v)\n{\n    return (bittok2str_internal(lp, fmt, v, \", \"));\n}\n\n/*\n * Convert a value to a string using an array; the macro\n * tok2strary() in <netdissect.h> is the public interface to\n * this function and ensures that the second argument is\n * correct for bounds-checking.\n */\nconst char *\ntok2strary_internal(const char **lp, int n, const char *fmt,\n\tint v)\n{\n\tstatic char buf[TOKBUFSIZE];\n\n\tif (v >= 0 && v < n && lp[v] != NULL)\n\t\treturn lp[v];\n\tif (fmt == NULL)\n\t\tfmt = \"#%d\";\n\t(void)snprintf(buf, sizeof(buf), fmt, v);\n\treturn (buf);\n}\n\nconst struct tok *\nuint2tokary_internal(const struct uint_tokary dict[], const size_t size,\n                     const u_int val)\n{\n\tsize_t i;\n\t/* Try a direct lookup before the full scan. */\n\tif (val < size && dict[val].uintval == val)\n\t\treturn dict[val].tokary; /* OK if NULL */\n\tfor (i = 0; i < size; i++)\n\t\tif (dict[i].uintval == val)\n\t\t\treturn dict[i].tokary; /* OK if NULL */\n\treturn NULL;\n}\n\n/*\n * Convert a 32-bit netmask to prefixlen if possible\n * the function returns the prefix-len; if plen == -1\n * then conversion was not possible;\n */\n\nint\nmask2plen(uint32_t mask)\n{\n\tconst uint32_t bitmasks[33] = {\n\t\t0x00000000,\n\t\t0x80000000, 0xc0000000, 0xe0000000, 0xf0000000,\n\t\t0xf8000000, 0xfc000000, 0xfe000000, 0xff000000,\n\t\t0xff800000, 0xffc00000, 0xffe00000, 0xfff00000,\n\t\t0xfff80000, 0xfffc0000, 0xfffe0000, 0xffff0000,\n\t\t0xffff8000, 0xffffc000, 0xffffe000, 0xfffff000,\n\t\t0xfffff800, 0xfffffc00, 0xfffffe00, 0xffffff00,\n\t\t0xffffff80, 0xffffffc0, 0xffffffe0, 0xfffffff0,\n\t\t0xfffffff8, 0xfffffffc, 0xfffffffe, 0xffffffff\n\t};\n\tint prefix_len = 32;\n\n\t/* let's see if we can transform the mask into a prefixlen */\n\twhile (prefix_len >= 0) {\n\t\tif (bitmasks[prefix_len] == mask)\n\t\t\tbreak;\n\t\tprefix_len--;\n\t}\n\treturn (prefix_len);\n}\n\nint\nmask62plen(const u_char *mask)\n{\n\tu_char bitmasks[9] = {\n\t\t0x00,\n\t\t0x80, 0xc0, 0xe0, 0xf0,\n\t\t0xf8, 0xfc, 0xfe, 0xff\n\t};\n\tint byte;\n\tint cidr_len = 0;\n\n\tfor (byte = 0; byte < 16; byte++) {\n\t\tu_int bits;\n\n\t\tfor (bits = 0; bits < (sizeof (bitmasks) / sizeof (bitmasks[0])); bits++) {\n\t\t\tif (mask[byte] == bitmasks[bits]) {\n\t\t\t\tcidr_len += bits;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mask[byte] != 0xff)\n\t\t\tbreak;\n\t}\n\treturn (cidr_len);\n}\n\n/*\n * Routine to print out information for text-based protocols such as FTP,\n * HTTP, SMTP, RTSP, SIP, ....\n */\n#define MAX_TOKEN\t128\n\n/*\n * Fetch a token from a packet, starting at the specified index,\n * and return the length of the token.\n *\n * Returns 0 on error; yes, this is indistinguishable from an empty\n * token, but an \"empty token\" isn't a valid token - it just means\n * either a space character at the beginning of the line (this\n * includes a blank line) or no more tokens remaining on the line.\n */\nstatic int\nfetch_token(netdissect_options *ndo, const u_char *pptr, u_int idx, u_int len,\n    u_char *tbuf, size_t tbuflen)\n{\n\tsize_t toklen = 0;\n\tu_char c;\n\n\tfor (; idx < len; idx++) {\n\t\tif (!ND_TTEST_1(pptr + idx)) {\n\t\t\t/* ran past end of captured data */\n\t\t\treturn (0);\n\t\t}\n\t\tc = GET_U_1(pptr + idx);\n\t\tif (!ND_ISASCII(c)) {\n\t\t\t/* not an ASCII character */\n\t\t\treturn (0);\n\t\t}\n\t\tif (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n\t\t\t/* end of token */\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ASCII_ISPRINT(c)) {\n\t\t\t/* not part of a command token or response code */\n\t\t\treturn (0);\n\t\t}\n\t\tif (toklen + 2 > tbuflen) {\n\t\t\t/* no room for this character and terminating '\\0' */\n\t\t\treturn (0);\n\t\t}\n\t\ttbuf[toklen] = c;\n\t\ttoklen++;\n\t}\n\tif (toklen == 0) {\n\t\t/* no token */\n\t\treturn (0);\n\t}\n\ttbuf[toklen] = '\\0';\n\n\t/*\n\t * Skip past any white space after the token, until we see\n\t * an end-of-line (CR or LF).\n\t */\n\tfor (; idx < len; idx++) {\n\t\tif (!ND_TTEST_1(pptr + idx)) {\n\t\t\t/* ran past end of captured data */\n\t\t\tbreak;\n\t\t}\n\t\tc = GET_U_1(pptr + idx);\n\t\tif (c == '\\r' || c == '\\n') {\n\t\t\t/* end of line */\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ASCII_ISPRINT(c)) {\n\t\t\t/* not a printable ASCII character */\n\t\t\tbreak;\n\t\t}\n\t\tif (c != ' ' && c != '\\t' && c != '\\r' && c != '\\n') {\n\t\t\t/* beginning of next token */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (idx);\n}\n\n/*\n * Scan a buffer looking for a line ending - LF or CR-LF.\n * Return the index of the character after the line ending or 0 if\n * we encounter a non-ASCII or non-printable character or don't find\n * the line ending.\n */\nstatic u_int\nprint_txt_line(netdissect_options *ndo, const char *prefix,\n\t       const u_char *pptr, u_int idx, u_int len)\n{\n\tu_int startidx;\n\tu_int linelen;\n\tu_char c;\n\n\tstartidx = idx;\n\twhile (idx < len) {\n\t\tc = GET_U_1(pptr + idx);\n\t\tif (c == '\\n') {\n\t\t\t/*\n\t\t\t * LF without CR; end of line.\n\t\t\t * Skip the LF and print the line, with the\n\t\t\t * exception of the LF.\n\t\t\t */\n\t\t\tlinelen = idx - startidx;\n\t\t\tidx++;\n\t\t\tgoto print;\n\t\t} else if (c == '\\r') {\n\t\t\t/* CR - any LF? */\n\t\t\tif ((idx+1) >= len) {\n\t\t\t\t/* not in this packet */\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (GET_U_1(pptr + idx + 1) == '\\n') {\n\t\t\t\t/*\n\t\t\t\t * CR-LF; end of line.\n\t\t\t\t * Skip the CR-LF and print the line, with\n\t\t\t\t * the exception of the CR-LF.\n\t\t\t\t */\n\t\t\t\tlinelen = idx - startidx;\n\t\t\t\tidx += 2;\n\t\t\t\tgoto print;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * CR followed by something else; treat this\n\t\t\t * as if it were binary data, and don't print\n\t\t\t * it.\n\t\t\t */\n\t\t\treturn (0);\n\t\t} else if (!ND_ASCII_ISPRINT(c) && c != '\\t') {\n\t\t\t/*\n\t\t\t * Not a printable ASCII character and not a tab;\n\t\t\t * treat this as if it were binary data, and\n\t\t\t * don't print it.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\tidx++;\n\t}\n\n\t/*\n\t * All printable ASCII, but no line ending after that point\n\t * in the buffer; treat this as if it were truncated.\n\t */\n\tlinelen = idx - startidx;\n\tND_PRINT(\"%s%.*s\", prefix, (int)linelen, pptr + startidx);\n\tnd_print_trunc(ndo);\n\treturn (0);\n\nprint:\n\tND_PRINT(\"%s%.*s\", prefix, (int)linelen, pptr + startidx);\n\treturn (idx);\n}\n\n/* Assign needed before calling txtproto_print(): ndo->ndo_protocol = \"proto\" */\nvoid\ntxtproto_print(netdissect_options *ndo, const u_char *pptr, u_int len,\n\t       const char **cmds, u_int flags)\n{\n\tu_int idx, eol;\n\tu_char token[MAX_TOKEN+1];\n\tconst char *cmd;\n\tint print_this = 0;\n\n\tif (cmds != NULL) {\n\t\t/*\n\t\t * This protocol has more than just request and\n\t\t * response lines; see whether this looks like a\n\t\t * request or response and, if so, print it and,\n\t\t * in verbose mode, print everything after it.\n\t\t *\n\t\t * This is for HTTP-like protocols, where we\n\t\t * want to print requests and responses, but\n\t\t * don't want to print continuations of request\n\t\t * or response bodies in packets that don't\n\t\t * contain the request or response line.\n\t\t */\n\t\tidx = fetch_token(ndo, pptr, 0, len, token, sizeof(token));\n\t\tif (idx != 0) {\n\t\t\t/* Is this a valid request name? */\n\t\t\twhile ((cmd = *cmds++) != NULL) {\n\t\t\t\tif (ascii_strcasecmp((const char *)token, cmd) == 0) {\n\t\t\t\t\t/* Yes. */\n\t\t\t\t\tprint_this = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * No - is this a valid response code (3 digits)?\n\t\t\t *\n\t\t\t * Is this token the response code, or is the next\n\t\t\t * token the response code?\n\t\t\t */\n\t\t\tif (flags & RESP_CODE_SECOND_TOKEN) {\n\t\t\t\t/*\n\t\t\t\t * Next token - get it.\n\t\t\t\t */\n\t\t\t\tidx = fetch_token(ndo, pptr, idx, len, token,\n\t\t\t\t    sizeof(token));\n\t\t\t}\n\t\t\tif (idx != 0) {\n\t\t\t\tif (ND_ASCII_ISDIGIT(token[0]) && ND_ASCII_ISDIGIT(token[1]) &&\n\t\t\t\t    ND_ASCII_ISDIGIT(token[2]) && token[3] == '\\0') {\n\t\t\t\t\t/* Yes. */\n\t\t\t\t\tprint_this = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Either:\n\t\t *\n\t\t * 1) This protocol has only request and response lines\n\t\t *    (e.g., FTP, where all the data goes over a different\n\t\t *    connection); assume the payload is a request or\n\t\t *    response.\n\t\t *\n\t\t * or\n\t\t *\n\t\t * 2) This protocol is just text, so that we should\n\t\t *    always, at minimum, print the first line and,\n\t\t *    in verbose mode, print all lines.\n\t\t */\n\t\tprint_this = 1;\n\t}\n\n\tnd_print_protocol_caps(ndo);\n\n\tif (print_this) {\n\t\t/*\n\t\t * In non-verbose mode, just print the protocol, followed\n\t\t * by the first line.\n\t\t *\n\t\t * In verbose mode, print lines as text until we run out\n\t\t * of characters or see something that's not a\n\t\t * printable-ASCII line.\n\t\t */\n\t\tif (ndo->ndo_vflag) {\n\t\t\t/*\n\t\t\t * We're going to print all the text lines in the\n\t\t\t * request or response; just print the length\n\t\t\t * on the first line of the output.\n\t\t\t */\n\t\t\tND_PRINT(\", length: %u\", len);\n\t\t\tfor (idx = 0;\n\t\t\t    idx < len && (eol = print_txt_line(ndo, \"\\n\\t\", pptr, idx, len)) != 0;\n\t\t\t    idx = eol)\n\t\t\t\t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Just print the first text line.\n\t\t\t */\n\t\t\tprint_txt_line(ndo, \": \", pptr, 0, len);\n\t\t}\n\t}\n}\n\n#if (defined(__i386__) || defined(_M_IX86) || defined(__X86__) || defined(__x86_64__) || defined(_M_X64)) || \\\n    (defined(__arm__) || defined(_M_ARM) || defined(__aarch64__)) || \\\n    (defined(__m68k__) && (!defined(__mc68000__) && !defined(__mc68010__))) || \\\n    (defined(__ppc__) || defined(__ppc64__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PPC64)) || \\\n    (defined(__s390__) || defined(__s390x__) || defined(__zarch__)) || \\\n    defined(__vax__)\n/*\n * The processor natively handles unaligned loads, so just use memcpy()\n * and memcmp(), to enable those optimizations.\n *\n * XXX - are those all the x86 tests we need?\n * XXX - do we need to worry about ARMv1 through ARMv5, which didn't\n * support unaligned loads, and, if so, do we need to worry about all\n * of them, or just some of them, e.g. ARMv5?\n * XXX - are those the only 68k tests we need not to generated\n * unaligned accesses if the target is the 68000 or 68010?\n * XXX - are there any tests we don't need, because some definitions are for\n * compilers that also predefine the GCC symbols?\n * XXX - do we need to test for both 32-bit and 64-bit versions of those\n * architectures in all cases?\n */\n#else\n/*\n * The processor doesn't natively handle unaligned loads,\n * and the compiler might \"helpfully\" optimize memcpy()\n * and memcmp(), when handed pointers that would normally\n * be properly aligned, into sequences that assume proper\n * alignment.\n *\n * Do copies and compares of possibly-unaligned data by\n * calling routines that wrap memcpy() and memcmp(), to\n * prevent that optimization.\n */\nvoid\nunaligned_memcpy(void *p, const void *q, size_t l)\n{\n\tmemcpy(p, q, l);\n}\n\n/* As with memcpy(), so with memcmp(). */\nint\nunaligned_memcmp(const void *p, const void *q, size_t l)\n{\n\treturn (memcmp(p, q, l));\n}\n#endif\n\n"], "filenames": ["netdissect.h", "ntp.c", "print-ahcp.c", "print-arista.c", "print-rx.c", "print-zep.c", "smbutil.c", "tcpdump.c", "util-print.c"], "buggy_code_start_loc": [424, 57, 105, 13, 797, 85, 771, 845, 233], "buggy_code_end_loc": [424, 81, 117, 107, 803, 91, 813, 860, 405], "fixing_code_start_loc": [425, 56, 105, 12, 797, 84, 770, 846, 233], "fixing_code_end_loc": [428, 73, 113, 102, 803, 90, 807, 878, 426], "type": "CWE-787", "message": "The SMB protocol decoder in tcpdump version 4.99.3 can perform an out-of-bounds write when decoding a crafted network packet.", "other": {"cve": {"id": "CVE-2023-1801", "sourceIdentifier": "security@tcpdump.org", "published": "2023-04-07T21:15:06.873", "lastModified": "2023-04-28T04:15:36.940", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The SMB protocol decoder in tcpdump version 4.99.3 can perform an out-of-bounds write when decoding a crafted network packet."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:4.99.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2019905-B202-4083-B00E-50C5C67F9830"}]}]}], "references": [{"url": "https://github.com/the-tcpdump-group/tcpdump/commit/03c037bbd75588beba3ee09f26d17783d21e30bc", "source": "security@tcpdump.org", "tags": ["Patch"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/7578e1c04ee280dda50c4c2813e7d55f539c6501", "source": "security@tcpdump.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KOA2BJFERAC3VRQIRHJOWN4HZY4ZA7CH/", "source": "security@tcpdump.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WYL5DEVHRJYF2CM5LTCZKEYFYDZAIZSN/", "source": "security@tcpdump.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLLZCG23MU6O4QOG2CX3DLEL3YXP6LAI/", "source": "security@tcpdump.org"}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/03c037bbd75588beba3ee09f26d17783d21e30bc"}}