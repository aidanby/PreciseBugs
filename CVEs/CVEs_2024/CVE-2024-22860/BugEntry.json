{"buggy_code": ["/*\n * Animated JPEG XL Demuxer\n * Copyright (c) 2023 Leo Izen (thebombzen)\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Animated JPEG XL Demuxer\n * @see ISO/IEC 18181-1 and 18181-2\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"libavcodec/jpegxl.h\"\n#include \"libavcodec/jpegxl_parse.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/opt.h\"\n\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct JXLAnimDemuxContext {\n    AVBufferRef *initial;\n} JXLAnimDemuxContext;\n\nstatic int jpegxl_anim_probe(const AVProbeData *p)\n{\n    uint8_t buffer[4096 + AV_INPUT_BUFFER_PADDING_SIZE];\n    int copied = 0, ret;\n    FFJXLMetadata meta = { 0 };\n\n    /* this is a raw codestream */\n    if (AV_RL16(p->buf) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {\n        ret = ff_jpegxl_parse_codestream_header(p->buf, p->buf_size, &meta, 5);\n        if (ret >= 0 && meta.animation_offset > 0)\n            return AVPROBE_SCORE_MAX;\n\n        return 0;\n    }\n\n    /* not a JPEG XL file at all */\n    if (AV_RL64(p->buf) != FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n        return 0;\n\n    if (ff_jpegxl_collect_codestream_header(p->buf, p->buf_size, buffer,\n            sizeof(buffer) - AV_INPUT_BUFFER_PADDING_SIZE, &copied) <= 0\n            || copied <= 0)\n        return 0;\n\n    ret = ff_jpegxl_parse_codestream_header(buffer, copied, &meta, 10);\n    if (ret >= 0 && meta.animation_offset > 0)\n        return AVPROBE_SCORE_MAX;\n\n    return 0;\n}\n\nstatic int jpegxl_anim_read_header(AVFormatContext *s)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint8_t head[256 + AV_INPUT_BUFFER_PADDING_SIZE];\n    const int sizeofhead = sizeof(head) - AV_INPUT_BUFFER_PADDING_SIZE;\n    int headsize = 0, ret;\n    FFJXLMetadata meta = { 0 };\n\n    uint64_t sig16 = avio_rl16(pb);\n    if (sig16 == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {\n        AV_WL16(head, sig16);\n        headsize = avio_read(s->pb, head + 2, sizeofhead - 2);\n        if (headsize < 0)\n            return headsize;\n        headsize += 2;\n        ctx->initial = av_buffer_alloc(headsize);\n        if (!ctx->initial)\n            return AVERROR(ENOMEM);\n        memcpy(ctx->initial->data, head, headsize);\n    } else {\n        uint64_t sig64 = avio_rl64(pb);\n        sig64 = (sig64 << 16) | sig16;\n        if (sig64 != FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 2); // first box always 12 bytes\n        while (1) {\n            int copied = 0;\n            uint8_t buf[4096];\n            int read = avio_read(pb, buf, sizeof(buf));\n            if (read < 0)\n                return read;\n            if (!ctx->initial) {\n                ctx->initial = av_buffer_alloc(read + 12);\n                if (!ctx->initial)\n                    return AVERROR(ENOMEM);\n                AV_WL64(ctx->initial->data, FF_JPEGXL_CONTAINER_SIGNATURE_LE);\n                AV_WL32(ctx->initial->data + 8, 0x0a870a0d);\n            } else {\n                /* this only should be happening zero or one times in practice */\n                if (av_buffer_realloc(&ctx->initial, ctx->initial->size + read) < 0)\n                    return AVERROR(ENOMEM);\n            }\n            ff_jpegxl_collect_codestream_header(buf, read, head + headsize, sizeofhead - headsize, &copied);\n            memcpy(ctx->initial->data + (ctx->initial->size - read), buf, read);\n            headsize += copied;\n            if (headsize >= sizeofhead || read < sizeof(buf))\n                break;\n        }\n    }\n\n    /* offset in bits of the animation header */\n    ret = ff_jpegxl_parse_codestream_header(head, headsize, &meta, 0);\n    if (ret < 0 || meta.animation_offset <= 0)\n        return AVERROR_INVALIDDATA;\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_JPEGXL;\n    avpriv_set_pts_info(st, 1, meta.timebase.num, meta.timebase.den);\n    ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n\n    return 0;\n}\n\n/* the decoder requires the full input file as a single packet */\nstatic int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size == 0)\n        size = 4096;\n\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n\n    return 0;\n}\n\nstatic int jpegxl_anim_close(AVFormatContext *s)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    if (ctx->initial)\n        av_buffer_unref(&ctx->initial);\n\n    return 0;\n}\n\nconst AVInputFormat ff_jpegxl_anim_demuxer = {\n    .name           = \"jpegxl_anim\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Animated JPEG XL\"),\n    .priv_data_size = sizeof(JXLAnimDemuxContext),\n    .read_probe     = jpegxl_anim_probe,\n    .read_header    = jpegxl_anim_read_header,\n    .read_packet    = jpegxl_anim_read_packet,\n    .read_close     = jpegxl_anim_close,\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .flags          = AVFMT_GENERIC_INDEX | AVFMT_NOTIMESTAMPS,\n    .mime_type      = \"image/jxl\",\n    .extensions     = \"jxl\",\n};\n"], "fixing_code": ["/*\n * Animated JPEG XL Demuxer\n * Copyright (c) 2023 Leo Izen (thebombzen)\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Animated JPEG XL Demuxer\n * @see ISO/IEC 18181-1 and 18181-2\n */\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"libavcodec/jpegxl.h\"\n#include \"libavcodec/jpegxl_parse.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/opt.h\"\n\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct JXLAnimDemuxContext {\n    AVBufferRef *initial;\n} JXLAnimDemuxContext;\n\nstatic int jpegxl_anim_probe(const AVProbeData *p)\n{\n    uint8_t buffer[4096 + AV_INPUT_BUFFER_PADDING_SIZE];\n    int copied = 0, ret;\n    FFJXLMetadata meta = { 0 };\n\n    /* this is a raw codestream */\n    if (AV_RL16(p->buf) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {\n        ret = ff_jpegxl_parse_codestream_header(p->buf, p->buf_size, &meta, 5);\n        if (ret >= 0 && meta.animation_offset > 0)\n            return AVPROBE_SCORE_MAX;\n\n        return 0;\n    }\n\n    /* not a JPEG XL file at all */\n    if (AV_RL64(p->buf) != FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n        return 0;\n\n    if (ff_jpegxl_collect_codestream_header(p->buf, p->buf_size, buffer,\n            sizeof(buffer) - AV_INPUT_BUFFER_PADDING_SIZE, &copied) <= 0\n            || copied <= 0)\n        return 0;\n\n    ret = ff_jpegxl_parse_codestream_header(buffer, copied, &meta, 10);\n    if (ret >= 0 && meta.animation_offset > 0)\n        return AVPROBE_SCORE_MAX;\n\n    return 0;\n}\n\nstatic int jpegxl_anim_read_header(AVFormatContext *s)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint8_t head[256 + AV_INPUT_BUFFER_PADDING_SIZE];\n    const int sizeofhead = sizeof(head) - AV_INPUT_BUFFER_PADDING_SIZE;\n    int headsize = 0, ret;\n    FFJXLMetadata meta = { 0 };\n\n    uint64_t sig16 = avio_rl16(pb);\n    if (sig16 == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {\n        AV_WL16(head, sig16);\n        headsize = avio_read(s->pb, head + 2, sizeofhead - 2);\n        if (headsize < 0)\n            return headsize;\n        headsize += 2;\n        ctx->initial = av_buffer_alloc(headsize);\n        if (!ctx->initial)\n            return AVERROR(ENOMEM);\n        memcpy(ctx->initial->data, head, headsize);\n    } else {\n        uint64_t sig64 = avio_rl64(pb);\n        sig64 = (sig64 << 16) | sig16;\n        if (sig64 != FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 2); // first box always 12 bytes\n        while (1) {\n            int copied = 0;\n            uint8_t buf[4096];\n            int read = avio_read(pb, buf, sizeof(buf));\n            if (read < 0)\n                return read;\n            if (!ctx->initial) {\n                ctx->initial = av_buffer_alloc(read + 12);\n                if (!ctx->initial)\n                    return AVERROR(ENOMEM);\n                AV_WL64(ctx->initial->data, FF_JPEGXL_CONTAINER_SIGNATURE_LE);\n                AV_WL32(ctx->initial->data + 8, 0x0a870a0d);\n            } else {\n                /* this only should be happening zero or one times in practice */\n                if (av_buffer_realloc(&ctx->initial, ctx->initial->size + read) < 0)\n                    return AVERROR(ENOMEM);\n            }\n            ff_jpegxl_collect_codestream_header(buf, read, head + headsize, sizeofhead - headsize, &copied);\n            memcpy(ctx->initial->data + (ctx->initial->size - read), buf, read);\n            headsize += copied;\n            if (headsize >= sizeofhead || read < sizeof(buf))\n                break;\n        }\n    }\n\n    /* offset in bits of the animation header */\n    ret = ff_jpegxl_parse_codestream_header(head, headsize, &meta, 0);\n    if (ret < 0 || meta.animation_offset <= 0)\n        return AVERROR_INVALIDDATA;\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_JPEGXL;\n    avpriv_set_pts_info(st, 1, meta.timebase.num, meta.timebase.den);\n    ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;\n\n    return 0;\n}\n\n/* the decoder requires the full input file as a single packet */\nstatic int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size > INT_MAX)\n        return AVERROR(EDOM);\n    if (size == 0)\n        size = 4096;\n\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n\n    return 0;\n}\n\nstatic int jpegxl_anim_close(AVFormatContext *s)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    if (ctx->initial)\n        av_buffer_unref(&ctx->initial);\n\n    return 0;\n}\n\nconst AVInputFormat ff_jpegxl_anim_demuxer = {\n    .name           = \"jpegxl_anim\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Animated JPEG XL\"),\n    .priv_data_size = sizeof(JXLAnimDemuxContext),\n    .read_probe     = jpegxl_anim_probe,\n    .read_header    = jpegxl_anim_read_header,\n    .read_packet    = jpegxl_anim_read_packet,\n    .read_close     = jpegxl_anim_close,\n    .flags_internal = FF_FMT_INIT_CLEANUP,\n    .flags          = AVFMT_GENERIC_INDEX | AVFMT_NOTIMESTAMPS,\n    .mime_type      = \"image/jxl\",\n    .extensions     = \"jxl\",\n};\n"], "filenames": ["libavformat/jpegxl_anim_dec.c"], "buggy_code_start_loc": [154], "buggy_code_end_loc": [154], "fixing_code_start_loc": [155], "fixing_code_end_loc": [157], "type": "CWE-190", "message": "Integer overflow vulnerability in FFmpeg before n6.1, allows remote attackers to execute arbitrary code via the jpegxl_anim_read_packet component in the JPEG XL Animation decoder.", "other": {"cve": {"id": "CVE-2024-22860", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-27T06:15:48.430", "lastModified": "2024-02-02T23:38:02.733", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in FFmpeg before n6.1, allows remote attackers to execute arbitrary code via the jpegxl_anim_read_packet component in the JPEG XL Animation decoder."}, {"lang": "es", "value": "Vulnerabilidad de desbordamiento de enteros en FFmpeg anterior a n6.1, permite a atacantes remotos ejecutar c\u00f3digo arbitrario a trav\u00e9s del componente jpegxl_anim_read_packet en el decodificador de animaci\u00f3n JPEG XL."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1", "matchCriteriaId": "54E3D89D-E427-413B-A8E1-C9ED6D2409F3"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=61991", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/d2e8974699a9e35cc1a926bf74a972300d629cd5", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/d2e8974699a9e35cc1a926bf74a972300d629cd5"}}