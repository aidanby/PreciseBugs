{"buggy_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2019 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// caff.c\n\n// This module is a helper to the WavPack command-line programs to support CAF files.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#ifdef _WIN32\n#define strdup(x) _strdup(x)\n#endif\n\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\ntypedef struct\n{\n    char mFileType [4];\n    uint16_t mFileVersion;\n    uint16_t mFileFlags;\n} CAFFileHeader;\n\n#define CAFFileHeaderFormat \"4SS\"\n\n#pragma pack(push,4)\ntypedef struct\n{\n    char mChunkType [4];\n    int64_t mChunkSize;\n} CAFChunkHeader;\n#pragma pack(pop)\n\n#define CAFChunkHeaderFormat \"4D\"\n\ntypedef struct\n{\n    double mSampleRate;\n    char mFormatID [4];\n    uint32_t mFormatFlags;\n    uint32_t mBytesPerPacket;\n    uint32_t mFramesPerPacket;\n    uint32_t mChannelsPerFrame;\n    uint32_t mBitsPerChannel;\n} CAFAudioFormat;\n\n#define CAFAudioFormatFormat \"D4LLLLL\"\n#define CAF_FORMAT_FLOAT            0x1\n#define CAF_FORMAT_LITTLE_ENDIAN    0x2\n\ntypedef struct\n{\n    uint32_t mChannelLayoutTag;\n    uint32_t mChannelBitmap;\n    uint32_t mNumberChannelDescriptions;\n} CAFChannelLayout;\n\n#define CAFChannelLayoutFormat \"LLL\"\n\nenum {\n    kCAFChannelLayoutTag_UseChannelDescriptions = (0<<16) | 0,  // use the array of AudioChannelDescriptions to define the mapping.\n    kCAFChannelLayoutTag_UseChannelBitmap = (1<<16) | 0,        // use the bitmap to define the mapping.\n};\n\ntypedef struct\n{\n    uint32_t mChannelLabel;\n    uint32_t mChannelFlags;\n    float mCoordinates [3];\n} CAFChannelDescription;\n\n#define CAFChannelDescriptionFormat \"LLLLL\"\n\nstatic const char TMH_full [] = { 1,2,3,13,9,10,5,6,12,14,15,16,17,9,4,18,7,8,19,20,21,0 };\nstatic const char TMH_std [] = { 1,2,3,11,8,9,5,6,10,12,13,14,15,7,4,16,0 };\n\nstatic struct {\n    uint32_t mChannelLayoutTag;     // Core Audio layout, 100 - 146 in high word, num channels in low word\n    uint32_t mChannelBitmap;        // Microsoft standard mask (for those channels that appear)\n    const char *mChannelReorder;    // reorder string if layout is NOT in Microsoft standard order\n    const char *mChannelIdentities; // identities of any channels NOT in Microsoft standard\n} layouts [] = {\n    { (100<<16) | 1, 0x004, NULL,       NULL            },  // FC\n    { (101<<16) | 2, 0x003, NULL,       NULL            },  // FL, FR\n    { (102<<16) | 2, 0x003, NULL,       NULL            },  // FL, FR (headphones)\n    { (103<<16) | 2, 0x000, NULL,       \"\\46\\47\"        },  // [Lt, Rt] (matrix encoded)\n    { (104<<16) | 2, 0x000, NULL,       \"\\314\\315\"      },  // [Mid, Side]\n    { (105<<16) | 2, 0x000, NULL,       \"\\316\\317\"      },  // [X, Y]\n    { (106<<16) | 2, 0x003, NULL,       NULL            },  // FL, FR (binaural)\n    { (107<<16) | 4, 0x000, NULL,       \"\\310\\311\\312\\313\"  },  // [W, X, Y, Z] (ambisonics)\n    { (108<<16) | 4, 0x033, NULL,       NULL            },  // FL, FR, BL, BR (quad)\n    { (109<<16) | 5, 0x037, \"12453\",    NULL            },  // FL, FR, BL, BR, FC (pentagonal)\n    { (110<<16) | 6, 0x137, \"124536\",   NULL            },  // FL, FR, BL, BR, FC, BC (hexagonal)\n    { (111<<16) | 8, 0x737, \"12453678\", NULL            },  // FL, FR, BL, BR, FC, BC, SL, SR (octagonal)\n    { (112<<16) | 8, 0x2d033, NULL,     NULL            },  // FL, FR, BL, BR, TFL, TFR, TBL, TBR (cubic)\n    { (113<<16) | 3, 0x007, NULL,       NULL            },  // FL, FR, FC\n    { (114<<16) | 3, 0x007, \"312\",      NULL            },  // FC, FL, FR\n    { (115<<16) | 4, 0x107, NULL,       NULL            },  // FL, FR, FC, BC\n    { (116<<16) | 4, 0x107, \"3124\",     NULL            },  // FC, FL, FR, BC\n    { (117<<16) | 5, 0x037, NULL,       NULL            },  // FL, FR, FC, BL, BR\n    { (118<<16) | 5, 0x037, \"12453\",    NULL            },  // FL, FR, BL, BR, FC\n    { (119<<16) | 5, 0x037, \"13245\",    NULL            },  // FL, FC, FR, BL, BR\n    { (120<<16) | 5, 0x037, \"31245\",    NULL            },  // FC, FL, FR, BL, BR\n    { (121<<16) | 6, 0x03f, NULL,       NULL            },  // FL, FR, FC, LFE, BL, BR\n    { (122<<16) | 6, 0x03f, \"125634\",   NULL            },  // FL, FR, BL, BR, FC, LFE\n    { (123<<16) | 6, 0x03f, \"132564\",   NULL            },  // FL, FC, FR, BL, BR, LFE\n    { (124<<16) | 6, 0x03f, \"312564\",   NULL            },  // FC, FL, FR, BL, BR, LFE\n    { (125<<16) | 7, 0x13f, NULL,       NULL            },  // FL, FR, FC, LFE, BL, BR, BC\n    { (126<<16) | 8, 0x0ff, NULL,       NULL            },  // FL, FR, FC, LFE, BL, BR, FLC, FRC\n    { (127<<16) | 8, 0x0ff, \"37812564\", NULL            },  // FC, FLC, FRC, FL, FR, BL, BR, LFE\n    { (128<<16) | 8, 0x03f, NULL,       \"\\41\\42\"        },  // FL, FR, FC, LFE, BL, BR, [Rls, Rrs]\n    { (129<<16) | 8, 0x0ff, \"12563478\", NULL            },  // FL, FR, BL, BR, FC, LFE, FLC, FRC\n    { (130<<16) | 8, 0x03f, NULL,       \"\\46\\47\"        },  // FL, FR, FC, LFE, BL, BR, [Lt, Rt]\n    { (131<<16) | 3, 0x103, NULL,       NULL            },  // FL, FR, BC\n    { (132<<16) | 4, 0x033, NULL,       NULL            },  // FL, FR, BL, BR\n    { (133<<16) | 3, 0x00B, NULL,       NULL            },  // FL, FR, LFE\n    { (134<<16) | 4, 0x10B, NULL,       NULL            },  // FL, FR, LFE, BC\n    { (135<<16) | 5, 0x03B, NULL,       NULL            },  // FL, FR, LFE, BL, BR\n    { (136<<16) | 4, 0x00F, NULL,       NULL            },  // FL, FR, FC, LFE\n    { (137<<16) | 5, 0x10f, NULL,       NULL            },  // FL, FR, FC, LFE, BC\n    { (138<<16) | 5, 0x03b, \"12453\",    NULL            },  // FL, FR, BL, BR, LFE\n    { (139<<16) | 6, 0x137, \"124536\",   NULL            },  // FL, FR, BL, BR, FC, BC\n    { (140<<16) | 7, 0x037, \"1245367\",  \"\\41\\42\"        },  // FL, FR, BL, BR, FC, [Rls, Rrs]\n    { (141<<16) | 6, 0x137, \"312456\",   NULL            },  // FC, FL, FR, BL, BR, BC\n    { (142<<16) | 7, 0x13f, \"3125674\",  NULL            },  // FC, FL, FR, BL, BR, BC, LFE\n    { (143<<16) | 7, 0x037, \"3124567\",  \"\\41\\42\"        },  // FC, FL, FR, BL, BR, [Rls, Rrs]\n    { (144<<16) | 8, 0x137, \"31245786\", \"\\41\\42\"        },  // FC, FL, FR, BL, BR, [Rls, Rrs], BC\n    { (145<<16) | 16, 0x773f, TMH_std,  \"\\43\\44\\54\\45\"  },  // FL, FR, FC, TFC, SL, SR, BL, BR, TFL, TFR, [Lw, Rw, Csd], BC, LFE, [LFE2]\n    { (146<<16) | 21, 0x77ff, TMH_full, \"\\43\\44\\54\\45\"  },  // FL, FR, FC, TFC, SL, SR, BL, BR, TFL, TFR, [Lw, Rw, Csd], BC, LFE, [LFE2],\n                                                            //     FLC, FRC, [HI, VI, Haptic]\n};\n\n#define NUM_LAYOUTS (sizeof (layouts) / sizeof (layouts [0]))\n\nint ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    uint32_t chan_chunk = 0, channel_layout = 0, bcount;\n    unsigned char *channel_identities = NULL;\n    unsigned char *channel_reorder = NULL;\n    int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .caf file we can handle\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n\n            if (debug_logging_mode) {\n                char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n            }\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||\n                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {\n                    error_line (\"this .CAF file has an invalid 'chan' chunk!\");\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);\n\n            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n                        // we allocate (and initialize to invalid values) a channel reorder array\n                        // (even though we might not end up doing any reordering) and a string for\n                        // any non-Microsoft channels we encounter\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n                        // convert the descriptions array to our native endian so it's easy to access\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n                        // first, we go though and find any MS channels present, and move those to the beginning\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n                        // next, we go though the channels again assigning any we haven't done\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n                        // then, go through the reordering array and see if we really have to reorder\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n                            // if debugging, display the reordering as a string (but only little ones)\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n            uint32_t mEditCount;\n\n            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                bcount != sizeof (mEditCount)) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteCaffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    CAFChunkHeader caf_desc_chunk_header, caf_chan_chunk_header, caf_data_chunk_header;\n    CAFChannelLayout caf_channel_layout;\n    CAFAudioFormat caf_audio_format;\n    CAFFileHeader caf_file_header;\n    uint32_t mEditCount, bcount;\n\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int float_norm_exp = WavpackGetFloatNormExp (wpc);\n    uint32_t channel_layout_tag = WavpackGetChannelLayout (wpc, NULL);\n    unsigned char *channel_identities = malloc (num_channels + 1);\n    int num_identified_chans, i;\n\n    if (float_norm_exp && float_norm_exp != 127) {\n        error_line (\"can't create valid CAFF header for non-normalized floating data!\");\n        free (channel_identities);\n        return FALSE;\n    }\n\n    // get the channel identities (including Microsoft) and count up the defined ones\n\n    WavpackGetChannelIdentities (wpc, channel_identities);\n\n    for (num_identified_chans = i = 0; i < num_channels; ++i)\n        if (channel_identities [i] != 0xff)\n            num_identified_chans++;\n\n    // format and write the CAF File Header\n\n    strncpy (caf_file_header.mFileType, \"caff\", sizeof (caf_file_header.mFileType));\n    caf_file_header.mFileVersion = 1;\n    caf_file_header.mFileFlags = 0;\n    WavpackNativeToBigEndian (&caf_file_header, CAFFileHeaderFormat);\n\n    if (!DoWriteFile (outfile, &caf_file_header, sizeof (caf_file_header), &bcount) ||\n        bcount != sizeof (caf_file_header))\n            return FALSE;\n\n    // format and write the Audio Description Chunk\n\n    strncpy (caf_desc_chunk_header.mChunkType, \"desc\", sizeof (caf_desc_chunk_header.mChunkType));\n    caf_desc_chunk_header.mChunkSize = sizeof (caf_audio_format);\n    WavpackNativeToBigEndian (&caf_desc_chunk_header, CAFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &caf_desc_chunk_header, sizeof (caf_desc_chunk_header), &bcount) ||\n        bcount != sizeof (caf_desc_chunk_header))\n            return FALSE;\n\n    caf_audio_format.mSampleRate = (double) sample_rate;\n    strncpy (caf_audio_format.mFormatID, \"lpcm\", sizeof (caf_audio_format.mFormatID));\n    caf_audio_format.mFormatFlags = float_norm_exp ? CAF_FORMAT_FLOAT : 0;\n\n    if (!(qmode & QMODE_BIG_ENDIAN))\n        caf_audio_format.mFormatFlags |= CAF_FORMAT_LITTLE_ENDIAN;\n\n    caf_audio_format.mBytesPerPacket = bytes_per_sample * num_channels;\n    caf_audio_format.mFramesPerPacket = 1;\n    caf_audio_format.mChannelsPerFrame = num_channels;\n    caf_audio_format.mBitsPerChannel = bits_per_sample;\n    WavpackNativeToBigEndian (&caf_audio_format, CAFAudioFormatFormat);\n\n    if (!DoWriteFile (outfile, &caf_audio_format, sizeof (caf_audio_format), &bcount) ||\n        bcount != sizeof (caf_audio_format))\n            return FALSE;\n\n    // we write the Channel Layout Chunk if any of these are true:\n    // 1. a specific CAF layout was specified (100 - 147)\n    // 2. there are more than 2 channels and ANY are defined\n    // 3. there are 1 or 2 channels and NOT regular mono/stereo\n\n    if (channel_layout_tag || (num_channels > 2 ? num_identified_chans : channel_mask != 5 - num_channels)) {\n        int bits = 0, bmask;\n\n        for (bmask = 1; bmask; bmask <<= 1)     // count the set bits in the channel mask\n            if (bmask & channel_mask)\n                ++bits;\n\n        // we use a layout tag if there is a specific CAF layout (100 - 147) or\n        // all the channels are MS defined and in MS order...otherwise we have to\n        // write a full channel description array\n\n        if ((channel_layout_tag & 0xff0000) || (bits == num_channels && !(qmode & QMODE_REORDERED_CHANS))) {\n\n            strncpy (caf_chan_chunk_header.mChunkType, \"chan\", sizeof (caf_chan_chunk_header.mChunkType));\n            caf_chan_chunk_header.mChunkSize = sizeof (caf_channel_layout);\n            WavpackNativeToBigEndian (&caf_chan_chunk_header, CAFChunkHeaderFormat);\n\n            if (!DoWriteFile (outfile, &caf_chan_chunk_header, sizeof (caf_chan_chunk_header), &bcount) ||\n                bcount != sizeof (caf_chan_chunk_header))\n                    return FALSE;\n\n            if (channel_layout_tag) {\n                if (debug_logging_mode)\n                    error_line (\"writing \\\"chan\\\" chunk with layout tag 0x%08x\", channel_layout_tag);\n\n                caf_channel_layout.mChannelLayoutTag = channel_layout_tag;\n                caf_channel_layout.mChannelBitmap = 0;\n            }\n            else {\n                if (debug_logging_mode)\n                    error_line (\"writing \\\"chan\\\" chunk with UseChannelBitmap tag, bitmap = 0x%08x\", channel_mask);\n\n                caf_channel_layout.mChannelLayoutTag = kCAFChannelLayoutTag_UseChannelBitmap;\n                caf_channel_layout.mChannelBitmap = channel_mask;\n            }\n\n            caf_channel_layout.mNumberChannelDescriptions = 0;\n            WavpackNativeToBigEndian (&caf_channel_layout, CAFChannelLayoutFormat);\n\n            if (!DoWriteFile (outfile, &caf_channel_layout, sizeof (caf_channel_layout), &bcount) ||\n                bcount != sizeof (caf_channel_layout))\n                    return FALSE;\n        }\n        else {  // write a channel description array because a single layout or bitmap won't do it...\n            CAFChannelDescription caf_channel_description;\n            unsigned char *new_channel_order = NULL;\n            int i;\n\n            if (debug_logging_mode)\n                error_line (\"writing \\\"chan\\\" chunk with UseChannelDescriptions tag, bitmap = 0x%08x, reordered = %s\",\n                    channel_mask, (qmode & QMODE_REORDERED_CHANS) ? \"yes\" : \"no\");\n\n            if (qmode & QMODE_REORDERED_CHANS) {\n                if ((int)(channel_layout_tag & 0xff) <= num_channels) {\n                    new_channel_order = malloc (num_channels);\n\n                    for (i = 0; i < num_channels; ++i)\n                        new_channel_order [i] = i;\n\n                    WavpackGetChannelLayout (wpc, new_channel_order);\n                }\n            }\n\n            strncpy (caf_chan_chunk_header.mChunkType, \"chan\", sizeof (caf_chan_chunk_header.mChunkType));\n            caf_chan_chunk_header.mChunkSize = sizeof (caf_channel_layout) + sizeof (caf_channel_description) * num_channels;\n            WavpackNativeToBigEndian (&caf_chan_chunk_header, CAFChunkHeaderFormat);\n\n            if (!DoWriteFile (outfile, &caf_chan_chunk_header, sizeof (caf_chan_chunk_header), &bcount) ||\n                bcount != sizeof (caf_chan_chunk_header))\n                    return FALSE;\n\n            caf_channel_layout.mChannelLayoutTag = kCAFChannelLayoutTag_UseChannelDescriptions;\n            caf_channel_layout.mChannelBitmap = 0;\n            caf_channel_layout.mNumberChannelDescriptions = num_channels;\n            WavpackNativeToBigEndian (&caf_channel_layout, CAFChannelLayoutFormat);\n\n            if (!DoWriteFile (outfile, &caf_channel_layout, sizeof (caf_channel_layout), &bcount) ||\n                bcount != sizeof (caf_channel_layout))\n                    return FALSE;\n\n            for (i = 0; i < num_channels; ++i) {\n                unsigned char chan_id = new_channel_order ? channel_identities [new_channel_order [i]] : channel_identities [i];\n                CLEAR (caf_channel_description);\n\n                if ((chan_id >= 1 && chan_id <= 18) || (chan_id >= 33 && chan_id <= 44) || (chan_id >= 200 && chan_id <= 207))\n                    caf_channel_description.mChannelLabel = chan_id;\n                else if (chan_id >= 221 && chan_id <= 225)\n                    caf_channel_description.mChannelLabel = chan_id + 80;\n\n                if (debug_logging_mode)\n                    error_line (\"chan %d --> %d\", i + 1, caf_channel_description.mChannelLabel);\n\n                WavpackNativeToBigEndian (&caf_channel_description, CAFChannelDescriptionFormat);\n\n                if (!DoWriteFile (outfile, &caf_channel_description, sizeof (caf_channel_description), &bcount) ||\n                    bcount != sizeof (caf_channel_description))\n                        return FALSE;\n            }\n\n            if (new_channel_order)\n                free (new_channel_order);\n        }\n    }\n\n    // format and write the Audio Data Chunk\n\n    strncpy (caf_data_chunk_header.mChunkType, \"data\", sizeof (caf_data_chunk_header.mChunkType));\n\n    if (total_samples == -1)\n        caf_data_chunk_header.mChunkSize = -1;\n    else\n        caf_data_chunk_header.mChunkSize = (total_samples * bytes_per_sample * num_channels) + sizeof (mEditCount);\n\n    WavpackNativeToBigEndian (&caf_data_chunk_header, CAFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &caf_data_chunk_header, sizeof (caf_data_chunk_header), &bcount) ||\n        bcount != sizeof (caf_data_chunk_header))\n            return FALSE;\n\n    mEditCount = 0;\n    WavpackNativeToBigEndian (&mEditCount, \"L\");\n\n    if (!DoWriteFile (outfile, &mEditCount, sizeof (mEditCount), &bcount) ||\n        bcount != sizeof (mEditCount))\n            return FALSE;\n\n    free (channel_identities);\n\n    return TRUE;\n}\n"], "fixing_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2019 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// caff.c\n\n// This module is a helper to the WavPack command-line programs to support CAF files.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#ifdef _WIN32\n#define strdup(x) _strdup(x)\n#endif\n\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\ntypedef struct\n{\n    char mFileType [4];\n    uint16_t mFileVersion;\n    uint16_t mFileFlags;\n} CAFFileHeader;\n\n#define CAFFileHeaderFormat \"4SS\"\n\n#pragma pack(push,4)\ntypedef struct\n{\n    char mChunkType [4];\n    int64_t mChunkSize;\n} CAFChunkHeader;\n#pragma pack(pop)\n\n#define CAFChunkHeaderFormat \"4D\"\n\ntypedef struct\n{\n    double mSampleRate;\n    char mFormatID [4];\n    uint32_t mFormatFlags;\n    uint32_t mBytesPerPacket;\n    uint32_t mFramesPerPacket;\n    uint32_t mChannelsPerFrame;\n    uint32_t mBitsPerChannel;\n} CAFAudioFormat;\n\n#define CAFAudioFormatFormat \"D4LLLLL\"\n#define CAF_FORMAT_FLOAT            0x1\n#define CAF_FORMAT_LITTLE_ENDIAN    0x2\n\ntypedef struct\n{\n    uint32_t mChannelLayoutTag;\n    uint32_t mChannelBitmap;\n    uint32_t mNumberChannelDescriptions;\n} CAFChannelLayout;\n\n#define CAFChannelLayoutFormat \"LLL\"\n\nenum {\n    kCAFChannelLayoutTag_UseChannelDescriptions = (0<<16) | 0,  // use the array of AudioChannelDescriptions to define the mapping.\n    kCAFChannelLayoutTag_UseChannelBitmap = (1<<16) | 0,        // use the bitmap to define the mapping.\n};\n\ntypedef struct\n{\n    uint32_t mChannelLabel;\n    uint32_t mChannelFlags;\n    float mCoordinates [3];\n} CAFChannelDescription;\n\n#define CAFChannelDescriptionFormat \"LLLLL\"\n\nstatic const char TMH_full [] = { 1,2,3,13,9,10,5,6,12,14,15,16,17,9,4,18,7,8,19,20,21,0 };\nstatic const char TMH_std [] = { 1,2,3,11,8,9,5,6,10,12,13,14,15,7,4,16,0 };\n\nstatic struct {\n    uint32_t mChannelLayoutTag;     // Core Audio layout, 100 - 146 in high word, num channels in low word\n    uint32_t mChannelBitmap;        // Microsoft standard mask (for those channels that appear)\n    const char *mChannelReorder;    // reorder string if layout is NOT in Microsoft standard order\n    const char *mChannelIdentities; // identities of any channels NOT in Microsoft standard\n} layouts [] = {\n    { (100<<16) | 1, 0x004, NULL,       NULL            },  // FC\n    { (101<<16) | 2, 0x003, NULL,       NULL            },  // FL, FR\n    { (102<<16) | 2, 0x003, NULL,       NULL            },  // FL, FR (headphones)\n    { (103<<16) | 2, 0x000, NULL,       \"\\46\\47\"        },  // [Lt, Rt] (matrix encoded)\n    { (104<<16) | 2, 0x000, NULL,       \"\\314\\315\"      },  // [Mid, Side]\n    { (105<<16) | 2, 0x000, NULL,       \"\\316\\317\"      },  // [X, Y]\n    { (106<<16) | 2, 0x003, NULL,       NULL            },  // FL, FR (binaural)\n    { (107<<16) | 4, 0x000, NULL,       \"\\310\\311\\312\\313\"  },  // [W, X, Y, Z] (ambisonics)\n    { (108<<16) | 4, 0x033, NULL,       NULL            },  // FL, FR, BL, BR (quad)\n    { (109<<16) | 5, 0x037, \"12453\",    NULL            },  // FL, FR, BL, BR, FC (pentagonal)\n    { (110<<16) | 6, 0x137, \"124536\",   NULL            },  // FL, FR, BL, BR, FC, BC (hexagonal)\n    { (111<<16) | 8, 0x737, \"12453678\", NULL            },  // FL, FR, BL, BR, FC, BC, SL, SR (octagonal)\n    { (112<<16) | 8, 0x2d033, NULL,     NULL            },  // FL, FR, BL, BR, TFL, TFR, TBL, TBR (cubic)\n    { (113<<16) | 3, 0x007, NULL,       NULL            },  // FL, FR, FC\n    { (114<<16) | 3, 0x007, \"312\",      NULL            },  // FC, FL, FR\n    { (115<<16) | 4, 0x107, NULL,       NULL            },  // FL, FR, FC, BC\n    { (116<<16) | 4, 0x107, \"3124\",     NULL            },  // FC, FL, FR, BC\n    { (117<<16) | 5, 0x037, NULL,       NULL            },  // FL, FR, FC, BL, BR\n    { (118<<16) | 5, 0x037, \"12453\",    NULL            },  // FL, FR, BL, BR, FC\n    { (119<<16) | 5, 0x037, \"13245\",    NULL            },  // FL, FC, FR, BL, BR\n    { (120<<16) | 5, 0x037, \"31245\",    NULL            },  // FC, FL, FR, BL, BR\n    { (121<<16) | 6, 0x03f, NULL,       NULL            },  // FL, FR, FC, LFE, BL, BR\n    { (122<<16) | 6, 0x03f, \"125634\",   NULL            },  // FL, FR, BL, BR, FC, LFE\n    { (123<<16) | 6, 0x03f, \"132564\",   NULL            },  // FL, FC, FR, BL, BR, LFE\n    { (124<<16) | 6, 0x03f, \"312564\",   NULL            },  // FC, FL, FR, BL, BR, LFE\n    { (125<<16) | 7, 0x13f, NULL,       NULL            },  // FL, FR, FC, LFE, BL, BR, BC\n    { (126<<16) | 8, 0x0ff, NULL,       NULL            },  // FL, FR, FC, LFE, BL, BR, FLC, FRC\n    { (127<<16) | 8, 0x0ff, \"37812564\", NULL            },  // FC, FLC, FRC, FL, FR, BL, BR, LFE\n    { (128<<16) | 8, 0x03f, NULL,       \"\\41\\42\"        },  // FL, FR, FC, LFE, BL, BR, [Rls, Rrs]\n    { (129<<16) | 8, 0x0ff, \"12563478\", NULL            },  // FL, FR, BL, BR, FC, LFE, FLC, FRC\n    { (130<<16) | 8, 0x03f, NULL,       \"\\46\\47\"        },  // FL, FR, FC, LFE, BL, BR, [Lt, Rt]\n    { (131<<16) | 3, 0x103, NULL,       NULL            },  // FL, FR, BC\n    { (132<<16) | 4, 0x033, NULL,       NULL            },  // FL, FR, BL, BR\n    { (133<<16) | 3, 0x00B, NULL,       NULL            },  // FL, FR, LFE\n    { (134<<16) | 4, 0x10B, NULL,       NULL            },  // FL, FR, LFE, BC\n    { (135<<16) | 5, 0x03B, NULL,       NULL            },  // FL, FR, LFE, BL, BR\n    { (136<<16) | 4, 0x00F, NULL,       NULL            },  // FL, FR, FC, LFE\n    { (137<<16) | 5, 0x10f, NULL,       NULL            },  // FL, FR, FC, LFE, BC\n    { (138<<16) | 5, 0x03b, \"12453\",    NULL            },  // FL, FR, BL, BR, LFE\n    { (139<<16) | 6, 0x137, \"124536\",   NULL            },  // FL, FR, BL, BR, FC, BC\n    { (140<<16) | 7, 0x037, \"1245367\",  \"\\41\\42\"        },  // FL, FR, BL, BR, FC, [Rls, Rrs]\n    { (141<<16) | 6, 0x137, \"312456\",   NULL            },  // FC, FL, FR, BL, BR, BC\n    { (142<<16) | 7, 0x13f, \"3125674\",  NULL            },  // FC, FL, FR, BL, BR, BC, LFE\n    { (143<<16) | 7, 0x037, \"3124567\",  \"\\41\\42\"        },  // FC, FL, FR, BL, BR, [Rls, Rrs]\n    { (144<<16) | 8, 0x137, \"31245786\", \"\\41\\42\"        },  // FC, FL, FR, BL, BR, [Rls, Rrs], BC\n    { (145<<16) | 16, 0x773f, TMH_std,  \"\\43\\44\\54\\45\"  },  // FL, FR, FC, TFC, SL, SR, BL, BR, TFL, TFR, [Lw, Rw, Csd], BC, LFE, [LFE2]\n    { (146<<16) | 21, 0x77ff, TMH_full, \"\\43\\44\\54\\45\"  },  // FL, FR, FC, TFC, SL, SR, BL, BR, TFL, TFR, [Lw, Rw, Csd], BC, LFE, [LFE2],\n                                                            //     FLC, FRC, [HI, VI, Haptic]\n};\n\n#define NUM_LAYOUTS (sizeof (layouts) / sizeof (layouts [0]))\n\nint ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;\n    unsigned char *channel_identities = NULL;\n    unsigned char *channel_reorder = NULL;\n    int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .caf file we can handle\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n            desc_chunk = 1;\n\n            if (debug_logging_mode) {\n                char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n            }\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||\n                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {\n                    error_line (\"this .CAF file has an invalid 'chan' chunk!\");\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);\n\n            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n                        // we allocate (and initialize to invalid values) a channel reorder array\n                        // (even though we might not end up doing any reordering) and a string for\n                        // any non-Microsoft channels we encounter\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n                        // convert the descriptions array to our native endian so it's easy to access\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n                        // first, we go though and find any MS channels present, and move those to the beginning\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n                        // next, we go though the channels again assigning any we haven't done\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n                        // then, go through the reordering array and see if we really have to reorder\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n                            // if debugging, display the reordering as a string (but only little ones)\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n            uint32_t mEditCount;\n\n            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                bcount != sizeof (mEditCount)) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteCaffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    CAFChunkHeader caf_desc_chunk_header, caf_chan_chunk_header, caf_data_chunk_header;\n    CAFChannelLayout caf_channel_layout;\n    CAFAudioFormat caf_audio_format;\n    CAFFileHeader caf_file_header;\n    uint32_t mEditCount, bcount;\n\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int float_norm_exp = WavpackGetFloatNormExp (wpc);\n    uint32_t channel_layout_tag = WavpackGetChannelLayout (wpc, NULL);\n    unsigned char *channel_identities = malloc (num_channels + 1);\n    int num_identified_chans, i;\n\n    if (float_norm_exp && float_norm_exp != 127) {\n        error_line (\"can't create valid CAFF header for non-normalized floating data!\");\n        free (channel_identities);\n        return FALSE;\n    }\n\n    // get the channel identities (including Microsoft) and count up the defined ones\n\n    WavpackGetChannelIdentities (wpc, channel_identities);\n\n    for (num_identified_chans = i = 0; i < num_channels; ++i)\n        if (channel_identities [i] != 0xff)\n            num_identified_chans++;\n\n    // format and write the CAF File Header\n\n    strncpy (caf_file_header.mFileType, \"caff\", sizeof (caf_file_header.mFileType));\n    caf_file_header.mFileVersion = 1;\n    caf_file_header.mFileFlags = 0;\n    WavpackNativeToBigEndian (&caf_file_header, CAFFileHeaderFormat);\n\n    if (!DoWriteFile (outfile, &caf_file_header, sizeof (caf_file_header), &bcount) ||\n        bcount != sizeof (caf_file_header))\n            return FALSE;\n\n    // format and write the Audio Description Chunk\n\n    strncpy (caf_desc_chunk_header.mChunkType, \"desc\", sizeof (caf_desc_chunk_header.mChunkType));\n    caf_desc_chunk_header.mChunkSize = sizeof (caf_audio_format);\n    WavpackNativeToBigEndian (&caf_desc_chunk_header, CAFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &caf_desc_chunk_header, sizeof (caf_desc_chunk_header), &bcount) ||\n        bcount != sizeof (caf_desc_chunk_header))\n            return FALSE;\n\n    caf_audio_format.mSampleRate = (double) sample_rate;\n    strncpy (caf_audio_format.mFormatID, \"lpcm\", sizeof (caf_audio_format.mFormatID));\n    caf_audio_format.mFormatFlags = float_norm_exp ? CAF_FORMAT_FLOAT : 0;\n\n    if (!(qmode & QMODE_BIG_ENDIAN))\n        caf_audio_format.mFormatFlags |= CAF_FORMAT_LITTLE_ENDIAN;\n\n    caf_audio_format.mBytesPerPacket = bytes_per_sample * num_channels;\n    caf_audio_format.mFramesPerPacket = 1;\n    caf_audio_format.mChannelsPerFrame = num_channels;\n    caf_audio_format.mBitsPerChannel = bits_per_sample;\n    WavpackNativeToBigEndian (&caf_audio_format, CAFAudioFormatFormat);\n\n    if (!DoWriteFile (outfile, &caf_audio_format, sizeof (caf_audio_format), &bcount) ||\n        bcount != sizeof (caf_audio_format))\n            return FALSE;\n\n    // we write the Channel Layout Chunk if any of these are true:\n    // 1. a specific CAF layout was specified (100 - 147)\n    // 2. there are more than 2 channels and ANY are defined\n    // 3. there are 1 or 2 channels and NOT regular mono/stereo\n\n    if (channel_layout_tag || (num_channels > 2 ? num_identified_chans : channel_mask != 5 - num_channels)) {\n        int bits = 0, bmask;\n\n        for (bmask = 1; bmask; bmask <<= 1)     // count the set bits in the channel mask\n            if (bmask & channel_mask)\n                ++bits;\n\n        // we use a layout tag if there is a specific CAF layout (100 - 147) or\n        // all the channels are MS defined and in MS order...otherwise we have to\n        // write a full channel description array\n\n        if ((channel_layout_tag & 0xff0000) || (bits == num_channels && !(qmode & QMODE_REORDERED_CHANS))) {\n\n            strncpy (caf_chan_chunk_header.mChunkType, \"chan\", sizeof (caf_chan_chunk_header.mChunkType));\n            caf_chan_chunk_header.mChunkSize = sizeof (caf_channel_layout);\n            WavpackNativeToBigEndian (&caf_chan_chunk_header, CAFChunkHeaderFormat);\n\n            if (!DoWriteFile (outfile, &caf_chan_chunk_header, sizeof (caf_chan_chunk_header), &bcount) ||\n                bcount != sizeof (caf_chan_chunk_header))\n                    return FALSE;\n\n            if (channel_layout_tag) {\n                if (debug_logging_mode)\n                    error_line (\"writing \\\"chan\\\" chunk with layout tag 0x%08x\", channel_layout_tag);\n\n                caf_channel_layout.mChannelLayoutTag = channel_layout_tag;\n                caf_channel_layout.mChannelBitmap = 0;\n            }\n            else {\n                if (debug_logging_mode)\n                    error_line (\"writing \\\"chan\\\" chunk with UseChannelBitmap tag, bitmap = 0x%08x\", channel_mask);\n\n                caf_channel_layout.mChannelLayoutTag = kCAFChannelLayoutTag_UseChannelBitmap;\n                caf_channel_layout.mChannelBitmap = channel_mask;\n            }\n\n            caf_channel_layout.mNumberChannelDescriptions = 0;\n            WavpackNativeToBigEndian (&caf_channel_layout, CAFChannelLayoutFormat);\n\n            if (!DoWriteFile (outfile, &caf_channel_layout, sizeof (caf_channel_layout), &bcount) ||\n                bcount != sizeof (caf_channel_layout))\n                    return FALSE;\n        }\n        else {  // write a channel description array because a single layout or bitmap won't do it...\n            CAFChannelDescription caf_channel_description;\n            unsigned char *new_channel_order = NULL;\n            int i;\n\n            if (debug_logging_mode)\n                error_line (\"writing \\\"chan\\\" chunk with UseChannelDescriptions tag, bitmap = 0x%08x, reordered = %s\",\n                    channel_mask, (qmode & QMODE_REORDERED_CHANS) ? \"yes\" : \"no\");\n\n            if (qmode & QMODE_REORDERED_CHANS) {\n                if ((int)(channel_layout_tag & 0xff) <= num_channels) {\n                    new_channel_order = malloc (num_channels);\n\n                    for (i = 0; i < num_channels; ++i)\n                        new_channel_order [i] = i;\n\n                    WavpackGetChannelLayout (wpc, new_channel_order);\n                }\n            }\n\n            strncpy (caf_chan_chunk_header.mChunkType, \"chan\", sizeof (caf_chan_chunk_header.mChunkType));\n            caf_chan_chunk_header.mChunkSize = sizeof (caf_channel_layout) + sizeof (caf_channel_description) * num_channels;\n            WavpackNativeToBigEndian (&caf_chan_chunk_header, CAFChunkHeaderFormat);\n\n            if (!DoWriteFile (outfile, &caf_chan_chunk_header, sizeof (caf_chan_chunk_header), &bcount) ||\n                bcount != sizeof (caf_chan_chunk_header))\n                    return FALSE;\n\n            caf_channel_layout.mChannelLayoutTag = kCAFChannelLayoutTag_UseChannelDescriptions;\n            caf_channel_layout.mChannelBitmap = 0;\n            caf_channel_layout.mNumberChannelDescriptions = num_channels;\n            WavpackNativeToBigEndian (&caf_channel_layout, CAFChannelLayoutFormat);\n\n            if (!DoWriteFile (outfile, &caf_channel_layout, sizeof (caf_channel_layout), &bcount) ||\n                bcount != sizeof (caf_channel_layout))\n                    return FALSE;\n\n            for (i = 0; i < num_channels; ++i) {\n                unsigned char chan_id = new_channel_order ? channel_identities [new_channel_order [i]] : channel_identities [i];\n                CLEAR (caf_channel_description);\n\n                if ((chan_id >= 1 && chan_id <= 18) || (chan_id >= 33 && chan_id <= 44) || (chan_id >= 200 && chan_id <= 207))\n                    caf_channel_description.mChannelLabel = chan_id;\n                else if (chan_id >= 221 && chan_id <= 225)\n                    caf_channel_description.mChannelLabel = chan_id + 80;\n\n                if (debug_logging_mode)\n                    error_line (\"chan %d --> %d\", i + 1, caf_channel_description.mChannelLabel);\n\n                WavpackNativeToBigEndian (&caf_channel_description, CAFChannelDescriptionFormat);\n\n                if (!DoWriteFile (outfile, &caf_channel_description, sizeof (caf_channel_description), &bcount) ||\n                    bcount != sizeof (caf_channel_description))\n                        return FALSE;\n            }\n\n            if (new_channel_order)\n                free (new_channel_order);\n        }\n    }\n\n    // format and write the Audio Data Chunk\n\n    strncpy (caf_data_chunk_header.mChunkType, \"data\", sizeof (caf_data_chunk_header.mChunkType));\n\n    if (total_samples == -1)\n        caf_data_chunk_header.mChunkSize = -1;\n    else\n        caf_data_chunk_header.mChunkSize = (total_samples * bytes_per_sample * num_channels) + sizeof (mEditCount);\n\n    WavpackNativeToBigEndian (&caf_data_chunk_header, CAFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &caf_data_chunk_header, sizeof (caf_data_chunk_header), &bcount) ||\n        bcount != sizeof (caf_data_chunk_header))\n            return FALSE;\n\n    mEditCount = 0;\n    WavpackNativeToBigEndian (&mEditCount, \"L\");\n\n    if (!DoWriteFile (outfile, &mEditCount, sizeof (mEditCount), &bcount) ||\n        bcount != sizeof (mEditCount))\n            return FALSE;\n\n    free (channel_identities);\n\n    return TRUE;\n}\n"], "filenames": ["cli/caff.c"], "buggy_code_start_loc": [155], "buggy_code_end_loc": [462], "fixing_code_start_loc": [155], "fixing_code_end_loc": [463], "type": "CWE-908", "message": "WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseCaffHeaderConfig (caff.c:486). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b.", "other": {"cve": {"id": "CVE-2019-1010317", "sourceIdentifier": "josh@bress.net", "published": "2019-07-11T20:15:12.227", "lastModified": "2022-10-06T18:02:02.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseCaffHeaderConfig (caff.c:486). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b."}, {"lang": "es", "value": "WavPack versiones 5.1.0 y anteriores, esta afectado por: CWE-457: Uso de Variable No Inicializada. El impacto es: Flujo de control inesperado, bloqueos y fallo de segmentaci\u00f3n. El componente es: ParseCaffHeaderConfig (en el archivo caff.c:486). El vector de ataque es: archivo .wav malicioso. La versi\u00f3n corregida es: Despu\u00e9s del commit https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}, {"source": "josh@bress.net", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-457"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wavpack:wavpack:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.1.0", "matchCriteriaId": "A5AF1FF6-17E5-429C-8280-8215E7010571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/66", "source": "josh@bress.net", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/01/msg00013.html", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6CFFFWIWALGQPKINRDW3PRGRD5LOLGZA/", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BRWQNE3TH5UF64IKHKKHVCHJHUOVKJUH/", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IX3J2JML5A7KC2BLGBEFTIIZR3EM7LVJ/", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PYESOAZ6Z6IG4BQBURL6OUY6P4YB6SKS/", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4062-1/", "source": "josh@bress.net", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b"}}