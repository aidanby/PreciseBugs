{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n\tOPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n\tOPJ_UINT32 bfSize;      /* Size of the file        */\n\tOPJ_UINT16 bfReserved1; /* Reserved : 0            */\n\tOPJ_UINT16 bfReserved2; /* Reserved : 0            */\n\tOPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n\tOPJ_UINT32 biSize;             /* Size of the structure in bytes */\n\tOPJ_UINT32 biWidth;            /* Width of the image in pixels */\n\tOPJ_UINT32 biHeight;           /* Heigth of the image in pixels */\n\tOPJ_UINT16 biPlanes;           /* 1 */\n\tOPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n\tOPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n\tOPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n\tOPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n\tOPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n\tOPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n\tOPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n\tOPJ_UINT32 biRedMask;          /* Red channel bit mask */\n\tOPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n\tOPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n\tOPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n\tOPJ_UINT32 biColorSpaceType;   /* Color space type */\n\tOPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n\tOPJ_UINT32 biRedGamma;         /* Red channel gamma */\n\tOPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n\tOPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n\tOPJ_UINT32 biIntent;           /* Intent */\n\tOPJ_UINT32 biIccProfileData;   /* ICC profile data */\n\tOPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n\tOPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* pDst, OPJ_INT32 dstStride,\n\tOPJ_UINT8 const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tpDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpDst += dstStride;\n\t}\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n\tOPJ_UINT8 const* const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\tOPJ_INT32* pR = pDst[0];\n\tOPJ_INT32* pG = pDst[1];\n\tOPJ_INT32* pB = pDst[2];\n\tOPJ_UINT8 const* pLUT_R = pLUT[0];\n\tOPJ_UINT8 const* pLUT_G = pLUT[1];\n\tOPJ_UINT8 const* pLUT_B = pLUT[2];\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT8 idx = pSrc[x];\n\t\t\tpR[x] = (OPJ_INT32)pLUT_R[idx];\n\t\t\tpG[x] = (OPJ_INT32)pLUT_G[idx];\n\t\t\tpB[x] = (OPJ_INT32)pLUT_B[idx];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpR += pDstStride[0];\n\t\tpG += pDstStride[1];\n\t\tpB += pDstStride[2];\n\t}\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)pSrc[3*x+2];\t/* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)pSrc[3*x+1];\t/* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)pSrc[3*x+0];\t/* B */\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)\n{\n\tOPJ_UINT32 l_shift, l_prec;\n\t\n\tl_shift = l_prec = 0U;\n\t\n\tif (mask != 0U) {\n\t\twhile ((mask & 1U) == 0U) {\n\t\t\tmask >>= 1;\n\t\t\tl_shift++;\n\t\t}\n\t\twhile (mask & 1U) {\n\t\t\tmask >>= 1;\n\t\t\tl_prec++;\n\t\t}\n\t}\n\t*shift = l_shift; *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+1]) <<  8;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+2]) << 16;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+3]) << 24;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+1]) <<  8;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n\tOPJ_UINT32 width, height;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tpSrc = pData + (height - 1U) * stride;\n\tif (image->numcomps == 1U) {\n\t\topj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);\n\t}\n\telse {\n\t\tOPJ_INT32* pDst[3];\n\t\tOPJ_INT32  pDstStride[3];\n\t\t\n\t\tpDst[0] = image->comps[0].data; pDst[1] = image->comps[1].data; pDst[2] = image->comps[2].data;\n\t\tpDstStride[0] = (OPJ_INT32)width; pDstStride[1] = (OPJ_INT32)width; pDstStride[2] = (OPJ_INT32)width;\n\t\topj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT, width, height);\n\t}\n\treturn image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n\theader->bfType  = (OPJ_UINT16)getc(IN);\n\theader->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif (header->bfType != 19778) {\n\t\tfprintf(stderr,\"Error, not a BMP file!\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t/* FILE HEADER */\n\t/* ------------- */\n\theader->bfSize  = (OPJ_UINT32)getc(IN);\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->bfReserved1  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfReserved2  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfOffBits  = (OPJ_UINT32)getc(IN);\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n\treturn OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n\tmemset(header, 0, sizeof(*header));\n\t/* INFO HEADER */\n\t/* ------------- */\n\theader->biSize  = (OPJ_UINT32)getc(IN);\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\tswitch (header->biSize) {\n\t\tcase 12U:  /* BITMAPCOREHEADER */\n\t\tcase 40U:  /* BITMAPINFOHEADER */\n\t\tcase 52U:  /* BITMAPV2INFOHEADER */\n\t\tcase 56U:  /* BITMAPV3INFOHEADER */\n\t\tcase 108U: /* BITMAPV4HEADER */\n\t\tcase 124U: /* BITMAPV5HEADER */\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr,\"Error, unknown BMP header size %d\\n\", header->biSize);\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\theader->biWidth  = (OPJ_UINT32)getc(IN);\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biHeight  = (OPJ_UINT32)getc(IN);\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biPlanes  = (OPJ_UINT16)getc(IN);\n\theader->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->biBitCount  = (OPJ_UINT16)getc(IN);\n\theader->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif(header->biSize >= 40U) {\n\t\theader->biCompression  = (OPJ_UINT32)getc(IN);\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biSizeImage  = (OPJ_UINT32)getc(IN);\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrUsed  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrImportant  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 56U) {\n\t\theader->biRedMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biAlphaMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 108U) {\n\t\theader->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\tif (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP), IN) != sizeof(header->biColorSpaceEP)) {\n\t\t\tfprintf(stderr,\"Error, can't  read BMP header\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\theader->biRedGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 124U) {\n\t\theader->biIntent  = (OPJ_UINT32)getc(IN);\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileData  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biReserved  = (OPJ_UINT32)getc(IN);\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_ARG_NOT_USED(width);\n\t\n\tif ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )\n\t{\n\t\tfprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\t\n\tx = y = 0U;\n\twhile (y < height)\n\t{\n\t\tint c = getc(IN);\n\t\t\n\t\tif (c) {\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = c1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tc = getc(IN);\n\t\t\tif (c == 0x00) { /* EOL */\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse if (c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);\n\t\t\t\tx += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);\n\t\t\t\ty += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse /* 03 .. 255 */\n\t\t\t{\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++)\n\t\t\t\t{\n\t\t\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t*pix = c1;\n\t\t\t\t}\n\t\t\t\tif ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/* while() */\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\tx = y = 0U;\n\twhile(y < height)\n\t{\n\t\tint c = getc(IN);\n\t\tif(c == EOF) break;\n\t\t\n\t\tif(c) {/* encoded mode */\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t}\n\t\t}\n\t\telse { /* absolute mode */\n\t\t\tc = getc(IN);\n\t\t\tif(c == EOF) break;\n\t\t\n\t\t\tif(c == 0x00) { /* EOL */\n\t\t\t\tx = 0;  y++;  pix = pData + y * stride;\n\t\t\t}\n\t\t\telse if(c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);  x += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);  y += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse { /* 03 .. 255 : absolute mode */\n\t\t\t\tint j;\n\t\t\t\tOPJ_UINT8 c1 = 0U;\n\t\t\t\t\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t\tif((j&1) == 0) {\n\t\t\t\t\t\t\tc1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t}\n\t\t\t\t\t*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t\t}\n\t\t\t\tif(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */\n\t\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  /* while(y < height) */\n\treturn OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\topj_image_cmptparm_t cmptparm[4];\t/* maximum of 4 components */\n\tOPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n\tOPJ_UINT8 const* pLUT[3];\n\topj_image_t * image = NULL;\n\tFILE *IN;\n\tOPJ_BITMAPFILEHEADER File_h;\n\tOPJ_BITMAPINFOHEADER Info_h;\n\tOPJ_UINT32 i, palette_len, numcmpts = 1U;\n\tOPJ_BOOL l_result = OPJ_FALSE;\n\tOPJ_UINT8* pData = NULL;\n\tOPJ_UINT32 stride;\n\t\n\tpLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;\n\t\n\tIN = fopen(filename, \"rb\");\n\tif (!IN)\n\t{\n\t\tfprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n\t\treturn NULL;\n\t}\n\n\tif (!bmp_read_file_header(IN, &File_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tif (!bmp_read_info_header(IN, &Info_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* Load palette */\n\tif (Info_h.biBitCount <= 8U)\n\t{\n\t\tmemset(&lut_R[0], 0, sizeof(lut_R));\n\t\tmemset(&lut_G[0], 0, sizeof(lut_G));\n\t\tmemset(&lut_B[0], 0, sizeof(lut_B));\n\t\t\n\t\tpalette_len = Info_h.biClrUsed;\n\t\tif((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n\t\t\tpalette_len = (1U << Info_h.biBitCount);\n\t\t}\n\t\tif (palette_len > 256U) {\n\t\t\tpalette_len = 256U;\n\t\t}\n\t\tif (palette_len > 0U) {\n\t\t\tOPJ_UINT8 has_color = 0U;\n\t\t\tfor (i = 0U; i < palette_len; i++) {\n\t\t\t\tlut_B[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_G[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_R[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\t(void)getc(IN); /* padding */\n\t\t\t\thas_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n\t\t\t}\n\t\t\tif(has_color) {\n\t\t\t\tnumcmpts = 3U;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnumcmpts = 3U;\n\t\tif ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n\t\t\tnumcmpts++;\n\t\t}\n\t}\n\t\n\tstride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */\n\tif (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n\t\tstride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n\t}\n\tpData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n\tif (pData == NULL) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t/* Place the cursor at the beginning of the image information */\n\tfseek(IN, 0, SEEK_SET);\n\tfseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\t\n\tswitch (Info_h.biCompression) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\t/* read raw data */\n\t\t\tl_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* read rle8 data */\n\t\t\tl_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* read rle4 data */\n\t\t\tl_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr, \"Unsupported BMP compression\\n\");\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t}\n\tif (!l_result) {\n\t\tfree(pData);\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* create the image */\n\tmemset(&cmptparm[0], 0, sizeof(cmptparm));\n\tfor(i = 0; i < 4U; i++)\n\t{\n\t\tcmptparm[i].prec = 8;\n\t\tcmptparm[i].bpp  = 8;\n\t\tcmptparm[i].sgnd = 0;\n\t\tcmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n\t\tcmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n\t\tcmptparm[i].w    = Info_h.biWidth;\n\t\tcmptparm[i].h    = Info_h.biHeight;\n\t}\n\n\timage = opj_image_create(numcmpts, &cmptparm[0], (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n\tif(!image) {\n\t\tfclose(IN);\n\t\tfree(pData);\n\t\treturn NULL;\n\t}\n\tif (numcmpts == 4U) {\n\t\timage->comps[3].alpha = 1;\n\t}\n\t\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\timage->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)parameters->subsampling_dx + 1U;\n\timage->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)parameters->subsampling_dy + 1U;\n\t\n\t/* Read the data */\n\tif (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n\t\tbmp24toimage(pData, stride, image);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n\t\tbmp8toimage(pData, stride, image, pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU, 0x00000000U);\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n\t\tbmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n\t\tif ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) && (Info_h.biBlueMask == 0U)) {\n\t\t\tInfo_h.biRedMask   = 0xF800U;\n\t\t\tInfo_h.biGreenMask = 0x07E0U;\n\t\t\tInfo_h.biBlueMask  = 0x001FU;\n\t\t}\n\t\tbmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse {\n\t\topj_image_destroy(image);\n\t\timage = NULL;\n\t\tfprintf(stderr, \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\", Info_h.biBitCount);\n\t}\n\tfree(pData);\n\tfclose(IN);\n\treturn image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile) {\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }\n        else\n            adjustR = 0;\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\", image->comps[1].prec);\n        }\n        else\n            adjustG = 0;\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\", image->comps[2].prec);\n        }\n        else\n            adjustB = 0;\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            g = ((g >> adjustG)+((g >> (adjustG-1))%2));\n            if(g > 255) g = 255; else if(g < 0) g = 0;\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            b = ((b >> adjustB)+((b >> (adjustB-1))%2));\n            if(b > 255) b = 255; else if(b < 0) b = 0;\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    } else {\t\t\t/* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }else\n            adjustR = 0;\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n\tOPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n\tOPJ_UINT32 bfSize;      /* Size of the file        */\n\tOPJ_UINT16 bfReserved1; /* Reserved : 0            */\n\tOPJ_UINT16 bfReserved2; /* Reserved : 0            */\n\tOPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n\tOPJ_UINT32 biSize;             /* Size of the structure in bytes */\n\tOPJ_UINT32 biWidth;            /* Width of the image in pixels */\n\tOPJ_UINT32 biHeight;           /* Heigth of the image in pixels */\n\tOPJ_UINT16 biPlanes;           /* 1 */\n\tOPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n\tOPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n\tOPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n\tOPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n\tOPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n\tOPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n\tOPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n\tOPJ_UINT32 biRedMask;          /* Red channel bit mask */\n\tOPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n\tOPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n\tOPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n\tOPJ_UINT32 biColorSpaceType;   /* Color space type */\n\tOPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n\tOPJ_UINT32 biRedGamma;         /* Red channel gamma */\n\tOPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n\tOPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n\tOPJ_UINT32 biIntent;           /* Intent */\n\tOPJ_UINT32 biIccProfileData;   /* ICC profile data */\n\tOPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n\tOPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* pDst, OPJ_INT32 dstStride,\n\tOPJ_UINT8 const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tpDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpDst += dstStride;\n\t}\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n\tOPJ_UINT8 const* const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\tOPJ_INT32* pR = pDst[0];\n\tOPJ_INT32* pG = pDst[1];\n\tOPJ_INT32* pB = pDst[2];\n\tOPJ_UINT8 const* pLUT_R = pLUT[0];\n\tOPJ_UINT8 const* pLUT_G = pLUT[1];\n\tOPJ_UINT8 const* pLUT_B = pLUT[2];\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT8 idx = pSrc[x];\n\t\t\tpR[x] = (OPJ_INT32)pLUT_R[idx];\n\t\t\tpG[x] = (OPJ_INT32)pLUT_G[idx];\n\t\t\tpB[x] = (OPJ_INT32)pLUT_B[idx];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpR += pDstStride[0];\n\t\tpG += pDstStride[1];\n\t\tpB += pDstStride[2];\n\t}\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)pSrc[3*x+2];\t/* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)pSrc[3*x+1];\t/* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)pSrc[3*x+0];\t/* B */\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)\n{\n\tOPJ_UINT32 l_shift, l_prec;\n\t\n\tl_shift = l_prec = 0U;\n\t\n\tif (mask != 0U) {\n\t\twhile ((mask & 1U) == 0U) {\n\t\t\tmask >>= 1;\n\t\t\tl_shift++;\n\t\t}\n\t\twhile (mask & 1U) {\n\t\t\tmask >>= 1;\n\t\t\tl_prec++;\n\t\t}\n\t}\n\t*shift = l_shift; *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+1]) <<  8;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+2]) << 16;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+3]) << 24;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+1]) <<  8;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n\tOPJ_UINT32 width, height;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tpSrc = pData + (height - 1U) * stride;\n\tif (image->numcomps == 1U) {\n\t\topj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);\n\t}\n\telse {\n\t\tOPJ_INT32* pDst[3];\n\t\tOPJ_INT32  pDstStride[3];\n\t\t\n\t\tpDst[0] = image->comps[0].data; pDst[1] = image->comps[1].data; pDst[2] = image->comps[2].data;\n\t\tpDstStride[0] = (OPJ_INT32)width; pDstStride[1] = (OPJ_INT32)width; pDstStride[2] = (OPJ_INT32)width;\n\t\topj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT, width, height);\n\t}\n\treturn image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n\theader->bfType  = (OPJ_UINT16)getc(IN);\n\theader->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif (header->bfType != 19778) {\n\t\tfprintf(stderr,\"Error, not a BMP file!\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t/* FILE HEADER */\n\t/* ------------- */\n\theader->bfSize  = (OPJ_UINT32)getc(IN);\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->bfReserved1  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfReserved2  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfOffBits  = (OPJ_UINT32)getc(IN);\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n\treturn OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n\tmemset(header, 0, sizeof(*header));\n\t/* INFO HEADER */\n\t/* ------------- */\n\theader->biSize  = (OPJ_UINT32)getc(IN);\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\tswitch (header->biSize) {\n\t\tcase 12U:  /* BITMAPCOREHEADER */\n\t\tcase 40U:  /* BITMAPINFOHEADER */\n\t\tcase 52U:  /* BITMAPV2INFOHEADER */\n\t\tcase 56U:  /* BITMAPV3INFOHEADER */\n\t\tcase 108U: /* BITMAPV4HEADER */\n\t\tcase 124U: /* BITMAPV5HEADER */\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr,\"Error, unknown BMP header size %d\\n\", header->biSize);\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\theader->biWidth  = (OPJ_UINT32)getc(IN);\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biHeight  = (OPJ_UINT32)getc(IN);\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biPlanes  = (OPJ_UINT16)getc(IN);\n\theader->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->biBitCount  = (OPJ_UINT16)getc(IN);\n\theader->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif(header->biSize >= 40U) {\n\t\theader->biCompression  = (OPJ_UINT32)getc(IN);\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biSizeImage  = (OPJ_UINT32)getc(IN);\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrUsed  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrImportant  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 56U) {\n\t\theader->biRedMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biAlphaMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 108U) {\n\t\theader->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\tif (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP), IN) != sizeof(header->biColorSpaceEP)) {\n\t\t\tfprintf(stderr,\"Error, can't  read BMP header\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\theader->biRedGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 124U) {\n\t\theader->biIntent  = (OPJ_UINT32)getc(IN);\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileData  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biReserved  = (OPJ_UINT32)getc(IN);\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_ARG_NOT_USED(width);\n\t\n\tif ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )\n\t{\n\t\tfprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\t\n\tx = y = 0U;\n\twhile (y < height)\n\t{\n\t\tint c = getc(IN);\n\t\t\n\t\tif (c) {\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = c1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tc = getc(IN);\n\t\t\tif (c == 0x00) { /* EOL */\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse if (c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);\n\t\t\t\tx += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);\n\t\t\t\ty += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse /* 03 .. 255 */\n\t\t\t{\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++)\n\t\t\t\t{\n\t\t\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t*pix = c1;\n\t\t\t\t}\n\t\t\t\tif ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/* while() */\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\tx = y = 0U;\n\twhile(y < height)\n\t{\n\t\tint c = getc(IN);\n\t\tif(c == EOF) break;\n\t\t\n\t\tif(c) {/* encoded mode */\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t}\n\t\t}\n\t\telse { /* absolute mode */\n\t\t\tc = getc(IN);\n\t\t\tif(c == EOF) break;\n\t\t\n\t\t\tif(c == 0x00) { /* EOL */\n\t\t\t\tx = 0;  y++;  pix = pData + y * stride;\n\t\t\t}\n\t\t\telse if(c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);  x += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);  y += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse { /* 03 .. 255 : absolute mode */\n\t\t\t\tint j;\n\t\t\t\tOPJ_UINT8 c1 = 0U;\n\t\t\t\t\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t\tif((j&1) == 0) {\n\t\t\t\t\t\t\tc1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t}\n\t\t\t\t\t*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t\t}\n\t\t\t\tif(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */\n\t\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  /* while(y < height) */\n\treturn OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\topj_image_cmptparm_t cmptparm[4];\t/* maximum of 4 components */\n\tOPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n\tOPJ_UINT8 const* pLUT[3];\n\topj_image_t * image = NULL;\n\tFILE *IN;\n\tOPJ_BITMAPFILEHEADER File_h;\n\tOPJ_BITMAPINFOHEADER Info_h;\n\tOPJ_UINT32 i, palette_len, numcmpts = 1U;\n\tOPJ_BOOL l_result = OPJ_FALSE;\n\tOPJ_UINT8* pData = NULL;\n\tOPJ_UINT32 stride;\n\t\n\tpLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;\n\t\n\tIN = fopen(filename, \"rb\");\n\tif (!IN)\n\t{\n\t\tfprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n\t\treturn NULL;\n\t}\n\n\tif (!bmp_read_file_header(IN, &File_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tif (!bmp_read_info_header(IN, &Info_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* Load palette */\n\tif (Info_h.biBitCount <= 8U)\n\t{\n\t\tmemset(&lut_R[0], 0, sizeof(lut_R));\n\t\tmemset(&lut_G[0], 0, sizeof(lut_G));\n\t\tmemset(&lut_B[0], 0, sizeof(lut_B));\n\t\t\n\t\tpalette_len = Info_h.biClrUsed;\n\t\tif((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n\t\t\tpalette_len = (1U << Info_h.biBitCount);\n\t\t}\n\t\tif (palette_len > 256U) {\n\t\t\tpalette_len = 256U;\n\t\t}\n\t\tif (palette_len > 0U) {\n\t\t\tOPJ_UINT8 has_color = 0U;\n\t\t\tfor (i = 0U; i < palette_len; i++) {\n\t\t\t\tlut_B[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_G[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_R[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\t(void)getc(IN); /* padding */\n\t\t\t\thas_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n\t\t\t}\n\t\t\tif(has_color) {\n\t\t\t\tnumcmpts = 3U;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnumcmpts = 3U;\n\t\tif ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n\t\t\tnumcmpts++;\n\t\t}\n\t}\n\t\n\tif (Info_h.biWidth == 0 || Info_h.biHeight == 0) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\tif (Info_h.biBitCount > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tstride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */\n\tif (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n\t\tif (8 > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {\n\t\t\tfclose(IN);\n\t\t\treturn NULL;\n\t\t}\n\t\tstride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n\t}\n\t\n\tif (stride > ((OPJ_UINT32)-1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tpData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n\tif (pData == NULL) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t/* Place the cursor at the beginning of the image information */\n\tfseek(IN, 0, SEEK_SET);\n\tfseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\t\n\tswitch (Info_h.biCompression) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\t/* read raw data */\n\t\t\tl_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* read rle8 data */\n\t\t\tl_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* read rle4 data */\n\t\t\tl_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr, \"Unsupported BMP compression\\n\");\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t}\n\tif (!l_result) {\n\t\tfree(pData);\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* create the image */\n\tmemset(&cmptparm[0], 0, sizeof(cmptparm));\n\tfor(i = 0; i < 4U; i++)\n\t{\n\t\tcmptparm[i].prec = 8;\n\t\tcmptparm[i].bpp  = 8;\n\t\tcmptparm[i].sgnd = 0;\n\t\tcmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n\t\tcmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n\t\tcmptparm[i].w    = Info_h.biWidth;\n\t\tcmptparm[i].h    = Info_h.biHeight;\n\t}\n\n\timage = opj_image_create(numcmpts, &cmptparm[0], (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n\tif(!image) {\n\t\tfclose(IN);\n\t\tfree(pData);\n\t\treturn NULL;\n\t}\n\tif (numcmpts == 4U) {\n\t\timage->comps[3].alpha = 1;\n\t}\n\t\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\timage->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)parameters->subsampling_dx + 1U;\n\timage->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)parameters->subsampling_dy + 1U;\n\t\n\t/* Read the data */\n\tif (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n\t\tbmp24toimage(pData, stride, image);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n\t\tbmp8toimage(pData, stride, image, pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU, 0x00000000U);\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n\t\tbmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n\t\tif ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) && (Info_h.biBlueMask == 0U)) {\n\t\t\tInfo_h.biRedMask   = 0xF800U;\n\t\t\tInfo_h.biGreenMask = 0x07E0U;\n\t\t\tInfo_h.biBlueMask  = 0x001FU;\n\t\t}\n\t\tbmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse {\n\t\topj_image_destroy(image);\n\t\timage = NULL;\n\t\tfprintf(stderr, \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\", Info_h.biBitCount);\n\t}\n\tfree(pData);\n\tfclose(IN);\n\treturn image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile) {\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }\n        else\n            adjustR = 0;\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\", image->comps[1].prec);\n        }\n        else\n            adjustG = 0;\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\", image->comps[2].prec);\n        }\n        else\n            adjustB = 0;\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            g = ((g >> adjustG)+((g >> (adjustG-1))%2));\n            if(g > 255) g = 255; else if(g < 0) g = 0;\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            b = ((b >> adjustB)+((b >> (adjustB-1))%2));\n            if(b > 255) b = 255; else if(b < 0) b = 0;\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    } else {\t\t\t/* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }else\n            adjustR = 0;\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n"], "filenames": ["src/bin/jp2/convertbmp.c"], "buggy_code_start_loc": [677], "buggy_code_end_loc": [680], "fixing_code_start_loc": [678], "fixing_code_end_loc": [699], "type": "CWE-190", "message": "Integer overflow vulnerability in the bmp24toimage function in convertbmp.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted bmp file.", "other": {"cve": {"id": "CVE-2016-10507", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-30T09:29:00.387", "lastModified": "2020-09-09T19:57:18.373", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in the bmp24toimage function in convertbmp.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted bmp file."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de enteros en la funci\u00f3n bmp24toimage de convertbmp.c en OpenJPEG en versiones anteriores a la 2.2.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer basada en mont\u00edculos y fallo de aplicaci\u00f3n) mediante un archivo bmp manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.2", "matchCriteriaId": "2A0A42B9-5905-4F51-8513-59CDC67CF06E"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100567", "source": "cve@mitre.org"}, {"url": "https://github.com/uclouvain/openjpeg/commit/da940424816e11d624362ce080bc026adffa26e8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/833", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-26", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/da940424816e11d624362ce080bc026adffa26e8"}}