{"buggy_code": ["# Changelog\n\n- Protocol-relative URLs are properly supported for script tags\n\n## 2.7.0 (2022-02-04)\n\n- Allows a more sensible set of default attributes on `<img />` tags. Thanks to [Zade Viggers](https://github.com/zadeviggers).\n\n## 2.6.1 (2021-12-08)\n\n- Fixes style filtering to retain `!important` when used.\n- Fixed trailing text bug on `transformTags` options that was reported on [issue #506](https://github.com/apostrophecms/sanitize-html/issues/506). Thanks to [Alex Rantos](https://github.com/alex-rantos).\n\n## 2.6.0 (2021-11-23)\n\n- Support for regular expressions in the `allowedClasses` option. Thanks to [Alex Rantos](https://github.com/alex-rantos).\n\n## 2.5.3 (2021-11-02):\n\n- Fixed bug introduced by klona 2.0.5, by removing klona entirely.\n\n## 2.5.2 (2021-10-13):\n\n- Nullish HTML input now returns an empty string. Nullish value may be explicit `null`, `undefined` or implicit `undefined` when value is not provided. Thanks to Artem Kostiuk for the contribution.\n- Documented that all text content is escaped. Thanks to Siddharth Singh.\n\n## 2.5.1 (2021-09-14):\n- The `allowedScriptHostnames` and `allowedScriptDomains` options now implicitly purge the inline content of all script tags, not just those with `src` attributes. This behavior was already strongly implied by the fact that they purged it in the case where a `src` attribute was actually present, and is necessary for the feature to provide any real security. Thanks to Grigorii Duca for pointing out the issue.\n\n## 2.5.0 (2021-09-08):\n\n- New `allowedScriptHostnames` option, it enables you to specify which hostnames are allowed in a script tag.\n- New `allowedScriptDomains` option, it enables you to specify which domains are allowed in a script tag. Thank you to [Yorick Girard](https://github.com/yorickgirard) for this and the `allowedScriptHostnames` contribution.\n- Updates whitelist to allowlist.\n\n## 2.4.0 (2021-05-19):\n- Added support for class names with wildcards in `allowedClasses`. Thanks to [zhangbenber](https://github.com/zhangbenber) for the contribution.\n\n## 2.3.3 (2021-03-19):\n- Security fix: `allowedSchemes` and related options did not properly block schemes containing a hyphen, plus sign, period or digit, such as `ms-calculator:`. Thanks to Lukas Euler for pointing out the issue.\n- Added a security note about the known risks associated with using the `parser` option, especially `decodeEntities: false`. See the documentation.\n\n## 2.3.2 (2021-01-26):\n\n- Additional fixes for iframe validation exploits. Prevent exploits based on browsers' tolerance of the use of \"\\\" rather than \"/\" and the presence of whitespace at this point in the URL. Thanks to Ron Masas of [Checkmarx](https://www.checkmarx.com/) for pointing out the issue and writing unit tests.\n- Updates README `yarn add` syntax. Thanks to [Tagir Khadshiev](https://github.com/Aspedm) for the contribution.\n\n## 2.3.1 (2021-01-22):\n- Uses the standard WHATWG URL parser to stop IDNA (Internationalized Domain Name) attacks on the iframe hostname validator. Thanks to Ron Masas of [Checkmarx](https://www.checkmarx.com/) for pointing out the issue and suggesting the use of the WHATWG parser.\n\n## 2.3.0 (2020-12-16):\n- Upgrades `htmlparser2` to new major version `^6.0.0`. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n\n## 2.2.0 (2020-12-02):\n- Adds a note to the README about Typescript support (or the lack-thereof).\n- Adds `tel` to the default `allowedSchemes`. Thanks to [Arne Herbots](https://github.com/aHerbots) for this contribution.\n\n## 2.1.2 (2020-11-04):\n- Fixes typos and inconsistencies in the README. Thanks to [Eric Lefevre-Ardant](https://github.com/elefevre) for this contribution.\n\n## 2.1.1 (2020-10-21):\n- Fixes a bug when using `allowedClasses` with an `'*'` wildcard selector. Thanks to [Clemens Damke](https://github.com/Cortys) for this contribution.\n- Updates mocha to 7.x to resolve security warnings.\n\n## 2.1.0 (2020-10-07):\n- `sup` added to the default allowed tags list. Thanks to [Julian Lam](https://github.com/julianlam) for the contribution.\n- Updates default `allowedTags` README documentation. Thanks to [Marco Arduini](https://github.com/nerfologist) for the contribution.\n\n## 2.0.0 (2020-09-23):\n- `nestingLimit` option added.\n- Updates ESLint config package and fixes warnings.\n- Upgrade `is-plain-object` package with named export. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n- Upgrade `postcss` package and drop Node 11 and Node 13 support (enforced by postcss).\n\n### Backwards compatibility breaks:\n- There is no build. You should no longer directly link to a sanitize-html file directly in the browser as it is using modern Javascript that is not fully supported by all major browsers (depending on your definition). You should now include sanitize-html in your project build for this purpose if you have one.\n- On the server side, Node.js 10 or higher is required.\n- The default `allowedTags` array was updated significantly. This mostly added HTML tags to be more comprehensive by default. You should review your projects and consider the `allowedTags` defaults if you are not already overriding them.\n\n## 2.0.0-rc.2 (2020-09-09):\n- Always use existing `has` function rather than duplicating it.\n\n## 2.0.0-rc.1 (2020-08-26):\n- Upgrade `klona` package. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n\n## 2.0.0-beta.2:\n- Add `files` to `package.json` to prevent publishing unnecessary files to npm #392. Thanks to [styfle](https://github.com/styfle) for the contribution.\n- Removes `iframe` and `nl` from default allowed tags. Adds most innocuous tags to the default `allowedTags` array.\n- Fixes a bug when using `transformTags` with out `textFilter`. Thanks to [Andrzej Porebski](https://github.com/andpor) for the help with a failing test.\n\n## 2.0.0-beta:\n- Moves the `index.js` file to the project root and removes all build steps within the package. Going forward, it is up to the developer to include sanitize-html in their project builds as-needed. This removes major points of conflict with project code and frees this module to not worry about myriad build-related questions.\n- Replaces lodash with utility packages: klona, is-plain-object, deepmerge, escape-string-regexp.\n- Makes custom tag transformations less error-prone by escaping frame `innerText`. Thanks to [Mike Samuel](https://github.com/mikesamuel) for the contribution. Prior to this patch, tag transformations which turned an attribute\nvalue into a text node could be vulnerable to code execution.\n- Updates code to use modern features including `const`/`let` variable assignment.\n- ESLint clean up.\n- Updates `is-plain-object` to the 4.x major version.\n- Updates `srcset` to the 3.x major version.\n\nThanks to [Bogdan Chadkin](https://github.com/TrySound) for contributions to this major version update.\n\n## 1.27.5 (2020-09-23):\n- Updates README to include ES modules syntax.\n\n## 1.27.4 (2020-08-26):\n- Fixes an IE11 regression from using `Array.prototype.includes`, replacing it with `Array.prototype.indexOf`.\n\n## 1.27.3 (2020-08-12):\n- Fixes a bug when using `transformTags` with out `textFilter`. Thanks to [Andrzej Porebski](https://github.com/andpor) for the help with a failing test.\n\n## 1.27.2 (2020-07-29):\n- Fixes CHANGELOG links. Thanks to [Alex Mayer](https://github.com/amayer5125) for the contribution.\n- Replaces `srcset` with `parse-srcset`. Thanks to [Massimiliano Mirra](https://github.com/bard) for the contribution.\n\n## 1.27.1 (2020-07-15):\n- Removes the unused chalk dependency.\n- Adds configuration for a Github stale bot.\n- Replace `xtend` package with native `Object.assign`.\n\n## 1.27.0:\n- Adds the `allowedIframeDomains` option. This works similar to `allowedIframeHostnames`, where you would set it to an array of web domains. It would then permit any hostname on those domains to be used in iframe `src` attributes. Thanks to [Stanislav Kravchenko](https://github.com/StanisLove) for the contribution.\n\n## 1.26.0:\n- Adds the `option` element to the default `nonTextTagsArray` of tags with contents that aren't meant to be displayed visually as text. This can be overridden with the `nonTextTags` option.\n\n## 1.25.0:\n- Adds `enforceHtmlBoundary` option to process code bounded by the `html` tag, discarding any code outside of those tags.\n- Migrates to the main lodash package from the per method packages since they are deprecated and cause code duplication. Thanks to [Merceyz](https://github.com/merceyz) for the contribution.\n- Adds a warning when `style` and `script` tags are allowed, as they are inherently vulnerable to being used in XSS attacks. That warning can be disabled by including the option `allowVulnerableTags: true` so this choice is knowing and explicit.\n\n## 1.24.0:\n- Fixes a bug where self-closing tags resulted in deletion with `disallowedTagsMode: 'escape'` set. Thanks to [Thiago Negri](https://github.com/thiago-negri) for the contribution.\n- Adds `abbr` to the default `allowedTags` for better accessibility support. Thanks to [Will Farrell](https://github.com/willfarrell) for the contribution.\n- Adds a `mediaChildren` property to the `frame` object in custom filters. This allows you to check for links or other parent tags that contain self-contained media to prevent collapse, regardless of whether there is also text inside. Thanks to [axdg](https://github.com/axdg) for the initial implementation and [Marco Arduini](https://github.com/nerfologist) for a failing test contribution.\n\n## 1.23.0:\n- Adds eslint configuration and adds eslint to test script.\n- Sets `sideEffects: false` on package.json to allow module bundlers like webpack tree-shake this module and all the dependencies from client build. Thanks to [Egor Voronov](https://github.com/egorvoronov) for the contribution.\n- Adds the `tagName` (HTML element name) as a second parameter passed to `textFilter`. Thanks to [Slava](https://github.com/slavaGanzin) for the contribution.\n\n## 1.22.1:\nncreases the patch version of `lodash.mergewith` to enforce an audit fix.\n\n## 1.22.0:\nbumped `htmlparser2` dependency to the 4.x series. This fixes longstanding bugs and should cause no bc breaks for this module, since the only bc breaks upstream are in regard to features we don't expose in this module.\n\n## 1.21.1:\nfixed issue with bad `main` setting in package.json that broke 1.21.0.\n\n## 1.21.0:\nnew `disallowedTagsMode` option can be set to `escape` to escape disallowed tags rather than discarding them. Any subtags are handled as usual. If you want to recursively escape them too, you can set `disallowedTagsMode` to `recursiveEscape`. Thanks to Yehonatan Zecharia for this contribution.\n\n## 1.20.1:\nFix failing tests, add CircleCI config\n\n## 1.20.0:\nreduced size of npm package via the `files` key; we only need to publish what's in `dist`. Thanks to Steven. There should be zero impact on behavior, minor version bump is precautionary.\n\n## 1.19.3:\nreverted to `postcss` due to a [reported issue with `css-tree` that might or might not have XSS implications](https://github.com/punkave/sanitize-html/issues/269).\n\n## 1.19.2:\n\n* Switched out the heavy `postcss` dependency for the lightweight `css-tree` module. No API changes. Thanks to Justin Braithwaite.\n* Various doc updates. Thanks to Pulkit Aggarwal and Cody Robertson.\n\n## 1.19.1:\n\n* `\"` characters are now entity-escaped only when they appear in attribute values, reducing the verbosity of the resulting markup.\n\n* Fixed a regression introduced in version 1.18.5 in the handling of markup that looks similar to a valid entity, but isn't. The bogus entity was passed through intact, i.e. `&0;` did not become `&amp;0;` as it should have. This fix has been made for the default parser settings only. There is no fix yet for those who wish to enable `decodeEntities: false`. That will require improving the alternative encoder in the `escapeHtml` function to only pass 100% valid entities.\n\n**For those using the default `parser` settings this bug is fixed.** Read on if you are using alternative `parser` settings.\n\nWhen `decodeEntities: true` is in effect (the default), this is not a problem because we only have to encode `& < > \"` and we always encode those things.\n\nThere is currently a commented-out test which verifies one example of the problem when `decodeEntities` is false. However a correct implementation would need to not only pass that simple example but correctly escape all invalid entities, and not escape those that are valid.\n\n## 1.19.0:\n\n* New `allowIframeRelativeUrls` option. It defaults to `true` unless `allowedIframeHostnames` is present, in which case it defaults to false, for backwards compatibility with existing behavior in both cases; however you can now set the option explicitly to allow both certain hostnames and relative URLs. Thanks to Rick Martin.\n\n## 1.18.5:\n\n* Stop double encoding ampersands on HTML entities. Thanks to Will Gibson.\n\n## 1.18.4:\n\n* Removed incorrect `browser` key, restoring frontend build. Thanks to Felix Becker.\n\n## 1.18.3:\n\n* `iframe` is an allowed tag by default, to better facilitate typical use cases and the use of the `allowedIframeHostnames` option.\n* Documentation improvements.\n* More browser packaging improvements.\n* Protocol-relative URLs are properly supported for iframe tags.\n\n## 1.18.2:\n\n* Travis tests passing.\n* Fixed another case issue \u2014\u00a0and instituted Travis CI testing so this doesn't happen again. Sorry for the hassle.\n\n## 1.18.1:\n\n* A file was required with incorrect case, breaking the library on case sensitive filesystems such as Linux. Fixed.\n\n## 1.18.0:\n\n* The new `allowedSchemesAppliedToAttributes` option. This determines which attributes are validated as URLs, replacing the old hardcoded list of `src` and `href` only. The default list now includes `cite`. Thanks to ml-dublin for this contribution.\n* It is now easy to configure a specific list of allowed values for an attribute. When configuring `allowedAttributes`, rather than listing an attribute name, simply list an object with an attribute `name` property and an allowed `values` array property. You can also add `multiple: true` to allow multiple space-separated allowed values in the attribute, otherwise the attribute must match one and only one of the allowed values. Thanks again to ml-dublin for this contribution.\n* Fixed a bug in the npm test procedure.\n\n## 1.17.0:\nThe new `allowedIframeHostnames` option. If present, this must be an array, and only iframe `src` URLs hostnames (complete hostnames; domain name matches are not enough) that appear on this list are allowed. You must also configure `hostname` as an allowed attribute for `iframe`. Thanks to Ryan Verys for this contribution.\n\n## 1.16.3:\nDon't throw away the browserified versions before publishing them. `prepare` is not a good place to `make clean`, it runs after `prepublish`.\n\n## 1.16.2:\n`sanitize-html` is now compiled with `babel`. An npm `prepublish` script takes care of this at `npm publish` time, so the latest code should always be compiled to operate all the way back to ES5 browsers and earlier versions of Node. Thanks to Ayushya Jaiswal.\n\nPlease note that running `sanitize-html` in the browser is usually a security hole. Are you trusting the browser? Anyone could bypass that using the network panel. Sanitization is almost always best done on servers and that is the primary use case for this module.\n\n## 1.16.1:\nchangelog formatting only.\n\n## 1.16.0:\nsupport for sanitizing inline CSS styles, by specifying the allowed attributes and a regular expression for each. Thanks to Cameron Will and Michael Loschiavo.\n\n## 1.15.0:\nif configured as an allowed attribute (not the default), check for naughty URLs in `srcset` attributes. Thanks to Mike Samuel for the nudge to do this and to Sindre Sorhus for the `srcset` module.\n\n## 1.14.3:\ninadvertent removal of lodash regexp quote dependency in 1.14.2 has been corrected.\n\n## 1.14.2:\nprotocol-relative URL detection must spot URLs starting with `\\\\` rather than `//` due to ages-old tolerance features of web browsers, intended for sleepy Windows developers. Thanks to Martin Bajanik.\n\n## 1.14.1:\ndocumented `allowProtocolRelative` option. No code changes from 1.14.0, released a few moments ago.\n\n## 1.14.0:\nthe new `allowProtocolRelative` option, which is set to `true` by default, allows you to decline to accept URLs that start with `//` and thus point to a different host using the current protocol. If you do **not** want to permit this, set this option to `false`. This is fully backwards compatible because the default behavior is to allow them. Thanks to Luke Bernard.\n\n## 1.13.0:\n`transformTags` can now add text to an element that initially had none. Thanks to Dushyant Singh.\n\n## 1.12.0:\noption to build for browser-side use. Thanks to Michael Blum.\n\n## 1.11.4:\nfixed crash when `__proto__` is a tag name. Now using a safe check for the existence of properties in all cases. Thanks to Andrew Krasichkov.\n\nFixed XSS attack vector via `textarea` tags (when explicitly allowed). Decided that `script` (obviously) and `style` (due to its own XSS vectors) cannot realistically be afforded any XSS protection if allowed, unless we add a full CSS parser. Thanks again to Andrew Krasichkov.\n\n## 1.11.3:\nbumped `htmlparser2` version to address crashing bug in older version. Thanks to e-jigsaw.\n\n## 1.11.2:\nfixed README typo that interfered with readability due to markdown issues. No code changes. Thanks to Mikael Korpela. Also improved code block highlighting in README. Thanks to Alex Siman.\n\n## 1.11.1:\nfixed a regression introduced in 1.11.0 which caused the closing tag of the parent of a `textarea` tag to be lost. Thanks to Stefano Sala, who contributed the missing test.\n\n## 1.11.0:\nadded the `nonTextTags` option, with tests.\n\n## 1.10.1:\ndocumentation cleanup. No code changes. Thanks to Rex Schrader.\n\n## 1.10.0:\n`allowedAttributes` now allows you to allow attributes for all tags by specifying `*` as the tag name. Thanks to Zdravko Georgiev.\n\n## 1.9.0:\n`parser` option allows options to be passed directly to `htmlparser`. Thanks to Danny Scott.\n\n## 1.8.0:\n\n* `transformTags` now accepts the `*` wildcard to transform all tags. Thanks to Jamy Timmermans.\n\n* Text that has been modified by `transformTags` is then passed through `textFilter`. Thanks to Pavlo Yurichuk.\n\n* Content inside `textarea` is discarded if `textarea` is not allowed. I don't know why it took me this long to see that this is just common sense. Thanks to David Frank.\n\n## 1.7.2:\nremoved `array-includes` dependency in favor of `indexOf`, which is a little more verbose but slightly faster and doesn't require a shim. Thanks again to Joseph Dykstra.\n\n## 1.7.1:\nremoved lodash dependency, adding lighter dependencies and polyfills in its place. Thanks to Joseph Dykstra.\n\n## 1.7.0:\nintroduced `allowedSchemesByTag` option. Thanks to Cameron Will.\n\n## 1.6.1:\nthe string `'undefined'` (as opposed to `undefined`) is perfectly valid text and shouldn't be expressly converted to the empty string.\n\n## 1.6.0:\nadded `textFilter` option. Thanks to Csaba Palfi.\n\n## 1.5.3:\ndo not escape special characters inside a script or style element, if they are allowed. This is consistent with the way browsers parse them; nothing closes them except the appropriate closing tag for the entire element. Of course, this only comes into play if you actually choose to allow those tags. Thanks to aletorrado.\n\n## 1.5.2:\nguard checks for allowed attributes correctly to avoid an undefined property error. Thanks to Zeke.\n\n## 1.5.1:\nupdated to htmlparser2 1.8.x. Started using the `decodeEntities` option, which allows us to pass our filter evasion tests without the need to recursively invoke the filter.\n\n## 1.5.0:\nsupport for `*` wildcards in allowedAttributes. With tests. Thanks to Calvin Montgomery.\n\n## 1.4.3:\ninvokes itself recursively until the markup stops changing to guard against [this issue](https://github.com/fb55/htmlparser2/issues/105). Bump to htmlparser2 version 3.7.x.\n\n## 1.4.1, 1.4.2:\nmore tests.\n\n## 1.4.0:\nability to  allow all attributes or tags through by setting `allowedAttributes` and/or `allowedTags` to false. Thanks to Anand Thakker.\n\n## 1.3.0:\n`attribs` now available on frames passed to exclusive filter.\n\n## 1.2.3:\nfixed another possible XSS attack vector; no definitive exploit was found but it looks possible. [See this issue.](https://github.com/punkave/sanitize-html/pull/20) Thanks to Jim O'Brien.\n\n## 1.2.2:\nreject `javascript:` URLs when disguised with an internal comment. This is probably not respected by browsers anyway except when inside an XML data island element, which you almost certainly are not allowing in your `allowedTags`, but we aim to be thorough. Thanks to Jim O'Brien.\n\n## 1.2.1:\nfixed crashing bug when presented with bad markup. The bug was in the `exclusiveFilter` mechanism. Unit test added. Thanks to Ilya Kantor for catching it.\n\n## 1.2.0:\n* The `allowedClasses` option now allows you to permit CSS classes in a fine-grained way.\n\n* Text passed to your `exclusiveFilter` function now includes the text of child elements, making it more useful for identifying elements that truly lack any inner text.\n\n## 1.1.7:\nuse `he` for entity decoding, because it is more actively maintained.\n\n## 1.1.6:\n`allowedSchemes` option for those who want to permit `data` URLs and such.\n\n## 1.1.5:\njust a packaging thing.\n\n## 1.1.4:\ncustom exclusion filter.\n\n## 1.1.3:\nmoved to lodash. 1.1.2 pointed to the wrong version of lodash.\n\n## 1.1.0:\nthe `transformTags` option was added. Thanks to [kl3ryk](https://github.com/kl3ryk).\n\n## 1.0.3:\nfixed several more javascript URL attack vectors after [studying the XSS filter evasion cheat sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) to better understand my enemy. Whitespace characters (codes from 0 to 32), which browsers ignore in URLs in certain cases allowing the \"javascript\" scheme to be snuck in, are now stripped out when checking for naughty URLs. Thanks again to [pinpickle](https://github.com/pinpickle).\n\n## 1.0.2:\nfixed a javascript URL attack vector. naughtyHref must entity-decode URLs and also check for mixed-case scheme names. Thanks to [pinpickle](https://github.com/pinpickle).\n\n## 1.0.1:\nDoc tweaks.\n\n## 1.0.0:\nIf the style tag is disallowed, then its content should be dumped, so that it doesn't appear as text. We were already doing this for script tags, however in both cases the content is now preserved if the tag is explicitly allowed.\n\nWe're rocking our tests and have been working great in production for months, so: declared 1.0.0 stable.\n\n## 0.1.3:\ndo not double-escape entities in attributes or text. Turns out the \"text\" provided by htmlparser2 is already escaped.\n\n## 0.1.2:\npackaging error meant it wouldn't install properly.\n\n## 0.1.1:\ndiscard the text of script tags.\n\n## 0.1.0:\ninitial release.\n", "const htmlparser = require('htmlparser2');\nconst escapeStringRegexp = require('escape-string-regexp');\nconst { isPlainObject } = require('is-plain-object');\nconst deepmerge = require('deepmerge');\nconst parseSrcset = require('parse-srcset');\nconst { parse: postcssParse } = require('postcss');\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n  'img', 'audio', 'video', 'picture', 'svg',\n  'object', 'map', 'iframe', 'embed'\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [ 'script', 'style' ];\n\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  const n = [];\n  each(a, function(v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nfunction isEmptyObject(obj) {\n  for (const key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function(part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n\n    return (\n      part.url +\n      (part.w ? ` ${part.w}w` : '') +\n      (part.h ? ` ${part.h}h` : '') +\n      (part.d ? ` ${part.d}x` : '')\n    );\n  }).join(', ');\n}\n\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  if (html == null) {\n    return '';\n  }\n\n  let result = '';\n  // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n  let tempResult = '';\n\n  function Frame(tag, attribs) {\n    const that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n    this.mediaChildren = [];\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n\n    this.updateParentNodeMediaChildren = function() {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n\n  // vulnerableTags\n  vulnerableTags.forEach(function (tag) {\n    if (\n      options.allowedTags && options.allowedTags.indexOf(tag) > -1 &&\n      !options.allowVulnerableTags\n    ) {\n      console.warn(`\\n\\n\u26a0\ufe0f Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n    }\n  });\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  const nonTextTagsArray = options.nonTextTags || [\n    'script',\n    'style',\n    'textarea',\n    'option'\n  ];\n  let allowedAttributesMap;\n  let allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      const globRegex = [];\n      attributes.forEach(function(obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n  const allowedClassesMap = {};\n  const allowedClassesGlobMap = {};\n  const allowedClassesRegexMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = [];\n    allowedClassesRegexMap[tag] = [];\n    const globRegex = [];\n    classes.forEach(function(obj) {\n      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n        globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n      } else if (obj instanceof RegExp) {\n        allowedClassesRegexMap[tag].push(obj);\n      } else {\n        allowedClassesMap[tag].push(obj);\n      }\n    });\n    if (globRegex.length) {\n      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    }\n  });\n\n  const transformTagsMap = {};\n  let transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    let transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  let depth;\n  let stack;\n  let skipMap;\n  let transformMap;\n  let skipText;\n  let skipTextDepth;\n  let addedText = false;\n\n  initializeState();\n\n  const parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      const frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      let skip = false;\n      const hasText = !!frame.text;\n      let transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if ((options.allowedTags && options.allowedTags.indexOf(name) === -1) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {\n        skip = true;\n        skipMap[depth] = true;\n        if (options.disallowedTagsMode === 'discard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard') {\n          // We want the contents but not this tag\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      result += '<' + name;\n\n      if (name === 'script') {\n        if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n          frame.innerText = '';\n        }\n      }\n\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          let passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap ||\n            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||\n            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||\n            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            for (const o of allowedAttributesMap[name]) {\n              if (isPlainObject(o) && o.name && (o.name === a)) {\n                passedAllowedAttributesMapCheck = true;\n                let newValue = '';\n                if (o.multiple === true) {\n                  // verify the values that are allowed\n                  const splitStrArray = value.split(' ');\n                  for (const s of splitStrArray) {\n                    if (o.values.indexOf(s) !== -1) {\n                      if (newValue === '') {\n                        newValue = s;\n                      } else {\n                        newValue += ' ' + s;\n                      }\n                    }\n                  }\n                } else if (o.values.indexOf(value) >= 0) {\n                  // verified an allowed value matches the entire attribute value\n                  newValue = value;\n                }\n                value = newValue;\n              }\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'script' && a === 'src') {\n\n              let allowed = true;\n\n              try {\n                const parsed = parseUrl(value);\n\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                allowed = false;\n              }\n\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'iframe' && a === 'src') {\n              let allowed = true;\n              try {\n                const parsed = parseUrl(value);\n\n                if (parsed.isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  allowed = has(options, 'allowIframeRelativeUrls')\n                    ? options.allowIframeRelativeUrls\n                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                let parsed = parseSrcset(value);\n                parsed.forEach(function(value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function(v) {\n                  return !v.evil;\n                });\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(parsed, function(v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              const allowedSpecificClasses = allowedClassesMap[name];\n              const allowedWildcardClasses = allowedClassesMap['*'];\n              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              const allowedClassesGlobs = [\n                allowedSpecificClassesGlob,\n                allowedWildcardClassesGlob\n              ]\n                .concat(allowedSpecificClassesRegex)\n                .filter(function (t) {\n                  return t;\n                });\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              try {\n                const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');\n                const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n\n                value = stringifyStyleAttributes(filteredAST);\n\n                if (value.length === 0) {\n                  delete frame.attribs[a];\n                  return;\n                }\n              } catch (e) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            result += ' ' + a;\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      const lastFrame = stack[stack.length - 1];\n      let tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (options.disallowedTagsMode === 'discard' && ((tag === 'script') || (tag === 'style'))) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        const escaped = escapeHtml(text, false);\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        const frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      const frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      const skip = skipMap[depth];\n      if (skip) {\n        delete skipMap[depth];\n        if (options.disallowedTagsMode === 'discard') {\n          frame.updateParentNodeText();\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n        return;\n      }\n\n      result += '</' + name + '>';\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n      addedText = false;\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n\n  function escapeHtml(s, quote) {\n    if (typeof (s) !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    href = href.replace(/<!--.*?-->/g, '');\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    const scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  function parseUrl(value) {\n    value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n    if (value.startsWith('relative:')) {\n      // An attempt to exploit our workaround for base URLs being\n      // mandatory for relative URL validation in the WHATWG\n      // URL parser, reject it\n      throw new Error('relative: exploit attempt');\n    }\n    // naughtyHref is in charge of whether protocol relative URLs\n    // are cool. Here we are concerned just with allowed hostnames and\n    // whether to allow relative URLs.\n    //\n    // Build a placeholder \"base URL\" against which any reasonable\n    // relative URL may be parsed successfully\n    let base = 'relative://relative-site';\n    for (let i = 0; (i < 100); i++) {\n      base += `/${i}`;\n    }\n\n    const parsed = new URL(value, base);\n\n    const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n    return {\n      isRelativeUrl,\n      url: parsed\n    };\n  }\n  /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    const astRules = abstractSyntaxTree.nodes[0];\n    let selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(\n        allowedStyles[astRules.selector],\n        allowedStyles['*']\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return abstractSyntaxTree;\n  }\n\n  /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes\n      .reduce(function(extractedAttributes, attrObject) {\n        extractedAttributes.push(\n          `${attrObject.prop}:${attrObject.value}${attrObject.important ? ' !important' : ''}`\n        );\n        return extractedAttributes;\n      }, [])\n      .join(';');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is allowlisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nconst htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [\n    // Sections derived from MDN element categories and limited to the more\n    // benign categories.\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n    // Content sectioning\n    'address', 'article', 'aside', 'footer', 'header',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',\n    'main', 'nav', 'section',\n    // Text content\n    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',\n    'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',\n    // Inline text semantics\n    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',\n    'em', 'i', 'kbd', 'mark', 'q',\n    'rb', 'rp', 'rt', 'rtc', 'ruby',\n    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',\n    // Table content\n    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',\n    'thead', 'tr'\n  ],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but\n    // these attributes would make sense if we did.\n    img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    let attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n", "{\n  \"name\": \"sanitize-html\",\n  \"version\": \"2.7.0\",\n  \"description\": \"Clean up user-submitted HTML, preserving allowlisted elements and allowlisted attributes on a per-element basis\",\n  \"sideEffects\": false,\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"npx eslint . && mocha test/test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/apostrophecms/sanitize-html.git\"\n  },\n  \"keywords\": [\n    \"html\",\n    \"parser\",\n    \"sanitizer\",\n    \"sanitize\"\n  ],\n  \"author\": \"Apostrophe Technologies, Inc.\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"deepmerge\": \"^4.2.2\",\n    \"escape-string-regexp\": \"^4.0.0\",\n    \"htmlparser2\": \"^6.0.0\",\n    \"is-plain-object\": \"^5.0.0\",\n    \"parse-srcset\": \"^1.0.2\",\n    \"postcss\": \"^8.3.11\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^7.3.1\",\n    \"eslint-config-apostrophe\": \"^3.4.0\",\n    \"eslint-config-standard\": \"^14.1.1\",\n    \"eslint-plugin-import\": \"^2.25.2\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-promise\": \"^4.2.1\",\n    \"eslint-plugin-standard\": \"^4.0.1\",\n    \"mocha\": \"^7.0.0\",\n    \"sinon\": \"^9.0.2\"\n  }\n}\n"], "fixing_code": ["# Changelog\n\n## 2.7.1 (2022-07-20)\n\n- Protocol-relative URLs are properly supported for script tags. Thanks to [paweljq](https://github.com/paweljq).\n- A denial-of-service vulnerability has been fixed by replacing global regular expression replacement logic for comment removal with a new implementation. Thanks to Nariyoshi Chida of NTT Security Japan for pointing out the issue.\n\n## 2.7.0 (2022-02-04)\n\n- Allows a more sensible set of default attributes on `<img />` tags. Thanks to [Zade Viggers](https://github.com/zadeviggers).\n\n## 2.6.1 (2021-12-08)\n\n- Fixes style filtering to retain `!important` when used.\n- Fixed trailing text bug on `transformTags` options that was reported on [issue #506](https://github.com/apostrophecms/sanitize-html/issues/506). Thanks to [Alex Rantos](https://github.com/alex-rantos).\n\n## 2.6.0 (2021-11-23)\n\n- Support for regular expressions in the `allowedClasses` option. Thanks to [Alex Rantos](https://github.com/alex-rantos).\n\n## 2.5.3 (2021-11-02):\n\n- Fixed bug introduced by klona 2.0.5, by removing klona entirely.\n\n## 2.5.2 (2021-10-13):\n\n- Nullish HTML input now returns an empty string. Nullish value may be explicit `null`, `undefined` or implicit `undefined` when value is not provided. Thanks to Artem Kostiuk for the contribution.\n- Documented that all text content is escaped. Thanks to Siddharth Singh.\n\n## 2.5.1 (2021-09-14):\n- The `allowedScriptHostnames` and `allowedScriptDomains` options now implicitly purge the inline content of all script tags, not just those with `src` attributes. This behavior was already strongly implied by the fact that they purged it in the case where a `src` attribute was actually present, and is necessary for the feature to provide any real security. Thanks to Grigorii Duca for pointing out the issue.\n\n## 2.5.0 (2021-09-08):\n\n- New `allowedScriptHostnames` option, it enables you to specify which hostnames are allowed in a script tag.\n- New `allowedScriptDomains` option, it enables you to specify which domains are allowed in a script tag. Thank you to [Yorick Girard](https://github.com/yorickgirard) for this and the `allowedScriptHostnames` contribution.\n- Updates whitelist to allowlist.\n\n## 2.4.0 (2021-05-19):\n- Added support for class names with wildcards in `allowedClasses`. Thanks to [zhangbenber](https://github.com/zhangbenber) for the contribution.\n\n## 2.3.3 (2021-03-19):\n- Security fix: `allowedSchemes` and related options did not properly block schemes containing a hyphen, plus sign, period or digit, such as `ms-calculator:`. Thanks to Lukas Euler for pointing out the issue.\n- Added a security note about the known risks associated with using the `parser` option, especially `decodeEntities: false`. See the documentation.\n\n## 2.3.2 (2021-01-26):\n\n- Additional fixes for iframe validation exploits. Prevent exploits based on browsers' tolerance of the use of \"\\\" rather than \"/\" and the presence of whitespace at this point in the URL. Thanks to Ron Masas of [Checkmarx](https://www.checkmarx.com/) for pointing out the issue and writing unit tests.\n- Updates README `yarn add` syntax. Thanks to [Tagir Khadshiev](https://github.com/Aspedm) for the contribution.\n\n## 2.3.1 (2021-01-22):\n- Uses the standard WHATWG URL parser to stop IDNA (Internationalized Domain Name) attacks on the iframe hostname validator. Thanks to Ron Masas of [Checkmarx](https://www.checkmarx.com/) for pointing out the issue and suggesting the use of the WHATWG parser.\n\n## 2.3.0 (2020-12-16):\n- Upgrades `htmlparser2` to new major version `^6.0.0`. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n\n## 2.2.0 (2020-12-02):\n- Adds a note to the README about Typescript support (or the lack-thereof).\n- Adds `tel` to the default `allowedSchemes`. Thanks to [Arne Herbots](https://github.com/aHerbots) for this contribution.\n\n## 2.1.2 (2020-11-04):\n- Fixes typos and inconsistencies in the README. Thanks to [Eric Lefevre-Ardant](https://github.com/elefevre) for this contribution.\n\n## 2.1.1 (2020-10-21):\n- Fixes a bug when using `allowedClasses` with an `'*'` wildcard selector. Thanks to [Clemens Damke](https://github.com/Cortys) for this contribution.\n- Updates mocha to 7.x to resolve security warnings.\n\n## 2.1.0 (2020-10-07):\n- `sup` added to the default allowed tags list. Thanks to [Julian Lam](https://github.com/julianlam) for the contribution.\n- Updates default `allowedTags` README documentation. Thanks to [Marco Arduini](https://github.com/nerfologist) for the contribution.\n\n## 2.0.0 (2020-09-23):\n- `nestingLimit` option added.\n- Updates ESLint config package and fixes warnings.\n- Upgrade `is-plain-object` package with named export. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n- Upgrade `postcss` package and drop Node 11 and Node 13 support (enforced by postcss).\n\n### Backwards compatibility breaks:\n- There is no build. You should no longer directly link to a sanitize-html file directly in the browser as it is using modern Javascript that is not fully supported by all major browsers (depending on your definition). You should now include sanitize-html in your project build for this purpose if you have one.\n- On the server side, Node.js 10 or higher is required.\n- The default `allowedTags` array was updated significantly. This mostly added HTML tags to be more comprehensive by default. You should review your projects and consider the `allowedTags` defaults if you are not already overriding them.\n\n## 2.0.0-rc.2 (2020-09-09):\n- Always use existing `has` function rather than duplicating it.\n\n## 2.0.0-rc.1 (2020-08-26):\n- Upgrade `klona` package. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n\n## 2.0.0-beta.2:\n- Add `files` to `package.json` to prevent publishing unnecessary files to npm #392. Thanks to [styfle](https://github.com/styfle) for the contribution.\n- Removes `iframe` and `nl` from default allowed tags. Adds most innocuous tags to the default `allowedTags` array.\n- Fixes a bug when using `transformTags` with out `textFilter`. Thanks to [Andrzej Porebski](https://github.com/andpor) for the help with a failing test.\n\n## 2.0.0-beta:\n- Moves the `index.js` file to the project root and removes all build steps within the package. Going forward, it is up to the developer to include sanitize-html in their project builds as-needed. This removes major points of conflict with project code and frees this module to not worry about myriad build-related questions.\n- Replaces lodash with utility packages: klona, is-plain-object, deepmerge, escape-string-regexp.\n- Makes custom tag transformations less error-prone by escaping frame `innerText`. Thanks to [Mike Samuel](https://github.com/mikesamuel) for the contribution. Prior to this patch, tag transformations which turned an attribute\nvalue into a text node could be vulnerable to code execution.\n- Updates code to use modern features including `const`/`let` variable assignment.\n- ESLint clean up.\n- Updates `is-plain-object` to the 4.x major version.\n- Updates `srcset` to the 3.x major version.\n\nThanks to [Bogdan Chadkin](https://github.com/TrySound) for contributions to this major version update.\n\n## 1.27.5 (2020-09-23):\n- Updates README to include ES modules syntax.\n\n## 1.27.4 (2020-08-26):\n- Fixes an IE11 regression from using `Array.prototype.includes`, replacing it with `Array.prototype.indexOf`.\n\n## 1.27.3 (2020-08-12):\n- Fixes a bug when using `transformTags` with out `textFilter`. Thanks to [Andrzej Porebski](https://github.com/andpor) for the help with a failing test.\n\n## 1.27.2 (2020-07-29):\n- Fixes CHANGELOG links. Thanks to [Alex Mayer](https://github.com/amayer5125) for the contribution.\n- Replaces `srcset` with `parse-srcset`. Thanks to [Massimiliano Mirra](https://github.com/bard) for the contribution.\n\n## 1.27.1 (2020-07-15):\n- Removes the unused chalk dependency.\n- Adds configuration for a Github stale bot.\n- Replace `xtend` package with native `Object.assign`.\n\n## 1.27.0:\n- Adds the `allowedIframeDomains` option. This works similar to `allowedIframeHostnames`, where you would set it to an array of web domains. It would then permit any hostname on those domains to be used in iframe `src` attributes. Thanks to [Stanislav Kravchenko](https://github.com/StanisLove) for the contribution.\n\n## 1.26.0:\n- Adds the `option` element to the default `nonTextTagsArray` of tags with contents that aren't meant to be displayed visually as text. This can be overridden with the `nonTextTags` option.\n\n## 1.25.0:\n- Adds `enforceHtmlBoundary` option to process code bounded by the `html` tag, discarding any code outside of those tags.\n- Migrates to the main lodash package from the per method packages since they are deprecated and cause code duplication. Thanks to [Merceyz](https://github.com/merceyz) for the contribution.\n- Adds a warning when `style` and `script` tags are allowed, as they are inherently vulnerable to being used in XSS attacks. That warning can be disabled by including the option `allowVulnerableTags: true` so this choice is knowing and explicit.\n\n## 1.24.0:\n- Fixes a bug where self-closing tags resulted in deletion with `disallowedTagsMode: 'escape'` set. Thanks to [Thiago Negri](https://github.com/thiago-negri) for the contribution.\n- Adds `abbr` to the default `allowedTags` for better accessibility support. Thanks to [Will Farrell](https://github.com/willfarrell) for the contribution.\n- Adds a `mediaChildren` property to the `frame` object in custom filters. This allows you to check for links or other parent tags that contain self-contained media to prevent collapse, regardless of whether there is also text inside. Thanks to [axdg](https://github.com/axdg) for the initial implementation and [Marco Arduini](https://github.com/nerfologist) for a failing test contribution.\n\n## 1.23.0:\n- Adds eslint configuration and adds eslint to test script.\n- Sets `sideEffects: false` on package.json to allow module bundlers like webpack tree-shake this module and all the dependencies from client build. Thanks to [Egor Voronov](https://github.com/egorvoronov) for the contribution.\n- Adds the `tagName` (HTML element name) as a second parameter passed to `textFilter`. Thanks to [Slava](https://github.com/slavaGanzin) for the contribution.\n\n## 1.22.1:\nncreases the patch version of `lodash.mergewith` to enforce an audit fix.\n\n## 1.22.0:\nbumped `htmlparser2` dependency to the 4.x series. This fixes longstanding bugs and should cause no bc breaks for this module, since the only bc breaks upstream are in regard to features we don't expose in this module.\n\n## 1.21.1:\nfixed issue with bad `main` setting in package.json that broke 1.21.0.\n\n## 1.21.0:\nnew `disallowedTagsMode` option can be set to `escape` to escape disallowed tags rather than discarding them. Any subtags are handled as usual. If you want to recursively escape them too, you can set `disallowedTagsMode` to `recursiveEscape`. Thanks to Yehonatan Zecharia for this contribution.\n\n## 1.20.1:\nFix failing tests, add CircleCI config\n\n## 1.20.0:\nreduced size of npm package via the `files` key; we only need to publish what's in `dist`. Thanks to Steven. There should be zero impact on behavior, minor version bump is precautionary.\n\n## 1.19.3:\nreverted to `postcss` due to a [reported issue with `css-tree` that might or might not have XSS implications](https://github.com/punkave/sanitize-html/issues/269).\n\n## 1.19.2:\n\n* Switched out the heavy `postcss` dependency for the lightweight `css-tree` module. No API changes. Thanks to Justin Braithwaite.\n* Various doc updates. Thanks to Pulkit Aggarwal and Cody Robertson.\n\n## 1.19.1:\n\n* `\"` characters are now entity-escaped only when they appear in attribute values, reducing the verbosity of the resulting markup.\n\n* Fixed a regression introduced in version 1.18.5 in the handling of markup that looks similar to a valid entity, but isn't. The bogus entity was passed through intact, i.e. `&0;` did not become `&amp;0;` as it should have. This fix has been made for the default parser settings only. There is no fix yet for those who wish to enable `decodeEntities: false`. That will require improving the alternative encoder in the `escapeHtml` function to only pass 100% valid entities.\n\n**For those using the default `parser` settings this bug is fixed.** Read on if you are using alternative `parser` settings.\n\nWhen `decodeEntities: true` is in effect (the default), this is not a problem because we only have to encode `& < > \"` and we always encode those things.\n\nThere is currently a commented-out test which verifies one example of the problem when `decodeEntities` is false. However a correct implementation would need to not only pass that simple example but correctly escape all invalid entities, and not escape those that are valid.\n\n## 1.19.0:\n\n* New `allowIframeRelativeUrls` option. It defaults to `true` unless `allowedIframeHostnames` is present, in which case it defaults to false, for backwards compatibility with existing behavior in both cases; however you can now set the option explicitly to allow both certain hostnames and relative URLs. Thanks to Rick Martin.\n\n## 1.18.5:\n\n* Stop double encoding ampersands on HTML entities. Thanks to Will Gibson.\n\n## 1.18.4:\n\n* Removed incorrect `browser` key, restoring frontend build. Thanks to Felix Becker.\n\n## 1.18.3:\n\n* `iframe` is an allowed tag by default, to better facilitate typical use cases and the use of the `allowedIframeHostnames` option.\n* Documentation improvements.\n* More browser packaging improvements.\n* Protocol-relative URLs are properly supported for iframe tags.\n\n## 1.18.2:\n\n* Travis tests passing.\n* Fixed another case issue \u2014\u00a0and instituted Travis CI testing so this doesn't happen again. Sorry for the hassle.\n\n## 1.18.1:\n\n* A file was required with incorrect case, breaking the library on case sensitive filesystems such as Linux. Fixed.\n\n## 1.18.0:\n\n* The new `allowedSchemesAppliedToAttributes` option. This determines which attributes are validated as URLs, replacing the old hardcoded list of `src` and `href` only. The default list now includes `cite`. Thanks to ml-dublin for this contribution.\n* It is now easy to configure a specific list of allowed values for an attribute. When configuring `allowedAttributes`, rather than listing an attribute name, simply list an object with an attribute `name` property and an allowed `values` array property. You can also add `multiple: true` to allow multiple space-separated allowed values in the attribute, otherwise the attribute must match one and only one of the allowed values. Thanks again to ml-dublin for this contribution.\n* Fixed a bug in the npm test procedure.\n\n## 1.17.0:\nThe new `allowedIframeHostnames` option. If present, this must be an array, and only iframe `src` URLs hostnames (complete hostnames; domain name matches are not enough) that appear on this list are allowed. You must also configure `hostname` as an allowed attribute for `iframe`. Thanks to Ryan Verys for this contribution.\n\n## 1.16.3:\nDon't throw away the browserified versions before publishing them. `prepare` is not a good place to `make clean`, it runs after `prepublish`.\n\n## 1.16.2:\n`sanitize-html` is now compiled with `babel`. An npm `prepublish` script takes care of this at `npm publish` time, so the latest code should always be compiled to operate all the way back to ES5 browsers and earlier versions of Node. Thanks to Ayushya Jaiswal.\n\nPlease note that running `sanitize-html` in the browser is usually a security hole. Are you trusting the browser? Anyone could bypass that using the network panel. Sanitization is almost always best done on servers and that is the primary use case for this module.\n\n## 1.16.1:\nchangelog formatting only.\n\n## 1.16.0:\nsupport for sanitizing inline CSS styles, by specifying the allowed attributes and a regular expression for each. Thanks to Cameron Will and Michael Loschiavo.\n\n## 1.15.0:\nif configured as an allowed attribute (not the default), check for naughty URLs in `srcset` attributes. Thanks to Mike Samuel for the nudge to do this and to Sindre Sorhus for the `srcset` module.\n\n## 1.14.3:\ninadvertent removal of lodash regexp quote dependency in 1.14.2 has been corrected.\n\n## 1.14.2:\nprotocol-relative URL detection must spot URLs starting with `\\\\` rather than `//` due to ages-old tolerance features of web browsers, intended for sleepy Windows developers. Thanks to Martin Bajanik.\n\n## 1.14.1:\ndocumented `allowProtocolRelative` option. No code changes from 1.14.0, released a few moments ago.\n\n## 1.14.0:\nthe new `allowProtocolRelative` option, which is set to `true` by default, allows you to decline to accept URLs that start with `//` and thus point to a different host using the current protocol. If you do **not** want to permit this, set this option to `false`. This is fully backwards compatible because the default behavior is to allow them. Thanks to Luke Bernard.\n\n## 1.13.0:\n`transformTags` can now add text to an element that initially had none. Thanks to Dushyant Singh.\n\n## 1.12.0:\noption to build for browser-side use. Thanks to Michael Blum.\n\n## 1.11.4:\nfixed crash when `__proto__` is a tag name. Now using a safe check for the existence of properties in all cases. Thanks to Andrew Krasichkov.\n\nFixed XSS attack vector via `textarea` tags (when explicitly allowed). Decided that `script` (obviously) and `style` (due to its own XSS vectors) cannot realistically be afforded any XSS protection if allowed, unless we add a full CSS parser. Thanks again to Andrew Krasichkov.\n\n## 1.11.3:\nbumped `htmlparser2` version to address crashing bug in older version. Thanks to e-jigsaw.\n\n## 1.11.2:\nfixed README typo that interfered with readability due to markdown issues. No code changes. Thanks to Mikael Korpela. Also improved code block highlighting in README. Thanks to Alex Siman.\n\n## 1.11.1:\nfixed a regression introduced in 1.11.0 which caused the closing tag of the parent of a `textarea` tag to be lost. Thanks to Stefano Sala, who contributed the missing test.\n\n## 1.11.0:\nadded the `nonTextTags` option, with tests.\n\n## 1.10.1:\ndocumentation cleanup. No code changes. Thanks to Rex Schrader.\n\n## 1.10.0:\n`allowedAttributes` now allows you to allow attributes for all tags by specifying `*` as the tag name. Thanks to Zdravko Georgiev.\n\n## 1.9.0:\n`parser` option allows options to be passed directly to `htmlparser`. Thanks to Danny Scott.\n\n## 1.8.0:\n\n* `transformTags` now accepts the `*` wildcard to transform all tags. Thanks to Jamy Timmermans.\n\n* Text that has been modified by `transformTags` is then passed through `textFilter`. Thanks to Pavlo Yurichuk.\n\n* Content inside `textarea` is discarded if `textarea` is not allowed. I don't know why it took me this long to see that this is just common sense. Thanks to David Frank.\n\n## 1.7.2:\nremoved `array-includes` dependency in favor of `indexOf`, which is a little more verbose but slightly faster and doesn't require a shim. Thanks again to Joseph Dykstra.\n\n## 1.7.1:\nremoved lodash dependency, adding lighter dependencies and polyfills in its place. Thanks to Joseph Dykstra.\n\n## 1.7.0:\nintroduced `allowedSchemesByTag` option. Thanks to Cameron Will.\n\n## 1.6.1:\nthe string `'undefined'` (as opposed to `undefined`) is perfectly valid text and shouldn't be expressly converted to the empty string.\n\n## 1.6.0:\nadded `textFilter` option. Thanks to Csaba Palfi.\n\n## 1.5.3:\ndo not escape special characters inside a script or style element, if they are allowed. This is consistent with the way browsers parse them; nothing closes them except the appropriate closing tag for the entire element. Of course, this only comes into play if you actually choose to allow those tags. Thanks to aletorrado.\n\n## 1.5.2:\nguard checks for allowed attributes correctly to avoid an undefined property error. Thanks to Zeke.\n\n## 1.5.1:\nupdated to htmlparser2 1.8.x. Started using the `decodeEntities` option, which allows us to pass our filter evasion tests without the need to recursively invoke the filter.\n\n## 1.5.0:\nsupport for `*` wildcards in allowedAttributes. With tests. Thanks to Calvin Montgomery.\n\n## 1.4.3:\ninvokes itself recursively until the markup stops changing to guard against [this issue](https://github.com/fb55/htmlparser2/issues/105). Bump to htmlparser2 version 3.7.x.\n\n## 1.4.1, 1.4.2:\nmore tests.\n\n## 1.4.0:\nability to  allow all attributes or tags through by setting `allowedAttributes` and/or `allowedTags` to false. Thanks to Anand Thakker.\n\n## 1.3.0:\n`attribs` now available on frames passed to exclusive filter.\n\n## 1.2.3:\nfixed another possible XSS attack vector; no definitive exploit was found but it looks possible. [See this issue.](https://github.com/punkave/sanitize-html/pull/20) Thanks to Jim O'Brien.\n\n## 1.2.2:\nreject `javascript:` URLs when disguised with an internal comment. This is probably not respected by browsers anyway except when inside an XML data island element, which you almost certainly are not allowing in your `allowedTags`, but we aim to be thorough. Thanks to Jim O'Brien.\n\n## 1.2.1:\nfixed crashing bug when presented with bad markup. The bug was in the `exclusiveFilter` mechanism. Unit test added. Thanks to Ilya Kantor for catching it.\n\n## 1.2.0:\n* The `allowedClasses` option now allows you to permit CSS classes in a fine-grained way.\n\n* Text passed to your `exclusiveFilter` function now includes the text of child elements, making it more useful for identifying elements that truly lack any inner text.\n\n## 1.1.7:\nuse `he` for entity decoding, because it is more actively maintained.\n\n## 1.1.6:\n`allowedSchemes` option for those who want to permit `data` URLs and such.\n\n## 1.1.5:\njust a packaging thing.\n\n## 1.1.4:\ncustom exclusion filter.\n\n## 1.1.3:\nmoved to lodash. 1.1.2 pointed to the wrong version of lodash.\n\n## 1.1.0:\nthe `transformTags` option was added. Thanks to [kl3ryk](https://github.com/kl3ryk).\n\n## 1.0.3:\nfixed several more javascript URL attack vectors after [studying the XSS filter evasion cheat sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) to better understand my enemy. Whitespace characters (codes from 0 to 32), which browsers ignore in URLs in certain cases allowing the \"javascript\" scheme to be snuck in, are now stripped out when checking for naughty URLs. Thanks again to [pinpickle](https://github.com/pinpickle).\n\n## 1.0.2:\nfixed a javascript URL attack vector. naughtyHref must entity-decode URLs and also check for mixed-case scheme names. Thanks to [pinpickle](https://github.com/pinpickle).\n\n## 1.0.1:\nDoc tweaks.\n\n## 1.0.0:\nIf the style tag is disallowed, then its content should be dumped, so that it doesn't appear as text. We were already doing this for script tags, however in both cases the content is now preserved if the tag is explicitly allowed.\n\nWe're rocking our tests and have been working great in production for months, so: declared 1.0.0 stable.\n\n## 0.1.3:\ndo not double-escape entities in attributes or text. Turns out the \"text\" provided by htmlparser2 is already escaped.\n\n## 0.1.2:\npackaging error meant it wouldn't install properly.\n\n## 0.1.1:\ndiscard the text of script tags.\n\n## 0.1.0:\ninitial release.\n", "const htmlparser = require('htmlparser2');\nconst escapeStringRegexp = require('escape-string-regexp');\nconst { isPlainObject } = require('is-plain-object');\nconst deepmerge = require('deepmerge');\nconst parseSrcset = require('parse-srcset');\nconst { parse: postcssParse } = require('postcss');\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n  'img', 'audio', 'video', 'picture', 'svg',\n  'object', 'map', 'iframe', 'embed'\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [ 'script', 'style' ];\n\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  const n = [];\n  each(a, function(v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nfunction isEmptyObject(obj) {\n  for (const key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function(part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n\n    return (\n      part.url +\n      (part.w ? ` ${part.w}w` : '') +\n      (part.h ? ` ${part.h}h` : '') +\n      (part.d ? ` ${part.d}x` : '')\n    );\n  }).join(', ');\n}\n\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  if (html == null) {\n    return '';\n  }\n\n  let result = '';\n  // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n  let tempResult = '';\n\n  function Frame(tag, attribs) {\n    const that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n    this.mediaChildren = [];\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n\n    this.updateParentNodeMediaChildren = function() {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n\n  // vulnerableTags\n  vulnerableTags.forEach(function (tag) {\n    if (\n      options.allowedTags && options.allowedTags.indexOf(tag) > -1 &&\n      !options.allowVulnerableTags\n    ) {\n      console.warn(`\\n\\n\u26a0\ufe0f Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n    }\n  });\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  const nonTextTagsArray = options.nonTextTags || [\n    'script',\n    'style',\n    'textarea',\n    'option'\n  ];\n  let allowedAttributesMap;\n  let allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      const globRegex = [];\n      attributes.forEach(function(obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n  const allowedClassesMap = {};\n  const allowedClassesGlobMap = {};\n  const allowedClassesRegexMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = [];\n    allowedClassesRegexMap[tag] = [];\n    const globRegex = [];\n    classes.forEach(function(obj) {\n      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n        globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n      } else if (obj instanceof RegExp) {\n        allowedClassesRegexMap[tag].push(obj);\n      } else {\n        allowedClassesMap[tag].push(obj);\n      }\n    });\n    if (globRegex.length) {\n      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    }\n  });\n\n  const transformTagsMap = {};\n  let transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    let transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  let depth;\n  let stack;\n  let skipMap;\n  let transformMap;\n  let skipText;\n  let skipTextDepth;\n  let addedText = false;\n\n  initializeState();\n\n  const parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      const frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      let skip = false;\n      const hasText = !!frame.text;\n      let transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if ((options.allowedTags && options.allowedTags.indexOf(name) === -1) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {\n        skip = true;\n        skipMap[depth] = true;\n        if (options.disallowedTagsMode === 'discard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard') {\n          // We want the contents but not this tag\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      result += '<' + name;\n\n      if (name === 'script') {\n        if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n          frame.innerText = '';\n        }\n      }\n\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          let passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap ||\n            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||\n            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||\n            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            for (const o of allowedAttributesMap[name]) {\n              if (isPlainObject(o) && o.name && (o.name === a)) {\n                passedAllowedAttributesMapCheck = true;\n                let newValue = '';\n                if (o.multiple === true) {\n                  // verify the values that are allowed\n                  const splitStrArray = value.split(' ');\n                  for (const s of splitStrArray) {\n                    if (o.values.indexOf(s) !== -1) {\n                      if (newValue === '') {\n                        newValue = s;\n                      } else {\n                        newValue += ' ' + s;\n                      }\n                    }\n                  }\n                } else if (o.values.indexOf(value) >= 0) {\n                  // verified an allowed value matches the entire attribute value\n                  newValue = value;\n                }\n                value = newValue;\n              }\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'script' && a === 'src') {\n\n              let allowed = true;\n\n              try {\n                const parsed = parseUrl(value);\n\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                allowed = false;\n              }\n\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'iframe' && a === 'src') {\n              let allowed = true;\n              try {\n                const parsed = parseUrl(value);\n\n                if (parsed.isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  allowed = has(options, 'allowIframeRelativeUrls')\n                    ? options.allowIframeRelativeUrls\n                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                let parsed = parseSrcset(value);\n                parsed.forEach(function(value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function(v) {\n                  return !v.evil;\n                });\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(parsed, function(v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              const allowedSpecificClasses = allowedClassesMap[name];\n              const allowedWildcardClasses = allowedClassesMap['*'];\n              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              const allowedClassesGlobs = [\n                allowedSpecificClassesGlob,\n                allowedWildcardClassesGlob\n              ]\n                .concat(allowedSpecificClassesRegex)\n                .filter(function (t) {\n                  return t;\n                });\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              try {\n                const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');\n                const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n\n                value = stringifyStyleAttributes(filteredAST);\n\n                if (value.length === 0) {\n                  delete frame.attribs[a];\n                  return;\n                }\n              } catch (e) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            result += ' ' + a;\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      const lastFrame = stack[stack.length - 1];\n      let tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (options.disallowedTagsMode === 'discard' && ((tag === 'script') || (tag === 'style'))) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        const escaped = escapeHtml(text, false);\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        const frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      const frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      const skip = skipMap[depth];\n      if (skip) {\n        delete skipMap[depth];\n        if (options.disallowedTagsMode === 'discard') {\n          frame.updateParentNodeText();\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n        return;\n      }\n\n      result += '</' + name + '>';\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n      addedText = false;\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n\n  function escapeHtml(s, quote) {\n    if (typeof (s) !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    while (true) {\n      const firstIndex = href.indexOf('<!--');\n      if (firstIndex === -1) {\n        break;\n      }\n      const lastIndex = href.indexOf('-->', firstIndex + 4);\n      if (lastIndex === -1) {\n        break;\n      }\n      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);\n    }\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    const scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  function parseUrl(value) {\n    value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n    if (value.startsWith('relative:')) {\n      // An attempt to exploit our workaround for base URLs being\n      // mandatory for relative URL validation in the WHATWG\n      // URL parser, reject it\n      throw new Error('relative: exploit attempt');\n    }\n    // naughtyHref is in charge of whether protocol relative URLs\n    // are cool. Here we are concerned just with allowed hostnames and\n    // whether to allow relative URLs.\n    //\n    // Build a placeholder \"base URL\" against which any reasonable\n    // relative URL may be parsed successfully\n    let base = 'relative://relative-site';\n    for (let i = 0; (i < 100); i++) {\n      base += `/${i}`;\n    }\n\n    const parsed = new URL(value, base);\n\n    const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n    return {\n      isRelativeUrl,\n      url: parsed\n    };\n  }\n  /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    const astRules = abstractSyntaxTree.nodes[0];\n    let selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(\n        allowedStyles[astRules.selector],\n        allowedStyles['*']\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return abstractSyntaxTree;\n  }\n\n  /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes\n      .reduce(function(extractedAttributes, attrObject) {\n        extractedAttributes.push(\n          `${attrObject.prop}:${attrObject.value}${attrObject.important ? ' !important' : ''}`\n        );\n        return extractedAttributes;\n      }, [])\n      .join(';');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is allowlisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nconst htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [\n    // Sections derived from MDN element categories and limited to the more\n    // benign categories.\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n    // Content sectioning\n    'address', 'article', 'aside', 'footer', 'header',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',\n    'main', 'nav', 'section',\n    // Text content\n    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',\n    'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',\n    // Inline text semantics\n    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',\n    'em', 'i', 'kbd', 'mark', 'q',\n    'rb', 'rp', 'rt', 'rtc', 'ruby',\n    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',\n    // Table content\n    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',\n    'thead', 'tr'\n  ],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but\n    // these attributes would make sense if we did.\n    img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    let attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n", "{\n  \"name\": \"sanitize-html\",\n  \"version\": \"2.7.1\",\n  \"description\": \"Clean up user-submitted HTML, preserving allowlisted elements and allowlisted attributes on a per-element basis\",\n  \"sideEffects\": false,\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"npx eslint . && mocha test/test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/apostrophecms/sanitize-html.git\"\n  },\n  \"keywords\": [\n    \"html\",\n    \"parser\",\n    \"sanitizer\",\n    \"sanitize\"\n  ],\n  \"author\": \"Apostrophe Technologies, Inc.\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"deepmerge\": \"^4.2.2\",\n    \"escape-string-regexp\": \"^4.0.0\",\n    \"htmlparser2\": \"^6.0.0\",\n    \"is-plain-object\": \"^5.0.0\",\n    \"parse-srcset\": \"^1.0.2\",\n    \"postcss\": \"^8.3.11\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^7.3.1\",\n    \"eslint-config-apostrophe\": \"^3.4.0\",\n    \"eslint-config-standard\": \"^14.1.1\",\n    \"eslint-plugin-import\": \"^2.25.2\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-promise\": \"^4.2.1\",\n    \"eslint-plugin-standard\": \"^4.0.1\",\n    \"mocha\": \"^7.0.0\",\n    \"sinon\": \"^9.0.2\"\n  }\n}\n"], "filenames": ["CHANGELOG.md", "index.js", "package.json"], "buggy_code_start_loc": [3, 615, 3], "buggy_code_end_loc": [4, 616, 4], "fixing_code_start_loc": [3, 615, 3], "fixing_code_end_loc": [7, 626, 4], "type": "NVD-CWE-Other", "message": "The package sanitize-html before 2.7.1 are vulnerable to Regular Expression Denial of Service (ReDoS) due to insecure global regular expression replacement logic of HTML comment removal.", "other": {"cve": {"id": "CVE-2022-25887", "sourceIdentifier": "report@snyk.io", "published": "2022-08-30T05:15:07.727", "lastModified": "2022-09-01T20:38:27.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package sanitize-html before 2.7.1 are vulnerable to Regular Expression Denial of Service (ReDoS) due to insecure global regular expression replacement logic of HTML comment removal."}, {"lang": "es", "value": "El paquete sanitize-html versiones anteriores a 2.7.1, es vulnerable a una Denegaci\u00f3n de Servicio por Expresi\u00f3n Regular (ReDoS) debido a una inseguridad de la l\u00f3gica de reemplazo global de expresiones regulares en la eliminaci\u00f3n de comentarios HTML"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apostrophecms:sanitize-html:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.7.1", "matchCriteriaId": "07CE3D84-F7A6-47CA-83D7-7A91E58D47B8"}]}]}], "references": [{"url": "https://github.com/apostrophecms/sanitize-html/commit/b4682c12fd30e12e82fa2d9b766de91d7d2cd23c", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/apostrophecms/sanitize-html/pull/557", "source": "report@snyk.io", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-3008102", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-SANITIZEHTML-2957526", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apostrophecms/sanitize-html/commit/b4682c12fd30e12e82fa2d9b766de91d7d2cd23c"}}