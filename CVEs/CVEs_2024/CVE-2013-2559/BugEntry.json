{"buggy_code": ["<?php\n\t/**\n\t * @package toolkit\n\t */\n\t/**\n\t * The `AuthorManager` class is responsible for managing all Author objects\n\t * in Symphony. Unlike other Manager objects, Authors are stored in the\n\t * database in `tbl_authors` and not on the file system. CRUD methods are\n\t * implemented to allow Authors to be created (add), read (fetch), updated\n\t * (edit) and deleted (delete).\n\t */\n\n\trequire_once(TOOLKIT . '/class.author.php');\n\n\tClass AuthorManager {\n\n\t\t/**\n\t\t * An array of all the objects that the Manager is responsible for.\n\t\t * Defaults to an empty array.\n\t\t * @var array\n\t\t */\n\t\tprotected static $_pool = array();\n\n\t\t/**\n\t\t * Given an associative array of fields, insert them into the database\n\t\t * returning the resulting Author ID if successful, or false if there\n\t\t * was an error\n\t\t *\n\t\t * @param array $fields\n\t\t *  Associative array of field names => values for the Author object\n\t\t * @return integer|boolean\n\t\t *  Returns an Author ID of the created Author on success, false otherwise.\n\t\t */\n\t\tpublic static function add(array $fields) {\n\t\t\tif(!Symphony::Database()->insert($fields, 'tbl_authors')) return false;\n\t\t\t$author_id = Symphony::Database()->getInsertID();\n\n\t\t\treturn $author_id;\n\t\t}\n\n\t\t/**\n\t\t * Given an Author ID and associative array of fields, update an existing Author\n\t\t * row in the `tbl_authors` database table. Returns boolean for success/failure\n\t\t *\n\t\t * @param integer $id\n\t\t *  The ID of the Author that should be updated\n\t\t * @param array $fields\n\t\t *  Associative array of field names => values for the Author object\n\t\t *  This array does need to contain every value for the author object, it\n\t\t *  can just be the changed values.\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function edit($id, array $fields) {\n\t\t\treturn Symphony::Database()->update($fields, 'tbl_authors', sprintf(\n\t\t\t\t\" `id` = %d\", $id\n\t\t\t));\n\t\t}\n\n\t\t/**\n\t\t * Given an Author ID, delete an Author from Symphony.\n\t\t *\n\t\t * @param integer $id\n\t\t *  The ID of the Author that should be deleted\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function delete($id) {\n\t\t\treturn Symphony::Database()->delete('tbl_authors', sprintf(\n\t\t\t\t\" `id` = %d\", $id\n\t\t\t));\n\t\t}\n\n\t\t/**\n\t\t * The fetch method returns all Authors from Symphony with the option to sort\n\t\t * or limit the output. This method returns an array of Author objects.\n\t\t *\n\t\t * @param string $sortby\n\t\t *  The field to sort the authors by, defaults to 'id'\n\t\t * @param string $sortdirection\n\t\t *  Available values of ASC (Ascending) or DESC (Descending), which refer to the\n\t\t *  sort order for the query. Defaults to ASC (Ascending)\n\t\t * @param integer $limit\n\t\t *  The number of rows to return\n\t\t * @param integer $start\n\t\t *  The offset start point for limiting, maps to the LIMIT {x}, {y} MySQL functionality\n\t\t * @param string $where\n\t\t *  Any custom WHERE clauses. The `tbl_authors` alias is `a`\n\t\t * @param string $joins\n\t\t *  Any custom JOIN's\n\t\t * @return array\n\t\t *  An array of Author objects. If no Authors are found, an empty array is returned.\n\t\t */\n\t\tpublic static function fetch($sortby = 'id', $sortdirection = 'ASC', $limit = null, $start = null, $where = null, $joins = null) {\n\n\t\t\t$records = Symphony::Database()->fetch(sprintf(\"\n\t\t\t\t\tSELECT a.*\n\t\t\t\t\tFROM `tbl_authors` AS `a`\n\t\t\t\t\t%s\n\t\t\t\t\tWHERE %s\n\t\t\t\t\tORDER BY %s %s\n\t\t\t\t\t%s %s\n\t\t\t\t\",\n\t\t\t\t$joins,\n\t\t\t\t($where) ? $where : 1,\n\t\t\t\t'a.'.$sortby, $sortdirection,\n\t\t\t\t($limit) ? \"LIMIT \" . $limit : '',\n\t\t\t\t($start && $limit) ? ', ' . $start : ''\n\t\t\t));\n\n\t\t\tif(!is_array($records) || empty($records)) return array();\n\n\t\t\t$authors = array();\n\n\t\t\tforeach($records as $row){\n\t\t\t\t$author = new Author;\n\n\t\t\t\tforeach($row as $field => $val) {\n\t\t\t\t\t$author->set($field, $val);\n\t\t\t\t}\n\n\t\t\t\tself::$_pool[$author->get('id')] = $author;\n\t\t\t\t$authors[] = $author;\n\t\t\t}\n\n\t\t\treturn $authors;\n\t\t}\n\n\t\t/**\n\t\t * Returns Author's that match the provided ID's with the option to\n\t\t * sort or limit the output. This function will search the\n\t\t * `AuthorManager::$_pool` for Authors first before querying `tbl_authors`\n\t\t *\n\t\t * @param integer|array $id\n\t\t *  A single ID or an array of ID's\n\t\t * @return mixed\n\t\t *  If `$id` is an integer, the result will be an Author object,\n\t\t *  otherwise an array of Author objects will be returned. If no\n\t\t *  Authors are found, or no `$id` is given, `null` is returned.\n\t\t */\n\t\tpublic static function fetchByID($id) {\n\t\t\t$return_single = false;\n\n\t\t\tif(is_null($id)) return null;\n\n\t\t\tif(!is_array($id)){\n\t\t\t\t$return_single = true;\n\t\t\t\t$id = array((int)$id);\n\t\t\t}\n\n\t\t\tif(empty($id)) return null;\n\n\t\t\t$authors = array();\n\t\t\t$pooled_authors = array();\n\n\t\t\t// Get all the Author ID's that are already in `self::$_pool`\n\t\t\t$pooled_authors = array_intersect($id, array_keys(self::$_pool));\n\t\t\tforeach($pooled_authors as $pool_author) {\n\t\t\t\t$authors[] = self::$_pool[$pool_author];\n\t\t\t}\n\n\t\t\t// Get all the Author ID's that are not already stored in `self::$_pool`\n\t\t\t$id = array_diff($id, array_keys(self::$_pool));\n\t\t\t$id = array_filter($id);\n\n\t\t\tif(empty($id)) return ($return_single ? $authors[0] : $authors);\n\n\t\t\t$records = Symphony::Database()->fetch(sprintf(\"\n\t\t\t\t\tSELECT *\n\t\t\t\t\tFROM `tbl_authors`\n\t\t\t\t\tWHERE `id` IN (%s)\n\t\t\t\t\",\n\t\t\t\timplode(\",\", $id)\n\t\t\t));\n\n\t\t\tif(!is_array($records) || empty($records)) return ($return_single ? $authors[0] : $authors);\n\n\t\t\tforeach($records as $row){\n\t\t\t\t$author = new Author;\n\n\t\t\t\tforeach($row as $field => $val) {\n\t\t\t\t\t$author->set($field, $val);\n\t\t\t\t}\n\t\t\t\tself::$_pool[$author->get('id')] = $author;\n\t\t\t\t$authors[] = $author;\n\t\t\t}\n\n\t\t\treturn ($return_single ? $authors[0] : $authors);\n\t\t}\n\n\t\t/**\n\t\t * Returns an Author by Username. This function will search the\n\t\t * `AuthorManager::$_pool` for Authors first before querying `tbl_authors`\n\t\t *\n\t\t * @param string $username\n\t\t *  The Author's username\n\t\t * @return Author|null\n\t\t *  If an Author is found, an Author object is returned, otherwise null.\n\t\t */\n\t\tpublic static function fetchByUsername($username) {\n\t\t\tif(!isset(self::$_pool[$username])) {\n\t\t\t\t$records = Symphony::Database()->fetchRow(0, sprintf(\"\n\t\t\t\t\t\tSELECT *\n\t\t\t\t\t\tFROM `tbl_authors`\n\t\t\t\t\t\tWHERE `username` = '%s'\n\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\",\tSymphony::Database()->cleanValue($username)\n\t\t\t\t));\n\n\t\t\t\tif(!is_array($records) || empty($records)) return array();\n\n\t\t\t\t$author = new Author;\n\n\t\t\t\tforeach($records as $field => $val) {\n\t\t\t\t\t$author->set($field, $val);\n\t\t\t\t}\n\n\t\t\t\tself::$_pool[$username] = $author;\n\t\t\t}\n\n\t\t\treturn self::$_pool[$username];\n\t\t}\n\n\t\t/**\n\t\t * This function will allow an Author to sign into Symphony by using their\n\t\t * authentication token as well as username/password.\n\t\t *\n\t\t * @param integer $author_id\n\t\t *  The Author ID to allow to use their authentication token.\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function activateAuthToken($author_id) {\n\t\t\tif(!is_int($author_id)) return false;\n\t\t\treturn Symphony::Database()->query(sprintf(\"\n\t\t\t\tUPDATE `tbl_authors`\n\t\t\t\tSET `auth_token_active` = 'yes'\n\t\t\t\tWHERE `id` = %d\n\t\t\t\", $author_id));\n\t\t}\n\n\t\t/**\n\t\t * This function will remove the ability for an Author to sign into Symphony\n\t\t * by using their authentication token\n\t\t *\n\t\t * @param integer $author_id\n\t\t *  The Author ID to allow to use their authentication token.\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function deactivateAuthToken($author_id) {\n\t\t\tif(!is_int($author_id)) return false;\n\t\t\treturn Symphony::Database()->query(sprintf(\"\n\t\t\t\tUPDATE `tbl_authors`\n\t\t\t\tSET `auth_token_active` = 'no'\n\t\t\t\tWHERE `id` = %d\n\t\t\t\", $author_id));\n\t\t}\n\n\t}\n"], "fixing_code": ["<?php\n\t/**\n\t * @package toolkit\n\t */\n\t/**\n\t * The `AuthorManager` class is responsible for managing all Author objects\n\t * in Symphony. Unlike other Manager objects, Authors are stored in the\n\t * database in `tbl_authors` and not on the file system. CRUD methods are\n\t * implemented to allow Authors to be created (add), read (fetch), updated\n\t * (edit) and deleted (delete).\n\t */\n\n\trequire_once(TOOLKIT . '/class.author.php');\n\n\tClass AuthorManager {\n\n\t\t/**\n\t\t * An array of all the objects that the Manager is responsible for.\n\t\t * Defaults to an empty array.\n\t\t * @var array\n\t\t */\n\t\tprotected static $_pool = array();\n\n\t\t/**\n\t\t * Given an associative array of fields, insert them into the database\n\t\t * returning the resulting Author ID if successful, or false if there\n\t\t * was an error\n\t\t *\n\t\t * @param array $fields\n\t\t *  Associative array of field names => values for the Author object\n\t\t * @return integer|boolean\n\t\t *  Returns an Author ID of the created Author on success, false otherwise.\n\t\t */\n\t\tpublic static function add(array $fields) {\n\t\t\tif(!Symphony::Database()->insert($fields, 'tbl_authors')) return false;\n\t\t\t$author_id = Symphony::Database()->getInsertID();\n\n\t\t\treturn $author_id;\n\t\t}\n\n\t\t/**\n\t\t * Given an Author ID and associative array of fields, update an existing Author\n\t\t * row in the `tbl_authors` database table. Returns boolean for success/failure\n\t\t *\n\t\t * @param integer $id\n\t\t *  The ID of the Author that should be updated\n\t\t * @param array $fields\n\t\t *  Associative array of field names => values for the Author object\n\t\t *  This array does need to contain every value for the author object, it\n\t\t *  can just be the changed values.\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function edit($id, array $fields) {\n\t\t\treturn Symphony::Database()->update($fields, 'tbl_authors', sprintf(\n\t\t\t\t\" `id` = %d\", $id\n\t\t\t));\n\t\t}\n\n\t\t/**\n\t\t * Given an Author ID, delete an Author from Symphony.\n\t\t *\n\t\t * @param integer $id\n\t\t *  The ID of the Author that should be deleted\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function delete($id) {\n\t\t\treturn Symphony::Database()->delete('tbl_authors', sprintf(\n\t\t\t\t\" `id` = %d\", $id\n\t\t\t));\n\t\t}\n\n\t\t/**\n\t\t * The fetch method returns all Authors from Symphony with the option to sort\n\t\t * or limit the output. This method returns an array of Author objects.\n\t\t *\n\t\t * @param string $sortby\n\t\t *  The field to sort the authors by, defaults to 'id'\n\t\t * @param string $sortdirection\n\t\t *  Available values of ASC (Ascending) or DESC (Descending), which refer to the\n\t\t *  sort order for the query. Defaults to ASC (Ascending)\n\t\t * @param integer $limit\n\t\t *  The number of rows to return\n\t\t * @param integer $start\n\t\t *  The offset start point for limiting, maps to the LIMIT {x}, {y} MySQL functionality\n\t\t * @param string $where\n\t\t *  Any custom WHERE clauses. The `tbl_authors` alias is `a`\n\t\t * @param string $joins\n\t\t *  Any custom JOIN's\n\t\t * @return array\n\t\t *  An array of Author objects. If no Authors are found, an empty array is returned.\n\t\t */\n\t\tpublic static function fetch($sortby = 'id', $sortdirection = 'ASC', $limit = null, $start = null, $where = null, $joins = null) {\n\t\t\t$sortby = is_null($sortby) ? 'id' : Symphony::Database()->cleanValue($sortby);\n\t\t\t$sortdirection = $sortdirection === 'ASC' ? 'ASC' : 'DESC';\n\n\t\t\t$records = Symphony::Database()->fetch(sprintf(\"\n\t\t\t\t\tSELECT a.*\n\t\t\t\t\tFROM `tbl_authors` AS `a`\n\t\t\t\t\t%s\n\t\t\t\t\tWHERE %s\n\t\t\t\t\tORDER BY %s %s\n\t\t\t\t\t%s %s\n\t\t\t\t\",\n\t\t\t\t$joins,\n\t\t\t\t($where) ? $where : 1,\n\t\t\t\t'a.'. $sortby, $sortdirection,\n\t\t\t\t($limit) ? \"LIMIT \" . $limit : '',\n\t\t\t\t($start && $limit) ? ', ' . $start : ''\n\t\t\t));\n\n\t\t\tif(!is_array($records) || empty($records)) return array();\n\n\t\t\t$authors = array();\n\n\t\t\tforeach($records as $row){\n\t\t\t\t$author = new Author;\n\n\t\t\t\tforeach($row as $field => $val) {\n\t\t\t\t\t$author->set($field, $val);\n\t\t\t\t}\n\n\t\t\t\tself::$_pool[$author->get('id')] = $author;\n\t\t\t\t$authors[] = $author;\n\t\t\t}\n\n\t\t\treturn $authors;\n\t\t}\n\n\t\t/**\n\t\t * Returns Author's that match the provided ID's with the option to\n\t\t * sort or limit the output. This function will search the\n\t\t * `AuthorManager::$_pool` for Authors first before querying `tbl_authors`\n\t\t *\n\t\t * @param integer|array $id\n\t\t *  A single ID or an array of ID's\n\t\t * @return mixed\n\t\t *  If `$id` is an integer, the result will be an Author object,\n\t\t *  otherwise an array of Author objects will be returned. If no\n\t\t *  Authors are found, or no `$id` is given, `null` is returned.\n\t\t */\n\t\tpublic static function fetchByID($id) {\n\t\t\t$return_single = false;\n\n\t\t\tif(is_null($id)) return null;\n\n\t\t\tif(!is_array($id)){\n\t\t\t\t$return_single = true;\n\t\t\t\t$id = array((int)$id);\n\t\t\t}\n\n\t\t\tif(empty($id)) return null;\n\n\t\t\t$authors = array();\n\t\t\t$pooled_authors = array();\n\n\t\t\t// Get all the Author ID's that are already in `self::$_pool`\n\t\t\t$pooled_authors = array_intersect($id, array_keys(self::$_pool));\n\t\t\tforeach($pooled_authors as $pool_author) {\n\t\t\t\t$authors[] = self::$_pool[$pool_author];\n\t\t\t}\n\n\t\t\t// Get all the Author ID's that are not already stored in `self::$_pool`\n\t\t\t$id = array_diff($id, array_keys(self::$_pool));\n\t\t\t$id = array_filter($id);\n\n\t\t\tif(empty($id)) return ($return_single ? $authors[0] : $authors);\n\n\t\t\t$records = Symphony::Database()->fetch(sprintf(\"\n\t\t\t\t\tSELECT *\n\t\t\t\t\tFROM `tbl_authors`\n\t\t\t\t\tWHERE `id` IN (%s)\n\t\t\t\t\",\n\t\t\t\timplode(\",\", $id)\n\t\t\t));\n\n\t\t\tif(!is_array($records) || empty($records)) return ($return_single ? $authors[0] : $authors);\n\n\t\t\tforeach($records as $row){\n\t\t\t\t$author = new Author;\n\n\t\t\t\tforeach($row as $field => $val) {\n\t\t\t\t\t$author->set($field, $val);\n\t\t\t\t}\n\t\t\t\tself::$_pool[$author->get('id')] = $author;\n\t\t\t\t$authors[] = $author;\n\t\t\t}\n\n\t\t\treturn ($return_single ? $authors[0] : $authors);\n\t\t}\n\n\t\t/**\n\t\t * Returns an Author by Username. This function will search the\n\t\t * `AuthorManager::$_pool` for Authors first before querying `tbl_authors`\n\t\t *\n\t\t * @param string $username\n\t\t *  The Author's username\n\t\t * @return Author|null\n\t\t *  If an Author is found, an Author object is returned, otherwise null.\n\t\t */\n\t\tpublic static function fetchByUsername($username) {\n\t\t\tif(!isset(self::$_pool[$username])) {\n\t\t\t\t$records = Symphony::Database()->fetchRow(0, sprintf(\"\n\t\t\t\t\t\tSELECT *\n\t\t\t\t\t\tFROM `tbl_authors`\n\t\t\t\t\t\tWHERE `username` = '%s'\n\t\t\t\t\t\tLIMIT 1\n\t\t\t\t\t\",\tSymphony::Database()->cleanValue($username)\n\t\t\t\t));\n\n\t\t\t\tif(!is_array($records) || empty($records)) return array();\n\n\t\t\t\t$author = new Author;\n\n\t\t\t\tforeach($records as $field => $val) {\n\t\t\t\t\t$author->set($field, $val);\n\t\t\t\t}\n\n\t\t\t\tself::$_pool[$username] = $author;\n\t\t\t}\n\n\t\t\treturn self::$_pool[$username];\n\t\t}\n\n\t\t/**\n\t\t * This function will allow an Author to sign into Symphony by using their\n\t\t * authentication token as well as username/password.\n\t\t *\n\t\t * @param integer $author_id\n\t\t *  The Author ID to allow to use their authentication token.\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function activateAuthToken($author_id) {\n\t\t\tif(!is_int($author_id)) return false;\n\t\t\treturn Symphony::Database()->query(sprintf(\"\n\t\t\t\tUPDATE `tbl_authors`\n\t\t\t\tSET `auth_token_active` = 'yes'\n\t\t\t\tWHERE `id` = %d\n\t\t\t\", $author_id));\n\t\t}\n\n\t\t/**\n\t\t * This function will remove the ability for an Author to sign into Symphony\n\t\t * by using their authentication token\n\t\t *\n\t\t * @param integer $author_id\n\t\t *  The Author ID to allow to use their authentication token.\n\t\t * @return boolean\n\t\t */\n\t\tpublic static function deactivateAuthToken($author_id) {\n\t\t\tif(!is_int($author_id)) return false;\n\t\t\treturn Symphony::Database()->query(sprintf(\"\n\t\t\t\tUPDATE `tbl_authors`\n\t\t\t\tSET `auth_token_active` = 'no'\n\t\t\t\tWHERE `id` = %d\n\t\t\t\", $author_id));\n\t\t}\n\n\t}\n"], "filenames": ["symphony/lib/toolkit/class.authormanager.php"], "buggy_code_start_loc": [92], "buggy_code_end_loc": [105], "fixing_code_start_loc": [93], "fixing_code_end_loc": [107], "type": "CWE-89", "message": "SQL injection vulnerability in Symphony CMS before 2.3.2 allows remote authenticated users to execute arbitrary SQL commands via the sort parameter to system/authors/.  NOTE: this can be leveraged using CSRF to allow remote unauthenticated attackers to execute arbitrary SQL commands.", "other": {"cve": {"id": "CVE-2013-2559", "sourceIdentifier": "cve@mitre.org", "published": "2014-03-27T16:55:05.537", "lastModified": "2020-08-25T15:59:18.950", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "SQL injection vulnerability in Symphony CMS before 2.3.2 allows remote authenticated users to execute arbitrary SQL commands via the sort parameter to system/authors/.  NOTE: this can be leveraged using CSRF to allow remote unauthenticated attackers to execute arbitrary SQL commands."}, {"lang": "es", "value": "Vulnerabilidad de inyecci\u00f3n SQL en Symphony CMS anterior a 2.3.2 permite a usuarios remotos autenticados ejecutar comandos SQL arbitrarios a trav\u00e9s del par\u00e1metro sort hacia system/authors/.  NOTA: esto puede ser aprovechado mediante el uso de CSRF para permitir a atacantes remotos no autenticados ejecutar comandos SQL arbitrarios."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.1", "matchCriteriaId": "6C440112-0B21-4832-A89C-1A343B627039"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "254956B4-E86A-429C-A8E6-0ABA833A9DB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "13379528-0C53-474F-B2E7-D5650C7F5F3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "8865CA96-3DF6-4499-8CEC-59977CC86FEB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "570A8AE5-E4A6-4400-982C-F725D15E35ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "EB2D9ACA-2A2A-4169-A8AC-ED259921E24B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "394B8CA2-4C11-4C2C-8BFE-C2BADA341502"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "C9D49697-497A-44EC-892B-DB8C5545AFE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "C922F66F-8E3D-404C-95B7-C57DA8DDC162"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.3:*:*:*:*:*:*:*", "matchCriteriaId": "DF41854C-206A-4BCF-B6FD-55253E3BC0AF"}]}]}], "references": [{"url": "http://archives.neohapsis.com/archives/bugtraq/2013-04/0018.html", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "http://www.getsymphony.com/download/releases/version/2.3.2", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/58843", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/83227", "source": "cve@mitre.org"}, {"url": "https://github.com/symphonycms/symphony-2/commit/6c8aa4e9c810994f7632837487426867ce50f468", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://www.htbridge.com/advisory/HTB23148", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/symphonycms/symphony-2/commit/6c8aa4e9c810994f7632837487426867ce50f468"}}