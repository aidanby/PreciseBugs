{"buggy_code": ["/*\n** codegen.c - mruby code generator\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/compile.h>\n#include <mruby/proc.h>\n#include <mruby/dump.h>\n#include <mruby/numeric.h>\n#include <mruby/string.h>\n#include <mruby/debug.h>\n#include <mruby/presym.h>\n#include \"node.h\"\n#include <mruby/opcode.h>\n#include <mruby/re.h>\n#include <mruby/throw.h>\n#include <ctype.h>\n#include <string.h>\n\n#ifndef MRB_CODEGEN_LEVEL_MAX\n#define MRB_CODEGEN_LEVEL_MAX 256\n#endif\n\n#define MAXARG_S (1<<16)\n\ntypedef mrb_ast_node node;\ntypedef struct mrb_parser_state parser_state;\n\nenum looptype {\n  LOOP_NORMAL,\n  LOOP_BLOCK,\n  LOOP_FOR,\n  LOOP_BEGIN,\n  LOOP_RESCUE,\n};\n\nstruct loopinfo {\n  enum looptype type;\n  uint32_t pc0;                 /* `next` destination */\n  uint32_t pc1;                 /* `redo` destination */\n  uint32_t pc2;                 /* `break` destination */\n  int reg;                      /* destination register */\n  struct loopinfo *prev;\n};\n\ntypedef struct scope {\n  mrb_state *mrb;\n  mrb_pool *mpool;\n\n  struct scope *prev;\n\n  node *lv;\n\n  uint16_t sp;\n  uint32_t pc;\n  uint32_t lastpc;\n  uint32_t lastlabel;\n  uint16_t ainfo:15;\n  mrb_bool mscope:1;\n\n  struct loopinfo *loop;\n  mrb_sym filename_sym;\n  uint16_t lineno;\n\n  mrb_code *iseq;\n  uint16_t *lines;\n  uint32_t icapa;\n\n  mrb_irep *irep;\n  mrb_pool_value *pool;\n  mrb_sym *syms;\n  mrb_irep **reps;\n  struct mrb_irep_catch_handler *catch_table;\n  uint32_t pcapa, scapa, rcapa;\n\n  uint16_t nlocals;\n  uint16_t nregs;\n  int ai;\n\n  int debug_start_pos;\n  uint16_t filename_index;\n  parser_state* parser;\n\n  int rlev;                     /* recursion levels */\n} codegen_scope;\n\nstatic codegen_scope* scope_new(mrb_state *mrb, codegen_scope *prev, node *lv);\nstatic void scope_finish(codegen_scope *s);\nstatic struct loopinfo *loop_push(codegen_scope *s, enum looptype t);\nstatic void loop_break(codegen_scope *s, node *tree);\nstatic void loop_pop(codegen_scope *s, int val);\n\n/*\n * The search for catch handlers starts at the end of the table in mrb_vm_run().\n * Therefore, the next handler to be added must meet one of the following conditions.\n * - Larger start position\n * - Same start position but smaller end position\n */\nstatic int catch_handler_new(codegen_scope *s);\nstatic void catch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target);\n\nstatic void gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val);\nstatic void gen_vmassignment(codegen_scope *s, node *tree, int sp, int val);\n\nstatic void codegen(codegen_scope *s, node *tree, int val);\nstatic void raise_error(codegen_scope *s, const char *msg);\n\nstatic void\ncodegen_error(codegen_scope *s, const char *message)\n{\n  if (!s) return;\n#ifndef MRB_NO_STDIO\n  if (s->filename_sym && s->lineno) {\n    const char *filename = mrb_sym_name_len(s->mrb, s->filename_sym, NULL);\n    fprintf(stderr, \"%s:%d: %s\\n\", filename, s->lineno, message);\n  }\n  else {\n    fprintf(stderr, \"%s\\n\", message);\n  }\n#endif\n  while (s->prev) {\n    codegen_scope *tmp = s->prev;\n    if (s->irep) {\n      mrb_free(s->mrb, s->iseq);\n      for (int i=0; i<s->irep->plen; i++) {\n        mrb_pool_value *pv = &s->pool[i];\n        if ((pv->tt & 0x3) == IREP_TT_STR || pv->tt == IREP_TT_BIGINT) {\n          mrb_free(s->mrb, (void*)pv->u.str);\n        }\n      }\n      mrb_free(s->mrb, s->pool);\n      mrb_free(s->mrb, s->syms);\n      mrb_free(s->mrb, s->catch_table);\n      if (s->reps) {\n        /* copied from mrb_irep_free() in state.c */\n        for (int i=0; i<s->irep->rlen; i++) {\n          if (s->reps[i])\n            mrb_irep_decref(s->mrb, (mrb_irep*)s->reps[i]);\n        }\n        mrb_free(s->mrb, s->reps);\n      }\n      mrb_free(s->mrb, s->lines);\n    }\n    mrb_pool_close(s->mpool);\n    s = tmp;\n  }\n  MRB_THROW(s->mrb->jmp);\n}\n\nstatic void*\ncodegen_palloc(codegen_scope *s, size_t len)\n{\n  void *p = mrb_pool_alloc(s->mpool, len);\n\n  if (!p) codegen_error(s, \"pool memory allocation\");\n  return p;\n}\n\nstatic void*\ncodegen_realloc(codegen_scope *s, void *p, size_t len)\n{\n  p = mrb_realloc_simple(s->mrb, p, len);\n\n  if (!p && len > 0) codegen_error(s, \"mrb_realloc\");\n  return p;\n}\n\nstatic void\ncheck_no_ext_ops(codegen_scope *s, uint16_t a, uint16_t b)\n{\n  if (s->parser->no_ext_ops && (a | b) > 0xff) {\n    codegen_error(s, \"need OP_EXTs instruction (currently OP_EXTs are prohibited)\");\n  }\n}\n\nstatic int\nnew_label(codegen_scope *s)\n{\n  return s->lastlabel = s->pc;\n}\n\nstatic void\nemit_B(codegen_scope *s, uint32_t pc, uint8_t i)\n{\n  if (pc >= s->icapa) {\n    if (pc == UINT32_MAX) {\n      codegen_error(s, \"too big code block\");\n    }\n    if (pc >= UINT32_MAX / 2) {\n      pc = UINT32_MAX;\n    }\n    else {\n      s->icapa *= 2;\n    }\n    s->iseq = (mrb_code *)codegen_realloc(s, s->iseq, sizeof(mrb_code)*s->icapa);\n    if (s->lines) {\n      s->lines = (uint16_t*)codegen_realloc(s, s->lines, sizeof(uint16_t)*s->icapa);\n    }\n  }\n  if (s->lines) {\n    if (s->lineno > 0 || pc == 0)\n      s->lines[pc] = s->lineno;\n    else\n      s->lines[pc] = s->lines[pc-1];\n  }\n  s->iseq[pc] = i;\n}\n\nstatic void\nemit_S(codegen_scope *s, int pc, uint16_t i)\n{\n  uint8_t hi = i>>8;\n  uint8_t lo = i&0xff;\n\n  emit_B(s, pc,   hi);\n  emit_B(s, pc+1, lo);\n}\n\nstatic void\ngen_B(codegen_scope *s, uint8_t i)\n{\n  emit_B(s, s->pc, i);\n  s->pc++;\n}\n\nstatic void\ngen_S(codegen_scope *s, uint16_t i)\n{\n  emit_S(s, s->pc, i);\n  s->pc += 2;\n}\n\nstatic void\ngenop_0(codegen_scope *s, mrb_code i)\n{\n  s->lastpc = s->pc;\n  gen_B(s, i);\n}\n\nstatic void\ngenop_1(codegen_scope *s, mrb_code i, uint16_t a)\n{\n  s->lastpc = s->pc;\n  check_no_ext_ops(s, a, 0);\n  if (a > 0xff) {\n    gen_B(s, OP_EXT1);\n    gen_B(s, i);\n    gen_S(s, a);\n  }\n  else {\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n  }\n}\n\nstatic void\ngenop_2(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b)\n{\n  s->lastpc = s->pc;\n  check_no_ext_ops(s, a, b);\n  if (a > 0xff && b > 0xff) {\n    gen_B(s, OP_EXT3);\n    gen_B(s, i);\n    gen_S(s, a);\n    gen_S(s, b);\n  }\n  else if (b > 0xff) {\n    gen_B(s, OP_EXT2);\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n    gen_S(s, b);\n  }\n  else if (a > 0xff) {\n    gen_B(s, OP_EXT1);\n    gen_B(s, i);\n    gen_S(s, a);\n    gen_B(s, (uint8_t)b);\n  }\n  else {\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n    gen_B(s, (uint8_t)b);\n  }\n}\n\nstatic void\ngenop_3(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b, uint8_t c)\n{\n  genop_2(s, i, a, b);\n  gen_B(s, c);\n}\n\nstatic void\ngenop_2S(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b)\n{\n  genop_1(s, i, a);\n  gen_S(s, b);\n}\n\nstatic void\ngenop_2SS(codegen_scope *s, mrb_code i, uint16_t a, uint32_t b)\n{\n  genop_1(s, i, a);\n  gen_S(s, b>>16);\n  gen_S(s, b&0xffff);\n}\n\nstatic void\ngenop_W(codegen_scope *s, mrb_code i, uint32_t a)\n{\n  uint8_t a1 = (a>>16) & 0xff;\n  uint8_t a2 = (a>>8) & 0xff;\n  uint8_t a3 = a & 0xff;\n\n  s->lastpc = s->pc;\n  gen_B(s, i);\n  gen_B(s, a1);\n  gen_B(s, a2);\n  gen_B(s, a3);\n}\n\n#define NOVAL  0\n#define VAL    1\n\nstatic mrb_bool\nno_optimize(codegen_scope *s)\n{\n  if (s && s->parser && s->parser->no_optimize)\n    return TRUE;\n  return FALSE;\n}\n\nstruct mrb_insn_data\nmrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n\n  switch (insn) {\n#define FETCH_Z() /* empty */\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}\n\n#undef OPCODE\n#define Z 1\n#define S 3\n#define W 4\n#define OPCODE(_,x) x,\n/* instruction sizes */\nstatic uint8_t mrb_insn_size[] = {\n#define B 2\n#define BB 3\n#define BBB 4\n#define BS 4\n#define BSS 6\n#include \"mruby/ops.h\"\n#undef B\n#undef BB\n#undef BBB\n#undef BS\n#undef BSS\n};\n/* EXT1 instruction sizes */\nstatic uint8_t mrb_insn_size1[] = {\n#define B 3\n#define BB 4\n#define BBB 5\n#define BS 5\n#define BSS 7\n#include \"mruby/ops.h\"\n#undef B\n#undef BS\n#undef BSS\n};\n/* EXT2 instruction sizes */\nstatic uint8_t mrb_insn_size2[] = {\n#define B 2\n#define BS 4\n#define BSS 6\n#include \"mruby/ops.h\"\n#undef B\n#undef BB\n#undef BBB\n#undef BS\n#undef BSS\n};\n/* EXT3 instruction sizes */\n#define B 3\n#define BB 5\n#define BBB 6\n#define BS 5\n#define BSS 7\nstatic uint8_t mrb_insn_size3[] = {\n#include \"mruby/ops.h\"\n};\n#undef B\n#undef BB\n#undef BBB\n#undef BS\n#undef BSS\n#undef OPCODE\n\nstatic const mrb_code*\nmrb_prev_pc(codegen_scope *s, const mrb_code *pc)\n{\n  const mrb_code *prev_pc = NULL;\n  const mrb_code *i = s->iseq;\n\n  while (i<pc) {\n    uint8_t insn = i[0];\n    prev_pc = i;\n    switch (insn) {\n    case OP_EXT1:\n      i += mrb_insn_size1[i[1]] + 1;\n      break;\n    case OP_EXT2:\n      i += mrb_insn_size2[i[1]] + 1;\n      break;\n    case OP_EXT3:\n      i += mrb_insn_size3[i[1]] + 1;\n      break;\n    default:\n      i += mrb_insn_size[insn];\n      break;\n    }\n  }\n  return prev_pc;\n}\n\n#define pc_addr(s) &((s)->iseq[(s)->pc])\n#define addr_pc(s, addr) (uint32_t)((addr) - s->iseq)\n#define rewind_pc(s) s->pc = s->lastpc\n\nstatic struct mrb_insn_data\nmrb_last_insn(codegen_scope *s)\n{\n  if (s->pc == 0) {\n    struct mrb_insn_data data = { OP_NOP, 0 };\n    return data;\n  }\n  return mrb_decode_insn(&s->iseq[s->lastpc]);\n}\n\nstatic mrb_bool\nno_peephole(codegen_scope *s)\n{\n  return no_optimize(s) || s->lastlabel == s->pc || s->pc == 0 || s->pc == s->lastpc;\n}\n\n#define JMPLINK_START UINT32_MAX\n\nstatic void\ngen_jmpdst(codegen_scope *s, uint32_t pc)\n{\n\n  if (pc == JMPLINK_START) {\n    pc = 0;\n  }\n  uint32_t pos2 = s->pc+2;\n  int32_t off = pc - pos2;\n\n  if (off > INT16_MAX || INT16_MIN > off) {\n    codegen_error(s, \"too big jump offset\");\n  }\n  gen_S(s, (uint16_t)off);\n}\n\nstatic uint32_t\ngenjmp(codegen_scope *s, mrb_code i, uint32_t pc)\n{\n  uint32_t pos;\n\n  genop_0(s, i);\n  pos = s->pc;\n  gen_jmpdst(s, pc);\n  return pos;\n}\n\n#define genjmp_0(s,i) genjmp(s,i,JMPLINK_START)\n\nstatic uint32_t\ngenjmp2(codegen_scope *s, mrb_code i, uint16_t a, uint32_t pc, int val)\n{\n  uint32_t pos;\n\n  if (!no_peephole(s) && !val) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    switch (data.insn) {\n    case OP_MOVE:\n      if (data.a == a && data.a > s->nlocals) {\n        rewind_pc(s);\n        a = data.b;\n      }\n      break;\n    case OP_LOADNIL:\n    case OP_LOADF:\n      if (data.a == a || data.a > s->nlocals) {\n        s->pc = addr_pc(s, data.addr);\n        if (i == OP_JMPNOT || (i == OP_JMPNIL && data.insn == OP_LOADNIL)) {\n          return genjmp(s, OP_JMP, pc);\n        }\n        else {                  /* OP_JMPIF */\n          return JMPLINK_START;\n        }\n      }\n      break;\n    case OP_LOADT: case OP_LOADI: case OP_LOADINEG: case OP_LOADI__1:\n    case OP_LOADI_0: case OP_LOADI_1: case OP_LOADI_2: case OP_LOADI_3:\n    case OP_LOADI_4: case OP_LOADI_5: case OP_LOADI_6: case OP_LOADI_7:\n      if (data.a == a || data.a > s->nlocals) {\n        s->pc = addr_pc(s, data.addr);\n        if (i == OP_JMPIF) {\n          return genjmp(s, OP_JMP, pc);\n        }\n        else {                  /* OP_JMPNOT and OP_JMPNIL */\n          return JMPLINK_START;\n        }\n      }\n      break;\n    }\n  }\n\n  if (a > 0xff) {\n    check_no_ext_ops(s, a, 0);\n    gen_B(s, OP_EXT1);\n    genop_0(s, i);\n    gen_S(s, a);\n  }\n  else {\n    genop_0(s, i);\n    gen_B(s, (uint8_t)a);\n  }\n  pos = s->pc;\n  gen_jmpdst(s, pc);\n  return pos;\n}\n\n#define genjmp2_0(s,i,a,val) genjmp2(s,i,a,JMPLINK_START,val)\n\nstatic mrb_bool get_int_operand(codegen_scope *s, struct mrb_insn_data *data, mrb_int *ns);\nstatic void gen_int(codegen_scope *s, uint16_t dst, mrb_int i);\n\nstatic void\ngen_move(codegen_scope *s, uint16_t dst, uint16_t src, int nopeep)\n{\n  if (nopeep || no_peephole(s)) goto normal;\n  else if (dst == src) return;\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    switch (data.insn) {\n    case OP_MOVE:\n      if (dst == src) return;             /* remove useless MOVE */\n      if (data.b == dst && data.a == src) /* skip swapping MOVE */\n        return;\n      goto normal;\n    case OP_LOADNIL: case OP_LOADSELF: case OP_LOADT: case OP_LOADF:\n    case OP_LOADI__1:\n    case OP_LOADI_0: case OP_LOADI_1: case OP_LOADI_2: case OP_LOADI_3:\n    case OP_LOADI_4: case OP_LOADI_5: case OP_LOADI_6: case OP_LOADI_7:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_1(s, data.insn, dst);\n      return;\n    case OP_HASH: case OP_ARRAY:\n      if (data.b != 0) goto normal;\n      /* fall through */\n    case OP_LOADI: case OP_LOADINEG:\n    case OP_LOADL: case OP_LOADSYM:\n    case OP_GETGV: case OP_GETSV: case OP_GETIV: case OP_GETCV:\n    case OP_GETCONST: case OP_STRING:\n    case OP_LAMBDA: case OP_BLOCK: case OP_METHOD: case OP_BLKPUSH:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_2(s, data.insn, dst, data.b);\n      return;\n    case OP_LOADI16:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_2S(s, data.insn, dst, data.b);\n      return;\n    case OP_LOADI32:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      else {\n        uint32_t i = (uint32_t)data.b<<16|data.c;\n        rewind_pc(s);\n        genop_2SS(s, data.insn, dst, i);\n      }\n      return;\n    case OP_AREF:\n    case OP_GETUPVAR:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_3(s, data.insn, dst, data.b, data.c);\n      return;\n    case OP_ADDI: case OP_SUBI:\n      if (addr_pc(s, data.addr) == s->lastlabel || data.a != src || data.a < s->nlocals) goto normal;\n      else {\n        struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n        if (data0.insn != OP_MOVE || data0.a != data.a || data0.b != dst) goto normal;\n        s->pc = addr_pc(s, data0.addr);\n        if (addr_pc(s, data0.addr) != s->lastlabel) {\n          /* constant folding */\n          data0 = mrb_decode_insn(mrb_prev_pc(s, data0.addr));\n          mrb_int n;\n          if (data0.a == dst && get_int_operand(s, &data0, &n)) {\n            if ((data.insn == OP_ADDI && !mrb_int_add_overflow(n, data.b, &n)) ||\n                (data.insn == OP_SUBI && !mrb_int_sub_overflow(n, data.b, &n))) {\n              s->pc = addr_pc(s, data0.addr);\n              gen_int(s, dst, n);\n              return;\n            }\n          }\n        }\n      }\n      genop_2(s, data.insn, dst, data.b);\n      return;\n    default:\n      break;\n    }\n  }\n normal:\n  genop_2(s, OP_MOVE, dst, src);\n  return;\n}\n\nstatic int search_upvar(codegen_scope *s, mrb_sym id, int *idx);\n\nstatic void\ngen_getupvar(codegen_scope *s, uint16_t dst, mrb_sym id)\n{\n  int idx;\n  int lv = search_upvar(s, id, &idx);\n\n  if (!no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    if (data.insn == OP_SETUPVAR && data.a == dst && data.b == idx && data.c == lv) {\n      /* skip GETUPVAR right after SETUPVAR */\n      return;\n    }\n  }\n  genop_3(s, OP_GETUPVAR, dst, idx, lv);\n}\n\nstatic void\ngen_setupvar(codegen_scope *s, uint16_t dst, mrb_sym id)\n{\n  int idx;\n  int lv = search_upvar(s, id, &idx);\n\n  if (!no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    if (data.insn == OP_MOVE && data.a == dst) {\n      dst = data.b;\n      rewind_pc(s);\n    }\n  }\n  genop_3(s, OP_SETUPVAR, dst, idx, lv);\n}\n\nstatic void\ngen_return(codegen_scope *s, uint8_t op, uint16_t src)\n{\n  if (no_peephole(s)) {\n    genop_1(s, op, src);\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    if (data.insn == OP_MOVE && src == data.a) {\n      rewind_pc(s);\n      genop_1(s, op, data.b);\n    }\n    else if (data.insn != OP_RETURN) {\n      genop_1(s, op, src);\n    }\n  }\n}\n\nstatic mrb_bool\nget_int_operand(codegen_scope *s, struct mrb_insn_data *data, mrb_int *n)\n{\n  switch (data->insn) {\n  case OP_LOADI__1:\n    *n = -1;\n    return TRUE;\n\n  case OP_LOADINEG:\n    *n = -data->b;\n    return TRUE;\n\n  case OP_LOADI_0: case OP_LOADI_1: case OP_LOADI_2: case OP_LOADI_3:\n  case OP_LOADI_4: case OP_LOADI_5: case OP_LOADI_6: case OP_LOADI_7:\n    *n = data->insn - OP_LOADI_0;\n    return TRUE;\n\n  case OP_LOADI:\n  case OP_LOADI16:\n    *n = (int16_t)data->b;\n    return TRUE;\n\n  case OP_LOADI32:\n    *n = (mrb_int)((uint32_t)data->b<<16)+data->c;\n    return TRUE;\n\n  case OP_LOADL:\n    {\n      mrb_pool_value *pv = &s->pool[data->b];\n\n      if (pv->tt == IREP_TT_INT32) {\n        *n = (mrb_int)pv->u.i32;\n      }\n#ifdef MRB_INT64\n      else if (pv->tt == IREP_TT_INT64) {\n        *n = (mrb_int)pv->u.i64;\n      }\n#endif\n      else {\n        return FALSE;\n      }\n    }\n    return TRUE;\n\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ngen_addsub(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n;\n\n    if (!get_int_operand(s, &data, &n)) {\n      /* not integer immediate */\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    mrb_int n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data0, &n0)) {\n      /* OP_ADDI/OP_SUBI takes upto 8bits */\n      if (n > INT8_MAX || n < INT8_MIN) goto normal;\n      rewind_pc(s);\n      if (n == 0) return;\n      if (n > 0) {\n        if (op == OP_ADD) genop_2(s, OP_ADDI, dst, (uint16_t)n);\n        else genop_2(s, OP_SUBI, dst, (uint16_t)n);\n      }\n      else {                    /* n < 0 */\n        n = -n;\n        if (op == OP_ADD) genop_2(s, OP_SUBI, dst, (uint16_t)n);\n        else genop_2(s, OP_ADDI, dst, (uint16_t)n);\n      }\n      return;\n    }\n    if (op == OP_ADD) {\n      if (mrb_int_add_overflow(n0, n, &n)) goto normal;\n    }\n    else { /* OP_SUB */\n      if (mrb_int_sub_overflow(n0, n, &n)) goto normal;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}\n\nstatic void\ngen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      /* not integer immediate */\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { /* OP_DIV */\n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}\n\nmrb_bool mrb_num_shift(mrb_state *mrb, mrb_int val, mrb_int width, mrb_int *num);\n\nstatic mrb_bool\ngen_binop(codegen_scope *s, mrb_sym op, uint16_t dst)\n{\n  if (no_peephole(s)) return FALSE;\n  else if (op == MRB_OPSYM_2(s->mrb, aref)) {\n    genop_1(s, OP_GETIDX, dst);\n    return TRUE;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      /* not integer immediate */\n      return FALSE;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0)) {\n      return FALSE;\n    }\n    if (op == MRB_OPSYM_2(s->mrb, lshift)) {\n      if (!mrb_num_shift(s->mrb, n0, n, &n)) return FALSE;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, rshift)) {\n      if (n == MRB_INT_MIN) return FALSE;\n      if (!mrb_num_shift(s->mrb, n0, -n, &n)) return FALSE;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, mod) && n != 0) {\n      if (n0 == MRB_INT_MIN && n == -1) {\n        n = 0;\n      }\n      else {\n        mrb_int n1 = n0 % n;\n        if ((n0 < 0) != (n < 0) && n1 != 0) {\n          n1 += n;\n        }\n        n = n1;\n      }\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, and)) {\n      n = n0 & n;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, or)) {\n      n = n0 | n;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, xor)) {\n      n = n0 ^ n;\n    }\n    else {\n      return FALSE;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n    return TRUE;\n  }\n}\n\nstatic uint32_t\ndispatch(codegen_scope *s, uint32_t pos0)\n{\n  int32_t pos1;\n  int32_t offset;\n  int16_t newpos;\n\n  if (pos0 == JMPLINK_START) return 0;\n\n  pos1 = pos0 + 2;\n  offset = s->pc - pos1;\n  if (offset > INT16_MAX) {\n    codegen_error(s, \"too big jmp offset\");\n  }\n  s->lastlabel = s->pc;\n  newpos = (int16_t)PEEK_S(s->iseq+pos0);\n  emit_S(s, pos0, (uint16_t)offset);\n  if (newpos == 0) return 0;\n  return pos1+newpos;\n}\n\nstatic void\ndispatch_linked(codegen_scope *s, uint32_t pos)\n{\n  if (pos==JMPLINK_START) return;\n  for (;;) {\n    pos = dispatch(s, pos);\n    if (pos==0) break;\n  }\n}\n\n#define nregs_update do {if (s->sp > s->nregs) s->nregs = s->sp;} while (0)\nstatic void\npush_n_(codegen_scope *s, int n)\n{\n  if (s->sp+n >= 0xffff) {\n    codegen_error(s, \"too complex expression\");\n  }\n  s->sp+=n;\n  nregs_update;\n}\n\nstatic void\npop_n_(codegen_scope *s, int n)\n{\n  if ((int)s->sp-n < 0) {\n    codegen_error(s, \"stack pointer underflow\");\n  }\n  s->sp-=n;\n}\n\n#define push() push_n_(s,1)\n#define push_n(n) push_n_(s,n)\n#define pop() pop_n_(s,1)\n#define pop_n(n) pop_n_(s,n)\n#define cursp() (s->sp)\n\nstatic int\nnew_litbn(codegen_scope *s, const char *p, int base, mrb_bool neg)\n{\n  int i;\n  size_t plen;\n  mrb_pool_value *pv;\n\n  plen = strlen(p);\n  if (plen > 255) {\n    codegen_error(s, \"integer too big\");\n  }\n  for (i=0; i<s->irep->plen; i++) {\n    size_t len;\n    pv = &s->pool[i];\n    if (pv->tt != IREP_TT_BIGINT) continue;\n    len = pv->u.str[0];\n    if (len == plen && pv->u.str[1] == base && memcmp(pv->u.str+2, p, len) == 0)\n      return i;\n  }\n\n  if (s->irep->plen == s->pcapa) {\n    s->pcapa *= 2;\n    s->pool = (mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*s->pcapa);\n  }\n\n  pv = &s->pool[s->irep->plen];\n  i = s->irep->plen++;\n  {\n    char *buf;\n    pv->tt = IREP_TT_BIGINT;\n    buf = (char*)codegen_realloc(s, NULL, plen+3);\n    buf[0] = (char)plen;\n    buf[1] = base;\n    if (neg) buf[1] = 0x80;\n    memcpy(buf+2, p, plen);\n    buf[plen+2] = '\\0';\n    pv->u.str = buf;\n  }\n  return i;\n}\n\nstatic int\nnew_lit(codegen_scope *s, mrb_value val)\n{\n  int i;\n  mrb_pool_value *pv;\n\n  switch (mrb_type(val)) {\n  case MRB_TT_STRING:\n    for (i=0; i<s->irep->plen; i++) {\n      mrb_int len;\n      pv = &s->pool[i];\n      if (pv->tt & IREP_TT_NFLAG) continue;\n      len = pv->tt>>2;\n      if (RSTRING_LEN(val) != len) continue;\n      if (memcmp(pv->u.str, RSTRING_PTR(val), len) == 0)\n        return i;\n    }\n    break;\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n    for (i=0; i<s->irep->plen; i++) {\n      mrb_float f1, f2;\n      pv = &s->pool[i];\n      if (pv->tt != IREP_TT_FLOAT) continue;\n      pv = &s->pool[i];\n      f1 = pv->u.f;\n      f2 = mrb_float(val);\n      if (f1 == f2 && !signbit(f1) == !signbit(f2)) return i;\n    }\n    break;\n#endif\n  case MRB_TT_INTEGER:\n    for (i=0; i<s->irep->plen; i++) {\n      mrb_int v = mrb_integer(val);\n      pv = &s->pool[i];\n      if (pv->tt == IREP_TT_INT32) {\n        if (v == pv->u.i32) return i;\n      }\n#ifdef MRB_64BIT\n      else if (pv->tt == IREP_TT_INT64) {\n        if (v == pv->u.i64) return i;\n      }\n      continue;\n#endif\n    }\n    break;\n  default:\n    /* should not happen */\n    return 0;\n  }\n\n  if (s->irep->plen == s->pcapa) {\n    s->pcapa *= 2;\n    s->pool = (mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*s->pcapa);\n  }\n\n  pv = &s->pool[s->irep->plen];\n  i = s->irep->plen++;\n\n  switch (mrb_type(val)) {\n  case MRB_TT_STRING:\n    if (RSTR_NOFREE_P(RSTRING(val))) {\n      pv->tt = (uint32_t)(RSTRING_LEN(val)<<2) | IREP_TT_SSTR;\n      pv->u.str = RSTRING_PTR(val);\n    }\n    else {\n      char *p;\n      mrb_int len = RSTRING_LEN(val);\n      pv->tt = (uint32_t)(len<<2) | IREP_TT_STR;\n      p = (char*)codegen_realloc(s, NULL, len+1);\n      memcpy(p, RSTRING_PTR(val), len);\n      p[len] = '\\0';\n      pv->u.str = p;\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n    pv->tt = IREP_TT_FLOAT;\n    pv->u.f = mrb_float(val);\n    break;\n#endif\n  case MRB_TT_INTEGER:\n#ifdef MRB_INT64\n    pv->tt = IREP_TT_INT64;\n    pv->u.i64 = mrb_integer(val);\n#else\n    pv->tt = IREP_TT_INT32;\n    pv->u.i32 = mrb_integer(val);\n#endif\n    break;\n\n  default:\n    /* should not happen */\n    break;\n  }\n  return i;\n}\n\nstatic int\nnew_sym(codegen_scope *s, mrb_sym sym)\n{\n  int i, len;\n\n  mrb_assert(s->irep);\n\n  len = s->irep->slen;\n  for (i=0; i<len; i++) {\n    if (s->syms[i] == sym) return i;\n  }\n  if (s->irep->slen >= s->scapa) {\n    s->scapa *= 2;\n    if (s->scapa > 0xffff) {\n      codegen_error(s, \"too many symbols\");\n    }\n    s->syms = (mrb_sym*)codegen_realloc(s, s->syms, sizeof(mrb_sym)*s->scapa);\n  }\n  s->syms[s->irep->slen] = sym;\n  return s->irep->slen++;\n}\n\nstatic void\ngen_setxv(codegen_scope *s, uint8_t op, uint16_t dst, mrb_sym sym, int val)\n{\n  int idx = new_sym(s, sym);\n  if (!val && !no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    if (data.insn == OP_MOVE && data.a == dst) {\n      dst = data.b;\n      rewind_pc(s);\n    }\n  }\n  genop_2(s, op, dst, idx);\n}\n\nstatic void\ngen_int(codegen_scope *s, uint16_t dst, mrb_int i)\n{\n  if (i < 0) {\n    if (i == -1) genop_1(s, OP_LOADI__1, dst);\n    else if (i >= -0xff) genop_2(s, OP_LOADINEG, dst, (uint16_t)-i);\n    else if (i >= INT16_MIN) genop_2S(s, OP_LOADI16, dst, (uint16_t)i);\n    else if (i >= INT32_MIN) genop_2SS(s, OP_LOADI32, dst, (uint32_t)i);\n    else goto int_lit;\n  }\n  else if (i < 8) genop_1(s, OP_LOADI_0 + (uint8_t)i, dst);\n  else if (i <= 0xff) genop_2(s, OP_LOADI, dst, (uint16_t)i);\n  else if (i <= INT16_MAX) genop_2S(s, OP_LOADI16, dst, (uint16_t)i);\n  else if (i <= INT32_MAX) genop_2SS(s, OP_LOADI32, dst, (uint32_t)i);\n  else {\n  int_lit:\n    genop_2(s, OP_LOADL, dst, new_lit(s, mrb_int_value(s->mrb, i)));\n  }\n}\n\nstatic mrb_bool\ngen_uniop(codegen_scope *s, mrb_sym sym, uint16_t dst)\n{\n  if (no_peephole(s)) return FALSE;\n  struct mrb_insn_data data = mrb_last_insn(s);\n  mrb_int n;\n\n  if (!get_int_operand(s, &data, &n)) return FALSE;\n  if (sym == MRB_OPSYM_2(s->mrb, plus)) {\n    /* unary plus does nothing */\n  }\n  else if (sym == MRB_OPSYM_2(s->mrb, minus)) {\n    if (n == MRB_INT_MIN) return FALSE;\n    n = -n;\n  }\n  else if (sym == MRB_OPSYM_2(s->mrb, neg)) {\n    n = ~n;\n  }\n  else {\n    return FALSE;\n  }\n  s->pc = addr_pc(s, data.addr);\n  gen_int(s, dst, n);\n  return TRUE;\n}\n\nstatic int\nnode_len(node *tree)\n{\n  int n = 0;\n\n  while (tree) {\n    n++;\n    tree = tree->cdr;\n  }\n  return n;\n}\n\n#define nint(x) ((int)(intptr_t)(x))\n#define nchar(x) ((char)(intptr_t)(x))\n#define nsym(x) ((mrb_sym)(intptr_t)(x))\n\n#define lv_name(lv) nsym((lv)->car)\n\nstatic int\nlv_idx(codegen_scope *s, mrb_sym id)\n{\n  node *lv = s->lv;\n  int n = 1;\n\n  while (lv) {\n    if (lv_name(lv) == id) return n;\n    n++;\n    lv = lv->cdr;\n  }\n  return 0;\n}\n\nstatic int\nsearch_upvar(codegen_scope *s, mrb_sym id, int *idx)\n{\n  const struct RProc *u;\n  int lv = 0;\n  codegen_scope *up = s->prev;\n\n  while (up) {\n    *idx = lv_idx(up, id);\n    if (*idx > 0) {\n      return lv;\n    }\n    lv ++;\n    up = up->prev;\n  }\n\n  if (lv < 1) lv = 1;\n  u = s->parser->upper;\n  while (u && !MRB_PROC_CFUNC_P(u)) {\n    const struct mrb_irep *ir = u->body.irep;\n    uint_fast16_t n = ir->nlocals;\n    int i;\n\n    const mrb_sym *v = ir->lv;\n    if (v) {\n      for (i=1; n > 1; n--, v++, i++) {\n        if (*v == id) {\n          *idx = i;\n          return lv - 1;\n        }\n      }\n    }\n    if (MRB_PROC_SCOPE_P(u)) break;\n    u = u->upper;\n    lv ++;\n  }\n\n  codegen_error(s, \"Can't found local variables\");\n  return -1; /* not reached */\n}\n\nstatic void\nfor_body(codegen_scope *s, node *tree)\n{\n  codegen_scope *prev = s;\n  int idx;\n  struct loopinfo *lp;\n  node *n2;\n\n  /* generate receiver */\n  codegen(s, tree->cdr->car, VAL);\n  /* generate loop-block */\n  s = scope_new(s->mrb, s, NULL);\n\n  push();                       /* push for a block parameter */\n\n  /* generate loop variable */\n  n2 = tree->car;\n  genop_W(s, OP_ENTER, 0x40000);\n  if (n2->car && !n2->car->cdr && !n2->cdr) {\n    gen_assignment(s, n2->car->car, NULL, 1, NOVAL);\n  }\n  else {\n    gen_vmassignment(s, n2, 1, VAL);\n  }\n  /* construct loop */\n  lp = loop_push(s, LOOP_FOR);\n  lp->pc1 = new_label(s);\n\n  /* loop body */\n  codegen(s, tree->cdr->cdr->car, VAL);\n  pop();\n  gen_return(s, OP_RETURN, cursp());\n  loop_pop(s, NOVAL);\n  scope_finish(s);\n  s = prev;\n  genop_2(s, OP_BLOCK, cursp(), s->irep->rlen-1);\n  push();pop(); /* space for a block */\n  pop();\n  idx = new_sym(s, MRB_SYM_2(s->mrb, each));\n  genop_3(s, OP_SENDB, cursp(), idx, 0);\n}\n\nstatic int\nlambda_body(codegen_scope *s, node *tree, int blk)\n{\n  codegen_scope *parent = s;\n  s = scope_new(s->mrb, s, tree->car);\n\n  s->mscope = !blk;\n\n  if (blk) {\n    struct loopinfo *lp = loop_push(s, LOOP_BLOCK);\n    lp->pc0 = new_label(s);\n  }\n  tree = tree->cdr;\n  if (tree->car == NULL) {\n    genop_W(s, OP_ENTER, 0);\n    s->ainfo = 0;\n  }\n  else {\n    mrb_aspec a;\n    int ma, oa, ra, pa, ka, kd, ba, i;\n    uint32_t pos;\n    node *opt;\n    node *margs, *pargs;\n    node *tail;\n\n    /* mandatory arguments */\n    ma = node_len(tree->car->car);\n    margs = tree->car->car;\n    tail = tree->car->cdr->cdr->cdr->cdr;\n\n    /* optional arguments */\n    oa = node_len(tree->car->cdr->car);\n    /* rest argument? */\n    ra = tree->car->cdr->cdr->car ? 1 : 0;\n    /* mandatory arguments after rest argument */\n    pa = node_len(tree->car->cdr->cdr->cdr->car);\n    pargs = tree->car->cdr->cdr->cdr->car;\n    /* keyword arguments */\n    ka = tail? node_len(tail->cdr->car) : 0;\n    /* keyword dictionary? */\n    kd = tail && tail->cdr->cdr->car? 1 : 0;\n    /* block argument? */\n    ba = tail && tail->cdr->cdr->cdr->car ? 1 : 0;\n\n    if (ma > 0x1f || oa > 0x1f || pa > 0x1f || ka > 0x1f) {\n      codegen_error(s, \"too many formal arguments\");\n    }\n    /* (23bits = 5:5:1:5:5:1:1) */\n    a = MRB_ARGS_REQ(ma)\n      | MRB_ARGS_OPT(oa)\n      | (ra? MRB_ARGS_REST() : 0)\n      | MRB_ARGS_POST(pa)\n      | MRB_ARGS_KEY(ka, kd)\n      | (ba? MRB_ARGS_BLOCK() : 0);\n    genop_W(s, OP_ENTER, a);\n    /* (12bits = 5:1:5:1) */\n    s->ainfo = (((ma+oa) & 0x3f) << 7)\n      | ((ra & 0x1) << 6)\n      | ((pa & 0x1f) << 1)\n      | ((ka | kd) ? 1 : 0);\n    /* generate jump table for optional arguments initializer */\n    pos = new_label(s);\n    for (i=0; i<oa; i++) {\n      new_label(s);\n      genjmp_0(s, OP_JMP);\n    }\n    if (oa > 0) {\n      genjmp_0(s, OP_JMP);\n    }\n    opt = tree->car->cdr->car;\n    i = 0;\n    while (opt) {\n      int idx;\n      mrb_sym id = nsym(opt->car->car);\n\n      dispatch(s, pos+i*3+1);\n      codegen(s, opt->car->cdr, VAL);\n      pop();\n      idx = lv_idx(s, id);\n      if (idx > 0) {\n        gen_move(s, idx, cursp(), 0);\n      }\n      else {\n        gen_getupvar(s, cursp(), id);\n      }\n      i++;\n      opt = opt->cdr;\n    }\n    if (oa > 0) {\n      dispatch(s, pos+i*3+1);\n    }\n\n    /* keyword arguments */\n    if (tail) {\n      node *kwds = tail->cdr->car;\n      int kwrest = 0;\n\n      if (tail->cdr->cdr->car) {\n        kwrest = 1;\n      }\n      mrb_assert(nint(tail->car) == NODE_ARGS_TAIL);\n      mrb_assert(node_len(tail) == 4);\n\n      while (kwds) {\n        int jmpif_key_p, jmp_def_set = -1;\n        node *kwd = kwds->car, *def_arg = kwd->cdr->cdr->car;\n        mrb_sym kwd_sym = nsym(kwd->cdr->car);\n\n        mrb_assert(nint(kwd->car) == NODE_KW_ARG);\n\n        if (def_arg) {\n          int idx;\n          genop_2(s, OP_KEY_P, lv_idx(s, kwd_sym), new_sym(s, kwd_sym));\n          jmpif_key_p = genjmp2_0(s, OP_JMPIF, lv_idx(s, kwd_sym), NOVAL);\n          codegen(s, def_arg, VAL);\n          pop();\n          idx = lv_idx(s, kwd_sym);\n          if (idx > 0) {\n            gen_move(s, idx, cursp(), 0);\n          }\n          else {\n            gen_getupvar(s, cursp(), kwd_sym);\n          }\n          jmp_def_set = genjmp_0(s, OP_JMP);\n          dispatch(s, jmpif_key_p);\n        }\n        genop_2(s, OP_KARG, lv_idx(s, kwd_sym), new_sym(s, kwd_sym));\n        if (jmp_def_set != -1) {\n          dispatch(s, jmp_def_set);\n        }\n        i++;\n\n        kwds = kwds->cdr;\n      }\n      if (tail->cdr->car && !kwrest) {\n        genop_0(s, OP_KEYEND);\n      }\n    }\n\n    /* argument destructuring */\n    if (margs) {\n      node *n = margs;\n\n      pos = 1;\n      while (n) {\n        if (nint(n->car->car) == NODE_MASGN) {\n          gen_vmassignment(s, n->car->cdr->car, pos, NOVAL);\n        }\n        pos++;\n        n = n->cdr;\n      }\n    }\n    if (pargs) {\n      node *n = pargs;\n\n      pos = ma+oa+ra+1;\n      while (n) {\n        if (nint(n->car->car) == NODE_MASGN) {\n          gen_vmassignment(s, n->car->cdr->car, pos, NOVAL);\n        }\n        pos++;\n        n = n->cdr;\n      }\n    }\n  }\n\n  codegen(s, tree->cdr->car, VAL);\n  pop();\n  if (s->pc > 0) {\n    gen_return(s, OP_RETURN, cursp());\n  }\n  if (blk) {\n    loop_pop(s, NOVAL);\n  }\n  scope_finish(s);\n  return parent->irep->rlen - 1;\n}\n\nstatic int\nscope_body(codegen_scope *s, node *tree, int val)\n{\n  codegen_scope *scope = scope_new(s->mrb, s, tree->car);\n\n  codegen(scope, tree->cdr, VAL);\n  gen_return(scope, OP_RETURN, scope->sp-1);\n  if (!s->iseq) {\n    genop_0(scope, OP_STOP);\n  }\n  scope_finish(scope);\n  if (!s->irep) {\n    /* should not happen */\n    return 0;\n  }\n  return s->irep->rlen - 1;\n}\n\nstatic mrb_bool\nnosplat(node *t)\n{\n  while (t) {\n    if (nint(t->car->car) == NODE_SPLAT) return FALSE;\n    t = t->cdr;\n  }\n  return TRUE;\n}\n\nstatic mrb_sym\nattrsym(codegen_scope *s, mrb_sym a)\n{\n  const char *name;\n  mrb_int len;\n  char *name2;\n\n  name = mrb_sym_name_len(s->mrb, a, &len);\n  name2 = (char *)codegen_palloc(s,\n                                 (size_t)len\n                                 + 1 /* '=' */\n                                 + 1 /* '\\0' */\n                                 );\n  mrb_assert_int_fit(mrb_int, len, size_t, SIZE_MAX);\n  memcpy(name2, name, (size_t)len);\n  name2[len] = '=';\n  name2[len+1] = '\\0';\n\n  return mrb_intern(s->mrb, name2, len+1);\n}\n\n#define CALL_MAXARGS 15\n#define GEN_LIT_ARY_MAX 64\n#define GEN_VAL_STACK_MAX 99\n\nstatic int\ngen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n\n    if (is_splat || cursp() >= slimit) { /* flush stack */\n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  /* variable length */\n  }\n  else if (n > limit) {\n    pop_n(n);\n    genop_2(s, OP_ARRAY, cursp(), n);\n    return -1;\n  }\n  return n;\n}\n\nstatic int\ngen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  mrb_bool first = TRUE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (val && first) {\n        genop_2(s, OP_HASH, cursp(), 0);\n        push();\n        update = TRUE;\n      }\n      else if (val && len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (val && (len > 0 || update)) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n    first = FALSE;\n  }\n  if (val && len > limit) {\n    pop_n(len*2);\n    genop_2(s, OP_HASH, cursp(), len);\n    push();\n    return -1;\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  return len;\n}\n\nstatic void\ngen_call(codegen_scope *s, node *tree, int val, int safe)\n{\n  mrb_sym sym = nsym(tree->cdr->car);\n  int skip = 0, n = 0, nk = 0, noop = 0, noself = 0, blk = 0, sp_save = cursp();\n\n  if (!tree->car) {\n    noself = noop = 1;\n    push();\n  }\n  else {\n    codegen(s, tree->car, VAL); /* receiver */\n  }\n  if (safe) {\n    int recv = cursp()-1;\n    gen_move(s, cursp(), recv, 1);\n    skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n  }\n  tree = tree->cdr->cdr->car;\n  if (tree) {\n    if (tree->car) {            /* positional arguments */\n      n = gen_values(s, tree->car, VAL, 14);\n      if (n < 0) {              /* variable length */\n        noop = 1;               /* not operator */\n        n = 15;\n        push();\n      }\n    }\n    if (tree->cdr->car) {       /* keyword arguments */\n      noop = 1;\n      nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n      if (nk < 0) nk = 15;\n    }\n  }\n  if (tree && tree->cdr && tree->cdr->cdr) {\n    codegen(s, tree->cdr->cdr, VAL);\n    pop();\n    noop = 1;\n    blk = 1;\n  }\n  push();pop();\n  s->sp = sp_save;\n  if (!noop && sym == MRB_OPSYM_2(s->mrb, add) && n == 1)  {\n    gen_addsub(s, OP_ADD, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, sub) && n == 1)  {\n    gen_addsub(s, OP_SUB, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, mul) && n == 1)  {\n    gen_muldiv(s, OP_MUL, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, div) && n == 1)  {\n    gen_muldiv(s, OP_DIV, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, lt) && n == 1)  {\n    genop_1(s, OP_LT, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, le) && n == 1)  {\n    genop_1(s, OP_LE, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, gt) && n == 1)  {\n    genop_1(s, OP_GT, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, ge) && n == 1)  {\n    genop_1(s, OP_GE, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, eq) && n == 1)  {\n    genop_1(s, OP_EQ, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, aset) && n == 2)  {\n    genop_1(s, OP_SETIDX, cursp());\n  }\n  else if (!noop && n == 0 && gen_uniop(s, sym, cursp())) {\n    /* constant folding succeeded */\n  }\n  else if (!noop && n == 1 && gen_binop(s, sym, cursp())) {\n    /* constant folding succeeded */\n  }\n  else if (noself){\n    genop_3(s, blk ? OP_SSENDB : OP_SSEND, cursp(), new_sym(s, sym), n|(nk<<4));\n  }\n  else {\n    genop_3(s, blk ? OP_SENDB : OP_SEND, cursp(), new_sym(s, sym), n|(nk<<4));\n  }\n  if (safe) {\n    dispatch(s, skip);\n  }\n  if (val) {\n    push();\n  }\n}\n\nstatic void\ngen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 14) {\n        n++;\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}\n\nstatic void\ngen_vmassignment(codegen_scope *s, node *tree, int rhs, int val)\n{\n  int n = 0, post = 0;\n  node *t, *p;\n\n  if (tree->car) {              /* pre */\n    t = tree->car;\n    n = 0;\n    while (t) {\n      int sp = cursp();\n\n      genop_3(s, OP_AREF, sp, rhs, n);\n      push();\n      gen_assignment(s, t->car, NULL, sp, NOVAL);\n      pop();\n      n++;\n      t = t->cdr;\n    }\n  }\n  t = tree->cdr;\n  if (t) {\n    if (t->cdr) {               /* post count */\n      p = t->cdr->car;\n      while (p) {\n        post++;\n        p = p->cdr;\n      }\n    }\n    gen_move(s, cursp(), rhs, val);\n    push_n(post+1);\n    pop_n(post+1);\n    genop_3(s, OP_APOST, cursp(), n, post);\n    n = 1;\n    if (t->car && t->car != (node*)-1) { /* rest */\n      gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n    }\n    if (t->cdr && t->cdr->car) {\n      t = t->cdr->car;\n      while (t) {\n        gen_assignment(s, t->car, NULL, cursp()+n, NOVAL);\n        t = t->cdr;\n        n++;\n      }\n    }\n    if (val) {\n      gen_move(s, cursp(), rhs, 0);\n    }\n  }\n}\n\nstatic void\ngen_intern(codegen_scope *s)\n{\n  pop();\n  if (!no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    if (data.insn == OP_STRING && data.a == cursp()) {\n      rewind_pc(s);\n      genop_2(s, OP_SYMBOL, data.a, data.b);\n      push();\n      return;\n    }\n  }\n  genop_1(s, OP_INTERN, cursp());\n  push();\n}\n\nstatic void\ngen_literal_array(codegen_scope *s, node *tree, mrb_bool sym, int val)\n{\n  if (val) {\n    int i = 0, j = 0, gen = 0;\n\n    while (tree) {\n      switch (nint(tree->car->car)) {\n      case NODE_STR:\n        if ((tree->cdr == NULL) && (nint(tree->car->cdr->cdr) == 0))\n          break;\n        /* fall through */\n      case NODE_BEGIN:\n        codegen(s, tree->car, VAL);\n        ++j;\n        break;\n\n      case NODE_LITERAL_DELIM:\n        if (j > 0) {\n          j = 0;\n          ++i;\n          if (sym)\n            gen_intern(s);\n        }\n        break;\n      }\n      while (j >= 2) {\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        j--;\n      }\n      if (i > GEN_LIT_ARY_MAX) {\n        pop_n(i);\n        if (gen) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), i);\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), i);\n          gen = 1;\n        }\n        push();\n        i = 0;\n      }\n      tree = tree->cdr;\n    }\n    if (j > 0) {\n      ++i;\n      if (sym)\n        gen_intern(s);\n    }\n    pop_n(i);\n    if (gen) {\n      pop();\n      genop_2(s, OP_ARYPUSH, cursp(), i);\n    }\n    else {\n      genop_2(s, OP_ARRAY, cursp(), i);\n    }\n    push();\n  }\n  else {\n    while (tree) {\n      switch (nint(tree->car->car)) {\n      case NODE_BEGIN: case NODE_BLOCK:\n        codegen(s, tree->car, NOVAL);\n      }\n      tree = tree->cdr;\n    }\n  }\n}\n\nstatic void\nraise_error(codegen_scope *s, const char *msg)\n{\n  int idx = new_lit(s, mrb_str_new_cstr(s->mrb, msg));\n\n  genop_1(s, OP_ERR, idx);\n}\n\nstatic mrb_int\nreadint(codegen_scope *s, const char *p, int base, mrb_bool neg, mrb_bool *overflow)\n{\n  const char *e = p + strlen(p);\n  mrb_int result = 0;\n\n  mrb_assert(base >= 2 && base <= 16);\n  if (*p == '+') p++;\n  while (p < e) {\n    int n;\n    char c = *p;\n    switch (c) {\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n      n = c - '0'; break;\n    case '8': case '9':\n      n = c - '0'; break;\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      n = c - 'a' + 10; break;\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n      n = c - 'A' + 10; break;\n    default:\n      codegen_error(s, \"malformed readint input\");\n      *overflow = TRUE;\n      /* not reached */\n      return result;\n    }\n    if (mrb_int_mul_overflow(result, base, &result)) {\n    overflow:\n      *overflow = TRUE;\n      return 0;\n    }\n    mrb_uint tmp = ((mrb_uint)result)+n;\n    if (neg && tmp == (mrb_uint)MRB_INT_MAX+1) {\n      *overflow = FALSE;\n      return MRB_INT_MIN;\n    }\n    if (tmp > MRB_INT_MAX) goto overflow;\n    result = (mrb_int)tmp;\n    p++;\n  }\n  *overflow = FALSE;\n  if (neg) return -result;\n  return result;\n}\n\nstatic void\ngen_retval(codegen_scope *s, node *tree)\n{\n  if (nint(tree->car) == NODE_SPLAT) {\n    codegen(s, tree, VAL);\n    pop();\n    genop_1(s, OP_ARYDUP, cursp());\n  }\n  else {\n    codegen(s, tree, VAL);\n    pop();\n  }\n}\n\nstatic mrb_bool\ntrue_always(node *tree)\n{\n  switch (nint(tree->car)) {\n  case NODE_TRUE:\n  case NODE_INT:\n  case NODE_STR:\n  case NODE_SYM:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic mrb_bool\nfalse_always(node *tree)\n{\n  switch (nint(tree->car)) {\n  case NODE_FALSE:\n  case NODE_NIL:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ngen_blkmove(codegen_scope *s, uint16_t ainfo, int lv)\n{\n  int m1 = (ainfo>>7)&0x3f;\n  int r  = (ainfo>>6)&0x1;\n  int m2 = (ainfo>>1)&0x1f;\n  int kd = (ainfo)&0x1;\n  int off = m1+r+m2+kd+1;\n  if (lv == 0) {\n    gen_move(s, cursp(), off, 0);\n  }\n  else {\n    genop_3(s, OP_GETUPVAR, cursp(), off, lv);\n  }\n  push();\n}\n\nstatic void\ncodegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n      if (val) push();\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}\n\nstatic void\nscope_add_irep(codegen_scope *s)\n{\n  mrb_irep *irep;\n  codegen_scope *prev = s->prev;\n\n  if (prev->irep == NULL) {\n    irep = mrb_add_irep(s->mrb);\n    prev->irep = s->irep = irep;\n    return;\n  }\n  else {\n    if (prev->irep->rlen == UINT16_MAX) {\n      codegen_error(s, \"too many nested blocks/methods\");\n    }\n    s->irep = irep = mrb_add_irep(s->mrb);\n    if (prev->irep->rlen == prev->rcapa) {\n      prev->rcapa *= 2;\n      prev->reps = (mrb_irep**)codegen_realloc(s, prev->reps, sizeof(mrb_irep*)*prev->rcapa);\n    }\n    prev->reps[prev->irep->rlen] = irep;\n    prev->irep->rlen++;\n  }\n}\n\nstatic codegen_scope*\nscope_new(mrb_state *mrb, codegen_scope *prev, node *nlv)\n{\n  static const codegen_scope codegen_scope_zero = { 0 };\n  mrb_pool *pool = mrb_pool_open(mrb);\n  codegen_scope *s = (codegen_scope *)mrb_pool_alloc(pool, sizeof(codegen_scope));\n\n  if (!s) {\n    if (prev)\n      codegen_error(prev, \"unexpected scope\");\n    return NULL;\n  }\n  *s = codegen_scope_zero;\n  s->mrb = mrb;\n  s->mpool = pool;\n  if (!prev) return s;\n  s->prev = prev;\n  s->ainfo = 0;\n  s->mscope = 0;\n\n  scope_add_irep(s);\n\n  s->rcapa = 8;\n  s->reps = (mrb_irep**)mrb_malloc(mrb, sizeof(mrb_irep*)*s->rcapa);\n\n  s->icapa = 1024;\n  s->iseq = (mrb_code*)mrb_malloc(mrb, sizeof(mrb_code)*s->icapa);\n\n  s->pcapa = 32;\n  s->pool = (mrb_pool_value*)mrb_malloc(mrb, sizeof(mrb_pool_value)*s->pcapa);\n\n  s->scapa = 256;\n  s->syms = (mrb_sym*)mrb_malloc(mrb, sizeof(mrb_sym)*s->scapa);\n\n  s->lv = nlv;\n  s->sp += node_len(nlv)+1;        /* add self */\n  s->nlocals = s->sp;\n  if (nlv) {\n    mrb_sym *lv;\n    node *n = nlv;\n    size_t i = 0;\n\n    s->irep->lv = lv = (mrb_sym*)mrb_malloc(mrb, sizeof(mrb_sym)*(s->nlocals-1));\n    for (i=0, n=nlv; n; i++,n=n->cdr) {\n      lv[i] = lv_name(n);\n    }\n    mrb_assert(i + 1 == s->nlocals);\n  }\n  s->ai = mrb_gc_arena_save(mrb);\n\n  s->filename_sym = prev->filename_sym;\n  if (s->filename_sym) {\n    s->lines = (uint16_t*)mrb_malloc(mrb, sizeof(short)*s->icapa);\n  }\n  s->lineno = prev->lineno;\n\n  /* debug setting */\n  s->debug_start_pos = 0;\n  if (s->filename_sym) {\n    mrb_debug_info_alloc(mrb, s->irep);\n  }\n  else {\n    s->irep->debug_info = NULL;\n  }\n  s->parser = prev->parser;\n  s->filename_index = prev->filename_index;\n\n  s->rlev = prev->rlev+1;\n\n  return s;\n}\n\nstatic void\nscope_finish(codegen_scope *s)\n{\n  mrb_state *mrb = s->mrb;\n  mrb_irep *irep = s->irep;\n\n  if (s->nlocals > 0xff) {\n    codegen_error(s, \"too many local variables\");\n  }\n  irep->flags = 0;\n  if (s->iseq) {\n    size_t catchsize = sizeof(struct mrb_irep_catch_handler) * irep->clen;\n    irep->iseq = (const mrb_code *)codegen_realloc(s, s->iseq, sizeof(mrb_code)*s->pc + catchsize);\n    irep->ilen = s->pc;\n    if (irep->clen > 0) {\n      memcpy((void *)(irep->iseq + irep->ilen), s->catch_table, catchsize);\n    }\n  }\n  else {\n    irep->clen = 0;\n  }\n  mrb_free(s->mrb, s->catch_table);\n  s->catch_table = NULL;\n  irep->pool = (const mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*irep->plen);\n  irep->syms = (const mrb_sym*)codegen_realloc(s, s->syms, sizeof(mrb_sym)*irep->slen);\n  irep->reps = (const mrb_irep**)codegen_realloc(s, s->reps, sizeof(mrb_irep*)*irep->rlen);\n  if (s->filename_sym) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n  }\n  mrb_free(s->mrb, s->lines);\n\n  irep->nlocals = s->nlocals;\n  irep->nregs = s->nregs;\n\n  mrb_gc_arena_restore(mrb, s->ai);\n  mrb_pool_close(s->mpool);\n}\n\nstatic struct loopinfo*\nloop_push(codegen_scope *s, enum looptype t)\n{\n  struct loopinfo *p = (struct loopinfo *)codegen_palloc(s, sizeof(struct loopinfo));\n\n  p->type = t;\n  p->pc0 = p->pc1 = p->pc2 = JMPLINK_START;\n  p->prev = s->loop;\n  p->reg = cursp();\n  s->loop = p;\n\n  return p;\n}\n\nstatic void\nloop_break(codegen_scope *s, node *tree)\n{\n  if (!s->loop) {\n    codegen(s, tree, NOVAL);\n    raise_error(s, \"unexpected break\");\n  }\n  else {\n    struct loopinfo *loop;\n\n\n    loop = s->loop;\n    if (tree) {\n      if (loop->reg < 0) {\n        codegen(s, tree, NOVAL);\n      }\n      else {\n        gen_retval(s, tree);\n      }\n    }\n    while (loop) {\n      if (loop->type == LOOP_BEGIN) {\n        loop = loop->prev;\n      }\n      else if (loop->type == LOOP_RESCUE) {\n        loop = loop->prev;\n      }\n      else{\n        break;\n      }\n    }\n    if (!loop) {\n      raise_error(s, \"unexpected break\");\n      return;\n    }\n\n    if (loop->type == LOOP_NORMAL) {\n      int tmp;\n\n      if (loop->reg >= 0) {\n        if (tree) {\n          gen_move(s, loop->reg, cursp(), 0);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, loop->reg);\n        }\n      }\n      tmp = genjmp(s, OP_JMPUW, loop->pc2);\n      loop->pc2 = tmp;\n    }\n    else {\n      if (!tree) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_BREAK, cursp());\n    }\n  }\n}\n\nstatic void\nloop_pop(codegen_scope *s, int val)\n{\n  if (val) {\n    genop_1(s, OP_LOADNIL, cursp());\n  }\n  dispatch_linked(s, s->loop->pc2);\n  s->loop = s->loop->prev;\n  if (val) push();\n}\n\nstatic int\ncatch_handler_new(codegen_scope *s)\n{\n  size_t newsize = sizeof(struct mrb_irep_catch_handler) * (s->irep->clen + 1);\n  s->catch_table = (struct mrb_irep_catch_handler *)codegen_realloc(s, (void *)s->catch_table, newsize);\n  return s->irep->clen ++;\n}\n\nstatic void\ncatch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target)\n{\n  struct mrb_irep_catch_handler *e;\n\n  mrb_assert(ent >= 0 && ent < s->irep->clen);\n\n  e = &s->catch_table[ent];\n  uint8_to_bin(type, &e->type);\n  mrb_irep_catch_handler_pack(begin, e->begin);\n  mrb_irep_catch_handler_pack(end, e->end);\n  mrb_irep_catch_handler_pack(target, e->target);\n}\n\nstatic struct RProc*\ngenerate_code(mrb_state *mrb, parser_state *p, int val)\n{\n  codegen_scope *scope = scope_new(mrb, 0, 0);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf jmpbuf;\n  struct RProc *proc;\n\n  mrb->jmp = &jmpbuf;\n\n  scope->mrb = mrb;\n  scope->parser = p;\n  scope->filename_sym = p->filename_sym;\n  scope->filename_index = p->current_filename_index;\n\n  MRB_TRY(mrb->jmp) {\n    /* prepare irep */\n    codegen(scope, p->tree, val);\n    proc = mrb_proc_new(mrb, scope->irep);\n    mrb_irep_decref(mrb, scope->irep);\n    mrb_pool_close(scope->mpool);\n    proc->c = NULL;\n    if (mrb->c->cibase && mrb->c->cibase->proc == proc->upper) {\n      proc->upper = NULL;\n    }\n    mrb->jmp = prev_jmp;\n    return proc;\n  }\n  MRB_CATCH(mrb->jmp) {\n    mrb_irep_decref(mrb, scope->irep);\n    mrb_pool_close(scope->mpool);\n    mrb->jmp = prev_jmp;\n    return NULL;\n  }\n  MRB_END_EXC(mrb->jmp);\n}\n\nMRB_API struct RProc*\nmrb_generate_code(mrb_state *mrb, parser_state *p)\n{\n  return generate_code(mrb, p, VAL);\n}\n\nvoid\nmrb_irep_remove_lv(mrb_state *mrb, mrb_irep *irep)\n{\n  int i;\n\n  if (irep->flags & MRB_IREP_NO_FREE) return;\n  if (irep->lv) {\n    mrb_free(mrb, (void*)irep->lv);\n    irep->lv = NULL;\n  }\n  if (!irep->reps) return;\n  for (i = 0; i < irep->rlen; ++i) {\n    mrb_irep_remove_lv(mrb, (mrb_irep*)irep->reps[i]);\n  }\n}\n"], "fixing_code": ["/*\n** codegen.c - mruby code generator\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/compile.h>\n#include <mruby/proc.h>\n#include <mruby/dump.h>\n#include <mruby/numeric.h>\n#include <mruby/string.h>\n#include <mruby/debug.h>\n#include <mruby/presym.h>\n#include \"node.h\"\n#include <mruby/opcode.h>\n#include <mruby/re.h>\n#include <mruby/throw.h>\n#include <ctype.h>\n#include <string.h>\n\n#ifndef MRB_CODEGEN_LEVEL_MAX\n#define MRB_CODEGEN_LEVEL_MAX 256\n#endif\n\n#define MAXARG_S (1<<16)\n\ntypedef mrb_ast_node node;\ntypedef struct mrb_parser_state parser_state;\n\nenum looptype {\n  LOOP_NORMAL,\n  LOOP_BLOCK,\n  LOOP_FOR,\n  LOOP_BEGIN,\n  LOOP_RESCUE,\n};\n\nstruct loopinfo {\n  enum looptype type;\n  uint32_t pc0;                 /* `next` destination */\n  uint32_t pc1;                 /* `redo` destination */\n  uint32_t pc2;                 /* `break` destination */\n  int reg;                      /* destination register */\n  struct loopinfo *prev;\n};\n\ntypedef struct scope {\n  mrb_state *mrb;\n  mrb_pool *mpool;\n\n  struct scope *prev;\n\n  node *lv;\n\n  uint16_t sp;\n  uint32_t pc;\n  uint32_t lastpc;\n  uint32_t lastlabel;\n  uint16_t ainfo:15;\n  mrb_bool mscope:1;\n\n  struct loopinfo *loop;\n  mrb_sym filename_sym;\n  uint16_t lineno;\n\n  mrb_code *iseq;\n  uint16_t *lines;\n  uint32_t icapa;\n\n  mrb_irep *irep;\n  mrb_pool_value *pool;\n  mrb_sym *syms;\n  mrb_irep **reps;\n  struct mrb_irep_catch_handler *catch_table;\n  uint32_t pcapa, scapa, rcapa;\n\n  uint16_t nlocals;\n  uint16_t nregs;\n  int ai;\n\n  int debug_start_pos;\n  uint16_t filename_index;\n  parser_state* parser;\n\n  int rlev;                     /* recursion levels */\n} codegen_scope;\n\nstatic codegen_scope* scope_new(mrb_state *mrb, codegen_scope *prev, node *lv);\nstatic void scope_finish(codegen_scope *s);\nstatic struct loopinfo *loop_push(codegen_scope *s, enum looptype t);\nstatic void loop_break(codegen_scope *s, node *tree);\nstatic void loop_pop(codegen_scope *s, int val);\n\n/*\n * The search for catch handlers starts at the end of the table in mrb_vm_run().\n * Therefore, the next handler to be added must meet one of the following conditions.\n * - Larger start position\n * - Same start position but smaller end position\n */\nstatic int catch_handler_new(codegen_scope *s);\nstatic void catch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target);\n\nstatic void gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val);\nstatic void gen_vmassignment(codegen_scope *s, node *tree, int sp, int val);\n\nstatic void codegen(codegen_scope *s, node *tree, int val);\nstatic void raise_error(codegen_scope *s, const char *msg);\n\nstatic void\ncodegen_error(codegen_scope *s, const char *message)\n{\n  if (!s) return;\n#ifndef MRB_NO_STDIO\n  if (s->filename_sym && s->lineno) {\n    const char *filename = mrb_sym_name_len(s->mrb, s->filename_sym, NULL);\n    fprintf(stderr, \"%s:%d: %s\\n\", filename, s->lineno, message);\n  }\n  else {\n    fprintf(stderr, \"%s\\n\", message);\n  }\n#endif\n  while (s->prev) {\n    codegen_scope *tmp = s->prev;\n    if (s->irep) {\n      mrb_free(s->mrb, s->iseq);\n      for (int i=0; i<s->irep->plen; i++) {\n        mrb_pool_value *pv = &s->pool[i];\n        if ((pv->tt & 0x3) == IREP_TT_STR || pv->tt == IREP_TT_BIGINT) {\n          mrb_free(s->mrb, (void*)pv->u.str);\n        }\n      }\n      mrb_free(s->mrb, s->pool);\n      mrb_free(s->mrb, s->syms);\n      mrb_free(s->mrb, s->catch_table);\n      if (s->reps) {\n        /* copied from mrb_irep_free() in state.c */\n        for (int i=0; i<s->irep->rlen; i++) {\n          if (s->reps[i])\n            mrb_irep_decref(s->mrb, (mrb_irep*)s->reps[i]);\n        }\n        mrb_free(s->mrb, s->reps);\n      }\n      mrb_free(s->mrb, s->lines);\n    }\n    mrb_pool_close(s->mpool);\n    s = tmp;\n  }\n  MRB_THROW(s->mrb->jmp);\n}\n\nstatic void*\ncodegen_palloc(codegen_scope *s, size_t len)\n{\n  void *p = mrb_pool_alloc(s->mpool, len);\n\n  if (!p) codegen_error(s, \"pool memory allocation\");\n  return p;\n}\n\nstatic void*\ncodegen_realloc(codegen_scope *s, void *p, size_t len)\n{\n  p = mrb_realloc_simple(s->mrb, p, len);\n\n  if (!p && len > 0) codegen_error(s, \"mrb_realloc\");\n  return p;\n}\n\nstatic void\ncheck_no_ext_ops(codegen_scope *s, uint16_t a, uint16_t b)\n{\n  if (s->parser->no_ext_ops && (a | b) > 0xff) {\n    codegen_error(s, \"need OP_EXTs instruction (currently OP_EXTs are prohibited)\");\n  }\n}\n\nstatic int\nnew_label(codegen_scope *s)\n{\n  return s->lastlabel = s->pc;\n}\n\nstatic void\nemit_B(codegen_scope *s, uint32_t pc, uint8_t i)\n{\n  if (pc >= s->icapa) {\n    if (pc == UINT32_MAX) {\n      codegen_error(s, \"too big code block\");\n    }\n    if (pc >= UINT32_MAX / 2) {\n      pc = UINT32_MAX;\n    }\n    else {\n      s->icapa *= 2;\n    }\n    s->iseq = (mrb_code *)codegen_realloc(s, s->iseq, sizeof(mrb_code)*s->icapa);\n    if (s->lines) {\n      s->lines = (uint16_t*)codegen_realloc(s, s->lines, sizeof(uint16_t)*s->icapa);\n    }\n  }\n  if (s->lines) {\n    if (s->lineno > 0 || pc == 0)\n      s->lines[pc] = s->lineno;\n    else\n      s->lines[pc] = s->lines[pc-1];\n  }\n  s->iseq[pc] = i;\n}\n\nstatic void\nemit_S(codegen_scope *s, int pc, uint16_t i)\n{\n  uint8_t hi = i>>8;\n  uint8_t lo = i&0xff;\n\n  emit_B(s, pc,   hi);\n  emit_B(s, pc+1, lo);\n}\n\nstatic void\ngen_B(codegen_scope *s, uint8_t i)\n{\n  emit_B(s, s->pc, i);\n  s->pc++;\n}\n\nstatic void\ngen_S(codegen_scope *s, uint16_t i)\n{\n  emit_S(s, s->pc, i);\n  s->pc += 2;\n}\n\nstatic void\ngenop_0(codegen_scope *s, mrb_code i)\n{\n  s->lastpc = s->pc;\n  gen_B(s, i);\n}\n\nstatic void\ngenop_1(codegen_scope *s, mrb_code i, uint16_t a)\n{\n  s->lastpc = s->pc;\n  check_no_ext_ops(s, a, 0);\n  if (a > 0xff) {\n    gen_B(s, OP_EXT1);\n    gen_B(s, i);\n    gen_S(s, a);\n  }\n  else {\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n  }\n}\n\nstatic void\ngenop_2(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b)\n{\n  s->lastpc = s->pc;\n  check_no_ext_ops(s, a, b);\n  if (a > 0xff && b > 0xff) {\n    gen_B(s, OP_EXT3);\n    gen_B(s, i);\n    gen_S(s, a);\n    gen_S(s, b);\n  }\n  else if (b > 0xff) {\n    gen_B(s, OP_EXT2);\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n    gen_S(s, b);\n  }\n  else if (a > 0xff) {\n    gen_B(s, OP_EXT1);\n    gen_B(s, i);\n    gen_S(s, a);\n    gen_B(s, (uint8_t)b);\n  }\n  else {\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n    gen_B(s, (uint8_t)b);\n  }\n}\n\nstatic void\ngenop_3(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b, uint8_t c)\n{\n  genop_2(s, i, a, b);\n  gen_B(s, c);\n}\n\nstatic void\ngenop_2S(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b)\n{\n  genop_1(s, i, a);\n  gen_S(s, b);\n}\n\nstatic void\ngenop_2SS(codegen_scope *s, mrb_code i, uint16_t a, uint32_t b)\n{\n  genop_1(s, i, a);\n  gen_S(s, b>>16);\n  gen_S(s, b&0xffff);\n}\n\nstatic void\ngenop_W(codegen_scope *s, mrb_code i, uint32_t a)\n{\n  uint8_t a1 = (a>>16) & 0xff;\n  uint8_t a2 = (a>>8) & 0xff;\n  uint8_t a3 = a & 0xff;\n\n  s->lastpc = s->pc;\n  gen_B(s, i);\n  gen_B(s, a1);\n  gen_B(s, a2);\n  gen_B(s, a3);\n}\n\n#define NOVAL  0\n#define VAL    1\n\nstatic mrb_bool\nno_optimize(codegen_scope *s)\n{\n  if (s && s->parser && s->parser->no_optimize)\n    return TRUE;\n  return FALSE;\n}\n\nstruct mrb_insn_data\nmrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n\n  switch (insn) {\n#define FETCH_Z() /* empty */\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}\n\n#undef OPCODE\n#define Z 1\n#define S 3\n#define W 4\n#define OPCODE(_,x) x,\n/* instruction sizes */\nstatic uint8_t mrb_insn_size[] = {\n#define B 2\n#define BB 3\n#define BBB 4\n#define BS 4\n#define BSS 6\n#include \"mruby/ops.h\"\n#undef B\n#undef BB\n#undef BBB\n#undef BS\n#undef BSS\n};\n/* EXT1 instruction sizes */\nstatic uint8_t mrb_insn_size1[] = {\n#define B 3\n#define BB 4\n#define BBB 5\n#define BS 5\n#define BSS 7\n#include \"mruby/ops.h\"\n#undef B\n#undef BS\n#undef BSS\n};\n/* EXT2 instruction sizes */\nstatic uint8_t mrb_insn_size2[] = {\n#define B 2\n#define BS 4\n#define BSS 6\n#include \"mruby/ops.h\"\n#undef B\n#undef BB\n#undef BBB\n#undef BS\n#undef BSS\n};\n/* EXT3 instruction sizes */\n#define B 3\n#define BB 5\n#define BBB 6\n#define BS 5\n#define BSS 7\nstatic uint8_t mrb_insn_size3[] = {\n#include \"mruby/ops.h\"\n};\n#undef B\n#undef BB\n#undef BBB\n#undef BS\n#undef BSS\n#undef OPCODE\n\nstatic const mrb_code*\nmrb_prev_pc(codegen_scope *s, const mrb_code *pc)\n{\n  const mrb_code *prev_pc = NULL;\n  const mrb_code *i = s->iseq;\n\n  while (i<pc) {\n    uint8_t insn = i[0];\n    prev_pc = i;\n    switch (insn) {\n    case OP_EXT1:\n      i += mrb_insn_size1[i[1]] + 1;\n      break;\n    case OP_EXT2:\n      i += mrb_insn_size2[i[1]] + 1;\n      break;\n    case OP_EXT3:\n      i += mrb_insn_size3[i[1]] + 1;\n      break;\n    default:\n      i += mrb_insn_size[insn];\n      break;\n    }\n  }\n  return prev_pc;\n}\n\n#define pc_addr(s) &((s)->iseq[(s)->pc])\n#define addr_pc(s, addr) (uint32_t)((addr) - s->iseq)\n#define rewind_pc(s) s->pc = s->lastpc\n\nstatic struct mrb_insn_data\nmrb_last_insn(codegen_scope *s)\n{\n  if (s->pc == 0) {\n    struct mrb_insn_data data = { OP_NOP, 0 };\n    return data;\n  }\n  return mrb_decode_insn(&s->iseq[s->lastpc]);\n}\n\nstatic mrb_bool\nno_peephole(codegen_scope *s)\n{\n  return no_optimize(s) || s->lastlabel == s->pc || s->pc == 0 || s->pc == s->lastpc;\n}\n\n#define JMPLINK_START UINT32_MAX\n\nstatic void\ngen_jmpdst(codegen_scope *s, uint32_t pc)\n{\n\n  if (pc == JMPLINK_START) {\n    pc = 0;\n  }\n  uint32_t pos2 = s->pc+2;\n  int32_t off = pc - pos2;\n\n  if (off > INT16_MAX || INT16_MIN > off) {\n    codegen_error(s, \"too big jump offset\");\n  }\n  gen_S(s, (uint16_t)off);\n}\n\nstatic uint32_t\ngenjmp(codegen_scope *s, mrb_code i, uint32_t pc)\n{\n  uint32_t pos;\n\n  genop_0(s, i);\n  pos = s->pc;\n  gen_jmpdst(s, pc);\n  return pos;\n}\n\n#define genjmp_0(s,i) genjmp(s,i,JMPLINK_START)\n\nstatic uint32_t\ngenjmp2(codegen_scope *s, mrb_code i, uint16_t a, uint32_t pc, int val)\n{\n  uint32_t pos;\n\n  if (!no_peephole(s) && !val) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    switch (data.insn) {\n    case OP_MOVE:\n      if (data.a == a && data.a > s->nlocals) {\n        rewind_pc(s);\n        a = data.b;\n      }\n      break;\n    case OP_LOADNIL:\n    case OP_LOADF:\n      if (data.a == a || data.a > s->nlocals) {\n        s->pc = addr_pc(s, data.addr);\n        if (i == OP_JMPNOT || (i == OP_JMPNIL && data.insn == OP_LOADNIL)) {\n          return genjmp(s, OP_JMP, pc);\n        }\n        else {                  /* OP_JMPIF */\n          return JMPLINK_START;\n        }\n      }\n      break;\n    case OP_LOADT: case OP_LOADI: case OP_LOADINEG: case OP_LOADI__1:\n    case OP_LOADI_0: case OP_LOADI_1: case OP_LOADI_2: case OP_LOADI_3:\n    case OP_LOADI_4: case OP_LOADI_5: case OP_LOADI_6: case OP_LOADI_7:\n      if (data.a == a || data.a > s->nlocals) {\n        s->pc = addr_pc(s, data.addr);\n        if (i == OP_JMPIF) {\n          return genjmp(s, OP_JMP, pc);\n        }\n        else {                  /* OP_JMPNOT and OP_JMPNIL */\n          return JMPLINK_START;\n        }\n      }\n      break;\n    }\n  }\n\n  if (a > 0xff) {\n    check_no_ext_ops(s, a, 0);\n    gen_B(s, OP_EXT1);\n    genop_0(s, i);\n    gen_S(s, a);\n  }\n  else {\n    genop_0(s, i);\n    gen_B(s, (uint8_t)a);\n  }\n  pos = s->pc;\n  gen_jmpdst(s, pc);\n  return pos;\n}\n\n#define genjmp2_0(s,i,a,val) genjmp2(s,i,a,JMPLINK_START,val)\n\nstatic mrb_bool get_int_operand(codegen_scope *s, struct mrb_insn_data *data, mrb_int *ns);\nstatic void gen_int(codegen_scope *s, uint16_t dst, mrb_int i);\n\nstatic void\ngen_move(codegen_scope *s, uint16_t dst, uint16_t src, int nopeep)\n{\n  if (nopeep || no_peephole(s)) goto normal;\n  else if (dst == src) return;\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    switch (data.insn) {\n    case OP_MOVE:\n      if (dst == src) return;             /* remove useless MOVE */\n      if (data.b == dst && data.a == src) /* skip swapping MOVE */\n        return;\n      goto normal;\n    case OP_LOADNIL: case OP_LOADSELF: case OP_LOADT: case OP_LOADF:\n    case OP_LOADI__1:\n    case OP_LOADI_0: case OP_LOADI_1: case OP_LOADI_2: case OP_LOADI_3:\n    case OP_LOADI_4: case OP_LOADI_5: case OP_LOADI_6: case OP_LOADI_7:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_1(s, data.insn, dst);\n      return;\n    case OP_HASH: case OP_ARRAY:\n      if (data.b != 0) goto normal;\n      /* fall through */\n    case OP_LOADI: case OP_LOADINEG:\n    case OP_LOADL: case OP_LOADSYM:\n    case OP_GETGV: case OP_GETSV: case OP_GETIV: case OP_GETCV:\n    case OP_GETCONST: case OP_STRING:\n    case OP_LAMBDA: case OP_BLOCK: case OP_METHOD: case OP_BLKPUSH:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_2(s, data.insn, dst, data.b);\n      return;\n    case OP_LOADI16:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_2S(s, data.insn, dst, data.b);\n      return;\n    case OP_LOADI32:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      else {\n        uint32_t i = (uint32_t)data.b<<16|data.c;\n        rewind_pc(s);\n        genop_2SS(s, data.insn, dst, i);\n      }\n      return;\n    case OP_AREF:\n    case OP_GETUPVAR:\n      if (data.a != src || data.a < s->nlocals) goto normal;\n      rewind_pc(s);\n      genop_3(s, data.insn, dst, data.b, data.c);\n      return;\n    case OP_ADDI: case OP_SUBI:\n      if (addr_pc(s, data.addr) == s->lastlabel || data.a != src || data.a < s->nlocals) goto normal;\n      else {\n        struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n        if (data0.insn != OP_MOVE || data0.a != data.a || data0.b != dst) goto normal;\n        s->pc = addr_pc(s, data0.addr);\n        if (addr_pc(s, data0.addr) != s->lastlabel) {\n          /* constant folding */\n          data0 = mrb_decode_insn(mrb_prev_pc(s, data0.addr));\n          mrb_int n;\n          if (data0.a == dst && get_int_operand(s, &data0, &n)) {\n            if ((data.insn == OP_ADDI && !mrb_int_add_overflow(n, data.b, &n)) ||\n                (data.insn == OP_SUBI && !mrb_int_sub_overflow(n, data.b, &n))) {\n              s->pc = addr_pc(s, data0.addr);\n              gen_int(s, dst, n);\n              return;\n            }\n          }\n        }\n      }\n      genop_2(s, data.insn, dst, data.b);\n      return;\n    default:\n      break;\n    }\n  }\n normal:\n  genop_2(s, OP_MOVE, dst, src);\n  return;\n}\n\nstatic int search_upvar(codegen_scope *s, mrb_sym id, int *idx);\n\nstatic void\ngen_getupvar(codegen_scope *s, uint16_t dst, mrb_sym id)\n{\n  int idx;\n  int lv = search_upvar(s, id, &idx);\n\n  if (!no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    if (data.insn == OP_SETUPVAR && data.a == dst && data.b == idx && data.c == lv) {\n      /* skip GETUPVAR right after SETUPVAR */\n      return;\n    }\n  }\n  genop_3(s, OP_GETUPVAR, dst, idx, lv);\n}\n\nstatic void\ngen_setupvar(codegen_scope *s, uint16_t dst, mrb_sym id)\n{\n  int idx;\n  int lv = search_upvar(s, id, &idx);\n\n  if (!no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    if (data.insn == OP_MOVE && data.a == dst) {\n      dst = data.b;\n      rewind_pc(s);\n    }\n  }\n  genop_3(s, OP_SETUPVAR, dst, idx, lv);\n}\n\nstatic void\ngen_return(codegen_scope *s, uint8_t op, uint16_t src)\n{\n  if (no_peephole(s)) {\n    genop_1(s, op, src);\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    if (data.insn == OP_MOVE && src == data.a) {\n      rewind_pc(s);\n      genop_1(s, op, data.b);\n    }\n    else if (data.insn != OP_RETURN) {\n      genop_1(s, op, src);\n    }\n  }\n}\n\nstatic mrb_bool\nget_int_operand(codegen_scope *s, struct mrb_insn_data *data, mrb_int *n)\n{\n  switch (data->insn) {\n  case OP_LOADI__1:\n    *n = -1;\n    return TRUE;\n\n  case OP_LOADINEG:\n    *n = -data->b;\n    return TRUE;\n\n  case OP_LOADI_0: case OP_LOADI_1: case OP_LOADI_2: case OP_LOADI_3:\n  case OP_LOADI_4: case OP_LOADI_5: case OP_LOADI_6: case OP_LOADI_7:\n    *n = data->insn - OP_LOADI_0;\n    return TRUE;\n\n  case OP_LOADI:\n  case OP_LOADI16:\n    *n = (int16_t)data->b;\n    return TRUE;\n\n  case OP_LOADI32:\n    *n = (mrb_int)((uint32_t)data->b<<16)+data->c;\n    return TRUE;\n\n  case OP_LOADL:\n    {\n      mrb_pool_value *pv = &s->pool[data->b];\n\n      if (pv->tt == IREP_TT_INT32) {\n        *n = (mrb_int)pv->u.i32;\n      }\n#ifdef MRB_INT64\n      else if (pv->tt == IREP_TT_INT64) {\n        *n = (mrb_int)pv->u.i64;\n      }\n#endif\n      else {\n        return FALSE;\n      }\n    }\n    return TRUE;\n\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ngen_addsub(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n;\n\n    if (!get_int_operand(s, &data, &n)) {\n      /* not integer immediate */\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    mrb_int n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data0, &n0)) {\n      /* OP_ADDI/OP_SUBI takes upto 8bits */\n      if (n > INT8_MAX || n < INT8_MIN) goto normal;\n      rewind_pc(s);\n      if (n == 0) return;\n      if (n > 0) {\n        if (op == OP_ADD) genop_2(s, OP_ADDI, dst, (uint16_t)n);\n        else genop_2(s, OP_SUBI, dst, (uint16_t)n);\n      }\n      else {                    /* n < 0 */\n        n = -n;\n        if (op == OP_ADD) genop_2(s, OP_SUBI, dst, (uint16_t)n);\n        else genop_2(s, OP_ADDI, dst, (uint16_t)n);\n      }\n      return;\n    }\n    if (op == OP_ADD) {\n      if (mrb_int_add_overflow(n0, n, &n)) goto normal;\n    }\n    else { /* OP_SUB */\n      if (mrb_int_sub_overflow(n0, n, &n)) goto normal;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}\n\nstatic void\ngen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      /* not integer immediate */\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { /* OP_DIV */\n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}\n\nmrb_bool mrb_num_shift(mrb_state *mrb, mrb_int val, mrb_int width, mrb_int *num);\n\nstatic mrb_bool\ngen_binop(codegen_scope *s, mrb_sym op, uint16_t dst)\n{\n  if (no_peephole(s)) return FALSE;\n  else if (op == MRB_OPSYM_2(s->mrb, aref)) {\n    genop_1(s, OP_GETIDX, dst);\n    return TRUE;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      /* not integer immediate */\n      return FALSE;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0)) {\n      return FALSE;\n    }\n    if (op == MRB_OPSYM_2(s->mrb, lshift)) {\n      if (!mrb_num_shift(s->mrb, n0, n, &n)) return FALSE;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, rshift)) {\n      if (n == MRB_INT_MIN) return FALSE;\n      if (!mrb_num_shift(s->mrb, n0, -n, &n)) return FALSE;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, mod) && n != 0) {\n      if (n0 == MRB_INT_MIN && n == -1) {\n        n = 0;\n      }\n      else {\n        mrb_int n1 = n0 % n;\n        if ((n0 < 0) != (n < 0) && n1 != 0) {\n          n1 += n;\n        }\n        n = n1;\n      }\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, and)) {\n      n = n0 & n;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, or)) {\n      n = n0 | n;\n    }\n    else if (op == MRB_OPSYM_2(s->mrb, xor)) {\n      n = n0 ^ n;\n    }\n    else {\n      return FALSE;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n    return TRUE;\n  }\n}\n\nstatic uint32_t\ndispatch(codegen_scope *s, uint32_t pos0)\n{\n  int32_t pos1;\n  int32_t offset;\n  int16_t newpos;\n\n  if (pos0 == JMPLINK_START) return 0;\n\n  pos1 = pos0 + 2;\n  offset = s->pc - pos1;\n  if (offset > INT16_MAX) {\n    codegen_error(s, \"too big jmp offset\");\n  }\n  s->lastlabel = s->pc;\n  newpos = (int16_t)PEEK_S(s->iseq+pos0);\n  emit_S(s, pos0, (uint16_t)offset);\n  if (newpos == 0) return 0;\n  return pos1+newpos;\n}\n\nstatic void\ndispatch_linked(codegen_scope *s, uint32_t pos)\n{\n  if (pos==JMPLINK_START) return;\n  for (;;) {\n    pos = dispatch(s, pos);\n    if (pos==0) break;\n  }\n}\n\n#define nregs_update do {if (s->sp > s->nregs) s->nregs = s->sp;} while (0)\nstatic void\npush_n_(codegen_scope *s, int n)\n{\n  if (s->sp+n >= 0xffff) {\n    codegen_error(s, \"too complex expression\");\n  }\n  s->sp+=n;\n  nregs_update;\n}\n\nstatic void\npop_n_(codegen_scope *s, int n)\n{\n  if ((int)s->sp-n < 0) {\n    codegen_error(s, \"stack pointer underflow\");\n  }\n  s->sp-=n;\n}\n\n#define push() push_n_(s,1)\n#define push_n(n) push_n_(s,n)\n#define pop() pop_n_(s,1)\n#define pop_n(n) pop_n_(s,n)\n#define cursp() (s->sp)\n\nstatic int\nnew_litbn(codegen_scope *s, const char *p, int base, mrb_bool neg)\n{\n  int i;\n  size_t plen;\n  mrb_pool_value *pv;\n\n  plen = strlen(p);\n  if (plen > 255) {\n    codegen_error(s, \"integer too big\");\n  }\n  for (i=0; i<s->irep->plen; i++) {\n    size_t len;\n    pv = &s->pool[i];\n    if (pv->tt != IREP_TT_BIGINT) continue;\n    len = pv->u.str[0];\n    if (len == plen && pv->u.str[1] == base && memcmp(pv->u.str+2, p, len) == 0)\n      return i;\n  }\n\n  if (s->irep->plen == s->pcapa) {\n    s->pcapa *= 2;\n    s->pool = (mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*s->pcapa);\n  }\n\n  pv = &s->pool[s->irep->plen];\n  i = s->irep->plen++;\n  {\n    char *buf;\n    pv->tt = IREP_TT_BIGINT;\n    buf = (char*)codegen_realloc(s, NULL, plen+3);\n    buf[0] = (char)plen;\n    buf[1] = base;\n    if (neg) buf[1] = 0x80;\n    memcpy(buf+2, p, plen);\n    buf[plen+2] = '\\0';\n    pv->u.str = buf;\n  }\n  return i;\n}\n\nstatic int\nnew_lit(codegen_scope *s, mrb_value val)\n{\n  int i;\n  mrb_pool_value *pv;\n\n  switch (mrb_type(val)) {\n  case MRB_TT_STRING:\n    for (i=0; i<s->irep->plen; i++) {\n      mrb_int len;\n      pv = &s->pool[i];\n      if (pv->tt & IREP_TT_NFLAG) continue;\n      len = pv->tt>>2;\n      if (RSTRING_LEN(val) != len) continue;\n      if (memcmp(pv->u.str, RSTRING_PTR(val), len) == 0)\n        return i;\n    }\n    break;\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n    for (i=0; i<s->irep->plen; i++) {\n      mrb_float f1, f2;\n      pv = &s->pool[i];\n      if (pv->tt != IREP_TT_FLOAT) continue;\n      pv = &s->pool[i];\n      f1 = pv->u.f;\n      f2 = mrb_float(val);\n      if (f1 == f2 && !signbit(f1) == !signbit(f2)) return i;\n    }\n    break;\n#endif\n  case MRB_TT_INTEGER:\n    for (i=0; i<s->irep->plen; i++) {\n      mrb_int v = mrb_integer(val);\n      pv = &s->pool[i];\n      if (pv->tt == IREP_TT_INT32) {\n        if (v == pv->u.i32) return i;\n      }\n#ifdef MRB_64BIT\n      else if (pv->tt == IREP_TT_INT64) {\n        if (v == pv->u.i64) return i;\n      }\n      continue;\n#endif\n    }\n    break;\n  default:\n    /* should not happen */\n    return 0;\n  }\n\n  if (s->irep->plen == s->pcapa) {\n    s->pcapa *= 2;\n    s->pool = (mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*s->pcapa);\n  }\n\n  pv = &s->pool[s->irep->plen];\n  i = s->irep->plen++;\n\n  switch (mrb_type(val)) {\n  case MRB_TT_STRING:\n    if (RSTR_NOFREE_P(RSTRING(val))) {\n      pv->tt = (uint32_t)(RSTRING_LEN(val)<<2) | IREP_TT_SSTR;\n      pv->u.str = RSTRING_PTR(val);\n    }\n    else {\n      char *p;\n      mrb_int len = RSTRING_LEN(val);\n      pv->tt = (uint32_t)(len<<2) | IREP_TT_STR;\n      p = (char*)codegen_realloc(s, NULL, len+1);\n      memcpy(p, RSTRING_PTR(val), len);\n      p[len] = '\\0';\n      pv->u.str = p;\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n    pv->tt = IREP_TT_FLOAT;\n    pv->u.f = mrb_float(val);\n    break;\n#endif\n  case MRB_TT_INTEGER:\n#ifdef MRB_INT64\n    pv->tt = IREP_TT_INT64;\n    pv->u.i64 = mrb_integer(val);\n#else\n    pv->tt = IREP_TT_INT32;\n    pv->u.i32 = mrb_integer(val);\n#endif\n    break;\n\n  default:\n    /* should not happen */\n    break;\n  }\n  return i;\n}\n\nstatic int\nnew_sym(codegen_scope *s, mrb_sym sym)\n{\n  int i, len;\n\n  mrb_assert(s->irep);\n\n  len = s->irep->slen;\n  for (i=0; i<len; i++) {\n    if (s->syms[i] == sym) return i;\n  }\n  if (s->irep->slen >= s->scapa) {\n    s->scapa *= 2;\n    if (s->scapa > 0xffff) {\n      codegen_error(s, \"too many symbols\");\n    }\n    s->syms = (mrb_sym*)codegen_realloc(s, s->syms, sizeof(mrb_sym)*s->scapa);\n  }\n  s->syms[s->irep->slen] = sym;\n  return s->irep->slen++;\n}\n\nstatic void\ngen_setxv(codegen_scope *s, uint8_t op, uint16_t dst, mrb_sym sym, int val)\n{\n  int idx = new_sym(s, sym);\n  if (!val && !no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    if (data.insn == OP_MOVE && data.a == dst) {\n      dst = data.b;\n      rewind_pc(s);\n    }\n  }\n  genop_2(s, op, dst, idx);\n}\n\nstatic void\ngen_int(codegen_scope *s, uint16_t dst, mrb_int i)\n{\n  if (i < 0) {\n    if (i == -1) genop_1(s, OP_LOADI__1, dst);\n    else if (i >= -0xff) genop_2(s, OP_LOADINEG, dst, (uint16_t)-i);\n    else if (i >= INT16_MIN) genop_2S(s, OP_LOADI16, dst, (uint16_t)i);\n    else if (i >= INT32_MIN) genop_2SS(s, OP_LOADI32, dst, (uint32_t)i);\n    else goto int_lit;\n  }\n  else if (i < 8) genop_1(s, OP_LOADI_0 + (uint8_t)i, dst);\n  else if (i <= 0xff) genop_2(s, OP_LOADI, dst, (uint16_t)i);\n  else if (i <= INT16_MAX) genop_2S(s, OP_LOADI16, dst, (uint16_t)i);\n  else if (i <= INT32_MAX) genop_2SS(s, OP_LOADI32, dst, (uint32_t)i);\n  else {\n  int_lit:\n    genop_2(s, OP_LOADL, dst, new_lit(s, mrb_int_value(s->mrb, i)));\n  }\n}\n\nstatic mrb_bool\ngen_uniop(codegen_scope *s, mrb_sym sym, uint16_t dst)\n{\n  if (no_peephole(s)) return FALSE;\n  struct mrb_insn_data data = mrb_last_insn(s);\n  mrb_int n;\n\n  if (!get_int_operand(s, &data, &n)) return FALSE;\n  if (sym == MRB_OPSYM_2(s->mrb, plus)) {\n    /* unary plus does nothing */\n  }\n  else if (sym == MRB_OPSYM_2(s->mrb, minus)) {\n    if (n == MRB_INT_MIN) return FALSE;\n    n = -n;\n  }\n  else if (sym == MRB_OPSYM_2(s->mrb, neg)) {\n    n = ~n;\n  }\n  else {\n    return FALSE;\n  }\n  s->pc = addr_pc(s, data.addr);\n  gen_int(s, dst, n);\n  return TRUE;\n}\n\nstatic int\nnode_len(node *tree)\n{\n  int n = 0;\n\n  while (tree) {\n    n++;\n    tree = tree->cdr;\n  }\n  return n;\n}\n\n#define nint(x) ((int)(intptr_t)(x))\n#define nchar(x) ((char)(intptr_t)(x))\n#define nsym(x) ((mrb_sym)(intptr_t)(x))\n\n#define lv_name(lv) nsym((lv)->car)\n\nstatic int\nlv_idx(codegen_scope *s, mrb_sym id)\n{\n  node *lv = s->lv;\n  int n = 1;\n\n  while (lv) {\n    if (lv_name(lv) == id) return n;\n    n++;\n    lv = lv->cdr;\n  }\n  return 0;\n}\n\nstatic int\nsearch_upvar(codegen_scope *s, mrb_sym id, int *idx)\n{\n  const struct RProc *u;\n  int lv = 0;\n  codegen_scope *up = s->prev;\n\n  while (up) {\n    *idx = lv_idx(up, id);\n    if (*idx > 0) {\n      return lv;\n    }\n    lv ++;\n    up = up->prev;\n  }\n\n  if (lv < 1) lv = 1;\n  u = s->parser->upper;\n  while (u && !MRB_PROC_CFUNC_P(u)) {\n    const struct mrb_irep *ir = u->body.irep;\n    uint_fast16_t n = ir->nlocals;\n    int i;\n\n    const mrb_sym *v = ir->lv;\n    if (v) {\n      for (i=1; n > 1; n--, v++, i++) {\n        if (*v == id) {\n          *idx = i;\n          return lv - 1;\n        }\n      }\n    }\n    if (MRB_PROC_SCOPE_P(u)) break;\n    u = u->upper;\n    lv ++;\n  }\n\n  codegen_error(s, \"Can't found local variables\");\n  return -1; /* not reached */\n}\n\nstatic void\nfor_body(codegen_scope *s, node *tree)\n{\n  codegen_scope *prev = s;\n  int idx;\n  struct loopinfo *lp;\n  node *n2;\n\n  /* generate receiver */\n  codegen(s, tree->cdr->car, VAL);\n  /* generate loop-block */\n  s = scope_new(s->mrb, s, NULL);\n\n  push();                       /* push for a block parameter */\n\n  /* generate loop variable */\n  n2 = tree->car;\n  genop_W(s, OP_ENTER, 0x40000);\n  if (n2->car && !n2->car->cdr && !n2->cdr) {\n    gen_assignment(s, n2->car->car, NULL, 1, NOVAL);\n  }\n  else {\n    gen_vmassignment(s, n2, 1, VAL);\n  }\n  /* construct loop */\n  lp = loop_push(s, LOOP_FOR);\n  lp->pc1 = new_label(s);\n\n  /* loop body */\n  codegen(s, tree->cdr->cdr->car, VAL);\n  pop();\n  gen_return(s, OP_RETURN, cursp());\n  loop_pop(s, NOVAL);\n  scope_finish(s);\n  s = prev;\n  genop_2(s, OP_BLOCK, cursp(), s->irep->rlen-1);\n  push();pop(); /* space for a block */\n  pop();\n  idx = new_sym(s, MRB_SYM_2(s->mrb, each));\n  genop_3(s, OP_SENDB, cursp(), idx, 0);\n}\n\nstatic int\nlambda_body(codegen_scope *s, node *tree, int blk)\n{\n  codegen_scope *parent = s;\n  s = scope_new(s->mrb, s, tree->car);\n\n  s->mscope = !blk;\n\n  if (blk) {\n    struct loopinfo *lp = loop_push(s, LOOP_BLOCK);\n    lp->pc0 = new_label(s);\n  }\n  tree = tree->cdr;\n  if (tree->car == NULL) {\n    genop_W(s, OP_ENTER, 0);\n    s->ainfo = 0;\n  }\n  else {\n    mrb_aspec a;\n    int ma, oa, ra, pa, ka, kd, ba, i;\n    uint32_t pos;\n    node *opt;\n    node *margs, *pargs;\n    node *tail;\n\n    /* mandatory arguments */\n    ma = node_len(tree->car->car);\n    margs = tree->car->car;\n    tail = tree->car->cdr->cdr->cdr->cdr;\n\n    /* optional arguments */\n    oa = node_len(tree->car->cdr->car);\n    /* rest argument? */\n    ra = tree->car->cdr->cdr->car ? 1 : 0;\n    /* mandatory arguments after rest argument */\n    pa = node_len(tree->car->cdr->cdr->cdr->car);\n    pargs = tree->car->cdr->cdr->cdr->car;\n    /* keyword arguments */\n    ka = tail? node_len(tail->cdr->car) : 0;\n    /* keyword dictionary? */\n    kd = tail && tail->cdr->cdr->car? 1 : 0;\n    /* block argument? */\n    ba = tail && tail->cdr->cdr->cdr->car ? 1 : 0;\n\n    if (ma > 0x1f || oa > 0x1f || pa > 0x1f || ka > 0x1f) {\n      codegen_error(s, \"too many formal arguments\");\n    }\n    /* (23bits = 5:5:1:5:5:1:1) */\n    a = MRB_ARGS_REQ(ma)\n      | MRB_ARGS_OPT(oa)\n      | (ra? MRB_ARGS_REST() : 0)\n      | MRB_ARGS_POST(pa)\n      | MRB_ARGS_KEY(ka, kd)\n      | (ba? MRB_ARGS_BLOCK() : 0);\n    genop_W(s, OP_ENTER, a);\n    /* (12bits = 5:1:5:1) */\n    s->ainfo = (((ma+oa) & 0x3f) << 7)\n      | ((ra & 0x1) << 6)\n      | ((pa & 0x1f) << 1)\n      | ((ka | kd) ? 1 : 0);\n    /* generate jump table for optional arguments initializer */\n    pos = new_label(s);\n    for (i=0; i<oa; i++) {\n      new_label(s);\n      genjmp_0(s, OP_JMP);\n    }\n    if (oa > 0) {\n      genjmp_0(s, OP_JMP);\n    }\n    opt = tree->car->cdr->car;\n    i = 0;\n    while (opt) {\n      int idx;\n      mrb_sym id = nsym(opt->car->car);\n\n      dispatch(s, pos+i*3+1);\n      codegen(s, opt->car->cdr, VAL);\n      pop();\n      idx = lv_idx(s, id);\n      if (idx > 0) {\n        gen_move(s, idx, cursp(), 0);\n      }\n      else {\n        gen_getupvar(s, cursp(), id);\n      }\n      i++;\n      opt = opt->cdr;\n    }\n    if (oa > 0) {\n      dispatch(s, pos+i*3+1);\n    }\n\n    /* keyword arguments */\n    if (tail) {\n      node *kwds = tail->cdr->car;\n      int kwrest = 0;\n\n      if (tail->cdr->cdr->car) {\n        kwrest = 1;\n      }\n      mrb_assert(nint(tail->car) == NODE_ARGS_TAIL);\n      mrb_assert(node_len(tail) == 4);\n\n      while (kwds) {\n        int jmpif_key_p, jmp_def_set = -1;\n        node *kwd = kwds->car, *def_arg = kwd->cdr->cdr->car;\n        mrb_sym kwd_sym = nsym(kwd->cdr->car);\n\n        mrb_assert(nint(kwd->car) == NODE_KW_ARG);\n\n        if (def_arg) {\n          int idx;\n          genop_2(s, OP_KEY_P, lv_idx(s, kwd_sym), new_sym(s, kwd_sym));\n          jmpif_key_p = genjmp2_0(s, OP_JMPIF, lv_idx(s, kwd_sym), NOVAL);\n          codegen(s, def_arg, VAL);\n          pop();\n          idx = lv_idx(s, kwd_sym);\n          if (idx > 0) {\n            gen_move(s, idx, cursp(), 0);\n          }\n          else {\n            gen_getupvar(s, cursp(), kwd_sym);\n          }\n          jmp_def_set = genjmp_0(s, OP_JMP);\n          dispatch(s, jmpif_key_p);\n        }\n        genop_2(s, OP_KARG, lv_idx(s, kwd_sym), new_sym(s, kwd_sym));\n        if (jmp_def_set != -1) {\n          dispatch(s, jmp_def_set);\n        }\n        i++;\n\n        kwds = kwds->cdr;\n      }\n      if (tail->cdr->car && !kwrest) {\n        genop_0(s, OP_KEYEND);\n      }\n    }\n\n    /* argument destructuring */\n    if (margs) {\n      node *n = margs;\n\n      pos = 1;\n      while (n) {\n        if (nint(n->car->car) == NODE_MASGN) {\n          gen_vmassignment(s, n->car->cdr->car, pos, NOVAL);\n        }\n        pos++;\n        n = n->cdr;\n      }\n    }\n    if (pargs) {\n      node *n = pargs;\n\n      pos = ma+oa+ra+1;\n      while (n) {\n        if (nint(n->car->car) == NODE_MASGN) {\n          gen_vmassignment(s, n->car->cdr->car, pos, NOVAL);\n        }\n        pos++;\n        n = n->cdr;\n      }\n    }\n  }\n\n  codegen(s, tree->cdr->car, VAL);\n  pop();\n  if (s->pc > 0) {\n    gen_return(s, OP_RETURN, cursp());\n  }\n  if (blk) {\n    loop_pop(s, NOVAL);\n  }\n  scope_finish(s);\n  return parent->irep->rlen - 1;\n}\n\nstatic int\nscope_body(codegen_scope *s, node *tree, int val)\n{\n  codegen_scope *scope = scope_new(s->mrb, s, tree->car);\n\n  codegen(scope, tree->cdr, VAL);\n  gen_return(scope, OP_RETURN, scope->sp-1);\n  if (!s->iseq) {\n    genop_0(scope, OP_STOP);\n  }\n  scope_finish(scope);\n  if (!s->irep) {\n    /* should not happen */\n    return 0;\n  }\n  return s->irep->rlen - 1;\n}\n\nstatic mrb_bool\nnosplat(node *t)\n{\n  while (t) {\n    if (nint(t->car->car) == NODE_SPLAT) return FALSE;\n    t = t->cdr;\n  }\n  return TRUE;\n}\n\nstatic mrb_sym\nattrsym(codegen_scope *s, mrb_sym a)\n{\n  const char *name;\n  mrb_int len;\n  char *name2;\n\n  name = mrb_sym_name_len(s->mrb, a, &len);\n  name2 = (char *)codegen_palloc(s,\n                                 (size_t)len\n                                 + 1 /* '=' */\n                                 + 1 /* '\\0' */\n                                 );\n  mrb_assert_int_fit(mrb_int, len, size_t, SIZE_MAX);\n  memcpy(name2, name, (size_t)len);\n  name2[len] = '=';\n  name2[len+1] = '\\0';\n\n  return mrb_intern(s->mrb, name2, len+1);\n}\n\n#define CALL_MAXARGS 15\n#define GEN_LIT_ARY_MAX 64\n#define GEN_VAL_STACK_MAX 99\n\nstatic int\ngen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n\n    if (is_splat || cursp() >= slimit) { /* flush stack */\n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  /* variable length */\n  }\n  else if (n > limit) {\n    pop_n(n);\n    genop_2(s, OP_ARRAY, cursp(), n);\n    return -1;\n  }\n  return n;\n}\n\nstatic int\ngen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  mrb_bool first = TRUE;\n\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (val && first) {\n        genop_2(s, OP_HASH, cursp(), 0);\n        push();\n        update = TRUE;\n      }\n      else if (val && len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (val && (len > 0 || update)) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n    first = FALSE;\n  }\n  if (val && len > limit) {\n    pop_n(len*2);\n    genop_2(s, OP_HASH, cursp(), len);\n    push();\n    return -1;\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  /* variable length */\n  }\n  return len;\n}\n\nstatic void\ngen_call(codegen_scope *s, node *tree, int val, int safe)\n{\n  mrb_sym sym = nsym(tree->cdr->car);\n  int skip = 0, n = 0, nk = 0, noop = 0, noself = 0, blk = 0, sp_save = cursp();\n\n  if (!tree->car) {\n    noself = noop = 1;\n    push();\n  }\n  else {\n    codegen(s, tree->car, VAL); /* receiver */\n  }\n  if (safe) {\n    int recv = cursp()-1;\n    gen_move(s, cursp(), recv, 1);\n    skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n  }\n  tree = tree->cdr->cdr->car;\n  if (tree) {\n    if (tree->car) {            /* positional arguments */\n      n = gen_values(s, tree->car, VAL, 14);\n      if (n < 0) {              /* variable length */\n        noop = 1;               /* not operator */\n        n = 15;\n        push();\n      }\n    }\n    if (tree->cdr->car) {       /* keyword arguments */\n      noop = 1;\n      nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n      if (nk < 0) nk = 15;\n    }\n  }\n  if (tree && tree->cdr && tree->cdr->cdr) {\n    codegen(s, tree->cdr->cdr, VAL);\n    pop();\n    noop = 1;\n    blk = 1;\n  }\n  push();pop();\n  s->sp = sp_save;\n  if (!noop && sym == MRB_OPSYM_2(s->mrb, add) && n == 1)  {\n    gen_addsub(s, OP_ADD, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, sub) && n == 1)  {\n    gen_addsub(s, OP_SUB, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, mul) && n == 1)  {\n    gen_muldiv(s, OP_MUL, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, div) && n == 1)  {\n    gen_muldiv(s, OP_DIV, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, lt) && n == 1)  {\n    genop_1(s, OP_LT, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, le) && n == 1)  {\n    genop_1(s, OP_LE, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, gt) && n == 1)  {\n    genop_1(s, OP_GT, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, ge) && n == 1)  {\n    genop_1(s, OP_GE, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, eq) && n == 1)  {\n    genop_1(s, OP_EQ, cursp());\n  }\n  else if (!noop && sym == MRB_OPSYM_2(s->mrb, aset) && n == 2)  {\n    genop_1(s, OP_SETIDX, cursp());\n  }\n  else if (!noop && n == 0 && gen_uniop(s, sym, cursp())) {\n    /* constant folding succeeded */\n  }\n  else if (!noop && n == 1 && gen_binop(s, sym, cursp())) {\n    /* constant folding succeeded */\n  }\n  else if (noself){\n    genop_3(s, blk ? OP_SSENDB : OP_SSEND, cursp(), new_sym(s, sym), n|(nk<<4));\n  }\n  else {\n    genop_3(s, blk ? OP_SENDB : OP_SEND, cursp(), new_sym(s, sym), n|(nk<<4));\n  }\n  if (safe) {\n    dispatch(s, skip);\n  }\n  if (val) {\n    push();\n  }\n}\n\nstatic void\ngen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}\n\nstatic void\ngen_vmassignment(codegen_scope *s, node *tree, int rhs, int val)\n{\n  int n = 0, post = 0;\n  node *t, *p;\n\n  if (tree->car) {              /* pre */\n    t = tree->car;\n    n = 0;\n    while (t) {\n      int sp = cursp();\n\n      genop_3(s, OP_AREF, sp, rhs, n);\n      push();\n      gen_assignment(s, t->car, NULL, sp, NOVAL);\n      pop();\n      n++;\n      t = t->cdr;\n    }\n  }\n  t = tree->cdr;\n  if (t) {\n    if (t->cdr) {               /* post count */\n      p = t->cdr->car;\n      while (p) {\n        post++;\n        p = p->cdr;\n      }\n    }\n    gen_move(s, cursp(), rhs, val);\n    push_n(post+1);\n    pop_n(post+1);\n    genop_3(s, OP_APOST, cursp(), n, post);\n    n = 1;\n    if (t->car && t->car != (node*)-1) { /* rest */\n      gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n    }\n    if (t->cdr && t->cdr->car) {\n      t = t->cdr->car;\n      while (t) {\n        gen_assignment(s, t->car, NULL, cursp()+n, NOVAL);\n        t = t->cdr;\n        n++;\n      }\n    }\n    if (val) {\n      gen_move(s, cursp(), rhs, 0);\n    }\n  }\n}\n\nstatic void\ngen_intern(codegen_scope *s)\n{\n  pop();\n  if (!no_peephole(s)) {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    if (data.insn == OP_STRING && data.a == cursp()) {\n      rewind_pc(s);\n      genop_2(s, OP_SYMBOL, data.a, data.b);\n      push();\n      return;\n    }\n  }\n  genop_1(s, OP_INTERN, cursp());\n  push();\n}\n\nstatic void\ngen_literal_array(codegen_scope *s, node *tree, mrb_bool sym, int val)\n{\n  if (val) {\n    int i = 0, j = 0, gen = 0;\n\n    while (tree) {\n      switch (nint(tree->car->car)) {\n      case NODE_STR:\n        if ((tree->cdr == NULL) && (nint(tree->car->cdr->cdr) == 0))\n          break;\n        /* fall through */\n      case NODE_BEGIN:\n        codegen(s, tree->car, VAL);\n        ++j;\n        break;\n\n      case NODE_LITERAL_DELIM:\n        if (j > 0) {\n          j = 0;\n          ++i;\n          if (sym)\n            gen_intern(s);\n        }\n        break;\n      }\n      while (j >= 2) {\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        j--;\n      }\n      if (i > GEN_LIT_ARY_MAX) {\n        pop_n(i);\n        if (gen) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), i);\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), i);\n          gen = 1;\n        }\n        push();\n        i = 0;\n      }\n      tree = tree->cdr;\n    }\n    if (j > 0) {\n      ++i;\n      if (sym)\n        gen_intern(s);\n    }\n    pop_n(i);\n    if (gen) {\n      pop();\n      genop_2(s, OP_ARYPUSH, cursp(), i);\n    }\n    else {\n      genop_2(s, OP_ARRAY, cursp(), i);\n    }\n    push();\n  }\n  else {\n    while (tree) {\n      switch (nint(tree->car->car)) {\n      case NODE_BEGIN: case NODE_BLOCK:\n        codegen(s, tree->car, NOVAL);\n      }\n      tree = tree->cdr;\n    }\n  }\n}\n\nstatic void\nraise_error(codegen_scope *s, const char *msg)\n{\n  int idx = new_lit(s, mrb_str_new_cstr(s->mrb, msg));\n\n  genop_1(s, OP_ERR, idx);\n}\n\nstatic mrb_int\nreadint(codegen_scope *s, const char *p, int base, mrb_bool neg, mrb_bool *overflow)\n{\n  const char *e = p + strlen(p);\n  mrb_int result = 0;\n\n  mrb_assert(base >= 2 && base <= 16);\n  if (*p == '+') p++;\n  while (p < e) {\n    int n;\n    char c = *p;\n    switch (c) {\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n      n = c - '0'; break;\n    case '8': case '9':\n      n = c - '0'; break;\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      n = c - 'a' + 10; break;\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n      n = c - 'A' + 10; break;\n    default:\n      codegen_error(s, \"malformed readint input\");\n      *overflow = TRUE;\n      /* not reached */\n      return result;\n    }\n    if (mrb_int_mul_overflow(result, base, &result)) {\n    overflow:\n      *overflow = TRUE;\n      return 0;\n    }\n    mrb_uint tmp = ((mrb_uint)result)+n;\n    if (neg && tmp == (mrb_uint)MRB_INT_MAX+1) {\n      *overflow = FALSE;\n      return MRB_INT_MIN;\n    }\n    if (tmp > MRB_INT_MAX) goto overflow;\n    result = (mrb_int)tmp;\n    p++;\n  }\n  *overflow = FALSE;\n  if (neg) return -result;\n  return result;\n}\n\nstatic void\ngen_retval(codegen_scope *s, node *tree)\n{\n  if (nint(tree->car) == NODE_SPLAT) {\n    codegen(s, tree, VAL);\n    pop();\n    genop_1(s, OP_ARYDUP, cursp());\n  }\n  else {\n    codegen(s, tree, VAL);\n    pop();\n  }\n}\n\nstatic mrb_bool\ntrue_always(node *tree)\n{\n  switch (nint(tree->car)) {\n  case NODE_TRUE:\n  case NODE_INT:\n  case NODE_STR:\n  case NODE_SYM:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic mrb_bool\nfalse_always(node *tree)\n{\n  switch (nint(tree->car)) {\n  case NODE_FALSE:\n  case NODE_NIL:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}\n\nstatic void\ngen_blkmove(codegen_scope *s, uint16_t ainfo, int lv)\n{\n  int m1 = (ainfo>>7)&0x3f;\n  int r  = (ainfo>>6)&0x1;\n  int m2 = (ainfo>>1)&0x1f;\n  int kd = (ainfo)&0x1;\n  int off = m1+r+m2+kd+1;\n  if (lv == 0) {\n    gen_move(s, cursp(), off, 0);\n  }\n  else {\n    genop_3(s, OP_GETUPVAR, cursp(), off, lv);\n  }\n  push();\n}\n\nstatic void\ncodegen(codegen_scope *s, node *tree, int val)\n{\n  int nt;\n  int rlev = s->rlev;\n\n  if (!tree) {\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    return;\n  }\n\n  s->rlev++;\n  if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n    codegen_error(s, \"too complex expression\");\n  }\n  if (s->irep && s->filename_index != tree->filename_index) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n    s->debug_start_pos = s->pc;\n    s->filename_index = tree->filename_index;\n    s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n  }\n\n  nt = nint(tree->car);\n  s->lineno = tree->lineno;\n  tree = tree->cdr;\n  switch (nt) {\n  case NODE_BEGIN:\n    if (val && !tree) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    while (tree) {\n      codegen(s, tree->car, tree->cdr ? NOVAL : val);\n      tree = tree->cdr;\n    }\n    break;\n\n  case NODE_RESCUE:\n    {\n      int noexc;\n      uint32_t exend, pos1, pos2, tmp;\n      struct loopinfo *lp;\n      int catch_entry, begin, end;\n\n      if (tree->car == NULL) goto exit;\n      lp = loop_push(s, LOOP_BEGIN);\n      lp->pc0 = new_label(s);\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, VAL);\n      pop();\n      lp->type = LOOP_RESCUE;\n      end = s->pc;\n      noexc = genjmp_0(s, OP_JMP);\n      catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n      tree = tree->cdr;\n      exend = JMPLINK_START;\n      pos1 = JMPLINK_START;\n      if (tree->car) {\n        node *n2 = tree->car;\n        int exc = cursp();\n\n        genop_1(s, OP_EXCEPT, exc);\n        push();\n        while (n2) {\n          node *n3 = n2->car;\n          node *n4 = n3->car;\n\n          dispatch(s, pos1);\n          pos2 = JMPLINK_START;\n          do {\n            if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n              codegen(s, n4->car, VAL);\n              gen_move(s, cursp(), exc, 0);\n              push_n(2); pop_n(2); /* space for one arg and a block */\n              pop();\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              if (n4) {\n                codegen(s, n4->car, VAL);\n              }\n              else {\n                genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                push();\n              }\n              pop();\n              genop_2(s, OP_RESCUE, exc, cursp());\n            }\n            tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n            pos2 = tmp;\n            if (n4) {\n              n4 = n4->cdr;\n            }\n          } while (n4);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n\n          pop();\n          if (n3->cdr->car) {\n            gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n          }\n          if (n3->cdr->cdr->car) {\n            codegen(s, n3->cdr->cdr->car, val);\n            if (val) pop();\n          }\n          tmp = genjmp(s, OP_JMP, exend);\n          exend = tmp;\n          n2 = n2->cdr;\n          push();\n        }\n        if (pos1 != JMPLINK_START) {\n          dispatch(s, pos1);\n          genop_1(s, OP_RAISEIF, exc);\n        }\n      }\n      pop();\n      tree = tree->cdr;\n      dispatch(s, noexc);\n      if (tree->car) {\n        codegen(s, tree->car, val);\n      }\n      else if (val) {\n        push();\n      }\n      dispatch_linked(s, exend);\n      loop_pop(s, NOVAL);\n    }\n    break;\n\n  case NODE_ENSURE:\n    if (!tree->cdr || !tree->cdr->cdr ||\n        (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n         tree->cdr->cdr->cdr)) {\n      int catch_entry, begin, end, target;\n      int idx;\n\n      catch_entry = catch_handler_new(s);\n      begin = s->pc;\n      codegen(s, tree->car, val);\n      end = target = s->pc;\n      push();\n      idx = cursp();\n      genop_1(s, OP_EXCEPT, idx);\n      push();\n      codegen(s, tree->cdr->cdr, NOVAL);\n      pop();\n      genop_1(s, OP_RAISEIF, idx);\n      pop();\n      catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n    }\n    else {                      /* empty ensure ignored */\n      codegen(s, tree->car, val);\n    }\n    break;\n\n  case NODE_LAMBDA:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_LAMBDA, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_BLOCK:\n    if (val) {\n      int idx = lambda_body(s, tree, 1);\n\n      genop_2(s, OP_BLOCK, cursp(), idx);\n      push();\n    }\n    break;\n\n  case NODE_IF:\n    {\n      uint32_t pos1, pos2;\n      mrb_bool nil_p = FALSE;\n      node *elsepart = tree->cdr->cdr->car;\n\n      if (!tree->car) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, elsepart, val);\n        goto exit;\n      }\n      if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        mrb_sym mid = nsym(n->cdr->car);\n        mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n        if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n          nil_p = TRUE;\n          codegen(s, n->car, VAL);\n        }\n      }\n      if (!nil_p) {\n        codegen(s, tree->car, VAL);\n      }\n      pop();\n      if (val || tree->cdr->car) {\n        if (nil_p) {\n          pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos2);\n        }\n        else {\n          pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->car, val);\n        if (val) pop();\n        if (elsepart || val) {\n          pos2 = genjmp_0(s, OP_JMP);\n          dispatch(s, pos1);\n          codegen(s, elsepart, val);\n          dispatch(s, pos2);\n        }\n        else {\n          dispatch(s, pos1);\n        }\n      }\n      else {                    /* empty then-part */\n        if (elsepart) {\n          if (nil_p) {\n            pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n          }\n          else {\n            pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n          }\n          codegen(s, elsepart, val);\n          dispatch(s, pos1);\n        }\n        else if (val && !nil_p) {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n    }\n    break;\n\n  case NODE_AND:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_OR:\n    {\n      uint32_t pos;\n\n      if (true_always(tree->car)) {\n        codegen(s, tree->car, val);\n        goto exit;\n      }\n      if (false_always(tree->car)) {\n        codegen(s, tree->cdr, val);\n        goto exit;\n      }\n      codegen(s, tree->car, VAL);\n      pop();\n      pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n      codegen(s, tree->cdr, val);\n      dispatch(s, pos);\n    }\n    break;\n\n  case NODE_WHILE:\n  case NODE_UNTIL:\n    {\n      if (true_always(tree->car)) {\n        if (nt == NODE_UNTIL) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n      else if (false_always(tree->car)) {\n        if (nt == NODE_WHILE) {\n          if (val) {\n            genop_1(s, OP_LOADNIL, cursp());\n            push();\n          }\n          goto exit;\n        }\n      }\n\n      uint32_t pos = JMPLINK_START;\n      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n\n      if (!val) lp->reg = -1;\n      lp->pc0 = new_label(s);\n      codegen(s, tree->car, VAL);\n      pop();\n      if (nt == NODE_WHILE) {\n        pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n      }\n      else {\n        pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n      }\n      lp->pc1 = new_label(s);\n      codegen(s, tree->cdr, NOVAL);\n      genjmp(s, OP_JMP, lp->pc0);\n      dispatch(s, pos);\n      loop_pop(s, val);\n    }\n    break;\n\n  case NODE_FOR:\n    for_body(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_CASE:\n    {\n      int head = 0;\n      uint32_t pos1, pos2, pos3, tmp;\n      node *n;\n\n      pos3 = JMPLINK_START;\n      if (tree->car) {\n        head = cursp();\n        codegen(s, tree->car, VAL);\n      }\n      tree = tree->cdr;\n      while (tree) {\n        n = tree->car->car;\n        pos1 = pos2 = JMPLINK_START;\n        while (n) {\n          codegen(s, n->car, VAL);\n          if (head) {\n            gen_move(s, cursp(), head, 0);\n            push(); push(); pop(); pop(); pop();\n            if (nint(n->car->car) == NODE_SPLAT) {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n            }\n            else {\n              genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n            }\n          }\n          else {\n            pop();\n          }\n          tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n          pos2 = tmp;\n          n = n->cdr;\n        }\n        if (tree->car->car) {\n          pos1 = genjmp_0(s, OP_JMP);\n          dispatch_linked(s, pos2);\n        }\n        codegen(s, tree->car->cdr, val);\n        if (val) pop();\n        tmp = genjmp(s, OP_JMP, pos3);\n        pos3 = tmp;\n        dispatch(s, pos1);\n        tree = tree->cdr;\n      }\n      if (val) {\n        uint32_t pos = cursp();\n        genop_1(s, OP_LOADNIL, cursp());\n        if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n        if (head) pop();\n        if (cursp() != pos) {\n          gen_move(s, cursp(), pos, 0);\n        }\n        push();\n      }\n      else {\n        if (pos3 != JMPLINK_START) {\n          dispatch_linked(s, pos3);\n        }\n        if (head) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_SCOPE:\n    scope_body(s, tree, NOVAL);\n    break;\n\n  case NODE_FCALL:\n  case NODE_CALL:\n    gen_call(s, tree, val, 0);\n    break;\n  case NODE_SCALL:\n    gen_call(s, tree, val, 1);\n    break;\n\n  case NODE_DOT2:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_INC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_DOT3:\n    codegen(s, tree->car, val);\n    codegen(s, tree->cdr, val);\n    if (val) {\n      pop(); pop();\n      genop_1(s, OP_RANGE_EXC, cursp());\n      push();\n    }\n    break;\n\n  case NODE_COLON2:\n    {\n      int sym = new_sym(s, nsym(tree->cdr));\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_COLON3:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ARRAY:\n    {\n      int n;\n\n      n = gen_values(s, tree, val, 0);\n      if (val) {\n        if (n >= 0) {\n          pop_n(n);\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n      }\n    }\n    break;\n\n  case NODE_HASH:\n  case NODE_KW_HASH:\n    {\n      int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n      if (val && nk >= 0) {\n        pop_n(nk*2);\n        genop_2(s, OP_HASH, cursp(), nk);\n        push();\n      }\n    }\n    break;\n\n  case NODE_SPLAT:\n    codegen(s, tree, val);\n    break;\n\n  case NODE_ASGN:\n    gen_assignment(s, tree->car, tree->cdr, 0, val);\n    break;\n\n  case NODE_MASGN:\n    {\n      int len = 0, n = 0, post = 0;\n      node *t = tree->cdr, *p;\n      int rhs = cursp();\n\n      if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n        /* fixed rhs */\n        t = t->cdr;\n        while (t) {\n          codegen(s, t->car, VAL);\n          len++;\n          t = t->cdr;\n        }\n        tree = tree->car;\n        if (tree->car) {                /* pre */\n          t = tree->car;\n          n = 0;\n          while (t) {\n            if (n < len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              n++;\n            }\n            else {\n              genop_1(s, OP_LOADNIL, rhs+n);\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n            }\n            t = t->cdr;\n          }\n        }\n        t = tree->cdr;\n        if (t) {\n          if (t->cdr) {         /* post count */\n            p = t->cdr->car;\n            while (p) {\n              post++;\n              p = p->cdr;\n            }\n          }\n          if (t->car) {         /* rest (len - pre - post) */\n            int rn;\n\n            if (len < post + n) {\n              rn = 0;\n            }\n            else {\n              rn = len - post - n;\n            }\n            genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n            gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n            n += rn;\n          }\n          if (t->cdr && t->cdr->car) {\n            t = t->cdr->car;\n            while (n<len) {\n              gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n              t = t->cdr;\n              n++;\n            }\n          }\n        }\n        pop_n(len);\n        if (val) {\n          genop_2(s, OP_ARRAY, rhs, len);\n          push();\n        }\n      }\n      else {\n        /* variable rhs */\n        codegen(s, t, VAL);\n        gen_vmassignment(s, tree->car, rhs, val);\n        if (!val) {\n          pop();\n        }\n      }\n    }\n    break;\n\n  case NODE_OP_ASGN:\n    {\n      mrb_sym sym = nsym(tree->cdr->car);\n      mrb_int len;\n      const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n      int idx, callargs = -1, vsp = -1;\n\n      if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n          (nint(tree->car->car) == NODE_CONST ||\n           nint(tree->car->car) == NODE_CVAR)) {\n        int catch_entry, begin, end;\n        int noexc, exc;\n        struct loopinfo *lp;\n\n        lp = loop_push(s, LOOP_BEGIN);\n        lp->pc0 = new_label(s);\n        catch_entry = catch_handler_new(s);\n        begin = s->pc;\n        exc = cursp();\n        codegen(s, tree->car, VAL);\n        end = s->pc;\n        noexc = genjmp_0(s, OP_JMP);\n        lp->type = LOOP_RESCUE;\n        catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n        genop_1(s, OP_EXCEPT, exc);\n        genop_1(s, OP_LOADF, exc);\n        dispatch(s, noexc);\n        loop_pop(s, NOVAL);\n      }\n      else if (nint(tree->car->car) == NODE_CALL) {\n        node *n = tree->car->cdr;\n        int base, i, nargs = 0;\n        callargs = 0;\n\n        if (val) {\n          vsp = cursp();\n          push();\n        }\n        codegen(s, n->car, VAL);   /* receiver */\n        idx = new_sym(s, nsym(n->cdr->car));\n        base = cursp()-1;\n        if (n->cdr->cdr->car) {\n          nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n          if (nargs >= 0) {\n            callargs = nargs;\n          }\n          else { /* varargs */\n            push();\n            nargs = 1;\n            callargs = CALL_MAXARGS;\n          }\n        }\n        /* copy receiver and arguments */\n        gen_move(s, cursp(), base, 1);\n        for (i=0; i<nargs; i++) {\n          gen_move(s, cursp()+i+1, base+i+1, 1);\n        }\n        push_n(nargs+2);pop_n(nargs+2); /* space for receiver, arguments and a block */\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL);\n      }\n      if (len == 2 &&\n          ((name[0] == '|' && name[1] == '|') ||\n           (name[0] == '&' && name[1] == '&'))) {\n        uint32_t pos;\n\n        pop();\n        if (val) {\n          if (vsp >= 0) {\n            gen_move(s, vsp, cursp(), 1);\n          }\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        else {\n          pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n        }\n        codegen(s, tree->cdr->cdr->car, VAL);\n        pop();\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 1);\n        }\n        if (nint(tree->car->car) == NODE_CALL) {\n          if (callargs == CALL_MAXARGS) {\n            pop();\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          else {\n            pop_n(callargs);\n            callargs++;\n          }\n          pop();\n          idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n          genop_3(s, OP_SEND, cursp(), idx, callargs);\n        }\n        else {\n          gen_assignment(s, tree->car, NULL, cursp(), val);\n        }\n        dispatch(s, pos);\n        goto exit;\n      }\n      codegen(s, tree->cdr->cdr->car, VAL);\n      push(); pop();\n      pop(); pop();\n\n      if (len == 1 && name[0] == '+')  {\n        gen_addsub(s, OP_ADD, cursp());\n      }\n      else if (len == 1 && name[0] == '-')  {\n        gen_addsub(s, OP_SUB, cursp());\n      }\n      else if (len == 1 && name[0] == '*')  {\n        genop_1(s, OP_MUL, cursp());\n      }\n      else if (len == 1 && name[0] == '/')  {\n        genop_1(s, OP_DIV, cursp());\n      }\n      else if (len == 1 && name[0] == '<')  {\n        genop_1(s, OP_LT, cursp());\n      }\n      else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n        genop_1(s, OP_LE, cursp());\n      }\n      else if (len == 1 && name[0] == '>')  {\n        genop_1(s, OP_GT, cursp());\n      }\n      else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n        genop_1(s, OP_GE, cursp());\n      }\n      else {\n        idx = new_sym(s, sym);\n        genop_3(s, OP_SEND, cursp(), idx, 1);\n      }\n      if (callargs < 0) {\n        gen_assignment(s, tree->car, NULL, cursp(), val);\n      }\n      else {\n        if (val && vsp >= 0) {\n          gen_move(s, vsp, cursp(), 0);\n        }\n        if (callargs == CALL_MAXARGS) {\n          pop();\n          genop_2(s, OP_ARYPUSH, cursp(), 1);\n        }\n        else {\n          pop_n(callargs);\n          callargs++;\n        }\n        pop();\n        idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n        genop_3(s, OP_SEND, cursp(), idx, callargs);\n      }\n    }\n    break;\n\n  case NODE_SUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      int n = 0, nk = 0, st = 0;\n\n      push();\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (tree) {\n        node *args = tree->car;\n        if (args) {\n          st = n = gen_values(s, args, VAL, 14);\n          if (n < 0) {\n            st = 1; n = 15;\n            push();\n          }\n        }\n        /* keyword arguments */\n        if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n          nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n          if (nk < 0) {st++; nk = 15;}\n          else st += nk*2;\n          n |= nk<<4;\n        }\n        /* block arguments */\n        if (tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n      pop_n(st+1);\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_ZSUPER:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0;\n      uint16_t ainfo = 0;\n      int n = CALL_MAXARGS;\n      int sp = cursp();\n\n      push();        /* room for receiver */\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2 && s2->ainfo > 0) {\n        ainfo = s2->ainfo;\n      }\n      if (ainfo > 0) {\n        genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n        push(); push(); push();   /* ARGARY pushes 3 values at most */\n        pop(); pop(); pop();\n        /* keyword arguments */\n        if (ainfo & 0x1) {\n          n |= CALL_MAXARGS<<4;\n          push();\n        }\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          push();\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n      }\n      else {\n        /* block argument */\n        if (tree && tree->cdr && tree->cdr->cdr) {\n          codegen(s, tree->cdr->cdr, VAL);\n        }\n        else {\n          gen_blkmove(s, 0, lv);\n        }\n        n = 0;\n      }\n      s->sp = sp;\n      genop_2(s, OP_SUPER, cursp(), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_RETURN:\n    if (tree) {\n      gen_retval(s, tree);\n    }\n    else {\n      genop_1(s, OP_LOADNIL, cursp());\n    }\n    if (s->loop) {\n      gen_return(s, OP_RETURN_BLK, cursp());\n    }\n    else {\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_YIELD:\n    {\n      codegen_scope *s2 = s;\n      int lv = 0, ainfo = -1;\n      int n = 0, sendv = 0;\n\n      while (!s2->mscope) {\n        lv++;\n        s2 = s2->prev;\n        if (!s2) break;\n      }\n      if (s2) {\n        ainfo = (int)s2->ainfo;\n      }\n      if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n      push();\n      if (tree) {\n        n = gen_values(s, tree, VAL, 14);\n        if (n < 0) {\n          n = sendv = 1;\n          push();\n        }\n      }\n      push();pop(); /* space for a block */\n      pop_n(n+1);\n      genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n      if (sendv) n = CALL_MAXARGS;\n      genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BREAK:\n    loop_break(s, tree);\n    if (val) push();\n    break;\n\n  case NODE_NEXT:\n    if (!s->loop) {\n      raise_error(s, \"unexpected next\");\n    }\n    else if (s->loop->type == LOOP_NORMAL) {\n      codegen(s, tree, NOVAL);\n      genjmp(s, OP_JMPUW, s->loop->pc0);\n    }\n    else {\n      if (tree) {\n        codegen(s, tree, VAL);\n        pop();\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_RETURN, cursp());\n    }\n    if (val) push();\n    break;\n\n  case NODE_REDO:\n    if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n      raise_error(s, \"unexpected redo\");\n    }\n    else {\n      genjmp(s, OP_JMPUW, s->loop->pc1);\n    }\n    if (val) push();\n    break;\n\n  case NODE_RETRY:\n    {\n      const char *msg = \"unexpected retry\";\n      const struct loopinfo *lp = s->loop;\n\n      while (lp && lp->type != LOOP_RESCUE) {\n        lp = lp->prev;\n      }\n      if (!lp) {\n        raise_error(s, msg);\n      }\n      else {\n        genjmp(s, OP_JMPUW, lp->pc0);\n      }\n      if (val) push();\n    }\n    break;\n\n  case NODE_LVAR:\n    if (val) {\n      int idx = lv_idx(s, nsym(tree));\n\n      if (idx > 0) {\n        gen_move(s, cursp(), idx, val);\n      }\n      else {\n        gen_getupvar(s, cursp(), nsym(tree));\n      }\n      push();\n    }\n    break;\n\n  case NODE_NVAR:\n    if (val) {\n      int idx = nint(tree);\n\n      gen_move(s, cursp(), idx, val);\n\n      push();\n    }\n    break;\n\n  case NODE_GVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_IVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETIV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CVAR:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCV, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_CONST:\n    {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_GETCONST, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_BACK_REF:\n    if (val) {\n      char buf[] = {'$', nchar(tree)};\n      int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_NTH_REF:\n    if (val) {\n      mrb_state *mrb = s->mrb;\n      mrb_value str;\n      int sym;\n\n      str = mrb_format(mrb, \"$%d\", nint(tree));\n      sym = new_sym(s, mrb_intern_str(mrb, str));\n      genop_2(s, OP_GETGV, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_ARG:\n    /* should not happen */\n    break;\n\n  case NODE_BLOCK_ARG:\n    if (!tree) {\n      int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n\n      if (idx == 0) {\n        codegen_error(s, \"no anonymous block argument\");\n      }\n      gen_move(s, cursp(), idx, val);\n      if (val) push();\n    }\n    else {\n      codegen(s, tree, val);\n    }\n    break;\n\n  case NODE_INT:\n    if (val) {\n      char *p = (char*)tree->car;\n      int base = nint(tree->cdr->car);\n      mrb_int i;\n      mrb_bool overflow;\n\n      i = readint(s, p, base, FALSE, &overflow);\n      if (overflow) {\n        int off = new_litbn(s, p, base, FALSE);\n        genop_2(s, OP_LOADL, cursp(), off);\n      }\n      else {\n        gen_int(s, cursp(), i);\n      }\n      push();\n    }\n    break;\n\n#ifndef MRB_NO_FLOAT\n  case NODE_FLOAT:\n    if (val) {\n      char *p = (char*)tree;\n      mrb_float f = mrb_float_read(p, NULL);\n      int off = new_lit(s, mrb_float_value(s->mrb, f));\n\n      genop_2(s, OP_LOADL, cursp(), off);\n      push();\n    }\n    break;\n#endif\n\n  case NODE_NEGATE:\n    {\n      nt = nint(tree->car);\n      switch (nt) {\n#ifndef MRB_NO_FLOAT\n      case NODE_FLOAT:\n        if (val) {\n          char *p = (char*)tree->cdr;\n          mrb_float f = mrb_float_read(p, NULL);\n          int off = new_lit(s, mrb_float_value(s->mrb, -f));\n\n          genop_2(s, OP_LOADL, cursp(), off);\n          push();\n        }\n        break;\n#endif\n\n      case NODE_INT:\n        if (val) {\n          char *p = (char*)tree->cdr->car;\n          int base = nint(tree->cdr->cdr->car);\n          mrb_int i;\n          mrb_bool overflow;\n\n          i = readint(s, p, base, TRUE, &overflow);\n          if (overflow) {\n            int off = new_litbn(s, p, base, TRUE);\n            genop_2(s, OP_LOADL, cursp(), off);\n          }\n          else {\n            gen_int(s, cursp(), i);\n          }\n          push();\n        }\n        break;\n\n      default:\n        if (val) {\n          codegen(s, tree, VAL);\n          pop();\n          push_n(2);pop_n(2); /* space for receiver&block */\n          mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n          if (!gen_uniop(s, minus, cursp())) {\n            genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n          }\n          push();\n        }\n        else {\n          codegen(s, tree, NOVAL);\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_STR:\n    if (val) {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n\n      mrb_gc_arena_restore(s->mrb, ai);\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n    }\n    break;\n\n  case NODE_HEREDOC:\n    tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n    /* fall through */\n  case NODE_DSTR:\n    if (val) {\n      node *n = tree;\n\n      if (!n) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n        break;\n      }\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n    }\n    else {\n      node *n = tree;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_WORDS:\n    gen_literal_array(s, tree, FALSE, val);\n    break;\n\n  case NODE_SYMBOLS:\n    gen_literal_array(s, tree, TRUE, val);\n    break;\n\n  case NODE_DXSTR:\n    {\n      node *n;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      codegen(s, tree->car, VAL);\n      n = tree->cdr;\n      while (n) {\n        if (nint(n->car->car) == NODE_XSTR) {\n          n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n          mrb_assert(!n->cdr); /* must be the end */\n        }\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      push();                   /* for block */\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_XSTR:\n    {\n      char *p = (char*)tree->car;\n      size_t len = (intptr_t)tree->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n      int sym;\n\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push(); push();\n      pop_n(3);\n      sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick)); /* ` */\n      genop_3(s, OP_SEND, cursp(), sym, 1);\n      if (val) push();\n      mrb_gc_arena_restore(s->mrb, ai);\n    }\n    break;\n\n  case NODE_REGX:\n    if (val) {\n      char *p1 = (char*)tree->car;\n      char *p2 = (char*)tree->cdr->car;\n      char *p3 = (char*)tree->cdr->cdr;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n      int argc = 1;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      genop_2(s, OP_STRING, cursp(), off);\n      push();\n      if (p2 || p3) {\n        if (p2) { /* opt */\n          off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n          genop_2(s, OP_STRING, cursp(), off);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        push();\n        argc++;\n        if (p3) { /* enc */\n          off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n          genop_2(s, OP_STRING, cursp(), off);\n          push();\n          argc++;\n        }\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    break;\n\n  case NODE_DREGX:\n    if (val) {\n      node *n = tree->car;\n      int ai = mrb_gc_arena_save(s->mrb);\n      int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n      int argc = 1;\n      int off;\n      char *p;\n\n      genop_1(s, OP_OCLASS, cursp());\n      genop_2(s, OP_GETMCNST, cursp(), sym);\n      push();\n      codegen(s, n->car, VAL);\n      n = n->cdr;\n      while (n) {\n        codegen(s, n->car, VAL);\n        pop(); pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n        n = n->cdr;\n      }\n      n = tree->cdr->cdr;\n      if (n->car) { /* tail */\n        p = (char*)n->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n        codegen(s, tree->car, VAL);\n        genop_2(s, OP_STRING, cursp(), off);\n        pop();\n        genop_1(s, OP_STRCAT, cursp());\n        push();\n      }\n      if (n->cdr->car) { /* opt */\n        char *p2 = (char*)n->cdr->car;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      if (n->cdr->cdr) { /* enc */\n        char *p2 = (char*)n->cdr->cdr;\n        off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n        genop_2(s, OP_STRING, cursp(), off);\n        push();\n        argc++;\n      }\n      push(); /* space for a block */\n      pop_n(argc+2);\n      sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n      genop_3(s, OP_SEND, cursp(), sym, argc);\n      mrb_gc_arena_restore(s->mrb, ai);\n      push();\n    }\n    else {\n      node *n = tree->car;\n\n      while (n) {\n        if (nint(n->car->car) != NODE_STR) {\n          codegen(s, n->car, NOVAL);\n        }\n        n = n->cdr;\n      }\n    }\n    break;\n\n  case NODE_SYM:\n    if (val) {\n      int sym = new_sym(s, nsym(tree));\n\n      genop_2(s, OP_LOADSYM, cursp(), sym);\n      push();\n    }\n    break;\n\n  case NODE_DSYM:\n    codegen(s, tree, val);\n    if (val) {\n      gen_intern(s);\n    }\n    break;\n\n  case NODE_SELF:\n    if (val) {\n      genop_1(s, OP_LOADSELF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_NIL:\n    if (val) {\n      genop_1(s, OP_LOADNIL, cursp());\n      push();\n    }\n    break;\n\n  case NODE_TRUE:\n    if (val) {\n      genop_1(s, OP_LOADT, cursp());\n      push();\n    }\n    break;\n\n  case NODE_FALSE:\n    if (val) {\n      genop_1(s, OP_LOADF, cursp());\n      push();\n    }\n    break;\n\n  case NODE_ALIAS:\n    {\n      int a = new_sym(s, nsym(tree->car));\n      int b = new_sym(s, nsym(tree->cdr));\n\n      genop_2(s, OP_ALIAS, a, b);\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n   break;\n\n  case NODE_UNDEF:\n    {\n      node *t = tree;\n\n      while (t) {\n        int symbol = new_sym(s, nsym(t->car));\n        genop_1(s, OP_UNDEF, symbol);\n        t = t->cdr;\n      }\n      if (val) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n    }\n    break;\n\n  case NODE_CLASS:\n    {\n      int idx;\n      node *body;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      if (tree->cdr->car) {\n        codegen(s, tree->cdr->car, VAL);\n      }\n      else {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      pop(); pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_CLASS, cursp(), idx);\n      body = tree->cdr->cdr->car;\n      if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, body, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_MODULE:\n    {\n      int idx;\n\n      if (tree->car->car == (node*)0) {\n        genop_1(s, OP_LOADNIL, cursp());\n        push();\n      }\n      else if (tree->car->car == (node*)1) {\n        genop_1(s, OP_OCLASS, cursp());\n        push();\n      }\n      else {\n        codegen(s, tree->car->car, VAL);\n      }\n      pop();\n      idx = new_sym(s, nsym(tree->car->cdr));\n      genop_2(s, OP_MODULE, cursp(), idx);\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_SCLASS:\n    {\n      int idx;\n\n      codegen(s, tree->car, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n          tree->cdr->car->cdr->cdr == NULL) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      else {\n        idx = scope_body(s, tree->cdr->car, val);\n        genop_2(s, OP_EXEC, cursp(), idx);\n      }\n      if (val) {\n        push();\n      }\n    }\n    break;\n\n  case NODE_DEF:\n    {\n      int sym = new_sym(s, nsym(tree->car));\n      int idx = lambda_body(s, tree->cdr, 0);\n\n      genop_1(s, OP_TCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      push(); pop();\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_SDEF:\n    {\n      node *recv = tree->car;\n      int sym = new_sym(s, nsym(tree->cdr->car));\n      int idx = lambda_body(s, tree->cdr->cdr, 0);\n\n      codegen(s, recv, VAL);\n      pop();\n      genop_1(s, OP_SCLASS, cursp());\n      push();\n      genop_2(s, OP_METHOD, cursp(), idx);\n      pop();\n      genop_2(s, OP_DEF, cursp(), sym);\n      if (val) push();\n    }\n    break;\n\n  case NODE_POSTEXE:\n    codegen(s, tree, NOVAL);\n    break;\n\n  default:\n    break;\n  }\n exit:\n  s->rlev = rlev;\n}\n\nstatic void\nscope_add_irep(codegen_scope *s)\n{\n  mrb_irep *irep;\n  codegen_scope *prev = s->prev;\n\n  if (prev->irep == NULL) {\n    irep = mrb_add_irep(s->mrb);\n    prev->irep = s->irep = irep;\n    return;\n  }\n  else {\n    if (prev->irep->rlen == UINT16_MAX) {\n      codegen_error(s, \"too many nested blocks/methods\");\n    }\n    s->irep = irep = mrb_add_irep(s->mrb);\n    if (prev->irep->rlen == prev->rcapa) {\n      prev->rcapa *= 2;\n      prev->reps = (mrb_irep**)codegen_realloc(s, prev->reps, sizeof(mrb_irep*)*prev->rcapa);\n    }\n    prev->reps[prev->irep->rlen] = irep;\n    prev->irep->rlen++;\n  }\n}\n\nstatic codegen_scope*\nscope_new(mrb_state *mrb, codegen_scope *prev, node *nlv)\n{\n  static const codegen_scope codegen_scope_zero = { 0 };\n  mrb_pool *pool = mrb_pool_open(mrb);\n  codegen_scope *s = (codegen_scope *)mrb_pool_alloc(pool, sizeof(codegen_scope));\n\n  if (!s) {\n    if (prev)\n      codegen_error(prev, \"unexpected scope\");\n    return NULL;\n  }\n  *s = codegen_scope_zero;\n  s->mrb = mrb;\n  s->mpool = pool;\n  if (!prev) return s;\n  s->prev = prev;\n  s->ainfo = 0;\n  s->mscope = 0;\n\n  scope_add_irep(s);\n\n  s->rcapa = 8;\n  s->reps = (mrb_irep**)mrb_malloc(mrb, sizeof(mrb_irep*)*s->rcapa);\n\n  s->icapa = 1024;\n  s->iseq = (mrb_code*)mrb_malloc(mrb, sizeof(mrb_code)*s->icapa);\n\n  s->pcapa = 32;\n  s->pool = (mrb_pool_value*)mrb_malloc(mrb, sizeof(mrb_pool_value)*s->pcapa);\n\n  s->scapa = 256;\n  s->syms = (mrb_sym*)mrb_malloc(mrb, sizeof(mrb_sym)*s->scapa);\n\n  s->lv = nlv;\n  s->sp += node_len(nlv)+1;        /* add self */\n  s->nlocals = s->sp;\n  if (nlv) {\n    mrb_sym *lv;\n    node *n = nlv;\n    size_t i = 0;\n\n    s->irep->lv = lv = (mrb_sym*)mrb_malloc(mrb, sizeof(mrb_sym)*(s->nlocals-1));\n    for (i=0, n=nlv; n; i++,n=n->cdr) {\n      lv[i] = lv_name(n);\n    }\n    mrb_assert(i + 1 == s->nlocals);\n  }\n  s->ai = mrb_gc_arena_save(mrb);\n\n  s->filename_sym = prev->filename_sym;\n  if (s->filename_sym) {\n    s->lines = (uint16_t*)mrb_malloc(mrb, sizeof(short)*s->icapa);\n  }\n  s->lineno = prev->lineno;\n\n  /* debug setting */\n  s->debug_start_pos = 0;\n  if (s->filename_sym) {\n    mrb_debug_info_alloc(mrb, s->irep);\n  }\n  else {\n    s->irep->debug_info = NULL;\n  }\n  s->parser = prev->parser;\n  s->filename_index = prev->filename_index;\n\n  s->rlev = prev->rlev+1;\n\n  return s;\n}\n\nstatic void\nscope_finish(codegen_scope *s)\n{\n  mrb_state *mrb = s->mrb;\n  mrb_irep *irep = s->irep;\n\n  if (s->nlocals > 0xff) {\n    codegen_error(s, \"too many local variables\");\n  }\n  irep->flags = 0;\n  if (s->iseq) {\n    size_t catchsize = sizeof(struct mrb_irep_catch_handler) * irep->clen;\n    irep->iseq = (const mrb_code *)codegen_realloc(s, s->iseq, sizeof(mrb_code)*s->pc + catchsize);\n    irep->ilen = s->pc;\n    if (irep->clen > 0) {\n      memcpy((void *)(irep->iseq + irep->ilen), s->catch_table, catchsize);\n    }\n  }\n  else {\n    irep->clen = 0;\n  }\n  mrb_free(s->mrb, s->catch_table);\n  s->catch_table = NULL;\n  irep->pool = (const mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*irep->plen);\n  irep->syms = (const mrb_sym*)codegen_realloc(s, s->syms, sizeof(mrb_sym)*irep->slen);\n  irep->reps = (const mrb_irep**)codegen_realloc(s, s->reps, sizeof(mrb_irep*)*irep->rlen);\n  if (s->filename_sym) {\n    mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n    const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n\n    mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                               filename, s->lines, s->debug_start_pos, s->pc);\n  }\n  mrb_free(s->mrb, s->lines);\n\n  irep->nlocals = s->nlocals;\n  irep->nregs = s->nregs;\n\n  mrb_gc_arena_restore(mrb, s->ai);\n  mrb_pool_close(s->mpool);\n}\n\nstatic struct loopinfo*\nloop_push(codegen_scope *s, enum looptype t)\n{\n  struct loopinfo *p = (struct loopinfo *)codegen_palloc(s, sizeof(struct loopinfo));\n\n  p->type = t;\n  p->pc0 = p->pc1 = p->pc2 = JMPLINK_START;\n  p->prev = s->loop;\n  p->reg = cursp();\n  s->loop = p;\n\n  return p;\n}\n\nstatic void\nloop_break(codegen_scope *s, node *tree)\n{\n  if (!s->loop) {\n    codegen(s, tree, NOVAL);\n    raise_error(s, \"unexpected break\");\n  }\n  else {\n    struct loopinfo *loop;\n\n\n    loop = s->loop;\n    if (tree) {\n      if (loop->reg < 0) {\n        codegen(s, tree, NOVAL);\n      }\n      else {\n        gen_retval(s, tree);\n      }\n    }\n    while (loop) {\n      if (loop->type == LOOP_BEGIN) {\n        loop = loop->prev;\n      }\n      else if (loop->type == LOOP_RESCUE) {\n        loop = loop->prev;\n      }\n      else{\n        break;\n      }\n    }\n    if (!loop) {\n      raise_error(s, \"unexpected break\");\n      return;\n    }\n\n    if (loop->type == LOOP_NORMAL) {\n      int tmp;\n\n      if (loop->reg >= 0) {\n        if (tree) {\n          gen_move(s, loop->reg, cursp(), 0);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, loop->reg);\n        }\n      }\n      tmp = genjmp(s, OP_JMPUW, loop->pc2);\n      loop->pc2 = tmp;\n    }\n    else {\n      if (!tree) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_BREAK, cursp());\n    }\n  }\n}\n\nstatic void\nloop_pop(codegen_scope *s, int val)\n{\n  if (val) {\n    genop_1(s, OP_LOADNIL, cursp());\n  }\n  dispatch_linked(s, s->loop->pc2);\n  s->loop = s->loop->prev;\n  if (val) push();\n}\n\nstatic int\ncatch_handler_new(codegen_scope *s)\n{\n  size_t newsize = sizeof(struct mrb_irep_catch_handler) * (s->irep->clen + 1);\n  s->catch_table = (struct mrb_irep_catch_handler *)codegen_realloc(s, (void *)s->catch_table, newsize);\n  return s->irep->clen ++;\n}\n\nstatic void\ncatch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target)\n{\n  struct mrb_irep_catch_handler *e;\n\n  mrb_assert(ent >= 0 && ent < s->irep->clen);\n\n  e = &s->catch_table[ent];\n  uint8_to_bin(type, &e->type);\n  mrb_irep_catch_handler_pack(begin, e->begin);\n  mrb_irep_catch_handler_pack(end, e->end);\n  mrb_irep_catch_handler_pack(target, e->target);\n}\n\nstatic struct RProc*\ngenerate_code(mrb_state *mrb, parser_state *p, int val)\n{\n  codegen_scope *scope = scope_new(mrb, 0, 0);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf jmpbuf;\n  struct RProc *proc;\n\n  mrb->jmp = &jmpbuf;\n\n  scope->mrb = mrb;\n  scope->parser = p;\n  scope->filename_sym = p->filename_sym;\n  scope->filename_index = p->current_filename_index;\n\n  MRB_TRY(mrb->jmp) {\n    /* prepare irep */\n    codegen(scope, p->tree, val);\n    proc = mrb_proc_new(mrb, scope->irep);\n    mrb_irep_decref(mrb, scope->irep);\n    mrb_pool_close(scope->mpool);\n    proc->c = NULL;\n    if (mrb->c->cibase && mrb->c->cibase->proc == proc->upper) {\n      proc->upper = NULL;\n    }\n    mrb->jmp = prev_jmp;\n    return proc;\n  }\n  MRB_CATCH(mrb->jmp) {\n    mrb_irep_decref(mrb, scope->irep);\n    mrb_pool_close(scope->mpool);\n    mrb->jmp = prev_jmp;\n    return NULL;\n  }\n  MRB_END_EXC(mrb->jmp);\n}\n\nMRB_API struct RProc*\nmrb_generate_code(mrb_state *mrb, parser_state *p)\n{\n  return generate_code(mrb, p, VAL);\n}\n\nvoid\nmrb_irep_remove_lv(mrb_state *mrb, mrb_irep *irep)\n{\n  int i;\n\n  if (irep->flags & MRB_IREP_NO_FREE) return;\n  if (irep->lv) {\n    mrb_free(mrb, (void*)irep->lv);\n    irep->lv = NULL;\n  }\n  if (!irep->reps) return;\n  for (i = 0; i < irep->rlen; ++i) {\n    mrb_irep_remove_lv(mrb, (mrb_irep*)irep->reps[i]);\n  }\n}\n"], "filenames": ["mrbgems/mruby-compiler/core/codegen.c"], "buggy_code_start_loc": [1907], "buggy_code_end_loc": [1908], "fixing_code_start_loc": [1907], "fixing_code_end_loc": [1913], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository mruby/mruby prior to 3.2.", "other": {"cve": {"id": "CVE-2022-0717", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-23T02:15:06.973", "lastModified": "2022-03-02T03:02:34.910", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository mruby/mruby prior to 3.2."}, {"lang": "es", "value": "Una Lectura Fuera de L\u00edmites en el repositorio de GitHub mruby/mruby versiones anteriores a 3.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.1", "matchCriteriaId": "47896591-3F1F-4AC0-9EC0-72AC0F4AA988"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/f72315575f78a9a773adbce0ee7d3ec33434cb76", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/27a851a5-7ebf-409b-854f-b2614771e8f9", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/f72315575f78a9a773adbce0ee7d3ec33434cb76"}}