{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/sdp.h>\n#include <pjmedia/errno.h>\n#include <pjlib-util/scanner.h>\n#include <pj/array.h>\n#include <pj/except.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n\n\nenum {\n    SKIP_WS = 0,\n    SYNTAX_ERROR = 1,\n};\n// New token definition from RFC 4566 (SDP)\n#define TOKEN\t\t\"!#$%&'*+-.^_`{|}~\"\n//#define TOKEN\t\t\"-.!%*_=`'~\"\n//#define TOKEN\t\t\"'`-./:?\\\"#$&*;=@[]^_`{|}+~!\"\n#define NTP_OFFSET\t((pj_uint32_t)2208988800)\n#define THIS_FILE\t\"sdp.c\"\n\ntypedef struct parse_context\n{ \n    pj_status_t last_error;\n} parse_context;\n\n\n/*\n * Prototypes for line parser.\n */\nstatic void parse_version(pj_scanner *scanner, volatile parse_context *ctx);\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx);\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx);\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx);\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx);\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx);\nstatic pjmedia_sdp_attr *parse_attr(pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx);\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx);\nstatic void on_scanner_error(pj_scanner *scanner);\n\n/*\n * Scanner character specification.\n */\nstatic int is_initialized;\nstatic pj_cis_buf_t cis_buf;\nstatic pj_cis_t cs_digit, cs_token;\n\nstatic void init_sdp_parser(void)\n{\n    if (is_initialized != 0)\n\treturn;\n\n    pj_enter_critical_section();\n\n    if (is_initialized != 0) {\n\tpj_leave_critical_section();\n\treturn;\n    }\n    \n    pj_cis_buf_init(&cis_buf);\n\n    pj_cis_init(&cis_buf, &cs_token);\n    pj_cis_add_alpha(&cs_token);\n    pj_cis_add_num(&cs_token);\n    pj_cis_add_str(&cs_token, TOKEN);\n\n    pj_cis_init(&cis_buf, &cs_digit);\n    pj_cis_add_num(&cs_digit);\n\n    is_initialized = 1;\n    pj_leave_critical_section();\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create( pj_pool_t *pool,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   const pj_str_t *value)\n{\n    pjmedia_sdp_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && name, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    pj_strdup2(pool, &attr->name, name);\n\n    if (value)\n\tpj_strdup_with_null(pool, &attr->value, value);\n    else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_clone(pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_attr *rhs)\n{\n    pjmedia_sdp_attr *attr;\n    \n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    pj_strdup(pool, &attr->name, &rhs->name);\n    pj_strdup_with_null(pool, &attr->value, &rhs->value);\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find (unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const pj_str_t *name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    unsigned i;\n    unsigned c_pt = 0xFFFF;\n\n    PJ_ASSERT_RETURN(count <= PJMEDIA_MAX_SDP_ATTR, NULL);\n\n    if (c_fmt)\n\tc_pt = pj_strtoul(c_fmt);\n\n    for (i=0; i<count; ++i) {\n\tif (pj_strcmp(&attr_array[i]->name, name) == 0) {\n\t    const pjmedia_sdp_attr *a = attr_array[i];\n\t    if (c_fmt) {\n\t\tunsigned pt = (unsigned) pj_strtoul2(&a->value, NULL, 10);\n\t\tif (pt == c_pt) {\n\t\t    return (pjmedia_sdp_attr*)a;\n\t\t}\n\t    } else \n\t\treturn (pjmedia_sdp_attr*)a;\n\t}\n    }\n    return NULL;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find2(unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const char *c_name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    pj_str_t name;\n\n    name.ptr = (char*)c_name;\n    name.slen = pj_ansi_strlen(c_name);\n\n    return pjmedia_sdp_attr_find(count, attr_array, &name, c_fmt);\n}\n\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_add(unsigned *count,\n\t\t\t\t\t pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count < PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_array[*count] = attr;\n    (*count)++;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(unsigned) pjmedia_sdp_attr_remove_all(unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     const char *name)\n{\n    unsigned i, removed = 0;\n    pj_str_t attr_name;\n\n    PJ_ASSERT_RETURN(count && attr_array && name, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_name.ptr = (char*)name;\n    attr_name.slen = pj_ansi_strlen(name);\n\n    for (i=0; i<*count; ) {\n\tif (pj_strcmp(&attr_array[i]->name, &attr_name)==0) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}   \n    }\n\n    return removed;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_remove( unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     pjmedia_sdp_attr *attr )\n{\n    unsigned i, removed=0;\n\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    for (i=0; i<*count; ) {\n\tif (attr_array[i] == attr) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}\n    }\n\n    return removed ? PJ_SUCCESS : PJ_ENOTFOUND;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtpmap( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t\t pjmedia_sdp_rtpmap *rtpmap)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    char term = 0;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtpmap\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* Check if input is null terminated, and null terminate if\n     * necessary. Unfortunately this may crash the application if\n     * attribute was allocated from a read-only memory location.\n     * But this shouldn't happen as attribute's value normally is\n     * null terminated.\n     */\n    if (attr->value.ptr[attr->value.slen] != 0 &&\n\tattr->value.ptr[attr->value.slen] != '\\r' &&\n\tattr->value.ptr[attr->value.slen] != '\\n')\n    {\n\tpj_assert(!\"Shouldn't happen\");\n\tterm = attr->value.ptr[attr->value.slen];\n\tattr->value.ptr[attr->value.slen] = '\\0';\n    }\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */    \n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* rtpmap sample:\n     *\ta=rtpmap:98 L16/16000/2.\n     */\n\n    /* Init */\n    rtpmap->pt.slen = rtpmap->param.slen = rtpmap->enc_name.slen = 0;\n    rtpmap->clock_rate = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get payload type. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->pt);\n\n\n\t/* Get encoding name. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->enc_name);\n\n\t/* Expecting '/' after encoding name. */\n\tif (pj_scan_get_char(&scanner) != '/') {\n\t    status = PJMEDIA_SDP_EINRTPMAP;\n\t    goto on_return;\n\t}\n\n\n\t/* Get the clock rate. */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\trtpmap->clock_rate = pj_strtoul(&token);\n\n\t/* Expecting either '/' or EOF */\n\tif (*scanner.curptr == '/') {\n\t    /* Skip the '/' */\n\t    pj_scan_get_char(&scanner);\n\t    pj_scan_get(&scanner, &cs_token, &rtpmap->param);\n\t} else {\n\t    rtpmap->param.slen = 0;\n\t}\n\n\tstatus = PJ_SUCCESS;\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTPMAP;\n    }\n    PJ_END;\n\n\non_return:\n    pj_scan_fini(&scanner);\n    if (term) {\n\tattr->value.ptr[attr->value.slen] = term;\n    }\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_fmtp( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_fmtp *fmtp)\n{\n    const char *p = attr->value.ptr;\n    const char *end = attr->value.ptr + attr->value.slen;\n    pj_str_t token;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"fmtp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    /* fmtp BNF:\n     *\ta=fmtp:<format> <format specific parameter>\n     */\n\n    /* Get format. */\n    token.ptr = (char*)p;\n    while (pj_isdigit(*p) && p!=end)\n\t++p;\n    token.slen = p - token.ptr;\n    if (token.slen == 0)\n\treturn PJMEDIA_SDP_EINFMTP;\n\n    fmtp->fmt = token;\n\n    /* Expecting space after format. */\n    if (*p != ' ') return PJMEDIA_SDP_EINFMTP;\n\n    /* Get space. */\n    ++p;\n\n    /* Set the remaining string as fmtp format parameter. */\n    fmtp->fmt_param.ptr = (char*)p;\n    fmtp->fmt_param.slen = end - p;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtcp(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_rtcp_attr *rtcp)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtcp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* fmtp BNF:\n     *\ta=rtcp:<port> [nettype addrtype address]\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    rtcp->net_type.slen = rtcp->addr_type.slen = rtcp->addr.slen = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get the port */\n\tpj_scan_get(&scanner, &cs_token, &token);\n\trtcp->port = pj_strtoul(&token);\n\n\t/* Have address? */\n\tif (!pj_scan_is_eof(&scanner)) {\n\n\t    /* Get network type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->net_type);\n\n\t    /* Get address type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->addr_type);\n\n\t    /* Get the address */\n\t    //pj_scan_get(&scanner, &cs_token, &rtcp->addr);\n\t    pj_scan_get_until_chr(&scanner, \"/ \\t\\r\\n\", &rtcp->addr);\n\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTCP;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_rtcp(pj_pool_t *pool,\n\t\t\t\t\t\t       const pj_sockaddr *a)\n{\n    enum {\n\tATTR_LEN = PJ_INET6_ADDRSTRLEN+16\n    };\n    char tmp_addr[PJ_INET6_ADDRSTRLEN];\n    pjmedia_sdp_attr *attr;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"rtcp\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, ATTR_LEN);\n    if (a->addr.sa_family == pj_AF_INET()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP4 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n    } else if (a->addr.sa_family == pj_AF_INET6()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP6 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n\n    } else {\n\tpj_assert(!\"Unsupported address family\");\n\treturn NULL;\n    }\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_ssrc(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_ssrc_attr *ssrc)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"ssrc\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* ssrc BNF:\n     *  a=ssrc:<ssrc-id> <attribute>\n     *\ta=ssrc:<ssrc-id> <attribute>:<value>\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    pj_bzero(ssrc, sizeof(*ssrc));\n\n    /* Parse */\n    PJ_TRY {\n        pj_str_t scan_attr;\n\n\t/* Get the ssrc */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\tssrc->ssrc = pj_strtoul(&token);\n\n    \tpj_scan_get_char(&scanner);\n\tpj_scan_get(&scanner, &cs_token, &scan_attr);\n\t\n\t/* Get cname attribute, if any */\n\tif (!pj_scan_is_eof(&scanner) &&\n\t    pj_scan_get_char(&scanner) == ':' &&\n\t    pj_strcmp2(&scan_attr, \"cname\"))\n\t{\n\t    pj_scan_get(&scanner, &cs_token, &ssrc->cname);\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINSSRC;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_ssrc( pj_pool_t *pool,\n\t\t\t\t\t\t\tpj_uint32_t ssrc,\n\t\t\t\t\t\t\tconst pj_str_t *cname)\n{\n    pjmedia_sdp_attr *attr;\n\n    if (cname->slen == 0)\n        return NULL;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"ssrc\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, cname->slen+7 /* \" cname:\"*/\n    \t\t\t\t\t\t  + 10 /* 32-bit integer */\n    \t\t\t\t\t\t  + 1 /* NULL */);\n    attr->value.slen = pj_ansi_snprintf(attr->value.ptr, cname->slen+18,\n    \t\t\t\t\t\"%u cname:%.*s\", ssrc,\n\t\t\t   \t   \t(int)cname->slen, cname->ptr);\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_to_rtpmap(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_rtpmap **p_rtpmap)\n{\n    PJ_ASSERT_RETURN(pool && attr && p_rtpmap, PJ_EINVAL);\n\n    *p_rtpmap = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_rtpmap);\n    PJ_ASSERT_RETURN(*p_rtpmap, PJ_ENOMEM);\n\n    return pjmedia_sdp_attr_get_rtpmap(attr, *p_rtpmap);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_rtpmap_to_attr(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_rtpmap *rtpmap,\n\t\t\t\t\t       pjmedia_sdp_attr **p_attr)\n{\n    pjmedia_sdp_attr *attr;\n    char tempbuf[128];\n    int len;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && rtpmap && p_attr, PJ_EINVAL);\n\n    /* Check that mandatory attributes are specified. */\n    PJ_ASSERT_RETURN(rtpmap->enc_name.slen && rtpmap->clock_rate,\n\t\t     PJMEDIA_SDP_EINRTPMAP);\n\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    PJ_ASSERT_RETURN(attr != NULL, PJ_ENOMEM);\n\n    attr->name.ptr = \"rtpmap\";\n    attr->name.slen = 6;\n\n    /* Format: \":pt enc_name/clock_rate[/param]\" */\n    len = pj_ansi_snprintf(tempbuf, sizeof(tempbuf), \n\t\t\t   \"%.*s %.*s/%u%s%.*s\",\n\t\t\t   (int)rtpmap->pt.slen,\n\t\t\t   rtpmap->pt.ptr,\n\t\t\t   (int)rtpmap->enc_name.slen,\n\t\t\t   rtpmap->enc_name.ptr,\n\t\t\t   rtpmap->clock_rate,\n\t\t\t   (rtpmap->param.slen ? \"/\" : \"\"),\n\t\t\t   (int)rtpmap->param.slen,\n\t\t\t   rtpmap->param.ptr);\n\n    if (len < 1 || len >= (int)sizeof(tempbuf))\n\treturn PJMEDIA_SDP_ERTPMAPTOOLONG;\n\n    attr->value.slen = len;\n    attr->value.ptr = (char*) pj_pool_alloc(pool, attr->value.slen+1);\n    pj_memcpy(attr->value.ptr, tempbuf, attr->value.slen+1);\n\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic int print_connection_info( pjmedia_sdp_conn *c, char *buf, int len)\n{\n    int printed;\n\n    printed = pj_ansi_snprintf(buf, len, \"c=%.*s %.*s %.*s\\r\\n\",\n\t\t\t       (int)c->net_type.slen,\n\t\t\t       c->net_type.ptr,\n\t\t\t       (int)c->addr_type.slen,\n\t\t\t       c->addr_type.ptr,\n\t\t\t       (int)c->addr.slen,\n\t\t\t       c->addr.ptr);\n    if (printed < 1 || printed >= len)\n\treturn -1;\n\n    return printed;\n}\n\n\nPJ_DEF(pjmedia_sdp_conn*) pjmedia_sdp_conn_clone (pj_pool_t *pool, \n\t\t\t\t\t\t  const pjmedia_sdp_conn *rhs)\n{\n    pjmedia_sdp_conn *c = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_conn);\n    if (!c) return NULL;\n\n    if (!pj_strdup (pool, &c->net_type, &rhs->net_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr_type, &rhs->addr_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr, &rhs->addr)) return NULL;\n\n    return c;\n}\n\nPJ_DEF(pjmedia_sdp_bandw*)\npjmedia_sdp_bandw_clone (pj_pool_t *pool, \n\t\t\t const pjmedia_sdp_bandw *rhs)\n{\n    pjmedia_sdp_bandw *b = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_bandw);\n    if (!b) return NULL;\n\n    if (!pj_strdup (pool, &b->modifier, &rhs->modifier)) return NULL;\n    b->value = rhs->value;\n\n    return b;\n}\n\nstatic pj_ssize_t print_bandw(const pjmedia_sdp_bandw *bandw,\n\t\t\t      char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < bandw->modifier.slen + 10 + 5)\n\treturn -1;\n\n    *p++ = 'b';\n    *p++ = '=';\n    pj_memcpy(p, bandw->modifier.ptr, bandw->modifier.slen);\n    p += bandw->modifier.slen;\n    *p++ = ':';\n    p += pj_utoa(bandw->value, p);\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic pj_ssize_t print_attr(const pjmedia_sdp_attr *attr, \n\t\t\t     char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < attr->name.slen + attr->value.slen + 10)\n\treturn -1;\n\n    *p++ = 'a';\n    *p++ = '=';\n    pj_memcpy(p, attr->name.ptr, attr->name.slen);\n    p += attr->name.slen;\n    \n\n    if (attr->value.slen) {\n\t*p++ = ':';\n\tpj_memcpy(p, attr->value.ptr, attr->value.slen);\n\tp += attr->value.slen;\n    }\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\nPJ_DEF(int) pjmedia_sdp_media_print(const pjmedia_sdp_media *media,\n\t\t\t       char *buf, pj_size_t size)\n{\n\treturn print_media_desc(media, buf, size);\n}\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone(\n\t\t\t\t\t\t pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_media);\n    PJ_ASSERT_RETURN(m != NULL, NULL);\n\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    m->desc.port = rhs->desc.port;\n    m->desc.port_count = rhs->desc.port_count;\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    m->desc.fmt_count = rhs->desc.fmt_count;\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    } else {\n\tm->conn = NULL;\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    m->attr_count = rhs->attr_count;\n    for (i=0; i < rhs->attr_count; ++i) {\n\tm->attr[i] = pjmedia_sdp_attr_clone (pool, rhs->attr[i]);\n\tPJ_ASSERT_RETURN(m->attr[i] != NULL, NULL);\n    }\n\n    return m;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst pj_str_t *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find(m->attr_count, m->attr, name, fmt);\n}\n\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr2(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst char *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find2(m->attr_count, m->attr, name, fmt);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_add_attr( pjmedia_sdp_media *m,\n\t\t\t\t\t\tpjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_session_add_attr(pjmedia_sdp_session *s,\n\t\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&s->attr_count, s->attr, attr);\n}\n\nPJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,\n\t\t\t\t\t\t   const char *name)\n{\n    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_remove_attr(pjmedia_sdp_media *m,\n\t\t\t      \t\t\t  pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_remove(&m->attr_count, m->attr, attr);\n}\n\nstatic int print_session(const pjmedia_sdp_session *ses, \n\t\t\t char *buf, pj_ssize_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* Check length for v= and o= lines. */\n    if (len < 5+ \n\t      2+ses->origin.user.slen+18+\n\t      ses->origin.net_type.slen+ses->origin.addr.slen + 2)\n    {\n\treturn -1;\n    }\n\n    /* SDP version (v= line) */\n    pj_memcpy(p, \"v=0\\r\\n\", 5);\n    p += 5;\n\n    /* Owner (o=) line. */\n    *p++ = 'o';\n    *p++ = '=';\n    pj_memcpy(p, ses->origin.user.ptr, ses->origin.user.slen);\n    p += ses->origin.user.slen;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.id, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.version, p);\n    p += printed;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.net_type.ptr, ses->origin.net_type.slen);\n    p += ses->origin.net_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr_type.ptr, ses->origin.addr_type.slen);\n    p += ses->origin.addr_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr.ptr, ses->origin.addr.slen);\n    p += ses->origin.addr.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Session name (s=) line. */\n    if ((end-p)  < 8+ses->name.slen) {\n\treturn -1;\n    }\n    *p++ = 's';\n    *p++ = '=';\n    pj_memcpy(p, ses->name.ptr, ses->name.slen);\n    p += ses->name.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Connection line (c=) if exist. */\n    if (ses->conn) {\n\tprinted = print_connection_info(ses->conn, p, (int)(end-p));\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print optional bandwidth info. */\n    for (i=0; i<ses->bandw_count; ++i) {\n\tprinted = (int)print_bandw(ses->bandw[i], p, end-p);\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Time */\n    if ((end-p) < 24) {\n\treturn -1;\n    }\n    *p++ = 't';\n    *p++ = '=';\n    printed = pj_utoa(ses->time.start, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->time.stop, p);\n    p += printed;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Print all attribute (a=) lines. */\n    for (i=0; i<ses->attr_count; ++i) {\n\tprinted = (int)print_attr(ses->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Print media (m=) lines. */\n    for (i=0; i<ses->media_count; ++i) {\n\tprinted = print_media_desc(ses->media[i], p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\n/******************************************************************************\n * PARSERS\n */\n\nstatic void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* check version is 0 */\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* o= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* username. */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n\n    /* id */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* version */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n}\n\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* t= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* start time */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n\n    pj_scan_get_char(scanner);\n\n    /* stop time */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* get anything until newline (including whitespaces). */\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n\n    /* newline. */\n    pj_scan_get_newline(scanner);\n}\n\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINCONN;\n\n    /* c= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address. */\n    pj_scan_get_until_chr(scanner, \"/ \\t\\r\\n\", &conn->addr);\n    PJ_TODO(PARSE_SDP_CONN_ADDRESS_SUBFIELDS);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINBANDW;\n\n    /* b= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* modifier */\n    pj_scan_get_until_ch(scanner, ':', &bandw->modifier);\n    pj_scan_get_char(scanner);\n\n    /* value */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    bandw->value = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n\n    /* check the equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* m= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* type */\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n\n    /* port */\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\t/* port count */\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n\n    } else {\n\tmed->desc.port_count = 0;\n    }\n\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n\n    /* transport */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n\n    /* format list */\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\n\tpj_scan_get_char(scanner);\n\n\t/* Check again for the end of the line */\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void on_scanner_error(pj_scanner *scanner)\n{\n    PJ_UNUSED_ARG(scanner);\n\n    PJ_THROW(SYNTAX_ERROR);\n}\n\nstatic pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n\n    /* skip a= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    \n    /* get attr name. */\n    pj_scan_get(scanner, &cs_token, &attr->name);\n\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\t/* skip ':' if present. */\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\n\t/* get value */\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n    return attr;\n}\n\n\n/*\n * Apply direction attribute in session to all media.\n */\nstatic void apply_media_direction(pjmedia_sdp_session *sdp)\n{\n    pjmedia_sdp_attr *dir_attr = NULL;\n    unsigned i;\n\n    const pj_str_t inactive = { \"inactive\", 8 };\n    const pj_str_t sendonly = { \"sendonly\", 8 };\n    const pj_str_t recvonly = { \"recvonly\", 8 };\n    const pj_str_t sendrecv = { \"sendrecv\", 8 };\n\n    /* Find direction attribute in session, don't need to find default \n     * direction \"sendrecv\".\n     */\n    for (i = 0; i < sdp->attr_count && !dir_attr; ++i) {\n\tif (!pj_strcmp(&sdp->attr[i]->name, &sendonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &recvonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &inactive)) \n\t{\n\t    dir_attr = sdp->attr[i];\n\t}\n    }\n\n    /* Found the direction attribute */\n    if (dir_attr) {\n\t/* Remove the direction attribute in session */\n\tpjmedia_sdp_attr_remove(&sdp->attr_count, sdp->attr, dir_attr);\n\n\t/* Apply the direction attribute to all media, but not overriding it\n\t * if media already has direction attribute.\n\t */\n\tfor (i = 0; i < sdp->media_count; ++i) {\n\t    pjmedia_sdp_media *m;\n\t    unsigned j;\n\n\t    /* Find direction attribute in this media */\n\t    m = sdp->media[i];\n\t    for (j = 0; j < m->attr_count; ++j) {\n\t\tif (!pj_strcmp(&m->attr[j]->name, &sendrecv) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &sendonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &recvonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &inactive)) \n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Not found, apply direction attribute from session */\n\t    if (j == m->attr_count)\n\t\tpjmedia_sdp_media_add_attr(m, dir_attr);\n\t}\n    }\n}\n\n\n/*\n * Parse SDP message.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_parse( pj_pool_t *pool,\n\t\t\t\t       char *buf, pj_size_t len, \n\t\t\t\t       pjmedia_sdp_session **p_sdp)\n{\n    pj_scanner scanner;\n    pjmedia_sdp_session *session;\n    pjmedia_sdp_media *media = NULL;\n    pjmedia_sdp_attr *attr;\n    pjmedia_sdp_conn *conn;\n    pjmedia_sdp_bandw *bandw;\n    pj_str_t dummy;\n    int cur_name = 254;\n    volatile parse_context ctx;\n    PJ_USE_EXCEPTION;\n\n    ctx.last_error = PJ_SUCCESS;\n\n    init_sdp_parser();\n\n    pj_scan_init(&scanner, buf, len, 0, &on_scanner_error);\n    session = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(session != NULL, PJ_ENOMEM);\n\n    /* Ignore leading newlines */\n    while (*scanner.curptr=='\\r' || *scanner.curptr=='\\n')\n\tpj_scan_get_char(&scanner);\n\n    PJ_TRY {\n\twhile (!pj_scan_is_eof(&scanner)) {\n\t\tcur_name = *scanner.curptr;\n\t\tswitch (cur_name) {\n\t\tcase 'a':\n\t\t    attr = parse_attr(pool, &scanner, &ctx);\n\t\t    if (attr) {\n\t\t\tif (media) {\n\t\t\t    if (media->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_media_add_attr(media, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding media attribute, \"\n\t\t\t\t\t      \"attribute is ignored\"));\n\t\t\t} else {\n\t\t\t    if (session->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_session_add_attr(session, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding session attribute\"\n\t\t\t\t\t      \", attribute is ignored\"));\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 'o':\n\t\t    parse_origin(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 's':\n\t\t    parse_generic_line(&scanner, &session->name, &ctx);\n\t\t    break;\n\t\tcase 'c':\n\t\t    conn = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_conn);\n\t\t    parse_connection_info(&scanner, conn, &ctx);\n\t\t    if (media) {\n\t\t\tmedia->conn = conn;\n\t\t    } else {\n\t\t\tsession->conn = conn;\n\t\t    }\n\t\t    break;\n\t\tcase 't':\n\t\t    parse_time(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 'm':\n\t\t    media = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n\t\t    parse_media(&scanner, media, &ctx);\n\t\t    if (session->media_count < PJMEDIA_MAX_SDP_MEDIA)\n\t\t\tsession->media[ session->media_count++ ] = media;\n\t\t    else\n\t\t\tPJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t     \"Error adding media, media is ignored\"));\n\t\t    break;\n\t\tcase 'v':\n\t\t    parse_version(&scanner, &ctx);\n\t\t    break;\n\t\tcase 13:\n\t\tcase 10:\n\t\t    pj_scan_get_char(&scanner);\n\t\t    /* Allow empty newlines at the end of the message */\n\t\t    while (!pj_scan_is_eof(&scanner)) {\n\t\t\tif (*scanner.curptr != 13 && *scanner.curptr != 10) {\n\t\t\t    ctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\t    on_scanner_error(&scanner);\n\t\t\t}\n\t\t\tpj_scan_get_char(&scanner);\n\t\t    }\n\t\t    break;\n\t\tcase 'b':\n\t\t    bandw = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_bandw);\n\t\t    parse_bandwidth_info(&scanner, bandw, &ctx);\n\t\t    if (media) {\n\t\t\tif (media->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    media->bandw[media->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding media bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    } else {\n\t\t\tif (session->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    session->bandw[session->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding session bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    if (cur_name >= 'a' && cur_name <= 'z')\n\t\t\tparse_generic_line(&scanner, &dummy, &ctx);\n\t\t    else  {\n\t\t\tctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\ton_scanner_error(&scanner);\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\tctx.last_error = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\t\t\n\tPJ_PERROR(4, (THIS_FILE, ctx.last_error,\n\t\t      \"Error parsing SDP in line %d col %d\",\n\t\t      scanner.line, pj_scan_get_col(&scanner)));\n\n\tsession = NULL;\n\n\tpj_assert(ctx.last_error != PJ_SUCCESS);\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n\n    if (session)\n\tapply_media_direction(session);\n\n    *p_sdp = session;\n    return ctx.last_error;\n}\n\n/*\n * Print SDP description.\n */\nPJ_DEF(int) pjmedia_sdp_print( const pjmedia_sdp_session *desc, \n\t\t\t       char *buf, pj_size_t size)\n{\n    return print_session(desc, buf, size);\n}\n\n\n/*\n * Clone session\n */\nPJ_DEF(pjmedia_sdp_session*) pjmedia_sdp_session_clone( pj_pool_t *pool,\n\t\t\t   \t\t\tconst pjmedia_sdp_session *rhs)\n{\n    pjmedia_sdp_session *sess;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    sess = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(sess != NULL, NULL);\n\n    /* Clone origin line. */\n    pj_strdup(pool, &sess->origin.user, &rhs->origin.user);\n    sess->origin.id = rhs->origin.id;\n    sess->origin.version = rhs->origin.version;\n    pj_strdup(pool, &sess->origin.net_type, &rhs->origin.net_type);\n    pj_strdup(pool, &sess->origin.addr_type, &rhs->origin.addr_type);\n    pj_strdup(pool, &sess->origin.addr, &rhs->origin.addr);\n\n    /* Clone subject line. */\n    pj_strdup(pool, &sess->name, &rhs->name);\n\n    /* Clone connection line */\n    if (rhs->conn) {\n\tsess->conn = pjmedia_sdp_conn_clone(pool, rhs->conn);\n\tPJ_ASSERT_RETURN(sess->conn != NULL, NULL);\n    }\n\n    /* Duplicate bandwidth info */\n    sess->bandw_count = rhs->bandw_count;\n    for (i=0; i<rhs->bandw_count; ++i) {\n\tsess->bandw[i] = pjmedia_sdp_bandw_clone(pool, rhs->bandw[i]);\n    }\n\n    /* Clone time line. */\n    sess->time.start = rhs->time.start;\n    sess->time.stop = rhs->time.stop;\n\n    /* Duplicate session attributes. */\n    sess->attr_count = rhs->attr_count;\n    for (i=0; i<rhs->attr_count; ++i) {\n\tsess->attr[i] = pjmedia_sdp_attr_clone(pool, rhs->attr[i]);\n    }\n\n    /* Duplicate media descriptors. */\n    sess->media_count = rhs->media_count;\n    for (i=0; i<rhs->media_count; ++i) {\n\tsess->media[i] = pjmedia_sdp_media_clone(pool, rhs->media[i]);\n    }\n\n    return sess;\n}\n\n\n#define CHECK(exp,ret)\tdo {\t\t\t\\\n\t\t\t    /*pj_assert(exp);*/\t\\\n\t\t\t    if (!(exp))\t\t\\\n\t\t\t\treturn ret;\t\\\n\t\t\t} while (0)\n\n/* Validate SDP connetion info. */\nstatic pj_status_t validate_sdp_conn(const pjmedia_sdp_conn *c)\n{\n    CHECK( c, PJ_EINVAL);\n    CHECK( pj_strcmp2(&c->net_type, \"IN\")==0, PJMEDIA_SDP_EINCONN);\n    CHECK( pj_strcmp2(&c->addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&c->addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINCONN);\n    CHECK( c->addr.slen != 0, PJMEDIA_SDP_EINCONN);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate(const pjmedia_sdp_session *sdp)\n{\n    return pjmedia_sdp_validate2(sdp, PJ_TRUE);\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate2(const pjmedia_sdp_session *sdp,\n\t\t\t\t\t  pj_bool_t strict)\n{\n    unsigned i;\n    const pj_str_t STR_RTPMAP = { \"rtpmap\", 6 };\n\n    CHECK( sdp != NULL, PJ_EINVAL);\n\n    /* Validate origin line. */\n    CHECK( sdp->origin.user.slen != 0, PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.net_type, \"IN\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&sdp->origin.addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( sdp->origin.addr.slen != 0, PJMEDIA_SDP_EINORIGIN);\n\n    /* Validate subject line. */\n    CHECK( sdp->name.slen != 0, PJMEDIA_SDP_EINNAME);\n\n    /* Ignore start and stop time. */\n\n    /* If session level connection info is present, validate it. */\n    if (sdp->conn) {\n\tpj_status_t status = validate_sdp_conn(sdp->conn);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Validate each media. */\n    for (i=0; i<sdp->media_count; ++i) {\n\tconst pjmedia_sdp_media *m = sdp->media[i];\n\tunsigned j;\n\n\t/* Validate the m= line. */\n\tCHECK( m->desc.media.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.transport.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.fmt_count != 0 || m->desc.port==0, PJMEDIA_SDP_ENOFMT);\n\n\t/* If media level connection info is present, validate it. */\n\tif (m->conn) {\n\t    pj_status_t status = validate_sdp_conn(m->conn);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\t}\n\n\t/* If media doesn't have connection info, then connection info\n\t * must be present in the session.\n\t */\n\tif (m->conn == NULL) {\n\t    if (sdp->conn == NULL)\n\t\tif (strict || m->desc.port != 0)\n\t\t    return PJMEDIA_SDP_EMISSINGCONN;\n\t}\n\n\t/* Verify payload type. */\n\tfor (j=0; j<m->desc.fmt_count; ++j) {\n\n\t    /* Arrgh noo!! Payload type can be non-numeric!!\n\t     * RTC based programs sends \"null\" for instant messaging!\n\t     */\n\t    if (pj_isdigit(*m->desc.fmt[j].ptr)) {\n\t\tunsigned long pt;\n\t\tpj_status_t status = pj_strtoul3(&m->desc.fmt[j], &pt, 10);\n\n\t\t/* Payload type is between 0 and 127. \n\t\t */\n\t\tCHECK( status == PJ_SUCCESS && pt <= 127, PJMEDIA_SDP_EINPT);\n\n\t\t/* If port is not zero, then for each dynamic payload type, an\n\t\t * rtpmap attribute must be specified.\n\t\t */\n\t\tif (m->desc.port != 0 && pt >= 96) {\n\t\t    const pjmedia_sdp_attr *a;\n\n\t\t    a = pjmedia_sdp_media_find_attr(m, &STR_RTPMAP, \n\t\t\t\t\t\t    &m->desc.fmt[j]);\n\t\t    CHECK( a != NULL, PJMEDIA_SDP_EMISSINGRTPMAP);\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Looks good. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_transport_cmp( const pj_str_t *t1,\n\t\t\t\t\t       const pj_str_t *t2)\n{\n    pj_uint32_t t1_proto, t2_proto;\n\n    /* Exactly equal? */\n    if (pj_stricmp(t1, t2) == 0)\n\treturn PJ_SUCCESS;\n\n    /* Check if boths are RTP/AVP based */\n    t1_proto = pjmedia_sdp_transport_get_proto(t1);\n    t2_proto = pjmedia_sdp_transport_get_proto(t2);\n    if (PJMEDIA_TP_PROTO_HAS_FLAG(t1_proto, PJMEDIA_TP_PROTO_RTP_AVP) && \n\tPJMEDIA_TP_PROTO_HAS_FLAG(t2_proto, PJMEDIA_TP_PROTO_RTP_AVP))\n    {\n\treturn PJ_SUCCESS;\n    }\n\n    /* Compatible? */\n    //{\n    //\tstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\n    //\tstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n    //\tif ((!pj_stricmp(t1, &ID_RTP_AVP) || !pj_stricmp(t1, &ID_RTP_SAVP)) &&\n    //      (!pj_stricmp(t2, &ID_RTP_AVP) || !pj_stricmp(t2, &ID_RTP_SAVP)))\n    //\t    return PJ_SUCCESS;\n    //}\n\n    return PJMEDIA_SDP_ETPORTNOTEQUAL;\n}\n\n\n/*\n * Get media transport info, e.g: protocol and profile.\n */\nPJ_DEF(pj_uint32_t) pjmedia_sdp_transport_get_proto(const pj_str_t *tp)\n{\n    pj_str_t token, rest = {0};\n    pj_ssize_t idx;\n\n    PJ_ASSERT_RETURN(tp, PJMEDIA_TP_PROTO_NONE);\n\n    idx = pj_strtok2(tp, \"/\", &token, 0);\n    if (idx != tp->slen)\n\tpj_strset(&rest, tp->ptr + token.slen + 1, tp->slen - token.slen - 1);\n\n    if (pj_stricmp2(&token, \"RTP\") == 0) {\n\t/* Starts with \"RTP\" */\n\n\t/* RTP/AVP */\n\tif (pj_stricmp2(&rest, \"AVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVP;\n\n\t/* RTP/SAVP */\n\tif (pj_stricmp2(&rest, \"SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVP;\n\n\t/* RTP/AVPF */\n\tif (pj_stricmp2(&rest, \"AVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVPF;\n\n\t/* RTP/SAVPF */\n\tif (pj_stricmp2(&rest, \"SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVPF;\n\n    } else if (pj_stricmp2(&token, \"UDP\") == 0) {\n\t/* Starts with \"UDP\" */\n\n\t/* Plain UDP */\n\tif (rest.slen == 0)\n\t    return PJMEDIA_TP_PROTO_UDP;\n\n\t/* DTLS-SRTP */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTP;\n\n\t/* DTLS-SRTP with RTCP-FB */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTPF;\n    }\n\n    /* Unknown transport */\n    return PJMEDIA_TP_PROTO_UNKNOWN;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_deactivate(pj_pool_t *pool,\n\t\t\t\t\t\t pjmedia_sdp_media *m)\n{\n    PJ_ASSERT_RETURN(m, PJ_EINVAL);\n    PJ_UNUSED_ARG(pool);\n\n    /* Set port to zero */\n    m->desc.port = 0;\n\n    /* And remove attributes */\n    m->attr_count = 0;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone_deactivate(\n\t\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\t\tconst pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    m = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n    pj_memcpy(m, rhs, sizeof(*m));\n\n    /* Clone the media line only */\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    /* And deactivate it */\n    pjmedia_sdp_media_deactivate(pool, m);\n\n    return m;\n}\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/sdp.h>\n#include <pjmedia/errno.h>\n#include <pjlib-util/scanner.h>\n#include <pj/array.h>\n#include <pj/except.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n\n\nenum {\n    SKIP_WS = 0,\n    SYNTAX_ERROR = 1,\n};\n// New token definition from RFC 4566 (SDP)\n#define TOKEN\t\t\"!#$%&'*+-.^_`{|}~\"\n//#define TOKEN\t\t\"-.!%*_=`'~\"\n//#define TOKEN\t\t\"'`-./:?\\\"#$&*;=@[]^_`{|}+~!\"\n#define NTP_OFFSET\t((pj_uint32_t)2208988800)\n#define THIS_FILE\t\"sdp.c\"\n\ntypedef struct parse_context\n{ \n    pj_status_t last_error;\n} parse_context;\n\n\n/*\n * Prototypes for line parser.\n */\nstatic void parse_version(pj_scanner *scanner, volatile parse_context *ctx);\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx);\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx);\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx);\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx);\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx);\nstatic pjmedia_sdp_attr *parse_attr(pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx);\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx);\nstatic void on_scanner_error(pj_scanner *scanner);\n\n/*\n * Scanner character specification.\n */\nstatic int is_initialized;\nstatic pj_cis_buf_t cis_buf;\nstatic pj_cis_t cs_digit, cs_token;\n\nstatic void init_sdp_parser(void)\n{\n    if (is_initialized != 0)\n\treturn;\n\n    pj_enter_critical_section();\n\n    if (is_initialized != 0) {\n\tpj_leave_critical_section();\n\treturn;\n    }\n    \n    pj_cis_buf_init(&cis_buf);\n\n    pj_cis_init(&cis_buf, &cs_token);\n    pj_cis_add_alpha(&cs_token);\n    pj_cis_add_num(&cs_token);\n    pj_cis_add_str(&cs_token, TOKEN);\n\n    pj_cis_init(&cis_buf, &cs_digit);\n    pj_cis_add_num(&cs_digit);\n\n    is_initialized = 1;\n    pj_leave_critical_section();\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create( pj_pool_t *pool,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   const pj_str_t *value)\n{\n    pjmedia_sdp_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && name, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    pj_strdup2(pool, &attr->name, name);\n\n    if (value)\n\tpj_strdup_with_null(pool, &attr->value, value);\n    else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_clone(pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_attr *rhs)\n{\n    pjmedia_sdp_attr *attr;\n    \n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    pj_strdup(pool, &attr->name, &rhs->name);\n    pj_strdup_with_null(pool, &attr->value, &rhs->value);\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find (unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const pj_str_t *name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    unsigned i;\n    unsigned c_pt = 0xFFFF;\n\n    PJ_ASSERT_RETURN(count <= PJMEDIA_MAX_SDP_ATTR, NULL);\n\n    if (c_fmt)\n\tc_pt = pj_strtoul(c_fmt);\n\n    for (i=0; i<count; ++i) {\n\tif (pj_strcmp(&attr_array[i]->name, name) == 0) {\n\t    const pjmedia_sdp_attr *a = attr_array[i];\n\t    if (c_fmt) {\n\t\tunsigned pt = (unsigned) pj_strtoul2(&a->value, NULL, 10);\n\t\tif (pt == c_pt) {\n\t\t    return (pjmedia_sdp_attr*)a;\n\t\t}\n\t    } else \n\t\treturn (pjmedia_sdp_attr*)a;\n\t}\n    }\n    return NULL;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find2(unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const char *c_name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    pj_str_t name;\n\n    name.ptr = (char*)c_name;\n    name.slen = pj_ansi_strlen(c_name);\n\n    return pjmedia_sdp_attr_find(count, attr_array, &name, c_fmt);\n}\n\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_add(unsigned *count,\n\t\t\t\t\t pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count < PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_array[*count] = attr;\n    (*count)++;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(unsigned) pjmedia_sdp_attr_remove_all(unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     const char *name)\n{\n    unsigned i, removed = 0;\n    pj_str_t attr_name;\n\n    PJ_ASSERT_RETURN(count && attr_array && name, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_name.ptr = (char*)name;\n    attr_name.slen = pj_ansi_strlen(name);\n\n    for (i=0; i<*count; ) {\n\tif (pj_strcmp(&attr_array[i]->name, &attr_name)==0) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}   \n    }\n\n    return removed;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_remove( unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     pjmedia_sdp_attr *attr )\n{\n    unsigned i, removed=0;\n\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    for (i=0; i<*count; ) {\n\tif (attr_array[i] == attr) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}\n    }\n\n    return removed ? PJ_SUCCESS : PJ_ENOTFOUND;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtpmap( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t\t pjmedia_sdp_rtpmap *rtpmap)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    char term = 0;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtpmap\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* Check if input is null terminated, and null terminate if\n     * necessary. Unfortunately this may crash the application if\n     * attribute was allocated from a read-only memory location.\n     * But this shouldn't happen as attribute's value normally is\n     * null terminated.\n     */\n    if (attr->value.ptr[attr->value.slen] != 0 &&\n\tattr->value.ptr[attr->value.slen] != '\\r' &&\n\tattr->value.ptr[attr->value.slen] != '\\n')\n    {\n\tpj_assert(!\"Shouldn't happen\");\n\tterm = attr->value.ptr[attr->value.slen];\n\tattr->value.ptr[attr->value.slen] = '\\0';\n    }\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */    \n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* rtpmap sample:\n     *\ta=rtpmap:98 L16/16000/2.\n     */\n\n    /* Init */\n    rtpmap->pt.slen = rtpmap->param.slen = rtpmap->enc_name.slen = 0;\n    rtpmap->clock_rate = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get payload type. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->pt);\n\n\n\t/* Get encoding name. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->enc_name);\n\n\t/* Expecting '/' after encoding name. */\n\tif (pj_scan_get_char(&scanner) != '/') {\n\t    status = PJMEDIA_SDP_EINRTPMAP;\n\t    goto on_return;\n\t}\n\n\n\t/* Get the clock rate. */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\trtpmap->clock_rate = pj_strtoul(&token);\n\n\t/* Expecting either '/' or EOF */\n\tif (*scanner.curptr == '/') {\n\t    /* Skip the '/' */\n\t    pj_scan_get_char(&scanner);\n\t    pj_scan_get(&scanner, &cs_token, &rtpmap->param);\n\t} else {\n\t    rtpmap->param.slen = 0;\n\t}\n\n\tstatus = PJ_SUCCESS;\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTPMAP;\n    }\n    PJ_END;\n\n\non_return:\n    pj_scan_fini(&scanner);\n    if (term) {\n\tattr->value.ptr[attr->value.slen] = term;\n    }\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_fmtp( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_fmtp *fmtp)\n{\n    const char *p = attr->value.ptr;\n    const char *end = attr->value.ptr + attr->value.slen;\n    pj_str_t token;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"fmtp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    /* fmtp BNF:\n     *\ta=fmtp:<format> <format specific parameter>\n     */\n\n    /* Get format. */\n    token.ptr = (char*)p;\n    while (pj_isdigit(*p) && p!=end)\n\t++p;\n    token.slen = p - token.ptr;\n    if (token.slen == 0)\n\treturn PJMEDIA_SDP_EINFMTP;\n\n    fmtp->fmt = token;\n\n    /* Expecting space after format. */\n    if (*p != ' ') return PJMEDIA_SDP_EINFMTP;\n\n    /* Get space. */\n    ++p;\n\n    /* Set the remaining string as fmtp format parameter. */\n    fmtp->fmt_param.ptr = (char*)p;\n    fmtp->fmt_param.slen = end - p;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtcp(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_rtcp_attr *rtcp)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtcp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* fmtp BNF:\n     *\ta=rtcp:<port> [nettype addrtype address]\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    rtcp->net_type.slen = rtcp->addr_type.slen = rtcp->addr.slen = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get the port */\n\tpj_scan_get(&scanner, &cs_token, &token);\n\trtcp->port = pj_strtoul(&token);\n\n\t/* Have address? */\n\tif (!pj_scan_is_eof(&scanner)) {\n\n\t    /* Get network type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->net_type);\n\n\t    /* Get address type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->addr_type);\n\n\t    /* Get the address */\n\t    //pj_scan_get(&scanner, &cs_token, &rtcp->addr);\n\t    pj_scan_get_until_chr(&scanner, \"/ \\t\\r\\n\", &rtcp->addr);\n\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTCP;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_rtcp(pj_pool_t *pool,\n\t\t\t\t\t\t       const pj_sockaddr *a)\n{\n    enum {\n\tATTR_LEN = PJ_INET6_ADDRSTRLEN+16\n    };\n    char tmp_addr[PJ_INET6_ADDRSTRLEN];\n    pjmedia_sdp_attr *attr;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"rtcp\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, ATTR_LEN);\n    if (a->addr.sa_family == pj_AF_INET()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP4 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n    } else if (a->addr.sa_family == pj_AF_INET6()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP6 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n\n    } else {\n\tpj_assert(!\"Unsupported address family\");\n\treturn NULL;\n    }\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_ssrc(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_ssrc_attr *ssrc)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"ssrc\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* ssrc BNF:\n     *  a=ssrc:<ssrc-id> <attribute>\n     *\ta=ssrc:<ssrc-id> <attribute>:<value>\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    pj_bzero(ssrc, sizeof(*ssrc));\n\n    /* Parse */\n    PJ_TRY {\n        pj_str_t scan_attr;\n\n\t/* Get the ssrc */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\tssrc->ssrc = pj_strtoul(&token);\n\n    \tpj_scan_get_char(&scanner);\n\tpj_scan_get(&scanner, &cs_token, &scan_attr);\n\t\n\t/* Get cname attribute, if any */\n\tif (!pj_scan_is_eof(&scanner) &&\n\t    pj_scan_get_char(&scanner) == ':' &&\n\t    pj_strcmp2(&scan_attr, \"cname\"))\n\t{\n\t    pj_scan_get(&scanner, &cs_token, &ssrc->cname);\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINSSRC;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_ssrc( pj_pool_t *pool,\n\t\t\t\t\t\t\tpj_uint32_t ssrc,\n\t\t\t\t\t\t\tconst pj_str_t *cname)\n{\n    pjmedia_sdp_attr *attr;\n\n    if (cname->slen == 0)\n        return NULL;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"ssrc\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, cname->slen+7 /* \" cname:\"*/\n    \t\t\t\t\t\t  + 10 /* 32-bit integer */\n    \t\t\t\t\t\t  + 1 /* NULL */);\n    attr->value.slen = pj_ansi_snprintf(attr->value.ptr, cname->slen+18,\n    \t\t\t\t\t\"%u cname:%.*s\", ssrc,\n\t\t\t   \t   \t(int)cname->slen, cname->ptr);\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_to_rtpmap(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_rtpmap **p_rtpmap)\n{\n    PJ_ASSERT_RETURN(pool && attr && p_rtpmap, PJ_EINVAL);\n\n    *p_rtpmap = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_rtpmap);\n    PJ_ASSERT_RETURN(*p_rtpmap, PJ_ENOMEM);\n\n    return pjmedia_sdp_attr_get_rtpmap(attr, *p_rtpmap);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_rtpmap_to_attr(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_rtpmap *rtpmap,\n\t\t\t\t\t       pjmedia_sdp_attr **p_attr)\n{\n    pjmedia_sdp_attr *attr;\n    char tempbuf[128];\n    int len;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && rtpmap && p_attr, PJ_EINVAL);\n\n    /* Check that mandatory attributes are specified. */\n    PJ_ASSERT_RETURN(rtpmap->enc_name.slen && rtpmap->clock_rate,\n\t\t     PJMEDIA_SDP_EINRTPMAP);\n\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    PJ_ASSERT_RETURN(attr != NULL, PJ_ENOMEM);\n\n    attr->name.ptr = \"rtpmap\";\n    attr->name.slen = 6;\n\n    /* Format: \":pt enc_name/clock_rate[/param]\" */\n    len = pj_ansi_snprintf(tempbuf, sizeof(tempbuf), \n\t\t\t   \"%.*s %.*s/%u%s%.*s\",\n\t\t\t   (int)rtpmap->pt.slen,\n\t\t\t   rtpmap->pt.ptr,\n\t\t\t   (int)rtpmap->enc_name.slen,\n\t\t\t   rtpmap->enc_name.ptr,\n\t\t\t   rtpmap->clock_rate,\n\t\t\t   (rtpmap->param.slen ? \"/\" : \"\"),\n\t\t\t   (int)rtpmap->param.slen,\n\t\t\t   rtpmap->param.ptr);\n\n    if (len < 1 || len >= (int)sizeof(tempbuf))\n\treturn PJMEDIA_SDP_ERTPMAPTOOLONG;\n\n    attr->value.slen = len;\n    attr->value.ptr = (char*) pj_pool_alloc(pool, attr->value.slen+1);\n    pj_memcpy(attr->value.ptr, tempbuf, attr->value.slen+1);\n\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic int print_connection_info( pjmedia_sdp_conn *c, char *buf, int len)\n{\n    int printed;\n\n    printed = pj_ansi_snprintf(buf, len, \"c=%.*s %.*s %.*s\\r\\n\",\n\t\t\t       (int)c->net_type.slen,\n\t\t\t       c->net_type.ptr,\n\t\t\t       (int)c->addr_type.slen,\n\t\t\t       c->addr_type.ptr,\n\t\t\t       (int)c->addr.slen,\n\t\t\t       c->addr.ptr);\n    if (printed < 1 || printed >= len)\n\treturn -1;\n\n    return printed;\n}\n\n\nPJ_DEF(pjmedia_sdp_conn*) pjmedia_sdp_conn_clone (pj_pool_t *pool, \n\t\t\t\t\t\t  const pjmedia_sdp_conn *rhs)\n{\n    pjmedia_sdp_conn *c = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_conn);\n    if (!c) return NULL;\n\n    if (!pj_strdup (pool, &c->net_type, &rhs->net_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr_type, &rhs->addr_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr, &rhs->addr)) return NULL;\n\n    return c;\n}\n\nPJ_DEF(pjmedia_sdp_bandw*)\npjmedia_sdp_bandw_clone (pj_pool_t *pool, \n\t\t\t const pjmedia_sdp_bandw *rhs)\n{\n    pjmedia_sdp_bandw *b = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_bandw);\n    if (!b) return NULL;\n\n    if (!pj_strdup (pool, &b->modifier, &rhs->modifier)) return NULL;\n    b->value = rhs->value;\n\n    return b;\n}\n\nstatic pj_ssize_t print_bandw(const pjmedia_sdp_bandw *bandw,\n\t\t\t      char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < bandw->modifier.slen + 10 + 5)\n\treturn -1;\n\n    *p++ = 'b';\n    *p++ = '=';\n    pj_memcpy(p, bandw->modifier.ptr, bandw->modifier.slen);\n    p += bandw->modifier.slen;\n    *p++ = ':';\n    p += pj_utoa(bandw->value, p);\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic pj_ssize_t print_attr(const pjmedia_sdp_attr *attr, \n\t\t\t     char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < attr->name.slen + attr->value.slen + 10)\n\treturn -1;\n\n    *p++ = 'a';\n    *p++ = '=';\n    pj_memcpy(p, attr->name.ptr, attr->name.slen);\n    p += attr->name.slen;\n    \n\n    if (attr->value.slen) {\n\t*p++ = ':';\n\tpj_memcpy(p, attr->value.ptr, attr->value.slen);\n\tp += attr->value.slen;\n    }\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n    }\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\nPJ_DEF(int) pjmedia_sdp_media_print(const pjmedia_sdp_media *media,\n\t\t\t       char *buf, pj_size_t size)\n{\n\treturn print_media_desc(media, buf, size);\n}\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone(\n\t\t\t\t\t\t pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_media);\n    PJ_ASSERT_RETURN(m != NULL, NULL);\n\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    m->desc.port = rhs->desc.port;\n    m->desc.port_count = rhs->desc.port_count;\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    m->desc.fmt_count = rhs->desc.fmt_count;\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    } else {\n\tm->conn = NULL;\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    m->attr_count = rhs->attr_count;\n    for (i=0; i < rhs->attr_count; ++i) {\n\tm->attr[i] = pjmedia_sdp_attr_clone (pool, rhs->attr[i]);\n\tPJ_ASSERT_RETURN(m->attr[i] != NULL, NULL);\n    }\n\n    return m;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst pj_str_t *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find(m->attr_count, m->attr, name, fmt);\n}\n\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr2(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst char *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find2(m->attr_count, m->attr, name, fmt);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_add_attr( pjmedia_sdp_media *m,\n\t\t\t\t\t\tpjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_session_add_attr(pjmedia_sdp_session *s,\n\t\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&s->attr_count, s->attr, attr);\n}\n\nPJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,\n\t\t\t\t\t\t   const char *name)\n{\n    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_remove_attr(pjmedia_sdp_media *m,\n\t\t\t      \t\t\t  pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_remove(&m->attr_count, m->attr, attr);\n}\n\nstatic int print_session(const pjmedia_sdp_session *ses, \n\t\t\t char *buf, pj_ssize_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* Check length for v= and o= lines. */\n    if (len < 5+ \n\t      2+ses->origin.user.slen+18+\n\t      ses->origin.net_type.slen+ses->origin.addr.slen + 2)\n    {\n\treturn -1;\n    }\n\n    /* SDP version (v= line) */\n    pj_memcpy(p, \"v=0\\r\\n\", 5);\n    p += 5;\n\n    /* Owner (o=) line. */\n    *p++ = 'o';\n    *p++ = '=';\n    pj_memcpy(p, ses->origin.user.ptr, ses->origin.user.slen);\n    p += ses->origin.user.slen;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.id, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.version, p);\n    p += printed;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.net_type.ptr, ses->origin.net_type.slen);\n    p += ses->origin.net_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr_type.ptr, ses->origin.addr_type.slen);\n    p += ses->origin.addr_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr.ptr, ses->origin.addr.slen);\n    p += ses->origin.addr.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Session name (s=) line. */\n    if ((end-p)  < 8+ses->name.slen) {\n\treturn -1;\n    }\n    *p++ = 's';\n    *p++ = '=';\n    pj_memcpy(p, ses->name.ptr, ses->name.slen);\n    p += ses->name.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Connection line (c=) if exist. */\n    if (ses->conn) {\n\tprinted = print_connection_info(ses->conn, p, (int)(end-p));\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print optional bandwidth info. */\n    for (i=0; i<ses->bandw_count; ++i) {\n\tprinted = (int)print_bandw(ses->bandw[i], p, end-p);\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Time */\n    if ((end-p) < 24) {\n\treturn -1;\n    }\n    *p++ = 't';\n    *p++ = '=';\n    printed = pj_utoa(ses->time.start, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->time.stop, p);\n    p += printed;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Print all attribute (a=) lines. */\n    for (i=0; i<ses->attr_count; ++i) {\n\tprinted = (int)print_attr(ses->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Print media (m=) lines. */\n    for (i=0; i<ses->media_count; ++i) {\n\tprinted = print_media_desc(ses->media[i], p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\n/******************************************************************************\n * PARSERS\n */\n\nstatic void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* check version is 0 */\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* o= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* username. */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n\n    /* id */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* version */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n}\n\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* t= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* start time */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n\n    pj_scan_get_char(scanner);\n\n    /* stop time */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* get anything until newline (including whitespaces). */\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n\n    /* newline. */\n    pj_scan_get_newline(scanner);\n}\n\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINCONN;\n\n    /* c= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address. */\n    pj_scan_get_until_chr(scanner, \"/ \\t\\r\\n\", &conn->addr);\n    PJ_TODO(PARSE_SDP_CONN_ADDRESS_SUBFIELDS);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINBANDW;\n\n    /* b= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* modifier */\n    pj_scan_get_until_ch(scanner, ':', &bandw->modifier);\n    pj_scan_get_char(scanner);\n\n    /* value */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    bandw->value = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n\n    /* check the equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* m= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* type */\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n\n    /* port */\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\t/* port count */\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n\n    } else {\n\tmed->desc.port_count = 0;\n    }\n\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n\n    /* transport */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n\n    /* format list */\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\n\tpj_scan_get_char(scanner);\n\n\t/* Check again for the end of the line */\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void on_scanner_error(pj_scanner *scanner)\n{\n    PJ_UNUSED_ARG(scanner);\n\n    PJ_THROW(SYNTAX_ERROR);\n}\n\nstatic pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n\n    /* skip a= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    \n    /* get attr name. */\n    pj_scan_get(scanner, &cs_token, &attr->name);\n\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\t/* skip ':' if present. */\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\n\t/* get value */\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n    return attr;\n}\n\n\n/*\n * Apply direction attribute in session to all media.\n */\nstatic void apply_media_direction(pjmedia_sdp_session *sdp)\n{\n    pjmedia_sdp_attr *dir_attr = NULL;\n    unsigned i;\n\n    const pj_str_t inactive = { \"inactive\", 8 };\n    const pj_str_t sendonly = { \"sendonly\", 8 };\n    const pj_str_t recvonly = { \"recvonly\", 8 };\n    const pj_str_t sendrecv = { \"sendrecv\", 8 };\n\n    /* Find direction attribute in session, don't need to find default \n     * direction \"sendrecv\".\n     */\n    for (i = 0; i < sdp->attr_count && !dir_attr; ++i) {\n\tif (!pj_strcmp(&sdp->attr[i]->name, &sendonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &recvonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &inactive)) \n\t{\n\t    dir_attr = sdp->attr[i];\n\t}\n    }\n\n    /* Found the direction attribute */\n    if (dir_attr) {\n\t/* Remove the direction attribute in session */\n\tpjmedia_sdp_attr_remove(&sdp->attr_count, sdp->attr, dir_attr);\n\n\t/* Apply the direction attribute to all media, but not overriding it\n\t * if media already has direction attribute.\n\t */\n\tfor (i = 0; i < sdp->media_count; ++i) {\n\t    pjmedia_sdp_media *m;\n\t    unsigned j;\n\n\t    /* Find direction attribute in this media */\n\t    m = sdp->media[i];\n\t    for (j = 0; j < m->attr_count; ++j) {\n\t\tif (!pj_strcmp(&m->attr[j]->name, &sendrecv) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &sendonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &recvonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &inactive)) \n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Not found, apply direction attribute from session */\n\t    if (j == m->attr_count)\n\t\tpjmedia_sdp_media_add_attr(m, dir_attr);\n\t}\n    }\n}\n\n\n/*\n * Parse SDP message.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_parse( pj_pool_t *pool,\n\t\t\t\t       char *buf, pj_size_t len, \n\t\t\t\t       pjmedia_sdp_session **p_sdp)\n{\n    pj_scanner scanner;\n    pjmedia_sdp_session *session;\n    pjmedia_sdp_media *media = NULL;\n    pjmedia_sdp_attr *attr;\n    pjmedia_sdp_conn *conn;\n    pjmedia_sdp_bandw *bandw;\n    pj_str_t dummy;\n    int cur_name = 254;\n    volatile parse_context ctx;\n    PJ_USE_EXCEPTION;\n\n    ctx.last_error = PJ_SUCCESS;\n\n    init_sdp_parser();\n\n    pj_scan_init(&scanner, buf, len, 0, &on_scanner_error);\n    session = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(session != NULL, PJ_ENOMEM);\n\n    /* Ignore leading newlines */\n    while (*scanner.curptr=='\\r' || *scanner.curptr=='\\n')\n\tpj_scan_get_char(&scanner);\n\n    PJ_TRY {\n\twhile (!pj_scan_is_eof(&scanner)) {\n\t\tcur_name = *scanner.curptr;\n\t\tswitch (cur_name) {\n\t\tcase 'a':\n\t\t    attr = parse_attr(pool, &scanner, &ctx);\n\t\t    if (attr) {\n\t\t\tif (media) {\n\t\t\t    if (media->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_media_add_attr(media, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding media attribute, \"\n\t\t\t\t\t      \"attribute is ignored\"));\n\t\t\t} else {\n\t\t\t    if (session->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_session_add_attr(session, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding session attribute\"\n\t\t\t\t\t      \", attribute is ignored\"));\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 'o':\n\t\t    parse_origin(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 's':\n\t\t    parse_generic_line(&scanner, &session->name, &ctx);\n\t\t    break;\n\t\tcase 'c':\n\t\t    conn = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_conn);\n\t\t    parse_connection_info(&scanner, conn, &ctx);\n\t\t    if (media) {\n\t\t\tmedia->conn = conn;\n\t\t    } else {\n\t\t\tsession->conn = conn;\n\t\t    }\n\t\t    break;\n\t\tcase 't':\n\t\t    parse_time(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 'm':\n\t\t    media = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n\t\t    parse_media(&scanner, media, &ctx);\n\t\t    if (session->media_count < PJMEDIA_MAX_SDP_MEDIA)\n\t\t\tsession->media[ session->media_count++ ] = media;\n\t\t    else\n\t\t\tPJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t     \"Error adding media, media is ignored\"));\n\t\t    break;\n\t\tcase 'v':\n\t\t    parse_version(&scanner, &ctx);\n\t\t    break;\n\t\tcase 13:\n\t\tcase 10:\n\t\t    pj_scan_get_char(&scanner);\n\t\t    /* Allow empty newlines at the end of the message */\n\t\t    while (!pj_scan_is_eof(&scanner)) {\n\t\t\tif (*scanner.curptr != 13 && *scanner.curptr != 10) {\n\t\t\t    ctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\t    on_scanner_error(&scanner);\n\t\t\t}\n\t\t\tpj_scan_get_char(&scanner);\n\t\t    }\n\t\t    break;\n\t\tcase 'b':\n\t\t    bandw = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_bandw);\n\t\t    parse_bandwidth_info(&scanner, bandw, &ctx);\n\t\t    if (media) {\n\t\t\tif (media->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    media->bandw[media->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding media bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    } else {\n\t\t\tif (session->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    session->bandw[session->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding session bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    if (cur_name >= 'a' && cur_name <= 'z')\n\t\t\tparse_generic_line(&scanner, &dummy, &ctx);\n\t\t    else  {\n\t\t\tctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\ton_scanner_error(&scanner);\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\tctx.last_error = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\t\t\n\tPJ_PERROR(4, (THIS_FILE, ctx.last_error,\n\t\t      \"Error parsing SDP in line %d col %d\",\n\t\t      scanner.line, pj_scan_get_col(&scanner)));\n\n\tsession = NULL;\n\n\tpj_assert(ctx.last_error != PJ_SUCCESS);\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n\n    if (session)\n\tapply_media_direction(session);\n\n    *p_sdp = session;\n    return ctx.last_error;\n}\n\n/*\n * Print SDP description.\n */\nPJ_DEF(int) pjmedia_sdp_print( const pjmedia_sdp_session *desc, \n\t\t\t       char *buf, pj_size_t size)\n{\n    return print_session(desc, buf, size);\n}\n\n\n/*\n * Clone session\n */\nPJ_DEF(pjmedia_sdp_session*) pjmedia_sdp_session_clone( pj_pool_t *pool,\n\t\t\t   \t\t\tconst pjmedia_sdp_session *rhs)\n{\n    pjmedia_sdp_session *sess;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    sess = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(sess != NULL, NULL);\n\n    /* Clone origin line. */\n    pj_strdup(pool, &sess->origin.user, &rhs->origin.user);\n    sess->origin.id = rhs->origin.id;\n    sess->origin.version = rhs->origin.version;\n    pj_strdup(pool, &sess->origin.net_type, &rhs->origin.net_type);\n    pj_strdup(pool, &sess->origin.addr_type, &rhs->origin.addr_type);\n    pj_strdup(pool, &sess->origin.addr, &rhs->origin.addr);\n\n    /* Clone subject line. */\n    pj_strdup(pool, &sess->name, &rhs->name);\n\n    /* Clone connection line */\n    if (rhs->conn) {\n\tsess->conn = pjmedia_sdp_conn_clone(pool, rhs->conn);\n\tPJ_ASSERT_RETURN(sess->conn != NULL, NULL);\n    }\n\n    /* Duplicate bandwidth info */\n    sess->bandw_count = rhs->bandw_count;\n    for (i=0; i<rhs->bandw_count; ++i) {\n\tsess->bandw[i] = pjmedia_sdp_bandw_clone(pool, rhs->bandw[i]);\n    }\n\n    /* Clone time line. */\n    sess->time.start = rhs->time.start;\n    sess->time.stop = rhs->time.stop;\n\n    /* Duplicate session attributes. */\n    sess->attr_count = rhs->attr_count;\n    for (i=0; i<rhs->attr_count; ++i) {\n\tsess->attr[i] = pjmedia_sdp_attr_clone(pool, rhs->attr[i]);\n    }\n\n    /* Duplicate media descriptors. */\n    sess->media_count = rhs->media_count;\n    for (i=0; i<rhs->media_count; ++i) {\n\tsess->media[i] = pjmedia_sdp_media_clone(pool, rhs->media[i]);\n    }\n\n    return sess;\n}\n\n\n#define CHECK(exp,ret)\tdo {\t\t\t\\\n\t\t\t    /*pj_assert(exp);*/\t\\\n\t\t\t    if (!(exp))\t\t\\\n\t\t\t\treturn ret;\t\\\n\t\t\t} while (0)\n\n/* Validate SDP connetion info. */\nstatic pj_status_t validate_sdp_conn(const pjmedia_sdp_conn *c)\n{\n    CHECK( c, PJ_EINVAL);\n    CHECK( pj_strcmp2(&c->net_type, \"IN\")==0, PJMEDIA_SDP_EINCONN);\n    CHECK( pj_strcmp2(&c->addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&c->addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINCONN);\n    CHECK( c->addr.slen != 0, PJMEDIA_SDP_EINCONN);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate(const pjmedia_sdp_session *sdp)\n{\n    return pjmedia_sdp_validate2(sdp, PJ_TRUE);\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate2(const pjmedia_sdp_session *sdp,\n\t\t\t\t\t  pj_bool_t strict)\n{\n    unsigned i;\n    const pj_str_t STR_RTPMAP = { \"rtpmap\", 6 };\n\n    CHECK( sdp != NULL, PJ_EINVAL);\n\n    /* Validate origin line. */\n    CHECK( sdp->origin.user.slen != 0, PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.net_type, \"IN\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&sdp->origin.addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( sdp->origin.addr.slen != 0, PJMEDIA_SDP_EINORIGIN);\n\n    /* Validate subject line. */\n    CHECK( sdp->name.slen != 0, PJMEDIA_SDP_EINNAME);\n\n    /* Ignore start and stop time. */\n\n    /* If session level connection info is present, validate it. */\n    if (sdp->conn) {\n\tpj_status_t status = validate_sdp_conn(sdp->conn);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Validate each media. */\n    for (i=0; i<sdp->media_count; ++i) {\n\tconst pjmedia_sdp_media *m = sdp->media[i];\n\tunsigned j;\n\n\t/* Validate the m= line. */\n\tCHECK( m->desc.media.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.transport.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.fmt_count != 0 || m->desc.port==0, PJMEDIA_SDP_ENOFMT);\n\n\t/* If media level connection info is present, validate it. */\n\tif (m->conn) {\n\t    pj_status_t status = validate_sdp_conn(m->conn);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\t}\n\n\t/* If media doesn't have connection info, then connection info\n\t * must be present in the session.\n\t */\n\tif (m->conn == NULL) {\n\t    if (sdp->conn == NULL)\n\t\tif (strict || m->desc.port != 0)\n\t\t    return PJMEDIA_SDP_EMISSINGCONN;\n\t}\n\n\t/* Verify payload type. */\n\tfor (j=0; j<m->desc.fmt_count; ++j) {\n\n\t    /* Arrgh noo!! Payload type can be non-numeric!!\n\t     * RTC based programs sends \"null\" for instant messaging!\n\t     */\n\t    if (pj_isdigit(*m->desc.fmt[j].ptr)) {\n\t\tunsigned long pt;\n\t\tpj_status_t status = pj_strtoul3(&m->desc.fmt[j], &pt, 10);\n\n\t\t/* Payload type is between 0 and 127. \n\t\t */\n\t\tCHECK( status == PJ_SUCCESS && pt <= 127, PJMEDIA_SDP_EINPT);\n\n\t\t/* If port is not zero, then for each dynamic payload type, an\n\t\t * rtpmap attribute must be specified.\n\t\t */\n\t\tif (m->desc.port != 0 && pt >= 96) {\n\t\t    const pjmedia_sdp_attr *a;\n\n\t\t    a = pjmedia_sdp_media_find_attr(m, &STR_RTPMAP, \n\t\t\t\t\t\t    &m->desc.fmt[j]);\n\t\t    CHECK( a != NULL, PJMEDIA_SDP_EMISSINGRTPMAP);\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Looks good. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_transport_cmp( const pj_str_t *t1,\n\t\t\t\t\t       const pj_str_t *t2)\n{\n    pj_uint32_t t1_proto, t2_proto;\n\n    /* Exactly equal? */\n    if (pj_stricmp(t1, t2) == 0)\n\treturn PJ_SUCCESS;\n\n    /* Check if boths are RTP/AVP based */\n    t1_proto = pjmedia_sdp_transport_get_proto(t1);\n    t2_proto = pjmedia_sdp_transport_get_proto(t2);\n    if (PJMEDIA_TP_PROTO_HAS_FLAG(t1_proto, PJMEDIA_TP_PROTO_RTP_AVP) && \n\tPJMEDIA_TP_PROTO_HAS_FLAG(t2_proto, PJMEDIA_TP_PROTO_RTP_AVP))\n    {\n\treturn PJ_SUCCESS;\n    }\n\n    /* Compatible? */\n    //{\n    //\tstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\n    //\tstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n    //\tif ((!pj_stricmp(t1, &ID_RTP_AVP) || !pj_stricmp(t1, &ID_RTP_SAVP)) &&\n    //      (!pj_stricmp(t2, &ID_RTP_AVP) || !pj_stricmp(t2, &ID_RTP_SAVP)))\n    //\t    return PJ_SUCCESS;\n    //}\n\n    return PJMEDIA_SDP_ETPORTNOTEQUAL;\n}\n\n\n/*\n * Get media transport info, e.g: protocol and profile.\n */\nPJ_DEF(pj_uint32_t) pjmedia_sdp_transport_get_proto(const pj_str_t *tp)\n{\n    pj_str_t token, rest = {0};\n    pj_ssize_t idx;\n\n    PJ_ASSERT_RETURN(tp, PJMEDIA_TP_PROTO_NONE);\n\n    idx = pj_strtok2(tp, \"/\", &token, 0);\n    if (idx != tp->slen)\n\tpj_strset(&rest, tp->ptr + token.slen + 1, tp->slen - token.slen - 1);\n\n    if (pj_stricmp2(&token, \"RTP\") == 0) {\n\t/* Starts with \"RTP\" */\n\n\t/* RTP/AVP */\n\tif (pj_stricmp2(&rest, \"AVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVP;\n\n\t/* RTP/SAVP */\n\tif (pj_stricmp2(&rest, \"SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVP;\n\n\t/* RTP/AVPF */\n\tif (pj_stricmp2(&rest, \"AVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVPF;\n\n\t/* RTP/SAVPF */\n\tif (pj_stricmp2(&rest, \"SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVPF;\n\n    } else if (pj_stricmp2(&token, \"UDP\") == 0) {\n\t/* Starts with \"UDP\" */\n\n\t/* Plain UDP */\n\tif (rest.slen == 0)\n\t    return PJMEDIA_TP_PROTO_UDP;\n\n\t/* DTLS-SRTP */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTP;\n\n\t/* DTLS-SRTP with RTCP-FB */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTPF;\n    }\n\n    /* Unknown transport */\n    return PJMEDIA_TP_PROTO_UNKNOWN;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_deactivate(pj_pool_t *pool,\n\t\t\t\t\t\t pjmedia_sdp_media *m)\n{\n    PJ_ASSERT_RETURN(m, PJ_EINVAL);\n    PJ_UNUSED_ARG(pool);\n\n    /* Set port to zero */\n    m->desc.port = 0;\n\n    /* And remove attributes */\n    m->attr_count = 0;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone_deactivate(\n\t\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\t\tconst pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    m = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n    pj_memcpy(m, rhs, sizeof(*m));\n\n    /* Clone the media line only */\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    /* And deactivate it */\n    pjmedia_sdp_media_deactivate(pool, m);\n\n    return m;\n}\n"], "filenames": ["pjmedia/src/pjmedia/sdp.c"], "buggy_code_start_loc": [736], "buggy_code_end_loc": [742], "fixing_code_start_loc": [736], "fixing_code_end_loc": [751], "type": "CWE-120", "message": "PJSIP is a free and open source multimedia communication library written in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`. Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()` or `pjmedia_sdp_media_print()` should not be affected. A patch is available on the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-24764", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-22T17:15:07.870", "lastModified": "2023-02-02T18:30:40.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`. Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()` or `pjmedia_sdp_media_print()` should not be affected. A patch is available on the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en C. Las versiones 2.12 y anteriores contienen una vulnerabilidad de desbordamiento del buffer de la pila que afecta a los usuarios de PJSUA2 o a los que llaman a la API \"pjmedia_sdp_print(), pjmedia_sdp_media_print()\". Las aplicaciones que no usan PJSUA2 y no llaman directamente a \"pjmedia_sdp_print()\" o \"pjmedia_sdp_media_print()\" no deber\u00edan verse afectadas. Se presenta un parche disponible en la rama \"master\" del repositorio \"pjsip/pjproject\" de GitHub. Actualmente no se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}, {"lang": "en", "value": "CWE-121"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.12", "matchCriteriaId": "0BB82CA1-A3B5-4FFB-B6B2-9E5FB840ED07"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/560a1346f87aabe126509bb24930106dea292b00", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-f5qg-pqcg-765m", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/560a1346f87aabe126509bb24930106dea292b00"}}