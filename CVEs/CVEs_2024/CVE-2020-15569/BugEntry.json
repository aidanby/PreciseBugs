{"buggy_code": ["/*\n * Copyright (c) 2009, The MilkyTracker Team.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n * - Neither the name of the <ORGANIZATION> nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n *  PlayerGeneric.cpp\n *  MilkyPlay \n *\n *  PlayerGeneric is a wrapper that allocates a suiting type of player\n *\tfor a module while providing the same player interfaces.\n *\tCurrently there are three types of players: PlayerFAR, PlayerSTD and PlayerIT\n *\n */\n#include \"PlayerGeneric.h\"\n#include \"MasterMixer.h\"\n#include \"XModule.h\"\n#include \"AudioDriver_WAVWriter.h\"\n#include \"AudioDriverManager.h\"\n#include \"PlayerBase.h\"\n#include \"PlayerSTD.h\"\n#ifndef MILKYTRACKER\n#include \"PlayerIT.h\"\n#include \"PlayerFAR.h\"\n#endif\n\n#undef __VERBOSE__\n\nclass MixerNotificationListener : public MasterMixer::MasterMixerNotificationListener\n{\nprivate:\n\tclass PlayerGeneric& player;\n\npublic:\n\tMixerNotificationListener(PlayerGeneric& player) :\n\t\tplayer(player)\n\t{\n\t}\n\n\tvirtual void masterMixerNotification(MasterMixer::MasterMixerNotifications notification)\n\t{\n\t\tplayer.adjustSettings();\n\t}\n};\n\nvoid PlayerGeneric::adjustSettings()\n{\n\tmp_uint32 bufferSize = mixer->getBufferSize();\n\tmp_uint32 sampleRate = mixer->getSampleRate();\n\t\n\tthis->bufferSize = bufferSize;\n\tthis->frequency = sampleRate;\n\t\n\tif (player)\n\t{\n\t\tplayer->setBufferSize(bufferSize);\n\t\tplayer->adjustFrequency(sampleRate);\n\t}\n}\n\nPlayerBase::PlayerTypes PlayerGeneric::getPreferredPlayerType(XModule* module)\n{\n\tif (module == NULL)\n\t\treturn PlayerBase::PlayerType_INVALID;\n\t\t\n\tswitch (module->getType())\n\t{\n\t\tcase XModule::ModuleType_669:\n\t\tcase XModule::ModuleType_FAR:\n#ifndef MILKYTRACKER\n\t\t\treturn PlayerBase::PlayerType_FAR;\n\t\t\tbreak;\n#endif\n\t\tcase XModule::ModuleType_IT:\n#ifndef MILKYTRACKER\n\t\t\treturn PlayerBase::PlayerType_IT;\n\t\t\tbreak;\n#endif\n\t\tcase XModule::ModuleType_UNKNOWN: // just assume our standard player can handle this\n\t\t//case XModule::ModuleType_669:\n\t\tcase XModule::ModuleType_AMF:\n\t\tcase XModule::ModuleType_AMS:\n\t\tcase XModule::ModuleType_CBA:\n\t\tcase XModule::ModuleType_DBM:\n\t\tcase XModule::ModuleType_DIGI:\n\t\tcase XModule::ModuleType_DSM:\n\t\tcase XModule::ModuleType_DSm:\n\t\tcase XModule::ModuleType_DTM_1:\n\t\tcase XModule::ModuleType_DTM_2:\n\t\tcase XModule::ModuleType_GDM:\n\t\tcase XModule::ModuleType_GMC:\n\t\tcase XModule::ModuleType_IMF:\n\t\tcase XModule::ModuleType_MDL:\n\t\tcase XModule::ModuleType_MOD:\n\t\tcase XModule::ModuleType_MTM:\n\t\tcase XModule::ModuleType_MXM:\n\t\tcase XModule::ModuleType_OKT:\n\t\tcase XModule::ModuleType_PLM:\n\t\tcase XModule::ModuleType_PSM:\n\t\tcase XModule::ModuleType_PTM:\n\t\tcase XModule::ModuleType_S3M:\n\t\tcase XModule::ModuleType_STM:\n\t\tcase XModule::ModuleType_SFX:\n\t\tcase XModule::ModuleType_UNI:\n\t\tcase XModule::ModuleType_ULT:\n\t\tcase XModule::ModuleType_XM:\n\t\tcase XModule::ModuleType_NONE:\n\t\t\treturn PlayerBase::PlayerType_Generic;\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\treturn PlayerBase::PlayerType_INVALID;\n\t}\n}\n\nPlayerBase*\tPlayerGeneric::getPreferredPlayer(XModule* module) const\n{\n\tswitch (getPreferredPlayerType(module))\n\t{\n#ifndef MILKYTRACKER\n\t\tcase PlayerBase::PlayerType_FAR:\n\t\t\treturn new PlayerFAR(frequency);\n\t\tcase PlayerBase::PlayerType_IT:\n\t\t\treturn new PlayerIT(frequency);\n#endif\n\t\tcase PlayerBase::PlayerType_Generic:\n\t\t\treturn new PlayerSTD(frequency);\n\t\t\t\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n}\n\nPlayerGeneric::PlayerGeneric(mp_sint32 frequency, AudioDriverInterface* audioDriver/* = NULL*/) :\n\tmixer(NULL),\n\tplayer(NULL),\n\tfrequency(frequency),\n\taudioDriver(audioDriver),\n\taudioDriverName(NULL)\n{\n\tlistener = new MixerNotificationListener(*this);\n\n\tbufferSize = 0;\n\tsampleShift = 0;\n\t\n\tresamplerType = MIXER_NORMAL;\n\n\tidle = false;\n\tplayOneRowOnly = false;\n\tpaused = false;\n\trepeat = false;\n\tresetOnStopFlag = false;\n\tautoAdjustPeak = false;\n\tdisableMixing = false;\n\tallowFilters = false;\n#ifdef __FORCEPOWEROFTWOBUFFERSIZE__\n\tcompensateBufferFlag = true;\n#else\n\tcompensateBufferFlag = false;\n#endif\n\tmasterVolume = panningSeparation = numMaxVirChannels = 256;\n\tresetMainVolumeOnStartPlayFlag = true;\n\tplayMode = PlayMode_Auto;\n\n\t// Special playmode settings\n\toptions[PlayModeOptionPanning8xx] = true;\n\toptions[PlayModeOptionPanningE8x] = false;\n\toptions[PlayModeOptionForcePTPitchLimit] = true;\n\n\tAudioDriverManager audioDriverManager;\n\tconst char* defaultName = audioDriverManager.getPreferredAudioDriver()->getDriverID();\n\tif (defaultName)\n\t{\n\t\taudioDriverName = new char[strlen(defaultName)+1];\n\t\tstrcpy(audioDriverName, defaultName);\n\t}\n}\n\t\nPlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}\n\n// -- wrapping mixer specific stuff ----------------------\nvoid PlayerGeneric::setResamplerType(ResamplerTypes type)\n{\n\tresamplerType = type;\n\tif (player)\n\t\tplayer->setResamplerType(type);\n}\n\nvoid PlayerGeneric::setResamplerType(bool interpolation, bool ramping)\n{\n\tif (interpolation)\n\t{\n\t\tif (ramping)\n\t\t\tresamplerType = MIXER_LERPING_RAMPING;\n\t\telse\n\t\t\tresamplerType = MIXER_LERPING;\n\t}\n\telse\n\t{\n\t\tif (ramping)\n\t\t\tresamplerType = MIXER_NORMAL_RAMPING;\n\t\telse\n\t\t\tresamplerType = MIXER_NORMAL;\n\t}\n\n\tif (player)\n\t\tplayer->setResamplerType(resamplerType);\n}\n\nChannelMixer::ResamplerTypes PlayerGeneric::getResamplerType() const\n{\n\tif (player)\n\t\treturn player->getResamplerType();\n\t\t\n\treturn resamplerType;\n}\n\t\nvoid PlayerGeneric::setSampleShift(mp_sint32 shift)\n{\n\tsampleShift = shift;\n\tif (mixer)\n\t\tmixer->setSampleShift(shift);\n}\n\nmp_sint32 PlayerGeneric::getSampleShift() const\n{\n\tif (mixer)\n\t\treturn mixer->getSampleShift();\n\t\n\treturn sampleShift;\n}\n\nvoid PlayerGeneric::setPeakAutoAdjust(bool b)\n{\n\tthis->autoAdjustPeak = b;\n}\n\nmp_sint32 PlayerGeneric::adjustFrequency(mp_uint32 frequency)\n{\n\tthis->frequency = frequency;\n\t\n\tmp_sint32 res = MP_OK;\n\t\n\tif (mixer)\n\t\tres = mixer->setSampleRate(frequency);\n\t\n\treturn res;\n}\n\nmp_sint32 PlayerGeneric::getMixFrequency() const\n{\n\tif (player)\n\t\treturn player->getMixFrequency();\n\t\t\n\treturn frequency;\n}\n\nmp_sint32 PlayerGeneric::beatPacketsToBufferSize(mp_uint32 numBeats)\n{\n\treturn ChannelMixer::beatPacketsToBufferSize(getMixFrequency(), numBeats);\n}\n\nmp_sint32 PlayerGeneric::adjustBufferSize(mp_uint32 numBeats)\n{\n\treturn setBufferSize(beatPacketsToBufferSize(numBeats));\n}\n\nmp_sint32 PlayerGeneric::setBufferSize(mp_uint32 bufferSize)\n{\n\tmp_sint32 res = 0;\n\t\n\tthis->bufferSize = bufferSize;\n\t\n\tif (mixer)\n\t{\n\t\t// If we're told to compensate the samples until we \n\t\t// we reached 2^n buffer sizes\n\t\tif (compensateBufferFlag)\n\t\t{\n\t\t\tfor (mp_uint32 i = 0; i < 16; i++)\n\t\t\t{\n\t\t\t\tif ((unsigned)(1 << i) >= (unsigned)bufferSize)\n\t\t\t\t{\n\t\t\t\t\tbufferSize = 1 << i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\n\t\tres = mixer->setBufferSize(bufferSize);\n\t}\n\t\n\treturn res;\n}\n\t\nmp_sint32 PlayerGeneric::setPowerOfTwoCompensationFlag(bool b)\n{\n\tif (mixer && compensateBufferFlag != b)\n\t{\n\t\tcompensateBufferFlag = b;\n\t\tsetBufferSize(bufferSize);\n\t}\n\n\treturn MP_OK;\n}\n\nbool PlayerGeneric::getPowerOfTwoCompensationFlag() const\n{\n\treturn compensateBufferFlag;\n}\n\nconst char*\tPlayerGeneric::getCurrentAudioDriverName() const\n{\n\tif (mixer)\n\t\treturn mixer->getCurrentAudioDriverName();\n\n\treturn audioDriverName;\n}\n\t\nbool PlayerGeneric::setCurrentAudioDriverByName(const char* name)\n{\n\tif (name == NULL)\n\t\treturn false;\n\n\tif (mixer)\n\t{\n\t\tbool res = mixer->setCurrentAudioDriverByName(name);\n\n\t\tif (audioDriverName)\n\t\t\tdelete[] audioDriverName;\n\n\t\tconst char* curDrvName = getCurrentAudioDriverName();\n\t\tASSERT(curDrvName);\n\t\taudioDriverName = new char[strlen(curDrvName)+1];\n\t\tstrcpy(audioDriverName, curDrvName);\n\t\treturn res;\n\t}\n\n\tAudioDriverManager audioDriverManager;\n\tif (audioDriverManager.getAudioDriverByName(name))\n\t{\n\t\tif (audioDriverName)\n\t\t\tdelete[] audioDriverName;\n\n\t\taudioDriverName = new char[strlen(name)+1];\n\t\tstrcpy(audioDriverName, name);\t\t\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nbool PlayerGeneric::isInitialized() const\n{\n\tif (mixer)\n\t\treturn mixer->isInitialized();\n\t\t\n\treturn false;\n}\n\nbool PlayerGeneric::isPlaying() const\n{\n\tif (mixer)\n\t\treturn mixer->isPlaying();\n\t\t\n\treturn false;\n}\n\t\nmp_int64 PlayerGeneric::getSampleCounter() const\n{\n\tif (player)\n\t\treturn player->getSampleCounter();\n\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::resetSampleCounter()\n{\n\tif (player)\n\t\tplayer->resetSampleCounter();\n}\n\t\nmp_sint32 PlayerGeneric::getCurrentSamplePosition() const\n{\n\tif (mixer && mixer->getAudioDriver())\n\t\treturn mixer->getAudioDriver()->getBufferPos();\n\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getCurrentBeatIndex()\n{\n\tif (player)\n\t\treturn player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\n\treturn 0;\n}\n\t\nmp_sint32 PlayerGeneric::getCurrentSample(mp_sint32 position, mp_sint32 channel)\n{\n\tif (mixer)\n\t\treturn mixer->getCurrentSample(position, channel);\n\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getCurrentSamplePeak(mp_sint32 position, mp_sint32 channel)\n{\n\tif (mixer)\n\t\treturn mixer->getCurrentSamplePeak(position, channel);\n\n\treturn 0;\n}\n\nvoid PlayerGeneric::resetChannels()\n{\n\tif (player)\n\t\tplayer->resetChannelsFull();\n}\n\nmp_sint32 PlayerGeneric::getNumAllocatedChannels() const\n{\n\tif (player)\n\t\treturn player->getNumAllocatedChannels();\n\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getNumActiveChannels() const\n{\n\tif (player)\n\t\treturn player->getNumActiveChannels();\n\n\treturn 0;\n}\n\n// -- wrapping player specific stuff ----------------------\nvoid PlayerGeneric::setPlayMode(PlayModes mode)\n{\n\tplayMode = mode;\n\tif (player)\n\t\tplayer->setPlayMode(mode);\n}\n\nPlayerGeneric::PlayModes PlayerGeneric::getPlayMode() const\n{\n\tif (player)\n\t\treturn player->getPlayMode();\n\t\t\n\treturn playMode;\n}\n\nvoid PlayerGeneric::enable(PlayModeOptions option, bool b)\n{\n\tASSERT(option>=PlayModeOptionFirst && option<PlayModeOptionLast);\n\toptions[option] = b;\n\t\n\tif (player)\n\t\tplayer->enable(option, b);\n}\n\nbool PlayerGeneric::isEnabled(PlayModeOptions option) const\n{\n\tASSERT(option>=PlayModeOptionFirst && option<PlayModeOptionLast);\n\t\n\tif (!player)\n\t\treturn options[option];\n\telse \n\t\treturn player->isEnabled(option);\n}\n\nvoid PlayerGeneric::restart(mp_uint32 startPosition/* = 0*/, mp_uint32 startRow/* = 0*/, bool resetMixer/* = true*/, const mp_ubyte* customPanningTable/* = NULL*/, bool playOneRowOnly/* = false*/)\n{\n\tif (player)\n\t\tplayer->restart(startPosition, startRow, resetMixer, customPanningTable, playOneRowOnly);\n}\n\nvoid PlayerGeneric::reset()\n{\n\tif (player)\n\t\tplayer->reset();\n}\n\nvoid PlayerGeneric::resetAllSpeed()\n{\n\tif (player)\n\t\tplayer->resetAllSpeed();\n}\n\nmp_sint32 PlayerGeneric::startPlaying(XModule* module, \n\t\t\t\t\t\t\t\t\t  bool repeat/* = false*/, \n\t\t\t\t\t\t\t\t\t  mp_uint32 startPosition/* = 0*/, \n\t\t\t\t\t\t\t\t\t  mp_uint32 startRow/* = 0*/,\n\t\t\t\t\t\t\t\t\t  mp_sint32 numChannels/* = -1*/, \n\t\t\t\t\t\t\t\t\t  const mp_ubyte* customPanningTable/* = NULL*/,\n\t\t\t\t\t\t\t\t\t  bool idle/* = false*/,\n\t\t\t\t\t\t\t\t\t  mp_sint32 patternIndex/* = -1*/,\n\t\t\t\t\t\t\t\t\t  bool playOneRowOnly/* = false*/)\n{\n\tthis->idle = idle;\n\tthis->repeat = repeat;\n\tthis->playOneRowOnly = playOneRowOnly;\n\n\tif (mixer == NULL)\n\t{\n\t\tmixer = new MasterMixer(frequency, bufferSize, 1, audioDriver);\n\t\tmixer->setMasterMixerNotificationListener(listener);\n\t\tmixer->setSampleShift(sampleShift);\n\t\tif (audioDriver == NULL)\n\t\t\tmixer->setCurrentAudioDriverByName(audioDriverName);\n\t}\n\n\tif (!player || player->getType() != getPreferredPlayerType(module))\n\t{\n\t\tif (player)\n\t\t{\n\t\t\tif (!mixer->isDeviceRemoved(player))\n\t\t\t\tmixer->removeDevice(player);\n\t\t\tdelete player;\n\t\t}\n\t\t\n\t\tplayer = getPreferredPlayer(module);\n\t\t\n\t\tif (player)\n\t\t{\n\t\t\t// apply our own \"state\" to the state of the newly allocated player\n\t\t\tplayer->resetMainVolumeOnStartPlay(resetMainVolumeOnStartPlayFlag);\n\t\t\tplayer->resetOnStop(resetOnStopFlag);\n\t\t\tplayer->setBufferSize(bufferSize);\n\t\t\tplayer->setResamplerType(resamplerType);\n\t\t\tplayer->setMasterVolume(masterVolume);\n\t\t\tplayer->setPanningSeparation(panningSeparation);\n\t\t\tplayer->setPlayMode(playMode);\n\n\t\t\tfor (mp_sint32 i = PlayModeOptionFirst; i < PlayModeOptionLast; i++)\n\t\t\t\tplayer->enable((PlayModeOptions)i, options[i]);\t\t\t\n\t\t\t\n\t\t\tplayer->setDisableMixing(disableMixing);\n\t\t\tplayer->setAllowFilters(allowFilters);\n\t\t\t//if (paused)\n\t\t\t//\tplayer->pausePlaying();\n\n\t\t\t// adjust number of virtual channels if necessary\n\t\t\tsetNumMaxVirChannels(numMaxVirChannels);\n\t\t}\t\t\n\t}\n\t\n\tif (player && mixer)\n\t{\n\t\tif (!mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\t\t\n\t\tplayer->startPlaying(module, repeat, startPosition, startRow, numChannels, customPanningTable, idle, patternIndex, playOneRowOnly);\n\t\t\n\t\tmixer->addDevice(player);\n\t\t\n\t\tif (!mixer->isPlaying())\n\t\t\treturn mixer->start();\n\t}\n\n\n\treturn MP_OK;\n}\n\nvoid PlayerGeneric::setPatternToPlay(mp_sint32 patternIndex)\n{\n\tif (player)\n\t\tplayer->setPatternToPlay(patternIndex);\n}\n\nmp_sint32 PlayerGeneric::stopPlaying()\n{\n\tif (player)\n\t\tplayer->stopPlaying();\n\n\tif (mixer)\n\t\treturn mixer->stop();\n\t\t\n\treturn MP_OK;\n}\n\nbool PlayerGeneric::hasSongHalted() const\n{\n\tif (player)\n\t\treturn player->hasSongHalted();\n\t\t\n\treturn true;\n}\n\nvoid PlayerGeneric::setIdle(bool idle)\n{\n\tthis->idle = idle;\n\tif (player)\n\t\tplayer->setIdle(idle);\n}\n\nbool PlayerGeneric::isIdle() const\n{\n\tif (player)\n\t\treturn player->isIdle();\n\t\t\n\treturn idle;\n}\n\nvoid PlayerGeneric::setRepeat(bool repeat)\n{\n\tthis->repeat = repeat;\n\tif (player)\n\t\tplayer->setRepeat(repeat);\n}\n\nbool PlayerGeneric::isRepeating() const\n{\n\tif (player)\n\t\treturn player->isRepeating();\n\t\t\n\treturn repeat;\n}\n\t\nmp_sint32 PlayerGeneric::pausePlaying()\n{\n\tpaused = true;\n\tif (mixer)\n\t\treturn mixer->pause();\n\t\t\n\treturn MP_OK;\n}\n\nmp_sint32 PlayerGeneric::resumePlaying()\n{\n\tif (player && !player->isPlaying())\n\t\tplayer->resumePlaying();\n\n\tif (mixer && mixer->isPaused())\n\t\treturn mixer->resume();\n\telse if (mixer && !mixer->isPlaying())\n\t\treturn mixer->start();\n\n\treturn MP_OK;\n}\n\nbool PlayerGeneric::isPaused() const\n{\n\tif (mixer)\n\t\treturn mixer->isPaused();\n\t\t\n\treturn paused;\n}\n\nvoid PlayerGeneric::setDisableMixing(bool b)\n{\n\tdisableMixing = b;\n\n\tif (player)\n\t\tplayer->setDisableMixing(disableMixing);\n}\n\nvoid PlayerGeneric::setAllowFilters(bool b)\n{\n\tallowFilters = b;\n\n\tif (player)\n\t\tplayer->setAllowFilters(allowFilters);\n}\n\nbool PlayerGeneric::getAllowFilters() const\n{\n\tif (player)\n\t\treturn player->getAllowFilters();\n\t\t\n\treturn allowFilters;\n}\n\n// volume control\nvoid PlayerGeneric::setMasterVolume(mp_sint32 vol)\n{\n\tmasterVolume = vol;\n\tif (player)\n\t\tplayer->setMasterVolume(vol);\n}\n\nmp_sint32 PlayerGeneric::getMasterVolume() const\n{\n\tif (player)\n\t\treturn player->getMasterVolume();\n\t\t\n\treturn masterVolume;\n}\n\n// panning control\nvoid PlayerGeneric::setPanningSeparation(mp_sint32 separation)\n{\n\tpanningSeparation = separation;\n\tif (player)\n\t\tplayer->setPanningSeparation(separation);\n}\n\nmp_sint32 PlayerGeneric::getPanningSeparation() const\n{\n\tif (player)\n\t\treturn player->getPanningSeparation();\n\t\t\n\treturn panningSeparation;\n}\n\nmp_sint32 PlayerGeneric::getSongMainVolume() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getSongMainVolume(index);\n\t}\n\t\n\treturn 255;\n}\n\nmp_sint32 PlayerGeneric::getRow() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getRow(index);\n\t}\n\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getOrder() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getOrder(index);\n\t}\n\t\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::getPosition(mp_sint32& order, mp_sint32& row) const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\t\n\t\tplayer->getPosition(order, row, index);\n\t\treturn;\n\t}\n\t\n\torder = row = 0;\n}\n\nmp_sint32 PlayerGeneric::getLastUnvisitedPosition() const\n{\n\tif (player)\n\t\treturn player->getLastUnvisitedPosition();\n\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::getPosition(mp_sint32& order, mp_sint32& row, mp_sint32& ticker) const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\tplayer->getPosition(order, row, ticker, index);\n\t\treturn;\n\t}\n\t\n\torder = row = ticker = 0;\n}\n\nmp_int64 PlayerGeneric::getSyncCount() const\n{\n\tif (player)\n\t\treturn player->getSyncCount();\n\t\t\n\treturn 0;\n}\n\nmp_uint32 PlayerGeneric::getSyncSampleCounter() const\n{\n\tif (player)\n\t\treturn player->getSyncSampleCounter();\n\t\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::nextPattern()\n{\n\tif (player)\n\t\tplayer->nextPattern();\n}\n\nvoid PlayerGeneric::lastPattern()\n{\n\tif (player)\n\t\tplayer->lastPattern();\n}\n\nvoid PlayerGeneric::setPatternPos(mp_uint32 pos, mp_uint32 row/* = 0*/, bool resetChannels/* = true*/, bool resetFXMemory/* = true*/)\n{\n\tif (player)\n\t\tplayer->setPatternPos(pos, row, resetChannels, resetFXMemory);\n}\n\nmp_sint32 PlayerGeneric::getTempo() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getTempo(index);\n\t}\n\t\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getSpeed() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getSpeed(index);\n\t}\n\t\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::resetOnStop(bool b) \n{\n\tresetOnStopFlag = b;\n\tif (player)\n\t\tplayer->resetOnStop(b); \n}\n\nvoid PlayerGeneric::resetMainVolumeOnStartPlay(bool b)\n{\n\tresetMainVolumeOnStartPlayFlag = b;\n\tif (player)\n\t\tplayer->resetMainVolumeOnStartPlay(b); \n}\n\nstruct PeakAutoAdjustFilter : public Mixable\n{\n\tmp_uint32 mixerShift;\n\tmp_uint32 masterVolume;\n\tmp_sint32 lastPeakValue;\n\t\n\tPeakAutoAdjustFilter() : \n\t\tmixerShift(0),\n\t\tmasterVolume(256),\n\t\tlastPeakValue(0)\n\t{\n\t}\n\t\n\tvirtual void mix(mp_sint32* buffer, mp_uint32 bufferSize)\n\t{\n\t\tconst mp_sint32* buffer32 = buffer;\n\t\t\n\t\tfor (mp_uint32 i = 0; i < bufferSize*MP_NUMCHANNELS; i++)\n\t\t{\n\t\t\tmp_sint32 b = *buffer32++;\n\t\t\t\n\t\t\tif (abs(b) > lastPeakValue)\n\t\t\t\tlastPeakValue = abs(b);\t\t\t\t\t\n\t\t}\n\t}\n\t\n\tvoid calculateMasterVolume()\n\t{\n\t\tif (lastPeakValue)\n\t\t{\n\t\t\tfloat v = 32768.0f*(1<<mixerShift) / (float)lastPeakValue;\n\t\t\tmasterVolume = (mp_sint32)((float)masterVolume*v);\n\t\t\tif (masterVolume > 256)\n\t\t\t\tmasterVolume = 256;\n\t\t}\n\t}\n};\n\n// export to 16bit stereo WAV\nmp_sint32 PlayerGeneric::exportToWAV(const SYSCHAR* fileName, XModule* module, \n\t\t\t\t\t\t\t\t\t mp_sint32 startOrder/* = 0*/, mp_sint32 endOrder/* = -1*/, \n\t\t\t\t\t\t\t\t\t const mp_ubyte* mutingArray/* = NULL*/, mp_uint32 mutingNumChannels/* = 0*/,\n\t\t\t\t\t\t\t\t\t const mp_ubyte* customPanningTable/* = NULL*/,\n\t\t\t\t\t\t\t\t\t AudioDriverBase* preferredDriver/* = NULL*/,\n\t\t\t\t\t\t\t\t\t mp_sint32* timingLUT/* = NULL*/)\n{\n\tPlayerBase* player = NULL;\n\t\n\tAudioDriverBase* wavWriter = preferredDriver;\n\tbool isWAVWriterDriver = false;\n\t\n\tif (wavWriter == NULL)\n\t{\n\t\twavWriter = new WAVWriter(fileName);\n\t\tisWAVWriterDriver = true;\n\t\n\t\tif (!static_cast<WAVWriter*>(wavWriter)->isOpen())\n\t\t{\n\t\t\tdelete wavWriter;\n\t\t\treturn MP_DEVICE_ERROR;\n\t\t}\n\t}\n\t\n\tMasterMixer mixer(frequency, bufferSize, 1, wavWriter);\n\tmixer.setSampleShift(sampleShift);\n\tmixer.setDisableMixing(disableMixing);\n\t\n\tplayer = getPreferredPlayer(module);\n\t\n\tPeakAutoAdjustFilter filter;\n\tif (autoAdjustPeak)\n\t\tmixer.setFilterHook(&filter);\n\t\t\n\tif (player)\n\t{\n\t\tplayer->adjustFrequency(frequency);\n\t\tplayer->resetOnStop(resetOnStopFlag);\n\t\tplayer->setBufferSize(bufferSize);\n\t\tplayer->setResamplerType(resamplerType);\n\t\tplayer->setMasterVolume(masterVolume);\n\t\tplayer->setPlayMode(playMode);\n\t\tplayer->setDisableMixing(disableMixing);\n\t\tplayer->setAllowFilters(allowFilters);\t\t\n#ifndef MILKYTRACKER\n\t\tif (player->getType() == PlayerBase::PlayerType_IT)\n\t\t{\n\t\t\tstatic_cast<PlayerIT*>(player)->setNumMaxVirChannels(numMaxVirChannels);\n\t\t}\n#endif\n\t\tmixer.addDevice(player);\n\t}\n\n\tif (player)\n\t{\n\t\tif (mutingArray && mutingNumChannels > 0 && mutingNumChannels <= module->header.channum)\n\t\t{\n\t\t\tfor (mp_uint32 i = 0; i < mutingNumChannels; i++)\n\t\t\t\tplayer->muteChannel(i, mutingArray[i] == 1);\n\t\t}\n\t\tplayer->startPlaying(module, false, startOrder, 0, -1, customPanningTable, false, -1);\n\t\t\n\t\tmixer.start();\n\t}\n\n\tif (endOrder == -1 || endOrder < startOrder || endOrder > module->header.ordnum - 1)\n\t\tendOrder = module->header.ordnum - 1;\t\t\n\n\tmp_sint32 curOrderPos = startOrder;\n\tif (timingLUT)\n\t{\n\t\tfor (mp_sint32 i = 0; i < module->header.ordnum; i++)\n\t\t\ttimingLUT[i] = -1;\n\t\t\n\t\ttimingLUT[curOrderPos] = 0;\n\t}\n\n\twhile (!player->hasSongHalted() && player->getOrder(0) <= endOrder)\n\t{\n\t\twavWriter->advance();\n\n\t\tif (player->getOrder(0) != curOrderPos)\n\t\t{\n#ifdef __VERBOSE__\n\t\t\tprintf(\"%f\\n\", (float)wavWriter->getNumPlayedSamples() / (float)getMixFrequency());\n#endif\n\t\t\tcurOrderPos = player->getOrder(0);\n\t\t\tif (timingLUT && curOrderPos < module->header.ordnum && timingLUT[curOrderPos] == -1)\n\t\t\t\ttimingLUT[curOrderPos] = wavWriter->getNumPlayedSamples();\t\t\t\n\t\t}\n\t}\n\n\tplayer->stopPlaying();\n\t\n\tmixer.stop();\n\t// important step, otherwise destruction of the audio driver will cause\n\t// trouble if the mixer instance is removed from this function's stack \n\t// and trys to access the driver which is no longer existant\n\tmixer.closeAudioDevice();\n\n\t// Sync value\n\tsampleShift = mixer.getSampleShift();\n\tfilter.mixerShift = sampleShift;\n\tfilter.calculateMasterVolume();\n\tmasterVolume = filter.masterVolume;\n\n\tdelete player;\n\n\tmp_sint32 numWrittenSamples = wavWriter->getNumPlayedSamples();\n\t\n\tif (isWAVWriterDriver)\n\t\tdelete wavWriter;\n\n\treturn numWrittenSamples;\n}\n\nbool PlayerGeneric::grabChannelInfo(mp_sint32 chn, TPlayerChannelInfo& channelInfo) const\n{\n\tif (player)\n\t\treturn player->grabChannelInfo(chn, channelInfo);\n\t\t\n\treturn false;\n}\n\nvoid PlayerGeneric::setNumMaxVirChannels(mp_sint32 max)\n{\n\tnumMaxVirChannels = max;\n#ifndef MILKYTRACKER\n\tif (player)\n\t{\n\t\tif (player->getType() == PlayerBase::PlayerType_IT)\n\t\t{\n\t\t\tstatic_cast<PlayerIT*>(player)->setNumMaxVirChannels(max);\n\t\t}\n\t}\n#endif\n}\n\nmp_sint32 PlayerGeneric::getNumMaxVirChannels() const\n{\n#ifndef MILKYTRACKER\n\tif (player)\n\t{\n\t\tif (player->getType() == PlayerBase::PlayerType_IT)\n\t\t{\n\t\t\treturn static_cast<PlayerIT*>(player)->getNumMaxVirChannels();\n\t\t}\n\t}\n#endif\n\treturn numMaxVirChannels;\n}\n\n// milkytracker\nvoid PlayerGeneric::setPanning(mp_ubyte chn, mp_ubyte pan)\n{\n\tif (player)\n\t\tplayer->setPanning(chn, pan);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009, The MilkyTracker Team.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n * - Neither the name of the <ORGANIZATION> nor the names of its contributors\n *   may be used to endorse or promote products derived from this software\n *   without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n *  PlayerGeneric.cpp\n *  MilkyPlay \n *\n *  PlayerGeneric is a wrapper that allocates a suiting type of player\n *\tfor a module while providing the same player interfaces.\n *\tCurrently there are three types of players: PlayerFAR, PlayerSTD and PlayerIT\n *\n */\n#include \"PlayerGeneric.h\"\n#include \"MasterMixer.h\"\n#include \"XModule.h\"\n#include \"AudioDriver_WAVWriter.h\"\n#include \"AudioDriverManager.h\"\n#include \"PlayerBase.h\"\n#include \"PlayerSTD.h\"\n#ifndef MILKYTRACKER\n#include \"PlayerIT.h\"\n#include \"PlayerFAR.h\"\n#endif\n\n#undef __VERBOSE__\n\nclass MixerNotificationListener : public MasterMixer::MasterMixerNotificationListener\n{\nprivate:\n\tclass PlayerGeneric& player;\n\npublic:\n\tMixerNotificationListener(PlayerGeneric& player) :\n\t\tplayer(player)\n\t{\n\t}\n\n\tvirtual void masterMixerNotification(MasterMixer::MasterMixerNotifications notification)\n\t{\n\t\tplayer.adjustSettings();\n\t}\n};\n\nvoid PlayerGeneric::adjustSettings()\n{\n\tmp_uint32 bufferSize = mixer->getBufferSize();\n\tmp_uint32 sampleRate = mixer->getSampleRate();\n\t\n\tthis->bufferSize = bufferSize;\n\tthis->frequency = sampleRate;\n\t\n\tif (player)\n\t{\n\t\tplayer->setBufferSize(bufferSize);\n\t\tplayer->adjustFrequency(sampleRate);\n\t}\n}\n\nPlayerBase::PlayerTypes PlayerGeneric::getPreferredPlayerType(XModule* module)\n{\n\tif (module == NULL)\n\t\treturn PlayerBase::PlayerType_INVALID;\n\t\t\n\tswitch (module->getType())\n\t{\n\t\tcase XModule::ModuleType_669:\n\t\tcase XModule::ModuleType_FAR:\n#ifndef MILKYTRACKER\n\t\t\treturn PlayerBase::PlayerType_FAR;\n\t\t\tbreak;\n#endif\n\t\tcase XModule::ModuleType_IT:\n#ifndef MILKYTRACKER\n\t\t\treturn PlayerBase::PlayerType_IT;\n\t\t\tbreak;\n#endif\n\t\tcase XModule::ModuleType_UNKNOWN: // just assume our standard player can handle this\n\t\t//case XModule::ModuleType_669:\n\t\tcase XModule::ModuleType_AMF:\n\t\tcase XModule::ModuleType_AMS:\n\t\tcase XModule::ModuleType_CBA:\n\t\tcase XModule::ModuleType_DBM:\n\t\tcase XModule::ModuleType_DIGI:\n\t\tcase XModule::ModuleType_DSM:\n\t\tcase XModule::ModuleType_DSm:\n\t\tcase XModule::ModuleType_DTM_1:\n\t\tcase XModule::ModuleType_DTM_2:\n\t\tcase XModule::ModuleType_GDM:\n\t\tcase XModule::ModuleType_GMC:\n\t\tcase XModule::ModuleType_IMF:\n\t\tcase XModule::ModuleType_MDL:\n\t\tcase XModule::ModuleType_MOD:\n\t\tcase XModule::ModuleType_MTM:\n\t\tcase XModule::ModuleType_MXM:\n\t\tcase XModule::ModuleType_OKT:\n\t\tcase XModule::ModuleType_PLM:\n\t\tcase XModule::ModuleType_PSM:\n\t\tcase XModule::ModuleType_PTM:\n\t\tcase XModule::ModuleType_S3M:\n\t\tcase XModule::ModuleType_STM:\n\t\tcase XModule::ModuleType_SFX:\n\t\tcase XModule::ModuleType_UNI:\n\t\tcase XModule::ModuleType_ULT:\n\t\tcase XModule::ModuleType_XM:\n\t\tcase XModule::ModuleType_NONE:\n\t\t\treturn PlayerBase::PlayerType_Generic;\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\treturn PlayerBase::PlayerType_INVALID;\n\t}\n}\n\nPlayerBase*\tPlayerGeneric::getPreferredPlayer(XModule* module) const\n{\n\tswitch (getPreferredPlayerType(module))\n\t{\n#ifndef MILKYTRACKER\n\t\tcase PlayerBase::PlayerType_FAR:\n\t\t\treturn new PlayerFAR(frequency);\n\t\tcase PlayerBase::PlayerType_IT:\n\t\t\treturn new PlayerIT(frequency);\n#endif\n\t\tcase PlayerBase::PlayerType_Generic:\n\t\t\treturn new PlayerSTD(frequency);\n\t\t\t\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n}\n\nPlayerGeneric::PlayerGeneric(mp_sint32 frequency, AudioDriverInterface* audioDriver/* = NULL*/) :\n\tmixer(NULL),\n\tplayer(NULL),\n\tfrequency(frequency),\n\taudioDriver(audioDriver),\n\taudioDriverName(NULL)\n{\n\tlistener = new MixerNotificationListener(*this);\n\n\tbufferSize = 0;\n\tsampleShift = 0;\n\t\n\tresamplerType = MIXER_NORMAL;\n\n\tidle = false;\n\tplayOneRowOnly = false;\n\tpaused = false;\n\trepeat = false;\n\tresetOnStopFlag = false;\n\tautoAdjustPeak = false;\n\tdisableMixing = false;\n\tallowFilters = false;\n#ifdef __FORCEPOWEROFTWOBUFFERSIZE__\n\tcompensateBufferFlag = true;\n#else\n\tcompensateBufferFlag = false;\n#endif\n\tmasterVolume = panningSeparation = numMaxVirChannels = 256;\n\tresetMainVolumeOnStartPlayFlag = true;\n\tplayMode = PlayMode_Auto;\n\n\t// Special playmode settings\n\toptions[PlayModeOptionPanning8xx] = true;\n\toptions[PlayModeOptionPanningE8x] = false;\n\toptions[PlayModeOptionForcePTPitchLimit] = true;\n\n\tAudioDriverManager audioDriverManager;\n\tconst char* defaultName = audioDriverManager.getPreferredAudioDriver()->getDriverID();\n\tif (defaultName)\n\t{\n\t\taudioDriverName = new char[strlen(defaultName)+1];\n\t\tstrcpy(audioDriverName, defaultName);\n\t}\n}\n\t\nPlayerGeneric::~PlayerGeneric()\n{\n\n\tif (player)\n\t{\n\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\t\n\tif (mixer)\n\t\tdelete mixer;\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}\n\n// -- wrapping mixer specific stuff ----------------------\nvoid PlayerGeneric::setResamplerType(ResamplerTypes type)\n{\n\tresamplerType = type;\n\tif (player)\n\t\tplayer->setResamplerType(type);\n}\n\nvoid PlayerGeneric::setResamplerType(bool interpolation, bool ramping)\n{\n\tif (interpolation)\n\t{\n\t\tif (ramping)\n\t\t\tresamplerType = MIXER_LERPING_RAMPING;\n\t\telse\n\t\t\tresamplerType = MIXER_LERPING;\n\t}\n\telse\n\t{\n\t\tif (ramping)\n\t\t\tresamplerType = MIXER_NORMAL_RAMPING;\n\t\telse\n\t\t\tresamplerType = MIXER_NORMAL;\n\t}\n\n\tif (player)\n\t\tplayer->setResamplerType(resamplerType);\n}\n\nChannelMixer::ResamplerTypes PlayerGeneric::getResamplerType() const\n{\n\tif (player)\n\t\treturn player->getResamplerType();\n\t\t\n\treturn resamplerType;\n}\n\t\nvoid PlayerGeneric::setSampleShift(mp_sint32 shift)\n{\n\tsampleShift = shift;\n\tif (mixer)\n\t\tmixer->setSampleShift(shift);\n}\n\nmp_sint32 PlayerGeneric::getSampleShift() const\n{\n\tif (mixer)\n\t\treturn mixer->getSampleShift();\n\t\n\treturn sampleShift;\n}\n\nvoid PlayerGeneric::setPeakAutoAdjust(bool b)\n{\n\tthis->autoAdjustPeak = b;\n}\n\nmp_sint32 PlayerGeneric::adjustFrequency(mp_uint32 frequency)\n{\n\tthis->frequency = frequency;\n\t\n\tmp_sint32 res = MP_OK;\n\t\n\tif (mixer)\n\t\tres = mixer->setSampleRate(frequency);\n\t\n\treturn res;\n}\n\nmp_sint32 PlayerGeneric::getMixFrequency() const\n{\n\tif (player)\n\t\treturn player->getMixFrequency();\n\t\t\n\treturn frequency;\n}\n\nmp_sint32 PlayerGeneric::beatPacketsToBufferSize(mp_uint32 numBeats)\n{\n\treturn ChannelMixer::beatPacketsToBufferSize(getMixFrequency(), numBeats);\n}\n\nmp_sint32 PlayerGeneric::adjustBufferSize(mp_uint32 numBeats)\n{\n\treturn setBufferSize(beatPacketsToBufferSize(numBeats));\n}\n\nmp_sint32 PlayerGeneric::setBufferSize(mp_uint32 bufferSize)\n{\n\tmp_sint32 res = 0;\n\t\n\tthis->bufferSize = bufferSize;\n\t\n\tif (mixer)\n\t{\n\t\t// If we're told to compensate the samples until we \n\t\t// we reached 2^n buffer sizes\n\t\tif (compensateBufferFlag)\n\t\t{\n\t\t\tfor (mp_uint32 i = 0; i < 16; i++)\n\t\t\t{\n\t\t\t\tif ((unsigned)(1 << i) >= (unsigned)bufferSize)\n\t\t\t\t{\n\t\t\t\t\tbufferSize = 1 << i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\n\t\tres = mixer->setBufferSize(bufferSize);\n\t}\n\t\n\treturn res;\n}\n\t\nmp_sint32 PlayerGeneric::setPowerOfTwoCompensationFlag(bool b)\n{\n\tif (mixer && compensateBufferFlag != b)\n\t{\n\t\tcompensateBufferFlag = b;\n\t\tsetBufferSize(bufferSize);\n\t}\n\n\treturn MP_OK;\n}\n\nbool PlayerGeneric::getPowerOfTwoCompensationFlag() const\n{\n\treturn compensateBufferFlag;\n}\n\nconst char*\tPlayerGeneric::getCurrentAudioDriverName() const\n{\n\tif (mixer)\n\t\treturn mixer->getCurrentAudioDriverName();\n\n\treturn audioDriverName;\n}\n\t\nbool PlayerGeneric::setCurrentAudioDriverByName(const char* name)\n{\n\tif (name == NULL)\n\t\treturn false;\n\n\tif (mixer)\n\t{\n\t\tbool res = mixer->setCurrentAudioDriverByName(name);\n\n\t\tif (audioDriverName)\n\t\t\tdelete[] audioDriverName;\n\n\t\tconst char* curDrvName = getCurrentAudioDriverName();\n\t\tASSERT(curDrvName);\n\t\taudioDriverName = new char[strlen(curDrvName)+1];\n\t\tstrcpy(audioDriverName, curDrvName);\n\t\treturn res;\n\t}\n\n\tAudioDriverManager audioDriverManager;\n\tif (audioDriverManager.getAudioDriverByName(name))\n\t{\n\t\tif (audioDriverName)\n\t\t\tdelete[] audioDriverName;\n\n\t\taudioDriverName = new char[strlen(name)+1];\n\t\tstrcpy(audioDriverName, name);\t\t\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nbool PlayerGeneric::isInitialized() const\n{\n\tif (mixer)\n\t\treturn mixer->isInitialized();\n\t\t\n\treturn false;\n}\n\nbool PlayerGeneric::isPlaying() const\n{\n\tif (mixer)\n\t\treturn mixer->isPlaying();\n\t\t\n\treturn false;\n}\n\t\nmp_int64 PlayerGeneric::getSampleCounter() const\n{\n\tif (player)\n\t\treturn player->getSampleCounter();\n\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::resetSampleCounter()\n{\n\tif (player)\n\t\tplayer->resetSampleCounter();\n}\n\t\nmp_sint32 PlayerGeneric::getCurrentSamplePosition() const\n{\n\tif (mixer && mixer->getAudioDriver())\n\t\treturn mixer->getAudioDriver()->getBufferPos();\n\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getCurrentBeatIndex()\n{\n\tif (player)\n\t\treturn player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\n\treturn 0;\n}\n\t\nmp_sint32 PlayerGeneric::getCurrentSample(mp_sint32 position, mp_sint32 channel)\n{\n\tif (mixer)\n\t\treturn mixer->getCurrentSample(position, channel);\n\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getCurrentSamplePeak(mp_sint32 position, mp_sint32 channel)\n{\n\tif (mixer)\n\t\treturn mixer->getCurrentSamplePeak(position, channel);\n\n\treturn 0;\n}\n\nvoid PlayerGeneric::resetChannels()\n{\n\tif (player)\n\t\tplayer->resetChannelsFull();\n}\n\nmp_sint32 PlayerGeneric::getNumAllocatedChannels() const\n{\n\tif (player)\n\t\treturn player->getNumAllocatedChannels();\n\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getNumActiveChannels() const\n{\n\tif (player)\n\t\treturn player->getNumActiveChannels();\n\n\treturn 0;\n}\n\n// -- wrapping player specific stuff ----------------------\nvoid PlayerGeneric::setPlayMode(PlayModes mode)\n{\n\tplayMode = mode;\n\tif (player)\n\t\tplayer->setPlayMode(mode);\n}\n\nPlayerGeneric::PlayModes PlayerGeneric::getPlayMode() const\n{\n\tif (player)\n\t\treturn player->getPlayMode();\n\t\t\n\treturn playMode;\n}\n\nvoid PlayerGeneric::enable(PlayModeOptions option, bool b)\n{\n\tASSERT(option>=PlayModeOptionFirst && option<PlayModeOptionLast);\n\toptions[option] = b;\n\t\n\tif (player)\n\t\tplayer->enable(option, b);\n}\n\nbool PlayerGeneric::isEnabled(PlayModeOptions option) const\n{\n\tASSERT(option>=PlayModeOptionFirst && option<PlayModeOptionLast);\n\t\n\tif (!player)\n\t\treturn options[option];\n\telse \n\t\treturn player->isEnabled(option);\n}\n\nvoid PlayerGeneric::restart(mp_uint32 startPosition/* = 0*/, mp_uint32 startRow/* = 0*/, bool resetMixer/* = true*/, const mp_ubyte* customPanningTable/* = NULL*/, bool playOneRowOnly/* = false*/)\n{\n\tif (player)\n\t\tplayer->restart(startPosition, startRow, resetMixer, customPanningTable, playOneRowOnly);\n}\n\nvoid PlayerGeneric::reset()\n{\n\tif (player)\n\t\tplayer->reset();\n}\n\nvoid PlayerGeneric::resetAllSpeed()\n{\n\tif (player)\n\t\tplayer->resetAllSpeed();\n}\n\nmp_sint32 PlayerGeneric::startPlaying(XModule* module, \n\t\t\t\t\t\t\t\t\t  bool repeat/* = false*/, \n\t\t\t\t\t\t\t\t\t  mp_uint32 startPosition/* = 0*/, \n\t\t\t\t\t\t\t\t\t  mp_uint32 startRow/* = 0*/,\n\t\t\t\t\t\t\t\t\t  mp_sint32 numChannels/* = -1*/, \n\t\t\t\t\t\t\t\t\t  const mp_ubyte* customPanningTable/* = NULL*/,\n\t\t\t\t\t\t\t\t\t  bool idle/* = false*/,\n\t\t\t\t\t\t\t\t\t  mp_sint32 patternIndex/* = -1*/,\n\t\t\t\t\t\t\t\t\t  bool playOneRowOnly/* = false*/)\n{\n\tthis->idle = idle;\n\tthis->repeat = repeat;\n\tthis->playOneRowOnly = playOneRowOnly;\n\n\tif (mixer == NULL)\n\t{\n\t\tmixer = new MasterMixer(frequency, bufferSize, 1, audioDriver);\n\t\tmixer->setMasterMixerNotificationListener(listener);\n\t\tmixer->setSampleShift(sampleShift);\n\t\tif (audioDriver == NULL)\n\t\t\tmixer->setCurrentAudioDriverByName(audioDriverName);\n\t}\n\n\tif (!player || player->getType() != getPreferredPlayerType(module))\n\t{\n\t\tif (player)\n\t\t{\n\t\t\tif (!mixer->isDeviceRemoved(player))\n\t\t\t\tmixer->removeDevice(player);\n\t\t\tdelete player;\n\t\t}\n\t\t\n\t\tplayer = getPreferredPlayer(module);\n\t\t\n\t\tif (player)\n\t\t{\n\t\t\t// apply our own \"state\" to the state of the newly allocated player\n\t\t\tplayer->resetMainVolumeOnStartPlay(resetMainVolumeOnStartPlayFlag);\n\t\t\tplayer->resetOnStop(resetOnStopFlag);\n\t\t\tplayer->setBufferSize(bufferSize);\n\t\t\tplayer->setResamplerType(resamplerType);\n\t\t\tplayer->setMasterVolume(masterVolume);\n\t\t\tplayer->setPanningSeparation(panningSeparation);\n\t\t\tplayer->setPlayMode(playMode);\n\n\t\t\tfor (mp_sint32 i = PlayModeOptionFirst; i < PlayModeOptionLast; i++)\n\t\t\t\tplayer->enable((PlayModeOptions)i, options[i]);\t\t\t\n\t\t\t\n\t\t\tplayer->setDisableMixing(disableMixing);\n\t\t\tplayer->setAllowFilters(allowFilters);\n\t\t\t//if (paused)\n\t\t\t//\tplayer->pausePlaying();\n\n\t\t\t// adjust number of virtual channels if necessary\n\t\t\tsetNumMaxVirChannels(numMaxVirChannels);\n\t\t}\t\t\n\t}\n\t\n\tif (player && mixer)\n\t{\n\t\tif (!mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\t\t\n\t\tplayer->startPlaying(module, repeat, startPosition, startRow, numChannels, customPanningTable, idle, patternIndex, playOneRowOnly);\n\t\t\n\t\tmixer->addDevice(player);\n\t\t\n\t\tif (!mixer->isPlaying())\n\t\t\treturn mixer->start();\n\t}\n\n\n\treturn MP_OK;\n}\n\nvoid PlayerGeneric::setPatternToPlay(mp_sint32 patternIndex)\n{\n\tif (player)\n\t\tplayer->setPatternToPlay(patternIndex);\n}\n\nmp_sint32 PlayerGeneric::stopPlaying()\n{\n\tif (player)\n\t\tplayer->stopPlaying();\n\n\tif (mixer)\n\t\treturn mixer->stop();\n\t\t\n\treturn MP_OK;\n}\n\nbool PlayerGeneric::hasSongHalted() const\n{\n\tif (player)\n\t\treturn player->hasSongHalted();\n\t\t\n\treturn true;\n}\n\nvoid PlayerGeneric::setIdle(bool idle)\n{\n\tthis->idle = idle;\n\tif (player)\n\t\tplayer->setIdle(idle);\n}\n\nbool PlayerGeneric::isIdle() const\n{\n\tif (player)\n\t\treturn player->isIdle();\n\t\t\n\treturn idle;\n}\n\nvoid PlayerGeneric::setRepeat(bool repeat)\n{\n\tthis->repeat = repeat;\n\tif (player)\n\t\tplayer->setRepeat(repeat);\n}\n\nbool PlayerGeneric::isRepeating() const\n{\n\tif (player)\n\t\treturn player->isRepeating();\n\t\t\n\treturn repeat;\n}\n\t\nmp_sint32 PlayerGeneric::pausePlaying()\n{\n\tpaused = true;\n\tif (mixer)\n\t\treturn mixer->pause();\n\t\t\n\treturn MP_OK;\n}\n\nmp_sint32 PlayerGeneric::resumePlaying()\n{\n\tif (player && !player->isPlaying())\n\t\tplayer->resumePlaying();\n\n\tif (mixer && mixer->isPaused())\n\t\treturn mixer->resume();\n\telse if (mixer && !mixer->isPlaying())\n\t\treturn mixer->start();\n\n\treturn MP_OK;\n}\n\nbool PlayerGeneric::isPaused() const\n{\n\tif (mixer)\n\t\treturn mixer->isPaused();\n\t\t\n\treturn paused;\n}\n\nvoid PlayerGeneric::setDisableMixing(bool b)\n{\n\tdisableMixing = b;\n\n\tif (player)\n\t\tplayer->setDisableMixing(disableMixing);\n}\n\nvoid PlayerGeneric::setAllowFilters(bool b)\n{\n\tallowFilters = b;\n\n\tif (player)\n\t\tplayer->setAllowFilters(allowFilters);\n}\n\nbool PlayerGeneric::getAllowFilters() const\n{\n\tif (player)\n\t\treturn player->getAllowFilters();\n\t\t\n\treturn allowFilters;\n}\n\n// volume control\nvoid PlayerGeneric::setMasterVolume(mp_sint32 vol)\n{\n\tmasterVolume = vol;\n\tif (player)\n\t\tplayer->setMasterVolume(vol);\n}\n\nmp_sint32 PlayerGeneric::getMasterVolume() const\n{\n\tif (player)\n\t\treturn player->getMasterVolume();\n\t\t\n\treturn masterVolume;\n}\n\n// panning control\nvoid PlayerGeneric::setPanningSeparation(mp_sint32 separation)\n{\n\tpanningSeparation = separation;\n\tif (player)\n\t\tplayer->setPanningSeparation(separation);\n}\n\nmp_sint32 PlayerGeneric::getPanningSeparation() const\n{\n\tif (player)\n\t\treturn player->getPanningSeparation();\n\t\t\n\treturn panningSeparation;\n}\n\nmp_sint32 PlayerGeneric::getSongMainVolume() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getSongMainVolume(index);\n\t}\n\t\n\treturn 255;\n}\n\nmp_sint32 PlayerGeneric::getRow() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getRow(index);\n\t}\n\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getOrder() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getOrder(index);\n\t}\n\t\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::getPosition(mp_sint32& order, mp_sint32& row) const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\t\n\t\tplayer->getPosition(order, row, index);\n\t\treturn;\n\t}\n\t\n\torder = row = 0;\n}\n\nmp_sint32 PlayerGeneric::getLastUnvisitedPosition() const\n{\n\tif (player)\n\t\treturn player->getLastUnvisitedPosition();\n\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::getPosition(mp_sint32& order, mp_sint32& row, mp_sint32& ticker) const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\tplayer->getPosition(order, row, ticker, index);\n\t\treturn;\n\t}\n\t\n\torder = row = ticker = 0;\n}\n\nmp_int64 PlayerGeneric::getSyncCount() const\n{\n\tif (player)\n\t\treturn player->getSyncCount();\n\t\t\n\treturn 0;\n}\n\nmp_uint32 PlayerGeneric::getSyncSampleCounter() const\n{\n\tif (player)\n\t\treturn player->getSyncSampleCounter();\n\t\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::nextPattern()\n{\n\tif (player)\n\t\tplayer->nextPattern();\n}\n\nvoid PlayerGeneric::lastPattern()\n{\n\tif (player)\n\t\tplayer->lastPattern();\n}\n\nvoid PlayerGeneric::setPatternPos(mp_uint32 pos, mp_uint32 row/* = 0*/, bool resetChannels/* = true*/, bool resetFXMemory/* = true*/)\n{\n\tif (player)\n\t\tplayer->setPatternPos(pos, row, resetChannels, resetFXMemory);\n}\n\nmp_sint32 PlayerGeneric::getTempo() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getTempo(index);\n\t}\n\t\t\n\treturn 0;\n}\n\nmp_sint32 PlayerGeneric::getSpeed() const\n{\n\tif (player)\n\t{\n\t\tmp_uint32 index = player->getBeatIndexFromSamplePos(getCurrentSamplePosition());\n\t\treturn player->getSpeed(index);\n\t}\n\t\t\n\treturn 0;\n}\n\nvoid PlayerGeneric::resetOnStop(bool b) \n{\n\tresetOnStopFlag = b;\n\tif (player)\n\t\tplayer->resetOnStop(b); \n}\n\nvoid PlayerGeneric::resetMainVolumeOnStartPlay(bool b)\n{\n\tresetMainVolumeOnStartPlayFlag = b;\n\tif (player)\n\t\tplayer->resetMainVolumeOnStartPlay(b); \n}\n\nstruct PeakAutoAdjustFilter : public Mixable\n{\n\tmp_uint32 mixerShift;\n\tmp_uint32 masterVolume;\n\tmp_sint32 lastPeakValue;\n\t\n\tPeakAutoAdjustFilter() : \n\t\tmixerShift(0),\n\t\tmasterVolume(256),\n\t\tlastPeakValue(0)\n\t{\n\t}\n\t\n\tvirtual void mix(mp_sint32* buffer, mp_uint32 bufferSize)\n\t{\n\t\tconst mp_sint32* buffer32 = buffer;\n\t\t\n\t\tfor (mp_uint32 i = 0; i < bufferSize*MP_NUMCHANNELS; i++)\n\t\t{\n\t\t\tmp_sint32 b = *buffer32++;\n\t\t\t\n\t\t\tif (abs(b) > lastPeakValue)\n\t\t\t\tlastPeakValue = abs(b);\t\t\t\t\t\n\t\t}\n\t}\n\t\n\tvoid calculateMasterVolume()\n\t{\n\t\tif (lastPeakValue)\n\t\t{\n\t\t\tfloat v = 32768.0f*(1<<mixerShift) / (float)lastPeakValue;\n\t\t\tmasterVolume = (mp_sint32)((float)masterVolume*v);\n\t\t\tif (masterVolume > 256)\n\t\t\t\tmasterVolume = 256;\n\t\t}\n\t}\n};\n\n// export to 16bit stereo WAV\nmp_sint32 PlayerGeneric::exportToWAV(const SYSCHAR* fileName, XModule* module, \n\t\t\t\t\t\t\t\t\t mp_sint32 startOrder/* = 0*/, mp_sint32 endOrder/* = -1*/, \n\t\t\t\t\t\t\t\t\t const mp_ubyte* mutingArray/* = NULL*/, mp_uint32 mutingNumChannels/* = 0*/,\n\t\t\t\t\t\t\t\t\t const mp_ubyte* customPanningTable/* = NULL*/,\n\t\t\t\t\t\t\t\t\t AudioDriverBase* preferredDriver/* = NULL*/,\n\t\t\t\t\t\t\t\t\t mp_sint32* timingLUT/* = NULL*/)\n{\n\tPlayerBase* player = NULL;\n\t\n\tAudioDriverBase* wavWriter = preferredDriver;\n\tbool isWAVWriterDriver = false;\n\t\n\tif (wavWriter == NULL)\n\t{\n\t\twavWriter = new WAVWriter(fileName);\n\t\tisWAVWriterDriver = true;\n\t\n\t\tif (!static_cast<WAVWriter*>(wavWriter)->isOpen())\n\t\t{\n\t\t\tdelete wavWriter;\n\t\t\treturn MP_DEVICE_ERROR;\n\t\t}\n\t}\n\t\n\tMasterMixer mixer(frequency, bufferSize, 1, wavWriter);\n\tmixer.setSampleShift(sampleShift);\n\tmixer.setDisableMixing(disableMixing);\n\t\n\tplayer = getPreferredPlayer(module);\n\t\n\tPeakAutoAdjustFilter filter;\n\tif (autoAdjustPeak)\n\t\tmixer.setFilterHook(&filter);\n\t\t\n\tif (player)\n\t{\n\t\tplayer->adjustFrequency(frequency);\n\t\tplayer->resetOnStop(resetOnStopFlag);\n\t\tplayer->setBufferSize(bufferSize);\n\t\tplayer->setResamplerType(resamplerType);\n\t\tplayer->setMasterVolume(masterVolume);\n\t\tplayer->setPlayMode(playMode);\n\t\tplayer->setDisableMixing(disableMixing);\n\t\tplayer->setAllowFilters(allowFilters);\t\t\n#ifndef MILKYTRACKER\n\t\tif (player->getType() == PlayerBase::PlayerType_IT)\n\t\t{\n\t\t\tstatic_cast<PlayerIT*>(player)->setNumMaxVirChannels(numMaxVirChannels);\n\t\t}\n#endif\n\t\tmixer.addDevice(player);\n\t}\n\n\tif (player)\n\t{\n\t\tif (mutingArray && mutingNumChannels > 0 && mutingNumChannels <= module->header.channum)\n\t\t{\n\t\t\tfor (mp_uint32 i = 0; i < mutingNumChannels; i++)\n\t\t\t\tplayer->muteChannel(i, mutingArray[i] == 1);\n\t\t}\n\t\tplayer->startPlaying(module, false, startOrder, 0, -1, customPanningTable, false, -1);\n\t\t\n\t\tmixer.start();\n\t}\n\n\tif (endOrder == -1 || endOrder < startOrder || endOrder > module->header.ordnum - 1)\n\t\tendOrder = module->header.ordnum - 1;\t\t\n\n\tmp_sint32 curOrderPos = startOrder;\n\tif (timingLUT)\n\t{\n\t\tfor (mp_sint32 i = 0; i < module->header.ordnum; i++)\n\t\t\ttimingLUT[i] = -1;\n\t\t\n\t\ttimingLUT[curOrderPos] = 0;\n\t}\n\n\twhile (!player->hasSongHalted() && player->getOrder(0) <= endOrder)\n\t{\n\t\twavWriter->advance();\n\n\t\tif (player->getOrder(0) != curOrderPos)\n\t\t{\n#ifdef __VERBOSE__\n\t\t\tprintf(\"%f\\n\", (float)wavWriter->getNumPlayedSamples() / (float)getMixFrequency());\n#endif\n\t\t\tcurOrderPos = player->getOrder(0);\n\t\t\tif (timingLUT && curOrderPos < module->header.ordnum && timingLUT[curOrderPos] == -1)\n\t\t\t\ttimingLUT[curOrderPos] = wavWriter->getNumPlayedSamples();\t\t\t\n\t\t}\n\t}\n\n\tplayer->stopPlaying();\n\t\n\tmixer.stop();\n\t// important step, otherwise destruction of the audio driver will cause\n\t// trouble if the mixer instance is removed from this function's stack \n\t// and trys to access the driver which is no longer existant\n\tmixer.closeAudioDevice();\n\n\t// Sync value\n\tsampleShift = mixer.getSampleShift();\n\tfilter.mixerShift = sampleShift;\n\tfilter.calculateMasterVolume();\n\tmasterVolume = filter.masterVolume;\n\n\tdelete player;\n\n\tmp_sint32 numWrittenSamples = wavWriter->getNumPlayedSamples();\n\t\n\tif (isWAVWriterDriver)\n\t\tdelete wavWriter;\n\n\treturn numWrittenSamples;\n}\n\nbool PlayerGeneric::grabChannelInfo(mp_sint32 chn, TPlayerChannelInfo& channelInfo) const\n{\n\tif (player)\n\t\treturn player->grabChannelInfo(chn, channelInfo);\n\t\t\n\treturn false;\n}\n\nvoid PlayerGeneric::setNumMaxVirChannels(mp_sint32 max)\n{\n\tnumMaxVirChannels = max;\n#ifndef MILKYTRACKER\n\tif (player)\n\t{\n\t\tif (player->getType() == PlayerBase::PlayerType_IT)\n\t\t{\n\t\t\tstatic_cast<PlayerIT*>(player)->setNumMaxVirChannels(max);\n\t\t}\n\t}\n#endif\n}\n\nmp_sint32 PlayerGeneric::getNumMaxVirChannels() const\n{\n#ifndef MILKYTRACKER\n\tif (player)\n\t{\n\t\tif (player->getType() == PlayerBase::PlayerType_IT)\n\t\t{\n\t\t\treturn static_cast<PlayerIT*>(player)->getNumMaxVirChannels();\n\t\t}\n\t}\n#endif\n\treturn numMaxVirChannels;\n}\n\n// milkytracker\nvoid PlayerGeneric::setPanning(mp_ubyte chn, mp_ubyte pan)\n{\n\tif (player)\n\t\tplayer->setPanning(chn, pan);\n}\n"], "filenames": ["src/milkyplay/PlayerGeneric.cpp"], "buggy_code_start_loc": [205], "buggy_code_end_loc": [213], "fixing_code_start_loc": [205], "fixing_code_end_loc": [215], "type": "CWE-416", "message": "PlayerGeneric.cpp in MilkyTracker through 1.02.00 has a use-after-free in the PlayerGeneric destructor.", "other": {"cve": {"id": "CVE-2020-15569", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-06T14:15:10.990", "lastModified": "2023-01-27T19:32:16.097", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PlayerGeneric.cpp in MilkyTracker through 1.02.00 has a use-after-free in the PlayerGeneric destructor."}, {"lang": "es", "value": "El archivo PlayerGeneric.cpp en MilkyTracker versiones hasta 1.02.00, presenta un uso de la memoria previamente liberada en el destructor PlayerGeneric"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:milkytracker_project:milkytracker:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.02.00", "matchCriteriaId": "D6B2B628-1D11-4B0B-A84F-3D73B66D455E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/milkytracker/MilkyTracker/commit/7afd55c42ad80d01a339197a2d8b5461d214edaf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00023.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/milkytracker/MilkyTracker/commit/7afd55c42ad80d01a339197a2d8b5461d214edaf"}}