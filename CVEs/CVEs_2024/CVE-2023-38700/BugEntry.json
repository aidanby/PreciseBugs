{"buggy_code": ["import { IrcBridge } from \"./IrcBridge\";\nimport { BridgeRequest, BridgeRequestErr } from \"../models/BridgeRequest\";\nimport {\n    ContentRepo,\n    MatrixUser,\n    MatrixRoom,\n    MembershipQueue,\n    StateLookup,\n    StateLookupEvent,\n    Intent,\n} from \"matrix-appservice-bridge\";\nimport { IrcUser } from \"../models/IrcUser\";\nimport { ActionType, MatrixAction, MatrixMessageEvent } from \"../models/MatrixAction\";\nimport { IrcRoom } from \"../models/IrcRoom\";\nimport { BridgedClient } from \"../irc/BridgedClient\";\nimport { IrcServer } from \"../irc/IrcServer\";\nimport { IrcAction } from \"../models/IrcAction\";\nimport { toIrcLowerCase } from \"../irc/formatting\";\nimport { AdminRoomHandler, parseCommandFromEvent } from \"./AdminRoomHandler\";\nimport { trackChannelAndCreateRoom } from \"./RoomCreation\";\nimport { renderTemplate } from \"../util/Template\";\nimport { trimString } from \"../util/TrimString\";\nimport { messageDiff } from \"../util/MessageDiff\";\n\nasync function reqHandler(req: BridgeRequest, promise: PromiseLike<unknown>|void) {\n    try {\n        const res = await promise;\n        req.resolve(res);\n        return res;\n    }\n    catch (err) {\n        req.reject(err);\n        throw err;\n    }\n}\n\nconst MSG_PMS_DISABLED = \"[Bridge] Sorry, PMs are disabled on this bridge.\";\nconst MSG_PMS_DISABLED_FEDERATION = \"[Bridge] Sorry, PMs are disabled on this bridge over federation.\";\n\nexport interface MatrixHandlerConfig {\n    /* Number of events to store in memory for use in replies. */\n    eventCacheSize: number;\n    /* Length of the source text in a formatted reply message */\n    replySourceMaxLength: number;\n    // How many seconds needs to pass between a message and a reply to it to switch to the long reply format\n    shortReplyTresholdSeconds: number;\n    // Format of replies sent shortly after the original message\n    shortReplyTemplate: string;\n    // Format of replies sent a while after the original message\n    longReplyTemplate: string;\n    // Format of the text explaining why a message is truncated and pastebinned\n    truncatedMessageTemplate: string;\n}\n\nconst DEFAULTS: MatrixHandlerConfig = {\n    eventCacheSize: 4096,\n    replySourceMaxLength: 32,\n    shortReplyTresholdSeconds: 5 * 60,\n    shortReplyTemplate: \"$NICK: $REPLY\",\n    longReplyTemplate: \"<$NICK> \\\"$ORIGINAL\\\" <- $REPLY\",\n    truncatedMessageTemplate: \"(full message at <$URL>)\",\n};\n\nexport interface MatrixEventInvite {\n    room_id: string;\n    state_key: string;\n    sender: string;\n    content: {\n        is_direct?: boolean;\n        membership: \"invite\";\n    };\n    type: string;\n    event_id: string;\n}\n\nexport interface MatrixEventKick {\n    room_id: string;\n    sender: string;\n    state_key: string;\n    content: {\n        reason?: string;\n        membership: \"leave\";\n    };\n    type: string;\n    event_id: string;\n}\n\nexport interface MatrixSimpleMessage {\n    sender: string;\n    event_id: string;\n    content: {\n        body: string;\n    };\n}\n\ninterface MatrixEventLeave {\n    room_id: string;\n    event_id: string;\n    _injected?: boolean;\n}\n\nexport interface OnMemberEventData {\n    _frontier?: boolean;\n    _injected?: boolean;\n    room_id: string;\n    state_key: string;\n    type: string;\n    event_id: string;\n    content: {\n        displayname?: string;\n        membership: string;\n    };\n}\n\ninterface CachedEvent {\n    body: string;\n    sender: string;\n    timestamp: number;\n}\n\nexport class MatrixHandler {\n    private readonly processingInvitesForRooms: {\n        [roomIdUserId: string]: Promise<unknown>;\n    } = {};\n    // maintain a list of room IDs which are being processed invite-wise. This is\n    // required because invites are processed asyncly, so you could get invite->msg\n    // and the message is processed before the room is created.\n    private readonly eventCache: Map<string, CachedEvent> = new Map();\n    private readonly metrics: {[domain: string]: {\n        [metricName: string]: number;\n    };} = {};\n    private readonly mediaUrl: string;\n    private memberTracker?: StateLookup;\n    private adminHandler: AdminRoomHandler;\n    private config: MatrixHandlerConfig = DEFAULTS;\n\n    constructor(\n        private readonly ircBridge: IrcBridge,\n        config: MatrixHandlerConfig|undefined,\n        private readonly membershipQueue: MembershipQueue\n    ) {\n        this.onConfigChanged(config);\n\n        // The media URL to use to transform mxc:// URLs when handling m.room.[file|image]s\n        this.mediaUrl = ircBridge.config.homeserver.media_url || ircBridge.config.homeserver.url;\n        this.adminHandler = new AdminRoomHandler(ircBridge, this);\n    }\n\n    public initialise() {\n        this.memberTracker = new StateLookup({\n            intent: this.ircBridge.getAppServiceBridge().getIntent(),\n            eventTypes: ['m.room.member']\n        });\n    }\n\n    // ===== Matrix Invite Handling =====\n\n    /**\n     * Process a Matrix invite event for an Admin room.\n     * @param {Object} event : The Matrix invite event.\n     * @param {Request} req : The request for this event.\n     * @param {MatrixUser} inviter : The user who invited the bot.\n     */\n    private async handleAdminRoomInvite(req: BridgeRequest, event: {room_id: string}, inviter: MatrixUser) {\n        req.log.info(`Handling invite from ${inviter.getId()} directed to bot.`);\n        // Real MX user inviting BOT to a private chat\n        const mxRoom = new MatrixRoom(event.room_id);\n        await this.membershipQueue.join(event.room_id, undefined, req, true);\n\n        // Do not create an admin room if the room is marked as 'plumbed'\n        const matrixClient = this.ircBridge.getAppServiceBridge().getIntent();\n        const plumbedState = await matrixClient.getStateEvent(event.room_id, 'm.room.plumbing', '', true);\n        if (plumbedState?.status === \"enabled\") {\n            req.log.info(\n                'This room is marked for plumbing (m.room.plumbing.status = \"enabled\"). ' +\n                'Not treating room as admin room.'\n            );\n            return;\n        }\n\n        // clobber any previous admin room ID\n        await this.ircBridge.getStore().storeAdminRoom(mxRoom, inviter.userId);\n    }\n\n    /**\n     * Process a Matrix invite event for an Admin room.\n     * @param {Object} event : The Matrix invite event.\n     * @param {Request} req : The request for this event.\n     * @param {IrcUser} invitedIrcUser : The IRC user the bot invited to a room.\n     */\n    private async handleInviteFromBot(req: BridgeRequest, event: {room_id: string}, invitedIrcUser: IrcUser) {\n        req.log.info(\"Handling invite from bot directed at %s on %s\",\n            invitedIrcUser.server.domain, invitedIrcUser.nick);\n        // Bot inviting VMX to a matrix room which is mapped to IRC. Just make a\n        // matrix user and join the room (we trust the bot, so no additional checks)\n        const mxUser = await this.ircBridge.getMatrixUser(invitedIrcUser);\n        await this.membershipQueue.join(event.room_id, mxUser.getId(), req, true);\n    }\n\n    private async handleInviteFromUser(req: BridgeRequest, event: MatrixEventInvite, invited: IrcUser) {\n        req.log.info(\"Handling invite from user directed at %s on %s\",\n            invited.nick, invited.server.domain);\n        const invitedUser = await this.ircBridge.getMatrixUser(invited);\n        const mxRoom = new MatrixRoom(event.room_id);\n        const intent = this.ircBridge.getAppServiceBridge().getIntent(invitedUser.getId());\n        const mxUser = new MatrixUser(event.sender);\n        // Real MX user inviting VMX to a matrix room for PM chat\n        if (!invited.server.allowsPms()) {\n            req.log.error(\"Accepting invite, and then leaving: This server does not allow PMs.\");\n            await intent.join(event.room_id);\n            await this.ircBridge.sendMatrixAction(mxRoom, invitedUser, new MatrixAction(\n                ActionType.Notice,\n                MSG_PMS_DISABLED\n            ));\n            await intent.leave(event.room_id);\n            return;\n        }\n\n        // If no federated PMs are allowed, check the origin of the PM\n        //  is same the domain as the bridge\n        if (!invited.server.shouldFederatePMs()) {\n            // Matches for the local part (the not-user part)\n            if (mxUser.host !== this.ircBridge.domain) {\n                req.log.error(\n                    \"Accepting invite, and then leaving: This server does not allow federated PMs.\"\n                );\n                await intent.join(event.room_id);\n                await this.ircBridge.sendMatrixAction(mxRoom, invitedUser, new MatrixAction(\n                    ActionType.Notice,\n                    MSG_PMS_DISABLED_FEDERATION\n                ));\n                await intent.leave(event.room_id);\n                return;\n            }\n        }\n        // create a virtual Matrix user for the IRC user\n\n        await this.membershipQueue.join(event.room_id, invitedUser.getId(), req, true);\n        req.log.info(\"Joined %s to room %s\", invitedUser.getId(), event.room_id);\n\n        // check if this room is a PM room or not.\n        const isPmRoom = event.content.is_direct === true;\n\n        if (isPmRoom) {\n            // nick is the channel\n            const ircRoom = new IrcRoom(invited.server, invited.nick);\n            await this.ircBridge.getStore().setPmRoom(\n                ircRoom, mxRoom, event.sender, event.state_key\n            );\n            return;\n        }\n        req.log.warn(`Room ${event.room_id} is not a 1:1 chat`);\n        await intent.kick(event.room_id, invitedUser.getId(), \"Group chat not supported.\");\n    }\n\n    // === Admin room handling ===\n    private async onAdminMessage(req: BridgeRequest, event: MatrixSimpleMessage,\n                                 adminRoom: MatrixRoom): Promise<void> {\n        req.log.info(\"Received admin message from %s\", event.sender);\n\n        const botUser = new MatrixUser(this.ircBridge.appServiceUserId, undefined, false);\n\n        // First call begins tracking, subsequent calls do nothing\n        await this.memberTracker?.trackRoom(adminRoom.getId());\n        const members = ((this.memberTracker?.getState(\n            adminRoom.getId(),\n            \"m.room.member\",\n        ) || []) as Array<StateLookupEvent>).filter((m) =>\n            (m.content as {membership: string}).membership === \"join\"\n        );\n\n        // If an admin room has more than 2 people in it, kick the bot out\n        if (members.length > 2) {\n            req.log.error(\n                `onAdminMessage: admin room has ${members.length}` +\n                ` users instead of just 2; bot will leave`\n            );\n\n            // Notify users in admin room\n            const notice = new MatrixAction(ActionType.Notice,\n                \"There are more than 2 users in this admin room\"\n            );\n            await this.ircBridge.sendMatrixAction(adminRoom, botUser, notice);\n\n            await this.ircBridge.getAppServiceBridge().getIntent(\n                botUser.getId()\n            ).leave(adminRoom.getId());\n            return;\n        }\n\n        await this.adminHandler.onAdminMessage(req, event, adminRoom);\n        return;\n    }\n\n    public async quitUser(req: BridgeRequest, userId: string, clientList: BridgedClient[],\n                          ircServer: IrcServer|null, reason: string) {\n        let clients = clientList;\n        if (ircServer) {\n            // Filter to get the clients for the [specified] server\n            clients = clientList.filter(\n                (bridgedClient) => bridgedClient.server.domain === ircServer.domain\n            );\n        }\n        if (clients.length === 0) {\n            req.log.info(`No bridgedClients for ${userId}`);\n            return \"You are not connected to any networks.\";\n        }\n\n        const intent = this.ircBridge.getAppServiceBridge().getIntent();\n\n        for (const bridgedClient of clients) {\n            req.log.info(\n                `Killing bridgedClient (nick = ${bridgedClient.nick}) for ${bridgedClient.userId}`\n            );\n            if (!bridgedClient.server.config.ircClients.kickOn.userQuit) {\n                req.log.info(\n                    `Not leaving ${userId} from rooms on ${bridgedClient.server.domain}`\n                );\n                await bridgedClient.kill(reason);\n                continue;\n            }\n\n            if (bridgedClient.chanList.size === 0) {\n                req.log.info(\n                    `Bridged client for ${userId} is not in any channels ` +\n                    `on ${bridgedClient.server.domain}`\n                );\n            }\n            else {\n                // Get all rooms that the bridgedClient is in\n                const uniqueRoomIds = new Set<string>();\n                (await Promise.all(\n                    [...bridgedClient.chanList].map(\n                        (channel) => {\n                            return this.ircBridge.getStore().getMatrixRoomsForChannel(\n                                bridgedClient.server, channel\n                            );\n                        }\n                    )\n                    // flatten to a single unqiue set\n                )).forEach((rSet) => rSet.forEach((r) => uniqueRoomIds.add(r.getId())));\n\n                // Don't wait for these to complete\n                Promise.all([...uniqueRoomIds].map(async (roomId) => {\n                    let state: {membership?: string};\n                    try {\n                        state = await intent.getStateEvent(roomId, \"m.room.member\", userId);\n                    }\n                    catch (ex) {\n                        state = {};\n                    }\n                    try {\n                        // Only kick if the state is join or leave, ignore all else.\n                        // https://github.com/matrix-org/matrix-appservice-irc/issues/1163\n                        if (state.membership === \"join\" || state.membership === \"invite\" ) {\n                            await this.membershipQueue.leave(\n                                roomId,\n                                userId,\n                                req,\n                                false,\n                                reason,\n                                this.ircBridge.appServiceUserId\n                            );\n                        }\n                    }\n                    catch (err) {\n                        req.log.error(err);\n                        req.log.warn(\n                            `Could not kick ${bridgedClient.userId} ` +\n                            `from bridged room ${roomId}: ${err.message}`\n                        );\n                    }\n                }));\n            }\n\n            // The success message will effectively be 'Your connection to ... has been lost.`\n            await bridgedClient.kill(reason);\n        }\n\n        return null;\n    }\n\n    /**\n     * Called when the AS receives a new Matrix invite/join/leave event.\n     * @param {Object} event : The Matrix member event.\n     */\n    private _onMemberEvent(req: BridgeRequest, event: OnMemberEventData) {\n        this.memberTracker?.onEvent(event);\n    }\n\n    /**\n     * Called when a Matrix user tries to invite another user into a PM\n     * @param {Object} event : The Matrix invite event.\n     * @param {MatrixUser} inviter : The inviter (sender).\n     * @param {MatrixUser} invitee : The invitee (receiver).\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async handleInviteToPMRoom(req: BridgeRequest, event: MatrixEventInvite,\n                                       inviter: MatrixUser, invitee: MatrixUser): Promise<BridgeRequestErr|null> {\n        // We don't support this\n        req.log.warn(\n            `User ${inviter.getId()} tried to invite ${invitee.getId()} to a PM room. Disconnecting from room`\n        );\n        const store = this.ircBridge.getStore();\n        const [room] = await store.getIrcChannelsForRoomId(event.room_id);\n        await store.removePmRoom(event.room_id);\n        const userId = room.server.getUserIdFromNick(room.channel);\n        const intent = this.ircBridge.getAppServiceBridge().getIntent(userId);\n        await intent.sendMessage(event.room_id, {\n            msgtype: \"m.notice\",\n            body: \"This room has been disconnected from IRC. You cannot invite new users into a IRC PM. \" +\n                  \"Please create a new PM room.\",\n        });\n        await intent.leave(event.room_id);\n        return null;\n    }\n\n    /**\n     * Called when the AS receives a new Matrix invite event.\n     * @param {Object} event : The Matrix invite event.\n     * @param {MatrixUser} inviter : The inviter (sender).\n     * @param {MatrixUser} invitee : The invitee (receiver).\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onInvite(req: BridgeRequest, event: MatrixEventInvite, inviter: MatrixUser, invitee: MatrixUser):\n    Promise<BridgeRequestErr|null> {\n        /*\n        * (MX=Matrix user, VMX=Virtual matrix user, BOT=AS bot)\n        * Valid invite flows:\n        * [1] MX  --invite--> VMX  (starting a PM chat)\n        * [2] bot --invite--> VMX  (invite-only room that the bot is in who is inviting virtuals)\n        * [3] MX  --invite--> BOT  (admin room; auth)\n        * [4] bot --invite--> MX   (bot telling real mx user IRC conn state) - Ignore.\n        * [5] irc --invite--> MX   (real irc user PMing a Matrix user) - Ignore.\n        * [6] MX  --invite--> BOT  (invite to private room to allow bot to bridge) - Ignore.\n        * [7] MX  --invite--> MX   (matrix user inviting another matrix user)\n        */\n        req.log.info(\"onInvite: from=%s to=%s rm=%s id=%s\", event.sender,\n            event.state_key, event.room_id, event.event_id);\n        this._onMemberEvent(req, event);\n\n        // mark this room as being processed in case we simultaneously get\n        // messages for this room (which would fail if we haven't done the\n        // invite yet!)\n        this.processingInvitesForRooms[event.room_id + event.state_key] = req.getPromise();\n        req.getPromise().finally(() => {\n            delete this.processingInvitesForRooms[event.room_id + event.state_key];\n        });\n\n        // Check if this room is known to us.\n        const rooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n        const hasExistingRoom= rooms.length > 1;\n\n        const inviteeIsVirtual = !!this.ircBridge.getServerForUserId(event.state_key);\n        const inviterIsVirtual = !!this.ircBridge.getServerForUserId(event.sender);\n\n        // work out which flow we're dealing with and fork off asap\n        // is the invitee the bot?\n        if (this.ircBridge.appServiceUserId === event.state_key) {\n            if (event.content.is_direct && !hasExistingRoom) {\n                // case [3]\n                // This is a PM invite to the bot.\n                await this.handleAdminRoomInvite(req, event, inviter);\n            }\n            // case[6]\n            // Drop through so the invite stays active, but do not join the room.\n        }\n        else if (!inviterIsVirtual && rooms[0]?.getType() === \"pm\") {\n            // case[7]-pms\n            return this.handleInviteToPMRoom(req, event, inviter, invitee);\n        } // case[7]-groups falls through.\n        // else is the invitee a real matrix user? If they are, there will be no IRC server\n        else if (!inviteeIsVirtual) {\n            // If this is a PM, we need to disconnect it\n            // cases [4], [5]: We cannot accept on behalf of real matrix users, so nop\n            return BridgeRequestErr.ERR_NOT_MAPPED;\n        }\n        else {\n            // cases [1] and [2] : The invitee represents a real IRC user\n            const ircUser = await this.ircBridge.matrixToIrcUser(invitee);\n            // is the invite from the bot?\n            if (this.ircBridge.appServiceUserId === event.sender) {\n                await this.handleInviteFromBot(req, event, ircUser); // case [2]\n            }\n            else { // We check if this is an invite inside the func.\n                await this.handleInviteFromUser(req, event, ircUser); // case [1]\n            }\n        }\n        return null;\n    }\n\n    private async _onJoin(req: BridgeRequest, event: OnMemberEventData, user: MatrixUser):\n    Promise<BridgeRequestErr|null> {\n        req.log.info(\"onJoin: usr=%s rm=%s id=%s\", event.state_key, event.room_id, event.event_id);\n        this._onMemberEvent(req, event);\n        // membershiplists injects leave events when syncing initial membership\n        // lists. We know if this event is injected because this flag is set.\n        const syncKind = event._injected ? \"initial\" : \"incremental\";\n        const promises: Promise<unknown>[] = []; // one for each join request\n\n        if (this.ircBridge.appServiceUserId === user.getId()) {\n            // ignore messages from the bot\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        // is this a tracked channel?\n        let ircRooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n\n        // =========== Bridge Bot Joining ===========\n        // Make sure the bot is joining on all mapped IRC channels\n        ircRooms.forEach((ircRoom) => {\n            this.ircBridge.joinBot(ircRoom);\n        });\n\n        // =========== Client Joining ===========\n        // filter out rooms which don't mirror matrix join parts and are NOT frontier\n        // entries. Frontier entries must ALWAYS be joined else the IRC channel will\n        // not be bridged!\n        ircRooms = ircRooms.filter((room) => {\n            return room.server.shouldSyncMembershipToIrc(\n                syncKind, event.room_id\n            ) || event._frontier;\n        });\n\n        if (ircRooms.length === 0) {\n            req.log.info(\n                \"No tracked channels which mirror joins for this room.\"\n            );\n            return BridgeRequestErr.ERR_NOT_MAPPED;\n        }\n\n        // for each room (which may be on different servers)\n        ircRooms.forEach((room) => {\n            if (room.server.claimsUserId(user.getId())) {\n                req.log.debug(\"%s is a virtual user (claimed by %s)\",\n                    user.getId(), room.server.domain);\n                return;\n            }\n            // get the virtual IRC user for this user\n            promises.push((async () => {\n                let bridgedClient: BridgedClient|null = null;\n                try {\n                    bridgedClient = await this.ircBridge.getBridgedClient(\n                        room.server, user.getId(), (event.content || {}).displayname\n                    );\n                }\n                catch (e) {\n                    req.log.info(`${user.getId()} failed to get a IRC connection.`, e);\n                    if (room.server.config.ircClients.kickOn.ircConnectionFailure) {\n                        // We need to kick on failure to get a client.\n                        req.log.info(`Kicking from room`);\n                        this.incrementMetric(room.server.domain, \"connection_failure_kicks\");\n                        const excluded = room.server.isExcludedUser(user.getId());\n                        await this.membershipQueue.leave(\n                            event.room_id,\n                            user.getId(),\n                            req,\n                            true,\n                            excluded && excluded.kickReason || `IRC connection failure.`,\n                            this.ircBridge.appServiceUserId,\n                        );\n                    }\n                    else {\n                        req.log.info(`Not kicking - disabled in config`);\n                    }\n                }\n\n                if (!bridgedClient || !bridgedClient.userId) {\n                    // For types, drop out early if we don't have a bridgedClient\n                    return;\n                }\n\n                // Check for a displayname change and update nick accordingly.\n                if (event.content &&\n                    event.content.displayname &&\n                    event.content.displayname !== bridgedClient.displayName) {\n                    bridgedClient.displayName = event.content.displayname;\n                    // Changing the nick requires that:\n                    // - the server allows nick changes\n                    // - the nick is not custom\n                    const config = await this.ircBridge.getStore().getIrcClientConfig(\n                        bridgedClient.userId, room.server.domain\n                    );\n                    if (config && room.server.allowsNickChanges() &&\n                        !config.getDesiredNick()\n                    ) {\n                        const intent = this.ircBridge.getAppServiceBridge().getIntent();\n                        // Check that the /profile matches the displayname.\n                        const userProfile = await intent.getProfileInfo(event.state_key, \"displayname\");\n                        // We only want to update the nickname if the profile contains the displayname\n                        if (userProfile.displayname === event.content.displayname) {\n                            try {\n                                const newNick = room.server.getNick(\n                                    bridgedClient.userId, event.content.displayname\n                                );\n                                bridgedClient.changeNick(newNick, false);\n                            }\n                            catch (e) {\n                                req.log.warn(`Didn't change nick on the IRC side: ${e}`);\n                            }\n                        }\n                    }\n                }\n\n                await bridgedClient.joinChannel(room.channel); // join each channel\n            })());\n        });\n\n        // We know ircRooms.length > 1. The only time when this isn't mapped into a Promise\n        // is when there is a virtual user: TODO: clean this up! Control flow is hard.\n        if (promises.length === 0) {\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        await Promise.all(promises);\n        return null;\n    }\n\n    private async _onKick(req: BridgeRequest, event: MatrixEventKick, kicker: MatrixUser, kickee: MatrixUser) {\n        req.log.info(\n            \"onKick %s is kicking/banning %s from %s (reason: %s)\",\n            kicker.getId(), kickee.getId(), event.room_id, event.content.reason || \"none\"\n        );\n        this._onMemberEvent(req, event);\n\n        /*\n        We know this is a Matrix client kicking someone.\n        There are 2 scenarios to consider here:\n        - Matrix on Matrix kicking\n        - Matrix on IRC kicking\n\n        Matrix-Matrix\n        =============\n        __USER A____            ____USER B___\n        |            |          |             |\n        Matrix     vIRC1       Matrix        vIRC2 |     Effect\n        -----------------------------------------------------------------------\n        Kicker                 Kickee              |  vIRC2 parts channel.\n                                                    This avoids potential permission issues\n                                                    in case vIRC1 cannot kick vIRC2 on IRC.\n\n        Matrix-IRC\n        ==========\n        __USER A____            ____USER B___\n        |            |          |             |\n        Matrix      vIRC        IRC       vMatrix  |     Effect\n        -----------------------------------------------------------------------\n        Kicker                            Kickee   |  vIRC tries to kick IRC via KICK command.\n        */\n\n        const ircRooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n        // do we have an active connection for the kickee? This tells us if they are real\n        // or virtual.\n        const kickeeClients = this.ircBridge.getBridgedClientsForUserId(kickee.getId());\n\n        if (kickeeClients.length === 0) {\n            // Matrix on IRC kicking, work out which IRC user to kick.\n            let server = null;\n            for (let i = 0; i < ircRooms.length; i++) {\n                if (ircRooms[i].server.claimsUserId(kickee.getId())) {\n                    server = ircRooms[i].server;\n                    break;\n                }\n            }\n            if (!server) {\n                return; // kicking a bogus user\n            }\n            const kickeeNick = server.getNickFromUserId(kickee.getId());\n            if (!kickeeNick) {\n                return; // bogus virtual user ID\n            }\n            // work out which client will do the kicking\n            const kickerClient = this.ircBridge.getIrcUserFromCache(server, kicker.getId());\n            if (!kickerClient) {\n                // well this is awkward.. whine about it and bail.\n                req.log.warn(\n                    \"%s has no client instance to send kick from. Cannot kick.\",\n                    kicker.getId()\n                );\n                return;\n            }\n            // we may be bridging this matrix room into many different IRC channels, and we want\n            // to kick this user from all of them.\n            for (let i = 0; i < ircRooms.length; i++) {\n                if (ircRooms[i].server.domain !== server.domain) {\n                    return;\n                }\n                kickerClient.kick(\n                    kickeeNick, ircRooms[i].channel,\n                    `Kicked by ${kicker.getId()}` +\n                    (event.content.reason ? ` : ${event.content.reason}` : \"\")\n                );\n            }\n        }\n        else {\n            // Matrix on Matrix kicking: part the channel.\n            const kickeeServerLookup: {[serverDomain: string]: BridgedClient} = {};\n            kickeeClients.forEach((ircClient) => {\n                kickeeServerLookup[ircClient.server.domain] = ircClient;\n            });\n            await Promise.all(ircRooms.map((async (ircRoom) => {\n                // Make the connected IRC client leave the channel.\n                const client = kickeeServerLookup[ircRoom.server.domain];\n                if (!client) {\n                    return; // not connected to this server\n                }\n                // If we aren't joined this will no-op.\n                await client.leaveChannel(\n                    ircRoom.channel,\n                    `Kicked by ${kicker.getId()} ` +\n                    (event.content.reason ? ` : ${event.content.reason}` : \"\")\n                );\n            })));\n        }\n    }\n\n    private async _onLeave(req: BridgeRequest, event: MatrixEventLeave, user: MatrixUser):\n    Promise<BridgeRequestErr|null> {\n        req.log.info(\"onLeave: usr=%s rm=%s id=%s\", user.getId(), event.room_id, event.event_id);\n        // membershiplists injects leave events when syncing initial membership\n        // lists. We know if this event is injected because this flag is set.\n        const syncKind = event._injected ? \"initial\" : \"incremental\";\n\n        if (this.ircBridge.appServiceUserId === user.getId()) {\n            // ignore messages from the bot\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        // do we have an active connection for this user?\n        let clientList = this.ircBridge.getBridgedClientsForUserId(user.getId());\n        // filter out servers which don't mirror matrix join parts (unless it's a kick)\n        clientList = clientList.filter((client) => {\n            return (\n                client.server.shouldSyncMembershipToIrc(syncKind, event.room_id) &&\n                !client.server.claimsUserId(user.getId())\n            ); // not a virtual user\n        });\n\n        const serverLookup: {[serverDomain: string]: BridgedClient} = {};\n        clientList.forEach((ircClient) => {\n            serverLookup[ircClient.server.domain] = ircClient;\n        });\n\n        const store = this.ircBridge.getStore();\n\n        // which channels should the connected client leave?\n        const ircRooms = await store.getIrcChannelsForRoomId(event.room_id);\n\n        if (!ircRooms) {\n            const adminRoom = await store.getAdminRoomById(event.room_id);\n            if (adminRoom) {\n                await store.removeAdminRoom(adminRoom);\n                // The user left the admin room, let's also leave.\n                // XXX: The typing of .leave is wrong, it should\n                // allow undefined.\n                await this.membershipQueue.leave(event.room_id, \"\", req);\n                return null;\n            }\n\n            const pmRoom = await store.getMatrixPmRoomById(event.room_id);\n            if (pmRoom) {\n                await store.removePmRoom(pmRoom.roomId);\n                // The user left the pm room, let's also leave.\n                const members = await this.ircBridge.getAppServiceBridge().getBot().getJoinedMembers(pmRoom.roomId);\n                await Promise.all(Object.keys(members).map((u) => {\n                    this.membershipQueue.leave(event.room_id, u, req);\n                }));\n                return null;\n            }\n\n        }\n\n        // ========== Client Parting ==========\n        // for each room, if we're connected to it, leave the channel.\n        const promises = ircRooms.map(async (ircRoom) => {\n            // Make the connected IRC client leave the channel.\n            const client = serverLookup[ircRoom.server.domain];\n            if (!client) {\n                return; // not connected to this server\n            }\n            // leave it; if we aren't joined this will no-op.\n            await client.leaveChannel(ircRoom.channel);\n        });\n\n        if (promises.length === 0) { // no connected clients\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        // =========== Bridge Bot Parting ===========\n        // For membership list syncing only\n        await Promise.all(ircRooms.map(async (ircRoom) => {\n            const client = serverLookup[ircRoom.server.domain];\n            if (!client) {\n                return; // no client left the room, so no need to recheck part room.\n            }\n            if (!ircRoom.server.isBotEnabled()) {\n                return; // don't do expensive queries needlessly\n            }\n            if (!ircRoom.server.shouldJoinChannelsIfNoUsers()) {\n                if (ircRoom.server.domain) {\n                    // this = IrcBridge\n                    await this.ircBridge.getMemberListSyncer(ircRoom.server).checkBotPartRoom(\n                        ircRoom, req\n                    );\n                }\n            }\n        }));\n        await Promise.all(promises);\n        return null;\n    }\n\n    private async onCommand(req: BridgeRequest, event: MatrixMessageEvent): Promise<BridgeRequestErr|null> {\n        req.log.info(`Handling in-room command from ${event.sender}`);\n        const parseResult = parseCommandFromEvent(event, \"!irc \");\n        if (!parseResult) {\n            throw Error('Cannot handle malformed command');\n        }\n        const intent = this.ircBridge.getAppServiceBridge().getIntent();\n        const { cmd: command, args } = parseResult;\n        // We currently only check the first room.\n        const [targetRoom] = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n        if (command === \"nick\") {\n            const newNick = args[0];\n            if (!(newNick?.length > 0)) {\n                await intent.sendMessage(event.room_id, {\n                    msgtype: \"m.notice\",\n                    body: \"You must specify a valid nickname\",\n                });\n                return BridgeRequestErr.ERR_DROPPED;\n            }\n            // We need to get the context of this room.\n            if (!targetRoom) {\n                await intent.sendMessage(event.room_id, {\n                    'msgtype': 'm.notice',\n                    'body': 'Room is not bridged, cannot set nick without a target server'\n                });\n                return BridgeRequestErr.ERR_NOT_MAPPED;\n            }\n            const bridgedClient = await this.ircBridge.getBridgedClient(targetRoom.server, event.sender);\n            req.log.info(\"Matrix user wants to change nick from %s to %s\", bridgedClient.nick, newNick);\n            try {\n                await bridgedClient.changeNick(newNick, true);\n            }\n            catch (e) {\n                await intent.sendMessage(event.room_id, {\n                    'msgtype': 'm.notice',\n                    'body': `Unable to change nick: ${e.message}`\n                });\n                req.log.warn(`Didn't change nick on the IRC side: ${e}`);\n            }\n            return null;\n        }\n        await intent.sendMessage(event.room_id, {\n            'msgtype': 'm.notice',\n            'body': 'Command not known'\n        });\n        return null;\n    }\n\n    /**\n     * Called when the AS receives a new Matrix Event.\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onMessage(req: BridgeRequest, event: MatrixMessageEvent): Promise<BridgeRequestErr|null> {\n        /*\n        * Valid message flows:\n        * Matrix --> IRC (Bridged communication)\n        * Matrix --> Matrix (Admin room)\n        */\n\n        req.log.info(\"onMessage: %s usr=%s rm=%s id=%s\",\n            event.type, event.sender, event.room_id, event.event_id\n        );\n        if (event.content.body) {\n            req.log.debug(\"Message body: %s\", event.content.body);\n        }\n\n        const mxAction = MatrixAction.fromEvent(\n            event, this.mediaUrl\n        );\n\n        // check if this message is from one of our virtual users\n        const servers = this.ircBridge.getServers();\n        for (let i = 0; i < servers.length; i++) {\n            if (servers[i].claimsUserId(event.sender)) {\n                req.log.debug(\"%s is a virtual user (claimed by %s)\",\n                    event.sender, servers[i].domain);\n                return BridgeRequestErr.ERR_VIRTUAL_USER;\n            }\n        }\n\n\n        if (mxAction.type === \"command\") {\n            return this.onCommand(req, event);\n        }\n\n        const ircAction = IrcAction.fromMatrixAction(mxAction);\n        if (ircAction === null) {\n            req.log.info(\"IrcAction couldn't determine an action type.\");\n            return BridgeRequestErr.ERR_DROPPED;\n        }\n\n        // wait a while if we just got an invite else we may not have the mapping stored\n        // yet...\n        const key = `${event.room_id}+${event.sender}`;\n        if (key in this.processingInvitesForRooms) {\n            req.log.info(\n                \"Holding request for %s until invite for room %s is done.\",\n                event.sender, event.room_id\n            );\n            await this.processingInvitesForRooms[key];\n            req.log.info(\n                \"Finished holding event for %s in room %s\", event.sender, event.room_id\n            );\n        }\n\n        if (this.ircBridge.appServiceUserId === event.sender) {\n            // ignore messages from the bot\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n\n        const ircRooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n\n        // Sometimes bridge's message each other and get stuck in a silly loop. Ensure it's m.text\n        if (ircRooms.length === 0 && event.content && event.content.msgtype === \"m.text\") {\n            // This is used to ensure type safety.\n            const body = event.content.body;\n            if (!body?.trim().length) {\n                return BridgeRequestErr.ERR_DROPPED;\n            }\n            // could be an Admin room, so check.\n            const adminRoom = await this.ircBridge.getStore().getAdminRoomById(event.room_id);\n            if (!adminRoom) {\n                req.log.debug(\"No mapped channels.\");\n                return BridgeRequestErr.ERR_DROPPED;\n            }\n            // process admin request\n            await this.onAdminMessage(req, { ...event, content: { body }}, adminRoom);\n        }\n\n\n        // Check for other matrix rooms which are bridged to this channel.\n        // If there are other rooms, send this message directly to that room as the virtual matrix user.\n        // E.g: send this message to MROOM2 and MROOM3:\n        //\n        // MROOM1            MROOM2             MROOM3\n        //   |                 |                  |\n        //   +->>MSG>>----------------------------+\n        //                 |                  |\n        //                #chan              #chan2\n        //\n        const otherMatrixRoomIdsToServers = Object.create(null);\n        const messageSendPromiseSet: Promise<unknown>[] = [];\n        const fetchRoomsPromiseSet: Promise<unknown>[] = [];\n\n        ircRooms.forEach((ircRoom) => {\n            if (ircRoom.server.claimsUserId(event.sender)) {\n                req.log.debug(\"%s is a virtual user (claimed by %s)\",\n                    event.sender, ircRoom.server.domain);\n                return;\n            }\n            req.log.info(\"Relaying message in %s on %s\",\n                ircRoom.channel, ircRoom.server.domain);\n\n            if (ircRoom.getType() === \"channel\") {\n                fetchRoomsPromiseSet.push((async () => {\n                    const otherMatrixRooms = await this.ircBridge.getStore().getMatrixRoomsForChannel(\n                        ircRoom.server, ircRoom.channel\n                    );\n                    otherMatrixRooms.forEach((mxRoom) => {\n                        otherMatrixRoomIdsToServers[mxRoom.getId()] = ircRoom.server;\n                    });\n                })());\n            }\n\n            // If we already have a cached client then yay, but if we\n            // don't then we need to hit out for their display name in\n            // this room.\n            let bridgedClient = this.ircBridge.getIrcUserFromCache(ircRoom.server, event.sender);\n            if (!bridgedClient) {\n                messageSendPromiseSet.push((async () => {\n                    const intent = this.ircBridge.getAppServiceBridge().getIntent();\n                    const displayName = await intent.getStateEvent(\n                        event.room_id, \"m.room.member\", event.sender\n                    ).catch(err => {\n                        req.log.warn(`Failed to get display name for the room: ${err}`);\n                        return intent.getProfileInfo(event.sender, \"displayname\");\n                    }).then(\n                        res => res.displayname\n                    ).catch(err => {\n                        req.log.error(`Failed to get display name: ${err}`);\n                    });\n                    bridgedClient = await this.ircBridge.getBridgedClient(\n                        ircRoom.server, event.sender, displayName\n                    );\n                    await this.sendIrcAction(req, ircRoom, bridgedClient, ircAction, event);\n                })());\n            }\n            else {\n                // push each request so we don't block processing other rooms\n                messageSendPromiseSet.push(\n                    this.sendIrcAction(req, ircRoom, bridgedClient, ircAction, event),\n                );\n            }\n        });\n        await Promise.all(fetchRoomsPromiseSet);\n        Object.keys(otherMatrixRoomIdsToServers).forEach((roomId) => {\n            if (roomId === event.room_id) {\n                return; // don't bounce back to the sender\n            }\n            const otherServer = otherMatrixRoomIdsToServers[roomId];\n            // convert the sender's user ID to a nick and back to a virtual user for this server\n            // then send from that user ID (yuck!).\n            const n = otherServer.getNick(event.sender);\n            const virtUserId = otherServer.getUserIdFromNick(n);\n            messageSendPromiseSet.push(\n                this.ircBridge.sendMatrixAction(\n                    new MatrixRoom(roomId), new MatrixUser(virtUserId), mxAction\n                )\n            );\n        });\n\n        await Promise.all(messageSendPromiseSet);\n        return null;\n    }\n\n    private async sendIrcAction(req: BridgeRequest, ircRoom: IrcRoom, ircClient: BridgedClient, ircAction: IrcAction,\n                                event: MatrixMessageEvent) {\n        // Send the action as is if it is not a text message\n        if (![\"m.text\", \"m.notice\"].find(msgtype => msgtype === event.content.msgtype) || !event.content.body) {\n            await this.ircBridge.sendIrcAction(ircRoom, ircClient, ircAction);\n            return;\n        }\n\n        let cacheBody = ircAction.text;\n\n        // special handling for replies (and threads)\n        if (event.content[\"m.relates_to\"] && event.content[\"m.relates_to\"][\"m.in_reply_to\"]) {\n            const eventId = event.content[\"m.relates_to\"][\"m.in_reply_to\"].event_id;\n            const reply = await this.textForReplyEvent(event, eventId, ircRoom);\n            if (reply !== null) {\n                ircAction.text = reply.formatted;\n                cacheBody = reply.reply;\n            }\n        }\n\n        // special handling for edits\n        if (event.content[\"m.relates_to\"]?.rel_type === \"m.replace\") {\n            const originalEventId = event.content[\"m.relates_to\"].event_id;\n            let originalBody = this.getCachedEvent(originalEventId)?.body;\n            if (!originalBody) {\n                try {\n                    // FIXME: this will return the new event rather than the original one\n                    // to actually see the original content we'd need to use whatever\n                    // https://github.com/matrix-org/matrix-doc/pull/2675 stabilizes on\n                    let intent: Intent;\n                    if (ircRoom.getType() === \"pm\") {\n                        // no Matrix Bot, use the IRC user's intent\n                        const userId = ircRoom.server.getUserIdFromNick(ircRoom.channel);\n                        intent = this.ircBridge.getAppServiceBridge().getIntent(userId);\n                    }\n                    else {\n                        intent = this.ircBridge.getAppServiceBridge().getIntent();\n                    }\n                    const eventContent = await intent.getEvent(\n                        event.room_id, originalEventId\n                    );\n                    originalBody = eventContent.content.body;\n                }\n                catch (_err) {\n                    req.log.warn(\"Couldn't find an event being edited, using fallback text\");\n                }\n            }\n            const newBody = event.content[\"m.new_content\"]?.body;\n            if (originalBody && newBody) {\n                const diff = messageDiff(originalBody, newBody);\n                if (diff) {\n                    ircAction.text = diff;\n                }\n            }\n        }\n\n        let body = cacheBody.trim().substring(0, this.config.replySourceMaxLength);\n        const nextNewLine = body.indexOf(\"\\n\");\n        if (nextNewLine !== -1) {\n            body = body.substring(0, nextNewLine);\n        }\n        // Cache events in here so we can refer to them for replies.\n        this.cacheEvent(event.event_id, {\n            body: cacheBody,\n            sender: event.sender,\n            timestamp: event.origin_server_ts,\n        });\n\n        // The client might still be connected, for abundance of safety let's wait.\n        await ircClient.waitForConnected();\n\n        // Generate an array of individual messages that would be sent\n        const potentialMessages = ircClient.getSplitMessages(ircRoom.channel, ircAction.text);\n        const roomLineLimit = await this.ircBridge.roomConfigs.getLineLimit(event.room_id, ircRoom);\n        const lineLimit = roomLineLimit === null ? ircRoom.server.getLineLimit() : roomLineLimit;\n\n        if (potentialMessages.length <= lineLimit) {\n            await this.ircBridge.sendIrcAction(ircRoom, ircClient, ircAction);\n            return;\n        }\n\n        // Message body too long, upload to HS instead\n\n        // Use the current ISO datetime as the name of the file\n        //  strip off milliseconds and replace 'T' with an underscore\n        //  result e.g : 2016-08-03T10:40:48.620Z becomes 2016-08-03_10:40:48\n        let fileName = new Date().toISOString()\n            .split(/[T|\\.]/)\n            .splice(0, 2)\n            .join('_') + '.txt';\n\n        // somenick_2016-08-03_10:40:48.txt\n        fileName = ircClient.nick + '_' + fileName;\n\n        let contentUri: string|null = null;\n\n        try {\n            // Try to upload as a file and get URI\n            //  (this could fail, see the catch statement)\n            contentUri = await this.ircBridge.uploadTextFile(fileName, ircAction.text);\n        }\n        catch (err) {\n            // Uploading the file to HS could fail\n            req.log.error(\"Failed to upload text file \", err);\n        }\n\n        // This is true if the upload was a success\n        if (contentUri) {\n            const httpUrl = ContentRepo.getHttpUriForMxc(this.mediaUrl, contentUri);\n            // we check event.content.body since ircAction already has the markers stripped\n            const codeBlockMatch = event.content.body.match(/^```(\\w+)?/);\n            if (codeBlockMatch) {\n                const type = codeBlockMatch[1] ? ` ${codeBlockMatch[1]}` : '';\n                event.content = {\n                    msgtype: \"m.emote\",\n                    body:    `sent a${type} code block: ${httpUrl}`\n                };\n            }\n            else {\n                const explanation = renderTemplate(this.config.truncatedMessageTemplate, { url: httpUrl });\n                let messagePreview = trimString(\n                    potentialMessages[0],\n                    ircClient.getMaxLineLength() - 4 /* \"... \" */ - explanation.length - ircRoom.channel.length\n                );\n                if (potentialMessages.length > 1 || messagePreview.length < potentialMessages[0].length) {\n                    messagePreview += '...';\n                }\n\n                event.content = {\n                    ...event.content,\n                    body: `${messagePreview} ${explanation}`,\n                };\n            }\n\n            const truncatedIrcAction = IrcAction.fromMatrixAction(\n                MatrixAction.fromEvent(event, this.mediaUrl)\n            );\n            if (truncatedIrcAction) {\n                await this.ircBridge.sendIrcAction(ircRoom, ircClient, truncatedIrcAction);\n            }\n        }\n        else {\n            req.log.debug(\"Sending truncated message\");\n            // Modify the event to become a truncated version of the original\n            //  the truncation limits the number of lines sent to lineLimit.\n\n            const msg = '\\n...(truncated)';\n\n            const sendingEvent: MatrixMessageEvent = { ...event,\n                content: {\n                    ...event.content,\n                    body: potentialMessages.splice(0, lineLimit - 1).join('\\n') + msg\n                }\n            };\n\n            // Recreate action from modified event\n            const truncatedIrcAction = IrcAction.fromMatrixAction(\n                MatrixAction.fromEvent(\n                    sendingEvent,\n                    this.mediaUrl,\n                )\n            );\n            if (truncatedIrcAction) {\n                await this.ircBridge.sendIrcAction(ircRoom, ircClient, truncatedIrcAction);\n            }\n        }\n    }\n\n    /**\n     * Called when the AS receives an alias query from the HS.\n     * @param {string} roomAlias : The room alias queried.\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onAliasQuery(req: BridgeRequest, roomAlias: string) {\n        req.log.info(\"onAliasQuery %s\", roomAlias);\n\n        // check if alias maps to a valid IRC server and channel\n        const channelInfo = this.ircBridge.aliasToIrcChannel(roomAlias);\n        if (!channelInfo.channel) {\n            throw new Error(\"Unknown alias: \" + roomAlias); // bad alias\n        }\n        if (!channelInfo.server.createsPublicAliases()) {\n            throw new Error(\"This server does not allow alias mappings.\");\n        }\n        req.log.info(\"Mapped to %s on %s\",\n            channelInfo.channel, channelInfo.server.domain\n        );\n\n        // See if we are already tracking this channel (case-insensitive\n        // channels but case-sensitive aliases)\n        const matrixRooms = await this.ircBridge.getStore().getMatrixRoomsForChannel(\n            channelInfo.server, channelInfo.channel\n        );\n        if (matrixRooms.length === 0) {\n            await trackChannelAndCreateRoom(this.ircBridge, req, {\n                server: channelInfo.server,\n                // lower case the name to join (there's a bug in the IRC lib\n                // where the join callback never fires if you try to join\n                // #WithCaps in channels :/)\n                ircChannel:  toIrcLowerCase(channelInfo.channel),\n                roomAliasName: roomAlias.split(\":\")[0].substring(1), // localpart\n                origin: \"alias\",\n            })\n        }\n        else {\n            // create an alias pointing to this room (take first)\n            // TODO: Take first with public join_rules\n            const roomId = matrixRooms[0].getId();\n            req.log.info(\"Pointing alias %s to %s\", roomAlias, roomId);\n            await this.ircBridge.getAppServiceBridge().getIntent().createAlias(\n                roomAlias, roomId\n            );\n        }\n    }\n\n    /**\n     * Called when the AS receives a user query from the HS.\n     * @param {string} userId : The user ID queried.\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onUserQuery(req: BridgeRequest, userId: string) {\n        if (this.ircBridge.appServiceUserId === userId) {\n            return;\n        }\n        req.log.info(\"onUserQuery: %s\", userId);\n        const matrixUser = new MatrixUser(userId);\n        const ircUser = await this.ircBridge.matrixToIrcUser(matrixUser);\n        await this.ircBridge.getMatrixUser(ircUser);\n    }\n\n    private async textForReplyEvent(event: MatrixMessageEvent, replyEventId: string, ircRoom: IrcRoom):\n    Promise<{formatted: string; reply: string}|null> {\n        // strips out the quotation of the original message, if needed\n        const replyText = (body: string): string => {\n            const REPLY_REGEX = /> <(.*?)>(.*?)\\n\\n([\\s\\S]*)/;\n            const match = REPLY_REGEX.exec(body);\n            if (match === null || match.length !== 4) {\n                return body;\n            }\n            return match[3];\n        };\n\n        const REPLY_NAME_MAX_LENGTH = 12;\n        const eventId = replyEventId;\n        if (!event.content.body) {\n            return null;\n        }\n\n        const rplText = replyText(event.content.body);\n        let rplName: string;\n        let rplSource: string;\n        let cachedEvent = this.getCachedEvent(eventId);\n        if (!cachedEvent) {\n            // Fallback to fetching from the homeserver.\n            try {\n                const eventContent = await this.ircBridge.getAppServiceBridge().getIntent().getEvent(\n                    event.room_id, eventId\n                );\n                rplName = eventContent.sender;\n                if (typeof(eventContent.content.body) !== \"string\") {\n                    throw Error(\"'body' was not a string.\");\n                }\n                const isReply = eventContent.content[\"m.relates_to\"] &&\n                    eventContent.content[\"m.relates_to\"][\"m.in_reply_to\"];\n                if (isReply) {\n                    rplSource = replyText(eventContent.content.body);\n                }\n                else {\n                    rplSource = eventContent.content.body;\n                }\n                cachedEvent = {sender: rplName, body: rplSource, timestamp: eventContent.origin_server_ts};\n                this.cacheEvent(eventId, cachedEvent);\n            }\n            catch (err) {\n                // If we couldn't find the event, then frankly we can't\n                // trust it and we won't treat it as a reply.\n                return {\n                    formatted: rplText,\n                    reply: rplText,\n                };\n            }\n        }\n        else {\n            rplName = cachedEvent.sender;\n            rplSource = cachedEvent.body;\n        }\n\n        // Get the first non-blank line from the source.\n        const lines = rplSource.split('\\n').filter((line) => !/^\\s*$/.test(line))\n        if (lines.length > 0) {\n            rplSource = trimString(lines[0], this.config.replySourceMaxLength);\n\n            // Ellipsis if needed.\n            if (lines.length > 1 || rplSource.length < lines[0].length) {\n                rplSource = rplSource + \"...\";\n            }\n        }\n        else {\n            // Don't show a source because we couldn't format one.\n            rplSource = \"\";\n        }\n\n        // Fetch the sender's IRC nick.\n        const sourceClient = this.ircBridge.getIrcUserFromCache(ircRoom.server, rplName);\n        if (sourceClient) {\n            rplName = sourceClient.nick;\n        }\n        else {\n            // If we couldn't find a client for them, they might be a ghost.\n            const ghostName = ircRoom.getServer().getNickFromUserId(rplName);\n            // If we failed to get a name, just make a guess of it.\n            rplName = ghostName !== null ? ghostName : rplName.substring(1,\n                1 + Math.min(REPLY_NAME_MAX_LENGTH, rplName.indexOf(\":\") - 1)\n            );\n        }\n\n        let replyTemplate: string;\n        const tresholdMs = (this.config.shortReplyTresholdSeconds) * 1000;\n        if (rplSource && event.origin_server_ts - cachedEvent.timestamp > tresholdMs) {\n            replyTemplate = this.config.longReplyTemplate;\n        }\n        else {\n            replyTemplate = this.config.shortReplyTemplate;\n        }\n\n        const formattedReply = renderTemplate(replyTemplate, {\n            nick: rplName,\n            original: rplSource,\n            reply: rplText,\n        });\n        return {\n            formatted: formattedReply,\n            reply: rplText,\n        };\n    }\n\n    private incrementMetric(serverDomain: string, metricName: string) {\n        let metricSet = this.metrics[serverDomain];\n        if (!metricSet) {\n            metricSet = this.metrics[serverDomain] = {};\n        }\n        if (metricSet[metricName] === undefined) {\n            metricSet[metricName] = 1;\n        }\n        else {\n            metricSet[metricName]++;\n        }\n        this.metrics[serverDomain] = metricSet;\n    }\n\n    private cacheEvent(id: string, event: CachedEvent) {\n        this.eventCache.set(id, event);\n\n        if (this.eventCache.size > this.config.eventCacheSize) {\n            const delKey = this.eventCache.entries().next().value[0];\n            this.eventCache.delete(delKey);\n        }\n    }\n\n    private getCachedEvent(id: string): CachedEvent|undefined {\n        return this.eventCache.get(id);\n    }\n\n    // EXPORTS\n    public onConfigChanged(config: MatrixHandlerConfig|undefined) {\n        this.config = {...DEFAULTS, ...config};\n    }\n\n    public onMemberEvent(req: BridgeRequest, event: OnMemberEventData) {\n        return reqHandler(req, this._onMemberEvent(req, event));\n    }\n\n    public onInvite(req: BridgeRequest, event: MatrixEventInvite, inviter: MatrixUser, invitee: MatrixUser) {\n        return reqHandler(req, this._onInvite(req, event, inviter, invitee));\n    }\n\n    public onJoin(req: BridgeRequest, event: OnMemberEventData, user: MatrixUser) {\n        return reqHandler(req, this._onJoin(req, event, user));\n    }\n\n    public onLeave(req: BridgeRequest, event: MatrixEventLeave, user: MatrixUser) {\n        return reqHandler(req, this._onLeave(req, event, user));\n    }\n\n    public onKick(req: BridgeRequest, event: MatrixEventKick, kicker: MatrixUser, kickee: MatrixUser) {\n        return reqHandler(req, this._onKick(req, event, kicker, kickee));\n    }\n\n    public onMessage(req: BridgeRequest, event: MatrixMessageEvent) {\n        return reqHandler(req, this._onMessage(req, event));\n    }\n\n    public onAliasQuery(req: BridgeRequest, alias: string) {\n        return reqHandler(req, this._onAliasQuery(req, alias));\n    }\n\n    public onUserQuery(req: BridgeRequest, userId: string) {\n        return reqHandler(req, this._onUserQuery(req, userId))\n    }\n\n    public getMetrics(serverDomain: string) {\n        const metrics = this.metrics[serverDomain] || {};\n        this.metrics[serverDomain] = {}\n        return metrics || {};\n    }\n}\n"], "fixing_code": ["import { IrcBridge } from \"./IrcBridge\";\nimport { BridgeRequest, BridgeRequestErr } from \"../models/BridgeRequest\";\nimport {\n    ContentRepo,\n    MatrixUser,\n    MatrixRoom,\n    MembershipQueue,\n    StateLookup,\n    StateLookupEvent,\n    Intent,\n} from \"matrix-appservice-bridge\";\nimport { IrcUser } from \"../models/IrcUser\";\nimport { ActionType, MatrixAction, MatrixMessageEvent } from \"../models/MatrixAction\";\nimport { IrcRoom } from \"../models/IrcRoom\";\nimport { BridgedClient } from \"../irc/BridgedClient\";\nimport { IrcServer } from \"../irc/IrcServer\";\nimport { IrcAction } from \"../models/IrcAction\";\nimport { toIrcLowerCase } from \"../irc/formatting\";\nimport { AdminRoomHandler, parseCommandFromEvent } from \"./AdminRoomHandler\";\nimport { trackChannelAndCreateRoom } from \"./RoomCreation\";\nimport { renderTemplate } from \"../util/Template\";\nimport { trimString } from \"../util/TrimString\";\nimport { messageDiff } from \"../util/MessageDiff\";\n\nasync function reqHandler(req: BridgeRequest, promise: PromiseLike<unknown>|void) {\n    try {\n        const res = await promise;\n        req.resolve(res);\n        return res;\n    }\n    catch (err) {\n        req.reject(err);\n        throw err;\n    }\n}\n\nconst MSG_PMS_DISABLED = \"[Bridge] Sorry, PMs are disabled on this bridge.\";\nconst MSG_PMS_DISABLED_FEDERATION = \"[Bridge] Sorry, PMs are disabled on this bridge over federation.\";\n\nexport interface MatrixHandlerConfig {\n    /* Number of events to store in memory for use in replies. */\n    eventCacheSize: number;\n    /* Length of the source text in a formatted reply message */\n    replySourceMaxLength: number;\n    // How many seconds needs to pass between a message and a reply to it to switch to the long reply format\n    shortReplyTresholdSeconds: number;\n    // Format of replies sent shortly after the original message\n    shortReplyTemplate: string;\n    // Format of replies sent a while after the original message\n    longReplyTemplate: string;\n    // Format of the text explaining why a message is truncated and pastebinned\n    truncatedMessageTemplate: string;\n}\n\nconst DEFAULTS: MatrixHandlerConfig = {\n    eventCacheSize: 4096,\n    replySourceMaxLength: 32,\n    shortReplyTresholdSeconds: 5 * 60,\n    shortReplyTemplate: \"$NICK: $REPLY\",\n    longReplyTemplate: \"<$NICK> \\\"$ORIGINAL\\\" <- $REPLY\",\n    truncatedMessageTemplate: \"(full message at <$URL>)\",\n};\n\nexport interface MatrixEventInvite {\n    room_id: string;\n    state_key: string;\n    sender: string;\n    content: {\n        is_direct?: boolean;\n        membership: \"invite\";\n    };\n    type: string;\n    event_id: string;\n}\n\nexport interface MatrixEventKick {\n    room_id: string;\n    sender: string;\n    state_key: string;\n    content: {\n        reason?: string;\n        membership: \"leave\";\n    };\n    type: string;\n    event_id: string;\n}\n\nexport interface MatrixSimpleMessage {\n    sender: string;\n    event_id: string;\n    content: {\n        body: string;\n    };\n}\n\ninterface MatrixEventLeave {\n    room_id: string;\n    event_id: string;\n    _injected?: boolean;\n}\n\nexport interface OnMemberEventData {\n    _frontier?: boolean;\n    _injected?: boolean;\n    room_id: string;\n    state_key: string;\n    type: string;\n    event_id: string;\n    content: {\n        displayname?: string;\n        membership: string;\n    };\n}\n\ninterface CachedEvent {\n    body: string;\n    sender: string;\n    timestamp: number;\n}\n\nexport class MatrixHandler {\n    // maintain a list of room IDs which are being processed invite-wise. This is\n    // required because invites are processed asyncly, so you could get invite->msg\n    // and the message is processed before the room is created.\n    private readonly processingInvitesForRooms: {\n        [roomIdUserId: string]: Promise<unknown>;\n    } = {};\n    // Map of `roomId-eventId` -> cached event\n    private readonly eventCache: Map<string, CachedEvent> = new Map();\n    private readonly metrics: {[domain: string]: {\n            [metricName: string]: number;\n        };} = {};\n    private readonly mediaUrl: string;\n    private memberTracker?: StateLookup;\n    private adminHandler: AdminRoomHandler;\n    private config: MatrixHandlerConfig = DEFAULTS;\n\n    constructor(\n        private readonly ircBridge: IrcBridge,\n        config: MatrixHandlerConfig|undefined,\n        private readonly membershipQueue: MembershipQueue\n    ) {\n        this.onConfigChanged(config);\n\n        // The media URL to use to transform mxc:// URLs when handling m.room.[file|image]s\n        this.mediaUrl = ircBridge.config.homeserver.media_url || ircBridge.config.homeserver.url;\n        this.adminHandler = new AdminRoomHandler(ircBridge, this);\n    }\n\n    public initialise() {\n        this.memberTracker = new StateLookup({\n            intent: this.ircBridge.getAppServiceBridge().getIntent(),\n            eventTypes: ['m.room.member']\n        });\n    }\n\n    // ===== Matrix Invite Handling =====\n\n    /**\n     * Process a Matrix invite event for an Admin room.\n     * @param {Object} event : The Matrix invite event.\n     * @param {Request} req : The request for this event.\n     * @param {MatrixUser} inviter : The user who invited the bot.\n     */\n    private async handleAdminRoomInvite(req: BridgeRequest, event: {room_id: string}, inviter: MatrixUser) {\n        req.log.info(`Handling invite from ${inviter.getId()} directed to bot.`);\n        // Real MX user inviting BOT to a private chat\n        const mxRoom = new MatrixRoom(event.room_id);\n        await this.membershipQueue.join(event.room_id, undefined, req, true);\n\n        // Do not create an admin room if the room is marked as 'plumbed'\n        const matrixClient = this.ircBridge.getAppServiceBridge().getIntent();\n        const plumbedState = await matrixClient.getStateEvent(event.room_id, 'm.room.plumbing', '', true);\n        if (plumbedState?.status === \"enabled\") {\n            req.log.info(\n                'This room is marked for plumbing (m.room.plumbing.status = \"enabled\"). ' +\n                'Not treating room as admin room.'\n            );\n            return;\n        }\n\n        // clobber any previous admin room ID\n        await this.ircBridge.getStore().storeAdminRoom(mxRoom, inviter.userId);\n    }\n\n    /**\n     * Process a Matrix invite event for an Admin room.\n     * @param {Object} event : The Matrix invite event.\n     * @param {Request} req : The request for this event.\n     * @param {IrcUser} invitedIrcUser : The IRC user the bot invited to a room.\n     */\n    private async handleInviteFromBot(req: BridgeRequest, event: {room_id: string}, invitedIrcUser: IrcUser) {\n        req.log.info(\"Handling invite from bot directed at %s on %s\",\n            invitedIrcUser.server.domain, invitedIrcUser.nick);\n        // Bot inviting VMX to a matrix room which is mapped to IRC. Just make a\n        // matrix user and join the room (we trust the bot, so no additional checks)\n        const mxUser = await this.ircBridge.getMatrixUser(invitedIrcUser);\n        await this.membershipQueue.join(event.room_id, mxUser.getId(), req, true);\n    }\n\n    private async handleInviteFromUser(req: BridgeRequest, event: MatrixEventInvite, invited: IrcUser) {\n        req.log.info(\"Handling invite from user directed at %s on %s\",\n            invited.nick, invited.server.domain);\n        const invitedUser = await this.ircBridge.getMatrixUser(invited);\n        const mxRoom = new MatrixRoom(event.room_id);\n        const intent = this.ircBridge.getAppServiceBridge().getIntent(invitedUser.getId());\n        const mxUser = new MatrixUser(event.sender);\n        // Real MX user inviting VMX to a matrix room for PM chat\n        if (!invited.server.allowsPms()) {\n            req.log.error(\"Accepting invite, and then leaving: This server does not allow PMs.\");\n            await intent.join(event.room_id);\n            await this.ircBridge.sendMatrixAction(mxRoom, invitedUser, new MatrixAction(\n                ActionType.Notice,\n                MSG_PMS_DISABLED\n            ));\n            await intent.leave(event.room_id);\n            return;\n        }\n\n        // If no federated PMs are allowed, check the origin of the PM\n        //  is same the domain as the bridge\n        if (!invited.server.shouldFederatePMs()) {\n            // Matches for the local part (the not-user part)\n            if (mxUser.host !== this.ircBridge.domain) {\n                req.log.error(\n                    \"Accepting invite, and then leaving: This server does not allow federated PMs.\"\n                );\n                await intent.join(event.room_id);\n                await this.ircBridge.sendMatrixAction(mxRoom, invitedUser, new MatrixAction(\n                    ActionType.Notice,\n                    MSG_PMS_DISABLED_FEDERATION\n                ));\n                await intent.leave(event.room_id);\n                return;\n            }\n        }\n        // create a virtual Matrix user for the IRC user\n\n        await this.membershipQueue.join(event.room_id, invitedUser.getId(), req, true);\n        req.log.info(\"Joined %s to room %s\", invitedUser.getId(), event.room_id);\n\n        // check if this room is a PM room or not.\n        const isPmRoom = event.content.is_direct === true;\n\n        if (isPmRoom) {\n            // nick is the channel\n            const ircRoom = new IrcRoom(invited.server, invited.nick);\n            await this.ircBridge.getStore().setPmRoom(\n                ircRoom, mxRoom, event.sender, event.state_key\n            );\n            return;\n        }\n        req.log.warn(`Room ${event.room_id} is not a 1:1 chat`);\n        await intent.kick(event.room_id, invitedUser.getId(), \"Group chat not supported.\");\n    }\n\n    // === Admin room handling ===\n    private async onAdminMessage(req: BridgeRequest, event: MatrixSimpleMessage,\n                                 adminRoom: MatrixRoom): Promise<void> {\n        req.log.info(\"Received admin message from %s\", event.sender);\n\n        const botUser = new MatrixUser(this.ircBridge.appServiceUserId, undefined, false);\n\n        // First call begins tracking, subsequent calls do nothing\n        await this.memberTracker?.trackRoom(adminRoom.getId());\n        const members = ((this.memberTracker?.getState(\n            adminRoom.getId(),\n            \"m.room.member\",\n        ) || []) as Array<StateLookupEvent>).filter((m) =>\n            (m.content as {membership: string}).membership === \"join\"\n        );\n\n        // If an admin room has more than 2 people in it, kick the bot out\n        if (members.length > 2) {\n            req.log.error(\n                `onAdminMessage: admin room has ${members.length}` +\n                ` users instead of just 2; bot will leave`\n            );\n\n            // Notify users in admin room\n            const notice = new MatrixAction(ActionType.Notice,\n                \"There are more than 2 users in this admin room\"\n            );\n            await this.ircBridge.sendMatrixAction(adminRoom, botUser, notice);\n\n            await this.ircBridge.getAppServiceBridge().getIntent(\n                botUser.getId()\n            ).leave(adminRoom.getId());\n            return;\n        }\n\n        await this.adminHandler.onAdminMessage(req, event, adminRoom);\n        return;\n    }\n\n    public async quitUser(req: BridgeRequest, userId: string, clientList: BridgedClient[],\n                          ircServer: IrcServer|null, reason: string) {\n        let clients = clientList;\n        if (ircServer) {\n            // Filter to get the clients for the [specified] server\n            clients = clientList.filter(\n                (bridgedClient) => bridgedClient.server.domain === ircServer.domain\n            );\n        }\n        if (clients.length === 0) {\n            req.log.info(`No bridgedClients for ${userId}`);\n            return \"You are not connected to any networks.\";\n        }\n\n        const intent = this.ircBridge.getAppServiceBridge().getIntent();\n\n        for (const bridgedClient of clients) {\n            req.log.info(\n                `Killing bridgedClient (nick = ${bridgedClient.nick}) for ${bridgedClient.userId}`\n            );\n            if (!bridgedClient.server.config.ircClients.kickOn.userQuit) {\n                req.log.info(\n                    `Not leaving ${userId} from rooms on ${bridgedClient.server.domain}`\n                );\n                await bridgedClient.kill(reason);\n                continue;\n            }\n\n            if (bridgedClient.chanList.size === 0) {\n                req.log.info(\n                    `Bridged client for ${userId} is not in any channels ` +\n                    `on ${bridgedClient.server.domain}`\n                );\n            }\n            else {\n                // Get all rooms that the bridgedClient is in\n                const uniqueRoomIds = new Set<string>();\n                (await Promise.all(\n                    [...bridgedClient.chanList].map(\n                        (channel) => {\n                            return this.ircBridge.getStore().getMatrixRoomsForChannel(\n                                bridgedClient.server, channel\n                            );\n                        }\n                    )\n                    // flatten to a single unqiue set\n                )).forEach((rSet) => rSet.forEach((r) => uniqueRoomIds.add(r.getId())));\n\n                // Don't wait for these to complete\n                Promise.all([...uniqueRoomIds].map(async (roomId) => {\n                    let state: {membership?: string};\n                    try {\n                        state = await intent.getStateEvent(roomId, \"m.room.member\", userId);\n                    }\n                    catch (ex) {\n                        state = {};\n                    }\n                    try {\n                        // Only kick if the state is join or leave, ignore all else.\n                        // https://github.com/matrix-org/matrix-appservice-irc/issues/1163\n                        if (state.membership === \"join\" || state.membership === \"invite\" ) {\n                            await this.membershipQueue.leave(\n                                roomId,\n                                userId,\n                                req,\n                                false,\n                                reason,\n                                this.ircBridge.appServiceUserId\n                            );\n                        }\n                    }\n                    catch (err) {\n                        req.log.error(err);\n                        req.log.warn(\n                            `Could not kick ${bridgedClient.userId} ` +\n                            `from bridged room ${roomId}: ${err.message}`\n                        );\n                    }\n                }));\n            }\n\n            // The success message will effectively be 'Your connection to ... has been lost.`\n            await bridgedClient.kill(reason);\n        }\n\n        return null;\n    }\n\n    /**\n     * Called when the AS receives a new Matrix invite/join/leave event.\n     * @param {Object} event : The Matrix member event.\n     */\n    private _onMemberEvent(req: BridgeRequest, event: OnMemberEventData) {\n        this.memberTracker?.onEvent(event);\n    }\n\n    /**\n     * Called when a Matrix user tries to invite another user into a PM\n     * @param {Object} event : The Matrix invite event.\n     * @param {MatrixUser} inviter : The inviter (sender).\n     * @param {MatrixUser} invitee : The invitee (receiver).\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async handleInviteToPMRoom(req: BridgeRequest, event: MatrixEventInvite,\n                                       inviter: MatrixUser, invitee: MatrixUser): Promise<BridgeRequestErr|null> {\n        // We don't support this\n        req.log.warn(\n            `User ${inviter.getId()} tried to invite ${invitee.getId()} to a PM room. Disconnecting from room`\n        );\n        const store = this.ircBridge.getStore();\n        const [room] = await store.getIrcChannelsForRoomId(event.room_id);\n        await store.removePmRoom(event.room_id);\n        const userId = room.server.getUserIdFromNick(room.channel);\n        const intent = this.ircBridge.getAppServiceBridge().getIntent(userId);\n        await intent.sendMessage(event.room_id, {\n            msgtype: \"m.notice\",\n            body: \"This room has been disconnected from IRC. You cannot invite new users into a IRC PM. \" +\n                  \"Please create a new PM room.\",\n        });\n        await intent.leave(event.room_id);\n        return null;\n    }\n\n    /**\n     * Called when the AS receives a new Matrix invite event.\n     * @param {Object} event : The Matrix invite event.\n     * @param {MatrixUser} inviter : The inviter (sender).\n     * @param {MatrixUser} invitee : The invitee (receiver).\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onInvite(req: BridgeRequest, event: MatrixEventInvite, inviter: MatrixUser, invitee: MatrixUser):\n    Promise<BridgeRequestErr|null> {\n        /*\n        * (MX=Matrix user, VMX=Virtual matrix user, BOT=AS bot)\n        * Valid invite flows:\n        * [1] MX  --invite--> VMX  (starting a PM chat)\n        * [2] bot --invite--> VMX  (invite-only room that the bot is in who is inviting virtuals)\n        * [3] MX  --invite--> BOT  (admin room; auth)\n        * [4] bot --invite--> MX   (bot telling real mx user IRC conn state) - Ignore.\n        * [5] irc --invite--> MX   (real irc user PMing a Matrix user) - Ignore.\n        * [6] MX  --invite--> BOT  (invite to private room to allow bot to bridge) - Ignore.\n        * [7] MX  --invite--> MX   (matrix user inviting another matrix user)\n        */\n        req.log.info(\"onInvite: from=%s to=%s rm=%s id=%s\", event.sender,\n            event.state_key, event.room_id, event.event_id);\n        this._onMemberEvent(req, event);\n\n        // mark this room as being processed in case we simultaneously get\n        // messages for this room (which would fail if we haven't done the\n        // invite yet!)\n        this.processingInvitesForRooms[event.room_id + event.state_key] = req.getPromise();\n        req.getPromise().finally(() => {\n            delete this.processingInvitesForRooms[event.room_id + event.state_key];\n        });\n\n        // Check if this room is known to us.\n        const rooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n        const hasExistingRoom= rooms.length > 1;\n\n        const inviteeIsVirtual = !!this.ircBridge.getServerForUserId(event.state_key);\n        const inviterIsVirtual = !!this.ircBridge.getServerForUserId(event.sender);\n\n        // work out which flow we're dealing with and fork off asap\n        // is the invitee the bot?\n        if (this.ircBridge.appServiceUserId === event.state_key) {\n            if (event.content.is_direct && !hasExistingRoom) {\n                // case [3]\n                // This is a PM invite to the bot.\n                await this.handleAdminRoomInvite(req, event, inviter);\n            }\n            // case[6]\n            // Drop through so the invite stays active, but do not join the room.\n        }\n        else if (!inviterIsVirtual && rooms[0]?.getType() === \"pm\") {\n            // case[7]-pms\n            return this.handleInviteToPMRoom(req, event, inviter, invitee);\n        } // case[7]-groups falls through.\n        // else is the invitee a real matrix user? If they are, there will be no IRC server\n        else if (!inviteeIsVirtual) {\n            // If this is a PM, we need to disconnect it\n            // cases [4], [5]: We cannot accept on behalf of real matrix users, so nop\n            return BridgeRequestErr.ERR_NOT_MAPPED;\n        }\n        else {\n            // cases [1] and [2] : The invitee represents a real IRC user\n            const ircUser = await this.ircBridge.matrixToIrcUser(invitee);\n            // is the invite from the bot?\n            if (this.ircBridge.appServiceUserId === event.sender) {\n                await this.handleInviteFromBot(req, event, ircUser); // case [2]\n            }\n            else { // We check if this is an invite inside the func.\n                await this.handleInviteFromUser(req, event, ircUser); // case [1]\n            }\n        }\n        return null;\n    }\n\n    private async _onJoin(req: BridgeRequest, event: OnMemberEventData, user: MatrixUser):\n    Promise<BridgeRequestErr|null> {\n        req.log.info(\"onJoin: usr=%s rm=%s id=%s\", event.state_key, event.room_id, event.event_id);\n        this._onMemberEvent(req, event);\n        // membershiplists injects leave events when syncing initial membership\n        // lists. We know if this event is injected because this flag is set.\n        const syncKind = event._injected ? \"initial\" : \"incremental\";\n        const promises: Promise<unknown>[] = []; // one for each join request\n\n        if (this.ircBridge.appServiceUserId === user.getId()) {\n            // ignore messages from the bot\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        // is this a tracked channel?\n        let ircRooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n\n        // =========== Bridge Bot Joining ===========\n        // Make sure the bot is joining on all mapped IRC channels\n        ircRooms.forEach((ircRoom) => {\n            this.ircBridge.joinBot(ircRoom);\n        });\n\n        // =========== Client Joining ===========\n        // filter out rooms which don't mirror matrix join parts and are NOT frontier\n        // entries. Frontier entries must ALWAYS be joined else the IRC channel will\n        // not be bridged!\n        ircRooms = ircRooms.filter((room) => {\n            return room.server.shouldSyncMembershipToIrc(\n                syncKind, event.room_id\n            ) || event._frontier;\n        });\n\n        if (ircRooms.length === 0) {\n            req.log.info(\n                \"No tracked channels which mirror joins for this room.\"\n            );\n            return BridgeRequestErr.ERR_NOT_MAPPED;\n        }\n\n        // for each room (which may be on different servers)\n        ircRooms.forEach((room) => {\n            if (room.server.claimsUserId(user.getId())) {\n                req.log.debug(\"%s is a virtual user (claimed by %s)\",\n                    user.getId(), room.server.domain);\n                return;\n            }\n            // get the virtual IRC user for this user\n            promises.push((async () => {\n                let bridgedClient: BridgedClient|null = null;\n                try {\n                    bridgedClient = await this.ircBridge.getBridgedClient(\n                        room.server, user.getId(), (event.content || {}).displayname\n                    );\n                }\n                catch (e) {\n                    req.log.info(`${user.getId()} failed to get a IRC connection.`, e);\n                    if (room.server.config.ircClients.kickOn.ircConnectionFailure) {\n                        // We need to kick on failure to get a client.\n                        req.log.info(`Kicking from room`);\n                        this.incrementMetric(room.server.domain, \"connection_failure_kicks\");\n                        const excluded = room.server.isExcludedUser(user.getId());\n                        await this.membershipQueue.leave(\n                            event.room_id,\n                            user.getId(),\n                            req,\n                            true,\n                            excluded && excluded.kickReason || `IRC connection failure.`,\n                            this.ircBridge.appServiceUserId,\n                        );\n                    }\n                    else {\n                        req.log.info(`Not kicking - disabled in config`);\n                    }\n                }\n\n                if (!bridgedClient || !bridgedClient.userId) {\n                    // For types, drop out early if we don't have a bridgedClient\n                    return;\n                }\n\n                // Check for a displayname change and update nick accordingly.\n                if (event.content &&\n                    event.content.displayname &&\n                    event.content.displayname !== bridgedClient.displayName) {\n                    bridgedClient.displayName = event.content.displayname;\n                    // Changing the nick requires that:\n                    // - the server allows nick changes\n                    // - the nick is not custom\n                    const config = await this.ircBridge.getStore().getIrcClientConfig(\n                        bridgedClient.userId, room.server.domain\n                    );\n                    if (config && room.server.allowsNickChanges() &&\n                        !config.getDesiredNick()\n                    ) {\n                        const intent = this.ircBridge.getAppServiceBridge().getIntent();\n                        // Check that the /profile matches the displayname.\n                        const userProfile = await intent.getProfileInfo(event.state_key, \"displayname\");\n                        // We only want to update the nickname if the profile contains the displayname\n                        if (userProfile.displayname === event.content.displayname) {\n                            try {\n                                const newNick = room.server.getNick(\n                                    bridgedClient.userId, event.content.displayname\n                                );\n                                bridgedClient.changeNick(newNick, false);\n                            }\n                            catch (e) {\n                                req.log.warn(`Didn't change nick on the IRC side: ${e}`);\n                            }\n                        }\n                    }\n                }\n\n                await bridgedClient.joinChannel(room.channel); // join each channel\n            })());\n        });\n\n        // We know ircRooms.length > 1. The only time when this isn't mapped into a Promise\n        // is when there is a virtual user: TODO: clean this up! Control flow is hard.\n        if (promises.length === 0) {\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        await Promise.all(promises);\n        return null;\n    }\n\n    private async _onKick(req: BridgeRequest, event: MatrixEventKick, kicker: MatrixUser, kickee: MatrixUser) {\n        req.log.info(\n            \"onKick %s is kicking/banning %s from %s (reason: %s)\",\n            kicker.getId(), kickee.getId(), event.room_id, event.content.reason || \"none\"\n        );\n        this._onMemberEvent(req, event);\n\n        /*\n        We know this is a Matrix client kicking someone.\n        There are 2 scenarios to consider here:\n        - Matrix on Matrix kicking\n        - Matrix on IRC kicking\n\n        Matrix-Matrix\n        =============\n        __USER A____            ____USER B___\n        |            |          |             |\n        Matrix     vIRC1       Matrix        vIRC2 |     Effect\n        -----------------------------------------------------------------------\n        Kicker                 Kickee              |  vIRC2 parts channel.\n                                                    This avoids potential permission issues\n                                                    in case vIRC1 cannot kick vIRC2 on IRC.\n\n        Matrix-IRC\n        ==========\n        __USER A____            ____USER B___\n        |            |          |             |\n        Matrix      vIRC        IRC       vMatrix  |     Effect\n        -----------------------------------------------------------------------\n        Kicker                            Kickee   |  vIRC tries to kick IRC via KICK command.\n        */\n\n        const ircRooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n        // do we have an active connection for the kickee? This tells us if they are real\n        // or virtual.\n        const kickeeClients = this.ircBridge.getBridgedClientsForUserId(kickee.getId());\n\n        if (kickeeClients.length === 0) {\n            // Matrix on IRC kicking, work out which IRC user to kick.\n            let server = null;\n            for (let i = 0; i < ircRooms.length; i++) {\n                if (ircRooms[i].server.claimsUserId(kickee.getId())) {\n                    server = ircRooms[i].server;\n                    break;\n                }\n            }\n            if (!server) {\n                return; // kicking a bogus user\n            }\n            const kickeeNick = server.getNickFromUserId(kickee.getId());\n            if (!kickeeNick) {\n                return; // bogus virtual user ID\n            }\n            // work out which client will do the kicking\n            const kickerClient = this.ircBridge.getIrcUserFromCache(server, kicker.getId());\n            if (!kickerClient) {\n                // well this is awkward.. whine about it and bail.\n                req.log.warn(\n                    \"%s has no client instance to send kick from. Cannot kick.\",\n                    kicker.getId()\n                );\n                return;\n            }\n            // we may be bridging this matrix room into many different IRC channels, and we want\n            // to kick this user from all of them.\n            for (let i = 0; i < ircRooms.length; i++) {\n                if (ircRooms[i].server.domain !== server.domain) {\n                    return;\n                }\n                kickerClient.kick(\n                    kickeeNick, ircRooms[i].channel,\n                    `Kicked by ${kicker.getId()}` +\n                    (event.content.reason ? ` : ${event.content.reason}` : \"\")\n                );\n            }\n        }\n        else {\n            // Matrix on Matrix kicking: part the channel.\n            const kickeeServerLookup: {[serverDomain: string]: BridgedClient} = {};\n            kickeeClients.forEach((ircClient) => {\n                kickeeServerLookup[ircClient.server.domain] = ircClient;\n            });\n            await Promise.all(ircRooms.map((async (ircRoom) => {\n                // Make the connected IRC client leave the channel.\n                const client = kickeeServerLookup[ircRoom.server.domain];\n                if (!client) {\n                    return; // not connected to this server\n                }\n                // If we aren't joined this will no-op.\n                await client.leaveChannel(\n                    ircRoom.channel,\n                    `Kicked by ${kicker.getId()} ` +\n                    (event.content.reason ? ` : ${event.content.reason}` : \"\")\n                );\n            })));\n        }\n    }\n\n    private async _onLeave(req: BridgeRequest, event: MatrixEventLeave, user: MatrixUser):\n    Promise<BridgeRequestErr|null> {\n        req.log.info(\"onLeave: usr=%s rm=%s id=%s\", user.getId(), event.room_id, event.event_id);\n        // membershiplists injects leave events when syncing initial membership\n        // lists. We know if this event is injected because this flag is set.\n        const syncKind = event._injected ? \"initial\" : \"incremental\";\n\n        if (this.ircBridge.appServiceUserId === user.getId()) {\n            // ignore messages from the bot\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        // do we have an active connection for this user?\n        let clientList = this.ircBridge.getBridgedClientsForUserId(user.getId());\n        // filter out servers which don't mirror matrix join parts (unless it's a kick)\n        clientList = clientList.filter((client) => {\n            return (\n                client.server.shouldSyncMembershipToIrc(syncKind, event.room_id) &&\n                !client.server.claimsUserId(user.getId())\n            ); // not a virtual user\n        });\n\n        const serverLookup: {[serverDomain: string]: BridgedClient} = {};\n        clientList.forEach((ircClient) => {\n            serverLookup[ircClient.server.domain] = ircClient;\n        });\n\n        const store = this.ircBridge.getStore();\n\n        // which channels should the connected client leave?\n        const ircRooms = await store.getIrcChannelsForRoomId(event.room_id);\n\n        if (!ircRooms) {\n            const adminRoom = await store.getAdminRoomById(event.room_id);\n            if (adminRoom) {\n                await store.removeAdminRoom(adminRoom);\n                // The user left the admin room, let's also leave.\n                // XXX: The typing of .leave is wrong, it should\n                // allow undefined.\n                await this.membershipQueue.leave(event.room_id, \"\", req);\n                return null;\n            }\n\n            const pmRoom = await store.getMatrixPmRoomById(event.room_id);\n            if (pmRoom) {\n                await store.removePmRoom(pmRoom.roomId);\n                // The user left the pm room, let's also leave.\n                const members = await this.ircBridge.getAppServiceBridge().getBot().getJoinedMembers(pmRoom.roomId);\n                await Promise.all(Object.keys(members).map((u) => {\n                    this.membershipQueue.leave(event.room_id, u, req);\n                }));\n                return null;\n            }\n\n        }\n\n        // ========== Client Parting ==========\n        // for each room, if we're connected to it, leave the channel.\n        const promises = ircRooms.map(async (ircRoom) => {\n            // Make the connected IRC client leave the channel.\n            const client = serverLookup[ircRoom.server.domain];\n            if (!client) {\n                return; // not connected to this server\n            }\n            // leave it; if we aren't joined this will no-op.\n            await client.leaveChannel(ircRoom.channel);\n        });\n\n        if (promises.length === 0) { // no connected clients\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n        // =========== Bridge Bot Parting ===========\n        // For membership list syncing only\n        await Promise.all(ircRooms.map(async (ircRoom) => {\n            const client = serverLookup[ircRoom.server.domain];\n            if (!client) {\n                return; // no client left the room, so no need to recheck part room.\n            }\n            if (!ircRoom.server.isBotEnabled()) {\n                return; // don't do expensive queries needlessly\n            }\n            if (!ircRoom.server.shouldJoinChannelsIfNoUsers()) {\n                if (ircRoom.server.domain) {\n                    // this = IrcBridge\n                    await this.ircBridge.getMemberListSyncer(ircRoom.server).checkBotPartRoom(\n                        ircRoom, req\n                    );\n                }\n            }\n        }));\n        await Promise.all(promises);\n        return null;\n    }\n\n    private async onCommand(req: BridgeRequest, event: MatrixMessageEvent): Promise<BridgeRequestErr|null> {\n        req.log.info(`Handling in-room command from ${event.sender}`);\n        const parseResult = parseCommandFromEvent(event, \"!irc \");\n        if (!parseResult) {\n            throw Error('Cannot handle malformed command');\n        }\n        const intent = this.ircBridge.getAppServiceBridge().getIntent();\n        const { cmd: command, args } = parseResult;\n        // We currently only check the first room.\n        const [targetRoom] = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n        if (command === \"nick\") {\n            const newNick = args[0];\n            if (!(newNick?.length > 0)) {\n                await intent.sendMessage(event.room_id, {\n                    msgtype: \"m.notice\",\n                    body: \"You must specify a valid nickname\",\n                });\n                return BridgeRequestErr.ERR_DROPPED;\n            }\n            // We need to get the context of this room.\n            if (!targetRoom) {\n                await intent.sendMessage(event.room_id, {\n                    'msgtype': 'm.notice',\n                    'body': 'Room is not bridged, cannot set nick without a target server'\n                });\n                return BridgeRequestErr.ERR_NOT_MAPPED;\n            }\n            const bridgedClient = await this.ircBridge.getBridgedClient(targetRoom.server, event.sender);\n            req.log.info(\"Matrix user wants to change nick from %s to %s\", bridgedClient.nick, newNick);\n            try {\n                await bridgedClient.changeNick(newNick, true);\n            }\n            catch (e) {\n                await intent.sendMessage(event.room_id, {\n                    'msgtype': 'm.notice',\n                    'body': `Unable to change nick: ${e.message}`\n                });\n                req.log.warn(`Didn't change nick on the IRC side: ${e}`);\n            }\n            return null;\n        }\n        await intent.sendMessage(event.room_id, {\n            'msgtype': 'm.notice',\n            'body': 'Command not known'\n        });\n        return null;\n    }\n\n    /**\n     * Called when the AS receives a new Matrix Event.\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onMessage(req: BridgeRequest, event: MatrixMessageEvent): Promise<BridgeRequestErr|null> {\n        /*\n        * Valid message flows:\n        * Matrix --> IRC (Bridged communication)\n        * Matrix --> Matrix (Admin room)\n        */\n\n        req.log.info(\"onMessage: %s usr=%s rm=%s id=%s\",\n            event.type, event.sender, event.room_id, event.event_id\n        );\n        if (event.content.body) {\n            req.log.debug(\"Message body: %s\", event.content.body);\n        }\n\n        const mxAction = MatrixAction.fromEvent(\n            event, this.mediaUrl\n        );\n\n        // check if this message is from one of our virtual users\n        const servers = this.ircBridge.getServers();\n        for (let i = 0; i < servers.length; i++) {\n            if (servers[i].claimsUserId(event.sender)) {\n                req.log.debug(\"%s is a virtual user (claimed by %s)\",\n                    event.sender, servers[i].domain);\n                return BridgeRequestErr.ERR_VIRTUAL_USER;\n            }\n        }\n\n\n        if (mxAction.type === \"command\") {\n            return this.onCommand(req, event);\n        }\n\n        const ircAction = IrcAction.fromMatrixAction(mxAction);\n        if (ircAction === null) {\n            req.log.info(\"IrcAction couldn't determine an action type.\");\n            return BridgeRequestErr.ERR_DROPPED;\n        }\n\n        // wait a while if we just got an invite else we may not have the mapping stored\n        // yet...\n        const key = `${event.room_id}+${event.sender}`;\n        if (key in this.processingInvitesForRooms) {\n            req.log.info(\n                \"Holding request for %s until invite for room %s is done.\",\n                event.sender, event.room_id\n            );\n            await this.processingInvitesForRooms[key];\n            req.log.info(\n                \"Finished holding event for %s in room %s\", event.sender, event.room_id\n            );\n        }\n\n        if (this.ircBridge.appServiceUserId === event.sender) {\n            // ignore messages from the bot\n            return BridgeRequestErr.ERR_VIRTUAL_USER;\n        }\n\n\n        const ircRooms = await this.ircBridge.getStore().getIrcChannelsForRoomId(event.room_id);\n\n        // Sometimes bridge's message each other and get stuck in a silly loop. Ensure it's m.text\n        if (ircRooms.length === 0 && event.content && event.content.msgtype === \"m.text\") {\n            // This is used to ensure type safety.\n            const body = event.content.body;\n            if (!body?.trim().length) {\n                return BridgeRequestErr.ERR_DROPPED;\n            }\n            // could be an Admin room, so check.\n            const adminRoom = await this.ircBridge.getStore().getAdminRoomById(event.room_id);\n            if (!adminRoom) {\n                req.log.debug(\"No mapped channels.\");\n                return BridgeRequestErr.ERR_DROPPED;\n            }\n            // process admin request\n            await this.onAdminMessage(req, { ...event, content: { body }}, adminRoom);\n        }\n\n\n        // Check for other matrix rooms which are bridged to this channel.\n        // If there are other rooms, send this message directly to that room as the virtual matrix user.\n        // E.g: send this message to MROOM2 and MROOM3:\n        //\n        // MROOM1            MROOM2             MROOM3\n        //   |                 |                  |\n        //   +->>MSG>>----------------------------+\n        //                 |                  |\n        //                #chan              #chan2\n        //\n        const otherMatrixRoomIdsToServers = Object.create(null);\n        const messageSendPromiseSet: Promise<unknown>[] = [];\n        const fetchRoomsPromiseSet: Promise<unknown>[] = [];\n\n        ircRooms.forEach((ircRoom) => {\n            if (ircRoom.server.claimsUserId(event.sender)) {\n                req.log.debug(\"%s is a virtual user (claimed by %s)\",\n                    event.sender, ircRoom.server.domain);\n                return;\n            }\n            req.log.info(\"Relaying message in %s on %s\",\n                ircRoom.channel, ircRoom.server.domain);\n\n            if (ircRoom.getType() === \"channel\") {\n                fetchRoomsPromiseSet.push((async () => {\n                    const otherMatrixRooms = await this.ircBridge.getStore().getMatrixRoomsForChannel(\n                        ircRoom.server, ircRoom.channel\n                    );\n                    otherMatrixRooms.forEach((mxRoom) => {\n                        otherMatrixRoomIdsToServers[mxRoom.getId()] = ircRoom.server;\n                    });\n                })());\n            }\n\n            // If we already have a cached client then yay, but if we\n            // don't then we need to hit out for their display name in\n            // this room.\n            let bridgedClient = this.ircBridge.getIrcUserFromCache(ircRoom.server, event.sender);\n            if (!bridgedClient) {\n                messageSendPromiseSet.push((async () => {\n                    const intent = this.ircBridge.getAppServiceBridge().getIntent();\n                    const displayName = await intent.getStateEvent(\n                        event.room_id, \"m.room.member\", event.sender\n                    ).catch(err => {\n                        req.log.warn(`Failed to get display name for the room: ${err}`);\n                        return intent.getProfileInfo(event.sender, \"displayname\");\n                    }).then(\n                        res => res.displayname\n                    ).catch(err => {\n                        req.log.error(`Failed to get display name: ${err}`);\n                    });\n                    bridgedClient = await this.ircBridge.getBridgedClient(\n                        ircRoom.server, event.sender, displayName\n                    );\n                    await this.sendIrcAction(req, ircRoom, bridgedClient, ircAction, event);\n                })());\n            }\n            else {\n                // push each request so we don't block processing other rooms\n                messageSendPromiseSet.push(\n                    this.sendIrcAction(req, ircRoom, bridgedClient, ircAction, event),\n                );\n            }\n        });\n        await Promise.all(fetchRoomsPromiseSet);\n        Object.keys(otherMatrixRoomIdsToServers).forEach((roomId) => {\n            if (roomId === event.room_id) {\n                return; // don't bounce back to the sender\n            }\n            const otherServer = otherMatrixRoomIdsToServers[roomId];\n            // convert the sender's user ID to a nick and back to a virtual user for this server\n            // then send from that user ID (yuck!).\n            const n = otherServer.getNick(event.sender);\n            const virtUserId = otherServer.getUserIdFromNick(n);\n            messageSendPromiseSet.push(\n                this.ircBridge.sendMatrixAction(\n                    new MatrixRoom(roomId), new MatrixUser(virtUserId), mxAction\n                )\n            );\n        });\n\n        await Promise.all(messageSendPromiseSet);\n        return null;\n    }\n\n    private async sendIrcAction(req: BridgeRequest, ircRoom: IrcRoom, ircClient: BridgedClient, ircAction: IrcAction,\n                                event: MatrixMessageEvent) {\n        // Send the action as is if it is not a text message\n        if (![\"m.text\", \"m.notice\"].find(msgtype => msgtype === event.content.msgtype) || !event.content.body) {\n            await this.ircBridge.sendIrcAction(ircRoom, ircClient, ircAction);\n            return;\n        }\n\n        let cacheBody = ircAction.text;\n\n        // special handling for replies (and threads)\n        if (event.content[\"m.relates_to\"] && event.content[\"m.relates_to\"][\"m.in_reply_to\"]) {\n            const eventId = event.content[\"m.relates_to\"][\"m.in_reply_to\"].event_id;\n            const reply = await this.textForReplyEvent(event, eventId, ircRoom);\n            if (reply !== null) {\n                ircAction.text = reply.formatted;\n                cacheBody = reply.reply;\n            }\n        }\n\n        // special handling for edits\n        if (event.content[\"m.relates_to\"]?.rel_type === \"m.replace\") {\n            const originalEventId = event.content[\"m.relates_to\"].event_id;\n            let originalBody = this.getCachedEvent(event.room_id, originalEventId)?.body;\n            if (!originalBody) {\n                try {\n                    // FIXME: this will return the new event rather than the original one\n                    // to actually see the original content we'd need to use whatever\n                    // https://github.com/matrix-org/matrix-doc/pull/2675 stabilizes on\n                    let intent: Intent;\n                    if (ircRoom.getType() === \"pm\") {\n                        // no Matrix Bot, use the IRC user's intent\n                        const userId = ircRoom.server.getUserIdFromNick(ircRoom.channel);\n                        intent = this.ircBridge.getAppServiceBridge().getIntent(userId);\n                    }\n                    else {\n                        intent = this.ircBridge.getAppServiceBridge().getIntent();\n                    }\n                    const eventContent = await intent.getEvent(\n                        event.room_id, originalEventId\n                    );\n                    originalBody = eventContent.content.body;\n                }\n                catch (_err) {\n                    req.log.warn(\"Couldn't find an event being edited, using fallback text\");\n                }\n            }\n            const newBody = event.content[\"m.new_content\"]?.body;\n            if (originalBody && newBody) {\n                const diff = messageDiff(originalBody, newBody);\n                if (diff) {\n                    ircAction.text = diff;\n                }\n            }\n        }\n\n        let body = cacheBody.trim().substring(0, this.config.replySourceMaxLength);\n        const nextNewLine = body.indexOf(\"\\n\");\n        if (nextNewLine !== -1) {\n            body = body.substring(0, nextNewLine);\n        }\n        // Cache events in here so we can refer to them for replies.\n        this.cacheEvent(\n            event.room_id,\n            event.event_id,\n            {\n                body: cacheBody,\n                sender: event.sender,\n                timestamp: event.origin_server_ts,\n            },\n        );\n\n        // The client might still be connected, for abundance of safety let's wait.\n        await ircClient.waitForConnected();\n\n        // Generate an array of individual messages that would be sent\n        const potentialMessages = ircClient.getSplitMessages(ircRoom.channel, ircAction.text);\n        const roomLineLimit = await this.ircBridge.roomConfigs.getLineLimit(event.room_id, ircRoom);\n        const lineLimit = roomLineLimit === null ? ircRoom.server.getLineLimit() : roomLineLimit;\n\n        if (potentialMessages.length <= lineLimit) {\n            await this.ircBridge.sendIrcAction(ircRoom, ircClient, ircAction);\n            return;\n        }\n\n        // Message body too long, upload to HS instead\n\n        // Use the current ISO datetime as the name of the file\n        //  strip off milliseconds and replace 'T' with an underscore\n        //  result e.g : 2016-08-03T10:40:48.620Z becomes 2016-08-03_10:40:48\n        let fileName = new Date().toISOString()\n            .split(/[T|\\.]/)\n            .splice(0, 2)\n            .join('_') + '.txt';\n\n        // somenick_2016-08-03_10:40:48.txt\n        fileName = ircClient.nick + '_' + fileName;\n\n        let contentUri: string|null = null;\n\n        try {\n            // Try to upload as a file and get URI\n            //  (this could fail, see the catch statement)\n            contentUri = await this.ircBridge.uploadTextFile(fileName, ircAction.text);\n        }\n        catch (err) {\n            // Uploading the file to HS could fail\n            req.log.error(\"Failed to upload text file \", err);\n        }\n\n        // This is true if the upload was a success\n        if (contentUri) {\n            const httpUrl = ContentRepo.getHttpUriForMxc(this.mediaUrl, contentUri);\n            // we check event.content.body since ircAction already has the markers stripped\n            const codeBlockMatch = event.content.body.match(/^```(\\w+)?/);\n            if (codeBlockMatch) {\n                const type = codeBlockMatch[1] ? ` ${codeBlockMatch[1]}` : '';\n                event.content = {\n                    msgtype: \"m.emote\",\n                    body:    `sent a${type} code block: ${httpUrl}`\n                };\n            }\n            else {\n                const explanation = renderTemplate(this.config.truncatedMessageTemplate, { url: httpUrl });\n                let messagePreview = trimString(\n                    potentialMessages[0],\n                    ircClient.getMaxLineLength() - 4 /* \"... \" */ - explanation.length - ircRoom.channel.length\n                );\n                if (potentialMessages.length > 1 || messagePreview.length < potentialMessages[0].length) {\n                    messagePreview += '...';\n                }\n\n                event.content = {\n                    ...event.content,\n                    body: `${messagePreview} ${explanation}`,\n                };\n            }\n\n            const truncatedIrcAction = IrcAction.fromMatrixAction(\n                MatrixAction.fromEvent(event, this.mediaUrl)\n            );\n            if (truncatedIrcAction) {\n                await this.ircBridge.sendIrcAction(ircRoom, ircClient, truncatedIrcAction);\n            }\n        }\n        else {\n            req.log.debug(\"Sending truncated message\");\n            // Modify the event to become a truncated version of the original\n            //  the truncation limits the number of lines sent to lineLimit.\n\n            const msg = '\\n...(truncated)';\n\n            const sendingEvent: MatrixMessageEvent = { ...event,\n                content: {\n                    ...event.content,\n                    body: potentialMessages.splice(0, lineLimit - 1).join('\\n') + msg\n                }\n            };\n\n            // Recreate action from modified event\n            const truncatedIrcAction = IrcAction.fromMatrixAction(\n                MatrixAction.fromEvent(\n                    sendingEvent,\n                    this.mediaUrl,\n                )\n            );\n            if (truncatedIrcAction) {\n                await this.ircBridge.sendIrcAction(ircRoom, ircClient, truncatedIrcAction);\n            }\n        }\n    }\n\n    /**\n     * Called when the AS receives an alias query from the HS.\n     * @param {string} roomAlias : The room alias queried.\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onAliasQuery(req: BridgeRequest, roomAlias: string) {\n        req.log.info(\"onAliasQuery %s\", roomAlias);\n\n        // check if alias maps to a valid IRC server and channel\n        const channelInfo = this.ircBridge.aliasToIrcChannel(roomAlias);\n        if (!channelInfo.channel) {\n            throw new Error(\"Unknown alias: \" + roomAlias); // bad alias\n        }\n        if (!channelInfo.server.createsPublicAliases()) {\n            throw new Error(\"This server does not allow alias mappings.\");\n        }\n        req.log.info(\"Mapped to %s on %s\",\n            channelInfo.channel, channelInfo.server.domain\n        );\n\n        // See if we are already tracking this channel (case-insensitive\n        // channels but case-sensitive aliases)\n        const matrixRooms = await this.ircBridge.getStore().getMatrixRoomsForChannel(\n            channelInfo.server, channelInfo.channel\n        );\n        if (matrixRooms.length === 0) {\n            await trackChannelAndCreateRoom(this.ircBridge, req, {\n                server: channelInfo.server,\n                // lower case the name to join (there's a bug in the IRC lib\n                // where the join callback never fires if you try to join\n                // #WithCaps in channels :/)\n                ircChannel:  toIrcLowerCase(channelInfo.channel),\n                roomAliasName: roomAlias.split(\":\")[0].substring(1), // localpart\n                origin: \"alias\",\n            })\n        }\n        else {\n            // create an alias pointing to this room (take first)\n            // TODO: Take first with public join_rules\n            const roomId = matrixRooms[0].getId();\n            req.log.info(\"Pointing alias %s to %s\", roomAlias, roomId);\n            await this.ircBridge.getAppServiceBridge().getIntent().createAlias(\n                roomAlias, roomId\n            );\n        }\n    }\n\n    /**\n     * Called when the AS receives a user query from the HS.\n     * @param {string} userId : The user ID queried.\n     * @return {Promise} which is resolved/rejected when the request finishes.\n     */\n    private async _onUserQuery(req: BridgeRequest, userId: string) {\n        if (this.ircBridge.appServiceUserId === userId) {\n            return;\n        }\n        req.log.info(\"onUserQuery: %s\", userId);\n        const matrixUser = new MatrixUser(userId);\n        const ircUser = await this.ircBridge.matrixToIrcUser(matrixUser);\n        await this.ircBridge.getMatrixUser(ircUser);\n    }\n\n    private async textForReplyEvent(event: MatrixMessageEvent, replyEventId: string, ircRoom: IrcRoom):\n    Promise<{formatted: string; reply: string}|null> {\n        // strips out the quotation of the original message, if needed\n        const replyText = (body: string): string => {\n            const REPLY_REGEX = /> <(.*?)>(.*?)\\n\\n([\\s\\S]*)/;\n            const match = REPLY_REGEX.exec(body);\n            if (match === null || match.length !== 4) {\n                return body;\n            }\n            return match[3];\n        };\n\n        const REPLY_NAME_MAX_LENGTH = 12;\n        if (!event.content.body) {\n            return null;\n        }\n\n        const rplText = replyText(event.content.body);\n        let rplName: string;\n        let rplSource: string;\n        // Reply must be in the same room as the original event.\n        let cachedEvent = this.getCachedEvent(event.room_id, replyEventId);\n        if (!cachedEvent) {\n            // Fallback to fetching from the homeserver.\n            try {\n                const eventContent = await this.ircBridge.getAppServiceBridge().getIntent().getEvent(\n                    event.room_id, replyEventId\n                );\n                rplName = eventContent.sender;\n                if (typeof(eventContent.content.body) !== \"string\") {\n                    throw Error(\"'body' was not a string.\");\n                }\n                const isReply = eventContent.content[\"m.relates_to\"] &&\n                    eventContent.content[\"m.relates_to\"][\"m.in_reply_to\"];\n                if (isReply) {\n                    rplSource = replyText(eventContent.content.body);\n                }\n                else {\n                    rplSource = eventContent.content.body;\n                }\n                cachedEvent = {sender: rplName, body: rplSource, timestamp: eventContent.origin_server_ts};\n                this.cacheEvent(eventContent.room_id, eventContent.event_id, cachedEvent);\n            }\n            catch (err) {\n                // If we couldn't find the event, then frankly we can't\n                // trust it and we won't treat it as a reply.\n                return {\n                    formatted: rplText,\n                    reply: rplText,\n                };\n            }\n        }\n        else {\n            rplName = cachedEvent.sender;\n            rplSource = cachedEvent.body;\n        }\n\n        // Get the first non-blank line from the source.\n        const lines = rplSource.split('\\n').filter((line) => !/^\\s*$/.test(line))\n        if (lines.length > 0) {\n            rplSource = trimString(lines[0], this.config.replySourceMaxLength);\n\n            // Ellipsis if needed.\n            if (lines.length > 1 || rplSource.length < lines[0].length) {\n                rplSource = rplSource + \"...\";\n            }\n        }\n        else {\n            // Don't show a source because we couldn't format one.\n            rplSource = \"\";\n        }\n\n        // Fetch the sender's IRC nick.\n        const sourceClient = this.ircBridge.getIrcUserFromCache(ircRoom.server, rplName);\n        if (sourceClient) {\n            rplName = sourceClient.nick;\n        }\n        else {\n            // If we couldn't find a client for them, they might be a ghost.\n            const ghostName = ircRoom.getServer().getNickFromUserId(rplName);\n            // If we failed to get a name, just make a guess of it.\n            rplName = ghostName !== null ? ghostName : rplName.substring(1,\n                1 + Math.min(REPLY_NAME_MAX_LENGTH, rplName.indexOf(\":\") - 1)\n            );\n        }\n\n        let replyTemplate: string;\n        const tresholdMs = (this.config.shortReplyTresholdSeconds) * 1000;\n        if (rplSource && event.origin_server_ts - cachedEvent.timestamp > tresholdMs) {\n            replyTemplate = this.config.longReplyTemplate;\n        }\n        else {\n            replyTemplate = this.config.shortReplyTemplate;\n        }\n\n        const formattedReply = renderTemplate(replyTemplate, {\n            nick: rplName,\n            original: rplSource,\n            reply: rplText,\n        });\n        return {\n            formatted: formattedReply,\n            reply: rplText,\n        };\n    }\n\n    private incrementMetric(serverDomain: string, metricName: string) {\n        let metricSet = this.metrics[serverDomain];\n        if (!metricSet) {\n            metricSet = this.metrics[serverDomain] = {};\n        }\n        if (metricSet[metricName] === undefined) {\n            metricSet[metricName] = 1;\n        }\n        else {\n            metricSet[metricName]++;\n        }\n        this.metrics[serverDomain] = metricSet;\n    }\n\n    private cacheEvent(roomId: string, eventId: string, event: CachedEvent) {\n        const cacheKey = `${roomId}-${eventId}`;\n        this.eventCache.set(cacheKey, event);\n\n        if (this.eventCache.size > this.config.eventCacheSize) {\n            const delKey = this.eventCache.entries().next().value[0];\n            this.eventCache.delete(delKey);\n        }\n    }\n\n    private getCachedEvent(roomId: string, eventId: string): CachedEvent|undefined {\n        const cacheKey = `${roomId}-${eventId}`;\n        return this.eventCache.get(cacheKey);\n    }\n\n    // EXPORTS\n    public onConfigChanged(config: MatrixHandlerConfig|undefined) {\n        this.config = {...DEFAULTS, ...config};\n    }\n\n    public onMemberEvent(req: BridgeRequest, event: OnMemberEventData) {\n        return reqHandler(req, this._onMemberEvent(req, event));\n    }\n\n    public onInvite(req: BridgeRequest, event: MatrixEventInvite, inviter: MatrixUser, invitee: MatrixUser) {\n        return reqHandler(req, this._onInvite(req, event, inviter, invitee));\n    }\n\n    public onJoin(req: BridgeRequest, event: OnMemberEventData, user: MatrixUser) {\n        return reqHandler(req, this._onJoin(req, event, user));\n    }\n\n    public onLeave(req: BridgeRequest, event: MatrixEventLeave, user: MatrixUser) {\n        return reqHandler(req, this._onLeave(req, event, user));\n    }\n\n    public onKick(req: BridgeRequest, event: MatrixEventKick, kicker: MatrixUser, kickee: MatrixUser) {\n        return reqHandler(req, this._onKick(req, event, kicker, kickee));\n    }\n\n    public onMessage(req: BridgeRequest, event: MatrixMessageEvent) {\n        return reqHandler(req, this._onMessage(req, event));\n    }\n\n    public onAliasQuery(req: BridgeRequest, alias: string) {\n        return reqHandler(req, this._onAliasQuery(req, alias));\n    }\n\n    public onUserQuery(req: BridgeRequest, userId: string) {\n        return reqHandler(req, this._onUserQuery(req, userId))\n    }\n\n    public getMetrics(serverDomain: string) {\n        const metrics = this.metrics[serverDomain] || {};\n        this.metrics[serverDomain] = {}\n        return metrics || {};\n    }\n}\n"], "filenames": ["src/bridge/MatrixHandler.ts"], "buggy_code_start_loc": [121], "buggy_code_end_loc": [1389], "fixing_code_start_loc": [122], "fixing_code_end_loc": [1396], "type": "NVD-CWE-noinfo", "message": "matrix-appservice-irc is a Node.js IRC bridge for Matrix. Prior to version 1.0.1, it was possible to craft an event such that it would leak part of a targeted message event from another bridged room. This required knowing an event ID to target. Version 1.0.1n fixes this issue. As a workaround, set the `matrixHandler.eventCacheSize` config value to `0`. This workaround may impact performance.", "other": {"cve": {"id": "CVE-2023-38700", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-04T19:15:09.697", "lastModified": "2023-08-11T18:58:44.057", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-appservice-irc is a Node.js IRC bridge for Matrix. Prior to version 1.0.1, it was possible to craft an event such that it would leak part of a targeted message event from another bridged room. This required knowing an event ID to target. Version 1.0.1n fixes this issue. As a workaround, set the `matrixHandler.eventCacheSize` config value to `0`. This workaround may impact performance."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:matrix_irc_bridge:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "5E1ADA6C-5E11-43D2-B9D7-8357036D8621"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-appservice-irc/commit/8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/matrix-org/matrix-appservice-irc/releases/tag/1.0.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/matrix-org/matrix-appservice-irc/security/advisories/GHSA-c7hh-3v6c-fj4q", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-appservice-irc/commit/8bbd2b69a16cbcbeffdd9b5c973fd89d61498d75"}}