{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Memory Allocator\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <assert.h>\n\n/* We need the prototype for memset. */\n#include <string.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\nstatic size_t jas_mem = 0;\nstatic size_t jas_max_mem = JAS_DEFAULT_MAX_MEM_USAGE;\n\ntypedef struct {\n\tsize_t size;\n} jas_mb_t;\n\n#define JAS_MB_ADJUST \\\n  ((sizeof(jas_mb_t) + sizeof(max_align_t) - 1) / sizeof(max_align_t))\n#define JAS_MB_SIZE (JAS_MB_ADJUST * sizeof(max_align_t))\n\njas_mb_t *jas_get_mb(void *ptr)\n{\n\treturn JAS_CAST(jas_mb_t *, JAS_CAST(max_align_t *, ptr) - JAS_MB_ADJUST);\n}\n\nvoid *jas_mb_get_data(jas_mb_t *mb)\n{\n\treturn JAS_CAST(void *, JAS_CAST(max_align_t *, mb) + JAS_MB_ADJUST);\n}\n\nvoid jas_set_max_mem_usage(size_t max_mem)\n{\n\tjas_max_mem = max_mem;\n}\n\nsize_t jas_get_mem_usage()\n{\n\treturn jas_mem;\n}\n\nvoid *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu)\\n\", size));\n#if defined(JAS_MALLOC_RETURN_NULL_PTR_FOR_ZERO_SIZE)\n\tif (!size) {\n\t\treturn 0;\n\t}\n#endif\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\tresult = 0;\n\t\tmb = 0;\n\t} else if (!jas_safe_size_add(jas_mem, size, &mem) || mem > jas_max_mem) {\n\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\tresult = 0;\n\t\tmb = 0;\n\t} else {\n\t\tJAS_DBGLOG(100, (\"jas_malloc: ext_size=%zu\\n\", ext_size));\n\t\tif ((mb = malloc(ext_size))) {\n\t\t\tresult = jas_mb_get_data(mb);\n\t\t\tmb->size = size;\n\t\t\tjas_mem = mem;\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tJAS_DBGLOG(99, (\"jas_malloc(%zu) -> %p (mb=%p)\\n\", size, result, mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n\nvoid *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n\nvoid jas_free(void *ptr)\n{\n\tjas_mb_t *mb;\n\tsize_t mem;\n\tsize_t size;\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tif (ptr) {\n\t\tmb = jas_get_mb(ptr);\n\t\tsize = mb->size;\n\t\tJAS_DBGLOG(101, (\"jas_free(%p) (mb=%p; size=%zu)\\n\", ptr, mb, size));\n\t\tif (!jas_safe_size_sub(jas_mem, size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t\tJAS_DBGLOG(100, (\"jas_free: free(%p)\\n\", mb));\n\t\tfree(mb);\n\t}\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n}\n\n#endif\n\n/******************************************************************************\\\n* Basic memory allocation and deallocation primitives.\n\\******************************************************************************/\n\n#if !defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\nvoid *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n\nvoid *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}\n\nvoid jas_free(void *ptr)\n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n\n#endif\n\n/******************************************************************************\\\n* Additional memory allocation and deallocation primitives\n* (mainly for overflow checking).\n\\******************************************************************************/\n\nvoid *jas_alloc2(size_t num_elements, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n\nvoid *jas_alloc3(size_t num_arrays, size_t array_size, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(array_size, element_size, &size) ||\n\t  !jas_safe_size_mul(size, num_arrays, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n\nvoid *jas_realloc2(void *ptr, size_t num_elements, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_realloc(ptr, size);\n}\n\nvoid *jas_calloc(size_t num_elements, size_t element_size)\n{\n\tvoid *ptr;\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\tif (!(ptr = jas_malloc(size))) {\n\t\treturn 0;\n\t}\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Sequence/Matrix Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <math.h>\n\n#include \"jasper/jas_seq.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Constructors and destructors.\n\\******************************************************************************/\n\njas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n{\n\tjas_matrix_t *matrix;\n\tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n\treturn matrix;\n}\n\njas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\treturn 0;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}\n\nvoid jas_matrix_destroy(jas_matrix_t *matrix)\n{\n\tif (matrix->data_) {\n\t\tassert(!(matrix->flags_ & JAS_MATRIX_REF));\n\t\tjas_free(matrix->data_);\n\t\tmatrix->data_ = 0;\n\t}\n\tif (matrix->rows_) {\n\t\tjas_free(matrix->rows_);\n\t\tmatrix->rows_ = 0;\n\t}\n\tjas_free(matrix);\n}\n\njas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x), jas_seq2d_xend(x),\n\t  jas_seq2d_yend(x));\n\tassert(y);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\njas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\n/******************************************************************************\\\n* Bind operations.\n\\******************************************************************************/\n\nvoid jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart, int ystart,\n  int xend, int yend)\n{\n\tjas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,\n\t  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);\n}\n\nvoid jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,\n  int r1, int c1)\n{\n\tint i;\n\n\tif (mat0->data_) {\n\t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n\t\t\tjas_free(mat0->data_);\n\t\t}\n\t\tmat0->data_ = 0;\n\t\tmat0->datasize_ = 0;\n\t}\n\tif (mat0->rows_) {\n\t\tjas_free(mat0->rows_);\n\t\tmat0->rows_ = 0;\n\t}\n\tmat0->flags_ |= JAS_MATRIX_REF;\n\tmat0->numrows_ = r1 - r0 + 1;\n\tmat0->numcols_ = c1 - c0 + 1;\n\tmat0->maxrows_ = mat0->numrows_;\n\tif (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {\n\t\t/*\n\t\t\tThere is no way to indicate failure to the caller.\n\t\t\tSo, we have no choice but to abort.\n\t\t\tIdeally, this function should have a non-void return type.\n\t\t\tIn practice, a non-void return type probably would not help\n\t\t\tmuch anyways as the caller would just have to terminate anyways.\n\t\t*/\n\t\tabort();\n\t}\n\n\tfor (i = 0; i < mat0->numrows_; ++i) {\n\t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;\n\t}\n\n\tmat0->xstart_ = mat1->xstart_ + c0;\n\tmat0->ystart_ = mat1->ystart_ + r0;\n\tmat0->xend_ = mat0->xstart_ + mat0->numcols_;\n\tmat0->yend_ = mat0->ystart_ + mat0->numrows_;\n}\n\n/******************************************************************************\\\n* Arithmetic operations.\n\\******************************************************************************/\n\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tdata = rowstart;\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\tv = *data;\n\t\t\t\tif (v < minval) {\n\t\t\t\t\t*data = minval;\n\t\t\t\t} else if (v > maxval) {\n\t\t\t\t\t*data = maxval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asr(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tassert(n >= 0);\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data >>= n;\n\t\t\t\t*data = jas_seqent_asr(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data <<= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nint jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[numcols * i];\n\t}\n\n\treturn 0;\n}\n\nvoid jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = val;\n\t\t\t}\n\t\t}\n\t}\n}\n\njas_matrix_t *jas_seq2d_input(FILE *in)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tint j;\n\tlong x;\n\tint numrows;\n\tint numcols;\n\tint xoff;\n\tint yoff;\n\n\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)\n\t\treturn 0;\n\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)\n\t\treturn 0;\n\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n\t\treturn 0;\n\n\tif (jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {\n\t\tabort();\n\t}\n\n\t/* Get matrix data. */\n\tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {\n\t\t\tif (fscanf(in, \"%ld\", &x) != 1) {\n\t\t\t\tjas_matrix_destroy(matrix);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));\n\t\t}\n\t}\n\n\treturn matrix;\n}\n\nint jas_seq2d_output(jas_matrix_t *matrix, FILE *out)\n{\n#define MAXLINELEN\t80\n\tint i;\n\tint j;\n\tjas_seqent_t x;\n\tchar buf[MAXLINELEN + 1];\n\tchar sbuf[MAXLINELEN + 1];\n\tint n;\n\n\tfprintf(out, \"%d %d\\n\", jas_seq2d_xstart(matrix),\n\t  jas_seq2d_ystart(matrix));\n\tfprintf(out, \"%d %d\\n\", jas_matrix_numcols(matrix),\n\t  jas_matrix_numrows(matrix));\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < jas_matrix_numrows(matrix); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); ++j) {\n\t\t\tx = jas_matrix_get(matrix, i, j);\n\t\t\tsprintf(sbuf, \"%s%4ld\", (strlen(buf) > 0) ? \" \" : \"\",\n\t\t\t  JAS_CAST(long, x));\n\t\t\tn = strlen(buf);\n\t\t\tif (n + strlen(sbuf) > MAXLINELEN) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t\tstrcat(buf, sbuf);\n\t\t\tif (j == jas_matrix_numcols(matrix) - 1) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tfputs(buf, out);\n\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Memory Allocator\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <assert.h>\n\n/* We need the prototype for memset. */\n#include <string.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\nstatic size_t jas_mem = 0;\nstatic size_t jas_max_mem = JAS_DEFAULT_MAX_MEM_USAGE;\n\ntypedef struct {\n\tsize_t size;\n} jas_mb_t;\n\n#define JAS_MB_ADJUST \\\n  ((sizeof(jas_mb_t) + sizeof(max_align_t) - 1) / sizeof(max_align_t))\n#define JAS_MB_SIZE (JAS_MB_ADJUST * sizeof(max_align_t))\n\njas_mb_t *jas_get_mb(void *ptr)\n{\n\treturn JAS_CAST(jas_mb_t *, JAS_CAST(max_align_t *, ptr) - JAS_MB_ADJUST);\n}\n\nvoid *jas_mb_get_data(jas_mb_t *mb)\n{\n\treturn JAS_CAST(void *, JAS_CAST(max_align_t *, mb) + JAS_MB_ADJUST);\n}\n\nvoid jas_set_max_mem_usage(size_t max_mem)\n{\n\tjas_max_mem = max_mem;\n}\n\nsize_t jas_get_mem_usage()\n{\n\treturn jas_mem;\n}\n\nvoid *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu)\\n\", size));\n#if defined(JAS_MALLOC_RETURN_NULL_PTR_FOR_ZERO_SIZE)\n\tif (!size) {\n\t\treturn 0;\n\t}\n#endif\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\tresult = 0;\n\t\tmb = 0;\n\t} else if (!jas_safe_size_add(jas_mem, size, &mem) || mem > jas_max_mem) {\n\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\tresult = 0;\n\t\tmb = 0;\n\t} else {\n\t\tJAS_DBGLOG(100, (\"jas_malloc: ext_size=%zu\\n\", ext_size));\n\t\tif ((mb = malloc(ext_size))) {\n\t\t\tresult = jas_mb_get_data(mb);\n\t\t\tmb->size = size;\n\t\t\tjas_mem = mem;\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tJAS_DBGLOG(99, (\"jas_malloc(%zu) -> %p (mb=%p)\\n\", size, result, mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n\nvoid *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n\nvoid jas_free(void *ptr)\n{\n\tjas_mb_t *mb;\n\tsize_t mem;\n\tsize_t size;\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tif (ptr) {\n\t\tmb = jas_get_mb(ptr);\n\t\tsize = mb->size;\n\t\tJAS_DBGLOG(101, (\"jas_free(%p) (mb=%p; size=%zu)\\n\", ptr, mb, size));\n\t\tif (!jas_safe_size_sub(jas_mem, size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t\tJAS_DBGLOG(100, (\"jas_free: free(%p)\\n\", mb));\n\t\tfree(mb);\n\t}\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n}\n\n#endif\n\n/******************************************************************************\\\n* Basic memory allocation and deallocation primitives.\n\\******************************************************************************/\n\n#if !defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\nvoid *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n\nvoid *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}\n\nvoid jas_free(void *ptr)\n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n\n#endif\n\n/******************************************************************************\\\n* Additional memory allocation and deallocation primitives\n* (mainly for overflow checking).\n\\******************************************************************************/\n\nvoid *jas_alloc2(size_t num_elements, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n\nvoid *jas_alloc3(size_t num_arrays, size_t array_size, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(array_size, element_size, &size) ||\n\t  !jas_safe_size_mul(size, num_arrays, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n\nvoid *jas_realloc2(void *ptr, size_t num_elements, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_realloc(ptr, size);\n}\n\nvoid *jas_calloc(size_t num_elements, size_t element_size)\n{\n\tvoid *ptr;\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\tif (!(ptr = jas_malloc(size))) {\n\t\treturn 0;\n\t}\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Sequence/Matrix Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <math.h>\n\n#include \"jasper/jas_seq.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Constructors and destructors.\n\\******************************************************************************/\n\njas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n{\n\tjas_matrix_t *matrix;\n\tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n\treturn matrix;\n}\n\njas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tsize_t size;\n\n\tmatrix = 0;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\tgoto error;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\tgoto error;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = 0;\n\n\t// matrix->datasize_ = numrows * numcols;\n\tif (!jas_safe_size_mul(numrows, numcols, &size)) {\n\t\tgoto error;\n\t}\n\tmatrix->datasize_ = size;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n\nerror:\n\tif (matrix) {\n\t\tjas_matrix_destroy(matrix);\n\t}\n\treturn 0;\n}\n\nvoid jas_matrix_destroy(jas_matrix_t *matrix)\n{\n\tif (matrix->data_) {\n\t\tassert(!(matrix->flags_ & JAS_MATRIX_REF));\n\t\tjas_free(matrix->data_);\n\t\tmatrix->data_ = 0;\n\t}\n\tif (matrix->rows_) {\n\t\tjas_free(matrix->rows_);\n\t\tmatrix->rows_ = 0;\n\t}\n\tjas_free(matrix);\n}\n\njas_seq2d_t *jas_seq2d_copy(jas_seq2d_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_seq2d_create(jas_seq2d_xstart(x), jas_seq2d_ystart(x), jas_seq2d_xend(x),\n\t  jas_seq2d_yend(x));\n\tassert(y);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\njas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}\n\n/******************************************************************************\\\n* Bind operations.\n\\******************************************************************************/\n\nvoid jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart, int ystart,\n  int xend, int yend)\n{\n\tjas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_,\n\t  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1);\n}\n\nvoid jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,\n  int r1, int c1)\n{\n\tint i;\n\n\tif (mat0->data_) {\n\t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n\t\t\tjas_free(mat0->data_);\n\t\t}\n\t\tmat0->data_ = 0;\n\t\tmat0->datasize_ = 0;\n\t}\n\tif (mat0->rows_) {\n\t\tjas_free(mat0->rows_);\n\t\tmat0->rows_ = 0;\n\t}\n\tmat0->flags_ |= JAS_MATRIX_REF;\n\tmat0->numrows_ = r1 - r0 + 1;\n\tmat0->numcols_ = c1 - c0 + 1;\n\tmat0->maxrows_ = mat0->numrows_;\n\tif (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {\n\t\t/*\n\t\t\tThere is no way to indicate failure to the caller.\n\t\t\tSo, we have no choice but to abort.\n\t\t\tIdeally, this function should have a non-void return type.\n\t\t\tIn practice, a non-void return type probably would not help\n\t\t\tmuch anyways as the caller would just have to terminate anyways.\n\t\t*/\n\t\tabort();\n\t}\n\n\tfor (i = 0; i < mat0->numrows_; ++i) {\n\t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;\n\t}\n\n\tmat0->xstart_ = mat1->xstart_ + c0;\n\tmat0->ystart_ = mat1->ystart_ + r0;\n\tmat0->xend_ = mat0->xstart_ + mat0->numcols_;\n\tmat0->yend_ = mat0->ystart_ + mat0->numrows_;\n}\n\n/******************************************************************************\\\n* Arithmetic operations.\n\\******************************************************************************/\n\nint jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t maxval)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t v;\n\tjas_seqent_t *rowstart;\n\tjas_seqent_t *data;\n\tint rowstep;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tdata = rowstart;\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\tv = *data;\n\t\t\t\tif (v < minval) {\n\t\t\t\t\t*data = minval;\n\t\t\t\t} else if (v > maxval) {\n\t\t\t\t\t*data = maxval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asr(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tassert(n >= 0);\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data >>= n;\n\t\t\t\t*data = jas_seqent_asr(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid jas_matrix_asl(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data <<= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/******************************************************************************\\\n* Code.\n\\******************************************************************************/\n\nint jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[numcols * i];\n\t}\n\n\treturn 0;\n}\n\nvoid jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = val;\n\t\t\t}\n\t\t}\n\t}\n}\n\njas_matrix_t *jas_seq2d_input(FILE *in)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tint j;\n\tlong x;\n\tint numrows;\n\tint numcols;\n\tint xoff;\n\tint yoff;\n\n\tif (fscanf(in, \"%d %d\", &xoff, &yoff) != 2)\n\t\treturn 0;\n\tif (fscanf(in, \"%d %d\", &numcols, &numrows) != 2)\n\t\treturn 0;\n\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n\t\treturn 0;\n\n\tif (jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {\n\t\tabort();\n\t}\n\n\t/* Get matrix data. */\n\tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {\n\t\t\tif (fscanf(in, \"%ld\", &x) != 1) {\n\t\t\t\tjas_matrix_destroy(matrix);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));\n\t\t}\n\t}\n\n\treturn matrix;\n}\n\nint jas_seq2d_output(jas_matrix_t *matrix, FILE *out)\n{\n#define MAXLINELEN\t80\n\tint i;\n\tint j;\n\tjas_seqent_t x;\n\tchar buf[MAXLINELEN + 1];\n\tchar sbuf[MAXLINELEN + 1];\n\tint n;\n\n\tfprintf(out, \"%d %d\\n\", jas_seq2d_xstart(matrix),\n\t  jas_seq2d_ystart(matrix));\n\tfprintf(out, \"%d %d\\n\", jas_matrix_numcols(matrix),\n\t  jas_matrix_numrows(matrix));\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < jas_matrix_numrows(matrix); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); ++j) {\n\t\t\tx = jas_matrix_get(matrix, i, j);\n\t\t\tsprintf(sbuf, \"%s%4ld\", (strlen(buf) > 0) ? \" \" : \"\",\n\t\t\t  JAS_CAST(long, x));\n\t\t\tn = strlen(buf);\n\t\t\tif (n + strlen(sbuf) > MAXLINELEN) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t\tstrcat(buf, sbuf);\n\t\t\tif (j == jas_matrix_numcols(matrix) - 1) {\n\t\t\t\tfputs(buf, out);\n\t\t\t\tfputs(\"\\n\", out);\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tfputs(buf, out);\n\n\treturn 0;\n}\n"], "filenames": ["src/libjasper/base/jas_malloc.c", "src/libjasper/base/jas_seq.c"], "buggy_code_start_loc": [241, 103], "buggy_code_end_loc": [251, 149], "fixing_code_start_loc": [241, 104], "fixing_code_end_loc": [251, 163], "type": "CWE-190", "message": "Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2016-10249", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T14:59:00.307", "lastModified": "2018-01-05T02:30:32.527", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n jpc_dec_tiledecode en jpc_dec.c en JasPer en versiones anteriores a 1.900.12 permite a atacantes remotos tener un impacto no especificado a trav\u00e9s de un archivo de imagen manipulado, lo que desencadena un desbordamiento de b\u00fafer basado en memoria din\u00e1mica."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.11", "matchCriteriaId": "E129594F-D501-42E8-B130-92C73270F1DD"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3827", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/93838", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/10/23/jasper-heap-based-buffer-overflow-in-jpc_dec_tiledecode-jpc_dec-c/", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568"}}