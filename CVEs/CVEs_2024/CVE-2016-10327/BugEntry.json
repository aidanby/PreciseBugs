{"buggy_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include <osl/endian.h>\n#include <basegfx/matrix/b2dhommatrix.hxx>\n#include <vcl/dibtools.hxx>\n#include <o3tl/make_unique.hxx>\n\n#include \"winmtf.hxx\"\n\n#include <memory>\n\n#ifdef DBG_UTIL\n#include <tools/stream.hxx>\n#include <vcl/pngwrite.hxx>\n#endif\n\nusing namespace std;\n\n// GDI-Array\n\n#define EMR_HEADER                      1\n#define EMR_POLYBEZIER                  2\n#define EMR_POLYGON                     3\n#define EMR_POLYLINE                    4\n#define EMR_POLYBEZIERTO                5\n#define EMR_POLYLINETO                  6\n#define EMR_POLYPOLYLINE                7\n#define EMR_POLYPOLYGON                 8\n#define EMR_SETWINDOWEXTEX              9\n#define EMR_SETWINDOWORGEX              10\n#define EMR_SETVIEWPORTEXTEX            11\n#define EMR_SETVIEWPORTORGEX            12\n#define EMR_SETBRUSHORGEX               13\n#define EMR_EOF                         14\n#define EMR_SETPIXELV                   15\n#define EMR_SETMAPPERFLAGS              16\n#define EMR_SETMAPMODE                  17\n#define EMR_SETBKMODE                   18\n#define EMR_SETPOLYFILLMODE             19\n#define EMR_SETROP2                     20\n#define EMR_SETSTRETCHBLTMODE           21\n#define EMR_SETTEXTALIGN                22\n#define EMR_SETCOLORADJUSTMENT          23\n#define EMR_SETTEXTCOLOR                24\n#define EMR_SETBKCOLOR                  25\n#define EMR_OFFSETCLIPRGN               26\n#define EMR_MOVETOEX                    27\n#define EMR_SETMETARGN                  28\n#define EMR_EXCLUDECLIPRECT             29\n#define EMR_INTERSECTCLIPRECT           30\n#define EMR_SCALEVIEWPORTEXTEX          31\n#define EMR_SCALEWINDOWEXTEX            32\n#define EMR_SAVEDC                      33\n#define EMR_RESTOREDC                   34\n#define EMR_SETWORLDTRANSFORM           35\n#define EMR_MODIFYWORLDTRANSFORM        36\n#define EMR_SELECTOBJECT                37\n#define EMR_CREATEPEN                   38\n#define EMR_CREATEBRUSHINDIRECT         39\n#define EMR_DELETEOBJECT                40\n#define EMR_ANGLEARC                    41\n#define EMR_ELLIPSE                     42\n#define EMR_RECTANGLE                   43\n#define EMR_ROUNDRECT                   44\n#define EMR_ARC                         45\n#define EMR_CHORD                       46\n#define EMR_PIE                         47\n#define EMR_SELECTPALETTE               48\n#define EMR_CREATEPALETTE               49\n#define EMR_SETPALETTEENTRIES           50\n#define EMR_RESIZEPALETTE               51\n#define EMR_REALIZEPALETTE              52\n#define EMR_EXTFLOODFILL                53\n#define EMR_LINETO                      54\n#define EMR_ARCTO                       55\n#define EMR_POLYDRAW                    56\n#define EMR_SETARCDIRECTION             57\n#define EMR_SETMITERLIMIT               58\n#define EMR_BEGINPATH                   59\n#define EMR_ENDPATH                     60\n#define EMR_CLOSEFIGURE                 61\n#define EMR_FILLPATH                    62\n#define EMR_STROKEANDFILLPATH           63\n#define EMR_STROKEPATH                  64\n#define EMR_FLATTENPATH                 65\n#define EMR_WIDENPATH                   66\n#define EMR_SELECTCLIPPATH              67\n#define EMR_ABORTPATH                   68\n\n#define EMR_GDICOMMENT                  70\n#define EMR_FILLRGN                     71\n#define EMR_FRAMERGN                    72\n#define EMR_INVERTRGN                   73\n#define EMR_PAINTRGN                    74\n#define EMR_EXTSELECTCLIPRGN            75\n#define EMR_BITBLT                      76\n#define EMR_STRETCHBLT                  77\n#define EMR_MASKBLT                     78\n#define EMR_PLGBLT                      79\n#define EMR_SETDIBITSTODEVICE           80\n#define EMR_STRETCHDIBITS               81\n#define EMR_EXTCREATEFONTINDIRECTW      82\n#define EMR_EXTTEXTOUTA                 83\n#define EMR_EXTTEXTOUTW                 84\n#define EMR_POLYBEZIER16                85\n#define EMR_POLYGON16                   86\n#define EMR_POLYLINE16                  87\n#define EMR_POLYBEZIERTO16              88\n#define EMR_POLYLINETO16                89\n#define EMR_POLYPOLYLINE16              90\n#define EMR_POLYPOLYGON16               91\n#define EMR_POLYDRAW16                  92\n#define EMR_CREATEMONOBRUSH             93\n#define EMR_CREATEDIBPATTERNBRUSHPT     94\n#define EMR_EXTCREATEPEN                95\n#define EMR_POLYTEXTOUTA                96\n#define EMR_POLYTEXTOUTW                97\n\n// WINDOWS VERSION >= 0x400\n#define EMR_SETICMMODE                  98\n#define EMR_CREATECOLORSPACE            99\n#define EMR_SETCOLORSPACE              100\n#define EMR_DELETECOLORSPACE           101\n#define EMR_GLSRECORD                  102\n#define EMR_GLSBOUNDEDRECORD           103\n#define EMR_PIXELFORMAT                104\n\n// WINDOWS VERSION >= 0x500\n#define EMR_DRAWESCAPE                 105\n#define EMR_EXTESCAPE                  106\n#define EMR_STARTDOC                   107\n#define EMR_SMALLTEXTOUT               108\n#define EMR_FORCEUFIMAPPING            109\n#define EMR_NAMEDESCAPE                110\n#define EMR_COLORCORRECTPALETTE        111\n#define EMR_SETICMPROFILEA             112\n#define EMR_SETICMPROFILEW             113\n#define EMR_ALPHABLEND                 114\n#define EMR_ALPHADIBBLEND              115\n#define EMR_TRANSPARENTBLT             116\n#define EMR_TRANSPARENTDIB             117\n#define EMR_GRADIENTFILL               118\n#define EMR_SETLINKEDUFIS              119\n#define EMR_SETTEXTJUSTIFICATION       120\n\nnamespace\n{\n\nconst char *\nrecord_type_name(sal_uInt32 nRecType)\n{\n#ifndef SAL_LOG_INFO\n    (void) nRecType;\n    return \"\";\n#else\n    switch( nRecType )\n    {\n    case EMR_HEADER: return \"HEADER\";\n    case EMR_POLYBEZIER: return \"POLYBEZIER\";\n    case EMR_POLYGON: return \"POLYGON\";\n    case EMR_POLYLINE: return \"POLYLINE\";\n    case EMR_POLYBEZIERTO: return \"POLYBEZIERTO\";\n    case EMR_POLYLINETO: return \"POLYLINETO\";\n    case EMR_POLYPOLYLINE: return \"POLYPOLYLINE\";\n    case EMR_POLYPOLYGON: return \"POLYPOLYGON\";\n    case EMR_SETWINDOWEXTEX: return \"SETWINDOWEXTEX\";\n    case EMR_SETWINDOWORGEX: return \"SETWINDOWORGEX\";\n    case EMR_SETVIEWPORTEXTEX: return \"SETVIEWPORTEXTEX\";\n    case EMR_SETVIEWPORTORGEX: return \"SETVIEWPORTORGEX\";\n    case EMR_SETBRUSHORGEX: return \"SETBRUSHORGEX\";\n    case EMR_EOF: return \"EOF\";\n    case EMR_SETPIXELV: return \"SETPIXELV\";\n    case EMR_SETMAPPERFLAGS: return \"SETMAPPERFLAGS\";\n    case EMR_SETMAPMODE: return \"SETMAPMODE\";\n    case EMR_SETBKMODE: return \"SETBKMODE\";\n    case EMR_SETPOLYFILLMODE: return \"SETPOLYFILLMODE\";\n    case EMR_SETROP2: return \"SETROP2\";\n    case EMR_SETSTRETCHBLTMODE: return \"SETSTRETCHBLTMODE\";\n    case EMR_SETTEXTALIGN: return \"SETTEXTALIGN\";\n    case EMR_SETCOLORADJUSTMENT: return \"SETCOLORADJUSTMENT\";\n    case EMR_SETTEXTCOLOR: return \"SETTEXTCOLOR\";\n    case EMR_SETBKCOLOR: return \"SETBKCOLOR\";\n    case EMR_OFFSETCLIPRGN: return \"OFFSETCLIPRGN\";\n    case EMR_MOVETOEX: return \"MOVETOEX\";\n    case EMR_SETMETARGN: return \"SETMETARGN\";\n    case EMR_EXCLUDECLIPRECT: return \"EXCLUDECLIPRECT\";\n    case EMR_INTERSECTCLIPRECT: return \"INTERSECTCLIPRECT\";\n    case EMR_SCALEVIEWPORTEXTEX: return \"SCALEVIEWPORTEXTEX\";\n    case EMR_SCALEWINDOWEXTEX: return \"SCALEWINDOWEXTEX\";\n    case EMR_SAVEDC: return \"SAVEDC\";\n    case EMR_RESTOREDC: return \"RESTOREDC\";\n    case EMR_SETWORLDTRANSFORM: return \"SETWORLDTRANSFORM\";\n    case EMR_MODIFYWORLDTRANSFORM: return \"MODIFYWORLDTRANSFORM\";\n    case EMR_SELECTOBJECT: return \"SELECTOBJECT\";\n    case EMR_CREATEPEN: return \"CREATEPEN\";\n    case EMR_CREATEBRUSHINDIRECT: return \"CREATEBRUSHINDIRECT\";\n    case EMR_DELETEOBJECT: return \"DELETEOBJECT\";\n    case EMR_ANGLEARC: return \"ANGLEARC\";\n    case EMR_ELLIPSE: return \"ELLIPSE\";\n    case EMR_RECTANGLE: return \"RECTANGLE\";\n    case EMR_ROUNDRECT: return \"ROUNDRECT\";\n    case EMR_ARC: return \"ARC\";\n    case EMR_CHORD: return \"CHORD\";\n    case EMR_PIE: return \"PIE\";\n    case EMR_SELECTPALETTE: return \"SELECTPALETTE\";\n    case EMR_CREATEPALETTE: return \"CREATEPALETTE\";\n    case EMR_SETPALETTEENTRIES: return \"SETPALETTEENTRIES\";\n    case EMR_RESIZEPALETTE: return \"RESIZEPALETTE\";\n    case EMR_REALIZEPALETTE: return \"REALIZEPALETTE\";\n    case EMR_EXTFLOODFILL: return \"EXTFLOODFILL\";\n    case EMR_LINETO: return \"LINETO\";\n    case EMR_ARCTO: return \"ARCTO\";\n    case EMR_POLYDRAW: return \"POLYDRAW\";\n    case EMR_SETARCDIRECTION: return \"SETARCDIRECTION\";\n    case EMR_SETMITERLIMIT: return \"SETMITERLIMIT\";\n    case EMR_BEGINPATH: return \"BEGINPATH\";\n    case EMR_ENDPATH: return \"ENDPATH\";\n    case EMR_CLOSEFIGURE: return \"CLOSEFIGURE\";\n    case EMR_FILLPATH: return \"FILLPATH\";\n    case EMR_STROKEANDFILLPATH: return \"STROKEANDFILLPATH\";\n    case EMR_STROKEPATH: return \"STROKEPATH\";\n    case EMR_FLATTENPATH: return \"FLATTENPATH\";\n    case EMR_WIDENPATH: return \"WIDENPATH\";\n    case EMR_SELECTCLIPPATH: return \"SELECTCLIPPATH\";\n    case EMR_ABORTPATH: return \"ABORTPATH\";\n    case EMR_GDICOMMENT: return \"GDICOMMENT\";\n    case EMR_FILLRGN: return \"FILLRGN\";\n    case EMR_FRAMERGN: return \"FRAMERGN\";\n    case EMR_INVERTRGN: return \"INVERTRGN\";\n    case EMR_PAINTRGN: return \"PAINTRGN\";\n    case EMR_EXTSELECTCLIPRGN: return \"EXTSELECTCLIPRGN\";\n    case EMR_BITBLT: return \"BITBLT\";\n    case EMR_STRETCHBLT: return \"STRETCHBLT\";\n    case EMR_MASKBLT: return \"MASKBLT\";\n    case EMR_PLGBLT: return \"PLGBLT\";\n    case EMR_SETDIBITSTODEVICE: return \"SETDIBITSTODEVICE\";\n    case EMR_STRETCHDIBITS: return \"STRETCHDIBITS\";\n    case EMR_EXTCREATEFONTINDIRECTW: return \"EXTCREATEFONTINDIRECTW\";\n    case EMR_EXTTEXTOUTA: return \"EXTTEXTOUTA\";\n    case EMR_EXTTEXTOUTW: return \"EXTTEXTOUTW\";\n    case EMR_POLYBEZIER16: return \"POLYBEZIER16\";\n    case EMR_POLYGON16: return \"POLYGON16\";\n    case EMR_POLYLINE16: return \"POLYLINE16\";\n    case EMR_POLYBEZIERTO16: return \"POLYBEZIERTO16\";\n    case EMR_POLYLINETO16: return \"POLYLINETO16\";\n    case EMR_POLYPOLYLINE16: return \"POLYPOLYLINE16\";\n    case EMR_POLYPOLYGON16: return \"POLYPOLYGON16\";\n    case EMR_POLYDRAW16: return \"POLYDRAW16\";\n    case EMR_CREATEMONOBRUSH: return \"CREATEMONOBRUSH\";\n    case EMR_CREATEDIBPATTERNBRUSHPT: return \"CREATEDIBPATTERNBRUSHPT\";\n    case EMR_EXTCREATEPEN: return \"EXTCREATEPEN\";\n    case EMR_POLYTEXTOUTA: return \"POLYTEXTOUTA\";\n    case EMR_POLYTEXTOUTW: return \"POLYTEXTOUTW\";\n    case EMR_SETICMMODE: return \"SETICMMODE\";\n    case EMR_CREATECOLORSPACE: return \"CREATECOLORSPACE\";\n    case EMR_SETCOLORSPACE: return \"SETCOLORSPACE\";\n    case EMR_DELETECOLORSPACE: return \"DELETECOLORSPACE\";\n    case EMR_GLSRECORD: return \"GLSRECORD\";\n    case EMR_GLSBOUNDEDRECORD: return \"GLSBOUNDEDRECORD\";\n    case EMR_PIXELFORMAT: return \"PIXELFORMAT\";\n    case EMR_DRAWESCAPE: return \"DRAWESCAPE\";\n    case EMR_EXTESCAPE: return \"EXTESCAPE\";\n    case EMR_STARTDOC: return \"STARTDOC\";\n    case EMR_SMALLTEXTOUT: return \"SMALLTEXTOUT\";\n    case EMR_FORCEUFIMAPPING: return \"FORCEUFIMAPPING\";\n    case EMR_NAMEDESCAPE: return \"NAMEDESCAPE\";\n    case EMR_COLORCORRECTPALETTE: return \"COLORCORRECTPALETTE\";\n    case EMR_SETICMPROFILEA: return \"SETICMPROFILEA\";\n    case EMR_SETICMPROFILEW: return \"SETICMPROFILEW\";\n    case EMR_ALPHABLEND: return \"ALPHABLEND\";\n    case EMR_ALPHADIBBLEND: return \"ALPHADIBBLEND\";\n    case EMR_TRANSPARENTBLT: return \"TRANSPARENTBLT\";\n    case EMR_TRANSPARENTDIB: return \"TRANSPARENTDIB\";\n    case EMR_GRADIENTFILL: return \"GRADIENTFILL\";\n    case EMR_SETLINKEDUFIS: return \"SETLINKEDUFIS\";\n    case EMR_SETTEXTJUSTIFICATION: return \"SETTEXTJUSTIFICATION\";\n    default:\n        // Yes, return a pointer to a static buffer. This is a very\n        // local debugging output function, so no big deal.\n        static char buffer[11];\n        sprintf(buffer, \"0x%08\" SAL_PRIxUINT32, nRecType);\n        return buffer;\n    }\n#endif\n}\n\n#ifdef OSL_BIGENDIAN\n// little endian <-> big endian switch\nstatic float GetSwapFloat(SvStream& rStream)\n{\n    float fTmp;\n    sal_Int8* pPtr = (sal_Int8*)&fTmp;\n    rStream.ReadSChar(pPtr[3]);\n    rStream.ReadSChar(pPtr[2]);\n    rStream.ReadSChar(pPtr[1]);\n    rStream.ReadSChar(pPtr[0]);\n    return fTmp;\n}\n#endif\n\nstruct BLENDFUNCTION\n{\n    unsigned char aBlendOperation;\n    unsigned char aBlendFlags;\n    unsigned char aSrcConstantAlpha;\n    unsigned char aAlphaFormat;\n\n    friend SvStream& operator>>(SvStream& rInStream, BLENDFUNCTION& rBlendFun);\n};\n\nSvStream& operator>>(SvStream& rInStream, BLENDFUNCTION& rBlendFun)\n{\n    rInStream.ReadUChar(rBlendFun.aBlendOperation);\n    rInStream.ReadUChar(rBlendFun.aBlendFlags);\n    rInStream.ReadUChar(rBlendFun.aSrcConstantAlpha);\n    rInStream.ReadUChar(rBlendFun.aAlphaFormat);\n    return rInStream;\n}\n\nSvStream& operator>>(SvStream& rInStream, XForm& rXForm)\n{\n    if (sizeof(float) != 4)\n    {\n        OSL_FAIL( \"EnhWMFReader::sizeof( float ) != 4\" );\n        rXForm = XForm();\n    }\n    else\n    {\n#ifdef OSL_BIGENDIAN\n    rXForm.eM11 = GetSwapFloat(rInStream);\n    rXForm.eM12 = GetSwapFloat(rInStream);\n    rXForm.eM21 = GetSwapFloat(rInStream);\n    rXForm.eM22 = GetSwapFloat(rInStream);\n    rXForm.eDx = GetSwapFloat(rInStream);\n    rXForm.eDy = GetSwapFloat(rInStream);\n#else\n    rInStream.ReadFloat(rXForm.eM11);\n    rInStream.ReadFloat(rXForm.eM12);\n    rInStream.ReadFloat(rXForm.eM21);\n    rInStream.ReadFloat(rXForm.eM22);\n    rInStream.ReadFloat(rXForm.eDx);\n    rInStream.ReadFloat(rXForm.eDy);\n#endif\n    }\n    return rInStream;\n}\n\nbool ImplReadRegion( tools::PolyPolygon& rPolyPoly, SvStream& rStream, sal_uInt32 nLen )\n{\n    if (nLen == 0)\n        return false;\n\n    sal_uInt32 nHdSize, nType, nCount, nRgnSize, i;\n    rStream.ReadUInt32(nHdSize);\n    rStream.ReadUInt32(nType);\n    rStream.ReadUInt32(nCount);\n    rStream.ReadUInt32(nRgnSize);\n\n    if (   nCount > 0\n        && nType == RDH_RECTANGLES\n        && nLen >= ((nCount << 4) + (nHdSize - 16)))\n    {\n        sal_Int32 nx1, ny1, nx2, ny2;\n\n        for (i = 0; i < nCount; i++)\n        {\n            rStream.ReadInt32(nx1);\n            rStream.ReadInt32(ny1);\n            rStream.ReadInt32(nx2);\n            rStream.ReadInt32(ny2);\n\n            Rectangle aRectangle(Point(nx1, ny1), Point(nx2, ny2));\n\n            tools::Polygon aPolygon(aRectangle);\n            tools::PolyPolygon aPolyPolyOr1(aPolygon);\n            tools::PolyPolygon aPolyPolyOr2(rPolyPoly);\n            rPolyPoly.GetUnion(aPolyPolyOr1, aPolyPolyOr2);\n            rPolyPoly = aPolyPolyOr2;\n        }\n        return true;\n    }\n    return false;\n}\n\n} // anonymous namespace\n\nEnhWMFReader::EnhWMFReader(SvStream& rStream,GDIMetaFile& rGDIMetaFile,FilterConfigItem* pConfigItem)\n    : WinMtf(rGDIMetaFile, rStream , pConfigItem)\n    , bRecordPath(false)\n    , nRecordCount(0)\n    , bEMFPlus(false)\n{}\n\nEnhWMFReader::~EnhWMFReader()\n{}\n\nvoid EnhWMFReader::ReadEMFPlusComment(sal_uInt32 length, bool& bHaveDC)\n{\n    if (!bEMFPlus) {\n        pOut->PassEMFPlusHeaderInfo();\n\n#if OSL_DEBUG_LEVEL > 1\n        // debug code - write the stream to debug file /tmp/emf-stream.emf\n        sal_uInt64 const pos = pWMF->Tell();\n        pWMF->Seek(0);\n        SvFileStream file( OUString( \"/tmp/emf-stream.emf\" ), StreamMode::WRITE | StreamMode::TRUNC );\n\n        pWMF->WriteStream(file);\n        file.Flush();\n        file.Close();\n\n        pWMF->Seek( pos );\n#endif\n\n    }\n    bEMFPlus = true;\n\n    sal_uInt64 const pos = pWMF->Tell();\n    void *buffer = malloc( length );\n    pOut->PassEMFPlus( buffer, pWMF->ReadBytes(buffer, length) );\n    free( buffer );\n    pWMF->Seek( pos );\n\n    bHaveDC = false;\n\n    // skip in SeekRel if impossibly unavailable\n    sal_uInt32 nRemainder = length;\n\n    const size_t nRequiredHeaderSize = 12;\n    while (nRemainder >= nRequiredHeaderSize)\n    {\n        sal_uInt16 type(0), flags(0);\n        sal_uInt32 size(0), dataSize(0);\n\n        pWMF->ReadUInt16( type ).ReadUInt16( flags ).ReadUInt32( size ).ReadUInt32( dataSize );\n        nRemainder -= nRequiredHeaderSize;\n\n        SAL_INFO (\"vcl.emf\", \"\\t\\tEMF+ record type: \" << std::hex << type << std::dec);\n\n        // GetDC\n        if( type == 16388 ) {\n            bHaveDC = true;\n            SAL_INFO (\"vcl.emf\", \"\\t\\tEMF+ lock DC (device context)\");\n        }\n\n        // Get the length of the remaining data of this record based\n        // on the alleged size\n        sal_uInt32 nRemainingRecordData = size >= nRequiredHeaderSize ?\n            size-nRequiredHeaderSize : 0;\n        // clip to available size\n        nRemainingRecordData = std::min(nRemainingRecordData, nRemainder);\n        pWMF->SeekRel(nRemainingRecordData);\n        nRemainder -= nRemainingRecordData;\n    }\n    pWMF->SeekRel(nRemainder);\n}\n\n/**\n * Reads polygons from the stream.\n * The \\<class T> parameter is for the type of the points (sal_uInt32 or sal_uInt16).\n * The \\<class Drawer> parameter is a c++11 lambda for the method that will draw the polygon.\n * skipFirst: if the first point read is the 0th point or the 1st point in the array.\n * */\ntemplate <class T, class Drawer>\nvoid EnhWMFReader::ReadAndDrawPolygon(Drawer drawer, const bool skipFirst)\n{\n    sal_uInt32 nPoints(0), nStartIndex(0);\n    pWMF->SeekRel( 16 );\n    pWMF->ReadUInt32( nPoints );\n    if (skipFirst)\n    {\n        nPoints ++;\n        nStartIndex ++;\n    }\n\n    tools::Polygon aPolygon = ReadPolygon<T>(nStartIndex, nPoints);\n    drawer(pOut, aPolygon, skipFirst, bRecordPath);\n}\n\n/**\n * Reads polygons from the stream.\n * The \\<class T> parameter is for the type of the points\n * nStartIndex: which is the starting index in the polygon of the first point read\n * nPoints: number of points\n * pWMF: the stream containing the polygons\n * */\ntemplate <class T>\ntools::Polygon EnhWMFReader::ReadPolygon(sal_uInt32 nStartIndex, sal_uInt32 nPoints)\n{\n    bool bRecordOk = nPoints <= SAL_MAX_UINT16;\n    SAL_WARN_IF(!bRecordOk, \"vcl.emf\", \"polygon record has more polygons than we can handle\");\n    if (!bRecordOk)\n        return tools::Polygon();\n\n    tools::Polygon aPolygon(nPoints);\n    for (sal_uInt16 i = nStartIndex ; i < nPoints && pWMF->good(); i++ )\n    {\n        T nX, nY;\n        *pWMF >> nX >> nY;\n        if (!pWMF->good())\n            break;\n        aPolygon[ i ] = Point( nX, nY );\n    }\n\n    return aPolygon;\n}\n\n/**\n * Reads a polyline from the WMF file and draws it\n * The \\<class T> parameter refers to the type of the points. (e.g. sal_uInt16 or sal_uInt32)\n * */\ntemplate <class T>\nvoid EnhWMFReader::ReadAndDrawPolyLine()\n{\n    sal_uInt32  nPoints;\n    sal_Int32   i, nPoly(0), nGesPoints(0);\n    pWMF->SeekRel( 0x10 );\n    // Number of Polygons:\n    pWMF->ReadInt32( nPoly ).ReadInt32( nGesPoints );\n\n    // taking the amount of points of each polygon, retrieving the total number of points\n    if ( pWMF->good() &&\n         ( static_cast< sal_uInt32 >(nPoly) < SAL_MAX_UINT32 / sizeof(sal_uInt16) ) &&\n         ( static_cast< sal_uInt32 >( nPoly ) * sizeof(sal_uInt16) ) <= ( nEndPos - pWMF->Tell() )\n       )\n    {\n        std::unique_ptr<sal_uInt16[]> pnPoints(new sal_uInt16[ nPoly ]);\n        for ( i = 0; i < nPoly && pWMF->good(); i++ )\n        {\n            pWMF->ReadUInt32( nPoints );\n            pnPoints[ i ] = (sal_uInt16)nPoints;\n        }\n        // Get polygon points:\n        for ( i = 0; ( i < nPoly ) && pWMF->good(); i++ )\n        {\n            tools::Polygon aPolygon = ReadPolygon<T>(0, pnPoints[i]);\n            pOut->DrawPolyLine( aPolygon, false, bRecordPath );\n        }\n    }\n}\n\n// these are referenced from inside the templates\n\nSvStream& operator>>(SvStream& rStream, sal_Int16 &n)\n{\n    return rStream.ReadInt16(n);\n}\n\nSvStream& operator>>(SvStream& rStream, sal_Int32 &n)\n{\n    return rStream.ReadInt32(n);\n}\n\n/**\n * Reads a poly polygon from the WMF file and draws it.\n * The \\<class T> parameter refers to the type of the points. (e.g. sal_uInt16 or sal_uInt32)\n * */\ntemplate <class T>\nvoid EnhWMFReader::ReadAndDrawPolyPolygon()\n{\n    sal_uInt32 nPoly(0), nGesPoints(0), nReadPoints(0);\n    pWMF->SeekRel( 0x10 );\n    // Number of polygons\n    pWMF->ReadUInt32( nPoly ).ReadUInt32( nGesPoints );\n    if ( pWMF->good() &&\n        ( nGesPoints < SAL_MAX_UINT32 / sizeof(Point) ) && //check against numeric overflowing\n        ( nPoly < SAL_MAX_UINT32 / sizeof(sal_uInt16) ) &&\n        ( (  nPoly * sizeof( sal_uInt16 ) ) <= ( nEndPos - pWMF->Tell() ) ))\n    {\n        // Get number of points in each polygon\n        std::unique_ptr<sal_uInt16[]> pnPoints(new sal_uInt16[ nPoly ]);\n        for (sal_uInt32 i = 0; i < nPoly && pWMF->good(); ++i)\n        {\n            sal_uInt32 nPoints(0);\n            pWMF->ReadUInt32( nPoints );\n            pnPoints[ i ] = (sal_uInt16)nPoints;\n        }\n        if ( pWMF->good() && ( nGesPoints * (sizeof(T)+sizeof(T)) ) <= ( nEndPos - pWMF->Tell() ) )\n        {\n            // Get polygon points\n            tools::PolyPolygon aPolyPoly(nPoly, nPoly);\n            for (sal_uInt32 i = 0; i < nPoly && pWMF->good(); ++i)\n            {\n                const sal_uInt16 nPointCount(pnPoints[i]);\n                std::unique_ptr<Point[]> pPtAry(new Point[nPointCount]);\n                for (sal_uInt16 j = 0; j < nPointCount && pWMF->good(); ++j)\n                {\n                    T nX(0), nY(0);\n                    *pWMF >> nX >> nY;\n                    pPtAry[ j ] = Point( nX, nY );\n                    ++nReadPoints;\n                }\n\n                aPolyPoly.Insert( tools::Polygon(nPointCount, pPtAry.get()) );\n            }\n\n            pOut->DrawPolyPolygon( aPolyPoly, bRecordPath );\n        }\n\n        OSL_ENSURE(nReadPoints == nGesPoints, \"The number Points processed from EMR_POLYPOLYGON is unequal imported number (!)\");\n\n    }\n}\n\nbool EnhWMFReader::ReadEnhWMF()\n{\n    sal_uInt32  nStretchBltMode = 0;\n    sal_uInt32  nNextPos(0),\n                nW(0), nH(0), nColor(0), nIndex(0),\n                nDat32(0), nNom1(0), nDen1(0), nNom2(0), nDen2(0);\n    sal_Int32   nX32(0), nY32(0), nx32(0), ny32(0);\n\n    bool    bStatus = ReadHeader();\n    bool    bHaveDC = false;\n\n    static bool bEnableEMFPlus = ( getenv( \"EMF_PLUS_DISABLE\" ) == nullptr );\n\n    while( bStatus && nRecordCount-- && pWMF->good())\n    {\n        sal_uInt32  nRecType(0), nRecSize(0);\n        pWMF->ReadUInt32(nRecType).ReadUInt32(nRecSize);\n\n        if ( !pWMF->good() || ( nRecSize < 8 ) || ( nRecSize & 3 ) )     // Parameters are always divisible by 4\n        {\n            bStatus = false;\n            break;\n        }\n\n        auto nCurPos = pWMF->Tell();\n\n        if (nEndPos < nCurPos - 8)\n        {\n            bStatus = false;\n            break;\n        }\n\n        const sal_uInt32 nMaxPossibleRecSize = nEndPos - (nCurPos - 8);\n        if (nRecSize > nMaxPossibleRecSize)\n        {\n            bStatus = false;\n            break;\n        }\n\n        nNextPos = nCurPos + (nRecSize - 8);\n\n        if(  !aBmpSaveList.empty()\n          && ( nRecType != EMR_STRETCHBLT )\n          && ( nRecType != EMR_STRETCHDIBITS )\n          ) {\n            pOut->ResolveBitmapActions( aBmpSaveList );\n        }\n\n        bool bFlag = false;\n\n        SAL_INFO (\"vcl.emf\", \"0x\" << std::hex << (nNextPos - nRecSize) <<  \"-0x\" << nNextPos << \" \" << record_type_name(nRecType) << \" size: \" <<  nRecSize << std::dec);\n\n        if( bEnableEMFPlus && nRecType == EMR_GDICOMMENT ) {\n            sal_uInt32 length;\n\n            pWMF->ReadUInt32( length );\n\n            SAL_INFO(\"vcl.emf\", \"\\tGDI comment, length: \" << length);\n\n            if( pWMF->good() && length >= 4 && length <= pWMF->remainingSize() ) {\n                sal_uInt32 id;\n\n                pWMF->ReadUInt32( id );\n\n                SAL_INFO (\"vcl.emf\", \"\\t\\tbegin \" << (char)(id & 0xff) << (char)((id & 0xff00) >> 8) << (char)((id & 0xff0000) >> 16) << (char)((id & 0xff000000) >> 24) << \" id: 0x\" << std::hex << id << std::dec);\n\n                // EMF+ comment (FIXME: BE?)\n                if( id == 0x2B464D45 && nRecSize >= 12 )\n                    // [MS-EMF] 2.3.3: DataSize includes both CommentIdentifier and CommentRecordParm fields.\n                    // We have already read 4-byte CommentIdentifier, so reduce length appropriately\n                    ReadEMFPlusComment( length-4, bHaveDC );\n                // GDIC comment, doesn't do anything useful yet\n                else if( id == 0x43494447 && nRecSize >= 12 ) {\n                    // TODO: ReadGDIComment()\n                } else {\n                    SAL_INFO (\"vcl.emf\", \"\\t\\tunknown id: 0x\" << std::hex << id << std::dec);\n                }\n            }\n        }\n        else if( !bEMFPlus || bHaveDC || nRecType == EMR_EOF )\n        {\n            switch( nRecType )\n            {\n                case EMR_POLYBEZIERTO :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n                case EMR_POLYBEZIER :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYGON :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolygon( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYLINETO :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n\n                case EMR_POLYLINE :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYPOLYLINE :\n                    ReadAndDrawPolyLine<sal_Int32>();\n                break;\n\n                case EMR_POLYPOLYGON :\n                    ReadAndDrawPolyPolygon<sal_Int32>();\n                break;\n\n                case EMR_SETWINDOWEXTEX :\n                {\n                    pWMF->ReadUInt32( nW ).ReadUInt32( nH );\n                    pOut->SetWinExt( Size( nW, nH ), true);\n                }\n                break;\n\n                case EMR_SETWINDOWORGEX :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->SetWinOrg( Point( nX32, nY32 ), true);\n                }\n                break;\n\n                case EMR_SCALEWINDOWEXTEX :\n                {\n                    pWMF->ReadUInt32( nNom1 ).ReadUInt32( nDen1 ).ReadUInt32( nNom2 ).ReadUInt32( nDen2 );\n                    pOut->ScaleWinExt( (double)nNom1 / nDen1, (double)nNom2 / nDen2 );\n                }\n                break;\n\n                case EMR_SETVIEWPORTORGEX :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->SetDevOrg( Point( nX32, nY32 ) );\n                }\n                break;\n\n                case EMR_SCALEVIEWPORTEXTEX :\n                {\n                    pWMF->ReadUInt32( nNom1 ).ReadUInt32( nDen1 ).ReadUInt32( nNom2 ).ReadUInt32( nDen2 );\n                    pOut->ScaleDevExt( (double)nNom1 / nDen1, (double)nNom2 / nDen2 );\n                }\n                break;\n\n                case EMR_SETVIEWPORTEXTEX :\n                {\n                    pWMF->ReadUInt32( nW ).ReadUInt32( nH );\n                    pOut->SetDevExt( Size( nW, nH ) );\n                }\n                break;\n\n                case EMR_EOF :\n                    nRecordCount = 0;\n                break;\n\n                case EMR_SETPIXELV :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->DrawPixel( Point( nX32, nY32 ), ReadColor() );\n                }\n                break;\n\n                case EMR_SETMAPMODE :\n                {\n                    sal_uInt32 nMapMode;\n                    pWMF->ReadUInt32( nMapMode );\n                    pOut->SetMapMode( nMapMode );\n                }\n                break;\n\n                case EMR_SETBKMODE :\n                {\n                    pWMF->ReadUInt32( nDat32 );\n                    pOut->SetBkMode( static_cast<BkMode>(nDat32) );\n                }\n                break;\n\n                case EMR_SETPOLYFILLMODE :\n                break;\n\n                case EMR_SETROP2 :\n                {\n                    pWMF->ReadUInt32( nDat32 );\n                    pOut->SetRasterOp( (WMFRasterOp)nDat32 );\n                }\n                break;\n\n                case EMR_SETSTRETCHBLTMODE :\n                {\n                    pWMF->ReadUInt32( nStretchBltMode );\n                }\n                break;\n\n                case EMR_SETTEXTALIGN :\n                {\n                    pWMF->ReadUInt32( nDat32 );\n                    pOut->SetTextAlign( nDat32 );\n                }\n                break;\n\n                case EMR_SETTEXTCOLOR :\n                {\n                    pOut->SetTextColor( ReadColor() );\n                }\n                break;\n\n                case EMR_SETBKCOLOR :\n                {\n                    pOut->SetBkColor( ReadColor() );\n                }\n                break;\n\n                case EMR_OFFSETCLIPRGN :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->MoveClipRegion( Size( nX32, nY32 ) );\n                }\n                break;\n\n                case EMR_MOVETOEX :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->MoveTo( Point( nX32, nY32 ), bRecordPath );\n                }\n                break;\n\n                case EMR_INTERSECTCLIPRECT :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 );\n                    pOut->IntersectClipRect( ReadRectangle( nX32, nY32, nx32, ny32 ) );\n                }\n                break;\n\n                case EMR_SAVEDC :\n                {\n                    pOut->Push();\n                }\n                break;\n\n                case EMR_RESTOREDC :\n                {\n                    pOut->Pop();\n                }\n                break;\n\n                case EMR_SETWORLDTRANSFORM :\n                {\n                    XForm aTempXForm;\n                    *pWMF >> aTempXForm;\n                    pOut->SetWorldTransform( aTempXForm );\n                }\n                break;\n\n                case EMR_MODIFYWORLDTRANSFORM :\n                {\n                    sal_uInt32  nMode;\n                    XForm   aTempXForm;\n                    *pWMF >> aTempXForm;\n                    pWMF->ReadUInt32( nMode );\n                    pOut->ModifyWorldTransform( aTempXForm, nMode );\n                }\n                break;\n\n                case EMR_SELECTOBJECT :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    pOut->SelectObject( nIndex );\n                }\n                break;\n\n                case EMR_CREATEPEN :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n\n                        LineInfo    aLineInfo;\n                        sal_uInt32      nStyle;\n                        Size        aSize;\n                        // #fdo39428 Remove SvStream operator>>(long&)\n                        sal_Int32 nTmpW(0), nTmpH(0);\n\n                        pWMF->ReadUInt32( nStyle ).ReadInt32( nTmpW ).ReadInt32( nTmpH );\n                        aSize.Width() = nTmpW;\n                        aSize.Height() = nTmpH;\n\n                        if ( aSize.Width() )\n                            aLineInfo.SetWidth( aSize.Width() );\n\n                        bool bTransparent = false;\n                        switch( nStyle & PS_STYLE_MASK )\n                        {\n                            case PS_DASHDOTDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 2 );\n                            break;\n                            case PS_DASHDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 0 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DASH :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 0 );\n                            break;\n                            case PS_NULL :\n                                bTransparent = true;\n                                aLineInfo.SetStyle( LineStyle::NONE );\n                            break;\n                            case PS_INSIDEFRAME :\n                            case PS_SOLID :\n                            default :\n                                aLineInfo.SetStyle( LineStyle::Solid );\n                        }\n                        switch( nStyle & PS_ENDCAP_STYLE_MASK )\n                        {\n                            case PS_ENDCAP_ROUND :\n                                if ( aSize.Width() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_ROUND );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_SQUARE :\n                                if ( aSize.Width() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_SQUARE );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_FLAT :\n                            default :\n                                aLineInfo.SetLineCap( css::drawing::LineCap_BUTT );\n                        }\n                        switch( nStyle & PS_JOIN_STYLE_MASK )\n                        {\n                            case PS_JOIN_ROUND :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Round );\n                            break;\n                            case PS_JOIN_MITER :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Miter );\n                            break;\n                            case PS_JOIN_BEVEL :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Bevel );\n                            break;\n                            default :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::NONE );\n                        }\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfLineStyle>( ReadColor(), aLineInfo, bTransparent ));\n                    }\n                }\n                break;\n\n                case EMR_EXTCREATEPEN :\n                {\n                    sal_Int32   elpHatch;\n                    sal_uInt32  offBmi, cbBmi, offBits, cbBits, nStyle, nWidth, nBrushStyle, elpNumEntries;\n                    Color       aColorRef;\n\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        pWMF->ReadUInt32( offBmi ).ReadUInt32( cbBmi ).ReadUInt32( offBits ).ReadUInt32( cbBits ). ReadUInt32( nStyle ).ReadUInt32( nWidth ).ReadUInt32( nBrushStyle );\n                         aColorRef = ReadColor();\n                         pWMF->ReadInt32( elpHatch ).ReadUInt32( elpNumEntries );\n\n                        LineInfo    aLineInfo;\n                        if ( nWidth )\n                            aLineInfo.SetWidth( nWidth );\n\n                        bool bTransparent = false;\n\n                        switch( nStyle & PS_STYLE_MASK )\n                        {\n                            case PS_DASHDOTDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 2 );\n                            break;\n                            case PS_DASHDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 0 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DASH :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 0 );\n                            break;\n                            case PS_NULL :\n                                bTransparent = true;\n                                aLineInfo.SetStyle( LineStyle::NONE );\n                            break;\n\n                            case PS_INSIDEFRAME :\n                            case PS_SOLID :\n                            default :\n                                aLineInfo.SetStyle( LineStyle::Solid );\n                        }\n                        switch( nStyle & PS_ENDCAP_STYLE_MASK )\n                        {\n                            case PS_ENDCAP_ROUND :\n                                if ( aLineInfo.GetWidth() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_ROUND );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_SQUARE :\n                                if ( aLineInfo.GetWidth() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_SQUARE );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_FLAT :\n                            default :\n                                aLineInfo.SetLineCap( css::drawing::LineCap_BUTT );\n                        }\n                        switch( nStyle & PS_JOIN_STYLE_MASK )\n                        {\n                            case PS_JOIN_ROUND :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Round );\n                            break;\n                            case PS_JOIN_MITER :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Miter );\n                            break;\n                            case PS_JOIN_BEVEL :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Bevel );\n                            break;\n                            default :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::NONE );\n                        }\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfLineStyle>( aColorRef, aLineInfo, bTransparent ));\n                    }\n                }\n                break;\n\n                case EMR_CREATEBRUSHINDIRECT :\n                {\n                    sal_uInt32  nStyle;\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        pWMF->ReadUInt32( nStyle );\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfFillStyle>( ReadColor(), ( nStyle == BS_HOLLOW ) ));\n                    }\n                }\n                break;\n\n                case EMR_DELETEOBJECT :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                        pOut->DeleteObject( nIndex );\n                }\n                break;\n\n                case EMR_ELLIPSE :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 );\n                    pOut->DrawEllipse( ReadRectangle( nX32, nY32, nx32, ny32 ) );\n                }\n                break;\n\n                case EMR_RECTANGLE :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 );\n                    pOut->DrawRect( ReadRectangle( nX32, nY32, nx32, ny32 ) );\n                }\n                break;\n\n                case EMR_ROUNDRECT :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nW ).ReadUInt32( nH );\n                    Size aSize( Size( nW, nH ) );\n                    pOut->DrawRoundRect( ReadRectangle( nX32, nY32, nx32, ny32 ), aSize );\n                }\n                break;\n\n                case EMR_ARC :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    pOut->DrawArc( ReadRectangle( nX32, nY32, nx32, ny32 ), Point( nStartX, nStartY ), Point( nEndX, nEndY ) );\n                }\n                break;\n\n                case EMR_CHORD :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    pOut->DrawChord( ReadRectangle( nX32, nY32, nx32, ny32 ), Point( nStartX, nStartY ), Point( nEndX, nEndY ) );\n                }\n                break;\n\n                case EMR_PIE :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    const Rectangle aRect( ReadRectangle( nX32, nY32, nx32, ny32 ));\n\n                    // #i73608# OutputDevice deviates from WMF\n                    // semantics. start==end means full ellipse here.\n                    if( nStartX == nEndX && nStartY == nEndY )\n                        pOut->DrawEllipse( aRect );\n                    else\n                        pOut->DrawPie( aRect, Point( nStartX, nStartY ), Point( nEndX, nEndY ) );\n                }\n                break;\n\n                case EMR_LINETO :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->LineTo( Point( nX32, nY32 ), bRecordPath );\n                }\n                break;\n\n                case EMR_ARCTO :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    pOut->DrawArc( ReadRectangle( nX32, nY32, nx32, ny32 ), Point( nStartX, nStartY ), Point( nEndX, nEndY ), true );\n                }\n                break;\n\n                case EMR_BEGINPATH :\n                {\n                    pOut->ClearPath();\n                    bRecordPath = true;\n                }\n                break;\n\n                case EMR_ABORTPATH :\n                    pOut->ClearPath();\n                    SAL_FALLTHROUGH;\n                case EMR_ENDPATH :\n                    bRecordPath = false;\n                break;\n\n                case EMR_CLOSEFIGURE :\n                    pOut->ClosePath();\n                break;\n\n                case EMR_FILLPATH :\n                    pOut->StrokeAndFillPath( false, true );\n                break;\n\n                case EMR_STROKEANDFILLPATH :\n                    pOut->StrokeAndFillPath( true, true );\n                break;\n\n                case EMR_STROKEPATH :\n                    pOut->StrokeAndFillPath( true, false );\n                break;\n\n                case EMR_SELECTCLIPPATH :\n                {\n                    sal_Int32 nClippingMode;\n                    pWMF->ReadInt32(nClippingMode);\n                    pOut->SetClipPath(pOut->GetPathObj(), nClippingMode, true);\n                }\n                break;\n\n                case EMR_EXTSELECTCLIPRGN :\n                {\n                    sal_Int32 nClippingMode, cbRgnData;\n                    pWMF->ReadInt32(cbRgnData);\n                    pWMF->ReadInt32(nClippingMode);\n\n                    // This record's region data should be ignored if mode\n                    // is RGN_COPY - see EMF spec section 2.3.2.2\n                    if (nClippingMode == RGN_COPY)\n                    {\n                        pOut->SetDefaultClipPath();\n                    }\n                    else\n                    {\n                        tools::PolyPolygon aPolyPoly;\n                        if (cbRgnData)\n                            ImplReadRegion(aPolyPoly, *pWMF, nRecSize);\n                        pOut->SetClipPath(aPolyPoly, nClippingMode, false);\n                    }\n\n                }\n                break;\n\n                case EMR_ALPHABLEND:\n                {\n                    sal_Int32 xDest(0), yDest(0), cxDest(0), cyDest(0);\n\n                    BLENDFUNCTION aFunc;\n                    sal_Int32 xSrc(0), ySrc(0), cxSrc(0), cySrc(0);\n                    XForm xformSrc;\n                    sal_uInt32 BkColorSrc(0), iUsageSrc(0), offBmiSrc(0);\n                    sal_uInt32 cbBmiSrc(0), offBitsSrc(0), cbBitsSrc(0);\n\n                    sal_uInt32   nStart = pWMF->Tell() - 8;\n                    pWMF->SeekRel( 0x10 );\n\n                    pWMF->ReadInt32( xDest ).ReadInt32( yDest ).ReadInt32( cxDest ).ReadInt32( cyDest );\n                    *pWMF >> aFunc;\n                    pWMF->ReadInt32( xSrc ).ReadInt32( ySrc );\n                    *pWMF >> xformSrc;\n                    pWMF->ReadUInt32( BkColorSrc ).ReadUInt32( iUsageSrc ).ReadUInt32( offBmiSrc ).ReadUInt32( cbBmiSrc )\n                               .ReadUInt32( offBitsSrc ).ReadUInt32( cbBitsSrc ).ReadInt32( cxSrc ).ReadInt32( cySrc ) ;\n\n                    sal_uInt32  dwRop = SRCAND|SRCINVERT;\n                    Rectangle   aRect( Point( xDest, yDest ), Size( cxDest+1, cyDest+1 ) );\n\n                    if ( (cbBitsSrc > (SAL_MAX_UINT32 - 14)) || ((SAL_MAX_UINT32 - 14) - cbBitsSrc < cbBmiSrc) )\n                        bStatus = false;\n                    else\n                    {\n                        const sal_uInt32 nSourceSize = cbBmiSrc + cbBitsSrc + 14;\n                        if ( nSourceSize <= ( nEndPos - nStartPos ) )\n                        {\n                            // we need to read alpha channel data if AlphaFormat of BLENDFUNCTION is\n                            // AC_SRC_ALPHA (==0x01). To read it, create a temp DIB-File which is ready\n                            // for DIB-5 format\n                            const bool bReadAlpha(0x01 == aFunc.aAlphaFormat);\n                            const sal_uInt32 nDeltaToDIB5HeaderSize(bReadAlpha ? getDIBV5HeaderSize() - cbBmiSrc : 0);\n                            const sal_uInt32 nTargetSize(cbBmiSrc + nDeltaToDIB5HeaderSize + cbBitsSrc + 14);\n                            char* pBuf = new char[ nTargetSize ];\n                            SvMemoryStream aTmp( pBuf, nTargetSize, StreamMode::READ | StreamMode::WRITE );\n\n                            aTmp.ObjectOwnsMemory( true );\n\n                            // write BM-Header (14 bytes)\n                            aTmp.WriteUChar( 'B' )\n                                .WriteUChar( 'M' )\n                                .WriteUInt32( cbBitsSrc )\n                                .WriteUInt16( 0 )\n                                .WriteUInt16( 0 )\n                                .WriteUInt32( cbBmiSrc + nDeltaToDIB5HeaderSize + 14 );\n\n                            // copy DIBInfoHeader from source (cbBmiSrc bytes)\n                            pWMF->Seek( nStart + offBmiSrc );\n                            pWMF->ReadBytes(pBuf + 14, cbBmiSrc);\n\n                            if(bReadAlpha)\n                            {\n                                // need to add values for all stuff that DIBV5Header is bigger\n                                // than DIBInfoHeader, all values are correctly initialized to zero,\n                                // so we can use memset here\n                                memset(pBuf + cbBmiSrc + 14, 0, nDeltaToDIB5HeaderSize);\n                            }\n\n                            // copy bitmap data from source (offBitsSrc bytes)\n                            pWMF->Seek( nStart + offBitsSrc );\n                            pWMF->ReadBytes(pBuf + 14 + nDeltaToDIB5HeaderSize + cbBmiSrc, cbBitsSrc);\n                            aTmp.Seek( 0 );\n\n                            // prepare to read and fill BitmapEx\n                            BitmapEx aBitmapEx;\n\n                            if(bReadAlpha)\n                            {\n                                Bitmap aBitmap;\n                                AlphaMask aAlpha;\n\n                                if(ReadDIBV5(aBitmap, aAlpha, aTmp))\n                                {\n                                    aBitmapEx = BitmapEx(aBitmap, aAlpha);\n                                }\n                            }\n                            else\n                            {\n                                Bitmap aBitmap;\n\n                                if(ReadDIB(aBitmap, aTmp, true))\n                                {\n                                    if(0xff != aFunc.aSrcConstantAlpha)\n                                    {\n                                        // add const alpha channel\n                                        aBitmapEx = BitmapEx(\n                                            aBitmap,\n                                            AlphaMask(aBitmap.GetSizePixel(), &aFunc.aSrcConstantAlpha));\n                                    }\n                                    else\n                                    {\n                                        // just use Bitmap\n                                        aBitmapEx = BitmapEx(aBitmap);\n                                    }\n                                }\n                            }\n\n                            if(!aBitmapEx.IsEmpty())\n                            {\n                                // test if it is sensible to crop\n                                if ( ( cxSrc > 0 ) && ( cySrc > 0 ) &&\n                                    ( xSrc >= 0 ) && ( ySrc >= 0 ) &&\n                                        ( xSrc + cxSrc < aBitmapEx.GetSizePixel().Width() ) &&\n                                            ( ySrc + cySrc < aBitmapEx.GetSizePixel().Height() ) )\n                                {\n                                    const Rectangle aCropRect( Point( xSrc, ySrc ), Size( cxSrc, cySrc ) );\n\n                                    aBitmapEx.Crop( aCropRect );\n                                }\n\n#ifdef DBG_UTIL\n                                static bool bDoSaveForVisualControl(false);\n\n                                if(bDoSaveForVisualControl)\n                                {\n                                    SvFileStream aNew(OUString(\"c:\\\\metafile_content.png\"), StreamMode::WRITE|StreamMode::TRUNC);\n                                    vcl::PNGWriter aPNGWriter(aBitmapEx);\n                                    aPNGWriter.Write(aNew);\n                                }\n#endif\n                                aBmpSaveList.emplace_back(new BSaveStruct(aBitmapEx, aRect, dwRop));\n                            }\n                        }\n                    }\n                }\n                break;\n\n                case EMR_BITBLT :   // PASSTHROUGH INTENDED\n                case EMR_STRETCHBLT :\n                {\n                    sal_Int32   xDest, yDest, cxDest, cyDest, xSrc, ySrc, cxSrc, cySrc;\n                    sal_uInt32  dwRop, iUsageSrc, offBmiSrc, cbBmiSrc, offBitsSrc, cbBitsSrc;\n                    XForm   xformSrc;\n\n                    sal_uInt32  nStart = pWMF->Tell() - 8;\n\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadInt32( xDest ).ReadInt32( yDest ).ReadInt32( cxDest ).ReadInt32( cyDest ).ReadUInt32( dwRop ).ReadInt32( xSrc ).ReadInt32( ySrc )\n                            >> xformSrc;\n                    pWMF->ReadUInt32( nColor ).ReadUInt32( iUsageSrc ).ReadUInt32( offBmiSrc ).ReadUInt32( cbBmiSrc )\n                               .ReadUInt32( offBitsSrc ).ReadUInt32( cbBitsSrc );\n\n                    if ( nRecType == EMR_STRETCHBLT )\n                        pWMF->ReadInt32( cxSrc ).ReadInt32( cySrc );\n                    else\n                        cxSrc = cySrc = 0;\n\n                    Bitmap      aBitmap;\n                    Rectangle   aRect( Point( xDest, yDest ), Size( cxDest, cyDest ) );\n\n                    if ( (cbBitsSrc > (SAL_MAX_UINT32 - 14)) || ((SAL_MAX_UINT32 - 14) - cbBitsSrc < cbBmiSrc) )\n                        bStatus = false;\n                    else\n                    {\n                        sal_uInt32 nSize = cbBmiSrc + cbBitsSrc + 14;\n                        if ( nSize <= ( nEndPos - nStartPos ) )\n                        {\n                            char* pBuf = new char[ nSize ];\n                            SvMemoryStream aTmp( pBuf, nSize, StreamMode::READ | StreamMode::WRITE );\n                            aTmp.ObjectOwnsMemory( true );\n                            aTmp.WriteUChar( 'B' )\n                                .WriteUChar( 'M' )\n                                .WriteUInt32( cbBitsSrc )\n                                .WriteUInt16( 0 )\n                                .WriteUInt16( 0 )\n                                .WriteUInt32( cbBmiSrc + 14 );\n                            pWMF->Seek( nStart + offBmiSrc );\n                            pWMF->ReadBytes(pBuf + 14, cbBmiSrc);\n                            pWMF->Seek( nStart + offBitsSrc );\n                            pWMF->ReadBytes(pBuf + 14 + cbBmiSrc, cbBitsSrc);\n                            aTmp.Seek( 0 );\n                            ReadDIB(aBitmap, aTmp, true);\n\n                            // test if it is sensible to crop\n                            if ( ( cxSrc > 0 ) && ( cySrc > 0 ) &&\n                                ( xSrc >= 0 ) && ( ySrc >= 0 ) &&\n                                    ( xSrc + cxSrc <= aBitmap.GetSizePixel().Width() ) &&\n                                        ( ySrc + cySrc <= aBitmap.GetSizePixel().Height() ) )\n                            {\n                                Rectangle aCropRect( Point( xSrc, ySrc ), Size( cxSrc, cySrc ) );\n                                aBitmap.Crop( aCropRect );\n                            }\n                            aBmpSaveList.emplace_back(new BSaveStruct(aBitmap, aRect, dwRop));\n                        }\n                    }\n                }\n                break;\n\n                case EMR_STRETCHDIBITS :\n                {\n                    sal_Int32   xDest, yDest, xSrc, ySrc, cxSrc, cySrc, cxDest, cyDest;\n                    sal_uInt32  offBmiSrc, cbBmiSrc, offBitsSrc, cbBitsSrc, iUsageSrc, dwRop;\n                    sal_uInt32  nStart = pWMF->Tell() - 8;\n\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadInt32( xDest )\n                         .ReadInt32( yDest )\n                         .ReadInt32( xSrc )\n                         .ReadInt32( ySrc )\n                         .ReadInt32( cxSrc )\n                         .ReadInt32( cySrc )\n                         .ReadUInt32( offBmiSrc )\n                         .ReadUInt32( cbBmiSrc )\n                         .ReadUInt32( offBitsSrc )\n                         .ReadUInt32( cbBitsSrc )\n                         .ReadUInt32( iUsageSrc )\n                         .ReadUInt32( dwRop )\n                         .ReadInt32( cxDest )\n                         .ReadInt32( cyDest );\n\n                    Bitmap      aBitmap;\n                    Rectangle   aRect( Point( xDest, yDest ), Size( cxDest, cyDest ) );\n\n                    if (  ((SAL_MAX_UINT32 - 14)             < cbBitsSrc)\n                       || ((SAL_MAX_UINT32 - 14) - cbBitsSrc < cbBmiSrc )\n                       )\n                    {\n                        bStatus = false;\n                    }\n                    else\n                    {\n                        sal_uInt32 nSize = cbBmiSrc + cbBitsSrc + 14;\n                        if ( nSize <= ( nEndPos - nStartPos ) )\n                        {\n                            char* pBuf = new char[ nSize ];\n                            SvMemoryStream aTmp( pBuf, nSize, StreamMode::READ | StreamMode::WRITE );\n                            aTmp.ObjectOwnsMemory( true );\n                            aTmp.WriteUChar( 'B' )\n                               .WriteUChar( 'M' )\n                               .WriteUInt32( cbBitsSrc )\n                               .WriteUInt16( 0 )\n                               .WriteUInt16( 0 )\n                               .WriteUInt32( cbBmiSrc + 14 );\n                            pWMF->Seek( nStart + offBmiSrc );\n                            pWMF->ReadBytes(pBuf + 14, cbBmiSrc);\n                            pWMF->Seek( nStart + offBitsSrc );\n                            pWMF->ReadBytes(pBuf + 14 + cbBmiSrc, cbBitsSrc);\n                            aTmp.Seek( 0 );\n                            ReadDIB(aBitmap, aTmp, true);\n\n                            // test if it is sensible to crop\n                            if ( ( cxSrc > 0 ) && ( cySrc > 0 ) &&\n                                ( xSrc >= 0 ) && ( ySrc >= 0 ) &&\n                                    ( xSrc + cxSrc <= aBitmap.GetSizePixel().Width() ) &&\n                                        ( ySrc + cySrc <= aBitmap.GetSizePixel().Height() ) )\n                            {\n                                Rectangle aCropRect( Point( xSrc, ySrc ), Size( cxSrc, cySrc ) );\n                                aBitmap.Crop( aCropRect );\n                            }\n                            aBmpSaveList.emplace_back(new BSaveStruct(aBitmap, aRect, dwRop));\n                        }\n                    }\n                }\n                break;\n\n                case EMR_EXTCREATEFONTINDIRECTW :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        LOGFONTW aLogFont;\n                        pWMF->ReadInt32( aLogFont.lfHeight )\n                             .ReadInt32( aLogFont.lfWidth )\n                             .ReadInt32( aLogFont.lfEscapement )\n                             .ReadInt32( aLogFont.lfOrientation )\n                             .ReadInt32( aLogFont.lfWeight )\n                             .ReadUChar( aLogFont.lfItalic )\n                             .ReadUChar( aLogFont.lfUnderline )\n                             .ReadUChar( aLogFont.lfStrikeOut )\n                             .ReadUChar( aLogFont.lfCharSet )\n                             .ReadUChar( aLogFont.lfOutPrecision )\n                             .ReadUChar( aLogFont.lfClipPrecision )\n                             .ReadUChar( aLogFont.lfQuality )\n                             .ReadUChar( aLogFont.lfPitchAndFamily );\n\n                        sal_Unicode lfFaceName[LF_FACESIZE+1];\n                        lfFaceName[LF_FACESIZE] = 0;\n                        for (int i = 0; i < LF_FACESIZE; ++i)\n                        {\n                            sal_uInt16 nChar(0);\n                            pWMF->ReadUInt16(nChar);\n                            lfFaceName[i] = nChar;\n                        }\n                        aLogFont.alfFaceName = OUString( lfFaceName );\n\n                        // #i123216# Not used in the test case of #121382# (always identity in XForm), also\n                        // no hints in ms docu if FontSize should be scaled with WT. Using with the example\n                        // from #i123216# creates errors, so removing.\n\n                        // // #i121382# Need to apply WorldTransform to FontHeight/Width; this should be completely\n                        // // changed to basegfx::B2DHomMatrix instead of 'struct XForm', but not now due to time\n                        // // constraints and dangers\n                        // const XForm& rXF = pOut->GetWorldTransform();\n                        // const basegfx::B2DHomMatrix aWT(rXF.eM11, rXF.eM21, rXF.eDx, rXF.eM12, rXF.eM22, rXF.eDy);\n                        // const basegfx::B2DVector aTransVec(aWT * basegfx::B2DVector(aLogFont.lfWidth, aLogFont.lfHeight));\n                        // aLogFont.lfWidth = aTransVec.getX();\n                        // aLogFont.lfHeight = aTransVec.getY();\n\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfFontStyle>( aLogFont ));\n                    }\n                }\n                break;\n\n                case EMR_EXTTEXTOUTA :\n                    bFlag = true;\n                    SAL_FALLTHROUGH;\n                case EMR_EXTTEXTOUTW :\n                {\n                    sal_Int32   nLeft, nTop, nRight, nBottom, ptlReferenceX, ptlReferenceY, nGfxMode, nXScale, nYScale;\n                    sal_uInt32  nOffString, nOptions, offDx;\n                    sal_Int32   nLen;\n                    std::vector<long> aDX;\n\n                    nCurPos = pWMF->Tell() - 8;\n\n                    pWMF->ReadInt32( nLeft ).ReadInt32( nTop ).ReadInt32( nRight ).ReadInt32( nBottom ).ReadInt32( nGfxMode ).ReadInt32( nXScale ).ReadInt32( nYScale )\n                       .ReadInt32( ptlReferenceX ).ReadInt32( ptlReferenceY ).ReadInt32( nLen ).ReadUInt32( nOffString ).ReadUInt32( nOptions );\n\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadUInt32( offDx );\n\n                    ComplexTextLayoutFlags nTextLayoutMode = ComplexTextLayoutFlags::Default;\n                    if ( nOptions & ETO_RTLREADING )\n                        nTextLayoutMode = ComplexTextLayoutFlags::BiDiRtl | ComplexTextLayoutFlags::TextOriginLeft;\n                    pOut->SetTextLayoutMode( nTextLayoutMode );\n                    SAL_WARN_IF( ( nOptions & ( ETO_PDY | ETO_GLYPH_INDEX ) ) != 0, \"vcl.emf\", \"SJ: ETO_PDY || ETO_GLYPH_INDEX in EMF\" );\n\n                    Point aPos( ptlReferenceX, ptlReferenceY );\n                    bool bLenSane = nLen > 0 && nLen < static_cast<sal_Int32>( SAL_MAX_UINT32 / sizeof(sal_Int32) );\n                    bool bOffStringSane = nOffString <= nEndPos - nCurPos;\n                    if (bLenSane && bOffStringSane)\n                    {\n                        if ( offDx && (( nCurPos + offDx + nLen * 4 ) <= nNextPos ) )\n                        {\n                            pWMF->Seek( nCurPos + offDx );\n                            if ( ( nLen * sizeof(sal_uInt32) ) <= ( nEndPos - pWMF->Tell() ) )\n                            {\n                                aDX.resize(nLen);\n                                for (sal_Int32 i = 0; i < nLen; ++i)\n                                {\n                                    sal_Int32 val(0);\n                                    pWMF->ReadInt32(val);\n                                    aDX[i] = val;\n                                }\n                            }\n                        }\n                        pWMF->Seek( nCurPos + nOffString );\n                        OUString aText;\n                        if ( bFlag )\n                        {\n                            if ( nLen <= static_cast<sal_Int32>( nEndPos - pWMF->Tell() ) )\n                            {\n                                std::unique_ptr<sal_Char[]> pBuf(new sal_Char[ nLen ]);\n                                pWMF->ReadBytes(pBuf.get(), nLen);\n                                aText = OUString(pBuf.get(), nLen, pOut->GetCharSet());\n                                pBuf.reset();\n\n                                if ( aText.getLength() != nLen )\n                                {\n                                    std::vector<long> aOldDX(aText.getLength());\n                                    aOldDX.swap(aDX);\n                                    sal_Int32 nDXLen = std::min<sal_Int32>(nLen, aOldDX.size());\n                                    for (sal_Int32 i = 0, j = 0; i < aText.getLength(); ++i)\n                                    {\n                                        sal_Unicode cUniChar = aText[i];\n                                        OString aCharacter(&cUniChar, 1, pOut->GetCharSet());\n                                        aDX[i] = 0;\n                                        for (sal_Int32 k = 0; ( k < aCharacter.getLength() ) && ( j < nDXLen ) && ( i < aText.getLength() ); ++k)\n                                            aDX[ i ] += aOldDX[j++];\n                                    }\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if ( ( nLen * sizeof(sal_Unicode) ) <= ( nEndPos - pWMF->Tell() ) )\n                            {\n                                std::unique_ptr<sal_Unicode[]> pBuf(new sal_Unicode[ nLen ]);\n                                pWMF->ReadBytes(pBuf.get(), nLen << 1);\n#ifdef OSL_BIGENDIAN\n                                sal_Char nTmp, *pTmp = (sal_Char*)( pBuf.get() + nLen );\n                                while ( pTmp-- != (sal_Char*)pBuf.get() )\n                                {\n                                    nTmp = *pTmp--;\n                                    pTmp[ 1 ] = *pTmp;\n                                    *pTmp = nTmp;\n                                }\n#endif\n                                aText = OUString(pBuf.get(), nLen);\n                            }\n                        }\n                        pOut->DrawText(aPos, aText, aDX.data(), bRecordPath, nGfxMode);\n                    }\n                }\n                break;\n\n                case EMR_POLYBEZIERTO16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n\n                case EMR_POLYBEZIER16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYGON16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolygon( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYLINETO16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n\n                case EMR_POLYLINE16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYPOLYLINE16 :\n                    ReadAndDrawPolyLine<sal_Int16>();\n                break;\n\n                case EMR_POLYPOLYGON16 :\n                    ReadAndDrawPolyPolygon<sal_Int16>();\n                break;\n\n                case EMR_FILLRGN :\n                {\n                    sal_uInt32 nLen;\n                    tools::PolyPolygon aPolyPoly;\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadUInt32( nLen ).ReadUInt32( nIndex );\n\n                    if ( ImplReadRegion( aPolyPoly, *pWMF, nRecSize ) )\n                    {\n                        pOut->Push();\n                        pOut->SelectObject( nIndex );\n                        pOut->DrawPolyPolygon( aPolyPoly );\n                        pOut->Pop();\n                    }\n                }\n                break;\n\n                case EMR_CREATEDIBPATTERNBRUSHPT :\n                {\n                    sal_uInt32  nStart = pWMF->Tell() - 8;\n                    Bitmap aBitmap;\n\n                    pWMF->ReadUInt32( nIndex );\n\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        sal_uInt32 usage, offBmi, cbBmi, offBits, cbBits;\n\n                        pWMF->ReadUInt32( usage );\n                        pWMF->ReadUInt32( offBmi );\n                        pWMF->ReadUInt32( cbBmi );\n                        pWMF->ReadUInt32( offBits );\n                        pWMF->ReadUInt32( cbBits );\n\n                        if ( (cbBits > (SAL_MAX_UINT32 - 14)) || ((SAL_MAX_UINT32 - 14) - cbBits < cbBmi) )\n                           bStatus = false;\n                        else if ( offBmi )\n                        {\n                            sal_uInt32  nSize = cbBmi + cbBits + 14;\n                            if ( nSize <= ( nEndPos - nStartPos ) )\n                            {\n                                char*   pBuf = new char[ nSize ];\n\n                                SvMemoryStream aTmp( pBuf, nSize, StreamMode::READ | StreamMode::WRITE );\n                                aTmp.ObjectOwnsMemory( true );\n                                aTmp.WriteUChar( 'B' )\n                                    .WriteUChar( 'M' )\n                                    .WriteUInt32( cbBits )\n                                    .WriteUInt16( 0 )\n                                    .WriteUInt16( 0 )\n                                    .WriteUInt32( cbBmi + 14 );\n                                pWMF->Seek( nStart + offBmi );\n                                pWMF->ReadBytes(pBuf + 14, cbBmi);\n                                pWMF->Seek( nStart + offBits );\n                                pWMF->ReadBytes(pBuf + 14 + cbBmi, cbBits);\n                                aTmp.Seek( 0 );\n                                ReadDIB(aBitmap, aTmp, true);\n                            }\n                        }\n                    }\n\n                    pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfFillStyle>( aBitmap ));\n                }\n                break;\n\n                case EMR_MASKBLT :                  SAL_INFO(\"vcl.emf\", \"not implemented 'MaskBlt'\");                   break;\n                case EMR_PLGBLT :                   SAL_INFO(\"vcl.emf\", \"not implemented 'PlgBlt'\");                    break;\n                case EMR_SETDIBITSTODEVICE :        SAL_INFO(\"vcl.emf\", \"not implemented 'SetDIBitsToDevice'\");         break;\n                case EMR_FRAMERGN :                 SAL_INFO(\"vcl.emf\", \"not implemented 'FrameRgn'\");                  break;\n                case EMR_INVERTRGN :                SAL_INFO(\"vcl.emf\", \"not implemented 'InvertRgn'\");                 break;\n                case EMR_PAINTRGN :                 SAL_INFO(\"vcl.emf\", \"not implemented 'PaintRgn'\");                  break;\n                case EMR_FLATTENPATH :              SAL_INFO(\"vcl.emf\", \"not implemented 'FlattenPath'\");               break;\n                case EMR_WIDENPATH :                SAL_INFO(\"vcl.emf\", \"not implemented 'WidenPath'\");                 break;\n                case EMR_POLYDRAW :                 SAL_INFO(\"vcl.emf\", \"not implemented 'Polydraw'\");                  break;\n                case EMR_SETARCDIRECTION :          SAL_INFO(\"vcl.emf\", \"not implemented 'SetArcDirection'\");           break;\n                case EMR_SETPALETTEENTRIES :        SAL_INFO(\"vcl.emf\", \"not implemented 'SetPaletteEntries'\");         break;\n                case EMR_RESIZEPALETTE :            SAL_INFO(\"vcl.emf\", \"not implemented 'ResizePalette'\");             break;\n                case EMR_EXTFLOODFILL :             SAL_INFO(\"vcl.emf\", \"not implemented 'ExtFloodFill'\");              break;\n                case EMR_ANGLEARC :                 SAL_INFO(\"vcl.emf\", \"not implemented 'AngleArc'\");                  break;\n                case EMR_SETCOLORADJUSTMENT :       SAL_INFO(\"vcl.emf\", \"not implemented 'SetColorAdjustment'\");        break;\n                case EMR_POLYDRAW16 :               SAL_INFO(\"vcl.emf\", \"not implemented 'PolyDraw16'\");                break;\n                case EMR_POLYTEXTOUTA :             SAL_INFO(\"vcl.emf\", \"not implemented 'PolyTextOutA'\");              break;\n                case EMR_POLYTEXTOUTW :             SAL_INFO(\"vcl.emf\", \"not implemented 'PolyTextOutW'\");              break;\n                case EMR_CREATECOLORSPACE :         SAL_INFO(\"vcl.emf\", \"not implemented 'CreateColorSpace'\");          break;\n                case EMR_SETCOLORSPACE :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetColorSpace'\");             break;\n                case EMR_DELETECOLORSPACE :         SAL_INFO(\"vcl.emf\", \"not implemented 'DeleteColorSpace'\");          break;\n                case EMR_GLSRECORD :                SAL_INFO(\"vcl.emf\", \"not implemented 'GlsRecord'\");                 break;\n                case EMR_GLSBOUNDEDRECORD :         SAL_INFO(\"vcl.emf\", \"not implemented 'GlsBoundRecord'\");            break;\n                case EMR_PIXELFORMAT :              SAL_INFO(\"vcl.emf\", \"not implemented 'PixelFormat'\");               break;\n                case EMR_DRAWESCAPE :               SAL_INFO(\"vcl.emf\", \"not implemented 'DrawEscape'\");                break;\n                case EMR_EXTESCAPE :                SAL_INFO(\"vcl.emf\", \"not implemented 'ExtEscape'\");                 break;\n                case EMR_STARTDOC :                 SAL_INFO(\"vcl.emf\", \"not implemented 'StartDoc'\");                  break;\n                case EMR_SMALLTEXTOUT :             SAL_INFO(\"vcl.emf\", \"not implemented 'SmallTextOut'\");              break;\n                case EMR_FORCEUFIMAPPING :          SAL_INFO(\"vcl.emf\", \"not implemented 'ForceUFIMapping'\");           break;\n                case EMR_NAMEDESCAPE :              SAL_INFO(\"vcl.emf\", \"not implemented 'NamedEscape'\");               break;\n                case EMR_COLORCORRECTPALETTE :      SAL_INFO(\"vcl.emf\", \"not implemented 'ColorCorrectPalette'\");       break;\n                case EMR_SETICMPROFILEA :           SAL_INFO(\"vcl.emf\", \"not implemented 'SetICMProfileA'\");            break;\n                case EMR_SETICMPROFILEW :           SAL_INFO(\"vcl.emf\", \"not implemented 'SetICMProfileW'\");            break;\n                case EMR_TRANSPARENTBLT :           SAL_INFO(\"vcl.emf\", \"not implemented 'TransparenBlt'\");             break;\n                case EMR_TRANSPARENTDIB :           SAL_INFO(\"vcl.emf\", \"not implemented 'TransparenDib'\");             break;\n                case EMR_GRADIENTFILL :             SAL_INFO(\"vcl.emf\", \"not implemented 'GradientFill'\");              break;\n                case EMR_SETLINKEDUFIS :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetLinkedUFIS'\");             break;\n\n                case EMR_SETMAPPERFLAGS :           SAL_INFO(\"vcl.emf\", \"not implemented 'SetMapperFlags'\");            break;\n                case EMR_SETICMMODE :               SAL_INFO(\"vcl.emf\", \"not implemented 'SetICMMode'\");                break;\n                case EMR_CREATEMONOBRUSH :          SAL_INFO(\"vcl.emf\", \"not implemented 'CreateMonoBrush'\");           break;\n                case EMR_SETBRUSHORGEX :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetBrushOrgEx'\");             break;\n                case EMR_SETMETARGN :               SAL_INFO(\"vcl.emf\", \"not implemented 'SetMetArgn'\");                break;\n                case EMR_SETMITERLIMIT :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetMiterLimit'\");             break;\n                case EMR_EXCLUDECLIPRECT :          SAL_INFO(\"vcl.emf\", \"not implemented 'ExcludeClipRect'\");           break;\n                case EMR_REALIZEPALETTE :           SAL_INFO(\"vcl.emf\", \"not implemented 'RealizePalette'\");            break;\n                case EMR_SELECTPALETTE :            SAL_INFO(\"vcl.emf\", \"not implemented 'SelectPalette'\");             break;\n                case EMR_CREATEPALETTE :            SAL_INFO(\"vcl.emf\", \"not implemented 'CreatePalette'\");             break;\n                case EMR_ALPHADIBBLEND :            SAL_INFO(\"vcl.emf\", \"not implemented 'AlphaDibBlend'\");             break;\n                case EMR_SETTEXTJUSTIFICATION :     SAL_INFO(\"vcl.emf\", \"not implemented 'SetTextJustification'\");      break;\n\n                case EMR_GDICOMMENT :\n                case EMR_HEADER :               // has already been read at ReadHeader()\n                break;\n\n                default :                           SAL_INFO(\"vcl.emf\", \"Unknown Meta Action\");                                     break;\n            }\n        }\n        pWMF->Seek( nNextPos );\n    }\n    if( !aBmpSaveList.empty() )\n        pOut->ResolveBitmapActions( aBmpSaveList );\n\n    if ( bStatus )\n        pWMF->Seek(nEndPos);\n\n    return bStatus;\n};\n\nbool EnhWMFReader::ReadHeader()\n{\n    sal_uInt32      nType, nSignature, nVersion;\n    sal_uInt32      nHeaderSize, nPalEntries;\n\n    // Spare me the METAFILEHEADER here\n    // Reading the METAHEADER - EMR_HEADER ([MS-EMF] section 2.3.4.2 EMR_HEADER Record Types)\n    pWMF->ReadUInt32( nType ).ReadUInt32( nHeaderSize );\n    if (nType != 0x00000001)\n    {\n        // per [MS-EMF] 2.3.4.2 EMF Header Record Types, type MUST be 0x00000001\n        SAL_WARN(\"vcl.emf\", \"EMF header type is not set to 0x00000001 - possibly corrupted file?\");\n        return false;\n    }\n\n    // Start reading the EMR_HEADER Header object\n\n    // bound size (RectL object, see [MS-WMF] section 2.2.2.19)\n    Rectangle rclBounds = ReadRectangle(); // rectangle in logical units\n\n    // picture frame size (RectL object)\n    Rectangle rclFrame = ReadRectangle(); // rectangle in device units 1/100th mm\n\n    pWMF->ReadUInt32( nSignature );\n\n    // nSignature MUST be the ASCII characters \"FME\", see [WS-EMF] 2.2.9 Header Object\n    // and 2.1.14 FormatSignature Enumeration\n    if (nSignature != 0x464d4520)\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tSignature is not 0x464d4520 (\\\"FME\\\") - possibly corrupted file?\");\n        return false;\n    }\n\n    pWMF->ReadUInt32(nVersion);  // according to [WS-EMF] 2.2.9, this SHOULD be 0x0001000, however\n                                   // Microsoft note that not even Windows checks this...\n    if (nVersion != 0x00010000)\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tThis really should be 0x00010000, though not absolutely essential...\");\n    }\n\n    pWMF->ReadUInt32(nEndPos); // size of metafile\n    nEndPos += nStartPos;\n\n    sal_uInt32 nStrmPos = pWMF->Tell(); // checking if nEndPos is valid\n    pWMF->Seek(STREAM_SEEK_TO_END);\n    sal_uInt32 nActualFileSize = pWMF->Tell();\n\n    if ( nActualFileSize < nEndPos )\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tEMF Header object records number of bytes as \" << nEndPos\n                            << \", however the file size is actually \" << nActualFileSize\n                            << \" bytes. Possible file corruption?\");\n        nEndPos = nActualFileSize;\n    }\n    pWMF->Seek(nStrmPos);\n\n    pWMF->ReadInt32(nRecordCount);\n\n    if (nRecordCount <= 0)\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tEMF Header object shows record counter as <= 0! This shouldn't \"\n                            \"be possible... indicator of possible file corruption?\");\n        return false;\n    }\n\n    // the number of \"handles\", or graphics objects used in the metafile\n\n    sal_uInt16 nHandlesCount;\n    pWMF->ReadUInt16(nHandlesCount);\n\n    // the next 2 bytes are reserved, but according to [MS-EMF] section 2.2.9\n    // it MUST be 0x000 and MUST be ignored... the thing is, having such a specific\n    // value is actually pretty useful in checking if there is possible corruption\n\n    sal_uInt16 nReserved;\n    pWMF->ReadUInt16(nReserved);\n\n    if ( nReserved != 0x0000 )\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tEMF Header object's reserved field is NOT 0x0000... possible \"\n                            \"corruption?\");\n    }\n\n    // The next 4 bytes specifies the number of characters in the metafile description.\n    // The 4 bytes after that specific the offset from this record that contains the\n    // metafile description... zero means no description string.\n    // For now, we ignore it.\n\n    pWMF->SeekRel(0x8);\n\n    sal_Int32 nPixX, nPixY, nMillX, nMillY;\n    pWMF->ReadUInt32(nPalEntries);\n    pWMF->ReadInt32(nPixX);\n    pWMF->ReadInt32(nPixY);\n    pWMF->ReadInt32(nMillX);\n    pWMF->ReadInt32(nMillY);\n\n    pOut->SetrclFrame(rclFrame);\n    pOut->SetrclBounds(rclBounds);\n    pOut->SetRefPix(Size( nPixX, nPixY ) );\n    pOut->SetRefMill(Size( nMillX, nMillY ) );\n\n    pWMF->Seek(nStartPos + nHeaderSize);\n    return true;\n}\n\nRectangle EnhWMFReader::ReadRectangle()\n{\n    sal_Int32 nLeft, nTop, nRight, nBottom;\n    pWMF->ReadInt32(nLeft);\n    pWMF->ReadInt32(nTop);\n    pWMF->ReadInt32(nRight);\n    pWMF->ReadInt32(nBottom);\n    return Rectangle(nLeft, nTop, nRight, nBottom);\n}\n\nRectangle EnhWMFReader::ReadRectangle( sal_Int32 x1, sal_Int32 y1, sal_Int32 x2, sal_Int32 y2 )\n{\n    Point aTL ( Point( x1, y1 ) );\n    Point aBR( Point( --x2, --y2 ) );\n    return Rectangle( aTL, aBR );\n}\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "fixing_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include <osl/endian.h>\n#include <basegfx/matrix/b2dhommatrix.hxx>\n#include <vcl/dibtools.hxx>\n#include <o3tl/make_unique.hxx>\n\n#include \"winmtf.hxx\"\n\n#include <memory>\n\n#ifdef DBG_UTIL\n#include <tools/stream.hxx>\n#include <vcl/pngwrite.hxx>\n#endif\n\nusing namespace std;\n\n// GDI-Array\n\n#define EMR_HEADER                      1\n#define EMR_POLYBEZIER                  2\n#define EMR_POLYGON                     3\n#define EMR_POLYLINE                    4\n#define EMR_POLYBEZIERTO                5\n#define EMR_POLYLINETO                  6\n#define EMR_POLYPOLYLINE                7\n#define EMR_POLYPOLYGON                 8\n#define EMR_SETWINDOWEXTEX              9\n#define EMR_SETWINDOWORGEX              10\n#define EMR_SETVIEWPORTEXTEX            11\n#define EMR_SETVIEWPORTORGEX            12\n#define EMR_SETBRUSHORGEX               13\n#define EMR_EOF                         14\n#define EMR_SETPIXELV                   15\n#define EMR_SETMAPPERFLAGS              16\n#define EMR_SETMAPMODE                  17\n#define EMR_SETBKMODE                   18\n#define EMR_SETPOLYFILLMODE             19\n#define EMR_SETROP2                     20\n#define EMR_SETSTRETCHBLTMODE           21\n#define EMR_SETTEXTALIGN                22\n#define EMR_SETCOLORADJUSTMENT          23\n#define EMR_SETTEXTCOLOR                24\n#define EMR_SETBKCOLOR                  25\n#define EMR_OFFSETCLIPRGN               26\n#define EMR_MOVETOEX                    27\n#define EMR_SETMETARGN                  28\n#define EMR_EXCLUDECLIPRECT             29\n#define EMR_INTERSECTCLIPRECT           30\n#define EMR_SCALEVIEWPORTEXTEX          31\n#define EMR_SCALEWINDOWEXTEX            32\n#define EMR_SAVEDC                      33\n#define EMR_RESTOREDC                   34\n#define EMR_SETWORLDTRANSFORM           35\n#define EMR_MODIFYWORLDTRANSFORM        36\n#define EMR_SELECTOBJECT                37\n#define EMR_CREATEPEN                   38\n#define EMR_CREATEBRUSHINDIRECT         39\n#define EMR_DELETEOBJECT                40\n#define EMR_ANGLEARC                    41\n#define EMR_ELLIPSE                     42\n#define EMR_RECTANGLE                   43\n#define EMR_ROUNDRECT                   44\n#define EMR_ARC                         45\n#define EMR_CHORD                       46\n#define EMR_PIE                         47\n#define EMR_SELECTPALETTE               48\n#define EMR_CREATEPALETTE               49\n#define EMR_SETPALETTEENTRIES           50\n#define EMR_RESIZEPALETTE               51\n#define EMR_REALIZEPALETTE              52\n#define EMR_EXTFLOODFILL                53\n#define EMR_LINETO                      54\n#define EMR_ARCTO                       55\n#define EMR_POLYDRAW                    56\n#define EMR_SETARCDIRECTION             57\n#define EMR_SETMITERLIMIT               58\n#define EMR_BEGINPATH                   59\n#define EMR_ENDPATH                     60\n#define EMR_CLOSEFIGURE                 61\n#define EMR_FILLPATH                    62\n#define EMR_STROKEANDFILLPATH           63\n#define EMR_STROKEPATH                  64\n#define EMR_FLATTENPATH                 65\n#define EMR_WIDENPATH                   66\n#define EMR_SELECTCLIPPATH              67\n#define EMR_ABORTPATH                   68\n\n#define EMR_GDICOMMENT                  70\n#define EMR_FILLRGN                     71\n#define EMR_FRAMERGN                    72\n#define EMR_INVERTRGN                   73\n#define EMR_PAINTRGN                    74\n#define EMR_EXTSELECTCLIPRGN            75\n#define EMR_BITBLT                      76\n#define EMR_STRETCHBLT                  77\n#define EMR_MASKBLT                     78\n#define EMR_PLGBLT                      79\n#define EMR_SETDIBITSTODEVICE           80\n#define EMR_STRETCHDIBITS               81\n#define EMR_EXTCREATEFONTINDIRECTW      82\n#define EMR_EXTTEXTOUTA                 83\n#define EMR_EXTTEXTOUTW                 84\n#define EMR_POLYBEZIER16                85\n#define EMR_POLYGON16                   86\n#define EMR_POLYLINE16                  87\n#define EMR_POLYBEZIERTO16              88\n#define EMR_POLYLINETO16                89\n#define EMR_POLYPOLYLINE16              90\n#define EMR_POLYPOLYGON16               91\n#define EMR_POLYDRAW16                  92\n#define EMR_CREATEMONOBRUSH             93\n#define EMR_CREATEDIBPATTERNBRUSHPT     94\n#define EMR_EXTCREATEPEN                95\n#define EMR_POLYTEXTOUTA                96\n#define EMR_POLYTEXTOUTW                97\n\n// WINDOWS VERSION >= 0x400\n#define EMR_SETICMMODE                  98\n#define EMR_CREATECOLORSPACE            99\n#define EMR_SETCOLORSPACE              100\n#define EMR_DELETECOLORSPACE           101\n#define EMR_GLSRECORD                  102\n#define EMR_GLSBOUNDEDRECORD           103\n#define EMR_PIXELFORMAT                104\n\n// WINDOWS VERSION >= 0x500\n#define EMR_DRAWESCAPE                 105\n#define EMR_EXTESCAPE                  106\n#define EMR_STARTDOC                   107\n#define EMR_SMALLTEXTOUT               108\n#define EMR_FORCEUFIMAPPING            109\n#define EMR_NAMEDESCAPE                110\n#define EMR_COLORCORRECTPALETTE        111\n#define EMR_SETICMPROFILEA             112\n#define EMR_SETICMPROFILEW             113\n#define EMR_ALPHABLEND                 114\n#define EMR_ALPHADIBBLEND              115\n#define EMR_TRANSPARENTBLT             116\n#define EMR_TRANSPARENTDIB             117\n#define EMR_GRADIENTFILL               118\n#define EMR_SETLINKEDUFIS              119\n#define EMR_SETTEXTJUSTIFICATION       120\n\nnamespace\n{\n\nconst char *\nrecord_type_name(sal_uInt32 nRecType)\n{\n#ifndef SAL_LOG_INFO\n    (void) nRecType;\n    return \"\";\n#else\n    switch( nRecType )\n    {\n    case EMR_HEADER: return \"HEADER\";\n    case EMR_POLYBEZIER: return \"POLYBEZIER\";\n    case EMR_POLYGON: return \"POLYGON\";\n    case EMR_POLYLINE: return \"POLYLINE\";\n    case EMR_POLYBEZIERTO: return \"POLYBEZIERTO\";\n    case EMR_POLYLINETO: return \"POLYLINETO\";\n    case EMR_POLYPOLYLINE: return \"POLYPOLYLINE\";\n    case EMR_POLYPOLYGON: return \"POLYPOLYGON\";\n    case EMR_SETWINDOWEXTEX: return \"SETWINDOWEXTEX\";\n    case EMR_SETWINDOWORGEX: return \"SETWINDOWORGEX\";\n    case EMR_SETVIEWPORTEXTEX: return \"SETVIEWPORTEXTEX\";\n    case EMR_SETVIEWPORTORGEX: return \"SETVIEWPORTORGEX\";\n    case EMR_SETBRUSHORGEX: return \"SETBRUSHORGEX\";\n    case EMR_EOF: return \"EOF\";\n    case EMR_SETPIXELV: return \"SETPIXELV\";\n    case EMR_SETMAPPERFLAGS: return \"SETMAPPERFLAGS\";\n    case EMR_SETMAPMODE: return \"SETMAPMODE\";\n    case EMR_SETBKMODE: return \"SETBKMODE\";\n    case EMR_SETPOLYFILLMODE: return \"SETPOLYFILLMODE\";\n    case EMR_SETROP2: return \"SETROP2\";\n    case EMR_SETSTRETCHBLTMODE: return \"SETSTRETCHBLTMODE\";\n    case EMR_SETTEXTALIGN: return \"SETTEXTALIGN\";\n    case EMR_SETCOLORADJUSTMENT: return \"SETCOLORADJUSTMENT\";\n    case EMR_SETTEXTCOLOR: return \"SETTEXTCOLOR\";\n    case EMR_SETBKCOLOR: return \"SETBKCOLOR\";\n    case EMR_OFFSETCLIPRGN: return \"OFFSETCLIPRGN\";\n    case EMR_MOVETOEX: return \"MOVETOEX\";\n    case EMR_SETMETARGN: return \"SETMETARGN\";\n    case EMR_EXCLUDECLIPRECT: return \"EXCLUDECLIPRECT\";\n    case EMR_INTERSECTCLIPRECT: return \"INTERSECTCLIPRECT\";\n    case EMR_SCALEVIEWPORTEXTEX: return \"SCALEVIEWPORTEXTEX\";\n    case EMR_SCALEWINDOWEXTEX: return \"SCALEWINDOWEXTEX\";\n    case EMR_SAVEDC: return \"SAVEDC\";\n    case EMR_RESTOREDC: return \"RESTOREDC\";\n    case EMR_SETWORLDTRANSFORM: return \"SETWORLDTRANSFORM\";\n    case EMR_MODIFYWORLDTRANSFORM: return \"MODIFYWORLDTRANSFORM\";\n    case EMR_SELECTOBJECT: return \"SELECTOBJECT\";\n    case EMR_CREATEPEN: return \"CREATEPEN\";\n    case EMR_CREATEBRUSHINDIRECT: return \"CREATEBRUSHINDIRECT\";\n    case EMR_DELETEOBJECT: return \"DELETEOBJECT\";\n    case EMR_ANGLEARC: return \"ANGLEARC\";\n    case EMR_ELLIPSE: return \"ELLIPSE\";\n    case EMR_RECTANGLE: return \"RECTANGLE\";\n    case EMR_ROUNDRECT: return \"ROUNDRECT\";\n    case EMR_ARC: return \"ARC\";\n    case EMR_CHORD: return \"CHORD\";\n    case EMR_PIE: return \"PIE\";\n    case EMR_SELECTPALETTE: return \"SELECTPALETTE\";\n    case EMR_CREATEPALETTE: return \"CREATEPALETTE\";\n    case EMR_SETPALETTEENTRIES: return \"SETPALETTEENTRIES\";\n    case EMR_RESIZEPALETTE: return \"RESIZEPALETTE\";\n    case EMR_REALIZEPALETTE: return \"REALIZEPALETTE\";\n    case EMR_EXTFLOODFILL: return \"EXTFLOODFILL\";\n    case EMR_LINETO: return \"LINETO\";\n    case EMR_ARCTO: return \"ARCTO\";\n    case EMR_POLYDRAW: return \"POLYDRAW\";\n    case EMR_SETARCDIRECTION: return \"SETARCDIRECTION\";\n    case EMR_SETMITERLIMIT: return \"SETMITERLIMIT\";\n    case EMR_BEGINPATH: return \"BEGINPATH\";\n    case EMR_ENDPATH: return \"ENDPATH\";\n    case EMR_CLOSEFIGURE: return \"CLOSEFIGURE\";\n    case EMR_FILLPATH: return \"FILLPATH\";\n    case EMR_STROKEANDFILLPATH: return \"STROKEANDFILLPATH\";\n    case EMR_STROKEPATH: return \"STROKEPATH\";\n    case EMR_FLATTENPATH: return \"FLATTENPATH\";\n    case EMR_WIDENPATH: return \"WIDENPATH\";\n    case EMR_SELECTCLIPPATH: return \"SELECTCLIPPATH\";\n    case EMR_ABORTPATH: return \"ABORTPATH\";\n    case EMR_GDICOMMENT: return \"GDICOMMENT\";\n    case EMR_FILLRGN: return \"FILLRGN\";\n    case EMR_FRAMERGN: return \"FRAMERGN\";\n    case EMR_INVERTRGN: return \"INVERTRGN\";\n    case EMR_PAINTRGN: return \"PAINTRGN\";\n    case EMR_EXTSELECTCLIPRGN: return \"EXTSELECTCLIPRGN\";\n    case EMR_BITBLT: return \"BITBLT\";\n    case EMR_STRETCHBLT: return \"STRETCHBLT\";\n    case EMR_MASKBLT: return \"MASKBLT\";\n    case EMR_PLGBLT: return \"PLGBLT\";\n    case EMR_SETDIBITSTODEVICE: return \"SETDIBITSTODEVICE\";\n    case EMR_STRETCHDIBITS: return \"STRETCHDIBITS\";\n    case EMR_EXTCREATEFONTINDIRECTW: return \"EXTCREATEFONTINDIRECTW\";\n    case EMR_EXTTEXTOUTA: return \"EXTTEXTOUTA\";\n    case EMR_EXTTEXTOUTW: return \"EXTTEXTOUTW\";\n    case EMR_POLYBEZIER16: return \"POLYBEZIER16\";\n    case EMR_POLYGON16: return \"POLYGON16\";\n    case EMR_POLYLINE16: return \"POLYLINE16\";\n    case EMR_POLYBEZIERTO16: return \"POLYBEZIERTO16\";\n    case EMR_POLYLINETO16: return \"POLYLINETO16\";\n    case EMR_POLYPOLYLINE16: return \"POLYPOLYLINE16\";\n    case EMR_POLYPOLYGON16: return \"POLYPOLYGON16\";\n    case EMR_POLYDRAW16: return \"POLYDRAW16\";\n    case EMR_CREATEMONOBRUSH: return \"CREATEMONOBRUSH\";\n    case EMR_CREATEDIBPATTERNBRUSHPT: return \"CREATEDIBPATTERNBRUSHPT\";\n    case EMR_EXTCREATEPEN: return \"EXTCREATEPEN\";\n    case EMR_POLYTEXTOUTA: return \"POLYTEXTOUTA\";\n    case EMR_POLYTEXTOUTW: return \"POLYTEXTOUTW\";\n    case EMR_SETICMMODE: return \"SETICMMODE\";\n    case EMR_CREATECOLORSPACE: return \"CREATECOLORSPACE\";\n    case EMR_SETCOLORSPACE: return \"SETCOLORSPACE\";\n    case EMR_DELETECOLORSPACE: return \"DELETECOLORSPACE\";\n    case EMR_GLSRECORD: return \"GLSRECORD\";\n    case EMR_GLSBOUNDEDRECORD: return \"GLSBOUNDEDRECORD\";\n    case EMR_PIXELFORMAT: return \"PIXELFORMAT\";\n    case EMR_DRAWESCAPE: return \"DRAWESCAPE\";\n    case EMR_EXTESCAPE: return \"EXTESCAPE\";\n    case EMR_STARTDOC: return \"STARTDOC\";\n    case EMR_SMALLTEXTOUT: return \"SMALLTEXTOUT\";\n    case EMR_FORCEUFIMAPPING: return \"FORCEUFIMAPPING\";\n    case EMR_NAMEDESCAPE: return \"NAMEDESCAPE\";\n    case EMR_COLORCORRECTPALETTE: return \"COLORCORRECTPALETTE\";\n    case EMR_SETICMPROFILEA: return \"SETICMPROFILEA\";\n    case EMR_SETICMPROFILEW: return \"SETICMPROFILEW\";\n    case EMR_ALPHABLEND: return \"ALPHABLEND\";\n    case EMR_ALPHADIBBLEND: return \"ALPHADIBBLEND\";\n    case EMR_TRANSPARENTBLT: return \"TRANSPARENTBLT\";\n    case EMR_TRANSPARENTDIB: return \"TRANSPARENTDIB\";\n    case EMR_GRADIENTFILL: return \"GRADIENTFILL\";\n    case EMR_SETLINKEDUFIS: return \"SETLINKEDUFIS\";\n    case EMR_SETTEXTJUSTIFICATION: return \"SETTEXTJUSTIFICATION\";\n    default:\n        // Yes, return a pointer to a static buffer. This is a very\n        // local debugging output function, so no big deal.\n        static char buffer[11];\n        sprintf(buffer, \"0x%08\" SAL_PRIxUINT32, nRecType);\n        return buffer;\n    }\n#endif\n}\n\n#ifdef OSL_BIGENDIAN\n// little endian <-> big endian switch\nstatic float GetSwapFloat(SvStream& rStream)\n{\n    float fTmp;\n    sal_Int8* pPtr = (sal_Int8*)&fTmp;\n    rStream.ReadSChar(pPtr[3]);\n    rStream.ReadSChar(pPtr[2]);\n    rStream.ReadSChar(pPtr[1]);\n    rStream.ReadSChar(pPtr[0]);\n    return fTmp;\n}\n#endif\n\nstruct BLENDFUNCTION\n{\n    unsigned char aBlendOperation;\n    unsigned char aBlendFlags;\n    unsigned char aSrcConstantAlpha;\n    unsigned char aAlphaFormat;\n\n    friend SvStream& operator>>(SvStream& rInStream, BLENDFUNCTION& rBlendFun);\n};\n\nSvStream& operator>>(SvStream& rInStream, BLENDFUNCTION& rBlendFun)\n{\n    rInStream.ReadUChar(rBlendFun.aBlendOperation);\n    rInStream.ReadUChar(rBlendFun.aBlendFlags);\n    rInStream.ReadUChar(rBlendFun.aSrcConstantAlpha);\n    rInStream.ReadUChar(rBlendFun.aAlphaFormat);\n    return rInStream;\n}\n\nSvStream& operator>>(SvStream& rInStream, XForm& rXForm)\n{\n    if (sizeof(float) != 4)\n    {\n        OSL_FAIL( \"EnhWMFReader::sizeof( float ) != 4\" );\n        rXForm = XForm();\n    }\n    else\n    {\n#ifdef OSL_BIGENDIAN\n    rXForm.eM11 = GetSwapFloat(rInStream);\n    rXForm.eM12 = GetSwapFloat(rInStream);\n    rXForm.eM21 = GetSwapFloat(rInStream);\n    rXForm.eM22 = GetSwapFloat(rInStream);\n    rXForm.eDx = GetSwapFloat(rInStream);\n    rXForm.eDy = GetSwapFloat(rInStream);\n#else\n    rInStream.ReadFloat(rXForm.eM11);\n    rInStream.ReadFloat(rXForm.eM12);\n    rInStream.ReadFloat(rXForm.eM21);\n    rInStream.ReadFloat(rXForm.eM22);\n    rInStream.ReadFloat(rXForm.eDx);\n    rInStream.ReadFloat(rXForm.eDy);\n#endif\n    }\n    return rInStream;\n}\n\nbool ImplReadRegion( tools::PolyPolygon& rPolyPoly, SvStream& rStream, sal_uInt32 nLen )\n{\n    if (nLen == 0)\n        return false;\n\n    sal_uInt32 nHdSize, nType, nCount, nRgnSize, i;\n    rStream.ReadUInt32(nHdSize);\n    rStream.ReadUInt32(nType);\n    rStream.ReadUInt32(nCount);\n    rStream.ReadUInt32(nRgnSize);\n\n    if (   nCount > 0\n        && nType == RDH_RECTANGLES\n        && nLen >= ((nCount << 4) + (nHdSize - 16)))\n    {\n        sal_Int32 nx1, ny1, nx2, ny2;\n\n        for (i = 0; i < nCount; i++)\n        {\n            rStream.ReadInt32(nx1);\n            rStream.ReadInt32(ny1);\n            rStream.ReadInt32(nx2);\n            rStream.ReadInt32(ny2);\n\n            Rectangle aRectangle(Point(nx1, ny1), Point(nx2, ny2));\n\n            tools::Polygon aPolygon(aRectangle);\n            tools::PolyPolygon aPolyPolyOr1(aPolygon);\n            tools::PolyPolygon aPolyPolyOr2(rPolyPoly);\n            rPolyPoly.GetUnion(aPolyPolyOr1, aPolyPolyOr2);\n            rPolyPoly = aPolyPolyOr2;\n        }\n        return true;\n    }\n    return false;\n}\n\n} // anonymous namespace\n\nEnhWMFReader::EnhWMFReader(SvStream& rStream,GDIMetaFile& rGDIMetaFile,FilterConfigItem* pConfigItem)\n    : WinMtf(rGDIMetaFile, rStream , pConfigItem)\n    , bRecordPath(false)\n    , nRecordCount(0)\n    , bEMFPlus(false)\n{}\n\nEnhWMFReader::~EnhWMFReader()\n{}\n\nvoid EnhWMFReader::ReadEMFPlusComment(sal_uInt32 length, bool& bHaveDC)\n{\n    if (!bEMFPlus) {\n        pOut->PassEMFPlusHeaderInfo();\n\n#if OSL_DEBUG_LEVEL > 1\n        // debug code - write the stream to debug file /tmp/emf-stream.emf\n        sal_uInt64 const pos = pWMF->Tell();\n        pWMF->Seek(0);\n        SvFileStream file( OUString( \"/tmp/emf-stream.emf\" ), StreamMode::WRITE | StreamMode::TRUNC );\n\n        pWMF->WriteStream(file);\n        file.Flush();\n        file.Close();\n\n        pWMF->Seek( pos );\n#endif\n\n    }\n    bEMFPlus = true;\n\n    sal_uInt64 const pos = pWMF->Tell();\n    void *buffer = malloc( length );\n    pOut->PassEMFPlus( buffer, pWMF->ReadBytes(buffer, length) );\n    free( buffer );\n    pWMF->Seek( pos );\n\n    bHaveDC = false;\n\n    // skip in SeekRel if impossibly unavailable\n    sal_uInt32 nRemainder = length;\n\n    const size_t nRequiredHeaderSize = 12;\n    while (nRemainder >= nRequiredHeaderSize)\n    {\n        sal_uInt16 type(0), flags(0);\n        sal_uInt32 size(0), dataSize(0);\n\n        pWMF->ReadUInt16( type ).ReadUInt16( flags ).ReadUInt32( size ).ReadUInt32( dataSize );\n        nRemainder -= nRequiredHeaderSize;\n\n        SAL_INFO (\"vcl.emf\", \"\\t\\tEMF+ record type: \" << std::hex << type << std::dec);\n\n        // GetDC\n        if( type == 16388 ) {\n            bHaveDC = true;\n            SAL_INFO (\"vcl.emf\", \"\\t\\tEMF+ lock DC (device context)\");\n        }\n\n        // Get the length of the remaining data of this record based\n        // on the alleged size\n        sal_uInt32 nRemainingRecordData = size >= nRequiredHeaderSize ?\n            size-nRequiredHeaderSize : 0;\n        // clip to available size\n        nRemainingRecordData = std::min(nRemainingRecordData, nRemainder);\n        pWMF->SeekRel(nRemainingRecordData);\n        nRemainder -= nRemainingRecordData;\n    }\n    pWMF->SeekRel(nRemainder);\n}\n\n/**\n * Reads polygons from the stream.\n * The \\<class T> parameter is for the type of the points (sal_uInt32 or sal_uInt16).\n * The \\<class Drawer> parameter is a c++11 lambda for the method that will draw the polygon.\n * skipFirst: if the first point read is the 0th point or the 1st point in the array.\n * */\ntemplate <class T, class Drawer>\nvoid EnhWMFReader::ReadAndDrawPolygon(Drawer drawer, const bool skipFirst)\n{\n    sal_uInt32 nPoints(0), nStartIndex(0);\n    pWMF->SeekRel( 16 );\n    pWMF->ReadUInt32( nPoints );\n    if (skipFirst)\n    {\n        nPoints ++;\n        nStartIndex ++;\n    }\n\n    tools::Polygon aPolygon = ReadPolygon<T>(nStartIndex, nPoints);\n    drawer(pOut, aPolygon, skipFirst, bRecordPath);\n}\n\n/**\n * Reads polygons from the stream.\n * The \\<class T> parameter is for the type of the points\n * nStartIndex: which is the starting index in the polygon of the first point read\n * nPoints: number of points\n * pWMF: the stream containing the polygons\n * */\ntemplate <class T>\ntools::Polygon EnhWMFReader::ReadPolygon(sal_uInt32 nStartIndex, sal_uInt32 nPoints)\n{\n    bool bRecordOk = nPoints <= SAL_MAX_UINT16;\n    SAL_WARN_IF(!bRecordOk, \"vcl.emf\", \"polygon record has more polygons than we can handle\");\n    if (!bRecordOk)\n        return tools::Polygon();\n\n    tools::Polygon aPolygon(nPoints);\n    for (sal_uInt16 i = nStartIndex ; i < nPoints && pWMF->good(); i++ )\n    {\n        T nX, nY;\n        *pWMF >> nX >> nY;\n        if (!pWMF->good())\n            break;\n        aPolygon[ i ] = Point( nX, nY );\n    }\n\n    return aPolygon;\n}\n\n/**\n * Reads a polyline from the WMF file and draws it\n * The \\<class T> parameter refers to the type of the points. (e.g. sal_uInt16 or sal_uInt32)\n * */\ntemplate <class T>\nvoid EnhWMFReader::ReadAndDrawPolyLine()\n{\n    sal_uInt32  nPoints;\n    sal_Int32   i, nPoly(0), nGesPoints(0);\n    pWMF->SeekRel( 0x10 );\n    // Number of Polygons:\n    pWMF->ReadInt32( nPoly ).ReadInt32( nGesPoints );\n\n    // taking the amount of points of each polygon, retrieving the total number of points\n    if ( pWMF->good() &&\n         ( static_cast< sal_uInt32 >(nPoly) < SAL_MAX_UINT32 / sizeof(sal_uInt16) ) &&\n         ( static_cast< sal_uInt32 >( nPoly ) * sizeof(sal_uInt16) ) <= ( nEndPos - pWMF->Tell() )\n       )\n    {\n        std::unique_ptr<sal_uInt16[]> pnPoints(new sal_uInt16[ nPoly ]);\n        for ( i = 0; i < nPoly && pWMF->good(); i++ )\n        {\n            pWMF->ReadUInt32( nPoints );\n            pnPoints[ i ] = (sal_uInt16)nPoints;\n        }\n        // Get polygon points:\n        for ( i = 0; ( i < nPoly ) && pWMF->good(); i++ )\n        {\n            tools::Polygon aPolygon = ReadPolygon<T>(0, pnPoints[i]);\n            pOut->DrawPolyLine( aPolygon, false, bRecordPath );\n        }\n    }\n}\n\n// these are referenced from inside the templates\n\nSvStream& operator>>(SvStream& rStream, sal_Int16 &n)\n{\n    return rStream.ReadInt16(n);\n}\n\nSvStream& operator>>(SvStream& rStream, sal_Int32 &n)\n{\n    return rStream.ReadInt32(n);\n}\n\n/**\n * Reads a poly polygon from the WMF file and draws it.\n * The \\<class T> parameter refers to the type of the points. (e.g. sal_uInt16 or sal_uInt32)\n * */\ntemplate <class T>\nvoid EnhWMFReader::ReadAndDrawPolyPolygon()\n{\n    sal_uInt32 nPoly(0), nGesPoints(0), nReadPoints(0);\n    pWMF->SeekRel( 0x10 );\n    // Number of polygons\n    pWMF->ReadUInt32( nPoly ).ReadUInt32( nGesPoints );\n    if ( pWMF->good() &&\n        ( nGesPoints < SAL_MAX_UINT32 / sizeof(Point) ) && //check against numeric overflowing\n        ( nPoly < SAL_MAX_UINT32 / sizeof(sal_uInt16) ) &&\n        ( (  nPoly * sizeof( sal_uInt16 ) ) <= ( nEndPos - pWMF->Tell() ) ))\n    {\n        // Get number of points in each polygon\n        std::unique_ptr<sal_uInt16[]> pnPoints(new sal_uInt16[ nPoly ]);\n        for (sal_uInt32 i = 0; i < nPoly && pWMF->good(); ++i)\n        {\n            sal_uInt32 nPoints(0);\n            pWMF->ReadUInt32( nPoints );\n            pnPoints[ i ] = (sal_uInt16)nPoints;\n        }\n        if ( pWMF->good() && ( nGesPoints * (sizeof(T)+sizeof(T)) ) <= ( nEndPos - pWMF->Tell() ) )\n        {\n            // Get polygon points\n            tools::PolyPolygon aPolyPoly(nPoly, nPoly);\n            for (sal_uInt32 i = 0; i < nPoly && pWMF->good(); ++i)\n            {\n                const sal_uInt16 nPointCount(pnPoints[i]);\n                std::unique_ptr<Point[]> pPtAry(new Point[nPointCount]);\n                for (sal_uInt16 j = 0; j < nPointCount && pWMF->good(); ++j)\n                {\n                    T nX(0), nY(0);\n                    *pWMF >> nX >> nY;\n                    pPtAry[ j ] = Point( nX, nY );\n                    ++nReadPoints;\n                }\n\n                aPolyPoly.Insert( tools::Polygon(nPointCount, pPtAry.get()) );\n            }\n\n            pOut->DrawPolyPolygon( aPolyPoly, bRecordPath );\n        }\n\n        OSL_ENSURE(nReadPoints == nGesPoints, \"The number Points processed from EMR_POLYPOLYGON is unequal imported number (!)\");\n\n    }\n}\n\nbool EnhWMFReader::ReadEnhWMF()\n{\n    sal_uInt32  nStretchBltMode = 0;\n    sal_uInt32  nNextPos(0),\n                nW(0), nH(0), nColor(0), nIndex(0),\n                nDat32(0), nNom1(0), nDen1(0), nNom2(0), nDen2(0);\n    sal_Int32   nX32(0), nY32(0), nx32(0), ny32(0);\n\n    bool    bStatus = ReadHeader();\n    bool    bHaveDC = false;\n\n    static bool bEnableEMFPlus = ( getenv( \"EMF_PLUS_DISABLE\" ) == nullptr );\n\n    while( bStatus && nRecordCount-- && pWMF->good())\n    {\n        sal_uInt32  nRecType(0), nRecSize(0);\n        pWMF->ReadUInt32(nRecType).ReadUInt32(nRecSize);\n\n        if ( !pWMF->good() || ( nRecSize < 8 ) || ( nRecSize & 3 ) )     // Parameters are always divisible by 4\n        {\n            bStatus = false;\n            break;\n        }\n\n        auto nCurPos = pWMF->Tell();\n\n        if (nEndPos < nCurPos - 8)\n        {\n            bStatus = false;\n            break;\n        }\n\n        const sal_uInt32 nMaxPossibleRecSize = nEndPos - (nCurPos - 8);\n        if (nRecSize > nMaxPossibleRecSize)\n        {\n            bStatus = false;\n            break;\n        }\n\n        nNextPos = nCurPos + (nRecSize - 8);\n\n        if(  !aBmpSaveList.empty()\n          && ( nRecType != EMR_STRETCHBLT )\n          && ( nRecType != EMR_STRETCHDIBITS )\n          ) {\n            pOut->ResolveBitmapActions( aBmpSaveList );\n        }\n\n        bool bFlag = false;\n\n        SAL_INFO (\"vcl.emf\", \"0x\" << std::hex << (nNextPos - nRecSize) <<  \"-0x\" << nNextPos << \" \" << record_type_name(nRecType) << \" size: \" <<  nRecSize << std::dec);\n\n        if( bEnableEMFPlus && nRecType == EMR_GDICOMMENT ) {\n            sal_uInt32 length;\n\n            pWMF->ReadUInt32( length );\n\n            SAL_INFO(\"vcl.emf\", \"\\tGDI comment, length: \" << length);\n\n            if( pWMF->good() && length >= 4 && length <= pWMF->remainingSize() ) {\n                sal_uInt32 id;\n\n                pWMF->ReadUInt32( id );\n\n                SAL_INFO (\"vcl.emf\", \"\\t\\tbegin \" << (char)(id & 0xff) << (char)((id & 0xff00) >> 8) << (char)((id & 0xff0000) >> 16) << (char)((id & 0xff000000) >> 24) << \" id: 0x\" << std::hex << id << std::dec);\n\n                // EMF+ comment (FIXME: BE?)\n                if( id == 0x2B464D45 && nRecSize >= 12 )\n                    // [MS-EMF] 2.3.3: DataSize includes both CommentIdentifier and CommentRecordParm fields.\n                    // We have already read 4-byte CommentIdentifier, so reduce length appropriately\n                    ReadEMFPlusComment( length-4, bHaveDC );\n                // GDIC comment, doesn't do anything useful yet\n                else if( id == 0x43494447 && nRecSize >= 12 ) {\n                    // TODO: ReadGDIComment()\n                } else {\n                    SAL_INFO (\"vcl.emf\", \"\\t\\tunknown id: 0x\" << std::hex << id << std::dec);\n                }\n            }\n        }\n        else if( !bEMFPlus || bHaveDC || nRecType == EMR_EOF )\n        {\n            switch( nRecType )\n            {\n                case EMR_POLYBEZIERTO :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n                case EMR_POLYBEZIER :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYGON :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolygon( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYLINETO :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n\n                case EMR_POLYLINE :\n                    ReadAndDrawPolygon<sal_Int32>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYPOLYLINE :\n                    ReadAndDrawPolyLine<sal_Int32>();\n                break;\n\n                case EMR_POLYPOLYGON :\n                    ReadAndDrawPolyPolygon<sal_Int32>();\n                break;\n\n                case EMR_SETWINDOWEXTEX :\n                {\n                    pWMF->ReadUInt32( nW ).ReadUInt32( nH );\n                    pOut->SetWinExt( Size( nW, nH ), true);\n                }\n                break;\n\n                case EMR_SETWINDOWORGEX :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->SetWinOrg( Point( nX32, nY32 ), true);\n                }\n                break;\n\n                case EMR_SCALEWINDOWEXTEX :\n                {\n                    pWMF->ReadUInt32( nNom1 ).ReadUInt32( nDen1 ).ReadUInt32( nNom2 ).ReadUInt32( nDen2 );\n                    pOut->ScaleWinExt( (double)nNom1 / nDen1, (double)nNom2 / nDen2 );\n                }\n                break;\n\n                case EMR_SETVIEWPORTORGEX :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->SetDevOrg( Point( nX32, nY32 ) );\n                }\n                break;\n\n                case EMR_SCALEVIEWPORTEXTEX :\n                {\n                    pWMF->ReadUInt32( nNom1 ).ReadUInt32( nDen1 ).ReadUInt32( nNom2 ).ReadUInt32( nDen2 );\n                    pOut->ScaleDevExt( (double)nNom1 / nDen1, (double)nNom2 / nDen2 );\n                }\n                break;\n\n                case EMR_SETVIEWPORTEXTEX :\n                {\n                    pWMF->ReadUInt32( nW ).ReadUInt32( nH );\n                    pOut->SetDevExt( Size( nW, nH ) );\n                }\n                break;\n\n                case EMR_EOF :\n                    nRecordCount = 0;\n                break;\n\n                case EMR_SETPIXELV :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->DrawPixel( Point( nX32, nY32 ), ReadColor() );\n                }\n                break;\n\n                case EMR_SETMAPMODE :\n                {\n                    sal_uInt32 nMapMode;\n                    pWMF->ReadUInt32( nMapMode );\n                    pOut->SetMapMode( nMapMode );\n                }\n                break;\n\n                case EMR_SETBKMODE :\n                {\n                    pWMF->ReadUInt32( nDat32 );\n                    pOut->SetBkMode( static_cast<BkMode>(nDat32) );\n                }\n                break;\n\n                case EMR_SETPOLYFILLMODE :\n                break;\n\n                case EMR_SETROP2 :\n                {\n                    pWMF->ReadUInt32( nDat32 );\n                    pOut->SetRasterOp( (WMFRasterOp)nDat32 );\n                }\n                break;\n\n                case EMR_SETSTRETCHBLTMODE :\n                {\n                    pWMF->ReadUInt32( nStretchBltMode );\n                }\n                break;\n\n                case EMR_SETTEXTALIGN :\n                {\n                    pWMF->ReadUInt32( nDat32 );\n                    pOut->SetTextAlign( nDat32 );\n                }\n                break;\n\n                case EMR_SETTEXTCOLOR :\n                {\n                    pOut->SetTextColor( ReadColor() );\n                }\n                break;\n\n                case EMR_SETBKCOLOR :\n                {\n                    pOut->SetBkColor( ReadColor() );\n                }\n                break;\n\n                case EMR_OFFSETCLIPRGN :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->MoveClipRegion( Size( nX32, nY32 ) );\n                }\n                break;\n\n                case EMR_MOVETOEX :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->MoveTo( Point( nX32, nY32 ), bRecordPath );\n                }\n                break;\n\n                case EMR_INTERSECTCLIPRECT :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 );\n                    pOut->IntersectClipRect( ReadRectangle( nX32, nY32, nx32, ny32 ) );\n                }\n                break;\n\n                case EMR_SAVEDC :\n                {\n                    pOut->Push();\n                }\n                break;\n\n                case EMR_RESTOREDC :\n                {\n                    pOut->Pop();\n                }\n                break;\n\n                case EMR_SETWORLDTRANSFORM :\n                {\n                    XForm aTempXForm;\n                    *pWMF >> aTempXForm;\n                    pOut->SetWorldTransform( aTempXForm );\n                }\n                break;\n\n                case EMR_MODIFYWORLDTRANSFORM :\n                {\n                    sal_uInt32  nMode;\n                    XForm   aTempXForm;\n                    *pWMF >> aTempXForm;\n                    pWMF->ReadUInt32( nMode );\n                    pOut->ModifyWorldTransform( aTempXForm, nMode );\n                }\n                break;\n\n                case EMR_SELECTOBJECT :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    pOut->SelectObject( nIndex );\n                }\n                break;\n\n                case EMR_CREATEPEN :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n\n                        LineInfo    aLineInfo;\n                        sal_uInt32      nStyle;\n                        Size        aSize;\n                        // #fdo39428 Remove SvStream operator>>(long&)\n                        sal_Int32 nTmpW(0), nTmpH(0);\n\n                        pWMF->ReadUInt32( nStyle ).ReadInt32( nTmpW ).ReadInt32( nTmpH );\n                        aSize.Width() = nTmpW;\n                        aSize.Height() = nTmpH;\n\n                        if ( aSize.Width() )\n                            aLineInfo.SetWidth( aSize.Width() );\n\n                        bool bTransparent = false;\n                        switch( nStyle & PS_STYLE_MASK )\n                        {\n                            case PS_DASHDOTDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 2 );\n                            break;\n                            case PS_DASHDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 0 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DASH :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 0 );\n                            break;\n                            case PS_NULL :\n                                bTransparent = true;\n                                aLineInfo.SetStyle( LineStyle::NONE );\n                            break;\n                            case PS_INSIDEFRAME :\n                            case PS_SOLID :\n                            default :\n                                aLineInfo.SetStyle( LineStyle::Solid );\n                        }\n                        switch( nStyle & PS_ENDCAP_STYLE_MASK )\n                        {\n                            case PS_ENDCAP_ROUND :\n                                if ( aSize.Width() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_ROUND );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_SQUARE :\n                                if ( aSize.Width() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_SQUARE );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_FLAT :\n                            default :\n                                aLineInfo.SetLineCap( css::drawing::LineCap_BUTT );\n                        }\n                        switch( nStyle & PS_JOIN_STYLE_MASK )\n                        {\n                            case PS_JOIN_ROUND :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Round );\n                            break;\n                            case PS_JOIN_MITER :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Miter );\n                            break;\n                            case PS_JOIN_BEVEL :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Bevel );\n                            break;\n                            default :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::NONE );\n                        }\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfLineStyle>( ReadColor(), aLineInfo, bTransparent ));\n                    }\n                }\n                break;\n\n                case EMR_EXTCREATEPEN :\n                {\n                    sal_Int32   elpHatch;\n                    sal_uInt32  offBmi, cbBmi, offBits, cbBits, nStyle, nWidth, nBrushStyle, elpNumEntries;\n                    Color       aColorRef;\n\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        pWMF->ReadUInt32( offBmi ).ReadUInt32( cbBmi ).ReadUInt32( offBits ).ReadUInt32( cbBits ). ReadUInt32( nStyle ).ReadUInt32( nWidth ).ReadUInt32( nBrushStyle );\n                         aColorRef = ReadColor();\n                         pWMF->ReadInt32( elpHatch ).ReadUInt32( elpNumEntries );\n\n                        LineInfo    aLineInfo;\n                        if ( nWidth )\n                            aLineInfo.SetWidth( nWidth );\n\n                        bool bTransparent = false;\n\n                        switch( nStyle & PS_STYLE_MASK )\n                        {\n                            case PS_DASHDOTDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 2 );\n                            break;\n                            case PS_DASHDOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DOT :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 0 );\n                                aLineInfo.SetDotCount( 1 );\n                            break;\n                            case PS_DASH :\n                                aLineInfo.SetStyle( LineStyle::Dash );\n                                aLineInfo.SetDashCount( 1 );\n                                aLineInfo.SetDotCount( 0 );\n                            break;\n                            case PS_NULL :\n                                bTransparent = true;\n                                aLineInfo.SetStyle( LineStyle::NONE );\n                            break;\n\n                            case PS_INSIDEFRAME :\n                            case PS_SOLID :\n                            default :\n                                aLineInfo.SetStyle( LineStyle::Solid );\n                        }\n                        switch( nStyle & PS_ENDCAP_STYLE_MASK )\n                        {\n                            case PS_ENDCAP_ROUND :\n                                if ( aLineInfo.GetWidth() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_ROUND );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_SQUARE :\n                                if ( aLineInfo.GetWidth() )\n                                {\n                                    aLineInfo.SetLineCap( css::drawing::LineCap_SQUARE );\n                                    break;\n                                }\n                                SAL_FALLTHROUGH;\n                            case PS_ENDCAP_FLAT :\n                            default :\n                                aLineInfo.SetLineCap( css::drawing::LineCap_BUTT );\n                        }\n                        switch( nStyle & PS_JOIN_STYLE_MASK )\n                        {\n                            case PS_JOIN_ROUND :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Round );\n                            break;\n                            case PS_JOIN_MITER :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Miter );\n                            break;\n                            case PS_JOIN_BEVEL :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::Bevel );\n                            break;\n                            default :\n                                aLineInfo.SetLineJoin ( basegfx::B2DLineJoin::NONE );\n                        }\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfLineStyle>( aColorRef, aLineInfo, bTransparent ));\n                    }\n                }\n                break;\n\n                case EMR_CREATEBRUSHINDIRECT :\n                {\n                    sal_uInt32  nStyle;\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        pWMF->ReadUInt32( nStyle );\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfFillStyle>( ReadColor(), ( nStyle == BS_HOLLOW ) ));\n                    }\n                }\n                break;\n\n                case EMR_DELETEOBJECT :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                        pOut->DeleteObject( nIndex );\n                }\n                break;\n\n                case EMR_ELLIPSE :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 );\n                    pOut->DrawEllipse( ReadRectangle( nX32, nY32, nx32, ny32 ) );\n                }\n                break;\n\n                case EMR_RECTANGLE :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 );\n                    pOut->DrawRect( ReadRectangle( nX32, nY32, nx32, ny32 ) );\n                }\n                break;\n\n                case EMR_ROUNDRECT :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nW ).ReadUInt32( nH );\n                    Size aSize( Size( nW, nH ) );\n                    pOut->DrawRoundRect( ReadRectangle( nX32, nY32, nx32, ny32 ), aSize );\n                }\n                break;\n\n                case EMR_ARC :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    pOut->DrawArc( ReadRectangle( nX32, nY32, nx32, ny32 ), Point( nStartX, nStartY ), Point( nEndX, nEndY ) );\n                }\n                break;\n\n                case EMR_CHORD :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    pOut->DrawChord( ReadRectangle( nX32, nY32, nx32, ny32 ), Point( nStartX, nStartY ), Point( nEndX, nEndY ) );\n                }\n                break;\n\n                case EMR_PIE :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    const Rectangle aRect( ReadRectangle( nX32, nY32, nx32, ny32 ));\n\n                    // #i73608# OutputDevice deviates from WMF\n                    // semantics. start==end means full ellipse here.\n                    if( nStartX == nEndX && nStartY == nEndY )\n                        pOut->DrawEllipse( aRect );\n                    else\n                        pOut->DrawPie( aRect, Point( nStartX, nStartY ), Point( nEndX, nEndY ) );\n                }\n                break;\n\n                case EMR_LINETO :\n                {\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 );\n                    pOut->LineTo( Point( nX32, nY32 ), bRecordPath );\n                }\n                break;\n\n                case EMR_ARCTO :\n                {\n                    sal_uInt32 nStartX, nStartY, nEndX, nEndY;\n                    pWMF->ReadInt32( nX32 ).ReadInt32( nY32 ).ReadInt32( nx32 ).ReadInt32( ny32 ).ReadUInt32( nStartX ).ReadUInt32( nStartY ).ReadUInt32( nEndX ).ReadUInt32( nEndY );\n                    pOut->DrawArc( ReadRectangle( nX32, nY32, nx32, ny32 ), Point( nStartX, nStartY ), Point( nEndX, nEndY ), true );\n                }\n                break;\n\n                case EMR_BEGINPATH :\n                {\n                    pOut->ClearPath();\n                    bRecordPath = true;\n                }\n                break;\n\n                case EMR_ABORTPATH :\n                    pOut->ClearPath();\n                    SAL_FALLTHROUGH;\n                case EMR_ENDPATH :\n                    bRecordPath = false;\n                break;\n\n                case EMR_CLOSEFIGURE :\n                    pOut->ClosePath();\n                break;\n\n                case EMR_FILLPATH :\n                    pOut->StrokeAndFillPath( false, true );\n                break;\n\n                case EMR_STROKEANDFILLPATH :\n                    pOut->StrokeAndFillPath( true, true );\n                break;\n\n                case EMR_STROKEPATH :\n                    pOut->StrokeAndFillPath( true, false );\n                break;\n\n                case EMR_SELECTCLIPPATH :\n                {\n                    sal_Int32 nClippingMode;\n                    pWMF->ReadInt32(nClippingMode);\n                    pOut->SetClipPath(pOut->GetPathObj(), nClippingMode, true);\n                }\n                break;\n\n                case EMR_EXTSELECTCLIPRGN :\n                {\n                    sal_Int32 nClippingMode, cbRgnData;\n                    pWMF->ReadInt32(cbRgnData);\n                    pWMF->ReadInt32(nClippingMode);\n\n                    // This record's region data should be ignored if mode\n                    // is RGN_COPY - see EMF spec section 2.3.2.2\n                    if (nClippingMode == RGN_COPY)\n                    {\n                        pOut->SetDefaultClipPath();\n                    }\n                    else\n                    {\n                        tools::PolyPolygon aPolyPoly;\n                        if (cbRgnData)\n                            ImplReadRegion(aPolyPoly, *pWMF, nRecSize);\n                        pOut->SetClipPath(aPolyPoly, nClippingMode, false);\n                    }\n\n                }\n                break;\n\n                case EMR_ALPHABLEND:\n                {\n                    sal_Int32 xDest(0), yDest(0), cxDest(0), cyDest(0);\n\n                    BLENDFUNCTION aFunc;\n                    sal_Int32 xSrc(0), ySrc(0), cxSrc(0), cySrc(0);\n                    XForm xformSrc;\n                    sal_uInt32 BkColorSrc(0), iUsageSrc(0), offBmiSrc(0);\n                    sal_uInt32 cbBmiSrc(0), offBitsSrc(0), cbBitsSrc(0);\n\n                    sal_uInt32   nStart = pWMF->Tell() - 8;\n                    pWMF->SeekRel( 0x10 );\n\n                    pWMF->ReadInt32( xDest ).ReadInt32( yDest ).ReadInt32( cxDest ).ReadInt32( cyDest );\n                    *pWMF >> aFunc;\n                    pWMF->ReadInt32( xSrc ).ReadInt32( ySrc );\n                    *pWMF >> xformSrc;\n                    pWMF->ReadUInt32( BkColorSrc ).ReadUInt32( iUsageSrc ).ReadUInt32( offBmiSrc ).ReadUInt32( cbBmiSrc )\n                               .ReadUInt32( offBitsSrc ).ReadUInt32( cbBitsSrc ).ReadInt32( cxSrc ).ReadInt32( cySrc ) ;\n\n                    sal_uInt32  dwRop = SRCAND|SRCINVERT;\n                    Rectangle   aRect( Point( xDest, yDest ), Size( cxDest+1, cyDest+1 ) );\n\n                    if ( (cbBitsSrc > (SAL_MAX_UINT32 - 14)) || ((SAL_MAX_UINT32 - 14) - cbBitsSrc < cbBmiSrc) )\n                        bStatus = false;\n                    else\n                    {\n                        const sal_uInt32 nSourceSize = cbBmiSrc + cbBitsSrc + 14;\n                        bool bSafeRead = nSourceSize <= (nEndPos - nStartPos);\n                        sal_uInt32 nDeltaToDIB5HeaderSize(0);\n                        const bool bReadAlpha(0x01 == aFunc.aAlphaFormat);\n                        if (bSafeRead && bReadAlpha)\n                        {\n                            // we need to read alpha channel data if AlphaFormat of BLENDFUNCTION is\n                            // AC_SRC_ALPHA (==0x01). To read it, create a temp DIB-File which is ready\n                            // for DIB-5 format\n                            const sal_uInt32 nHeaderSize = getDIBV5HeaderSize();\n                            if (cbBmiSrc > nHeaderSize)\n                                bSafeRead = false;\n                            else\n                                nDeltaToDIB5HeaderSize = nHeaderSize - cbBmiSrc;\n                        }\n                        if (bSafeRead)\n                        {\n                            const sal_uInt32 nTargetSize(cbBmiSrc + nDeltaToDIB5HeaderSize + cbBitsSrc + 14);\n                            char* pBuf = new char[ nTargetSize ];\n                            SvMemoryStream aTmp( pBuf, nTargetSize, StreamMode::READ | StreamMode::WRITE );\n\n                            aTmp.ObjectOwnsMemory( true );\n\n                            // write BM-Header (14 bytes)\n                            aTmp.WriteUChar( 'B' )\n                                .WriteUChar( 'M' )\n                                .WriteUInt32( cbBitsSrc )\n                                .WriteUInt16( 0 )\n                                .WriteUInt16( 0 )\n                                .WriteUInt32( cbBmiSrc + nDeltaToDIB5HeaderSize + 14 );\n\n                            // copy DIBInfoHeader from source (cbBmiSrc bytes)\n                            pWMF->Seek( nStart + offBmiSrc );\n                            pWMF->ReadBytes(pBuf + 14, cbBmiSrc);\n\n                            if (bReadAlpha)\n                            {\n                                // need to add values for all stuff that DIBV5Header is bigger\n                                // than DIBInfoHeader, all values are correctly initialized to zero,\n                                // so we can use memset here\n                                memset(pBuf + cbBmiSrc + 14, 0, nDeltaToDIB5HeaderSize);\n                            }\n\n                            // copy bitmap data from source (offBitsSrc bytes)\n                            pWMF->Seek( nStart + offBitsSrc );\n                            pWMF->ReadBytes(pBuf + 14 + nDeltaToDIB5HeaderSize + cbBmiSrc, cbBitsSrc);\n                            aTmp.Seek( 0 );\n\n                            // prepare to read and fill BitmapEx\n                            BitmapEx aBitmapEx;\n\n                            if(bReadAlpha)\n                            {\n                                Bitmap aBitmap;\n                                AlphaMask aAlpha;\n\n                                if(ReadDIBV5(aBitmap, aAlpha, aTmp))\n                                {\n                                    aBitmapEx = BitmapEx(aBitmap, aAlpha);\n                                }\n                            }\n                            else\n                            {\n                                Bitmap aBitmap;\n\n                                if(ReadDIB(aBitmap, aTmp, true))\n                                {\n                                    if(0xff != aFunc.aSrcConstantAlpha)\n                                    {\n                                        // add const alpha channel\n                                        aBitmapEx = BitmapEx(\n                                            aBitmap,\n                                            AlphaMask(aBitmap.GetSizePixel(), &aFunc.aSrcConstantAlpha));\n                                    }\n                                    else\n                                    {\n                                        // just use Bitmap\n                                        aBitmapEx = BitmapEx(aBitmap);\n                                    }\n                                }\n                            }\n\n                            if(!aBitmapEx.IsEmpty())\n                            {\n                                // test if it is sensible to crop\n                                if ( ( cxSrc > 0 ) && ( cySrc > 0 ) &&\n                                    ( xSrc >= 0 ) && ( ySrc >= 0 ) &&\n                                        ( xSrc + cxSrc < aBitmapEx.GetSizePixel().Width() ) &&\n                                            ( ySrc + cySrc < aBitmapEx.GetSizePixel().Height() ) )\n                                {\n                                    const Rectangle aCropRect( Point( xSrc, ySrc ), Size( cxSrc, cySrc ) );\n\n                                    aBitmapEx.Crop( aCropRect );\n                                }\n\n#ifdef DBG_UTIL\n                                static bool bDoSaveForVisualControl(false);\n\n                                if(bDoSaveForVisualControl)\n                                {\n                                    SvFileStream aNew(OUString(\"c:\\\\metafile_content.png\"), StreamMode::WRITE|StreamMode::TRUNC);\n                                    vcl::PNGWriter aPNGWriter(aBitmapEx);\n                                    aPNGWriter.Write(aNew);\n                                }\n#endif\n                                aBmpSaveList.emplace_back(new BSaveStruct(aBitmapEx, aRect, dwRop));\n                            }\n                        }\n                    }\n                }\n                break;\n\n                case EMR_BITBLT :   // PASSTHROUGH INTENDED\n                case EMR_STRETCHBLT :\n                {\n                    sal_Int32   xDest, yDest, cxDest, cyDest, xSrc, ySrc, cxSrc, cySrc;\n                    sal_uInt32  dwRop, iUsageSrc, offBmiSrc, cbBmiSrc, offBitsSrc, cbBitsSrc;\n                    XForm   xformSrc;\n\n                    sal_uInt32  nStart = pWMF->Tell() - 8;\n\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadInt32( xDest ).ReadInt32( yDest ).ReadInt32( cxDest ).ReadInt32( cyDest ).ReadUInt32( dwRop ).ReadInt32( xSrc ).ReadInt32( ySrc )\n                            >> xformSrc;\n                    pWMF->ReadUInt32( nColor ).ReadUInt32( iUsageSrc ).ReadUInt32( offBmiSrc ).ReadUInt32( cbBmiSrc )\n                               .ReadUInt32( offBitsSrc ).ReadUInt32( cbBitsSrc );\n\n                    if ( nRecType == EMR_STRETCHBLT )\n                        pWMF->ReadInt32( cxSrc ).ReadInt32( cySrc );\n                    else\n                        cxSrc = cySrc = 0;\n\n                    Bitmap      aBitmap;\n                    Rectangle   aRect( Point( xDest, yDest ), Size( cxDest, cyDest ) );\n\n                    if ( (cbBitsSrc > (SAL_MAX_UINT32 - 14)) || ((SAL_MAX_UINT32 - 14) - cbBitsSrc < cbBmiSrc) )\n                        bStatus = false;\n                    else\n                    {\n                        sal_uInt32 nSize = cbBmiSrc + cbBitsSrc + 14;\n                        if ( nSize <= ( nEndPos - nStartPos ) )\n                        {\n                            char* pBuf = new char[ nSize ];\n                            SvMemoryStream aTmp( pBuf, nSize, StreamMode::READ | StreamMode::WRITE );\n                            aTmp.ObjectOwnsMemory( true );\n                            aTmp.WriteUChar( 'B' )\n                                .WriteUChar( 'M' )\n                                .WriteUInt32( cbBitsSrc )\n                                .WriteUInt16( 0 )\n                                .WriteUInt16( 0 )\n                                .WriteUInt32( cbBmiSrc + 14 );\n                            pWMF->Seek( nStart + offBmiSrc );\n                            pWMF->ReadBytes(pBuf + 14, cbBmiSrc);\n                            pWMF->Seek( nStart + offBitsSrc );\n                            pWMF->ReadBytes(pBuf + 14 + cbBmiSrc, cbBitsSrc);\n                            aTmp.Seek( 0 );\n                            ReadDIB(aBitmap, aTmp, true);\n\n                            // test if it is sensible to crop\n                            if ( ( cxSrc > 0 ) && ( cySrc > 0 ) &&\n                                ( xSrc >= 0 ) && ( ySrc >= 0 ) &&\n                                    ( xSrc + cxSrc <= aBitmap.GetSizePixel().Width() ) &&\n                                        ( ySrc + cySrc <= aBitmap.GetSizePixel().Height() ) )\n                            {\n                                Rectangle aCropRect( Point( xSrc, ySrc ), Size( cxSrc, cySrc ) );\n                                aBitmap.Crop( aCropRect );\n                            }\n                            aBmpSaveList.emplace_back(new BSaveStruct(aBitmap, aRect, dwRop));\n                        }\n                    }\n                }\n                break;\n\n                case EMR_STRETCHDIBITS :\n                {\n                    sal_Int32   xDest, yDest, xSrc, ySrc, cxSrc, cySrc, cxDest, cyDest;\n                    sal_uInt32  offBmiSrc, cbBmiSrc, offBitsSrc, cbBitsSrc, iUsageSrc, dwRop;\n                    sal_uInt32  nStart = pWMF->Tell() - 8;\n\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadInt32( xDest )\n                         .ReadInt32( yDest )\n                         .ReadInt32( xSrc )\n                         .ReadInt32( ySrc )\n                         .ReadInt32( cxSrc )\n                         .ReadInt32( cySrc )\n                         .ReadUInt32( offBmiSrc )\n                         .ReadUInt32( cbBmiSrc )\n                         .ReadUInt32( offBitsSrc )\n                         .ReadUInt32( cbBitsSrc )\n                         .ReadUInt32( iUsageSrc )\n                         .ReadUInt32( dwRop )\n                         .ReadInt32( cxDest )\n                         .ReadInt32( cyDest );\n\n                    Bitmap      aBitmap;\n                    Rectangle   aRect( Point( xDest, yDest ), Size( cxDest, cyDest ) );\n\n                    if (  ((SAL_MAX_UINT32 - 14)             < cbBitsSrc)\n                       || ((SAL_MAX_UINT32 - 14) - cbBitsSrc < cbBmiSrc )\n                       )\n                    {\n                        bStatus = false;\n                    }\n                    else\n                    {\n                        sal_uInt32 nSize = cbBmiSrc + cbBitsSrc + 14;\n                        if ( nSize <= ( nEndPos - nStartPos ) )\n                        {\n                            char* pBuf = new char[ nSize ];\n                            SvMemoryStream aTmp( pBuf, nSize, StreamMode::READ | StreamMode::WRITE );\n                            aTmp.ObjectOwnsMemory( true );\n                            aTmp.WriteUChar( 'B' )\n                               .WriteUChar( 'M' )\n                               .WriteUInt32( cbBitsSrc )\n                               .WriteUInt16( 0 )\n                               .WriteUInt16( 0 )\n                               .WriteUInt32( cbBmiSrc + 14 );\n                            pWMF->Seek( nStart + offBmiSrc );\n                            pWMF->ReadBytes(pBuf + 14, cbBmiSrc);\n                            pWMF->Seek( nStart + offBitsSrc );\n                            pWMF->ReadBytes(pBuf + 14 + cbBmiSrc, cbBitsSrc);\n                            aTmp.Seek( 0 );\n                            ReadDIB(aBitmap, aTmp, true);\n\n                            // test if it is sensible to crop\n                            if ( ( cxSrc > 0 ) && ( cySrc > 0 ) &&\n                                ( xSrc >= 0 ) && ( ySrc >= 0 ) &&\n                                    ( xSrc + cxSrc <= aBitmap.GetSizePixel().Width() ) &&\n                                        ( ySrc + cySrc <= aBitmap.GetSizePixel().Height() ) )\n                            {\n                                Rectangle aCropRect( Point( xSrc, ySrc ), Size( cxSrc, cySrc ) );\n                                aBitmap.Crop( aCropRect );\n                            }\n                            aBmpSaveList.emplace_back(new BSaveStruct(aBitmap, aRect, dwRop));\n                        }\n                    }\n                }\n                break;\n\n                case EMR_EXTCREATEFONTINDIRECTW :\n                {\n                    pWMF->ReadUInt32( nIndex );\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        LOGFONTW aLogFont;\n                        pWMF->ReadInt32( aLogFont.lfHeight )\n                             .ReadInt32( aLogFont.lfWidth )\n                             .ReadInt32( aLogFont.lfEscapement )\n                             .ReadInt32( aLogFont.lfOrientation )\n                             .ReadInt32( aLogFont.lfWeight )\n                             .ReadUChar( aLogFont.lfItalic )\n                             .ReadUChar( aLogFont.lfUnderline )\n                             .ReadUChar( aLogFont.lfStrikeOut )\n                             .ReadUChar( aLogFont.lfCharSet )\n                             .ReadUChar( aLogFont.lfOutPrecision )\n                             .ReadUChar( aLogFont.lfClipPrecision )\n                             .ReadUChar( aLogFont.lfQuality )\n                             .ReadUChar( aLogFont.lfPitchAndFamily );\n\n                        sal_Unicode lfFaceName[LF_FACESIZE+1];\n                        lfFaceName[LF_FACESIZE] = 0;\n                        for (int i = 0; i < LF_FACESIZE; ++i)\n                        {\n                            sal_uInt16 nChar(0);\n                            pWMF->ReadUInt16(nChar);\n                            lfFaceName[i] = nChar;\n                        }\n                        aLogFont.alfFaceName = OUString( lfFaceName );\n\n                        // #i123216# Not used in the test case of #121382# (always identity in XForm), also\n                        // no hints in ms docu if FontSize should be scaled with WT. Using with the example\n                        // from #i123216# creates errors, so removing.\n\n                        // // #i121382# Need to apply WorldTransform to FontHeight/Width; this should be completely\n                        // // changed to basegfx::B2DHomMatrix instead of 'struct XForm', but not now due to time\n                        // // constraints and dangers\n                        // const XForm& rXF = pOut->GetWorldTransform();\n                        // const basegfx::B2DHomMatrix aWT(rXF.eM11, rXF.eM21, rXF.eDx, rXF.eM12, rXF.eM22, rXF.eDy);\n                        // const basegfx::B2DVector aTransVec(aWT * basegfx::B2DVector(aLogFont.lfWidth, aLogFont.lfHeight));\n                        // aLogFont.lfWidth = aTransVec.getX();\n                        // aLogFont.lfHeight = aTransVec.getY();\n\n                        pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfFontStyle>( aLogFont ));\n                    }\n                }\n                break;\n\n                case EMR_EXTTEXTOUTA :\n                    bFlag = true;\n                    SAL_FALLTHROUGH;\n                case EMR_EXTTEXTOUTW :\n                {\n                    sal_Int32   nLeft, nTop, nRight, nBottom, ptlReferenceX, ptlReferenceY, nGfxMode, nXScale, nYScale;\n                    sal_uInt32  nOffString, nOptions, offDx;\n                    sal_Int32   nLen;\n                    std::vector<long> aDX;\n\n                    nCurPos = pWMF->Tell() - 8;\n\n                    pWMF->ReadInt32( nLeft ).ReadInt32( nTop ).ReadInt32( nRight ).ReadInt32( nBottom ).ReadInt32( nGfxMode ).ReadInt32( nXScale ).ReadInt32( nYScale )\n                       .ReadInt32( ptlReferenceX ).ReadInt32( ptlReferenceY ).ReadInt32( nLen ).ReadUInt32( nOffString ).ReadUInt32( nOptions );\n\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadUInt32( offDx );\n\n                    ComplexTextLayoutFlags nTextLayoutMode = ComplexTextLayoutFlags::Default;\n                    if ( nOptions & ETO_RTLREADING )\n                        nTextLayoutMode = ComplexTextLayoutFlags::BiDiRtl | ComplexTextLayoutFlags::TextOriginLeft;\n                    pOut->SetTextLayoutMode( nTextLayoutMode );\n                    SAL_WARN_IF( ( nOptions & ( ETO_PDY | ETO_GLYPH_INDEX ) ) != 0, \"vcl.emf\", \"SJ: ETO_PDY || ETO_GLYPH_INDEX in EMF\" );\n\n                    Point aPos( ptlReferenceX, ptlReferenceY );\n                    bool bLenSane = nLen > 0 && nLen < static_cast<sal_Int32>( SAL_MAX_UINT32 / sizeof(sal_Int32) );\n                    bool bOffStringSane = nOffString <= nEndPos - nCurPos;\n                    if (bLenSane && bOffStringSane)\n                    {\n                        if ( offDx && (( nCurPos + offDx + nLen * 4 ) <= nNextPos ) )\n                        {\n                            pWMF->Seek( nCurPos + offDx );\n                            if ( ( nLen * sizeof(sal_uInt32) ) <= ( nEndPos - pWMF->Tell() ) )\n                            {\n                                aDX.resize(nLen);\n                                for (sal_Int32 i = 0; i < nLen; ++i)\n                                {\n                                    sal_Int32 val(0);\n                                    pWMF->ReadInt32(val);\n                                    aDX[i] = val;\n                                }\n                            }\n                        }\n                        pWMF->Seek( nCurPos + nOffString );\n                        OUString aText;\n                        if ( bFlag )\n                        {\n                            if ( nLen <= static_cast<sal_Int32>( nEndPos - pWMF->Tell() ) )\n                            {\n                                std::unique_ptr<sal_Char[]> pBuf(new sal_Char[ nLen ]);\n                                pWMF->ReadBytes(pBuf.get(), nLen);\n                                aText = OUString(pBuf.get(), nLen, pOut->GetCharSet());\n                                pBuf.reset();\n\n                                if ( aText.getLength() != nLen )\n                                {\n                                    std::vector<long> aOldDX(aText.getLength());\n                                    aOldDX.swap(aDX);\n                                    sal_Int32 nDXLen = std::min<sal_Int32>(nLen, aOldDX.size());\n                                    for (sal_Int32 i = 0, j = 0; i < aText.getLength(); ++i)\n                                    {\n                                        sal_Unicode cUniChar = aText[i];\n                                        OString aCharacter(&cUniChar, 1, pOut->GetCharSet());\n                                        aDX[i] = 0;\n                                        for (sal_Int32 k = 0; ( k < aCharacter.getLength() ) && ( j < nDXLen ) && ( i < aText.getLength() ); ++k)\n                                            aDX[ i ] += aOldDX[j++];\n                                    }\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if ( ( nLen * sizeof(sal_Unicode) ) <= ( nEndPos - pWMF->Tell() ) )\n                            {\n                                std::unique_ptr<sal_Unicode[]> pBuf(new sal_Unicode[ nLen ]);\n                                pWMF->ReadBytes(pBuf.get(), nLen << 1);\n#ifdef OSL_BIGENDIAN\n                                sal_Char nTmp, *pTmp = (sal_Char*)( pBuf.get() + nLen );\n                                while ( pTmp-- != (sal_Char*)pBuf.get() )\n                                {\n                                    nTmp = *pTmp--;\n                                    pTmp[ 1 ] = *pTmp;\n                                    *pTmp = nTmp;\n                                }\n#endif\n                                aText = OUString(pBuf.get(), nLen);\n                            }\n                        }\n                        pOut->DrawText(aPos, aText, aDX.data(), bRecordPath, nGfxMode);\n                    }\n                }\n                break;\n\n                case EMR_POLYBEZIERTO16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n\n                case EMR_POLYBEZIER16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyBezier( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYGON16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolygon( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYLINETO16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, true );\n                break;\n\n                case EMR_POLYLINE16 :\n                    ReadAndDrawPolygon<sal_Int16>( [] ( std::unique_ptr<WinMtfOutput> &pWinMtfOutput, tools::Polygon& rPolygon, bool aTo, bool aRecordPath )\n                                                   { pWinMtfOutput->DrawPolyLine( rPolygon, aTo, aRecordPath ); }, false );\n                break;\n\n                case EMR_POLYPOLYLINE16 :\n                    ReadAndDrawPolyLine<sal_Int16>();\n                break;\n\n                case EMR_POLYPOLYGON16 :\n                    ReadAndDrawPolyPolygon<sal_Int16>();\n                break;\n\n                case EMR_FILLRGN :\n                {\n                    sal_uInt32 nLen;\n                    tools::PolyPolygon aPolyPoly;\n                    pWMF->SeekRel( 0x10 );\n                    pWMF->ReadUInt32( nLen ).ReadUInt32( nIndex );\n\n                    if ( ImplReadRegion( aPolyPoly, *pWMF, nRecSize ) )\n                    {\n                        pOut->Push();\n                        pOut->SelectObject( nIndex );\n                        pOut->DrawPolyPolygon( aPolyPoly );\n                        pOut->Pop();\n                    }\n                }\n                break;\n\n                case EMR_CREATEDIBPATTERNBRUSHPT :\n                {\n                    sal_uInt32  nStart = pWMF->Tell() - 8;\n                    Bitmap aBitmap;\n\n                    pWMF->ReadUInt32( nIndex );\n\n                    if ( ( nIndex & ENHMETA_STOCK_OBJECT ) == 0 )\n                    {\n                        sal_uInt32 usage, offBmi, cbBmi, offBits, cbBits;\n\n                        pWMF->ReadUInt32( usage );\n                        pWMF->ReadUInt32( offBmi );\n                        pWMF->ReadUInt32( cbBmi );\n                        pWMF->ReadUInt32( offBits );\n                        pWMF->ReadUInt32( cbBits );\n\n                        if ( (cbBits > (SAL_MAX_UINT32 - 14)) || ((SAL_MAX_UINT32 - 14) - cbBits < cbBmi) )\n                           bStatus = false;\n                        else if ( offBmi )\n                        {\n                            sal_uInt32  nSize = cbBmi + cbBits + 14;\n                            if ( nSize <= ( nEndPos - nStartPos ) )\n                            {\n                                char*   pBuf = new char[ nSize ];\n\n                                SvMemoryStream aTmp( pBuf, nSize, StreamMode::READ | StreamMode::WRITE );\n                                aTmp.ObjectOwnsMemory( true );\n                                aTmp.WriteUChar( 'B' )\n                                    .WriteUChar( 'M' )\n                                    .WriteUInt32( cbBits )\n                                    .WriteUInt16( 0 )\n                                    .WriteUInt16( 0 )\n                                    .WriteUInt32( cbBmi + 14 );\n                                pWMF->Seek( nStart + offBmi );\n                                pWMF->ReadBytes(pBuf + 14, cbBmi);\n                                pWMF->Seek( nStart + offBits );\n                                pWMF->ReadBytes(pBuf + 14 + cbBmi, cbBits);\n                                aTmp.Seek( 0 );\n                                ReadDIB(aBitmap, aTmp, true);\n                            }\n                        }\n                    }\n\n                    pOut->CreateObjectIndexed(nIndex, o3tl::make_unique<WinMtfFillStyle>( aBitmap ));\n                }\n                break;\n\n                case EMR_MASKBLT :                  SAL_INFO(\"vcl.emf\", \"not implemented 'MaskBlt'\");                   break;\n                case EMR_PLGBLT :                   SAL_INFO(\"vcl.emf\", \"not implemented 'PlgBlt'\");                    break;\n                case EMR_SETDIBITSTODEVICE :        SAL_INFO(\"vcl.emf\", \"not implemented 'SetDIBitsToDevice'\");         break;\n                case EMR_FRAMERGN :                 SAL_INFO(\"vcl.emf\", \"not implemented 'FrameRgn'\");                  break;\n                case EMR_INVERTRGN :                SAL_INFO(\"vcl.emf\", \"not implemented 'InvertRgn'\");                 break;\n                case EMR_PAINTRGN :                 SAL_INFO(\"vcl.emf\", \"not implemented 'PaintRgn'\");                  break;\n                case EMR_FLATTENPATH :              SAL_INFO(\"vcl.emf\", \"not implemented 'FlattenPath'\");               break;\n                case EMR_WIDENPATH :                SAL_INFO(\"vcl.emf\", \"not implemented 'WidenPath'\");                 break;\n                case EMR_POLYDRAW :                 SAL_INFO(\"vcl.emf\", \"not implemented 'Polydraw'\");                  break;\n                case EMR_SETARCDIRECTION :          SAL_INFO(\"vcl.emf\", \"not implemented 'SetArcDirection'\");           break;\n                case EMR_SETPALETTEENTRIES :        SAL_INFO(\"vcl.emf\", \"not implemented 'SetPaletteEntries'\");         break;\n                case EMR_RESIZEPALETTE :            SAL_INFO(\"vcl.emf\", \"not implemented 'ResizePalette'\");             break;\n                case EMR_EXTFLOODFILL :             SAL_INFO(\"vcl.emf\", \"not implemented 'ExtFloodFill'\");              break;\n                case EMR_ANGLEARC :                 SAL_INFO(\"vcl.emf\", \"not implemented 'AngleArc'\");                  break;\n                case EMR_SETCOLORADJUSTMENT :       SAL_INFO(\"vcl.emf\", \"not implemented 'SetColorAdjustment'\");        break;\n                case EMR_POLYDRAW16 :               SAL_INFO(\"vcl.emf\", \"not implemented 'PolyDraw16'\");                break;\n                case EMR_POLYTEXTOUTA :             SAL_INFO(\"vcl.emf\", \"not implemented 'PolyTextOutA'\");              break;\n                case EMR_POLYTEXTOUTW :             SAL_INFO(\"vcl.emf\", \"not implemented 'PolyTextOutW'\");              break;\n                case EMR_CREATECOLORSPACE :         SAL_INFO(\"vcl.emf\", \"not implemented 'CreateColorSpace'\");          break;\n                case EMR_SETCOLORSPACE :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetColorSpace'\");             break;\n                case EMR_DELETECOLORSPACE :         SAL_INFO(\"vcl.emf\", \"not implemented 'DeleteColorSpace'\");          break;\n                case EMR_GLSRECORD :                SAL_INFO(\"vcl.emf\", \"not implemented 'GlsRecord'\");                 break;\n                case EMR_GLSBOUNDEDRECORD :         SAL_INFO(\"vcl.emf\", \"not implemented 'GlsBoundRecord'\");            break;\n                case EMR_PIXELFORMAT :              SAL_INFO(\"vcl.emf\", \"not implemented 'PixelFormat'\");               break;\n                case EMR_DRAWESCAPE :               SAL_INFO(\"vcl.emf\", \"not implemented 'DrawEscape'\");                break;\n                case EMR_EXTESCAPE :                SAL_INFO(\"vcl.emf\", \"not implemented 'ExtEscape'\");                 break;\n                case EMR_STARTDOC :                 SAL_INFO(\"vcl.emf\", \"not implemented 'StartDoc'\");                  break;\n                case EMR_SMALLTEXTOUT :             SAL_INFO(\"vcl.emf\", \"not implemented 'SmallTextOut'\");              break;\n                case EMR_FORCEUFIMAPPING :          SAL_INFO(\"vcl.emf\", \"not implemented 'ForceUFIMapping'\");           break;\n                case EMR_NAMEDESCAPE :              SAL_INFO(\"vcl.emf\", \"not implemented 'NamedEscape'\");               break;\n                case EMR_COLORCORRECTPALETTE :      SAL_INFO(\"vcl.emf\", \"not implemented 'ColorCorrectPalette'\");       break;\n                case EMR_SETICMPROFILEA :           SAL_INFO(\"vcl.emf\", \"not implemented 'SetICMProfileA'\");            break;\n                case EMR_SETICMPROFILEW :           SAL_INFO(\"vcl.emf\", \"not implemented 'SetICMProfileW'\");            break;\n                case EMR_TRANSPARENTBLT :           SAL_INFO(\"vcl.emf\", \"not implemented 'TransparenBlt'\");             break;\n                case EMR_TRANSPARENTDIB :           SAL_INFO(\"vcl.emf\", \"not implemented 'TransparenDib'\");             break;\n                case EMR_GRADIENTFILL :             SAL_INFO(\"vcl.emf\", \"not implemented 'GradientFill'\");              break;\n                case EMR_SETLINKEDUFIS :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetLinkedUFIS'\");             break;\n\n                case EMR_SETMAPPERFLAGS :           SAL_INFO(\"vcl.emf\", \"not implemented 'SetMapperFlags'\");            break;\n                case EMR_SETICMMODE :               SAL_INFO(\"vcl.emf\", \"not implemented 'SetICMMode'\");                break;\n                case EMR_CREATEMONOBRUSH :          SAL_INFO(\"vcl.emf\", \"not implemented 'CreateMonoBrush'\");           break;\n                case EMR_SETBRUSHORGEX :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetBrushOrgEx'\");             break;\n                case EMR_SETMETARGN :               SAL_INFO(\"vcl.emf\", \"not implemented 'SetMetArgn'\");                break;\n                case EMR_SETMITERLIMIT :            SAL_INFO(\"vcl.emf\", \"not implemented 'SetMiterLimit'\");             break;\n                case EMR_EXCLUDECLIPRECT :          SAL_INFO(\"vcl.emf\", \"not implemented 'ExcludeClipRect'\");           break;\n                case EMR_REALIZEPALETTE :           SAL_INFO(\"vcl.emf\", \"not implemented 'RealizePalette'\");            break;\n                case EMR_SELECTPALETTE :            SAL_INFO(\"vcl.emf\", \"not implemented 'SelectPalette'\");             break;\n                case EMR_CREATEPALETTE :            SAL_INFO(\"vcl.emf\", \"not implemented 'CreatePalette'\");             break;\n                case EMR_ALPHADIBBLEND :            SAL_INFO(\"vcl.emf\", \"not implemented 'AlphaDibBlend'\");             break;\n                case EMR_SETTEXTJUSTIFICATION :     SAL_INFO(\"vcl.emf\", \"not implemented 'SetTextJustification'\");      break;\n\n                case EMR_GDICOMMENT :\n                case EMR_HEADER :               // has already been read at ReadHeader()\n                break;\n\n                default :                           SAL_INFO(\"vcl.emf\", \"Unknown Meta Action\");                                     break;\n            }\n        }\n        pWMF->Seek( nNextPos );\n    }\n    if( !aBmpSaveList.empty() )\n        pOut->ResolveBitmapActions( aBmpSaveList );\n\n    if ( bStatus )\n        pWMF->Seek(nEndPos);\n\n    return bStatus;\n};\n\nbool EnhWMFReader::ReadHeader()\n{\n    sal_uInt32      nType, nSignature, nVersion;\n    sal_uInt32      nHeaderSize, nPalEntries;\n\n    // Spare me the METAFILEHEADER here\n    // Reading the METAHEADER - EMR_HEADER ([MS-EMF] section 2.3.4.2 EMR_HEADER Record Types)\n    pWMF->ReadUInt32( nType ).ReadUInt32( nHeaderSize );\n    if (nType != 0x00000001)\n    {\n        // per [MS-EMF] 2.3.4.2 EMF Header Record Types, type MUST be 0x00000001\n        SAL_WARN(\"vcl.emf\", \"EMF header type is not set to 0x00000001 - possibly corrupted file?\");\n        return false;\n    }\n\n    // Start reading the EMR_HEADER Header object\n\n    // bound size (RectL object, see [MS-WMF] section 2.2.2.19)\n    Rectangle rclBounds = ReadRectangle(); // rectangle in logical units\n\n    // picture frame size (RectL object)\n    Rectangle rclFrame = ReadRectangle(); // rectangle in device units 1/100th mm\n\n    pWMF->ReadUInt32( nSignature );\n\n    // nSignature MUST be the ASCII characters \"FME\", see [WS-EMF] 2.2.9 Header Object\n    // and 2.1.14 FormatSignature Enumeration\n    if (nSignature != 0x464d4520)\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tSignature is not 0x464d4520 (\\\"FME\\\") - possibly corrupted file?\");\n        return false;\n    }\n\n    pWMF->ReadUInt32(nVersion);  // according to [WS-EMF] 2.2.9, this SHOULD be 0x0001000, however\n                                   // Microsoft note that not even Windows checks this...\n    if (nVersion != 0x00010000)\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tThis really should be 0x00010000, though not absolutely essential...\");\n    }\n\n    pWMF->ReadUInt32(nEndPos); // size of metafile\n    nEndPos += nStartPos;\n\n    sal_uInt32 nStrmPos = pWMF->Tell(); // checking if nEndPos is valid\n    pWMF->Seek(STREAM_SEEK_TO_END);\n    sal_uInt32 nActualFileSize = pWMF->Tell();\n\n    if ( nActualFileSize < nEndPos )\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tEMF Header object records number of bytes as \" << nEndPos\n                            << \", however the file size is actually \" << nActualFileSize\n                            << \" bytes. Possible file corruption?\");\n        nEndPos = nActualFileSize;\n    }\n    pWMF->Seek(nStrmPos);\n\n    pWMF->ReadInt32(nRecordCount);\n\n    if (nRecordCount <= 0)\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tEMF Header object shows record counter as <= 0! This shouldn't \"\n                            \"be possible... indicator of possible file corruption?\");\n        return false;\n    }\n\n    // the number of \"handles\", or graphics objects used in the metafile\n\n    sal_uInt16 nHandlesCount;\n    pWMF->ReadUInt16(nHandlesCount);\n\n    // the next 2 bytes are reserved, but according to [MS-EMF] section 2.2.9\n    // it MUST be 0x000 and MUST be ignored... the thing is, having such a specific\n    // value is actually pretty useful in checking if there is possible corruption\n\n    sal_uInt16 nReserved;\n    pWMF->ReadUInt16(nReserved);\n\n    if ( nReserved != 0x0000 )\n    {\n        SAL_WARN(\"vcl.emf\", \"EMF\\t\\tEMF Header object's reserved field is NOT 0x0000... possible \"\n                            \"corruption?\");\n    }\n\n    // The next 4 bytes specifies the number of characters in the metafile description.\n    // The 4 bytes after that specific the offset from this record that contains the\n    // metafile description... zero means no description string.\n    // For now, we ignore it.\n\n    pWMF->SeekRel(0x8);\n\n    sal_Int32 nPixX, nPixY, nMillX, nMillY;\n    pWMF->ReadUInt32(nPalEntries);\n    pWMF->ReadInt32(nPixX);\n    pWMF->ReadInt32(nPixY);\n    pWMF->ReadInt32(nMillX);\n    pWMF->ReadInt32(nMillY);\n\n    pOut->SetrclFrame(rclFrame);\n    pOut->SetrclBounds(rclBounds);\n    pOut->SetRefPix(Size( nPixX, nPixY ) );\n    pOut->SetRefMill(Size( nMillX, nMillY ) );\n\n    pWMF->Seek(nStartPos + nHeaderSize);\n    return true;\n}\n\nRectangle EnhWMFReader::ReadRectangle()\n{\n    sal_Int32 nLeft, nTop, nRight, nBottom;\n    pWMF->ReadInt32(nLeft);\n    pWMF->ReadInt32(nTop);\n    pWMF->ReadInt32(nRight);\n    pWMF->ReadInt32(nBottom);\n    return Rectangle(nLeft, nTop, nRight, nBottom);\n}\n\nRectangle EnhWMFReader::ReadRectangle( sal_Int32 x1, sal_Int32 y1, sal_Int32 x2, sal_Int32 y2 )\n{\n    Point aTL ( Point( x1, y1 ) );\n    Point aBR( Point( --x2, --y2 ) );\n    return Rectangle( aTL, aBR );\n}\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "filenames": ["vcl/source/filter/wmf/enhwmf.cxx"], "buggy_code_start_loc": [1255], "buggy_code_end_loc": [1281], "fixing_code_start_loc": [1255], "fixing_code_end_loc": [1290], "type": "CWE-787", "message": "LibreOffice before 2016-12-22 has an out-of-bounds write caused by a heap-based buffer overflow related to the EnhWMFReader::ReadEnhWMF function in vcl/source/filter/wmf/enhwmf.cxx.", "other": {"cve": {"id": "CVE-2016-10327", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-14T04:59:00.167", "lastModified": "2017-11-15T02:29:08.360", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "LibreOffice before 2016-12-22 has an out-of-bounds write caused by a heap-based buffer overflow related to the EnhWMFReader::ReadEnhWMF function in vcl/source/filter/wmf/enhwmf.cxx."}, {"lang": "es", "value": "LibreOffice en versiones anteriores a 22-12-2016 tiene una escritura fuera de l\u00edmites provocada por un desbordamiento de b\u00fafer basado en memoria din\u00e1mica relacionado con la funci\u00f3n EnhWMFReader::ReadEnhWMF en VCL/fuente/filtro/WMF/enhwmf.cxx."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreoffice:libreoffice:*:beta2:*:*:*:*:*:*", "versionEndIncluding": "5.3.0.0", "matchCriteriaId": "570C0612-FE5E-4003-8EB0-D156278EE2E5"}]}]}], "references": [{"url": "http://www.libreoffice.org/about-us/security/advisories/cve-2016-10327/", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97668", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=313", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/LibreOffice/core/commit/7485fc2a1484f31631f62f97e5c64c0ae74c6416", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201706-28", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/LibreOffice/core/commit/7485fc2a1484f31631f62f97e5c64c0ae74c6416"}}