{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RemoteFX USB Redirection\n *\n * Copyright 2012 Atrust corp.\n * Copyright 2012 Alfred Liu <alfred.liu@atruscorp.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/sysinfo.h>\n#include <winpr/collections.h>\n\n#include <errno.h>\n\n#include \"libusb_udevice.h\"\n#include \"../common/urbdrc_types.h\"\n\n#define BASIC_STATE_FUNC_DEFINED(_arg, _type)             \\\n\tstatic _type udev_get_##_arg(IUDEVICE* idev)          \\\n\t{                                                     \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                   \\\n\t\treturn pdev->_arg;                                \\\n\t}                                                     \\\n\tstatic void udev_set_##_arg(IUDEVICE* idev, _type _t) \\\n\t{                                                     \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                   \\\n\t\tpdev->_arg = _t;                                  \\\n\t}\n\n#define BASIC_POINT_FUNC_DEFINED(_arg, _type)               \\\n\tstatic _type udev_get_p_##_arg(IUDEVICE* idev)          \\\n\t{                                                       \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                     \\\n\t\treturn pdev->_arg;                                  \\\n\t}                                                       \\\n\tstatic void udev_set_p_##_arg(IUDEVICE* idev, _type _t) \\\n\t{                                                       \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                     \\\n\t\tpdev->_arg = _t;                                    \\\n\t}\n\n#define BASIC_STATE_FUNC_REGISTER(_arg, _dev) \\\n\t_dev->iface.get_##_arg = udev_get_##_arg; \\\n\t_dev->iface.set_##_arg = udev_set_##_arg\n\n#if LIBUSB_API_VERSION >= 0x01000103\n#define HAVE_STREAM_ID_API 1\n#endif\n\ntypedef struct _ASYNC_TRANSFER_USER_DATA ASYNC_TRANSFER_USER_DATA;\n\nstruct _ASYNC_TRANSFER_USER_DATA\n{\n\twStream* data;\n\tBOOL noack;\n\tUINT32 MessageId;\n\tUINT32 StartFrame;\n\tUINT32 ErrorCount;\n\tIUDEVICE* idev;\n\tUINT32 OutputBufferSize;\n\tURBDRC_CHANNEL_CALLBACK* callback;\n\tt_isoch_transfer_cb cb;\n\twArrayList* queue;\n#if !defined(HAVE_STREAM_ID_API)\n\tUINT32 streamID;\n#endif\n};\n\nstatic void request_free(void* value);\n\nstatic struct libusb_transfer* list_contains(wArrayList* list, UINT32 streamID)\n{\n\tint x, count;\n\tif (!list)\n\t\treturn NULL;\n\tcount = ArrayList_Count(list);\n\tfor (x = 0; x < count; x++)\n\t{\n\t\tstruct libusb_transfer* transfer = ArrayList_GetItem(list, x);\n\n#if defined(HAVE_STREAM_ID_API)\n\t\tconst UINT32 currentID = libusb_transfer_get_stream_id(transfer);\n#else\n\t\tconst ASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\t\tconst UINT32 currentID = user_data->streamID;\n#endif\n\t\tif (currentID == streamID)\n\t\t\treturn transfer;\n\t}\n\treturn NULL;\n}\n\nstatic UINT32 stream_id_from_buffer(struct libusb_transfer* transfer)\n{\n\tif (!transfer)\n\t\treturn 0;\n#if defined(HAVE_STREAM_ID_API)\n\treturn libusb_transfer_get_stream_id(transfer);\n#else\n\tASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tif (!user_data)\n\t\treturn 0;\n\treturn user_data->streamID;\n#endif\n}\n\nstatic void set_stream_id_for_buffer(struct libusb_transfer* transfer, UINT32 streamID)\n{\n#if defined(HAVE_STREAM_ID_API)\n\tlibusb_transfer_set_stream_id(transfer, streamID);\n#else\n\tASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tif (!user_data)\n\t\treturn;\n\tuser_data->streamID = streamID;\n#endif\n}\nstatic BOOL log_libusb_result(wLog* log, DWORD lvl, const char* fmt, int error, ...)\n{\n\tif (error < 0)\n\t{\n\t\tchar buffer[8192] = { 0 };\n\t\tva_list ap;\n\t\tva_start(ap, error);\n\t\tvsnprintf(buffer, sizeof(buffer), fmt, ap);\n\t\tva_end(ap);\n\n\t\tWLog_Print(log, lvl, \"%s: error %s[%d]\", buffer, libusb_error_name(error), error);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nconst char* usb_interface_class_to_string(uint8_t class)\n{\n\tswitch (class)\n\t{\n\t\tcase LIBUSB_CLASS_PER_INTERFACE:\n\t\t\treturn \"LIBUSB_CLASS_PER_INTERFACE\";\n\t\tcase LIBUSB_CLASS_AUDIO:\n\t\t\treturn \"LIBUSB_CLASS_AUDIO\";\n\t\tcase LIBUSB_CLASS_COMM:\n\t\t\treturn \"LIBUSB_CLASS_COMM\";\n\t\tcase LIBUSB_CLASS_HID:\n\t\t\treturn \"LIBUSB_CLASS_HID\";\n\t\tcase LIBUSB_CLASS_PHYSICAL:\n\t\t\treturn \"LIBUSB_CLASS_PHYSICAL\";\n\t\tcase LIBUSB_CLASS_PRINTER:\n\t\t\treturn \"LIBUSB_CLASS_PRINTER\";\n\t\tcase LIBUSB_CLASS_IMAGE:\n\t\t\treturn \"LIBUSB_CLASS_IMAGE\";\n\t\tcase LIBUSB_CLASS_MASS_STORAGE:\n\t\t\treturn \"LIBUSB_CLASS_MASS_STORAGE\";\n\t\tcase LIBUSB_CLASS_HUB:\n\t\t\treturn \"LIBUSB_CLASS_HUB\";\n\t\tcase LIBUSB_CLASS_DATA:\n\t\t\treturn \"LIBUSB_CLASS_DATA\";\n\t\tcase LIBUSB_CLASS_SMART_CARD:\n\t\t\treturn \"LIBUSB_CLASS_SMART_CARD\";\n\t\tcase LIBUSB_CLASS_CONTENT_SECURITY:\n\t\t\treturn \"LIBUSB_CLASS_CONTENT_SECURITY\";\n\t\tcase LIBUSB_CLASS_VIDEO:\n\t\t\treturn \"LIBUSB_CLASS_VIDEO\";\n\t\tcase LIBUSB_CLASS_PERSONAL_HEALTHCARE:\n\t\t\treturn \"LIBUSB_CLASS_PERSONAL_HEALTHCARE\";\n\t\tcase LIBUSB_CLASS_DIAGNOSTIC_DEVICE:\n\t\t\treturn \"LIBUSB_CLASS_DIAGNOSTIC_DEVICE\";\n\t\tcase LIBUSB_CLASS_WIRELESS:\n\t\t\treturn \"LIBUSB_CLASS_WIRELESS\";\n\t\tcase LIBUSB_CLASS_APPLICATION:\n\t\t\treturn \"LIBUSB_CLASS_APPLICATION\";\n\t\tcase LIBUSB_CLASS_VENDOR_SPEC:\n\t\t\treturn \"LIBUSB_CLASS_VENDOR_SPEC\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN_DEVICE_CLASS\";\n\t}\n}\n\nstatic ASYNC_TRANSFER_USER_DATA* async_transfer_user_data_new(IUDEVICE* idev, UINT32 MessageId,\n                                                              size_t offset, size_t BufferSize,\n                                                              const BYTE* data, size_t packetSize,\n                                                              BOOL NoAck, t_isoch_transfer_cb cb,\n                                                              URBDRC_CHANNEL_CALLBACK* callback)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data = calloc(1, sizeof(ASYNC_TRANSFER_USER_DATA));\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!user_data)\n\t\treturn NULL;\n\n\tuser_data->data = Stream_New(NULL, offset + BufferSize + packetSize);\n\n\tif (!user_data->data)\n\t{\n\t\tfree(user_data);\n\t\treturn NULL;\n\t}\n\n\tStream_Seek(user_data->data, offset); /* Skip header offset */\n\tif (data)\n\t\tmemcpy(Stream_Pointer(user_data->data), data, BufferSize);\n\telse\n\t\tuser_data->OutputBufferSize = BufferSize;\n\n\tuser_data->noack = NoAck;\n\tuser_data->cb = cb;\n\tuser_data->callback = callback;\n\tuser_data->idev = idev;\n\tuser_data->MessageId = MessageId;\n\n\tuser_data->queue = pdev->request_queue;\n\n\treturn user_data;\n}\n\nstatic void async_transfer_user_data_free(ASYNC_TRANSFER_USER_DATA* user_data)\n{\n\tif (user_data)\n\t{\n\t\tStream_Free(user_data->data, TRUE);\n\t\tfree(user_data);\n\t}\n}\n\nstatic void LIBUSB_CALL func_iso_callback(struct libusb_transfer* transfer)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tconst UINT32 streamID = stream_id_from_buffer(transfer);\n\twArrayList* list = user_data->queue;\n\n\tArrayList_Lock(list);\n\tswitch (transfer->status)\n\t{\n\t\tcase LIBUSB_TRANSFER_COMPLETED:\n\t\t{\n\t\t\tint i;\n\t\t\tUINT32 index = 0;\n\t\t\tBYTE* dataStart = Stream_Pointer(user_data->data);\n\t\t\tStream_SetPosition(user_data->data,\n\t\t\t                   40); /* TS_URB_ISOCH_TRANSFER_RESULT IsoPacket offset */\n\n\t\t\tfor (i = 0; i < transfer->num_iso_packets; i++)\n\t\t\t{\n\t\t\t\tconst UINT32 act_len = transfer->iso_packet_desc[i].actual_length;\n\t\t\t\tStream_Write_UINT32(user_data->data, index);\n\t\t\t\tStream_Write_UINT32(user_data->data, act_len);\n\t\t\t\tStream_Write_UINT32(user_data->data, transfer->iso_packet_desc[i].status);\n\n\t\t\t\tif (transfer->iso_packet_desc[i].status != USBD_STATUS_SUCCESS)\n\t\t\t\t\tuser_data->ErrorCount++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst unsigned char* packetBuffer =\n\t\t\t\t\t    libusb_get_iso_packet_buffer_simple(transfer, i);\n\t\t\t\t\tBYTE* data = dataStart + index;\n\n\t\t\t\t\tif (data != packetBuffer)\n\t\t\t\t\t\tmemmove(data, packetBuffer, act_len);\n\n\t\t\t\t\tindex += act_len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t/* fallthrough */\n\n\t\tcase LIBUSB_TRANSFER_CANCELLED:\n\t\tcase LIBUSB_TRANSFER_TIMED_OUT:\n\t\tcase LIBUSB_TRANSFER_ERROR:\n\t\t{\n\t\t\tconst UINT32 InterfaceId =\n\t\t\t    ((STREAM_ID_PROXY << 30) | user_data->idev->get_ReqCompletion(user_data->idev));\n\n\t\t\tif (list_contains(list, streamID))\n\t\t\t{\n\t\t\t\tif (!user_data->noack)\n\t\t\t\t{\n\t\t\t\t\tconst UINT32 RequestID = streamID & INTERFACE_ID_MASK;\n\t\t\t\t\tuser_data->cb(user_data->idev, user_data->callback, user_data->data,\n\t\t\t\t\t              InterfaceId, user_data->noack, user_data->MessageId, RequestID,\n\t\t\t\t\t              transfer->num_iso_packets, transfer->status,\n\t\t\t\t\t              user_data->StartFrame, user_data->ErrorCount,\n\t\t\t\t\t              user_data->OutputBufferSize);\n\t\t\t\t\tuser_data->data = NULL;\n\t\t\t\t}\n\t\t\t\tArrayList_Remove(list, transfer);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tArrayList_Unlock(list);\n}\n\nstatic const LIBUSB_ENDPOINT_DESCEIPTOR* func_get_ep_desc(LIBUSB_CONFIG_DESCRIPTOR* LibusbConfig,\n                                                          MSUSB_CONFIG_DESCRIPTOR* MsConfig,\n                                                          UINT32 EndpointAddress)\n{\n\tBYTE alt;\n\tUINT32 inum, pnum;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;\n\tconst LIBUSB_INTERFACE* interface;\n\tconst LIBUSB_ENDPOINT_DESCEIPTOR* endpoint;\n\tMsInterfaces = MsConfig->MsInterfaces;\n\tinterface = LibusbConfig->interface;\n\n\tfor (inum = 0; inum < MsConfig->NumInterfaces; inum++)\n\t{\n\t\talt = MsInterfaces[inum]->AlternateSetting;\n\t\tendpoint = interface[inum].altsetting[alt].endpoint;\n\n\t\tfor (pnum = 0; pnum < MsInterfaces[inum]->NumberOfPipes; pnum++)\n\t\t{\n\t\t\tif (endpoint[pnum].bEndpointAddress == EndpointAddress)\n\t\t\t{\n\t\t\t\treturn &endpoint[pnum];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void LIBUSB_CALL func_bulk_transfer_cb(struct libusb_transfer* transfer)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tuint32_t streamID;\n\twArrayList* list;\n\n\tuser_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tif (!user_data)\n\t{\n\t\tWLog_ERR(TAG, \"[%s]: Invalid transfer->user_data!\");\n\t\treturn;\n\t}\n\tlist = user_data->queue;\n\tArrayList_Lock(list);\n\tstreamID = stream_id_from_buffer(transfer);\n\n\tif (list_contains(list, streamID))\n\t{\n\t\tconst UINT32 InterfaceId =\n\t\t    ((STREAM_ID_PROXY << 30) | user_data->idev->get_ReqCompletion(user_data->idev));\n\t\tconst UINT32 RequestID = streamID & INTERFACE_ID_MASK;\n\n\t\tuser_data->cb(user_data->idev, user_data->callback, user_data->data, InterfaceId,\n\t\t              user_data->noack, user_data->MessageId, RequestID, transfer->num_iso_packets,\n\t\t              transfer->status, user_data->StartFrame, user_data->ErrorCount,\n\t\t              transfer->actual_length);\n\t\tuser_data->data = NULL;\n\t\tArrayList_Remove(list, transfer);\n\t}\n\tArrayList_Unlock(list);\n}\n\nstatic BOOL func_set_usbd_status(URBDRC_PLUGIN* urbdrc, UDEVICE* pdev, UINT32* status,\n                                 int err_result)\n{\n\tif (!urbdrc || !status)\n\t\treturn FALSE;\n\n\tswitch (err_result)\n\t{\n\t\tcase LIBUSB_SUCCESS:\n\t\t\t*status = USBD_STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_IO:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_INVALID_PARAM:\n\t\t\t*status = USBD_STATUS_INVALID_PARAMETER;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_ACCESS:\n\t\t\t*status = USBD_STATUS_NOT_ACCESSED;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NO_DEVICE:\n\t\t\t*status = USBD_STATUS_DEVICE_GONE;\n\n\t\t\tif (pdev)\n\t\t\t{\n\t\t\t\tif (!(pdev->status & URBDRC_DEVICE_NOT_FOUND))\n\t\t\t\t\tpdev->status |= URBDRC_DEVICE_NOT_FOUND;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NOT_FOUND:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_BUSY:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_TIMEOUT:\n\t\t\t*status = USBD_STATUS_TIMEOUT;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_OVERFLOW:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_PIPE:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_INTERRUPTED:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NO_MEM:\n\t\t\t*status = USBD_STATUS_NO_MEMORY;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NOT_SUPPORTED:\n\t\t\t*status = USBD_STATUS_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_OTHER:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*status = USBD_STATUS_SUCCESS;\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int func_config_release_all_interface(URBDRC_PLUGIN* urbdrc,\n                                             LIBUSB_DEVICE_HANDLE* libusb_handle,\n                                             UINT32 NumInterfaces)\n{\n\tUINT32 i;\n\n\tfor (i = 0; i < NumInterfaces; i++)\n\t{\n\t\tint ret = libusb_release_interface(libusb_handle, i);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_WARN, \"libusb_release_interface\", ret))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int func_claim_all_interface(URBDRC_PLUGIN* urbdrc, LIBUSB_DEVICE_HANDLE* libusb_handle,\n                                    int NumInterfaces)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < NumInterfaces; i++)\n\t{\n\t\tret = libusb_claim_interface(libusb_handle, i);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_claim_interface\", ret))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic LIBUSB_DEVICE* udev_get_libusb_dev(libusb_context* context, uint8_t bus_number,\n                                          uint8_t dev_number)\n{\n\tssize_t i, total_device;\n\tLIBUSB_DEVICE** libusb_list;\n\tLIBUSB_DEVICE* device = NULL;\n\ttotal_device = libusb_get_device_list(context, &libusb_list);\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\t\tif ((bus_number == libusb_get_bus_number(dev)) &&\n\t\t    (dev_number == libusb_get_device_address(dev)))\n\t\t{\n\t\t\tdevice = dev;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibusb_unref_device(dev);\n\t\t}\n\t}\n\n\tlibusb_free_device_list(libusb_list, 0);\n\treturn device;\n}\n\nstatic LIBUSB_DEVICE_DESCRIPTOR* udev_new_descript(URBDRC_PLUGIN* urbdrc, LIBUSB_DEVICE* libusb_dev)\n{\n\tint ret;\n\tLIBUSB_DEVICE_DESCRIPTOR* descriptor =\n\t    (LIBUSB_DEVICE_DESCRIPTOR*)calloc(1, sizeof(LIBUSB_DEVICE_DESCRIPTOR));\n\tif (!descriptor)\n\t\treturn NULL;\n\tret = libusb_get_device_descriptor(libusb_dev, descriptor);\n\n\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_get_device_descriptor\", ret))\n\t{\n\t\tfree(descriptor);\n\t\treturn NULL;\n\t}\n\n\treturn descriptor;\n}\n\nstatic int libusb_udev_select_interface(IUDEVICE* idev, BYTE InterfaceNumber, BYTE AlternateSetting)\n{\n\tint error = 0, diff = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tURBDRC_PLUGIN* urbdrc;\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tMsConfig = pdev->MsConfig;\n\n\tif (MsConfig)\n\t{\n\t\tMsInterfaces = MsConfig->MsInterfaces;\n\t\tif (MsInterfaces)\n\t\t{\n\t\t\tWLog_Print(urbdrc->log, WLOG_INFO,\n\t\t\t           \"select Interface(%\" PRIu8 \") curr AlternateSetting(%\" PRIu8\n\t\t\t           \") new AlternateSetting(\" PRIu8 \")\",\n\t\t\t           InterfaceNumber, MsInterfaces[InterfaceNumber]->AlternateSetting,\n\t\t\t           AlternateSetting);\n\n\t\t\tif (MsInterfaces[InterfaceNumber]->AlternateSetting != AlternateSetting)\n\t\t\t{\n\t\t\t\tdiff = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (diff)\n\t\t{\n\t\t\terror = libusb_set_interface_alt_setting(pdev->libusb_handle, InterfaceNumber,\n\t\t\t                                         AlternateSetting);\n\n\t\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_set_interface_alt_setting\", error);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nstatic MSUSB_CONFIG_DESCRIPTOR*\nlibusb_udev_complete_msconfig_setup(IUDEVICE* idev, MSUSB_CONFIG_DESCRIPTOR* MsConfig)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;\n\tMSUSB_INTERFACE_DESCRIPTOR* MsInterface;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\tMSUSB_PIPE_DESCRIPTOR* MsPipe;\n\tMSUSB_PIPE_DESCRIPTOR** t_MsPipes;\n\tMSUSB_PIPE_DESCRIPTOR* t_MsPipe;\n\tLIBUSB_CONFIG_DESCRIPTOR* LibusbConfig;\n\tconst LIBUSB_INTERFACE* LibusbInterface;\n\tconst LIBUSB_INTERFACE_DESCRIPTOR* LibusbAltsetting;\n\tconst LIBUSB_ENDPOINT_DESCEIPTOR* LibusbEndpoint;\n\tBYTE LibusbNumEndpoint;\n\tURBDRC_PLUGIN* urbdrc;\n\tUINT32 inum = 0, pnum = 0, MsOutSize = 0;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->urbdrc || !MsConfig)\n\t\treturn NULL;\n\n\turbdrc = pdev->urbdrc;\n\tLibusbConfig = pdev->LibusbConfig;\n\n\tif (LibusbConfig->bNumInterfaces != MsConfig->NumInterfaces)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t           \"Select Configuration: Libusb NumberInterfaces(%\" PRIu8 \") is different \"\n\t\t           \"with MsConfig NumberInterfaces(%\" PRIu32 \")\",\n\t\t           LibusbConfig->bNumInterfaces, MsConfig->NumInterfaces);\n\t}\n\n\t/* replace MsPipes for libusb */\n\tMsInterfaces = MsConfig->MsInterfaces;\n\n\tfor (inum = 0; inum < MsConfig->NumInterfaces; inum++)\n\t{\n\t\tMsInterface = MsInterfaces[inum];\n\t\t/* get libusb's number of endpoints */\n\t\tLibusbInterface = &LibusbConfig->interface[MsInterface->InterfaceNumber];\n\t\tLibusbAltsetting = &LibusbInterface->altsetting[MsInterface->AlternateSetting];\n\t\tLibusbNumEndpoint = LibusbAltsetting->bNumEndpoints;\n\t\tt_MsPipes =\n\t\t    (MSUSB_PIPE_DESCRIPTOR**)calloc(LibusbNumEndpoint, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\n\t\tfor (pnum = 0; pnum < LibusbNumEndpoint; pnum++)\n\t\t{\n\t\t\tt_MsPipe = (MSUSB_PIPE_DESCRIPTOR*)calloc(1, sizeof(MSUSB_PIPE_DESCRIPTOR));\n\n\t\t\tif (pnum < MsInterface->NumberOfPipes && MsInterface->MsPipes)\n\t\t\t{\n\t\t\t\tMsPipe = MsInterface->MsPipes[pnum];\n\t\t\t\tt_MsPipe->MaximumPacketSize = MsPipe->MaximumPacketSize;\n\t\t\t\tt_MsPipe->MaximumTransferSize = MsPipe->MaximumTransferSize;\n\t\t\t\tt_MsPipe->PipeFlags = MsPipe->PipeFlags;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt_MsPipe->MaximumPacketSize = 0;\n\t\t\t\tt_MsPipe->MaximumTransferSize = 0xffffffff;\n\t\t\t\tt_MsPipe->PipeFlags = 0;\n\t\t\t}\n\n\t\t\tt_MsPipe->PipeHandle = 0;\n\t\t\tt_MsPipe->bEndpointAddress = 0;\n\t\t\tt_MsPipe->bInterval = 0;\n\t\t\tt_MsPipe->PipeType = 0;\n\t\t\tt_MsPipe->InitCompleted = 0;\n\t\t\tt_MsPipes[pnum] = t_MsPipe;\n\t\t}\n\n\t\tmsusb_mspipes_replace(MsInterface, t_MsPipes, LibusbNumEndpoint);\n\t}\n\n\t/* setup configuration */\n\tMsOutSize = 8;\n\t/* ConfigurationHandle:  4 bytes\n\t * ---------------------------------------------------------------\n\t * ||<<< 1 byte >>>|<<< 1 byte >>>|<<<<<<<<<< 2 byte >>>>>>>>>>>||\n\t * ||  bus_number  |  dev_number  |      bConfigurationValue    ||\n\t * ---------------------------------------------------------------\n\t * ***********************/\n\tMsConfig->ConfigurationHandle =\n\t    MsConfig->bConfigurationValue | (pdev->bus_number << 24) | (pdev->dev_number << 16);\n\tMsInterfaces = MsConfig->MsInterfaces;\n\n\tfor (inum = 0; inum < MsConfig->NumInterfaces; inum++)\n\t{\n\t\tMsOutSize += 16;\n\t\tMsInterface = MsInterfaces[inum];\n\t\t/* get libusb's interface */\n\t\tLibusbInterface = &LibusbConfig->interface[MsInterface->InterfaceNumber];\n\t\tLibusbAltsetting = &LibusbInterface->altsetting[MsInterface->AlternateSetting];\n\t\t/* InterfaceHandle:  4 bytes\n\t\t * ---------------------------------------------------------------\n\t\t * ||<<< 1 byte >>>|<<< 1 byte >>>|<<< 1 byte >>>|<<< 1 byte >>>||\n\t\t * ||  bus_number  |  dev_number  |  altsetting  | interfaceNum ||\n\t\t * ---------------------------------------------------------------\n\t\t * ***********************/\n\t\tMsInterface->InterfaceHandle = LibusbAltsetting->bInterfaceNumber |\n\t\t                               (LibusbAltsetting->bAlternateSetting << 8) |\n\t\t                               (pdev->dev_number << 16) | (pdev->bus_number << 24);\n\t\tMsInterface->Length = 16 + (MsInterface->NumberOfPipes * 20);\n\t\tMsInterface->bInterfaceClass = LibusbAltsetting->bInterfaceClass;\n\t\tMsInterface->bInterfaceSubClass = LibusbAltsetting->bInterfaceSubClass;\n\t\tMsInterface->bInterfaceProtocol = LibusbAltsetting->bInterfaceProtocol;\n\t\tMsInterface->InitCompleted = 1;\n\t\tMsPipes = MsInterface->MsPipes;\n\t\tLibusbNumEndpoint = LibusbAltsetting->bNumEndpoints;\n\n\t\tfor (pnum = 0; pnum < LibusbNumEndpoint; pnum++)\n\t\t{\n\t\t\tMsOutSize += 20;\n\t\t\tMsPipe = MsPipes[pnum];\n\t\t\t/* get libusb's endpoint */\n\t\t\tLibusbEndpoint = &LibusbAltsetting->endpoint[pnum];\n\t\t\t/* PipeHandle:  4 bytes\n\t\t\t * ---------------------------------------------------------------\n\t\t\t * ||<<< 1 byte >>>|<<< 1 byte >>>|<<<<<<<<<< 2 byte >>>>>>>>>>>||\n\t\t\t * ||  bus_number  |  dev_number  |      bEndpointAddress       ||\n\t\t\t * ---------------------------------------------------------------\n\t\t\t * ***********************/\n\t\t\tMsPipe->PipeHandle = LibusbEndpoint->bEndpointAddress | (pdev->dev_number << 16) |\n\t\t\t                     (pdev->bus_number << 24);\n\t\t\t/* count endpoint max packet size */\n\t\t\tint max = LibusbEndpoint->wMaxPacketSize & 0x07ff;\n\t\t\tBYTE attr = LibusbEndpoint->bmAttributes;\n\n\t\t\tif ((attr & 0x3) == 1 || (attr & 0x3) == 3)\n\t\t\t{\n\t\t\t\tmax *= (1 + ((LibusbEndpoint->wMaxPacketSize >> 11) & 3));\n\t\t\t}\n\n\t\t\tMsPipe->MaximumPacketSize = max;\n\t\t\tMsPipe->bEndpointAddress = LibusbEndpoint->bEndpointAddress;\n\t\t\tMsPipe->bInterval = LibusbEndpoint->bInterval;\n\t\t\tMsPipe->PipeType = attr & 0x3;\n\t\t\tMsPipe->InitCompleted = 1;\n\t\t}\n\t}\n\n\tMsConfig->MsOutSize = MsOutSize;\n\tMsConfig->InitCompleted = 1;\n\n\t/* replace device's MsConfig */\n\tif (MsConfig != pdev->MsConfig)\n\t{\n\t\tmsusb_msconfig_free(pdev->MsConfig);\n\t\tpdev->MsConfig = MsConfig;\n\t}\n\n\treturn MsConfig;\n}\n\nstatic int libusb_udev_select_configuration(IUDEVICE* idev, UINT32 bConfigurationValue)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig;\n\tLIBUSB_DEVICE_HANDLE* libusb_handle;\n\tLIBUSB_DEVICE* libusb_dev;\n\tURBDRC_PLUGIN* urbdrc;\n\tLIBUSB_CONFIG_DESCRIPTOR** LibusbConfig;\n\tint ret = 0;\n\n\tif (!pdev || !pdev->MsConfig || !pdev->LibusbConfig || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tMsConfig = pdev->MsConfig;\n\tlibusb_handle = pdev->libusb_handle;\n\tlibusb_dev = pdev->libusb_dev;\n\tLibusbConfig = &pdev->LibusbConfig;\n\n\tif (MsConfig->InitCompleted)\n\t{\n\t\tfunc_config_release_all_interface(pdev->urbdrc, libusb_handle,\n\t\t                                  (*LibusbConfig)->bNumInterfaces);\n\t}\n\n\t/* The configuration value -1 is mean to put the device in unconfigured state. */\n\tif (bConfigurationValue == 0)\n\t\tret = libusb_set_configuration(libusb_handle, -1);\n\telse\n\t\tret = libusb_set_configuration(libusb_handle, bConfigurationValue);\n\n\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_set_configuration\", ret))\n\t{\n\t\tfunc_claim_all_interface(urbdrc, libusb_handle, (*LibusbConfig)->bNumInterfaces);\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tret = libusb_get_active_config_descriptor(libusb_dev, LibusbConfig);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_set_configuration\", ret))\n\t\t{\n\t\t\tfunc_claim_all_interface(urbdrc, libusb_handle, (*LibusbConfig)->bNumInterfaces);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfunc_claim_all_interface(urbdrc, libusb_handle, (*LibusbConfig)->bNumInterfaces);\n\treturn 0;\n}\n\nstatic int libusb_udev_control_pipe_request(IUDEVICE* idev, UINT32 RequestId,\n                                            UINT32 EndpointAddress, UINT32* UsbdStatus, int command)\n{\n\tint error = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\t/*\n\tpdev->request_queue->register_request(pdev->request_queue, RequestId, NULL, 0);\n\t*/\n\tswitch (command)\n\t{\n\t\tcase PIPE_CANCEL:\n\t\t\t/** cancel bulk or int transfer */\n\t\t\tidev->cancel_all_transfer_request(idev);\n\t\t\t// dummy_wait_s_obj(1);\n\t\t\t/** set feature to ep (set halt)*/\n\t\t\terror = libusb_control_transfer(\n\t\t\t    pdev->libusb_handle, LIBUSB_ENDPOINT_OUT | LIBUSB_RECIPIENT_ENDPOINT,\n\t\t\t    LIBUSB_REQUEST_SET_FEATURE, ENDPOINT_HALT, EndpointAddress, NULL, 0, 1000);\n\t\t\tbreak;\n\n\t\tcase PIPE_RESET:\n\t\t\tidev->cancel_all_transfer_request(idev);\n\t\t\terror = libusb_clear_halt(pdev->libusb_handle, EndpointAddress);\n\t\t\t// func_set_usbd_status(pdev, UsbdStatus, error);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror = -0xff;\n\t\t\tbreak;\n\t}\n\n\t*UsbdStatus = 0;\n\treturn error;\n}\n\nstatic UINT32 libusb_udev_control_query_device_text(IUDEVICE* idev, UINT32 TextType,\n                                                    UINT16 LocaleId, UINT8* BufferSize,\n                                                    BYTE* Buffer)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tLIBUSB_DEVICE_DESCRIPTOR* devDescriptor;\n\tconst char strDesc[] = \"Generic Usb String\";\n\tchar deviceLocation[25] = { 0 };\n\tBYTE bus_number;\n\tBYTE device_address;\n\tint ret = 0;\n\tsize_t i, len;\n\tURBDRC_PLUGIN* urbdrc;\n\tWCHAR* text = (WCHAR*)Buffer;\n\tBYTE slen, locale;\n\tconst UINT8 inSize = *BufferSize;\n\n\t*BufferSize = 0;\n\tif (!pdev || !pdev->devDescriptor || !pdev->urbdrc)\n\t\treturn ERROR_INVALID_DATA;\n\n\turbdrc = pdev->urbdrc;\n\tdevDescriptor = pdev->devDescriptor;\n\n\tswitch (TextType)\n\t{\n\t\tcase DeviceTextDescription:\n\t\t{\n\t\t\tBYTE data[0x100] = { 0 };\n\t\t\tret = libusb_get_string_descriptor(pdev->libusb_handle, devDescriptor->iProduct,\n\t\t\t                                   LocaleId, data, 0xFF);\n\t\t\t/* The returned data in the buffer is:\n\t\t\t * 1 byte  length of following data\n\t\t\t * 1 byte  descriptor type, must be 0x03 for strings\n\t\t\t * n WCHAR unicode string (of length / 2 characters) including '\\0'\n\t\t\t */\n\t\t\tslen = data[0];\n\t\t\tlocale = data[1];\n\n\t\t\tif ((ret <= 0) || (ret <= 4) || (slen <= 4) || (locale != LIBUSB_DT_STRING) ||\n\t\t\t    (ret > UINT8_MAX))\n\t\t\t{\n\t\t\t\tconst char* msg = \"SHORT_DESCRIPTOR\";\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tmsg = libusb_error_name(ret);\n\t\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t\t           \"libusb_get_string_descriptor: \"\n\t\t\t\t           \"%s [%d], iProduct: %\" PRIu8 \"!\",\n\t\t\t\t           msg, ret, devDescriptor->iProduct);\n\n\t\t\t\tlen = MIN(sizeof(strDesc), inSize);\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t\ttext[i] = (WCHAR)strDesc[i];\n\n\t\t\t\t*BufferSize = (BYTE)(len * 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* ret and slen should be equals, but you never know creativity\n\t\t\t\t * of device manufacturers...\n\t\t\t\t * So also check the string length returned as server side does\n\t\t\t\t * not honor strings with multi '\\0' characters well.\n\t\t\t\t */\n\t\t\t\tconst size_t rchar = _wcsnlen((WCHAR*)&data[2], sizeof(data) / 2);\n\t\t\t\tlen = MIN((BYTE)ret, slen);\n\t\t\t\tlen = MIN(len, inSize);\n\t\t\t\tlen = MIN(len, rchar * 2 + sizeof(WCHAR));\n\t\t\t\tmemcpy(Buffer, &data[2], len);\n\n\t\t\t\t/* Just as above, the returned WCHAR string should be '\\0'\n\t\t\t\t * terminated, but never trust hardware to conform to specs... */\n\t\t\t\tBuffer[len - 2] = '\\0';\n\t\t\t\tBuffer[len - 1] = '\\0';\n\t\t\t\t*BufferSize = (BYTE)len;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase DeviceTextLocationInformation:\n\t\t\tbus_number = libusb_get_bus_number(pdev->libusb_dev);\n\t\t\tdevice_address = libusb_get_device_address(pdev->libusb_dev);\n\t\t\tsprintf_s(deviceLocation, sizeof(deviceLocation),\n\t\t\t          \"Port_#%04\" PRIu8 \".Hub_#%04\" PRIu8 \"\", device_address, bus_number);\n\n\t\t\tlen = strnlen(deviceLocation,\n\t\t\t              MIN(sizeof(deviceLocation), (inSize > 0) ? inSize - 1U : 0));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\ttext[i] = (WCHAR)deviceLocation[i];\n\t\t\ttext[len++] = '\\0';\n\t\t\t*BufferSize = (UINT8)(len * sizeof(WCHAR));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"Query Text: unknown TextType %\" PRIu32 \"\",\n\t\t\t           TextType);\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\treturn S_OK;\n}\n\nstatic int libusb_udev_os_feature_descriptor_request(IUDEVICE* idev, UINT32 RequestId,\n                                                     BYTE Recipient, BYTE InterfaceNumber,\n                                                     BYTE Ms_PageIndex, UINT16 Ms_featureDescIndex,\n                                                     UINT32* UsbdStatus, UINT32* BufferSize,\n                                                     BYTE* Buffer, int Timeout)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tBYTE ms_string_desc[0x13] = { 0 };\n\tint error = 0;\n\t/*\n\tpdev->request_queue->register_request(pdev->request_queue, RequestId, NULL, 0);\n\t*/\n\terror = libusb_control_transfer(pdev->libusb_handle, LIBUSB_ENDPOINT_IN | Recipient,\n\t                                LIBUSB_REQUEST_GET_DESCRIPTOR, 0x03ee, 0, ms_string_desc, 0x12,\n\t                                Timeout);\n\n\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_control_transfer\", error);\n\n\tif (error > 0)\n\t{\n\t\tconst BYTE bMS_Vendorcode = ms_string_desc[16];\n\t\t/** get os descriptor */\n\t\terror = libusb_control_transfer(pdev->libusb_handle,\n\t\t                                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | Recipient,\n\t\t                                bMS_Vendorcode, (InterfaceNumber << 8) | Ms_PageIndex,\n\t\t                                Ms_featureDescIndex, Buffer, *BufferSize, Timeout);\n\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_control_transfer\", error);\n\n\t\tif (error >= 0)\n\t\t\t*BufferSize = error;\n\t}\n\n\tif (error < 0)\n\t\t*UsbdStatus = USBD_STATUS_STALL_PID;\n\telse\n\t\t*UsbdStatus = USBD_STATUS_SUCCESS;\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic int libusb_udev_query_device_descriptor(IUDEVICE* idev, int offset)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tswitch (offset)\n\t{\n\t\tcase B_LENGTH:\n\t\t\treturn pdev->devDescriptor->bLength;\n\n\t\tcase B_DESCRIPTOR_TYPE:\n\t\t\treturn pdev->devDescriptor->bDescriptorType;\n\n\t\tcase BCD_USB:\n\t\t\treturn pdev->devDescriptor->bcdUSB;\n\n\t\tcase B_DEVICE_CLASS:\n\t\t\treturn pdev->devDescriptor->bDeviceClass;\n\n\t\tcase B_DEVICE_SUBCLASS:\n\t\t\treturn pdev->devDescriptor->bDeviceSubClass;\n\n\t\tcase B_DEVICE_PROTOCOL:\n\t\t\treturn pdev->devDescriptor->bDeviceProtocol;\n\n\t\tcase B_MAX_PACKET_SIZE0:\n\t\t\treturn pdev->devDescriptor->bMaxPacketSize0;\n\n\t\tcase ID_VENDOR:\n\t\t\treturn pdev->devDescriptor->idVendor;\n\n\t\tcase ID_PRODUCT:\n\t\t\treturn pdev->devDescriptor->idProduct;\n\n\t\tcase BCD_DEVICE:\n\t\t\treturn pdev->devDescriptor->bcdDevice;\n\n\t\tcase I_MANUFACTURER:\n\t\t\treturn pdev->devDescriptor->iManufacturer;\n\n\t\tcase I_PRODUCT:\n\t\t\treturn pdev->devDescriptor->iProduct;\n\n\t\tcase I_SERIAL_NUMBER:\n\t\t\treturn pdev->devDescriptor->iSerialNumber;\n\n\t\tcase B_NUM_CONFIGURATIONS:\n\t\t\treturn pdev->devDescriptor->bNumConfigurations;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic BOOL libusb_udev_detach_kernel_driver(IUDEVICE* idev)\n{\n\tint i, err = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->libusb_handle || !pdev->urbdrc)\n\t\treturn FALSE;\n\n#ifdef _WIN32\n\treturn TRUE;\n#else\n\turbdrc = pdev->urbdrc;\n\n\tif ((pdev->status & URBDRC_DEVICE_DETACH_KERNEL) == 0)\n\t{\n\t\tfor (i = 0; i < pdev->LibusbConfig->bNumInterfaces; i++)\n\t\t{\n\t\t\terr = libusb_kernel_driver_active(pdev->libusb_handle, i);\n\t\t\tlog_libusb_result(urbdrc->log, WLOG_DEBUG, \"libusb_kernel_driver_active\", err);\n\n\t\t\tif (err)\n\t\t\t{\n\t\t\t\terr = libusb_detach_kernel_driver(pdev->libusb_handle, i);\n\t\t\t\tlog_libusb_result(urbdrc->log, WLOG_DEBUG, \"libusb_detach_kernel_driver\", err);\n\t\t\t}\n\t\t}\n\n\t\tpdev->status |= URBDRC_DEVICE_DETACH_KERNEL;\n\t}\n\n\treturn TRUE;\n#endif\n}\n\nstatic BOOL libusb_udev_attach_kernel_driver(IUDEVICE* idev)\n{\n\tint i, err = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->libusb_handle || !pdev->urbdrc)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < pdev->LibusbConfig->bNumInterfaces && err != LIBUSB_ERROR_NO_DEVICE; i++)\n\t{\n\t\terr = libusb_release_interface(pdev->libusb_handle, i);\n\n\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_release_interface\", err);\n\n#ifndef _WIN32\n\t\tif (err != LIBUSB_ERROR_NO_DEVICE)\n\t\t{\n\t\t\terr = libusb_attach_kernel_driver(pdev->libusb_handle, i);\n\t\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_attach_kernel_driver if=%d\",\n\t\t\t                  err, i);\n\t\t}\n#endif\n\t}\n\n\treturn TRUE;\n}\n\nstatic int libusb_udev_is_composite_device(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn pdev->isCompositeDevice;\n}\n\nstatic int libusb_udev_is_exist(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn (pdev->status & URBDRC_DEVICE_NOT_FOUND) ? 0 : 1;\n}\n\nstatic int libusb_udev_is_channel_closed(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tIUDEVMAN* udevman;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn 1;\n\n\tudevman = pdev->urbdrc->udevman;\n\tif (udevman)\n\t{\n\t\tif (udevman->status & URBDRC_DEVICE_CHANNEL_CLOSED)\n\t\t\treturn 1;\n\t}\n\n\tif (pdev->status & URBDRC_DEVICE_CHANNEL_CLOSED)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int libusb_udev_is_already_send(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn (pdev->status & URBDRC_DEVICE_ALREADY_SEND) ? 1 : 0;\n}\n\n/* This is called from channel cleanup code.\n * Avoid double free, just remove the device and mark the channel closed. */\nstatic void libusb_udev_mark_channel_closed(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tif (pdev && ((pdev->status & URBDRC_DEVICE_CHANNEL_CLOSED) == 0))\n\t{\n\t\tURBDRC_PLUGIN* urbdrc = pdev->urbdrc;\n\t\tconst uint8_t busNr = idev->get_bus_number(idev);\n\t\tconst uint8_t devNr = idev->get_dev_number(idev);\n\n\t\tpdev->status |= URBDRC_DEVICE_CHANNEL_CLOSED;\n\t\turbdrc->udevman->unregister_udevice(urbdrc->udevman, busNr, devNr);\n\t}\n}\n\n/* This is called by local events where the device is removed or in an error\n * state. Remove the device from redirection and close the channel. */\nstatic void libusb_udev_channel_closed(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tif (pdev && ((pdev->status & URBDRC_DEVICE_CHANNEL_CLOSED) == 0))\n\t{\n\t\tURBDRC_PLUGIN* urbdrc = pdev->urbdrc;\n\t\tconst uint8_t busNr = idev->get_bus_number(idev);\n\t\tconst uint8_t devNr = idev->get_dev_number(idev);\n\t\tIWTSVirtualChannel* channel = NULL;\n\n\t\tif (pdev->channelManager)\n\t\t\tchannel = IFCALLRESULT(NULL, pdev->channelManager->FindChannelById,\n\t\t\t                       pdev->channelManager, pdev->channelID);\n\n\t\tpdev->status |= URBDRC_DEVICE_CHANNEL_CLOSED;\n\n\t\tif (channel)\n\t\t\tchannel->Write(channel, 0, NULL, NULL);\n\n\t\turbdrc->udevman->unregister_udevice(urbdrc->udevman, busNr, devNr);\n\t}\n}\n\nstatic void libusb_udev_set_already_send(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tpdev->status |= URBDRC_DEVICE_ALREADY_SEND;\n}\n\nstatic char* libusb_udev_get_path(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn pdev->path;\n}\n\nstatic int libusb_udev_query_device_port_status(IUDEVICE* idev, UINT32* UsbdStatus,\n                                                UINT32* BufferSize, BYTE* Buffer)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tint success = 0, ret;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\n\tif (pdev->hub_handle != NULL)\n\t{\n\t\tret = idev->control_transfer(\n\t\t    idev, 0xffff, 0, 0,\n\t\t    LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_OTHER,\n\t\t    LIBUSB_REQUEST_GET_STATUS, 0, pdev->port_number, UsbdStatus, BufferSize, Buffer, 1000);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_DEBUG, \"libusb_control_transfer\", ret))\n\t\t\t*BufferSize = 0;\n\t\telse\n\t\t{\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"PORT STATUS:0x%02\" PRIx8 \"%02\" PRIx8 \"%02\" PRIx8 \"%02\" PRIx8 \"\", Buffer[3],\n\t\t\t           Buffer[2], Buffer[1], Buffer[0]);\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\treturn success;\n}\n\nstatic int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\n\tif (!user_data)\n\t\treturn -1;\n\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\n\tiso_packet_size = BufferSize / NumberOfPackets;\n\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\n\t/**  process URB_FUNCTION_IOSCH_TRANSFER */\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}\n\nstatic BOOL libusb_udev_control_transfer(IUDEVICE* idev, UINT32 RequestId, UINT32 EndpointAddress,\n                                         UINT32 TransferFlags, BYTE bmRequestType, BYTE Request,\n                                         UINT16 Value, UINT16 Index, UINT32* UrbdStatus,\n                                         UINT32* BufferSize, BYTE* Buffer, UINT32 Timeout)\n{\n\tint status = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn FALSE;\n\n\tstatus = libusb_control_transfer(pdev->libusb_handle, bmRequestType, Request, Value, Index,\n\t                                 Buffer, *BufferSize, Timeout);\n\n\tif (status >= 0)\n\t\t*BufferSize = (UINT32)status;\n\telse\n\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_ERROR, \"libusb_control_transfer\", status);\n\n\tif (!func_set_usbd_status(pdev->urbdrc, pdev, UrbdStatus, status))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic int libusb_udev_bulk_or_interrupt_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                                  UINT32 MessageId, UINT32 RequestId,\n                                                  UINT32 EndpointAddress, UINT32 TransferFlags,\n                                                  BOOL NoAck, UINT32 BufferSize, const BYTE* data,\n                                                  t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 transfer_type;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tconst LIBUSB_ENDPOINT_DESCEIPTOR* ep_desc;\n\tstruct libusb_transfer* transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tuint32_t streamID = 0x80000000 | RequestId;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tuser_data =\n\t    async_transfer_user_data_new(idev, MessageId, 36, BufferSize, data, 0, NoAck, cb, callback);\n\n\tif (!user_data)\n\t\treturn -1;\n\n\t/* alloc memory for urb transfer */\n\ttransfer = libusb_alloc_transfer(0);\n\tif (!transfer)\n\t{\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\n\tep_desc = func_get_ep_desc(pdev->LibusbConfig, pdev->MsConfig, EndpointAddress);\n\n\tif (!ep_desc)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"func_get_ep_desc: endpoint 0x%\" PRIx32 \" not found\",\n\t\t           EndpointAddress);\n\t\trequest_free(transfer);\n\t\treturn -1;\n\t}\n\n\ttransfer_type = (ep_desc->bmAttributes) & 0x3;\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"urb_bulk_or_interrupt_transfer: ep:0x%\" PRIx32 \" \"\n\t           \"transfer_type %\" PRIu32 \" flag:%\" PRIu32 \" OutputBufferSize:0x%\" PRIx32 \"\",\n\t           EndpointAddress, transfer_type, TransferFlags, BufferSize);\n\n\tswitch (transfer_type)\n\t{\n\t\tcase BULK_TRANSFER:\n\t\t\t/** Bulk Transfer */\n\t\t\tlibusb_fill_bulk_transfer(transfer, pdev->libusb_handle, EndpointAddress,\n\t\t\t                          Stream_Pointer(user_data->data), BufferSize,\n\t\t\t                          func_bulk_transfer_cb, user_data, Timeout);\n\t\t\tbreak;\n\n\t\tcase INTERRUPT_TRANSFER:\n\t\t\t/**  Interrupt Transfer */\n\t\t\tlibusb_fill_interrupt_transfer(transfer, pdev->libusb_handle, EndpointAddress,\n\t\t\t                               Stream_Pointer(user_data->data), BufferSize,\n\t\t\t                               func_bulk_transfer_cb, user_data, Timeout);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"urb_bulk_or_interrupt_transfer:\"\n\t\t\t           \" other transfer type 0x%\" PRIX32 \"\",\n\t\t\t           transfer_type);\n\t\t\trequest_free(transfer);\n\t\t\treturn -1;\n\t}\n\n\tset_stream_id_for_buffer(transfer, streamID);\n\n\tif (ArrayList_Add(pdev->request_queue, transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue transfer, streamID %08\" PRIx32 \" already in use!\", streamID);\n\t\trequest_free(transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(transfer);\n}\n\nstatic int func_cancel_xact_request(URBDRC_PLUGIN* urbdrc, struct libusb_transfer* transfer)\n{\n\tint status;\n\n\tif (!urbdrc || !transfer)\n\t\treturn -1;\n\n\tstatus = libusb_cancel_transfer(transfer);\n\n\tif (log_libusb_result(urbdrc->log, WLOG_WARN, \"libusb_cancel_transfer\", status))\n\t{\n\t\tif (status == LIBUSB_ERROR_NOT_FOUND)\n\t\t\treturn -1;\n\t}\n\telse\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void libusb_udev_cancel_all_transfer_request(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tint count, x;\n\n\tif (!pdev || !pdev->request_queue || !pdev->urbdrc)\n\t\treturn;\n\n\tArrayList_Lock(pdev->request_queue);\n\tcount = ArrayList_Count(pdev->request_queue);\n\n\tfor (x = 0; x < count; x++)\n\t{\n\t\tstruct libusb_transfer* transfer = ArrayList_GetItem(pdev->request_queue, x);\n\t\tfunc_cancel_xact_request(pdev->urbdrc, transfer);\n\t}\n\n\tArrayList_Unlock(pdev->request_queue);\n}\n\nstatic int libusb_udev_cancel_transfer_request(IUDEVICE* idev, UINT32 RequestId)\n{\n\tint rc = -1;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tstruct libusb_transfer* transfer;\n\tuint32_t cancelID1 = 0x40000000 | RequestId;\n\tuint32_t cancelID2 = 0x80000000 | RequestId;\n\n\tif (!idev || !pdev->urbdrc || !pdev->request_queue)\n\t\treturn -1;\n\n\tArrayList_Lock(pdev->request_queue);\n\ttransfer = list_contains(pdev->request_queue, cancelID1);\n\tif (!transfer)\n\t\ttransfer = list_contains(pdev->request_queue, cancelID2);\n\n\tif (transfer)\n\t{\n\t\tURBDRC_PLUGIN* urbdrc = (URBDRC_PLUGIN*)pdev->urbdrc;\n\n\t\trc = func_cancel_xact_request(urbdrc, transfer);\n\t}\n\tArrayList_Unlock(pdev->request_queue);\n\treturn rc;\n}\n\nBASIC_STATE_FUNC_DEFINED(channelManager, IWTSVirtualChannelManager*)\nBASIC_STATE_FUNC_DEFINED(channelID, UINT32)\nBASIC_STATE_FUNC_DEFINED(ReqCompletion, UINT32)\nBASIC_STATE_FUNC_DEFINED(bus_number, BYTE)\nBASIC_STATE_FUNC_DEFINED(dev_number, BYTE)\nBASIC_STATE_FUNC_DEFINED(port_number, int)\nBASIC_STATE_FUNC_DEFINED(MsConfig, MSUSB_CONFIG_DESCRIPTOR*)\n\nBASIC_POINT_FUNC_DEFINED(udev, void*)\nBASIC_POINT_FUNC_DEFINED(prev, void*)\nBASIC_POINT_FUNC_DEFINED(next, void*)\n\nstatic UINT32 udev_get_UsbDevice(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev)\n\t\treturn 0;\n\n\treturn pdev->UsbDevice;\n}\n\nstatic void udev_set_UsbDevice(IUDEVICE* idev, UINT32 val)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev)\n\t\treturn;\n\n\tpdev->UsbDevice = val;\n}\n\nstatic void udev_free(IUDEVICE* idev)\n{\n\tint rc;\n\tUDEVICE* udev = (UDEVICE*)idev;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!idev || !udev->urbdrc)\n\t\treturn;\n\n\turbdrc = udev->urbdrc;\n\n\tlibusb_udev_cancel_all_transfer_request(&udev->iface);\n\tif (udev->libusb_handle)\n\t{\n\t\trc = libusb_reset_device(udev->libusb_handle);\n\n\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_reset_device\", rc);\n\t}\n\n\t/* release all interface and  attach kernel driver */\n\tudev->iface.attach_kernel_driver(idev);\n\tArrayList_Free(udev->request_queue);\n\t/* free the config descriptor that send from windows */\n\tmsusb_msconfig_free(udev->MsConfig);\n\tlibusb_unref_device(udev->libusb_dev);\n\tlibusb_close(udev->libusb_handle);\n\tlibusb_close(udev->hub_handle);\n\tfree(udev->devDescriptor);\n\tfree(idev);\n}\n\nstatic void udev_load_interface(UDEVICE* pdev)\n{\n\t/* load interface */\n\t/* Basic */\n\tBASIC_STATE_FUNC_REGISTER(channelManager, pdev);\n\tBASIC_STATE_FUNC_REGISTER(channelID, pdev);\n\tBASIC_STATE_FUNC_REGISTER(UsbDevice, pdev);\n\tBASIC_STATE_FUNC_REGISTER(ReqCompletion, pdev);\n\tBASIC_STATE_FUNC_REGISTER(bus_number, pdev);\n\tBASIC_STATE_FUNC_REGISTER(dev_number, pdev);\n\tBASIC_STATE_FUNC_REGISTER(port_number, pdev);\n\tBASIC_STATE_FUNC_REGISTER(MsConfig, pdev);\n\tBASIC_STATE_FUNC_REGISTER(p_udev, pdev);\n\tBASIC_STATE_FUNC_REGISTER(p_prev, pdev);\n\tBASIC_STATE_FUNC_REGISTER(p_next, pdev);\n\tpdev->iface.isCompositeDevice = libusb_udev_is_composite_device;\n\tpdev->iface.isExist = libusb_udev_is_exist;\n\tpdev->iface.isAlreadySend = libusb_udev_is_already_send;\n\tpdev->iface.isChannelClosed = libusb_udev_is_channel_closed;\n\tpdev->iface.setAlreadySend = libusb_udev_set_already_send;\n\tpdev->iface.setChannelClosed = libusb_udev_channel_closed;\n\tpdev->iface.markChannelClosed = libusb_udev_mark_channel_closed;\n\tpdev->iface.getPath = libusb_udev_get_path;\n\t/* Transfer */\n\tpdev->iface.isoch_transfer = libusb_udev_isoch_transfer;\n\tpdev->iface.control_transfer = libusb_udev_control_transfer;\n\tpdev->iface.bulk_or_interrupt_transfer = libusb_udev_bulk_or_interrupt_transfer;\n\tpdev->iface.select_interface = libusb_udev_select_interface;\n\tpdev->iface.select_configuration = libusb_udev_select_configuration;\n\tpdev->iface.complete_msconfig_setup = libusb_udev_complete_msconfig_setup;\n\tpdev->iface.control_pipe_request = libusb_udev_control_pipe_request;\n\tpdev->iface.control_query_device_text = libusb_udev_control_query_device_text;\n\tpdev->iface.os_feature_descriptor_request = libusb_udev_os_feature_descriptor_request;\n\tpdev->iface.cancel_all_transfer_request = libusb_udev_cancel_all_transfer_request;\n\tpdev->iface.cancel_transfer_request = libusb_udev_cancel_transfer_request;\n\tpdev->iface.query_device_descriptor = libusb_udev_query_device_descriptor;\n\tpdev->iface.detach_kernel_driver = libusb_udev_detach_kernel_driver;\n\tpdev->iface.attach_kernel_driver = libusb_udev_attach_kernel_driver;\n\tpdev->iface.query_device_port_status = libusb_udev_query_device_port_status;\n\tpdev->iface.free = udev_free;\n}\n\nstatic int udev_get_device_handle(URBDRC_PLUGIN* urbdrc, libusb_context* ctx, UDEVICE* pdev,\n                                  UINT16 bus_number, UINT16 dev_number)\n{\n\tint error;\n\tssize_t i, total_device;\n\tuint8_t port_numbers[16];\n\tLIBUSB_DEVICE** libusb_list;\n\ttotal_device = libusb_get_device_list(ctx, &libusb_list);\n\t/* Look for device. */\n\terror = -1;\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\n\t\tif ((bus_number != libusb_get_bus_number(dev)) ||\n\t\t    (dev_number != libusb_get_device_address(dev)))\n\t\t\tcontinue;\n\n\t\terror = libusb_open(dev, &pdev->libusb_handle);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_open\", error))\n\t\t\tbreak;\n\n\t\t/* get port number */\n\t\terror = libusb_get_port_numbers(dev, port_numbers, sizeof(port_numbers));\n\n\t\tif (error < 1)\n\t\t{\n\t\t\t/* Prevent open hub, treat as error. */\n\t\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_get_port_numbers\", error);\n\t\t\tbreak;\n\t\t}\n\n\t\tpdev->port_number = port_numbers[(error - 1)];\n\t\terror = 0;\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"  Port: %d\", pdev->port_number);\n\t\t/* gen device path */\n\t\tsprintf(pdev->path, \"%\" PRIu16 \"-%\" PRIu16 \"\", bus_number, pdev->port_number);\n\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"  DevPath: %s\", pdev->path);\n\t\tbreak;\n\t}\n\tlibusb_free_device_list(libusb_list, 1);\n\n\tif (error < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int udev_get_hub_handle(URBDRC_PLUGIN* urbdrc, libusb_context* ctx, UDEVICE* pdev,\n                               UINT16 bus_number, UINT16 dev_number)\n{\n\tint error;\n\tssize_t i, total_device;\n\tLIBUSB_DEVICE** libusb_list;\n\tLIBUSB_DEVICE_HANDLE* handle;\n\ttotal_device = libusb_get_device_list(ctx, &libusb_list);\n\n\t/* Look for device hub. */\n\terror = -1;\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\n\t\tif ((bus_number != libusb_get_bus_number(dev)) ||\n\t\t    (1 != libusb_get_device_address(dev))) /* Root hub allways first on bus. */\n\t\t\tcontinue;\n\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"  Open hub: %\" PRIu16 \"\", bus_number);\n\t\terror = libusb_open(dev, &handle);\n\n\t\tif (!log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_open\", error))\n\t\t\tpdev->hub_handle = handle;\n\n\t\tbreak;\n\t}\n\n\tlibusb_free_device_list(libusb_list, 1);\n\n\tif (error < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void request_free(void* value)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* transfer = (struct libusb_transfer*)value;\n\tif (!transfer)\n\t\treturn;\n\n\tuser_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tasync_transfer_user_data_free(user_data);\n\ttransfer->user_data = NULL;\n\tlibusb_free_transfer(transfer);\n}\n\nstatic IUDEVICE* udev_init(URBDRC_PLUGIN* urbdrc, libusb_context* context, LIBUSB_DEVICE* device,\n                           BYTE bus_number, BYTE dev_number)\n{\n\tUDEVICE* pdev;\n\tint status = LIBUSB_ERROR_OTHER;\n\tLIBUSB_DEVICE_DESCRIPTOR* devDescriptor;\n\tLIBUSB_CONFIG_DESCRIPTOR* config_temp;\n\tLIBUSB_INTERFACE_DESCRIPTOR interface_temp;\n\tpdev = (PUDEVICE)calloc(1, sizeof(UDEVICE));\n\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpdev->urbdrc = urbdrc;\n\tudev_load_interface(pdev);\n\n\tif (device)\n\t\tpdev->libusb_dev = device;\n\telse\n\t\tpdev->libusb_dev = udev_get_libusb_dev(context, bus_number, dev_number);\n\n\tif (pdev->libusb_dev == NULL)\n\t\tgoto fail;\n\n\tif (urbdrc->listener_callback)\n\t\tudev_set_channelManager(&pdev->iface, urbdrc->listener_callback->channel_mgr);\n\n\t/* Get DEVICE handle */\n\tstatus = udev_get_device_handle(urbdrc, context, pdev, bus_number, dev_number);\n\tif (status != LIBUSB_SUCCESS)\n\t{\n\t\tstruct libusb_device_descriptor desc;\n\t\tconst uint8_t port = libusb_get_port_number(pdev->libusb_dev);\n\t\tlibusb_get_device_descriptor(pdev->libusb_dev, &desc);\n\n\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR,\n\t\t                  \"libusb_open [b=0x%02X,p=0x%02X,a=0x%02X,VID=0x%04X,PID=0x%04X]\", status,\n\t\t                  bus_number, port, dev_number, desc.idVendor, desc.idProduct);\n\t\tgoto fail;\n\t}\n\n\t/* Get HUB handle */\n\tstatus = udev_get_hub_handle(urbdrc, context, pdev, bus_number, dev_number);\n\n\tif (status < 0)\n\t\tpdev->hub_handle = NULL;\n\n\tpdev->devDescriptor = udev_new_descript(urbdrc, pdev->libusb_dev);\n\n\tif (!pdev->devDescriptor)\n\t\tgoto fail;\n\n\tstatus = libusb_get_active_config_descriptor(pdev->libusb_dev, &pdev->LibusbConfig);\n\n\tif (status == LIBUSB_ERROR_NOT_FOUND)\n\t\tstatus = libusb_get_config_descriptor(pdev->libusb_dev, 0, &pdev->LibusbConfig);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tconfig_temp = pdev->LibusbConfig;\n\t/* get the first interface and first altsetting */\n\tinterface_temp = config_temp->interface[0].altsetting[0];\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"Registered Device: Vid: 0x%04\" PRIX16 \" Pid: 0x%04\" PRIX16 \"\"\n\t           \" InterfaceClass = %s\",\n\t           pdev->devDescriptor->idVendor, pdev->devDescriptor->idProduct,\n\t           usb_interface_class_to_string(interface_temp.bInterfaceClass));\n\t/* Check composite device */\n\tdevDescriptor = pdev->devDescriptor;\n\n\tif ((devDescriptor->bNumConfigurations == 1) && (config_temp->bNumInterfaces > 1) &&\n\t    (devDescriptor->bDeviceClass == LIBUSB_CLASS_PER_INTERFACE))\n\t{\n\t\tpdev->isCompositeDevice = 1;\n\t}\n\telse if ((devDescriptor->bDeviceClass == 0xef) &&\n\t         (devDescriptor->bDeviceSubClass == LIBUSB_CLASS_COMM) &&\n\t         (devDescriptor->bDeviceProtocol == 0x01))\n\t{\n\t\tpdev->isCompositeDevice = 1;\n\t}\n\telse\n\t\tpdev->isCompositeDevice = 0;\n\n\t/* set device class to first interface class */\n\tdevDescriptor->bDeviceClass = interface_temp.bInterfaceClass;\n\tdevDescriptor->bDeviceSubClass = interface_temp.bInterfaceSubClass;\n\tdevDescriptor->bDeviceProtocol = interface_temp.bInterfaceProtocol;\n\t/* initialize pdev */\n\tpdev->bus_number = bus_number;\n\tpdev->dev_number = dev_number;\n\tpdev->request_queue = ArrayList_New(TRUE);\n\n\tif (!pdev->request_queue)\n\t\tgoto fail;\n\n\tArrayList_Object(pdev->request_queue)->fnObjectFree = request_free;\n\n\t/* set config of windows */\n\tpdev->MsConfig = msusb_msconfig_new();\n\n\tif (!pdev->MsConfig)\n\t\tgoto fail;\n\n\t// deb_config_msg(pdev->libusb_dev, config_temp, devDescriptor->bNumConfigurations);\n\treturn &pdev->iface;\nfail:\n\tpdev->iface.free(&pdev->iface);\n\treturn NULL;\n}\n\nsize_t udev_new_by_id(URBDRC_PLUGIN* urbdrc, libusb_context* ctx, UINT16 idVendor, UINT16 idProduct,\n                      IUDEVICE*** devArray)\n{\n\tLIBUSB_DEVICE** libusb_list;\n\tUDEVICE** array;\n\tssize_t i, total_device;\n\tsize_t num = 0;\n\n\tif (!urbdrc || !devArray)\n\t\treturn 0;\n\n\tWLog_Print(urbdrc->log, WLOG_INFO, \"VID: 0x%04\" PRIX16 \", PID: 0x%04\" PRIX16 \"\", idVendor,\n\t           idProduct);\n\ttotal_device = libusb_get_device_list(ctx, &libusb_list);\n\tarray = (UDEVICE**)calloc(total_device, sizeof(UDEVICE*));\n\n\tif (!array)\n\t\tgoto fail;\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\t\tLIBUSB_DEVICE_DESCRIPTOR* descriptor = udev_new_descript(urbdrc, dev);\n\n\t\tif ((descriptor->idVendor == idVendor) && (descriptor->idProduct == idProduct))\n\t\t{\n\t\t\tarray[num] = (PUDEVICE)udev_init(urbdrc, ctx, dev, libusb_get_bus_number(dev),\n\t\t\t                                 libusb_get_device_address(dev));\n\n\t\t\tif (array[num] != NULL)\n\t\t\t\tnum++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibusb_unref_device(dev);\n\t\t}\n\n\t\tfree(descriptor);\n\t}\n\nfail:\n\tlibusb_free_device_list(libusb_list, 0);\n\t*devArray = (IUDEVICE**)array;\n\treturn num;\n}\n\nIUDEVICE* udev_new_by_addr(URBDRC_PLUGIN* urbdrc, libusb_context* context, BYTE bus_number,\n                           BYTE dev_number)\n{\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"bus:%d dev:%d\", bus_number, dev_number);\n\treturn udev_init(urbdrc, context, NULL, bus_number, dev_number);\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RemoteFX USB Redirection\n *\n * Copyright 2012 Atrust corp.\n * Copyright 2012 Alfred Liu <alfred.liu@atruscorp.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/sysinfo.h>\n#include <winpr/collections.h>\n\n#include <errno.h>\n\n#include \"libusb_udevice.h\"\n#include \"../common/urbdrc_types.h\"\n\n#define BASIC_STATE_FUNC_DEFINED(_arg, _type)             \\\n\tstatic _type udev_get_##_arg(IUDEVICE* idev)          \\\n\t{                                                     \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                   \\\n\t\treturn pdev->_arg;                                \\\n\t}                                                     \\\n\tstatic void udev_set_##_arg(IUDEVICE* idev, _type _t) \\\n\t{                                                     \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                   \\\n\t\tpdev->_arg = _t;                                  \\\n\t}\n\n#define BASIC_POINT_FUNC_DEFINED(_arg, _type)               \\\n\tstatic _type udev_get_p_##_arg(IUDEVICE* idev)          \\\n\t{                                                       \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                     \\\n\t\treturn pdev->_arg;                                  \\\n\t}                                                       \\\n\tstatic void udev_set_p_##_arg(IUDEVICE* idev, _type _t) \\\n\t{                                                       \\\n\t\tUDEVICE* pdev = (UDEVICE*)idev;                     \\\n\t\tpdev->_arg = _t;                                    \\\n\t}\n\n#define BASIC_STATE_FUNC_REGISTER(_arg, _dev) \\\n\t_dev->iface.get_##_arg = udev_get_##_arg; \\\n\t_dev->iface.set_##_arg = udev_set_##_arg\n\n#if LIBUSB_API_VERSION >= 0x01000103\n#define HAVE_STREAM_ID_API 1\n#endif\n\ntypedef struct _ASYNC_TRANSFER_USER_DATA ASYNC_TRANSFER_USER_DATA;\n\nstruct _ASYNC_TRANSFER_USER_DATA\n{\n\twStream* data;\n\tBOOL noack;\n\tUINT32 MessageId;\n\tUINT32 StartFrame;\n\tUINT32 ErrorCount;\n\tIUDEVICE* idev;\n\tUINT32 OutputBufferSize;\n\tURBDRC_CHANNEL_CALLBACK* callback;\n\tt_isoch_transfer_cb cb;\n\twArrayList* queue;\n#if !defined(HAVE_STREAM_ID_API)\n\tUINT32 streamID;\n#endif\n};\n\nstatic void request_free(void* value);\n\nstatic struct libusb_transfer* list_contains(wArrayList* list, UINT32 streamID)\n{\n\tint x, count;\n\tif (!list)\n\t\treturn NULL;\n\tcount = ArrayList_Count(list);\n\tfor (x = 0; x < count; x++)\n\t{\n\t\tstruct libusb_transfer* transfer = ArrayList_GetItem(list, x);\n\n#if defined(HAVE_STREAM_ID_API)\n\t\tconst UINT32 currentID = libusb_transfer_get_stream_id(transfer);\n#else\n\t\tconst ASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\t\tconst UINT32 currentID = user_data->streamID;\n#endif\n\t\tif (currentID == streamID)\n\t\t\treturn transfer;\n\t}\n\treturn NULL;\n}\n\nstatic UINT32 stream_id_from_buffer(struct libusb_transfer* transfer)\n{\n\tif (!transfer)\n\t\treturn 0;\n#if defined(HAVE_STREAM_ID_API)\n\treturn libusb_transfer_get_stream_id(transfer);\n#else\n\tASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tif (!user_data)\n\t\treturn 0;\n\treturn user_data->streamID;\n#endif\n}\n\nstatic void set_stream_id_for_buffer(struct libusb_transfer* transfer, UINT32 streamID)\n{\n#if defined(HAVE_STREAM_ID_API)\n\tlibusb_transfer_set_stream_id(transfer, streamID);\n#else\n\tASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tif (!user_data)\n\t\treturn;\n\tuser_data->streamID = streamID;\n#endif\n}\nstatic BOOL log_libusb_result(wLog* log, DWORD lvl, const char* fmt, int error, ...)\n{\n\tif (error < 0)\n\t{\n\t\tchar buffer[8192] = { 0 };\n\t\tva_list ap;\n\t\tva_start(ap, error);\n\t\tvsnprintf(buffer, sizeof(buffer), fmt, ap);\n\t\tva_end(ap);\n\n\t\tWLog_Print(log, lvl, \"%s: error %s[%d]\", buffer, libusb_error_name(error), error);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nconst char* usb_interface_class_to_string(uint8_t class)\n{\n\tswitch (class)\n\t{\n\t\tcase LIBUSB_CLASS_PER_INTERFACE:\n\t\t\treturn \"LIBUSB_CLASS_PER_INTERFACE\";\n\t\tcase LIBUSB_CLASS_AUDIO:\n\t\t\treturn \"LIBUSB_CLASS_AUDIO\";\n\t\tcase LIBUSB_CLASS_COMM:\n\t\t\treturn \"LIBUSB_CLASS_COMM\";\n\t\tcase LIBUSB_CLASS_HID:\n\t\t\treturn \"LIBUSB_CLASS_HID\";\n\t\tcase LIBUSB_CLASS_PHYSICAL:\n\t\t\treturn \"LIBUSB_CLASS_PHYSICAL\";\n\t\tcase LIBUSB_CLASS_PRINTER:\n\t\t\treturn \"LIBUSB_CLASS_PRINTER\";\n\t\tcase LIBUSB_CLASS_IMAGE:\n\t\t\treturn \"LIBUSB_CLASS_IMAGE\";\n\t\tcase LIBUSB_CLASS_MASS_STORAGE:\n\t\t\treturn \"LIBUSB_CLASS_MASS_STORAGE\";\n\t\tcase LIBUSB_CLASS_HUB:\n\t\t\treturn \"LIBUSB_CLASS_HUB\";\n\t\tcase LIBUSB_CLASS_DATA:\n\t\t\treturn \"LIBUSB_CLASS_DATA\";\n\t\tcase LIBUSB_CLASS_SMART_CARD:\n\t\t\treturn \"LIBUSB_CLASS_SMART_CARD\";\n\t\tcase LIBUSB_CLASS_CONTENT_SECURITY:\n\t\t\treturn \"LIBUSB_CLASS_CONTENT_SECURITY\";\n\t\tcase LIBUSB_CLASS_VIDEO:\n\t\t\treturn \"LIBUSB_CLASS_VIDEO\";\n\t\tcase LIBUSB_CLASS_PERSONAL_HEALTHCARE:\n\t\t\treturn \"LIBUSB_CLASS_PERSONAL_HEALTHCARE\";\n\t\tcase LIBUSB_CLASS_DIAGNOSTIC_DEVICE:\n\t\t\treturn \"LIBUSB_CLASS_DIAGNOSTIC_DEVICE\";\n\t\tcase LIBUSB_CLASS_WIRELESS:\n\t\t\treturn \"LIBUSB_CLASS_WIRELESS\";\n\t\tcase LIBUSB_CLASS_APPLICATION:\n\t\t\treturn \"LIBUSB_CLASS_APPLICATION\";\n\t\tcase LIBUSB_CLASS_VENDOR_SPEC:\n\t\t\treturn \"LIBUSB_CLASS_VENDOR_SPEC\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN_DEVICE_CLASS\";\n\t}\n}\n\nstatic ASYNC_TRANSFER_USER_DATA* async_transfer_user_data_new(IUDEVICE* idev, UINT32 MessageId,\n                                                              size_t offset, size_t BufferSize,\n                                                              const BYTE* data, size_t packetSize,\n                                                              BOOL NoAck, t_isoch_transfer_cb cb,\n                                                              URBDRC_CHANNEL_CALLBACK* callback)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data = calloc(1, sizeof(ASYNC_TRANSFER_USER_DATA));\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!user_data)\n\t\treturn NULL;\n\n\tuser_data->data = Stream_New(NULL, offset + BufferSize + packetSize);\n\n\tif (!user_data->data)\n\t{\n\t\tfree(user_data);\n\t\treturn NULL;\n\t}\n\n\tStream_Seek(user_data->data, offset); /* Skip header offset */\n\tif (data)\n\t\tmemcpy(Stream_Pointer(user_data->data), data, BufferSize);\n\telse\n\t\tuser_data->OutputBufferSize = BufferSize;\n\n\tuser_data->noack = NoAck;\n\tuser_data->cb = cb;\n\tuser_data->callback = callback;\n\tuser_data->idev = idev;\n\tuser_data->MessageId = MessageId;\n\n\tuser_data->queue = pdev->request_queue;\n\n\treturn user_data;\n}\n\nstatic void async_transfer_user_data_free(ASYNC_TRANSFER_USER_DATA* user_data)\n{\n\tif (user_data)\n\t{\n\t\tStream_Free(user_data->data, TRUE);\n\t\tfree(user_data);\n\t}\n}\n\nstatic void LIBUSB_CALL func_iso_callback(struct libusb_transfer* transfer)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tconst UINT32 streamID = stream_id_from_buffer(transfer);\n\twArrayList* list = user_data->queue;\n\n\tArrayList_Lock(list);\n\tswitch (transfer->status)\n\t{\n\t\tcase LIBUSB_TRANSFER_COMPLETED:\n\t\t{\n\t\t\tint i;\n\t\t\tUINT32 index = 0;\n\t\t\tBYTE* dataStart = Stream_Pointer(user_data->data);\n\t\t\tStream_SetPosition(user_data->data,\n\t\t\t                   40); /* TS_URB_ISOCH_TRANSFER_RESULT IsoPacket offset */\n\n\t\t\tfor (i = 0; i < transfer->num_iso_packets; i++)\n\t\t\t{\n\t\t\t\tconst UINT32 act_len = transfer->iso_packet_desc[i].actual_length;\n\t\t\t\tStream_Write_UINT32(user_data->data, index);\n\t\t\t\tStream_Write_UINT32(user_data->data, act_len);\n\t\t\t\tStream_Write_UINT32(user_data->data, transfer->iso_packet_desc[i].status);\n\n\t\t\t\tif (transfer->iso_packet_desc[i].status != USBD_STATUS_SUCCESS)\n\t\t\t\t\tuser_data->ErrorCount++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst unsigned char* packetBuffer =\n\t\t\t\t\t    libusb_get_iso_packet_buffer_simple(transfer, i);\n\t\t\t\t\tBYTE* data = dataStart + index;\n\n\t\t\t\t\tif (data != packetBuffer)\n\t\t\t\t\t\tmemmove(data, packetBuffer, act_len);\n\n\t\t\t\t\tindex += act_len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t/* fallthrough */\n\n\t\tcase LIBUSB_TRANSFER_CANCELLED:\n\t\tcase LIBUSB_TRANSFER_TIMED_OUT:\n\t\tcase LIBUSB_TRANSFER_ERROR:\n\t\t{\n\t\t\tconst UINT32 InterfaceId =\n\t\t\t    ((STREAM_ID_PROXY << 30) | user_data->idev->get_ReqCompletion(user_data->idev));\n\n\t\t\tif (list_contains(list, streamID))\n\t\t\t{\n\t\t\t\tif (!user_data->noack)\n\t\t\t\t{\n\t\t\t\t\tconst UINT32 RequestID = streamID & INTERFACE_ID_MASK;\n\t\t\t\t\tuser_data->cb(user_data->idev, user_data->callback, user_data->data,\n\t\t\t\t\t              InterfaceId, user_data->noack, user_data->MessageId, RequestID,\n\t\t\t\t\t              transfer->num_iso_packets, transfer->status,\n\t\t\t\t\t              user_data->StartFrame, user_data->ErrorCount,\n\t\t\t\t\t              user_data->OutputBufferSize);\n\t\t\t\t\tuser_data->data = NULL;\n\t\t\t\t}\n\t\t\t\tArrayList_Remove(list, transfer);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tArrayList_Unlock(list);\n}\n\nstatic const LIBUSB_ENDPOINT_DESCEIPTOR* func_get_ep_desc(LIBUSB_CONFIG_DESCRIPTOR* LibusbConfig,\n                                                          MSUSB_CONFIG_DESCRIPTOR* MsConfig,\n                                                          UINT32 EndpointAddress)\n{\n\tBYTE alt;\n\tUINT32 inum, pnum;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;\n\tconst LIBUSB_INTERFACE* interface;\n\tconst LIBUSB_ENDPOINT_DESCEIPTOR* endpoint;\n\tMsInterfaces = MsConfig->MsInterfaces;\n\tinterface = LibusbConfig->interface;\n\n\tfor (inum = 0; inum < MsConfig->NumInterfaces; inum++)\n\t{\n\t\talt = MsInterfaces[inum]->AlternateSetting;\n\t\tendpoint = interface[inum].altsetting[alt].endpoint;\n\n\t\tfor (pnum = 0; pnum < MsInterfaces[inum]->NumberOfPipes; pnum++)\n\t\t{\n\t\t\tif (endpoint[pnum].bEndpointAddress == EndpointAddress)\n\t\t\t{\n\t\t\t\treturn &endpoint[pnum];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void LIBUSB_CALL func_bulk_transfer_cb(struct libusb_transfer* transfer)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tuint32_t streamID;\n\twArrayList* list;\n\n\tuser_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tif (!user_data)\n\t{\n\t\tWLog_ERR(TAG, \"[%s]: Invalid transfer->user_data!\");\n\t\treturn;\n\t}\n\tlist = user_data->queue;\n\tArrayList_Lock(list);\n\tstreamID = stream_id_from_buffer(transfer);\n\n\tif (list_contains(list, streamID))\n\t{\n\t\tconst UINT32 InterfaceId =\n\t\t    ((STREAM_ID_PROXY << 30) | user_data->idev->get_ReqCompletion(user_data->idev));\n\t\tconst UINT32 RequestID = streamID & INTERFACE_ID_MASK;\n\n\t\tuser_data->cb(user_data->idev, user_data->callback, user_data->data, InterfaceId,\n\t\t              user_data->noack, user_data->MessageId, RequestID, transfer->num_iso_packets,\n\t\t              transfer->status, user_data->StartFrame, user_data->ErrorCount,\n\t\t              transfer->actual_length);\n\t\tuser_data->data = NULL;\n\t\tArrayList_Remove(list, transfer);\n\t}\n\tArrayList_Unlock(list);\n}\n\nstatic BOOL func_set_usbd_status(URBDRC_PLUGIN* urbdrc, UDEVICE* pdev, UINT32* status,\n                                 int err_result)\n{\n\tif (!urbdrc || !status)\n\t\treturn FALSE;\n\n\tswitch (err_result)\n\t{\n\t\tcase LIBUSB_SUCCESS:\n\t\t\t*status = USBD_STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_IO:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_INVALID_PARAM:\n\t\t\t*status = USBD_STATUS_INVALID_PARAMETER;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_ACCESS:\n\t\t\t*status = USBD_STATUS_NOT_ACCESSED;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NO_DEVICE:\n\t\t\t*status = USBD_STATUS_DEVICE_GONE;\n\n\t\t\tif (pdev)\n\t\t\t{\n\t\t\t\tif (!(pdev->status & URBDRC_DEVICE_NOT_FOUND))\n\t\t\t\t\tpdev->status |= URBDRC_DEVICE_NOT_FOUND;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NOT_FOUND:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_BUSY:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_TIMEOUT:\n\t\t\t*status = USBD_STATUS_TIMEOUT;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_OVERFLOW:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_PIPE:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_INTERRUPTED:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NO_MEM:\n\t\t\t*status = USBD_STATUS_NO_MEMORY;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_NOT_SUPPORTED:\n\t\t\t*status = USBD_STATUS_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase LIBUSB_ERROR_OTHER:\n\t\t\t*status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*status = USBD_STATUS_SUCCESS;\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int func_config_release_all_interface(URBDRC_PLUGIN* urbdrc,\n                                             LIBUSB_DEVICE_HANDLE* libusb_handle,\n                                             UINT32 NumInterfaces)\n{\n\tUINT32 i;\n\n\tfor (i = 0; i < NumInterfaces; i++)\n\t{\n\t\tint ret = libusb_release_interface(libusb_handle, i);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_WARN, \"libusb_release_interface\", ret))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int func_claim_all_interface(URBDRC_PLUGIN* urbdrc, LIBUSB_DEVICE_HANDLE* libusb_handle,\n                                    int NumInterfaces)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < NumInterfaces; i++)\n\t{\n\t\tret = libusb_claim_interface(libusb_handle, i);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_claim_interface\", ret))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic LIBUSB_DEVICE* udev_get_libusb_dev(libusb_context* context, uint8_t bus_number,\n                                          uint8_t dev_number)\n{\n\tssize_t i, total_device;\n\tLIBUSB_DEVICE** libusb_list;\n\tLIBUSB_DEVICE* device = NULL;\n\ttotal_device = libusb_get_device_list(context, &libusb_list);\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\t\tif ((bus_number == libusb_get_bus_number(dev)) &&\n\t\t    (dev_number == libusb_get_device_address(dev)))\n\t\t{\n\t\t\tdevice = dev;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibusb_unref_device(dev);\n\t\t}\n\t}\n\n\tlibusb_free_device_list(libusb_list, 0);\n\treturn device;\n}\n\nstatic LIBUSB_DEVICE_DESCRIPTOR* udev_new_descript(URBDRC_PLUGIN* urbdrc, LIBUSB_DEVICE* libusb_dev)\n{\n\tint ret;\n\tLIBUSB_DEVICE_DESCRIPTOR* descriptor =\n\t    (LIBUSB_DEVICE_DESCRIPTOR*)calloc(1, sizeof(LIBUSB_DEVICE_DESCRIPTOR));\n\tif (!descriptor)\n\t\treturn NULL;\n\tret = libusb_get_device_descriptor(libusb_dev, descriptor);\n\n\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_get_device_descriptor\", ret))\n\t{\n\t\tfree(descriptor);\n\t\treturn NULL;\n\t}\n\n\treturn descriptor;\n}\n\nstatic int libusb_udev_select_interface(IUDEVICE* idev, BYTE InterfaceNumber, BYTE AlternateSetting)\n{\n\tint error = 0, diff = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tURBDRC_PLUGIN* urbdrc;\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tMsConfig = pdev->MsConfig;\n\n\tif (MsConfig)\n\t{\n\t\tMsInterfaces = MsConfig->MsInterfaces;\n\t\tif (MsInterfaces)\n\t\t{\n\t\t\tWLog_Print(urbdrc->log, WLOG_INFO,\n\t\t\t           \"select Interface(%\" PRIu8 \") curr AlternateSetting(%\" PRIu8\n\t\t\t           \") new AlternateSetting(\" PRIu8 \")\",\n\t\t\t           InterfaceNumber, MsInterfaces[InterfaceNumber]->AlternateSetting,\n\t\t\t           AlternateSetting);\n\n\t\t\tif (MsInterfaces[InterfaceNumber]->AlternateSetting != AlternateSetting)\n\t\t\t{\n\t\t\t\tdiff = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (diff)\n\t\t{\n\t\t\terror = libusb_set_interface_alt_setting(pdev->libusb_handle, InterfaceNumber,\n\t\t\t                                         AlternateSetting);\n\n\t\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_set_interface_alt_setting\", error);\n\t\t}\n\t}\n\n\treturn error;\n}\n\nstatic MSUSB_CONFIG_DESCRIPTOR*\nlibusb_udev_complete_msconfig_setup(IUDEVICE* idev, MSUSB_CONFIG_DESCRIPTOR* MsConfig)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces;\n\tMSUSB_INTERFACE_DESCRIPTOR* MsInterface;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\tMSUSB_PIPE_DESCRIPTOR* MsPipe;\n\tMSUSB_PIPE_DESCRIPTOR** t_MsPipes;\n\tMSUSB_PIPE_DESCRIPTOR* t_MsPipe;\n\tLIBUSB_CONFIG_DESCRIPTOR* LibusbConfig;\n\tconst LIBUSB_INTERFACE* LibusbInterface;\n\tconst LIBUSB_INTERFACE_DESCRIPTOR* LibusbAltsetting;\n\tconst LIBUSB_ENDPOINT_DESCEIPTOR* LibusbEndpoint;\n\tBYTE LibusbNumEndpoint;\n\tURBDRC_PLUGIN* urbdrc;\n\tUINT32 inum = 0, pnum = 0, MsOutSize = 0;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->urbdrc || !MsConfig)\n\t\treturn NULL;\n\n\turbdrc = pdev->urbdrc;\n\tLibusbConfig = pdev->LibusbConfig;\n\n\tif (LibusbConfig->bNumInterfaces != MsConfig->NumInterfaces)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t           \"Select Configuration: Libusb NumberInterfaces(%\" PRIu8 \") is different \"\n\t\t           \"with MsConfig NumberInterfaces(%\" PRIu32 \")\",\n\t\t           LibusbConfig->bNumInterfaces, MsConfig->NumInterfaces);\n\t}\n\n\t/* replace MsPipes for libusb */\n\tMsInterfaces = MsConfig->MsInterfaces;\n\n\tfor (inum = 0; inum < MsConfig->NumInterfaces; inum++)\n\t{\n\t\tMsInterface = MsInterfaces[inum];\n\t\t/* get libusb's number of endpoints */\n\t\tLibusbInterface = &LibusbConfig->interface[MsInterface->InterfaceNumber];\n\t\tLibusbAltsetting = &LibusbInterface->altsetting[MsInterface->AlternateSetting];\n\t\tLibusbNumEndpoint = LibusbAltsetting->bNumEndpoints;\n\t\tt_MsPipes =\n\t\t    (MSUSB_PIPE_DESCRIPTOR**)calloc(LibusbNumEndpoint, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\n\t\tfor (pnum = 0; pnum < LibusbNumEndpoint; pnum++)\n\t\t{\n\t\t\tt_MsPipe = (MSUSB_PIPE_DESCRIPTOR*)calloc(1, sizeof(MSUSB_PIPE_DESCRIPTOR));\n\n\t\t\tif (pnum < MsInterface->NumberOfPipes && MsInterface->MsPipes)\n\t\t\t{\n\t\t\t\tMsPipe = MsInterface->MsPipes[pnum];\n\t\t\t\tt_MsPipe->MaximumPacketSize = MsPipe->MaximumPacketSize;\n\t\t\t\tt_MsPipe->MaximumTransferSize = MsPipe->MaximumTransferSize;\n\t\t\t\tt_MsPipe->PipeFlags = MsPipe->PipeFlags;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt_MsPipe->MaximumPacketSize = 0;\n\t\t\t\tt_MsPipe->MaximumTransferSize = 0xffffffff;\n\t\t\t\tt_MsPipe->PipeFlags = 0;\n\t\t\t}\n\n\t\t\tt_MsPipe->PipeHandle = 0;\n\t\t\tt_MsPipe->bEndpointAddress = 0;\n\t\t\tt_MsPipe->bInterval = 0;\n\t\t\tt_MsPipe->PipeType = 0;\n\t\t\tt_MsPipe->InitCompleted = 0;\n\t\t\tt_MsPipes[pnum] = t_MsPipe;\n\t\t}\n\n\t\tmsusb_mspipes_replace(MsInterface, t_MsPipes, LibusbNumEndpoint);\n\t}\n\n\t/* setup configuration */\n\tMsOutSize = 8;\n\t/* ConfigurationHandle:  4 bytes\n\t * ---------------------------------------------------------------\n\t * ||<<< 1 byte >>>|<<< 1 byte >>>|<<<<<<<<<< 2 byte >>>>>>>>>>>||\n\t * ||  bus_number  |  dev_number  |      bConfigurationValue    ||\n\t * ---------------------------------------------------------------\n\t * ***********************/\n\tMsConfig->ConfigurationHandle =\n\t    MsConfig->bConfigurationValue | (pdev->bus_number << 24) | (pdev->dev_number << 16);\n\tMsInterfaces = MsConfig->MsInterfaces;\n\n\tfor (inum = 0; inum < MsConfig->NumInterfaces; inum++)\n\t{\n\t\tMsOutSize += 16;\n\t\tMsInterface = MsInterfaces[inum];\n\t\t/* get libusb's interface */\n\t\tLibusbInterface = &LibusbConfig->interface[MsInterface->InterfaceNumber];\n\t\tLibusbAltsetting = &LibusbInterface->altsetting[MsInterface->AlternateSetting];\n\t\t/* InterfaceHandle:  4 bytes\n\t\t * ---------------------------------------------------------------\n\t\t * ||<<< 1 byte >>>|<<< 1 byte >>>|<<< 1 byte >>>|<<< 1 byte >>>||\n\t\t * ||  bus_number  |  dev_number  |  altsetting  | interfaceNum ||\n\t\t * ---------------------------------------------------------------\n\t\t * ***********************/\n\t\tMsInterface->InterfaceHandle = LibusbAltsetting->bInterfaceNumber |\n\t\t                               (LibusbAltsetting->bAlternateSetting << 8) |\n\t\t                               (pdev->dev_number << 16) | (pdev->bus_number << 24);\n\t\tMsInterface->Length = 16 + (MsInterface->NumberOfPipes * 20);\n\t\tMsInterface->bInterfaceClass = LibusbAltsetting->bInterfaceClass;\n\t\tMsInterface->bInterfaceSubClass = LibusbAltsetting->bInterfaceSubClass;\n\t\tMsInterface->bInterfaceProtocol = LibusbAltsetting->bInterfaceProtocol;\n\t\tMsInterface->InitCompleted = 1;\n\t\tMsPipes = MsInterface->MsPipes;\n\t\tLibusbNumEndpoint = LibusbAltsetting->bNumEndpoints;\n\n\t\tfor (pnum = 0; pnum < LibusbNumEndpoint; pnum++)\n\t\t{\n\t\t\tMsOutSize += 20;\n\t\t\tMsPipe = MsPipes[pnum];\n\t\t\t/* get libusb's endpoint */\n\t\t\tLibusbEndpoint = &LibusbAltsetting->endpoint[pnum];\n\t\t\t/* PipeHandle:  4 bytes\n\t\t\t * ---------------------------------------------------------------\n\t\t\t * ||<<< 1 byte >>>|<<< 1 byte >>>|<<<<<<<<<< 2 byte >>>>>>>>>>>||\n\t\t\t * ||  bus_number  |  dev_number  |      bEndpointAddress       ||\n\t\t\t * ---------------------------------------------------------------\n\t\t\t * ***********************/\n\t\t\tMsPipe->PipeHandle = LibusbEndpoint->bEndpointAddress | (pdev->dev_number << 16) |\n\t\t\t                     (pdev->bus_number << 24);\n\t\t\t/* count endpoint max packet size */\n\t\t\tint max = LibusbEndpoint->wMaxPacketSize & 0x07ff;\n\t\t\tBYTE attr = LibusbEndpoint->bmAttributes;\n\n\t\t\tif ((attr & 0x3) == 1 || (attr & 0x3) == 3)\n\t\t\t{\n\t\t\t\tmax *= (1 + ((LibusbEndpoint->wMaxPacketSize >> 11) & 3));\n\t\t\t}\n\n\t\t\tMsPipe->MaximumPacketSize = max;\n\t\t\tMsPipe->bEndpointAddress = LibusbEndpoint->bEndpointAddress;\n\t\t\tMsPipe->bInterval = LibusbEndpoint->bInterval;\n\t\t\tMsPipe->PipeType = attr & 0x3;\n\t\t\tMsPipe->InitCompleted = 1;\n\t\t}\n\t}\n\n\tMsConfig->MsOutSize = MsOutSize;\n\tMsConfig->InitCompleted = 1;\n\n\t/* replace device's MsConfig */\n\tif (MsConfig != pdev->MsConfig)\n\t{\n\t\tmsusb_msconfig_free(pdev->MsConfig);\n\t\tpdev->MsConfig = MsConfig;\n\t}\n\n\treturn MsConfig;\n}\n\nstatic int libusb_udev_select_configuration(IUDEVICE* idev, UINT32 bConfigurationValue)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig;\n\tLIBUSB_DEVICE_HANDLE* libusb_handle;\n\tLIBUSB_DEVICE* libusb_dev;\n\tURBDRC_PLUGIN* urbdrc;\n\tLIBUSB_CONFIG_DESCRIPTOR** LibusbConfig;\n\tint ret = 0;\n\n\tif (!pdev || !pdev->MsConfig || !pdev->LibusbConfig || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tMsConfig = pdev->MsConfig;\n\tlibusb_handle = pdev->libusb_handle;\n\tlibusb_dev = pdev->libusb_dev;\n\tLibusbConfig = &pdev->LibusbConfig;\n\n\tif (MsConfig->InitCompleted)\n\t{\n\t\tfunc_config_release_all_interface(pdev->urbdrc, libusb_handle,\n\t\t                                  (*LibusbConfig)->bNumInterfaces);\n\t}\n\n\t/* The configuration value -1 is mean to put the device in unconfigured state. */\n\tif (bConfigurationValue == 0)\n\t\tret = libusb_set_configuration(libusb_handle, -1);\n\telse\n\t\tret = libusb_set_configuration(libusb_handle, bConfigurationValue);\n\n\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_set_configuration\", ret))\n\t{\n\t\tfunc_claim_all_interface(urbdrc, libusb_handle, (*LibusbConfig)->bNumInterfaces);\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tret = libusb_get_active_config_descriptor(libusb_dev, LibusbConfig);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_set_configuration\", ret))\n\t\t{\n\t\t\tfunc_claim_all_interface(urbdrc, libusb_handle, (*LibusbConfig)->bNumInterfaces);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfunc_claim_all_interface(urbdrc, libusb_handle, (*LibusbConfig)->bNumInterfaces);\n\treturn 0;\n}\n\nstatic int libusb_udev_control_pipe_request(IUDEVICE* idev, UINT32 RequestId,\n                                            UINT32 EndpointAddress, UINT32* UsbdStatus, int command)\n{\n\tint error = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\t/*\n\tpdev->request_queue->register_request(pdev->request_queue, RequestId, NULL, 0);\n\t*/\n\tswitch (command)\n\t{\n\t\tcase PIPE_CANCEL:\n\t\t\t/** cancel bulk or int transfer */\n\t\t\tidev->cancel_all_transfer_request(idev);\n\t\t\t// dummy_wait_s_obj(1);\n\t\t\t/** set feature to ep (set halt)*/\n\t\t\terror = libusb_control_transfer(\n\t\t\t    pdev->libusb_handle, LIBUSB_ENDPOINT_OUT | LIBUSB_RECIPIENT_ENDPOINT,\n\t\t\t    LIBUSB_REQUEST_SET_FEATURE, ENDPOINT_HALT, EndpointAddress, NULL, 0, 1000);\n\t\t\tbreak;\n\n\t\tcase PIPE_RESET:\n\t\t\tidev->cancel_all_transfer_request(idev);\n\t\t\terror = libusb_clear_halt(pdev->libusb_handle, EndpointAddress);\n\t\t\t// func_set_usbd_status(pdev, UsbdStatus, error);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror = -0xff;\n\t\t\tbreak;\n\t}\n\n\t*UsbdStatus = 0;\n\treturn error;\n}\n\nstatic UINT32 libusb_udev_control_query_device_text(IUDEVICE* idev, UINT32 TextType,\n                                                    UINT16 LocaleId, UINT8* BufferSize,\n                                                    BYTE* Buffer)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tLIBUSB_DEVICE_DESCRIPTOR* devDescriptor;\n\tconst char strDesc[] = \"Generic Usb String\";\n\tchar deviceLocation[25] = { 0 };\n\tBYTE bus_number;\n\tBYTE device_address;\n\tint ret = 0;\n\tsize_t i, len;\n\tURBDRC_PLUGIN* urbdrc;\n\tWCHAR* text = (WCHAR*)Buffer;\n\tBYTE slen, locale;\n\tconst UINT8 inSize = *BufferSize;\n\n\t*BufferSize = 0;\n\tif (!pdev || !pdev->devDescriptor || !pdev->urbdrc)\n\t\treturn ERROR_INVALID_DATA;\n\n\turbdrc = pdev->urbdrc;\n\tdevDescriptor = pdev->devDescriptor;\n\n\tswitch (TextType)\n\t{\n\t\tcase DeviceTextDescription:\n\t\t{\n\t\t\tBYTE data[0x100] = { 0 };\n\t\t\tret = libusb_get_string_descriptor(pdev->libusb_handle, devDescriptor->iProduct,\n\t\t\t                                   LocaleId, data, 0xFF);\n\t\t\t/* The returned data in the buffer is:\n\t\t\t * 1 byte  length of following data\n\t\t\t * 1 byte  descriptor type, must be 0x03 for strings\n\t\t\t * n WCHAR unicode string (of length / 2 characters) including '\\0'\n\t\t\t */\n\t\t\tslen = data[0];\n\t\t\tlocale = data[1];\n\n\t\t\tif ((ret <= 0) || (ret <= 4) || (slen <= 4) || (locale != LIBUSB_DT_STRING) ||\n\t\t\t    (ret > UINT8_MAX))\n\t\t\t{\n\t\t\t\tconst char* msg = \"SHORT_DESCRIPTOR\";\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tmsg = libusb_error_name(ret);\n\t\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t\t           \"libusb_get_string_descriptor: \"\n\t\t\t\t           \"%s [%d], iProduct: %\" PRIu8 \"!\",\n\t\t\t\t           msg, ret, devDescriptor->iProduct);\n\n\t\t\t\tlen = MIN(sizeof(strDesc), inSize);\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t\ttext[i] = (WCHAR)strDesc[i];\n\n\t\t\t\t*BufferSize = (BYTE)(len * 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* ret and slen should be equals, but you never know creativity\n\t\t\t\t * of device manufacturers...\n\t\t\t\t * So also check the string length returned as server side does\n\t\t\t\t * not honor strings with multi '\\0' characters well.\n\t\t\t\t */\n\t\t\t\tconst size_t rchar = _wcsnlen((WCHAR*)&data[2], sizeof(data) / 2);\n\t\t\t\tlen = MIN((BYTE)ret, slen);\n\t\t\t\tlen = MIN(len, inSize);\n\t\t\t\tlen = MIN(len, rchar * 2 + sizeof(WCHAR));\n\t\t\t\tmemcpy(Buffer, &data[2], len);\n\n\t\t\t\t/* Just as above, the returned WCHAR string should be '\\0'\n\t\t\t\t * terminated, but never trust hardware to conform to specs... */\n\t\t\t\tBuffer[len - 2] = '\\0';\n\t\t\t\tBuffer[len - 1] = '\\0';\n\t\t\t\t*BufferSize = (BYTE)len;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase DeviceTextLocationInformation:\n\t\t\tbus_number = libusb_get_bus_number(pdev->libusb_dev);\n\t\t\tdevice_address = libusb_get_device_address(pdev->libusb_dev);\n\t\t\tsprintf_s(deviceLocation, sizeof(deviceLocation),\n\t\t\t          \"Port_#%04\" PRIu8 \".Hub_#%04\" PRIu8 \"\", device_address, bus_number);\n\n\t\t\tlen = strnlen(deviceLocation,\n\t\t\t              MIN(sizeof(deviceLocation), (inSize > 0) ? inSize - 1U : 0));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\ttext[i] = (WCHAR)deviceLocation[i];\n\t\t\ttext[len++] = '\\0';\n\t\t\t*BufferSize = (UINT8)(len * sizeof(WCHAR));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"Query Text: unknown TextType %\" PRIu32 \"\",\n\t\t\t           TextType);\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\treturn S_OK;\n}\n\nstatic int libusb_udev_os_feature_descriptor_request(IUDEVICE* idev, UINT32 RequestId,\n                                                     BYTE Recipient, BYTE InterfaceNumber,\n                                                     BYTE Ms_PageIndex, UINT16 Ms_featureDescIndex,\n                                                     UINT32* UsbdStatus, UINT32* BufferSize,\n                                                     BYTE* Buffer, int Timeout)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tBYTE ms_string_desc[0x13] = { 0 };\n\tint error = 0;\n\t/*\n\tpdev->request_queue->register_request(pdev->request_queue, RequestId, NULL, 0);\n\t*/\n\terror = libusb_control_transfer(pdev->libusb_handle, LIBUSB_ENDPOINT_IN | Recipient,\n\t                                LIBUSB_REQUEST_GET_DESCRIPTOR, 0x03ee, 0, ms_string_desc, 0x12,\n\t                                Timeout);\n\n\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_control_transfer\", error);\n\n\tif (error > 0)\n\t{\n\t\tconst BYTE bMS_Vendorcode = ms_string_desc[16];\n\t\t/** get os descriptor */\n\t\terror = libusb_control_transfer(pdev->libusb_handle,\n\t\t                                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | Recipient,\n\t\t                                bMS_Vendorcode, (InterfaceNumber << 8) | Ms_PageIndex,\n\t\t                                Ms_featureDescIndex, Buffer, *BufferSize, Timeout);\n\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_control_transfer\", error);\n\n\t\tif (error >= 0)\n\t\t\t*BufferSize = error;\n\t}\n\n\tif (error < 0)\n\t\t*UsbdStatus = USBD_STATUS_STALL_PID;\n\telse\n\t\t*UsbdStatus = USBD_STATUS_SUCCESS;\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic int libusb_udev_query_device_descriptor(IUDEVICE* idev, int offset)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tswitch (offset)\n\t{\n\t\tcase B_LENGTH:\n\t\t\treturn pdev->devDescriptor->bLength;\n\n\t\tcase B_DESCRIPTOR_TYPE:\n\t\t\treturn pdev->devDescriptor->bDescriptorType;\n\n\t\tcase BCD_USB:\n\t\t\treturn pdev->devDescriptor->bcdUSB;\n\n\t\tcase B_DEVICE_CLASS:\n\t\t\treturn pdev->devDescriptor->bDeviceClass;\n\n\t\tcase B_DEVICE_SUBCLASS:\n\t\t\treturn pdev->devDescriptor->bDeviceSubClass;\n\n\t\tcase B_DEVICE_PROTOCOL:\n\t\t\treturn pdev->devDescriptor->bDeviceProtocol;\n\n\t\tcase B_MAX_PACKET_SIZE0:\n\t\t\treturn pdev->devDescriptor->bMaxPacketSize0;\n\n\t\tcase ID_VENDOR:\n\t\t\treturn pdev->devDescriptor->idVendor;\n\n\t\tcase ID_PRODUCT:\n\t\t\treturn pdev->devDescriptor->idProduct;\n\n\t\tcase BCD_DEVICE:\n\t\t\treturn pdev->devDescriptor->bcdDevice;\n\n\t\tcase I_MANUFACTURER:\n\t\t\treturn pdev->devDescriptor->iManufacturer;\n\n\t\tcase I_PRODUCT:\n\t\t\treturn pdev->devDescriptor->iProduct;\n\n\t\tcase I_SERIAL_NUMBER:\n\t\t\treturn pdev->devDescriptor->iSerialNumber;\n\n\t\tcase B_NUM_CONFIGURATIONS:\n\t\t\treturn pdev->devDescriptor->bNumConfigurations;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic BOOL libusb_udev_detach_kernel_driver(IUDEVICE* idev)\n{\n\tint i, err = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->libusb_handle || !pdev->urbdrc)\n\t\treturn FALSE;\n\n#ifdef _WIN32\n\treturn TRUE;\n#else\n\turbdrc = pdev->urbdrc;\n\n\tif ((pdev->status & URBDRC_DEVICE_DETACH_KERNEL) == 0)\n\t{\n\t\tfor (i = 0; i < pdev->LibusbConfig->bNumInterfaces; i++)\n\t\t{\n\t\t\terr = libusb_kernel_driver_active(pdev->libusb_handle, i);\n\t\t\tlog_libusb_result(urbdrc->log, WLOG_DEBUG, \"libusb_kernel_driver_active\", err);\n\n\t\t\tif (err)\n\t\t\t{\n\t\t\t\terr = libusb_detach_kernel_driver(pdev->libusb_handle, i);\n\t\t\t\tlog_libusb_result(urbdrc->log, WLOG_DEBUG, \"libusb_detach_kernel_driver\", err);\n\t\t\t}\n\t\t}\n\n\t\tpdev->status |= URBDRC_DEVICE_DETACH_KERNEL;\n\t}\n\n\treturn TRUE;\n#endif\n}\n\nstatic BOOL libusb_udev_attach_kernel_driver(IUDEVICE* idev)\n{\n\tint i, err = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->libusb_handle || !pdev->urbdrc)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < pdev->LibusbConfig->bNumInterfaces && err != LIBUSB_ERROR_NO_DEVICE; i++)\n\t{\n\t\terr = libusb_release_interface(pdev->libusb_handle, i);\n\n\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_release_interface\", err);\n\n#ifndef _WIN32\n\t\tif (err != LIBUSB_ERROR_NO_DEVICE)\n\t\t{\n\t\t\terr = libusb_attach_kernel_driver(pdev->libusb_handle, i);\n\t\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_DEBUG, \"libusb_attach_kernel_driver if=%d\",\n\t\t\t                  err, i);\n\t\t}\n#endif\n\t}\n\n\treturn TRUE;\n}\n\nstatic int libusb_udev_is_composite_device(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn pdev->isCompositeDevice;\n}\n\nstatic int libusb_udev_is_exist(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn (pdev->status & URBDRC_DEVICE_NOT_FOUND) ? 0 : 1;\n}\n\nstatic int libusb_udev_is_channel_closed(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tIUDEVMAN* udevman;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn 1;\n\n\tudevman = pdev->urbdrc->udevman;\n\tif (udevman)\n\t{\n\t\tif (udevman->status & URBDRC_DEVICE_CHANNEL_CLOSED)\n\t\t\treturn 1;\n\t}\n\n\tif (pdev->status & URBDRC_DEVICE_CHANNEL_CLOSED)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int libusb_udev_is_already_send(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn (pdev->status & URBDRC_DEVICE_ALREADY_SEND) ? 1 : 0;\n}\n\n/* This is called from channel cleanup code.\n * Avoid double free, just remove the device and mark the channel closed. */\nstatic void libusb_udev_mark_channel_closed(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tif (pdev && ((pdev->status & URBDRC_DEVICE_CHANNEL_CLOSED) == 0))\n\t{\n\t\tURBDRC_PLUGIN* urbdrc = pdev->urbdrc;\n\t\tconst uint8_t busNr = idev->get_bus_number(idev);\n\t\tconst uint8_t devNr = idev->get_dev_number(idev);\n\n\t\tpdev->status |= URBDRC_DEVICE_CHANNEL_CLOSED;\n\t\turbdrc->udevman->unregister_udevice(urbdrc->udevman, busNr, devNr);\n\t}\n}\n\n/* This is called by local events where the device is removed or in an error\n * state. Remove the device from redirection and close the channel. */\nstatic void libusb_udev_channel_closed(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tif (pdev && ((pdev->status & URBDRC_DEVICE_CHANNEL_CLOSED) == 0))\n\t{\n\t\tURBDRC_PLUGIN* urbdrc = pdev->urbdrc;\n\t\tconst uint8_t busNr = idev->get_bus_number(idev);\n\t\tconst uint8_t devNr = idev->get_dev_number(idev);\n\t\tIWTSVirtualChannel* channel = NULL;\n\n\t\tif (pdev->channelManager)\n\t\t\tchannel = IFCALLRESULT(NULL, pdev->channelManager->FindChannelById,\n\t\t\t                       pdev->channelManager, pdev->channelID);\n\n\t\tpdev->status |= URBDRC_DEVICE_CHANNEL_CLOSED;\n\n\t\tif (channel)\n\t\t\tchannel->Write(channel, 0, NULL, NULL);\n\n\t\turbdrc->udevman->unregister_udevice(urbdrc->udevman, busNr, devNr);\n\t}\n}\n\nstatic void libusb_udev_set_already_send(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tpdev->status |= URBDRC_DEVICE_ALREADY_SEND;\n}\n\nstatic char* libusb_udev_get_path(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\treturn pdev->path;\n}\n\nstatic int libusb_udev_query_device_port_status(IUDEVICE* idev, UINT32* UsbdStatus,\n                                                UINT32* BufferSize, BYTE* Buffer)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tint success = 0, ret;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\n\tif (pdev->hub_handle != NULL)\n\t{\n\t\tret = idev->control_transfer(\n\t\t    idev, 0xffff, 0, 0,\n\t\t    LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_OTHER,\n\t\t    LIBUSB_REQUEST_GET_STATUS, 0, pdev->port_number, UsbdStatus, BufferSize, Buffer, 1000);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_DEBUG, \"libusb_control_transfer\", ret))\n\t\t\t*BufferSize = 0;\n\t\telse\n\t\t{\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"PORT STATUS:0x%02\" PRIx8 \"%02\" PRIx8 \"%02\" PRIx8 \"%02\" PRIx8 \"\", Buffer[3],\n\t\t\t           Buffer[2], Buffer[1], Buffer[0]);\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\treturn success;\n}\n\nstatic int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\n\tif (!user_data)\n\t\treturn -1;\n\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\n\tif (NumberOfPackets > 0)\n\t{\n\t\tiso_packet_size = BufferSize / NumberOfPackets;\n\t\tiso_transfer = libusb_alloc_transfer((int)NumberOfPackets);\n\t}\n\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t           \"Error: libusb_alloc_transfer [NumberOfPackets=%\" PRIu32 \", BufferSize=%\" PRIu32\n\t\t           \" ]\",\n\t\t           NumberOfPackets, BufferSize);\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\n\t/**  process URB_FUNCTION_IOSCH_TRANSFER */\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}\n\nstatic BOOL libusb_udev_control_transfer(IUDEVICE* idev, UINT32 RequestId, UINT32 EndpointAddress,\n                                         UINT32 TransferFlags, BYTE bmRequestType, BYTE Request,\n                                         UINT16 Value, UINT16 Index, UINT32* UrbdStatus,\n                                         UINT32* BufferSize, BYTE* Buffer, UINT32 Timeout)\n{\n\tint status = 0;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn FALSE;\n\n\tstatus = libusb_control_transfer(pdev->libusb_handle, bmRequestType, Request, Value, Index,\n\t                                 Buffer, *BufferSize, Timeout);\n\n\tif (status >= 0)\n\t\t*BufferSize = (UINT32)status;\n\telse\n\t\tlog_libusb_result(pdev->urbdrc->log, WLOG_ERROR, \"libusb_control_transfer\", status);\n\n\tif (!func_set_usbd_status(pdev->urbdrc, pdev, UrbdStatus, status))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic int libusb_udev_bulk_or_interrupt_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                                  UINT32 MessageId, UINT32 RequestId,\n                                                  UINT32 EndpointAddress, UINT32 TransferFlags,\n                                                  BOOL NoAck, UINT32 BufferSize, const BYTE* data,\n                                                  t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 transfer_type;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tconst LIBUSB_ENDPOINT_DESCEIPTOR* ep_desc;\n\tstruct libusb_transfer* transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tuint32_t streamID = 0x80000000 | RequestId;\n\n\tif (!pdev || !pdev->LibusbConfig || !pdev->urbdrc)\n\t\treturn -1;\n\n\turbdrc = pdev->urbdrc;\n\tuser_data =\n\t    async_transfer_user_data_new(idev, MessageId, 36, BufferSize, data, 0, NoAck, cb, callback);\n\n\tif (!user_data)\n\t\treturn -1;\n\n\t/* alloc memory for urb transfer */\n\ttransfer = libusb_alloc_transfer(0);\n\tif (!transfer)\n\t{\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\n\tep_desc = func_get_ep_desc(pdev->LibusbConfig, pdev->MsConfig, EndpointAddress);\n\n\tif (!ep_desc)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"func_get_ep_desc: endpoint 0x%\" PRIx32 \" not found\",\n\t\t           EndpointAddress);\n\t\trequest_free(transfer);\n\t\treturn -1;\n\t}\n\n\ttransfer_type = (ep_desc->bmAttributes) & 0x3;\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"urb_bulk_or_interrupt_transfer: ep:0x%\" PRIx32 \" \"\n\t           \"transfer_type %\" PRIu32 \" flag:%\" PRIu32 \" OutputBufferSize:0x%\" PRIx32 \"\",\n\t           EndpointAddress, transfer_type, TransferFlags, BufferSize);\n\n\tswitch (transfer_type)\n\t{\n\t\tcase BULK_TRANSFER:\n\t\t\t/** Bulk Transfer */\n\t\t\tlibusb_fill_bulk_transfer(transfer, pdev->libusb_handle, EndpointAddress,\n\t\t\t                          Stream_Pointer(user_data->data), BufferSize,\n\t\t\t                          func_bulk_transfer_cb, user_data, Timeout);\n\t\t\tbreak;\n\n\t\tcase INTERRUPT_TRANSFER:\n\t\t\t/**  Interrupt Transfer */\n\t\t\tlibusb_fill_interrupt_transfer(transfer, pdev->libusb_handle, EndpointAddress,\n\t\t\t                               Stream_Pointer(user_data->data), BufferSize,\n\t\t\t                               func_bulk_transfer_cb, user_data, Timeout);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"urb_bulk_or_interrupt_transfer:\"\n\t\t\t           \" other transfer type 0x%\" PRIX32 \"\",\n\t\t\t           transfer_type);\n\t\t\trequest_free(transfer);\n\t\t\treturn -1;\n\t}\n\n\tset_stream_id_for_buffer(transfer, streamID);\n\n\tif (ArrayList_Add(pdev->request_queue, transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue transfer, streamID %08\" PRIx32 \" already in use!\", streamID);\n\t\trequest_free(transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(transfer);\n}\n\nstatic int func_cancel_xact_request(URBDRC_PLUGIN* urbdrc, struct libusb_transfer* transfer)\n{\n\tint status;\n\n\tif (!urbdrc || !transfer)\n\t\treturn -1;\n\n\tstatus = libusb_cancel_transfer(transfer);\n\n\tif (log_libusb_result(urbdrc->log, WLOG_WARN, \"libusb_cancel_transfer\", status))\n\t{\n\t\tif (status == LIBUSB_ERROR_NOT_FOUND)\n\t\t\treturn -1;\n\t}\n\telse\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void libusb_udev_cancel_all_transfer_request(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tint count, x;\n\n\tif (!pdev || !pdev->request_queue || !pdev->urbdrc)\n\t\treturn;\n\n\tArrayList_Lock(pdev->request_queue);\n\tcount = ArrayList_Count(pdev->request_queue);\n\n\tfor (x = 0; x < count; x++)\n\t{\n\t\tstruct libusb_transfer* transfer = ArrayList_GetItem(pdev->request_queue, x);\n\t\tfunc_cancel_xact_request(pdev->urbdrc, transfer);\n\t}\n\n\tArrayList_Unlock(pdev->request_queue);\n}\n\nstatic int libusb_udev_cancel_transfer_request(IUDEVICE* idev, UINT32 RequestId)\n{\n\tint rc = -1;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tstruct libusb_transfer* transfer;\n\tuint32_t cancelID1 = 0x40000000 | RequestId;\n\tuint32_t cancelID2 = 0x80000000 | RequestId;\n\n\tif (!idev || !pdev->urbdrc || !pdev->request_queue)\n\t\treturn -1;\n\n\tArrayList_Lock(pdev->request_queue);\n\ttransfer = list_contains(pdev->request_queue, cancelID1);\n\tif (!transfer)\n\t\ttransfer = list_contains(pdev->request_queue, cancelID2);\n\n\tif (transfer)\n\t{\n\t\tURBDRC_PLUGIN* urbdrc = (URBDRC_PLUGIN*)pdev->urbdrc;\n\n\t\trc = func_cancel_xact_request(urbdrc, transfer);\n\t}\n\tArrayList_Unlock(pdev->request_queue);\n\treturn rc;\n}\n\nBASIC_STATE_FUNC_DEFINED(channelManager, IWTSVirtualChannelManager*)\nBASIC_STATE_FUNC_DEFINED(channelID, UINT32)\nBASIC_STATE_FUNC_DEFINED(ReqCompletion, UINT32)\nBASIC_STATE_FUNC_DEFINED(bus_number, BYTE)\nBASIC_STATE_FUNC_DEFINED(dev_number, BYTE)\nBASIC_STATE_FUNC_DEFINED(port_number, int)\nBASIC_STATE_FUNC_DEFINED(MsConfig, MSUSB_CONFIG_DESCRIPTOR*)\n\nBASIC_POINT_FUNC_DEFINED(udev, void*)\nBASIC_POINT_FUNC_DEFINED(prev, void*)\nBASIC_POINT_FUNC_DEFINED(next, void*)\n\nstatic UINT32 udev_get_UsbDevice(IUDEVICE* idev)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev)\n\t\treturn 0;\n\n\treturn pdev->UsbDevice;\n}\n\nstatic void udev_set_UsbDevice(IUDEVICE* idev, UINT32 val)\n{\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\n\tif (!pdev)\n\t\treturn;\n\n\tpdev->UsbDevice = val;\n}\n\nstatic void udev_free(IUDEVICE* idev)\n{\n\tint rc;\n\tUDEVICE* udev = (UDEVICE*)idev;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!idev || !udev->urbdrc)\n\t\treturn;\n\n\turbdrc = udev->urbdrc;\n\n\tlibusb_udev_cancel_all_transfer_request(&udev->iface);\n\tif (udev->libusb_handle)\n\t{\n\t\trc = libusb_reset_device(udev->libusb_handle);\n\n\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_reset_device\", rc);\n\t}\n\n\t/* release all interface and  attach kernel driver */\n\tudev->iface.attach_kernel_driver(idev);\n\tArrayList_Free(udev->request_queue);\n\t/* free the config descriptor that send from windows */\n\tmsusb_msconfig_free(udev->MsConfig);\n\tlibusb_unref_device(udev->libusb_dev);\n\tlibusb_close(udev->libusb_handle);\n\tlibusb_close(udev->hub_handle);\n\tfree(udev->devDescriptor);\n\tfree(idev);\n}\n\nstatic void udev_load_interface(UDEVICE* pdev)\n{\n\t/* load interface */\n\t/* Basic */\n\tBASIC_STATE_FUNC_REGISTER(channelManager, pdev);\n\tBASIC_STATE_FUNC_REGISTER(channelID, pdev);\n\tBASIC_STATE_FUNC_REGISTER(UsbDevice, pdev);\n\tBASIC_STATE_FUNC_REGISTER(ReqCompletion, pdev);\n\tBASIC_STATE_FUNC_REGISTER(bus_number, pdev);\n\tBASIC_STATE_FUNC_REGISTER(dev_number, pdev);\n\tBASIC_STATE_FUNC_REGISTER(port_number, pdev);\n\tBASIC_STATE_FUNC_REGISTER(MsConfig, pdev);\n\tBASIC_STATE_FUNC_REGISTER(p_udev, pdev);\n\tBASIC_STATE_FUNC_REGISTER(p_prev, pdev);\n\tBASIC_STATE_FUNC_REGISTER(p_next, pdev);\n\tpdev->iface.isCompositeDevice = libusb_udev_is_composite_device;\n\tpdev->iface.isExist = libusb_udev_is_exist;\n\tpdev->iface.isAlreadySend = libusb_udev_is_already_send;\n\tpdev->iface.isChannelClosed = libusb_udev_is_channel_closed;\n\tpdev->iface.setAlreadySend = libusb_udev_set_already_send;\n\tpdev->iface.setChannelClosed = libusb_udev_channel_closed;\n\tpdev->iface.markChannelClosed = libusb_udev_mark_channel_closed;\n\tpdev->iface.getPath = libusb_udev_get_path;\n\t/* Transfer */\n\tpdev->iface.isoch_transfer = libusb_udev_isoch_transfer;\n\tpdev->iface.control_transfer = libusb_udev_control_transfer;\n\tpdev->iface.bulk_or_interrupt_transfer = libusb_udev_bulk_or_interrupt_transfer;\n\tpdev->iface.select_interface = libusb_udev_select_interface;\n\tpdev->iface.select_configuration = libusb_udev_select_configuration;\n\tpdev->iface.complete_msconfig_setup = libusb_udev_complete_msconfig_setup;\n\tpdev->iface.control_pipe_request = libusb_udev_control_pipe_request;\n\tpdev->iface.control_query_device_text = libusb_udev_control_query_device_text;\n\tpdev->iface.os_feature_descriptor_request = libusb_udev_os_feature_descriptor_request;\n\tpdev->iface.cancel_all_transfer_request = libusb_udev_cancel_all_transfer_request;\n\tpdev->iface.cancel_transfer_request = libusb_udev_cancel_transfer_request;\n\tpdev->iface.query_device_descriptor = libusb_udev_query_device_descriptor;\n\tpdev->iface.detach_kernel_driver = libusb_udev_detach_kernel_driver;\n\tpdev->iface.attach_kernel_driver = libusb_udev_attach_kernel_driver;\n\tpdev->iface.query_device_port_status = libusb_udev_query_device_port_status;\n\tpdev->iface.free = udev_free;\n}\n\nstatic int udev_get_device_handle(URBDRC_PLUGIN* urbdrc, libusb_context* ctx, UDEVICE* pdev,\n                                  UINT16 bus_number, UINT16 dev_number)\n{\n\tint error;\n\tssize_t i, total_device;\n\tuint8_t port_numbers[16];\n\tLIBUSB_DEVICE** libusb_list;\n\ttotal_device = libusb_get_device_list(ctx, &libusb_list);\n\t/* Look for device. */\n\terror = -1;\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\n\t\tif ((bus_number != libusb_get_bus_number(dev)) ||\n\t\t    (dev_number != libusb_get_device_address(dev)))\n\t\t\tcontinue;\n\n\t\terror = libusb_open(dev, &pdev->libusb_handle);\n\n\t\tif (log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_open\", error))\n\t\t\tbreak;\n\n\t\t/* get port number */\n\t\terror = libusb_get_port_numbers(dev, port_numbers, sizeof(port_numbers));\n\n\t\tif (error < 1)\n\t\t{\n\t\t\t/* Prevent open hub, treat as error. */\n\t\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_get_port_numbers\", error);\n\t\t\tbreak;\n\t\t}\n\n\t\tpdev->port_number = port_numbers[(error - 1)];\n\t\terror = 0;\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"  Port: %d\", pdev->port_number);\n\t\t/* gen device path */\n\t\tsprintf(pdev->path, \"%\" PRIu16 \"-%\" PRIu16 \"\", bus_number, pdev->port_number);\n\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"  DevPath: %s\", pdev->path);\n\t\tbreak;\n\t}\n\tlibusb_free_device_list(libusb_list, 1);\n\n\tif (error < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int udev_get_hub_handle(URBDRC_PLUGIN* urbdrc, libusb_context* ctx, UDEVICE* pdev,\n                               UINT16 bus_number, UINT16 dev_number)\n{\n\tint error;\n\tssize_t i, total_device;\n\tLIBUSB_DEVICE** libusb_list;\n\tLIBUSB_DEVICE_HANDLE* handle;\n\ttotal_device = libusb_get_device_list(ctx, &libusb_list);\n\n\t/* Look for device hub. */\n\terror = -1;\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\n\t\tif ((bus_number != libusb_get_bus_number(dev)) ||\n\t\t    (1 != libusb_get_device_address(dev))) /* Root hub allways first on bus. */\n\t\t\tcontinue;\n\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"  Open hub: %\" PRIu16 \"\", bus_number);\n\t\terror = libusb_open(dev, &handle);\n\n\t\tif (!log_libusb_result(urbdrc->log, WLOG_ERROR, \"libusb_open\", error))\n\t\t\tpdev->hub_handle = handle;\n\n\t\tbreak;\n\t}\n\n\tlibusb_free_device_list(libusb_list, 1);\n\n\tif (error < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void request_free(void* value)\n{\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* transfer = (struct libusb_transfer*)value;\n\tif (!transfer)\n\t\treturn;\n\n\tuser_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;\n\tasync_transfer_user_data_free(user_data);\n\ttransfer->user_data = NULL;\n\tlibusb_free_transfer(transfer);\n}\n\nstatic IUDEVICE* udev_init(URBDRC_PLUGIN* urbdrc, libusb_context* context, LIBUSB_DEVICE* device,\n                           BYTE bus_number, BYTE dev_number)\n{\n\tUDEVICE* pdev;\n\tint status = LIBUSB_ERROR_OTHER;\n\tLIBUSB_DEVICE_DESCRIPTOR* devDescriptor;\n\tLIBUSB_CONFIG_DESCRIPTOR* config_temp;\n\tLIBUSB_INTERFACE_DESCRIPTOR interface_temp;\n\tpdev = (PUDEVICE)calloc(1, sizeof(UDEVICE));\n\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpdev->urbdrc = urbdrc;\n\tudev_load_interface(pdev);\n\n\tif (device)\n\t\tpdev->libusb_dev = device;\n\telse\n\t\tpdev->libusb_dev = udev_get_libusb_dev(context, bus_number, dev_number);\n\n\tif (pdev->libusb_dev == NULL)\n\t\tgoto fail;\n\n\tif (urbdrc->listener_callback)\n\t\tudev_set_channelManager(&pdev->iface, urbdrc->listener_callback->channel_mgr);\n\n\t/* Get DEVICE handle */\n\tstatus = udev_get_device_handle(urbdrc, context, pdev, bus_number, dev_number);\n\tif (status != LIBUSB_SUCCESS)\n\t{\n\t\tstruct libusb_device_descriptor desc;\n\t\tconst uint8_t port = libusb_get_port_number(pdev->libusb_dev);\n\t\tlibusb_get_device_descriptor(pdev->libusb_dev, &desc);\n\n\t\tlog_libusb_result(urbdrc->log, WLOG_ERROR,\n\t\t                  \"libusb_open [b=0x%02X,p=0x%02X,a=0x%02X,VID=0x%04X,PID=0x%04X]\", status,\n\t\t                  bus_number, port, dev_number, desc.idVendor, desc.idProduct);\n\t\tgoto fail;\n\t}\n\n\t/* Get HUB handle */\n\tstatus = udev_get_hub_handle(urbdrc, context, pdev, bus_number, dev_number);\n\n\tif (status < 0)\n\t\tpdev->hub_handle = NULL;\n\n\tpdev->devDescriptor = udev_new_descript(urbdrc, pdev->libusb_dev);\n\n\tif (!pdev->devDescriptor)\n\t\tgoto fail;\n\n\tstatus = libusb_get_active_config_descriptor(pdev->libusb_dev, &pdev->LibusbConfig);\n\n\tif (status == LIBUSB_ERROR_NOT_FOUND)\n\t\tstatus = libusb_get_config_descriptor(pdev->libusb_dev, 0, &pdev->LibusbConfig);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tconfig_temp = pdev->LibusbConfig;\n\t/* get the first interface and first altsetting */\n\tinterface_temp = config_temp->interface[0].altsetting[0];\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"Registered Device: Vid: 0x%04\" PRIX16 \" Pid: 0x%04\" PRIX16 \"\"\n\t           \" InterfaceClass = %s\",\n\t           pdev->devDescriptor->idVendor, pdev->devDescriptor->idProduct,\n\t           usb_interface_class_to_string(interface_temp.bInterfaceClass));\n\t/* Check composite device */\n\tdevDescriptor = pdev->devDescriptor;\n\n\tif ((devDescriptor->bNumConfigurations == 1) && (config_temp->bNumInterfaces > 1) &&\n\t    (devDescriptor->bDeviceClass == LIBUSB_CLASS_PER_INTERFACE))\n\t{\n\t\tpdev->isCompositeDevice = 1;\n\t}\n\telse if ((devDescriptor->bDeviceClass == 0xef) &&\n\t         (devDescriptor->bDeviceSubClass == LIBUSB_CLASS_COMM) &&\n\t         (devDescriptor->bDeviceProtocol == 0x01))\n\t{\n\t\tpdev->isCompositeDevice = 1;\n\t}\n\telse\n\t\tpdev->isCompositeDevice = 0;\n\n\t/* set device class to first interface class */\n\tdevDescriptor->bDeviceClass = interface_temp.bInterfaceClass;\n\tdevDescriptor->bDeviceSubClass = interface_temp.bInterfaceSubClass;\n\tdevDescriptor->bDeviceProtocol = interface_temp.bInterfaceProtocol;\n\t/* initialize pdev */\n\tpdev->bus_number = bus_number;\n\tpdev->dev_number = dev_number;\n\tpdev->request_queue = ArrayList_New(TRUE);\n\n\tif (!pdev->request_queue)\n\t\tgoto fail;\n\n\tArrayList_Object(pdev->request_queue)->fnObjectFree = request_free;\n\n\t/* set config of windows */\n\tpdev->MsConfig = msusb_msconfig_new();\n\n\tif (!pdev->MsConfig)\n\t\tgoto fail;\n\n\t// deb_config_msg(pdev->libusb_dev, config_temp, devDescriptor->bNumConfigurations);\n\treturn &pdev->iface;\nfail:\n\tpdev->iface.free(&pdev->iface);\n\treturn NULL;\n}\n\nsize_t udev_new_by_id(URBDRC_PLUGIN* urbdrc, libusb_context* ctx, UINT16 idVendor, UINT16 idProduct,\n                      IUDEVICE*** devArray)\n{\n\tLIBUSB_DEVICE** libusb_list;\n\tUDEVICE** array;\n\tssize_t i, total_device;\n\tsize_t num = 0;\n\n\tif (!urbdrc || !devArray)\n\t\treturn 0;\n\n\tWLog_Print(urbdrc->log, WLOG_INFO, \"VID: 0x%04\" PRIX16 \", PID: 0x%04\" PRIX16 \"\", idVendor,\n\t           idProduct);\n\ttotal_device = libusb_get_device_list(ctx, &libusb_list);\n\tarray = (UDEVICE**)calloc(total_device, sizeof(UDEVICE*));\n\n\tif (!array)\n\t\tgoto fail;\n\n\tfor (i = 0; i < total_device; i++)\n\t{\n\t\tLIBUSB_DEVICE* dev = libusb_list[i];\n\t\tLIBUSB_DEVICE_DESCRIPTOR* descriptor = udev_new_descript(urbdrc, dev);\n\n\t\tif ((descriptor->idVendor == idVendor) && (descriptor->idProduct == idProduct))\n\t\t{\n\t\t\tarray[num] = (PUDEVICE)udev_init(urbdrc, ctx, dev, libusb_get_bus_number(dev),\n\t\t\t                                 libusb_get_device_address(dev));\n\n\t\t\tif (array[num] != NULL)\n\t\t\t\tnum++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlibusb_unref_device(dev);\n\t\t}\n\n\t\tfree(descriptor);\n\t}\n\nfail:\n\tlibusb_free_device_list(libusb_list, 0);\n\t*devArray = (IUDEVICE**)array;\n\treturn num;\n}\n\nIUDEVICE* udev_new_by_addr(URBDRC_PLUGIN* urbdrc, libusb_context* context, BYTE bus_number,\n                           BYTE dev_number)\n{\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"bus:%d dev:%d\", bus_number, dev_number);\n\treturn udev_init(urbdrc, context, NULL, bus_number, dev_number);\n}\n"], "filenames": ["channels/urbdrc/client/libusb/libusb_udevice.c"], "buggy_code_start_loc": [1224], "buggy_code_end_loc": [1230], "fixing_code_start_loc": [1224], "fixing_code_end_loc": [1236], "type": "CWE-20", "message": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input validation in `urbdrc` channel. A malicious server can trick a FreeRDP based client to crash with division by zero. This issue has been addressed in version 2.9.0. All users are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection switch.", "other": {"cve": {"id": "CVE-2022-39318", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-16T21:15:10.407", "lastModified": "2023-01-25T19:56:52.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input validation in `urbdrc` channel. A malicious server can trick a FreeRDP based client to crash with division by zero. This issue has been addressed in version 2.9.0. All users are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection switch."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-369"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.0", "matchCriteriaId": "AF273D61-AA72-44FE-937E-D5749D565AEE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-387j-8j96-7q35", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea"}}