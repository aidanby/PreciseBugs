{"buggy_code": ["/**\n * eCryptfs: Linux filesystem encryption layer\n *\n * Copyright (C) 1997-2003 Erez Zadok\n * Copyright (C) 2001-2003 Stony Brook University\n * Copyright (C) 2004-2007 International Business Machines Corp.\n *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>\n *              Michael C. Thompson <mcthomps@us.ibm.com>\n *              Tyler Hicks <tyhicks@ou.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n#include <linux/dcache.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/skbuff.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/key.h>\n#include <linux/parser.h>\n#include <linux/fs_stack.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include \"ecryptfs_kernel.h\"\n\n/**\n * Module parameter that defines the ecryptfs_verbosity level.\n */\nint ecryptfs_verbosity = 0;\n\nmodule_param(ecryptfs_verbosity, int, 0);\nMODULE_PARM_DESC(ecryptfs_verbosity,\n\t\t \"Initial verbosity level (0 or 1; defaults to \"\n\t\t \"0, which is Quiet)\");\n\n/**\n * Module parameter that defines the number of message buffer elements\n */\nunsigned int ecryptfs_message_buf_len = ECRYPTFS_DEFAULT_MSG_CTX_ELEMS;\n\nmodule_param(ecryptfs_message_buf_len, uint, 0);\nMODULE_PARM_DESC(ecryptfs_message_buf_len,\n\t\t \"Number of message buffer elements\");\n\n/**\n * Module parameter that defines the maximum guaranteed amount of time to wait\n * for a response from ecryptfsd.  The actual sleep time will be, more than\n * likely, a small amount greater than this specified value, but only less if\n * the message successfully arrives.\n */\nsigned long ecryptfs_message_wait_timeout = ECRYPTFS_MAX_MSG_CTX_TTL / HZ;\n\nmodule_param(ecryptfs_message_wait_timeout, long, 0);\nMODULE_PARM_DESC(ecryptfs_message_wait_timeout,\n\t\t \"Maximum number of seconds that an operation will \"\n\t\t \"sleep while waiting for a message response from \"\n\t\t \"userspace\");\n\n/**\n * Module parameter that is an estimate of the maximum number of users\n * that will be concurrently using eCryptfs. Set this to the right\n * value to balance performance and memory use.\n */\nunsigned int ecryptfs_number_of_users = ECRYPTFS_DEFAULT_NUM_USERS;\n\nmodule_param(ecryptfs_number_of_users, uint, 0);\nMODULE_PARM_DESC(ecryptfs_number_of_users, \"An estimate of the number of \"\n\t\t \"concurrent users of eCryptfs\");\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}\n\n/**\n * ecryptfs_init_lower_file\n * @ecryptfs_dentry: Fully initialized eCryptfs dentry object, with\n *                   the lower dentry and the lower mount set\n *\n * eCryptfs only ever keeps a single open file for every lower\n * inode. All I/O operations to the lower inode occur through that\n * file. When the first eCryptfs dentry that interposes with the first\n * lower dentry for that inode is created, this function creates the\n * lower file struct and associates it with the eCryptfs\n * inode. When all eCryptfs files associated with the inode are released, the\n * file is closed.\n *\n * The lower file will be opened with read/write permissions, if\n * possible. Otherwise, it is opened read-only.\n *\n * This function does nothing if a lower file is already\n * associated with the eCryptfs inode.\n *\n * Returns zero on success; non-zero otherwise\n */\nstatic int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct vfsmount *lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, lower_dentry, lower_mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", lower_dentry, lower_mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}\n\nenum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n       ecryptfs_opt_cipher, ecryptfs_opt_ecryptfs_cipher,\n       ecryptfs_opt_ecryptfs_key_bytes,\n       ecryptfs_opt_passthrough, ecryptfs_opt_xattr_metadata,\n       ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n       ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n       ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n       ecryptfs_opt_err };\n\nstatic const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_err, NULL}\n};\n\nstatic int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\nstatic void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}\n\n/**\n * ecryptfs_parse_options\n * @sb: The ecryptfs super block\n * @options: The options passed to the kernel\n *\n * Parse mount options:\n * debug=N \t   - ecryptfs_verbosity level for debug output\n * sig=XXX\t   - description(signature) of the key to use\n *\n * Returns the dentry object of the lower-level (lower/interposed)\n * directory; We want to mount our stackable file system on top of\n * that lower directory.\n *\n * The signature of the key to use must be the description of a key\n * already in the keyring. Mounting will fail if the key can not be\n * found.\n *\n * Returns zero on success; non-zero on error\n */\nstatic int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\nstatic struct file_system_type ecryptfs_fs_type;\n\n/**\n * ecryptfs_get_sb\n * @fs_type\n * @flags\n * @dev_name: The path to mount over\n * @raw_data: The options passed into the kernel\n */\nstatic struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\n\ts = sget(fs_type, NULL, set_anon_super, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\ts->s_flags = flags;\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_alloc_root(inode);\n\tif (!s->s_root) {\n\t\tiput(inode);\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\tecryptfs_set_dentry_lower(s->s_root, path.dentry);\n\tecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}\n\n/**\n * ecryptfs_kill_block_super\n * @sb: The ecryptfs super block\n *\n * Used to bring the superblock down and free the private data.\n */\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}\n\nstatic struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};\n\n/**\n * inode_info_init_once\n *\n * Initializes the ecryptfs_inode_info_cache when it is created\n */\nstatic void\ninode_info_init_once(void *vptr)\n{\n\tstruct ecryptfs_inode_info *ei = (struct ecryptfs_inode_info *)vptr;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n\t{\n\t\t.cache = &ecryptfs_open_req_cache,\n\t\t.name = \"ecryptfs_open_req_cache\",\n\t\t.size = sizeof(struct ecryptfs_open_req),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}\n\n/**\n * ecryptfs_init_kmem_caches\n *\n * Returns zero on success; non-zero otherwise\n */\nstatic int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size,\n\t\t\t\t0, SLAB_HWCACHE_ALIGN, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct kobject *ecryptfs_kobj;\n\nstatic ssize_t version_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buff)\n{\n\treturn snprintf(buff, PAGE_SIZE, \"%d\\n\", ECRYPTFS_VERSIONING_MASK);\n}\n\nstatic struct kobj_attribute version_attr = __ATTR_RO(version);\n\nstatic struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}\n\nstatic void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}\n\nstatic int __init ecryptfs_init(void)\n{\n\tint rc;\n\n\tif (ECRYPTFS_DEFAULT_EXTENT_SIZE > PAGE_CACHE_SIZE) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"The eCryptfs extent size is \"\n\t\t\t\t\"larger than the host's page size, and so \"\n\t\t\t\t\"eCryptfs cannot run on this system. The \"\n\t\t\t\t\"default eCryptfs extent size is [%u] bytes; \"\n\t\t\t\t\"the page size is [%lu] bytes.\\n\",\n\t\t\t\tECRYPTFS_DEFAULT_EXTENT_SIZE,\n\t\t\t\t(unsigned long)PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_init_kmem_caches();\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Failed to allocate one or more kmem_cache objects\\n\");\n\t\tgoto out;\n\t}\n\trc = register_filesystem(&ecryptfs_fs_type);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to register filesystem\\n\");\n\t\tgoto out_free_kmem_caches;\n\t}\n\trc = do_sysfs_registration();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"sysfs registration failed\\n\");\n\t\tgoto out_unregister_filesystem;\n\t}\n\trc = ecryptfs_init_kthread();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: kthread initialization failed; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_do_sysfs_unregistration;\n\t}\n\trc = ecryptfs_init_messaging();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure occurred while attempting to \"\n\t\t\t\t\"initialize the communications channel to \"\n\t\t\t\t\"ecryptfsd\\n\");\n\t\tgoto out_destroy_kthread;\n\t}\n\trc = ecryptfs_init_crypto();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure whilst attempting to init crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_release_messaging;\n\t}\n\tif (ecryptfs_verbosity > 0)\n\t\tprintk(KERN_CRIT \"eCryptfs verbosity set to %d. Secret values \"\n\t\t\t\"will be written to the syslog!\\n\", ecryptfs_verbosity);\n\n\tgoto out;\nout_release_messaging:\n\tecryptfs_release_messaging();\nout_destroy_kthread:\n\tecryptfs_destroy_kthread();\nout_do_sysfs_unregistration:\n\tdo_sysfs_unregistration();\nout_unregister_filesystem:\n\tunregister_filesystem(&ecryptfs_fs_type);\nout_free_kmem_caches:\n\tecryptfs_free_kmem_caches();\nout:\n\treturn rc;\n}\n\nstatic void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}\n\nMODULE_AUTHOR(\"Michael A. Halcrow <mhalcrow@us.ibm.com>\");\nMODULE_DESCRIPTION(\"eCryptfs\");\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(ecryptfs_init)\nmodule_exit(ecryptfs_exit)\n"], "fixing_code": ["/**\n * eCryptfs: Linux filesystem encryption layer\n *\n * Copyright (C) 1997-2003 Erez Zadok\n * Copyright (C) 2001-2003 Stony Brook University\n * Copyright (C) 2004-2007 International Business Machines Corp.\n *   Author(s): Michael A. Halcrow <mahalcro@us.ibm.com>\n *              Michael C. Thompson <mcthomps@us.ibm.com>\n *              Tyler Hicks <tyhicks@ou.edu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.\n */\n\n#include <linux/dcache.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/skbuff.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/key.h>\n#include <linux/parser.h>\n#include <linux/fs_stack.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include \"ecryptfs_kernel.h\"\n\n/**\n * Module parameter that defines the ecryptfs_verbosity level.\n */\nint ecryptfs_verbosity = 0;\n\nmodule_param(ecryptfs_verbosity, int, 0);\nMODULE_PARM_DESC(ecryptfs_verbosity,\n\t\t \"Initial verbosity level (0 or 1; defaults to \"\n\t\t \"0, which is Quiet)\");\n\n/**\n * Module parameter that defines the number of message buffer elements\n */\nunsigned int ecryptfs_message_buf_len = ECRYPTFS_DEFAULT_MSG_CTX_ELEMS;\n\nmodule_param(ecryptfs_message_buf_len, uint, 0);\nMODULE_PARM_DESC(ecryptfs_message_buf_len,\n\t\t \"Number of message buffer elements\");\n\n/**\n * Module parameter that defines the maximum guaranteed amount of time to wait\n * for a response from ecryptfsd.  The actual sleep time will be, more than\n * likely, a small amount greater than this specified value, but only less if\n * the message successfully arrives.\n */\nsigned long ecryptfs_message_wait_timeout = ECRYPTFS_MAX_MSG_CTX_TTL / HZ;\n\nmodule_param(ecryptfs_message_wait_timeout, long, 0);\nMODULE_PARM_DESC(ecryptfs_message_wait_timeout,\n\t\t \"Maximum number of seconds that an operation will \"\n\t\t \"sleep while waiting for a message response from \"\n\t\t \"userspace\");\n\n/**\n * Module parameter that is an estimate of the maximum number of users\n * that will be concurrently using eCryptfs. Set this to the right\n * value to balance performance and memory use.\n */\nunsigned int ecryptfs_number_of_users = ECRYPTFS_DEFAULT_NUM_USERS;\n\nmodule_param(ecryptfs_number_of_users, uint, 0);\nMODULE_PARM_DESC(ecryptfs_number_of_users, \"An estimate of the number of \"\n\t\t \"concurrent users of eCryptfs\");\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}\n\n/**\n * ecryptfs_init_lower_file\n * @ecryptfs_dentry: Fully initialized eCryptfs dentry object, with\n *                   the lower dentry and the lower mount set\n *\n * eCryptfs only ever keeps a single open file for every lower\n * inode. All I/O operations to the lower inode occur through that\n * file. When the first eCryptfs dentry that interposes with the first\n * lower dentry for that inode is created, this function creates the\n * lower file struct and associates it with the eCryptfs\n * inode. When all eCryptfs files associated with the inode are released, the\n * file is closed.\n *\n * The lower file will be opened with read/write permissions, if\n * possible. Otherwise, it is opened read-only.\n *\n * This function does nothing if a lower file is already\n * associated with the eCryptfs inode.\n *\n * Returns zero on success; non-zero otherwise\n */\nstatic int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tstruct vfsmount *lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, lower_dentry, lower_mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", lower_dentry, lower_mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}\n\nenum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n       ecryptfs_opt_cipher, ecryptfs_opt_ecryptfs_cipher,\n       ecryptfs_opt_ecryptfs_key_bytes,\n       ecryptfs_opt_passthrough, ecryptfs_opt_xattr_metadata,\n       ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n       ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n       ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n       ecryptfs_opt_check_dev_ruid,\n       ecryptfs_opt_err };\n\nstatic const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n\t{ecryptfs_opt_err, NULL}\n};\n\nstatic int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\nstatic void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}\n\n/**\n * ecryptfs_parse_options\n * @sb: The ecryptfs super block\n * @options: The options passed to the kernel\n * @check_ruid: set to 1 if device uid should be checked against the ruid\n *\n * Parse mount options:\n * debug=N \t   - ecryptfs_verbosity level for debug output\n * sig=XXX\t   - description(signature) of the key to use\n *\n * Returns the dentry object of the lower-level (lower/interposed)\n * directory; We want to mount our stackable file system on top of\n * that lower directory.\n *\n * The signature of the key to use must be the description of a key\n * already in the keyring. Mounting will fail if the key can not be\n * found.\n *\n * Returns zero on success; non-zero on error\n */\nstatic int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\nstatic struct file_system_type ecryptfs_fs_type;\n\n/**\n * ecryptfs_get_sb\n * @fs_type\n * @flags\n * @dev_name: The path to mount over\n * @raw_data: The options passed into the kernel\n */\nstatic struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t check_ruid;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\n\ts = sget(fs_type, NULL, set_anon_super, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\ts->s_flags = flags;\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t       path.dentry->d_inode->i_uid, current_uid());\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_alloc_root(inode);\n\tif (!s->s_root) {\n\t\tiput(inode);\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\tecryptfs_set_dentry_lower(s->s_root, path.dentry);\n\tecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}\n\n/**\n * ecryptfs_kill_block_super\n * @sb: The ecryptfs super block\n *\n * Used to bring the superblock down and free the private data.\n */\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}\n\nstatic struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};\n\n/**\n * inode_info_init_once\n *\n * Initializes the ecryptfs_inode_info_cache when it is created\n */\nstatic void\ninode_info_init_once(void *vptr)\n{\n\tstruct ecryptfs_inode_info *ei = (struct ecryptfs_inode_info *)vptr;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n\t{\n\t\t.cache = &ecryptfs_open_req_cache,\n\t\t.name = \"ecryptfs_open_req_cache\",\n\t\t.size = sizeof(struct ecryptfs_open_req),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}\n\n/**\n * ecryptfs_init_kmem_caches\n *\n * Returns zero on success; non-zero otherwise\n */\nstatic int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size,\n\t\t\t\t0, SLAB_HWCACHE_ALIGN, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct kobject *ecryptfs_kobj;\n\nstatic ssize_t version_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buff)\n{\n\treturn snprintf(buff, PAGE_SIZE, \"%d\\n\", ECRYPTFS_VERSIONING_MASK);\n}\n\nstatic struct kobj_attribute version_attr = __ATTR_RO(version);\n\nstatic struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};\n\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}\n\nstatic void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}\n\nstatic int __init ecryptfs_init(void)\n{\n\tint rc;\n\n\tif (ECRYPTFS_DEFAULT_EXTENT_SIZE > PAGE_CACHE_SIZE) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"The eCryptfs extent size is \"\n\t\t\t\t\"larger than the host's page size, and so \"\n\t\t\t\t\"eCryptfs cannot run on this system. The \"\n\t\t\t\t\"default eCryptfs extent size is [%u] bytes; \"\n\t\t\t\t\"the page size is [%lu] bytes.\\n\",\n\t\t\t\tECRYPTFS_DEFAULT_EXTENT_SIZE,\n\t\t\t\t(unsigned long)PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_init_kmem_caches();\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Failed to allocate one or more kmem_cache objects\\n\");\n\t\tgoto out;\n\t}\n\trc = register_filesystem(&ecryptfs_fs_type);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to register filesystem\\n\");\n\t\tgoto out_free_kmem_caches;\n\t}\n\trc = do_sysfs_registration();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"sysfs registration failed\\n\");\n\t\tgoto out_unregister_filesystem;\n\t}\n\trc = ecryptfs_init_kthread();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: kthread initialization failed; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_do_sysfs_unregistration;\n\t}\n\trc = ecryptfs_init_messaging();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure occurred while attempting to \"\n\t\t\t\t\"initialize the communications channel to \"\n\t\t\t\t\"ecryptfsd\\n\");\n\t\tgoto out_destroy_kthread;\n\t}\n\trc = ecryptfs_init_crypto();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure whilst attempting to init crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_release_messaging;\n\t}\n\tif (ecryptfs_verbosity > 0)\n\t\tprintk(KERN_CRIT \"eCryptfs verbosity set to %d. Secret values \"\n\t\t\t\"will be written to the syslog!\\n\", ecryptfs_verbosity);\n\n\tgoto out;\nout_release_messaging:\n\tecryptfs_release_messaging();\nout_destroy_kthread:\n\tecryptfs_destroy_kthread();\nout_do_sysfs_unregistration:\n\tdo_sysfs_unregistration();\nout_unregister_filesystem:\n\tunregister_filesystem(&ecryptfs_fs_type);\nout_free_kmem_caches:\n\tecryptfs_free_kmem_caches();\nout:\n\treturn rc;\n}\n\nstatic void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}\n\nMODULE_AUTHOR(\"Michael A. Halcrow <mhalcrow@us.ibm.com>\");\nMODULE_DESCRIPTION(\"eCryptfs\");\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(ecryptfs_init)\nmodule_exit(ecryptfs_exit)\n"], "filenames": ["fs/ecryptfs/main.c"], "buggy_code_start_loc": [177], "buggy_code_end_loc": [523], "fixing_code_start_loc": [178], "fixing_code_end_loc": [543], "type": "CWE-264", "message": "Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.", "other": {"cve": {"id": "CVE-2011-1833", "sourceIdentifier": "security@ubuntu.com", "published": "2012-10-03T11:02:55.940", "lastModified": "2014-03-08T04:47:54.257", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n ecryptfs_mount en fs/ecryptfs/main.c en el subsistema eCryptfs en el Kernel de Linux anteriores a v3.1 permite a usuarios locales evitar los permisos de ficheros impuestos a trav\u00e9s de montar una unidad con mount.ecryptfs_private con un uid que no coincide."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}, {"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.44", "matchCriteriaId": "3D31AE8D-EEA4-4B31-A35A-565A7647B305"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=764355487ea220fdc2faf128d577d7f679b91f97", "source": "security@ubuntu.com", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-08/msg00009.html", "source": "security@ubuntu.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "security@ubuntu.com"}, {"url": "http://www.ubuntu.com/usn/USN-1188-1", "source": "security@ubuntu.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=731172", "source": "security@ubuntu.com"}, {"url": "https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97", "source": "security@ubuntu.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97"}}