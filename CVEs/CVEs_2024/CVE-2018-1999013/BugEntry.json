{"buggy_code": ["/*\n * \"Real\" compatible demuxer.\n * Copyright (c) 2000, 2001 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/dict.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"internal.h\"\n#include \"rmsipr.h\"\n#include \"rm.h\"\n\n#define DEINT_ID_GENR MKTAG('g', 'e', 'n', 'r') ///< interleaving for Cooker/ATRAC\n#define DEINT_ID_INT0 MKTAG('I', 'n', 't', '0') ///< no interleaving needed\n#define DEINT_ID_INT4 MKTAG('I', 'n', 't', '4') ///< interleaving for 28.8\n#define DEINT_ID_SIPR MKTAG('s', 'i', 'p', 'r') ///< interleaving for Sipro\n#define DEINT_ID_VBRF MKTAG('v', 'b', 'r', 'f') ///< VBR case for AAC\n#define DEINT_ID_VBRS MKTAG('v', 'b', 'r', 's') ///< VBR case for AAC\n\nstruct RMStream {\n    AVPacket pkt;      ///< place to store merged video frame / reordered audio data\n    int videobufsize;  ///< current assembled frame size\n    int videobufpos;   ///< position for the next slice in the video buffer\n    int curpic_num;    ///< picture number of current frame\n    int cur_slice, slices;\n    int64_t pktpos;    ///< first slice position in file\n    /// Audio descrambling matrix parameters\n    int64_t audiotimestamp; ///< Audio packet timestamp\n    int sub_packet_cnt; // Subpacket counter, used while reading\n    int sub_packet_size, sub_packet_h, coded_framesize; ///< Descrambling parameters from container\n    int audio_framesize; /// Audio frame size from container\n    int sub_packet_lengths[16]; /// Length of each subpacket\n    int32_t deint_id;  ///< deinterleaver used in audio stream\n};\n\ntypedef struct RMDemuxContext {\n    int nb_packets;\n    int old_format;\n    int current_stream;\n    int remaining_len;\n    int audio_stream_num; ///< Stream number for audio packets\n    int audio_pkt_cnt; ///< Output packet counter\n    int data_end;\n} RMDemuxContext;\n\nstatic int rm_read_close(AVFormatContext *s);\n\nstatic inline void get_strl(AVIOContext *pb, char *buf, int buf_size, int len)\n{\n    int read = avio_get_str(pb, len, buf, buf_size);\n\n    if (read > 0)\n        avio_skip(pb, len - read);\n}\n\nstatic void get_str8(AVIOContext *pb, char *buf, int buf_size)\n{\n    get_strl(pb, buf, buf_size, avio_r8(pb));\n}\n\nstatic int rm_read_extradata(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, unsigned size)\n{\n    if (size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"extradata size %u too large\\n\", size);\n        return -1;\n    }\n    if (ff_get_extradata(s, par, pb, size) < 0)\n        return AVERROR(ENOMEM);\n    return 0;\n}\n\nstatic void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide)\n{\n    char buf[1024];\n    int i;\n\n    for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) {\n        int len = wide ? avio_rb16(pb) : avio_r8(pb);\n        if (len > 0) {\n            get_strl(pb, buf, sizeof(buf), len);\n            av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0);\n        }\n    }\n}\n\nRMStream *ff_rm_alloc_rmstream (void)\n{\n    RMStream *rms = av_mallocz(sizeof(RMStream));\n    if (!rms)\n        return NULL;\n    rms->curpic_num = -1;\n    return rms;\n}\n\nvoid ff_rm_free_rmstream (RMStream *rms)\n{\n    av_packet_unref(&rms->pkt);\n}\n\nstatic int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n                                     AVStream *st, RMStream *ast, int read_all)\n{\n    char buf[256];\n    uint32_t version;\n    int ret;\n\n    /* ra type header */\n    version = avio_rb16(pb); /* version */\n    if (version == 3) {\n        unsigned bytes_per_minute;\n        int header_size = avio_rb16(pb);\n        int64_t startpos = avio_tell(pb);\n        avio_skip(pb, 8);\n        bytes_per_minute = avio_rb16(pb);\n        avio_skip(pb, 4);\n        rm_read_metadata(s, pb, 0);\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n            // fourcc (should always be \"lpcJ\")\n            avio_r8(pb);\n            get_str8(pb, buf, sizeof(buf));\n        }\n        // Skip extra header crap (this should never happen)\n        if ((startpos + header_size) > avio_tell(pb))\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n        if (bytes_per_minute)\n            st->codecpar->bit_rate = 8LL * bytes_per_minute / 60;\n        st->codecpar->sample_rate = 8000;\n        st->codecpar->channels = 1;\n        st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_RA_144;\n        ast->deint_id = DEINT_ID_INT0;\n    } else {\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n        int codecdata_length;\n        unsigned bytes_per_minute;\n        /* old version (4) */\n        avio_skip(pb, 2); /* unused */\n        avio_rb32(pb); /* .ra4 */\n        avio_rb32(pb); /* data size */\n        avio_rb16(pb); /* version2 */\n        avio_rb32(pb); /* header size */\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n        avio_rb32(pb); /* ??? */\n        bytes_per_minute = avio_rb32(pb);\n        if (version == 4) {\n            if (bytes_per_minute)\n                st->codecpar->bit_rate = 8LL * bytes_per_minute / 60;\n        }\n        avio_rb32(pb); /* ??? */\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n        st->codecpar->block_align= avio_rb16(pb); /* frame size */\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n        avio_rb16(pb); /* ??? */\n        if (version == 5) {\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n        }\n        st->codecpar->sample_rate = avio_rb16(pb);\n        avio_rb32(pb);\n        st->codecpar->channels = avio_rb16(pb);\n        if (version == 5) {\n            ast->deint_id = avio_rl32(pb);\n            avio_read(pb, buf, 4);\n            buf[4] = 0;\n        } else {\n            AV_WL32(buf, 0);\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n            ast->deint_id = AV_RL32(buf);\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n        }\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_tag  = AV_RL32(buf);\n        st->codecpar->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                   st->codecpar->codec_tag);\n\n        switch (st->codecpar->codec_id) {\n        case AV_CODEC_ID_AC3:\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n            break;\n        case AV_CODEC_ID_RA_288:\n            st->codecpar->extradata_size= 0;\n            av_freep(&st->codecpar->extradata);\n            ast->audio_framesize = st->codecpar->block_align;\n            st->codecpar->block_align = coded_framesize;\n            break;\n        case AV_CODEC_ID_COOK:\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n        case AV_CODEC_ID_ATRAC3:\n        case AV_CODEC_ID_SIPR:\n            if (read_all) {\n                codecdata_length = 0;\n            } else {\n                avio_rb16(pb); avio_r8(pb);\n                if (version == 5)\n                    avio_r8(pb);\n                codecdata_length = avio_rb32(pb);\n                if(codecdata_length + AV_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                    return -1;\n                }\n            }\n\n            ast->audio_framesize = st->codecpar->block_align;\n            if (st->codecpar->codec_id == AV_CODEC_ID_SIPR) {\n                if (flavor > 3) {\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n                           flavor);\n                    return -1;\n                }\n                st->codecpar->block_align = ff_sipr_subpk_size[flavor];\n                st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n            } else {\n                if(sub_packet_size <= 0){\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n                    return -1;\n                }\n                st->codecpar->block_align = ast->sub_packet_size;\n            }\n            if ((ret = rm_read_extradata(s, pb, st->codecpar, codecdata_length)) < 0)\n                return ret;\n\n            break;\n        case AV_CODEC_ID_AAC:\n            avio_rb16(pb); avio_r8(pb);\n            if (version == 5)\n                avio_r8(pb);\n            codecdata_length = avio_rb32(pb);\n            if(codecdata_length + AV_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                return -1;\n            }\n            if (codecdata_length >= 1) {\n                avio_r8(pb);\n                if ((ret = rm_read_extradata(s, pb, st->codecpar, codecdata_length - 1)) < 0)\n                    return ret;\n            }\n            break;\n        }\n        switch (ast->deint_id) {\n        case DEINT_ID_INT4:\n            if (ast->coded_framesize > ast->audio_framesize ||\n                sub_packet_h <= 1 ||\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n                return AVERROR_INVALIDDATA;\n            if (ast->coded_framesize * sub_packet_h != 2*ast->audio_framesize) {\n                avpriv_request_sample(s, \"mismatching interleaver parameters\");\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case DEINT_ID_GENR:\n            if (ast->sub_packet_size <= 0 ||\n                ast->sub_packet_size > ast->audio_framesize)\n                return AVERROR_INVALIDDATA;\n            if (ast->audio_framesize % ast->sub_packet_size)\n                return AVERROR_INVALIDDATA;\n            break;\n        case DEINT_ID_SIPR:\n        case DEINT_ID_INT0:\n        case DEINT_ID_VBRS:\n        case DEINT_ID_VBRF:\n            break;\n        default:\n            av_log(s, AV_LOG_ERROR ,\"Unknown interleaver %\"PRIX32\"\\n\", ast->deint_id);\n            return AVERROR_INVALIDDATA;\n        }\n        if (ast->deint_id == DEINT_ID_INT4 ||\n            ast->deint_id == DEINT_ID_GENR ||\n            ast->deint_id == DEINT_ID_SIPR) {\n            if (st->codecpar->block_align <= 0 ||\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n                ast->audio_framesize * sub_packet_h < st->codecpar->block_align)\n                return AVERROR_INVALIDDATA;\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n                return AVERROR(ENOMEM);\n        }\n\n        if (read_all) {\n            avio_r8(pb);\n            avio_r8(pb);\n            avio_r8(pb);\n            rm_read_metadata(s, pb, 0);\n        }\n    }\n    return 0;\n}\n\nint ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    if (codec_data_size == 0)\n        return 0;\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(s, pb, st->codecpar, codec_data_size)) < 0)\n            return ret;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_tag  = AV_RL32(st->codecpar->extradata);\n        st->codecpar->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codecpar->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codecpar->codec_tag = avio_rl32(pb);\n        st->codecpar->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                                  st->codecpar->codec_tag);\n        av_log(s, AV_LOG_TRACE, \"%\"PRIX32\" %X\\n\",\n               st->codecpar->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codecpar->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codecpar->width  = avio_rb16(pb);\n        st->codecpar->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n\n        if ((ret = rm_read_extradata(s, pb, st->codecpar, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    if (codec_data_size >= size) {\n        avio_skip(pb, codec_data_size - size);\n    } else {\n        av_log(s, AV_LOG_WARNING, \"codec_data_size %u < size %d\\n\", codec_data_size, size);\n    }\n\n    return 0;\n}\n\n/** this function assumes that the demuxer has already seeked to the start\n * of the INDX chunk, and will bail out if not. */\nstatic int rm_read_index(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    unsigned int size, n_pkts, str_id, next_off, n, pos, pts;\n    AVStream *st;\n\n    do {\n        if (avio_rl32(pb) != MKTAG('I','N','D','X'))\n            return -1;\n        size     = avio_rb32(pb);\n        if (size < 20)\n            return -1;\n        avio_skip(pb, 2);\n        n_pkts   = avio_rb32(pb);\n        str_id   = avio_rb16(pb);\n        next_off = avio_rb32(pb);\n        for (n = 0; n < s->nb_streams; n++)\n            if (s->streams[n]->id == str_id) {\n                st = s->streams[n];\n                break;\n            }\n        if (n == s->nb_streams) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Invalid stream index %d for index at pos %\"PRId64\"\\n\",\n                   str_id, avio_tell(pb));\n            goto skip;\n        } else if ((avio_size(pb) - avio_tell(pb)) / 14 < n_pkts) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Nr. of packets in packet index for stream index %d \"\n                   \"exceeds filesize (%\"PRId64\" at %\"PRId64\" = %\"PRId64\")\\n\",\n                   str_id, avio_size(pb), avio_tell(pb),\n                   (avio_size(pb) - avio_tell(pb)) / 14);\n            goto skip;\n        }\n\n        for (n = 0; n < n_pkts; n++) {\n            avio_skip(pb, 2);\n            pts = avio_rb32(pb);\n            pos = avio_rb32(pb);\n            avio_skip(pb, 4); /* packet no. */\n\n            av_add_index_entry(st, pos, pts, 0, 0, AVINDEX_KEYFRAME);\n        }\n\nskip:\n        if (next_off && avio_tell(pb) < next_off &&\n            avio_seek(pb, next_off, SEEK_SET) < 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Non-linear index detected, not supported\\n\");\n            return -1;\n        }\n    } while (next_off);\n\n    return 0;\n}\n\nstatic int rm_read_header_old(AVFormatContext *s)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st;\n\n    rm->old_format = 1;\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return -1;\n    st->priv_data = ff_rm_alloc_rmstream();\n    if (!st->priv_data)\n        return AVERROR(ENOMEM);\n    return rm_read_audio_stream_info(s, s->pb, st, st->priv_data, 1);\n}\n\nstatic int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}\n\nstatic int rm_read_header(AVFormatContext *s)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st;\n    AVIOContext *pb = s->pb;\n    unsigned int tag;\n    int tag_size;\n    unsigned int start_time, duration;\n    unsigned int data_off = 0, indx_off = 0;\n    char buf[128], mime[128];\n    int flags = 0;\n    int ret = -1;\n    unsigned size, v;\n    int64_t codec_pos;\n\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.', 'r', 'a', 0xfd)) {\n        /* very old .ra format */\n        return rm_read_header_old(s);\n    } else if (tag != MKTAG('.', 'R', 'M', 'F')) {\n        return AVERROR(EIO);\n    }\n\n    tag_size = avio_rb32(pb);\n    avio_skip(pb, tag_size - 8);\n\n    for(;;) {\n        if (avio_feof(pb))\n            goto fail;\n        tag = avio_rl32(pb);\n        tag_size = avio_rb32(pb);\n        avio_rb16(pb);\n        av_log(s, AV_LOG_TRACE, \"tag=%s size=%d\\n\",\n               av_fourcc2str(tag), tag_size);\n        if (tag_size < 10 && tag != MKTAG('D', 'A', 'T', 'A'))\n            goto fail;\n        switch(tag) {\n        case MKTAG('P', 'R', 'O', 'P'):\n            /* file header */\n            avio_rb32(pb); /* max bit rate */\n            avio_rb32(pb); /* avg bit rate */\n            avio_rb32(pb); /* max packet size */\n            avio_rb32(pb); /* avg packet size */\n            avio_rb32(pb); /* nb packets */\n            duration = avio_rb32(pb); /* duration */\n            s->duration = av_rescale(duration, AV_TIME_BASE, 1000);\n            avio_rb32(pb); /* preroll */\n            indx_off = avio_rb32(pb); /* index offset */\n            data_off = avio_rb32(pb); /* data offset */\n            avio_rb16(pb); /* nb streams */\n            flags = avio_rb16(pb); /* flags */\n            break;\n        case MKTAG('C', 'O', 'N', 'T'):\n            rm_read_metadata(s, pb, 1);\n            break;\n        case MKTAG('M', 'D', 'P', 'R'):\n            st = avformat_new_stream(s, NULL);\n            if (!st) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            st->id = avio_rb16(pb);\n            avio_rb32(pb); /* max bit rate */\n            st->codecpar->bit_rate = avio_rb32(pb); /* bit rate */\n            avio_rb32(pb); /* max packet size */\n            avio_rb32(pb); /* avg packet size */\n            start_time = avio_rb32(pb); /* start time */\n            avio_rb32(pb); /* preroll */\n            duration = avio_rb32(pb); /* duration */\n            st->start_time = start_time;\n            st->duration = duration;\n            if(duration>0)\n                s->duration = AV_NOPTS_VALUE;\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n            get_str8(pb, mime, sizeof(mime)); /* mimetype */\n            st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st->priv_data = ff_rm_alloc_rmstream();\n            if (!st->priv_data)\n                return AVERROR(ENOMEM);\n\n            size = avio_rb32(pb);\n            codec_pos = avio_tell(pb);\n\n            ffio_ensure_seekback(pb, 4);\n            v = avio_rb32(pb);\n            if (v == MKBETAG('M', 'L', 'T', 'I')) {\n                ret = rm_read_multi(s, s->pb, st, mime);\n                if (ret < 0)\n                    goto fail;\n                avio_seek(pb, codec_pos + size, SEEK_SET);\n            } else {\n                avio_skip(pb, -4);\n                if (ff_rm_read_mdpr_codecdata(s, s->pb, st, st->priv_data,\n                                              size, mime) < 0)\n                    goto fail;\n            }\n\n            break;\n        case MKTAG('D', 'A', 'T', 'A'):\n            goto header_end;\n        default:\n            /* unknown tag: skip it */\n            avio_skip(pb, tag_size - 10);\n            break;\n        }\n    }\n header_end:\n    rm->nb_packets = avio_rb32(pb); /* number of packets */\n    if (!rm->nb_packets && (flags & 4))\n        rm->nb_packets = 3600 * 25;\n    avio_rb32(pb); /* next data header */\n\n    if (!data_off)\n        data_off = avio_tell(pb) - 18;\n    if (indx_off && (pb->seekable & AVIO_SEEKABLE_NORMAL) &&\n        !(s->flags & AVFMT_FLAG_IGNIDX) &&\n        avio_seek(pb, indx_off, SEEK_SET) >= 0) {\n        rm_read_index(s);\n        avio_seek(pb, data_off + 18, SEEK_SET);\n    }\n\n    return 0;\n\nfail:\n    rm_read_close(s);\n    return ret;\n}\n\nstatic int get_num(AVIOContext *pb, int *len)\n{\n    int n, n1;\n\n    n = avio_rb16(pb);\n    (*len)-=2;\n    n &= 0x7FFF;\n    if (n >= 0x4000) {\n        return n - 0x4000;\n    } else {\n        n1 = avio_rb16(pb);\n        (*len)-=2;\n        return (n << 16) | n1;\n    }\n}\n\n/* multiple of 20 bytes for ra144 (ugly) */\n#define RAW_PACKET_SIZE 1000\n\nstatic int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    /* some files don't add index entries to chunk size... */\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; // we already read part of the index header\n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); /* flags */\n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            /* skip packet if unknown number */\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n\n        return len;\n    }\n    return -1;\n}\n\nstatic int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb,\n                                   RMDemuxContext *rm, RMStream *vst,\n                                   AVPacket *pkt, int len, int *pseq,\n                                   int64_t *timestamp)\n{\n    int hdr;\n    int seq = 0, pic_num = 0, len2 = 0, pos = 0; //init to silence compiler warning\n    int type;\n    int ret;\n\n    hdr = avio_r8(pb); len--;\n    type = hdr >> 6;\n\n    if(type != 3){  // not frame as a part of packet\n        seq = avio_r8(pb); len--;\n    }\n    if(type != 1){  // not whole frame\n        len2 = get_num(pb, &len);\n        pos  = get_num(pb, &len);\n        pic_num = avio_r8(pb); len--;\n    }\n    if(len<0) {\n        av_log(s, AV_LOG_ERROR, \"Insufficient data\\n\");\n        return -1;\n    }\n    rm->remaining_len = len;\n    if(type&1){     // frame, not slice\n        if(type == 3){  // frame as a part of packet\n            len= len2;\n            *timestamp = pos;\n        }\n        if(rm->remaining_len < len) {\n            av_log(s, AV_LOG_ERROR, \"Insufficient remaining len\\n\");\n            return -1;\n        }\n        rm->remaining_len -= len;\n        if(av_new_packet(pkt, len + 9) < 0)\n            return AVERROR(EIO);\n        pkt->data[0] = 0;\n        AV_WL32(pkt->data + 1, 1);\n        AV_WL32(pkt->data + 5, 0);\n        if ((ret = avio_read(pb, pkt->data + 9, len)) != len) {\n            av_packet_unref(pkt);\n            av_log(s, AV_LOG_ERROR, \"Failed to read %d bytes\\n\", len);\n            return ret < 0 ? ret : AVERROR(EIO);\n        }\n        return 0;\n    }\n    //now we have to deal with single slice\n\n    *pseq = seq;\n    if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){\n        if (len2 > ffio_limit(pb, len2)) {\n            av_log(s, AV_LOG_ERROR, \"Impossibly sized packet\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        vst->slices = ((hdr & 0x3F) << 1) + 1;\n        vst->videobufsize = len2 + 8*vst->slices + 1;\n        av_packet_unref(&vst->pkt); //FIXME this should be output.\n        if(av_new_packet(&vst->pkt, vst->videobufsize) < 0)\n            return AVERROR(ENOMEM);\n        memset(vst->pkt.data, 0, vst->pkt.size);\n        vst->videobufpos = 8*vst->slices + 1;\n        vst->cur_slice = 0;\n        vst->curpic_num = pic_num;\n        vst->pktpos = avio_tell(pb);\n    }\n    if(type == 2)\n        len = FFMIN(len, pos);\n\n    if(++vst->cur_slice > vst->slices) {\n        av_log(s, AV_LOG_ERROR, \"cur slice %d, too large\\n\", vst->cur_slice);\n        return 1;\n    }\n    if(!vst->pkt.data)\n        return AVERROR(ENOMEM);\n    AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1);\n    AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1);\n    if(vst->videobufpos + len > vst->videobufsize) {\n        av_log(s, AV_LOG_ERROR, \"outside videobufsize\\n\");\n        return 1;\n    }\n    if (avio_read(pb, vst->pkt.data + vst->videobufpos, len) != len)\n        return AVERROR(EIO);\n    vst->videobufpos += len;\n    rm->remaining_len-= len;\n\n    if (type == 2 || vst->videobufpos == vst->videobufsize) {\n        vst->pkt.data[0] = vst->cur_slice-1;\n        *pkt= vst->pkt;\n        vst->pkt.data= NULL;\n        vst->pkt.size= 0;\n        vst->pkt.buf = NULL;\n        if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n            memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n                vst->videobufpos - 1 - 8*vst->slices);\n        pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices);\n        pkt->pts = AV_NOPTS_VALUE;\n        pkt->pos = vst->pktpos;\n        vst->slices = 0;\n        return 0;\n    }\n\n    return 1;\n}\n\nstatic inline void\nrm_ac3_swap_bytes (AVStream *st, AVPacket *pkt)\n{\n    uint8_t *ptr;\n    int j;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_AC3) {\n        ptr = pkt->data;\n        for (j=0;j<pkt->size;j+=2) {\n            FFSWAP(int, ptr[0], ptr[1]);\n            ptr += 2;\n        }\n    }\n}\n\nstatic int readfull(AVFormatContext *s, AVIOContext *pb, uint8_t *dst, int n) {\n    int ret = avio_read(pb, dst, n);\n    if (ret != n) {\n        if (ret >= 0) memset(dst + ret, 0, n - ret);\n        else          memset(dst      , 0, n);\n        av_log(s, AV_LOG_ERROR, \"Failed to fully read block\\n\");\n    }\n    return ret;\n}\n\nint\nff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n                    int *seq, int flags, int64_t timestamp)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        rm->current_stream= st->id;\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n        if(ret)\n            return ret < 0 ? ret : -1; //got partial frame or error\n    } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n            (ast->deint_id == DEINT_ID_INT4) ||\n            (ast->deint_id == DEINT_ID_SIPR)) {\n            int x;\n            int sps = ast->sub_packet_size;\n            int cfs = ast->coded_framesize;\n            int h = ast->sub_packet_h;\n            int y = ast->sub_packet_cnt;\n            int w = ast->audio_framesize;\n\n            if (flags & 2)\n                y = ast->sub_packet_cnt = 0;\n            if (!y)\n                ast->audiotimestamp = timestamp;\n\n            switch (ast->deint_id) {\n                case DEINT_ID_INT4:\n                    for (x = 0; x < h/2; x++)\n                        readfull(s, pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n                    break;\n                case DEINT_ID_GENR:\n                    for (x = 0; x < w/sps; x++)\n                        readfull(s, pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n                    break;\n                case DEINT_ID_SIPR:\n                    readfull(s, pb, ast->pkt.data + y * w, w);\n                    break;\n            }\n\n            if (++(ast->sub_packet_cnt) < h)\n                return -1;\n            if (ast->deint_id == DEINT_ID_SIPR)\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n             ast->sub_packet_cnt = 0;\n             rm->audio_stream_num = st->index;\n            if (st->codecpar->block_align <= 0) {\n                av_log(s, AV_LOG_ERROR, \"Invalid block alignment %d\\n\", st->codecpar->block_align);\n                return AVERROR_INVALIDDATA;\n            }\n             rm->audio_pkt_cnt = h * w / st->codecpar->block_align;\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n            int x;\n            rm->audio_stream_num = st->index;\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n            if (ast->sub_packet_cnt) {\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n                ast->audiotimestamp = timestamp;\n            } else\n                return -1;\n        } else {\n            ret = av_get_packet(pb, pkt, len);\n            if (ret < 0)\n                return ret;\n            rm_ac3_swap_bytes(st, pkt);\n        }\n    } else {\n        ret = av_get_packet(pb, pkt, len);\n        if (ret < 0)\n            return ret;\n    }\n\n    pkt->stream_index = st->index;\n\n    pkt->pts = timestamp;\n    if (flags & 2)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    return st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n}\n\nint\nff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n                      AVStream *st, RMStream *ast, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n\n    av_assert0 (rm->audio_pkt_cnt > 0);\n\n    if (ast->deint_id == DEINT_ID_VBRF ||\n        ast->deint_id == DEINT_ID_VBRS) {\n        ret = av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]);\n        if (ret < 0)\n            return ret;\n    } else {\n        ret = av_new_packet(pkt, st->codecpar->block_align);\n        if (ret < 0)\n            return ret;\n        memcpy(pkt->data, ast->pkt.data + st->codecpar->block_align * //FIXME avoid this\n               (ast->sub_packet_h * ast->audio_framesize / st->codecpar->block_align - rm->audio_pkt_cnt),\n               st->codecpar->block_align);\n    }\n    rm->audio_pkt_cnt--;\n    if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) {\n        ast->audiotimestamp = AV_NOPTS_VALUE;\n        pkt->flags = AV_PKT_FLAG_KEY;\n    } else\n        pkt->flags = 0;\n    pkt->stream_index = st->index;\n\n    return rm->audio_pkt_cnt;\n}\n\nstatic int rm_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st = NULL; // init to silence compiler warning\n    int i, len, res, seq = 1;\n    int64_t timestamp, pos;\n    int flags;\n\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            // If there are queued audio packet return them first\n            st = s->streams[rm->audio_stream_num];\n            res = ff_rm_retrieve_cache(s, s->pb, st, st->priv_data, pkt);\n            if(res < 0)\n                return res;\n            flags = 0;\n        } else {\n            if (rm->old_format) {\n                RMStream *ast;\n\n                st = s->streams[0];\n                ast = st->priv_data;\n                timestamp = AV_NOPTS_VALUE;\n                len = !ast->audio_framesize ? RAW_PACKET_SIZE :\n                    ast->coded_framesize * ast->sub_packet_h / 2;\n                flags = (seq++ == 1) ? 2 : 0;\n                pos = avio_tell(s->pb);\n            } else {\n                len = rm_sync(s, &timestamp, &flags, &i, &pos);\n                if (len > 0)\n                    st = s->streams[i];\n            }\n\n            if (avio_feof(s->pb))\n                return AVERROR_EOF;\n            if (len <= 0)\n                return AVERROR(EIO);\n\n            res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,\n                                      &seq, flags, timestamp);\n            if (res < -1)\n                return res;\n            if((flags&2) && (seq&0x7F) == 1)\n                av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);\n            if (res)\n                continue;\n        }\n\n        if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))\n           || st->discard >= AVDISCARD_ALL){\n            av_packet_unref(pkt);\n        } else\n            break;\n    }\n\n    return 0;\n}\n\nstatic int rm_read_close(AVFormatContext *s)\n{\n    int i;\n\n    for (i=0;i<s->nb_streams;i++)\n        ff_rm_free_rmstream(s->streams[i]->priv_data);\n\n    return 0;\n}\n\nstatic int rm_probe(AVProbeData *p)\n{\n    /* check file header */\n    if ((p->buf[0] == '.' && p->buf[1] == 'R' &&\n         p->buf[2] == 'M' && p->buf[3] == 'F' &&\n         p->buf[4] == 0 && p->buf[5] == 0) ||\n        (p->buf[0] == '.' && p->buf[1] == 'r' &&\n         p->buf[2] == 'a' && p->buf[3] == 0xfd))\n        return AVPROBE_SCORE_MAX;\n    else\n        return 0;\n}\n\nstatic int64_t rm_read_dts(AVFormatContext *s, int stream_index,\n                               int64_t *ppos, int64_t pos_limit)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int64_t pos, dts;\n    int stream_index2, flags, len, h;\n\n    pos = *ppos;\n\n    if(rm->old_format)\n        return AV_NOPTS_VALUE;\n\n    if (avio_seek(s->pb, pos, SEEK_SET) < 0)\n        return AV_NOPTS_VALUE;\n\n    rm->remaining_len=0;\n    for(;;){\n        int seq=1;\n        AVStream *st;\n\n        len = rm_sync(s, &dts, &flags, &stream_index2, &pos);\n        if(len<0)\n            return AV_NOPTS_VALUE;\n\n        st = s->streams[stream_index2];\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            h= avio_r8(s->pb); len--;\n            if(!(h & 0x40)){\n                seq = avio_r8(s->pb); len--;\n            }\n        }\n\n        if((flags&2) && (seq&0x7F) == 1){\n            av_log(s, AV_LOG_TRACE, \"%d %d-%d %\"PRId64\" %d\\n\",\n                    flags, stream_index2, stream_index, dts, seq);\n            av_add_index_entry(st, pos, dts, 0, 0, AVINDEX_KEYFRAME);\n            if(stream_index2 == stream_index)\n                break;\n        }\n\n        avio_skip(s->pb, len);\n    }\n    *ppos = pos;\n    return dts;\n}\n\nstatic int rm_read_seek(AVFormatContext *s, int stream_index,\n                        int64_t pts, int flags)\n{\n    RMDemuxContext *rm = s->priv_data;\n\n    if (ff_seek_frame_binary(s, stream_index, pts, flags) < 0)\n        return -1;\n    rm->audio_pkt_cnt = 0;\n    return 0;\n}\n\n\nAVInputFormat ff_rm_demuxer = {\n    .name           = \"rm\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"RealMedia\"),\n    .priv_data_size = sizeof(RMDemuxContext),\n    .read_probe     = rm_probe,\n    .read_header    = rm_read_header,\n    .read_packet    = rm_read_packet,\n    .read_close     = rm_read_close,\n    .read_timestamp = rm_read_dts,\n    .read_seek      = rm_read_seek,\n};\n\nAVInputFormat ff_rdt_demuxer = {\n    .name           = \"rdt\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"RDT demuxer\"),\n    .priv_data_size = sizeof(RMDemuxContext),\n    .read_close     = rm_read_close,\n    .flags          = AVFMT_NOFILE,\n};\n\nstatic int ivr_probe(AVProbeData *p)\n{\n    if (memcmp(p->buf, \".R1M\\x0\\x1\\x1\", 7) &&\n        memcmp(p->buf, \".REC\", 4))\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\nstatic int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n            for (j = 0; j < len; j++) {\n                if (avio_feof(pb))\n                    return AVERROR_INVALIDDATA;\n                av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n            }\n            av_log(s, AV_LOG_DEBUG, \"'\\n\");\n        } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n        for (i = 0; i < count; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n\n            type = avio_r8(pb);\n            tlen  = avio_rb32(pb);\n            avio_get_str(pb, tlen, key, sizeof(key));\n            len  = avio_rb32(pb);\n            if (type == 5) {\n                avio_get_str(pb, len, val, sizeof(val));\n                av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n            } else if (type == 4 && !strncmp(key, \"OpaqueData\", tlen)) {\n                ret = ffio_ensure_seekback(pb, 4);\n                if (ret < 0)\n                    return ret;\n                if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {\n                    ret = rm_read_multi(s, pb, st, NULL);\n                } else {\n                    avio_seek(pb, -4, SEEK_CUR);\n                    ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);\n                }\n\n                if (ret < 0)\n                    return ret;\n            } else if (type == 4) {\n                int j;\n\n                av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n                for (j = 0; j < len; j++)\n                    av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n                av_log(s, AV_LOG_DEBUG, \"'\\n\");\n            } else if (len == 4 && type == 3 && !strncmp(key, \"Duration\", tlen)) {\n                st->duration = avio_rb32(pb);\n            } else if (len == 4 && type == 3) {\n                value = avio_rb32(pb);\n                av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n                avio_skip(pb, len);\n            }\n        }\n    }\n\n    if (avio_r8(pb) != 6)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12);\n    avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));\n    if (avio_r8(pb) != 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8);\n\n    return 0;\n}\n\nstatic int ivr_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret = AVERROR_EOF, opcode;\n    AVIOContext *pb = s->pb;\n    unsigned size, index;\n    int64_t pos, pts;\n\n    if (avio_feof(pb) || rm->data_end)\n        return AVERROR_EOF;\n\n    pos = avio_tell(pb);\n\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            // If there are queued audio packet return them first\n            AVStream *st;\n\n            st = s->streams[rm->audio_stream_num];\n            ret = ff_rm_retrieve_cache(s, pb, st, st->priv_data, pkt);\n            if (ret < 0) {\n                return ret;\n            }\n        } else {\n            if (rm->remaining_len) {\n                avio_skip(pb, rm->remaining_len);\n                rm->remaining_len = 0;\n            }\n\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n\n            opcode = avio_r8(pb);\n            if (opcode == 2) {\n                AVStream *st;\n                int seq = 1;\n\n                pts = avio_rb32(pb);\n                index = avio_rb16(pb);\n                if (index >= s->nb_streams)\n                    return AVERROR_INVALIDDATA;\n\n                avio_skip(pb, 4);\n                size = avio_rb32(pb);\n                avio_skip(pb, 4);\n\n                if (size < 1 || size > INT_MAX/4) {\n                    av_log(s, AV_LOG_ERROR, \"size %u is invalid\\n\", size);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                st = s->streams[index];\n                ret = ff_rm_parse_packet(s, pb, st, st->priv_data, size, pkt,\n                                         &seq, 0, pts);\n                if (ret < -1) {\n                    return ret;\n                } else if (ret) {\n                    continue;\n                }\n\n                pkt->pos = pos;\n                pkt->pts = pts;\n                pkt->stream_index = index;\n            } else if (opcode == 7) {\n                pos = avio_rb64(pb);\n                if (!pos) {\n                    rm->data_end = 1;\n                    return AVERROR_EOF;\n                }\n            } else {\n                av_log(s, AV_LOG_ERROR, \"Unsupported opcode=%d at %\"PRIX64\"\\n\", opcode, avio_tell(pb) - 1);\n                return AVERROR(EIO);\n            }\n        }\n\n        break;\n    }\n\n    return ret;\n}\n\nAVInputFormat ff_ivr_demuxer = {\n    .name           = \"ivr\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"IVR (Internet Video Recording)\"),\n    .priv_data_size = sizeof(RMDemuxContext),\n    .read_probe     = ivr_probe,\n    .read_header    = ivr_read_header,\n    .read_packet    = ivr_read_packet,\n    .read_close     = rm_read_close,\n    .extensions     = \"ivr\",\n};\n"], "fixing_code": ["/*\n * \"Real\" compatible demuxer.\n * Copyright (c) 2000, 2001 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/dict.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"internal.h\"\n#include \"rmsipr.h\"\n#include \"rm.h\"\n\n#define DEINT_ID_GENR MKTAG('g', 'e', 'n', 'r') ///< interleaving for Cooker/ATRAC\n#define DEINT_ID_INT0 MKTAG('I', 'n', 't', '0') ///< no interleaving needed\n#define DEINT_ID_INT4 MKTAG('I', 'n', 't', '4') ///< interleaving for 28.8\n#define DEINT_ID_SIPR MKTAG('s', 'i', 'p', 'r') ///< interleaving for Sipro\n#define DEINT_ID_VBRF MKTAG('v', 'b', 'r', 'f') ///< VBR case for AAC\n#define DEINT_ID_VBRS MKTAG('v', 'b', 'r', 's') ///< VBR case for AAC\n\nstruct RMStream {\n    AVPacket pkt;      ///< place to store merged video frame / reordered audio data\n    int videobufsize;  ///< current assembled frame size\n    int videobufpos;   ///< position for the next slice in the video buffer\n    int curpic_num;    ///< picture number of current frame\n    int cur_slice, slices;\n    int64_t pktpos;    ///< first slice position in file\n    /// Audio descrambling matrix parameters\n    int64_t audiotimestamp; ///< Audio packet timestamp\n    int sub_packet_cnt; // Subpacket counter, used while reading\n    int sub_packet_size, sub_packet_h, coded_framesize; ///< Descrambling parameters from container\n    int audio_framesize; /// Audio frame size from container\n    int sub_packet_lengths[16]; /// Length of each subpacket\n    int32_t deint_id;  ///< deinterleaver used in audio stream\n};\n\ntypedef struct RMDemuxContext {\n    int nb_packets;\n    int old_format;\n    int current_stream;\n    int remaining_len;\n    int audio_stream_num; ///< Stream number for audio packets\n    int audio_pkt_cnt; ///< Output packet counter\n    int data_end;\n} RMDemuxContext;\n\nstatic int rm_read_close(AVFormatContext *s);\n\nstatic inline void get_strl(AVIOContext *pb, char *buf, int buf_size, int len)\n{\n    int read = avio_get_str(pb, len, buf, buf_size);\n\n    if (read > 0)\n        avio_skip(pb, len - read);\n}\n\nstatic void get_str8(AVIOContext *pb, char *buf, int buf_size)\n{\n    get_strl(pb, buf, buf_size, avio_r8(pb));\n}\n\nstatic int rm_read_extradata(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, unsigned size)\n{\n    if (size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"extradata size %u too large\\n\", size);\n        return -1;\n    }\n    if (ff_get_extradata(s, par, pb, size) < 0)\n        return AVERROR(ENOMEM);\n    return 0;\n}\n\nstatic void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide)\n{\n    char buf[1024];\n    int i;\n\n    for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) {\n        int len = wide ? avio_rb16(pb) : avio_r8(pb);\n        if (len > 0) {\n            get_strl(pb, buf, sizeof(buf), len);\n            av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0);\n        }\n    }\n}\n\nRMStream *ff_rm_alloc_rmstream (void)\n{\n    RMStream *rms = av_mallocz(sizeof(RMStream));\n    if (!rms)\n        return NULL;\n    rms->curpic_num = -1;\n    return rms;\n}\n\nvoid ff_rm_free_rmstream (RMStream *rms)\n{\n    av_packet_unref(&rms->pkt);\n}\n\nstatic int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n                                     AVStream *st, RMStream *ast, int read_all)\n{\n    char buf[256];\n    uint32_t version;\n    int ret;\n\n    /* ra type header */\n    version = avio_rb16(pb); /* version */\n    if (version == 3) {\n        unsigned bytes_per_minute;\n        int header_size = avio_rb16(pb);\n        int64_t startpos = avio_tell(pb);\n        avio_skip(pb, 8);\n        bytes_per_minute = avio_rb16(pb);\n        avio_skip(pb, 4);\n        rm_read_metadata(s, pb, 0);\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n            // fourcc (should always be \"lpcJ\")\n            avio_r8(pb);\n            get_str8(pb, buf, sizeof(buf));\n        }\n        // Skip extra header crap (this should never happen)\n        if ((startpos + header_size) > avio_tell(pb))\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n        if (bytes_per_minute)\n            st->codecpar->bit_rate = 8LL * bytes_per_minute / 60;\n        st->codecpar->sample_rate = 8000;\n        st->codecpar->channels = 1;\n        st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_RA_144;\n        ast->deint_id = DEINT_ID_INT0;\n    } else {\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n        int codecdata_length;\n        unsigned bytes_per_minute;\n        /* old version (4) */\n        avio_skip(pb, 2); /* unused */\n        avio_rb32(pb); /* .ra4 */\n        avio_rb32(pb); /* data size */\n        avio_rb16(pb); /* version2 */\n        avio_rb32(pb); /* header size */\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n        avio_rb32(pb); /* ??? */\n        bytes_per_minute = avio_rb32(pb);\n        if (version == 4) {\n            if (bytes_per_minute)\n                st->codecpar->bit_rate = 8LL * bytes_per_minute / 60;\n        }\n        avio_rb32(pb); /* ??? */\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n        st->codecpar->block_align= avio_rb16(pb); /* frame size */\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n        avio_rb16(pb); /* ??? */\n        if (version == 5) {\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n        }\n        st->codecpar->sample_rate = avio_rb16(pb);\n        avio_rb32(pb);\n        st->codecpar->channels = avio_rb16(pb);\n        if (version == 5) {\n            ast->deint_id = avio_rl32(pb);\n            avio_read(pb, buf, 4);\n            buf[4] = 0;\n        } else {\n            AV_WL32(buf, 0);\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n            ast->deint_id = AV_RL32(buf);\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n        }\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_tag  = AV_RL32(buf);\n        st->codecpar->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                   st->codecpar->codec_tag);\n\n        switch (st->codecpar->codec_id) {\n        case AV_CODEC_ID_AC3:\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n            break;\n        case AV_CODEC_ID_RA_288:\n            st->codecpar->extradata_size= 0;\n            av_freep(&st->codecpar->extradata);\n            ast->audio_framesize = st->codecpar->block_align;\n            st->codecpar->block_align = coded_framesize;\n            break;\n        case AV_CODEC_ID_COOK:\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n        case AV_CODEC_ID_ATRAC3:\n        case AV_CODEC_ID_SIPR:\n            if (read_all) {\n                codecdata_length = 0;\n            } else {\n                avio_rb16(pb); avio_r8(pb);\n                if (version == 5)\n                    avio_r8(pb);\n                codecdata_length = avio_rb32(pb);\n                if(codecdata_length + AV_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                    return -1;\n                }\n            }\n\n            ast->audio_framesize = st->codecpar->block_align;\n            if (st->codecpar->codec_id == AV_CODEC_ID_SIPR) {\n                if (flavor > 3) {\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n                           flavor);\n                    return -1;\n                }\n                st->codecpar->block_align = ff_sipr_subpk_size[flavor];\n                st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n            } else {\n                if(sub_packet_size <= 0){\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n                    return -1;\n                }\n                st->codecpar->block_align = ast->sub_packet_size;\n            }\n            if ((ret = rm_read_extradata(s, pb, st->codecpar, codecdata_length)) < 0)\n                return ret;\n\n            break;\n        case AV_CODEC_ID_AAC:\n            avio_rb16(pb); avio_r8(pb);\n            if (version == 5)\n                avio_r8(pb);\n            codecdata_length = avio_rb32(pb);\n            if(codecdata_length + AV_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                return -1;\n            }\n            if (codecdata_length >= 1) {\n                avio_r8(pb);\n                if ((ret = rm_read_extradata(s, pb, st->codecpar, codecdata_length - 1)) < 0)\n                    return ret;\n            }\n            break;\n        }\n        switch (ast->deint_id) {\n        case DEINT_ID_INT4:\n            if (ast->coded_framesize > ast->audio_framesize ||\n                sub_packet_h <= 1 ||\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n                return AVERROR_INVALIDDATA;\n            if (ast->coded_framesize * sub_packet_h != 2*ast->audio_framesize) {\n                avpriv_request_sample(s, \"mismatching interleaver parameters\");\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case DEINT_ID_GENR:\n            if (ast->sub_packet_size <= 0 ||\n                ast->sub_packet_size > ast->audio_framesize)\n                return AVERROR_INVALIDDATA;\n            if (ast->audio_framesize % ast->sub_packet_size)\n                return AVERROR_INVALIDDATA;\n            break;\n        case DEINT_ID_SIPR:\n        case DEINT_ID_INT0:\n        case DEINT_ID_VBRS:\n        case DEINT_ID_VBRF:\n            break;\n        default:\n            av_log(s, AV_LOG_ERROR ,\"Unknown interleaver %\"PRIX32\"\\n\", ast->deint_id);\n            return AVERROR_INVALIDDATA;\n        }\n        if (ast->deint_id == DEINT_ID_INT4 ||\n            ast->deint_id == DEINT_ID_GENR ||\n            ast->deint_id == DEINT_ID_SIPR) {\n            if (st->codecpar->block_align <= 0 ||\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n                ast->audio_framesize * sub_packet_h < st->codecpar->block_align)\n                return AVERROR_INVALIDDATA;\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n                return AVERROR(ENOMEM);\n        }\n\n        if (read_all) {\n            avio_r8(pb);\n            avio_r8(pb);\n            avio_r8(pb);\n            rm_read_metadata(s, pb, 0);\n        }\n    }\n    return 0;\n}\n\nint ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    if (codec_data_size == 0)\n        return 0;\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(s, pb, st->codecpar, codec_data_size)) < 0)\n            return ret;\n\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_tag  = AV_RL32(st->codecpar->extradata);\n        st->codecpar->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codecpar->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codecpar->codec_tag = avio_rl32(pb);\n        st->codecpar->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                                  st->codecpar->codec_tag);\n        av_log(s, AV_LOG_TRACE, \"%\"PRIX32\" %X\\n\",\n               st->codecpar->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codecpar->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codecpar->width  = avio_rb16(pb);\n        st->codecpar->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n\n        if ((ret = rm_read_extradata(s, pb, st->codecpar, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    if (codec_data_size >= size) {\n        avio_skip(pb, codec_data_size - size);\n    } else {\n        av_log(s, AV_LOG_WARNING, \"codec_data_size %u < size %d\\n\", codec_data_size, size);\n    }\n\n    return 0;\n}\n\n/** this function assumes that the demuxer has already seeked to the start\n * of the INDX chunk, and will bail out if not. */\nstatic int rm_read_index(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    unsigned int size, n_pkts, str_id, next_off, n, pos, pts;\n    AVStream *st;\n\n    do {\n        if (avio_rl32(pb) != MKTAG('I','N','D','X'))\n            return -1;\n        size     = avio_rb32(pb);\n        if (size < 20)\n            return -1;\n        avio_skip(pb, 2);\n        n_pkts   = avio_rb32(pb);\n        str_id   = avio_rb16(pb);\n        next_off = avio_rb32(pb);\n        for (n = 0; n < s->nb_streams; n++)\n            if (s->streams[n]->id == str_id) {\n                st = s->streams[n];\n                break;\n            }\n        if (n == s->nb_streams) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Invalid stream index %d for index at pos %\"PRId64\"\\n\",\n                   str_id, avio_tell(pb));\n            goto skip;\n        } else if ((avio_size(pb) - avio_tell(pb)) / 14 < n_pkts) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Nr. of packets in packet index for stream index %d \"\n                   \"exceeds filesize (%\"PRId64\" at %\"PRId64\" = %\"PRId64\")\\n\",\n                   str_id, avio_size(pb), avio_tell(pb),\n                   (avio_size(pb) - avio_tell(pb)) / 14);\n            goto skip;\n        }\n\n        for (n = 0; n < n_pkts; n++) {\n            avio_skip(pb, 2);\n            pts = avio_rb32(pb);\n            pos = avio_rb32(pb);\n            avio_skip(pb, 4); /* packet no. */\n\n            av_add_index_entry(st, pos, pts, 0, 0, AVINDEX_KEYFRAME);\n        }\n\nskip:\n        if (next_off && avio_tell(pb) < next_off &&\n            avio_seek(pb, next_off, SEEK_SET) < 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Non-linear index detected, not supported\\n\");\n            return -1;\n        }\n    } while (next_off);\n\n    return 0;\n}\n\nstatic int rm_read_header_old(AVFormatContext *s)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st;\n\n    rm->old_format = 1;\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return -1;\n    st->priv_data = ff_rm_alloc_rmstream();\n    if (!st->priv_data)\n        return AVERROR(ENOMEM);\n    return rm_read_audio_stream_info(s, s->pb, st, st->priv_data, 1);\n}\n\nstatic int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, NULL);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}\n\nstatic int rm_read_header(AVFormatContext *s)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st;\n    AVIOContext *pb = s->pb;\n    unsigned int tag;\n    int tag_size;\n    unsigned int start_time, duration;\n    unsigned int data_off = 0, indx_off = 0;\n    char buf[128], mime[128];\n    int flags = 0;\n    int ret = -1;\n    unsigned size, v;\n    int64_t codec_pos;\n\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.', 'r', 'a', 0xfd)) {\n        /* very old .ra format */\n        return rm_read_header_old(s);\n    } else if (tag != MKTAG('.', 'R', 'M', 'F')) {\n        return AVERROR(EIO);\n    }\n\n    tag_size = avio_rb32(pb);\n    avio_skip(pb, tag_size - 8);\n\n    for(;;) {\n        if (avio_feof(pb))\n            goto fail;\n        tag = avio_rl32(pb);\n        tag_size = avio_rb32(pb);\n        avio_rb16(pb);\n        av_log(s, AV_LOG_TRACE, \"tag=%s size=%d\\n\",\n               av_fourcc2str(tag), tag_size);\n        if (tag_size < 10 && tag != MKTAG('D', 'A', 'T', 'A'))\n            goto fail;\n        switch(tag) {\n        case MKTAG('P', 'R', 'O', 'P'):\n            /* file header */\n            avio_rb32(pb); /* max bit rate */\n            avio_rb32(pb); /* avg bit rate */\n            avio_rb32(pb); /* max packet size */\n            avio_rb32(pb); /* avg packet size */\n            avio_rb32(pb); /* nb packets */\n            duration = avio_rb32(pb); /* duration */\n            s->duration = av_rescale(duration, AV_TIME_BASE, 1000);\n            avio_rb32(pb); /* preroll */\n            indx_off = avio_rb32(pb); /* index offset */\n            data_off = avio_rb32(pb); /* data offset */\n            avio_rb16(pb); /* nb streams */\n            flags = avio_rb16(pb); /* flags */\n            break;\n        case MKTAG('C', 'O', 'N', 'T'):\n            rm_read_metadata(s, pb, 1);\n            break;\n        case MKTAG('M', 'D', 'P', 'R'):\n            st = avformat_new_stream(s, NULL);\n            if (!st) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            st->id = avio_rb16(pb);\n            avio_rb32(pb); /* max bit rate */\n            st->codecpar->bit_rate = avio_rb32(pb); /* bit rate */\n            avio_rb32(pb); /* max packet size */\n            avio_rb32(pb); /* avg packet size */\n            start_time = avio_rb32(pb); /* start time */\n            avio_rb32(pb); /* preroll */\n            duration = avio_rb32(pb); /* duration */\n            st->start_time = start_time;\n            st->duration = duration;\n            if(duration>0)\n                s->duration = AV_NOPTS_VALUE;\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n            get_str8(pb, mime, sizeof(mime)); /* mimetype */\n            st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st->priv_data = ff_rm_alloc_rmstream();\n            if (!st->priv_data)\n                return AVERROR(ENOMEM);\n\n            size = avio_rb32(pb);\n            codec_pos = avio_tell(pb);\n\n            ffio_ensure_seekback(pb, 4);\n            v = avio_rb32(pb);\n            if (v == MKBETAG('M', 'L', 'T', 'I')) {\n                ret = rm_read_multi(s, s->pb, st, mime);\n                if (ret < 0)\n                    goto fail;\n                avio_seek(pb, codec_pos + size, SEEK_SET);\n            } else {\n                avio_skip(pb, -4);\n                if (ff_rm_read_mdpr_codecdata(s, s->pb, st, st->priv_data,\n                                              size, mime) < 0)\n                    goto fail;\n            }\n\n            break;\n        case MKTAG('D', 'A', 'T', 'A'):\n            goto header_end;\n        default:\n            /* unknown tag: skip it */\n            avio_skip(pb, tag_size - 10);\n            break;\n        }\n    }\n header_end:\n    rm->nb_packets = avio_rb32(pb); /* number of packets */\n    if (!rm->nb_packets && (flags & 4))\n        rm->nb_packets = 3600 * 25;\n    avio_rb32(pb); /* next data header */\n\n    if (!data_off)\n        data_off = avio_tell(pb) - 18;\n    if (indx_off && (pb->seekable & AVIO_SEEKABLE_NORMAL) &&\n        !(s->flags & AVFMT_FLAG_IGNIDX) &&\n        avio_seek(pb, indx_off, SEEK_SET) >= 0) {\n        rm_read_index(s);\n        avio_seek(pb, data_off + 18, SEEK_SET);\n    }\n\n    return 0;\n\nfail:\n    rm_read_close(s);\n    return ret;\n}\n\nstatic int get_num(AVIOContext *pb, int *len)\n{\n    int n, n1;\n\n    n = avio_rb16(pb);\n    (*len)-=2;\n    n &= 0x7FFF;\n    if (n >= 0x4000) {\n        return n - 0x4000;\n    } else {\n        n1 = avio_rb16(pb);\n        (*len)-=2;\n        return (n << 16) | n1;\n    }\n}\n\n/* multiple of 20 bytes for ra144 (ugly) */\n#define RAW_PACKET_SIZE 1000\n\nstatic int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    /* some files don't add index entries to chunk size... */\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; // we already read part of the index header\n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); /* flags */\n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            /* skip packet if unknown number */\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n\n        return len;\n    }\n    return -1;\n}\n\nstatic int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb,\n                                   RMDemuxContext *rm, RMStream *vst,\n                                   AVPacket *pkt, int len, int *pseq,\n                                   int64_t *timestamp)\n{\n    int hdr;\n    int seq = 0, pic_num = 0, len2 = 0, pos = 0; //init to silence compiler warning\n    int type;\n    int ret;\n\n    hdr = avio_r8(pb); len--;\n    type = hdr >> 6;\n\n    if(type != 3){  // not frame as a part of packet\n        seq = avio_r8(pb); len--;\n    }\n    if(type != 1){  // not whole frame\n        len2 = get_num(pb, &len);\n        pos  = get_num(pb, &len);\n        pic_num = avio_r8(pb); len--;\n    }\n    if(len<0) {\n        av_log(s, AV_LOG_ERROR, \"Insufficient data\\n\");\n        return -1;\n    }\n    rm->remaining_len = len;\n    if(type&1){     // frame, not slice\n        if(type == 3){  // frame as a part of packet\n            len= len2;\n            *timestamp = pos;\n        }\n        if(rm->remaining_len < len) {\n            av_log(s, AV_LOG_ERROR, \"Insufficient remaining len\\n\");\n            return -1;\n        }\n        rm->remaining_len -= len;\n        if(av_new_packet(pkt, len + 9) < 0)\n            return AVERROR(EIO);\n        pkt->data[0] = 0;\n        AV_WL32(pkt->data + 1, 1);\n        AV_WL32(pkt->data + 5, 0);\n        if ((ret = avio_read(pb, pkt->data + 9, len)) != len) {\n            av_packet_unref(pkt);\n            av_log(s, AV_LOG_ERROR, \"Failed to read %d bytes\\n\", len);\n            return ret < 0 ? ret : AVERROR(EIO);\n        }\n        return 0;\n    }\n    //now we have to deal with single slice\n\n    *pseq = seq;\n    if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){\n        if (len2 > ffio_limit(pb, len2)) {\n            av_log(s, AV_LOG_ERROR, \"Impossibly sized packet\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        vst->slices = ((hdr & 0x3F) << 1) + 1;\n        vst->videobufsize = len2 + 8*vst->slices + 1;\n        av_packet_unref(&vst->pkt); //FIXME this should be output.\n        if(av_new_packet(&vst->pkt, vst->videobufsize) < 0)\n            return AVERROR(ENOMEM);\n        memset(vst->pkt.data, 0, vst->pkt.size);\n        vst->videobufpos = 8*vst->slices + 1;\n        vst->cur_slice = 0;\n        vst->curpic_num = pic_num;\n        vst->pktpos = avio_tell(pb);\n    }\n    if(type == 2)\n        len = FFMIN(len, pos);\n\n    if(++vst->cur_slice > vst->slices) {\n        av_log(s, AV_LOG_ERROR, \"cur slice %d, too large\\n\", vst->cur_slice);\n        return 1;\n    }\n    if(!vst->pkt.data)\n        return AVERROR(ENOMEM);\n    AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1);\n    AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1);\n    if(vst->videobufpos + len > vst->videobufsize) {\n        av_log(s, AV_LOG_ERROR, \"outside videobufsize\\n\");\n        return 1;\n    }\n    if (avio_read(pb, vst->pkt.data + vst->videobufpos, len) != len)\n        return AVERROR(EIO);\n    vst->videobufpos += len;\n    rm->remaining_len-= len;\n\n    if (type == 2 || vst->videobufpos == vst->videobufsize) {\n        vst->pkt.data[0] = vst->cur_slice-1;\n        *pkt= vst->pkt;\n        vst->pkt.data= NULL;\n        vst->pkt.size= 0;\n        vst->pkt.buf = NULL;\n        if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n            memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n                vst->videobufpos - 1 - 8*vst->slices);\n        pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices);\n        pkt->pts = AV_NOPTS_VALUE;\n        pkt->pos = vst->pktpos;\n        vst->slices = 0;\n        return 0;\n    }\n\n    return 1;\n}\n\nstatic inline void\nrm_ac3_swap_bytes (AVStream *st, AVPacket *pkt)\n{\n    uint8_t *ptr;\n    int j;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_AC3) {\n        ptr = pkt->data;\n        for (j=0;j<pkt->size;j+=2) {\n            FFSWAP(int, ptr[0], ptr[1]);\n            ptr += 2;\n        }\n    }\n}\n\nstatic int readfull(AVFormatContext *s, AVIOContext *pb, uint8_t *dst, int n) {\n    int ret = avio_read(pb, dst, n);\n    if (ret != n) {\n        if (ret >= 0) memset(dst + ret, 0, n - ret);\n        else          memset(dst      , 0, n);\n        av_log(s, AV_LOG_ERROR, \"Failed to fully read block\\n\");\n    }\n    return ret;\n}\n\nint\nff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n                    int *seq, int flags, int64_t timestamp)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        rm->current_stream= st->id;\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n        if(ret)\n            return ret < 0 ? ret : -1; //got partial frame or error\n    } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n            (ast->deint_id == DEINT_ID_INT4) ||\n            (ast->deint_id == DEINT_ID_SIPR)) {\n            int x;\n            int sps = ast->sub_packet_size;\n            int cfs = ast->coded_framesize;\n            int h = ast->sub_packet_h;\n            int y = ast->sub_packet_cnt;\n            int w = ast->audio_framesize;\n\n            if (flags & 2)\n                y = ast->sub_packet_cnt = 0;\n            if (!y)\n                ast->audiotimestamp = timestamp;\n\n            switch (ast->deint_id) {\n                case DEINT_ID_INT4:\n                    for (x = 0; x < h/2; x++)\n                        readfull(s, pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n                    break;\n                case DEINT_ID_GENR:\n                    for (x = 0; x < w/sps; x++)\n                        readfull(s, pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n                    break;\n                case DEINT_ID_SIPR:\n                    readfull(s, pb, ast->pkt.data + y * w, w);\n                    break;\n            }\n\n            if (++(ast->sub_packet_cnt) < h)\n                return -1;\n            if (ast->deint_id == DEINT_ID_SIPR)\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n             ast->sub_packet_cnt = 0;\n             rm->audio_stream_num = st->index;\n            if (st->codecpar->block_align <= 0) {\n                av_log(s, AV_LOG_ERROR, \"Invalid block alignment %d\\n\", st->codecpar->block_align);\n                return AVERROR_INVALIDDATA;\n            }\n             rm->audio_pkt_cnt = h * w / st->codecpar->block_align;\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n            int x;\n            rm->audio_stream_num = st->index;\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n            if (ast->sub_packet_cnt) {\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n                ast->audiotimestamp = timestamp;\n            } else\n                return -1;\n        } else {\n            ret = av_get_packet(pb, pkt, len);\n            if (ret < 0)\n                return ret;\n            rm_ac3_swap_bytes(st, pkt);\n        }\n    } else {\n        ret = av_get_packet(pb, pkt, len);\n        if (ret < 0)\n            return ret;\n    }\n\n    pkt->stream_index = st->index;\n\n    pkt->pts = timestamp;\n    if (flags & 2)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    return st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n}\n\nint\nff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n                      AVStream *st, RMStream *ast, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n\n    av_assert0 (rm->audio_pkt_cnt > 0);\n\n    if (ast->deint_id == DEINT_ID_VBRF ||\n        ast->deint_id == DEINT_ID_VBRS) {\n        ret = av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]);\n        if (ret < 0)\n            return ret;\n    } else {\n        ret = av_new_packet(pkt, st->codecpar->block_align);\n        if (ret < 0)\n            return ret;\n        memcpy(pkt->data, ast->pkt.data + st->codecpar->block_align * //FIXME avoid this\n               (ast->sub_packet_h * ast->audio_framesize / st->codecpar->block_align - rm->audio_pkt_cnt),\n               st->codecpar->block_align);\n    }\n    rm->audio_pkt_cnt--;\n    if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) {\n        ast->audiotimestamp = AV_NOPTS_VALUE;\n        pkt->flags = AV_PKT_FLAG_KEY;\n    } else\n        pkt->flags = 0;\n    pkt->stream_index = st->index;\n\n    return rm->audio_pkt_cnt;\n}\n\nstatic int rm_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st = NULL; // init to silence compiler warning\n    int i, len, res, seq = 1;\n    int64_t timestamp, pos;\n    int flags;\n\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            // If there are queued audio packet return them first\n            st = s->streams[rm->audio_stream_num];\n            res = ff_rm_retrieve_cache(s, s->pb, st, st->priv_data, pkt);\n            if(res < 0)\n                return res;\n            flags = 0;\n        } else {\n            if (rm->old_format) {\n                RMStream *ast;\n\n                st = s->streams[0];\n                ast = st->priv_data;\n                timestamp = AV_NOPTS_VALUE;\n                len = !ast->audio_framesize ? RAW_PACKET_SIZE :\n                    ast->coded_framesize * ast->sub_packet_h / 2;\n                flags = (seq++ == 1) ? 2 : 0;\n                pos = avio_tell(s->pb);\n            } else {\n                len = rm_sync(s, &timestamp, &flags, &i, &pos);\n                if (len > 0)\n                    st = s->streams[i];\n            }\n\n            if (avio_feof(s->pb))\n                return AVERROR_EOF;\n            if (len <= 0)\n                return AVERROR(EIO);\n\n            res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,\n                                      &seq, flags, timestamp);\n            if (res < -1)\n                return res;\n            if((flags&2) && (seq&0x7F) == 1)\n                av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);\n            if (res)\n                continue;\n        }\n\n        if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))\n           || st->discard >= AVDISCARD_ALL){\n            av_packet_unref(pkt);\n        } else\n            break;\n    }\n\n    return 0;\n}\n\nstatic int rm_read_close(AVFormatContext *s)\n{\n    int i;\n\n    for (i=0;i<s->nb_streams;i++)\n        ff_rm_free_rmstream(s->streams[i]->priv_data);\n\n    return 0;\n}\n\nstatic int rm_probe(AVProbeData *p)\n{\n    /* check file header */\n    if ((p->buf[0] == '.' && p->buf[1] == 'R' &&\n         p->buf[2] == 'M' && p->buf[3] == 'F' &&\n         p->buf[4] == 0 && p->buf[5] == 0) ||\n        (p->buf[0] == '.' && p->buf[1] == 'r' &&\n         p->buf[2] == 'a' && p->buf[3] == 0xfd))\n        return AVPROBE_SCORE_MAX;\n    else\n        return 0;\n}\n\nstatic int64_t rm_read_dts(AVFormatContext *s, int stream_index,\n                               int64_t *ppos, int64_t pos_limit)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int64_t pos, dts;\n    int stream_index2, flags, len, h;\n\n    pos = *ppos;\n\n    if(rm->old_format)\n        return AV_NOPTS_VALUE;\n\n    if (avio_seek(s->pb, pos, SEEK_SET) < 0)\n        return AV_NOPTS_VALUE;\n\n    rm->remaining_len=0;\n    for(;;){\n        int seq=1;\n        AVStream *st;\n\n        len = rm_sync(s, &dts, &flags, &stream_index2, &pos);\n        if(len<0)\n            return AV_NOPTS_VALUE;\n\n        st = s->streams[stream_index2];\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            h= avio_r8(s->pb); len--;\n            if(!(h & 0x40)){\n                seq = avio_r8(s->pb); len--;\n            }\n        }\n\n        if((flags&2) && (seq&0x7F) == 1){\n            av_log(s, AV_LOG_TRACE, \"%d %d-%d %\"PRId64\" %d\\n\",\n                    flags, stream_index2, stream_index, dts, seq);\n            av_add_index_entry(st, pos, dts, 0, 0, AVINDEX_KEYFRAME);\n            if(stream_index2 == stream_index)\n                break;\n        }\n\n        avio_skip(s->pb, len);\n    }\n    *ppos = pos;\n    return dts;\n}\n\nstatic int rm_read_seek(AVFormatContext *s, int stream_index,\n                        int64_t pts, int flags)\n{\n    RMDemuxContext *rm = s->priv_data;\n\n    if (ff_seek_frame_binary(s, stream_index, pts, flags) < 0)\n        return -1;\n    rm->audio_pkt_cnt = 0;\n    return 0;\n}\n\n\nAVInputFormat ff_rm_demuxer = {\n    .name           = \"rm\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"RealMedia\"),\n    .priv_data_size = sizeof(RMDemuxContext),\n    .read_probe     = rm_probe,\n    .read_header    = rm_read_header,\n    .read_packet    = rm_read_packet,\n    .read_close     = rm_read_close,\n    .read_timestamp = rm_read_dts,\n    .read_seek      = rm_read_seek,\n};\n\nAVInputFormat ff_rdt_demuxer = {\n    .name           = \"rdt\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"RDT demuxer\"),\n    .priv_data_size = sizeof(RMDemuxContext),\n    .read_close     = rm_read_close,\n    .flags          = AVFMT_NOFILE,\n};\n\nstatic int ivr_probe(AVProbeData *p)\n{\n    if (memcmp(p->buf, \".R1M\\x0\\x1\\x1\", 7) &&\n        memcmp(p->buf, \".REC\", 4))\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\nstatic int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n            for (j = 0; j < len; j++) {\n                if (avio_feof(pb))\n                    return AVERROR_INVALIDDATA;\n                av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n            }\n            av_log(s, AV_LOG_DEBUG, \"'\\n\");\n        } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n        for (i = 0; i < count; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n\n            type = avio_r8(pb);\n            tlen  = avio_rb32(pb);\n            avio_get_str(pb, tlen, key, sizeof(key));\n            len  = avio_rb32(pb);\n            if (type == 5) {\n                avio_get_str(pb, len, val, sizeof(val));\n                av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n            } else if (type == 4 && !strncmp(key, \"OpaqueData\", tlen)) {\n                ret = ffio_ensure_seekback(pb, 4);\n                if (ret < 0)\n                    return ret;\n                if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {\n                    ret = rm_read_multi(s, pb, st, NULL);\n                } else {\n                    avio_seek(pb, -4, SEEK_CUR);\n                    ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);\n                }\n\n                if (ret < 0)\n                    return ret;\n            } else if (type == 4) {\n                int j;\n\n                av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n                for (j = 0; j < len; j++)\n                    av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n                av_log(s, AV_LOG_DEBUG, \"'\\n\");\n            } else if (len == 4 && type == 3 && !strncmp(key, \"Duration\", tlen)) {\n                st->duration = avio_rb32(pb);\n            } else if (len == 4 && type == 3) {\n                value = avio_rb32(pb);\n                av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n                avio_skip(pb, len);\n            }\n        }\n    }\n\n    if (avio_r8(pb) != 6)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12);\n    avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));\n    if (avio_r8(pb) != 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8);\n\n    return 0;\n}\n\nstatic int ivr_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret = AVERROR_EOF, opcode;\n    AVIOContext *pb = s->pb;\n    unsigned size, index;\n    int64_t pos, pts;\n\n    if (avio_feof(pb) || rm->data_end)\n        return AVERROR_EOF;\n\n    pos = avio_tell(pb);\n\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            // If there are queued audio packet return them first\n            AVStream *st;\n\n            st = s->streams[rm->audio_stream_num];\n            ret = ff_rm_retrieve_cache(s, pb, st, st->priv_data, pkt);\n            if (ret < 0) {\n                return ret;\n            }\n        } else {\n            if (rm->remaining_len) {\n                avio_skip(pb, rm->remaining_len);\n                rm->remaining_len = 0;\n            }\n\n            if (avio_feof(pb))\n                return AVERROR_EOF;\n\n            opcode = avio_r8(pb);\n            if (opcode == 2) {\n                AVStream *st;\n                int seq = 1;\n\n                pts = avio_rb32(pb);\n                index = avio_rb16(pb);\n                if (index >= s->nb_streams)\n                    return AVERROR_INVALIDDATA;\n\n                avio_skip(pb, 4);\n                size = avio_rb32(pb);\n                avio_skip(pb, 4);\n\n                if (size < 1 || size > INT_MAX/4) {\n                    av_log(s, AV_LOG_ERROR, \"size %u is invalid\\n\", size);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                st = s->streams[index];\n                ret = ff_rm_parse_packet(s, pb, st, st->priv_data, size, pkt,\n                                         &seq, 0, pts);\n                if (ret < -1) {\n                    return ret;\n                } else if (ret) {\n                    continue;\n                }\n\n                pkt->pos = pos;\n                pkt->pts = pts;\n                pkt->stream_index = index;\n            } else if (opcode == 7) {\n                pos = avio_rb64(pb);\n                if (!pos) {\n                    rm->data_end = 1;\n                    return AVERROR_EOF;\n                }\n            } else {\n                av_log(s, AV_LOG_ERROR, \"Unsupported opcode=%d at %\"PRIX64\"\\n\", opcode, avio_tell(pb) - 1);\n                return AVERROR(EIO);\n            }\n        }\n\n        break;\n    }\n\n    return ret;\n}\n\nAVInputFormat ff_ivr_demuxer = {\n    .name           = \"ivr\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"IVR (Internet Video Recording)\"),\n    .priv_data_size = sizeof(RMDemuxContext),\n    .read_probe     = ivr_probe,\n    .read_header    = ivr_read_header,\n    .read_packet    = ivr_read_packet,\n    .read_close     = rm_read_close,\n    .extensions     = \"ivr\",\n};\n"], "filenames": ["libavformat/rmdec.c"], "buggy_code_start_loc": [525], "buggy_code_end_loc": [526], "fixing_code_start_loc": [525], "fixing_code_end_loc": [526], "type": "CWE-416", "message": "FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later.", "other": {"cve": {"id": "CVE-2018-1999013", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-23T15:29:00.423", "lastModified": "2018-09-20T16:21:56.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later."}, {"lang": "es", "value": "FFmpeg antes del commit con ID a7e032a277452366771951e29fd0bf2bd5c029f0 contiene una vulnerabilidad de uso de memoria previamente liberada en el demuxer realmedia que puede resultar en una vulnerabilidad que permite que el atacante lea memoria din\u00e1mica (heap). Este ataque parece ser explotable mediante un archivo RM especialmente manipulado que debe proporcionarse como entrada. La vulnerabilidad parece haber sido solucionada en a7e032a277452366771951e29fd0bf2bd5c029f0 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.1", "matchCriteriaId": "9B915B68-D7F0-4B61-9DA0-000EE6AE9A51"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104896", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/a7e032a277452366771951e29fd0bf2bd5c029f0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/a7e032a277452366771951e29fd0bf2bd5c029f0"}}