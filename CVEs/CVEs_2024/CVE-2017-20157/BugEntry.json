{"buggy_code": ["<?php\n\n/*\n * This file is part of the Ariadne Component Library.\n *\n * (c) Muze <info@muze.nl>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace arc\\url;\n\n/**\n *\tUrl parses a URL string and returns an object with the seperate parts. You can change\n *\tthese and when cast to a string Url will regenerate the URL string and make sure it\n *\tis valid.\n *\n *\tUsage:\n *\t\t$url = new \\arc\\url\\Url( 'http://www.ariadne-cms.org/' );\n *\t\t$url->path = '/docs/search/';\n *\t\t$url->query = 'a=1&a=2';\n *\t\techo $url; // => 'http://www.ariadne-cms.org/docs/search/?a=1&a=2'\n * @property Query $query The query arguments\n */\nclass Url\n{\n    /**\n     *\tAll parts of the URL format, as returned by parse_url.\n     *\tscheme://user:pass@host:port/path?query#fragment\n     */\n    public $scheme, $user, $pass, $host, $port, $path, $fragment;\n    private $query;\n\n    /**\n     *\t@param string $url The URL to parse, the query part will remain a string.\n     *  @param QueryInterface queryObject Optional. An object that parses the query string.\n     */\n    public function __construct($url, $queryObject = null)\n    {\n        $componentList = [\n            'scheme', 'host', 'port', 'user', 'pass', 'path', 'query', 'fragment'\n        ];\n        $this->importUrlComponents( parse_url( $url ), $componentList );\n        if ( isset( $queryObject ) ) {\n            $this->query = $queryObject->import( $this->query );\n        }\n    }\n\n    /**\n     * @return string\n     */\n    public function __toString()\n    {\n        switch ($this->scheme) {\n            case 'file':\n                return $this->getScheme() . '//' . $this->host . $this->getFilePath();\n            break;\n            case 'mailto':\n            case 'news':\n                return ( $this->path ? $this->getScheme() . $this->getPath() : '' );\n            break;\n            case 'ldap':\n                return $this->getSchemeAndAuthority() . $this->getPath() . $this->getLdapQuery();\n            break;\n            default:\n                return $this->getSchemeAndAuthority() . $this->getPath() . $this->getQuery() . $this->getFragment();\n            break;\n        }\n    }\n\n    /**\n     * @param $name\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        switch ( (string) $name ) {\n            case 'password':\n                return $this->pass;\n            break;\n            case 'query':\n                return $this->query;\n            break;\n        }\n    }\n\n    /**\n     * @param $name\n     * @param $value\n     */\n    public function __set($name, $value)\n    {\n        switch ( (string) $name ) {\n            case 'password':\n                $this->pass = $value;\n            break;\n            case 'query':\n                if ( is_object( $this->query ) ) {\n                    $this->query->reset()->import( $value );\n                } else {\n                    $this->query = $value;\n                }\n            break;\n        }\n    }\n\n    /**\n     *\n     */\n    public function __clone()\n    {\n        if ( is_object( $this->query ) ) {\n            $this->query = clone $this->query;\n        }\n    }\n\n    /**\n     * @param $components\n     * @param $validComponents\n     */\n    private function importUrlComponents($components, $validComponents)\n    {\n        array_walk( $validComponents, function ($componentName) use ($components) {\n            $this->{$componentName} = ( isset( $components[$componentName] ) ? $components[$componentName] : '' );\n        } );\n    }\n\n    /**\n     * @return string\n     */\n    private function getSchemeAndAuthority()\n    {\n        // note: both '//google.com/' and 'file:///C:/' are valid URL's - so if either a scheme or host is set, add the // part\n        return ( ( $this->scheme || $this->host ) ? $this->getScheme() . $this->getAuthority() : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getScheme()\n    {\n        return ( $this->scheme ? $this->scheme . ':' : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getAuthority()\n    {\n        return ( $this->host ? '//' . $this->getUser() . $this->host . $this->getPort() : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getUser()\n    {\n        return ( $this->user ? rawurlencode( $this->user ) . $this->getPassword() . '@' : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getPassword()\n    {\n        return ( $this->user && $this->pass ?  ':' . rawurlencode( $this->pass ) : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getPort()\n    {\n        return ( $this->port ? ':' . (int) $this->port : '' );\n    }\n\n    /**\n     * @return mixed|string\n     */\n    private function getPath()\n    {\n        if (!$this->path) {\n            return '';\n        }\n        $path = $this->path;\n        if ( $this->host && ( !$path || $path[0] !== '/' ) ) {\n            // note: if a host is set, the path _must_ be made absolute or the URL will be invalid\n            $path = '/' . $path;\n        }\n        // urlencode encodes too many characters for the path part, so we decode them back to get readable urls.\n        return str_replace( [ '%3D', '%2B', '%3A', '%40', '%7E'], [ '=', '+', ':', '@', '~'], $path = join( '/', array_map( 'urlencode', explode( '/', $path ) ) ) );\n    }\n\n    /**\n     * @return mixed|string\n     */\n    private function getFilePath()\n    {\n        // in the file: scheme, a path must start with a '/' even if no host is set. This contradicts with the email: scheme.\n        $path = $this->getPath();\n        if ($path && $path[0]!=='/') {\n            $path = '/' . $path;\n        }\n\n        return $path;\n    }\n\n    /**\n     * @return string\n     */\n    private function getQuery()\n    {\n        // queries are assumed to handle themselves, so no encoding here.\n        $query = (string) $this->query; // convert explicitly to string first, because the query object may exist but still return an empty string\n\n        return ( $query ? '?' . $query : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getLdapQuery()\n    {\n        // ldap queries may contain multiple ? tokens - so these are unencoded here.\n        $query = (string) $this->query; // convert explicitly to string first, because the query object may exist but still return an empty string\n\n        return ( $query ? '?' . str_replace( '%3F', '?', $query ) : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getFragment()\n    {\n        return ( $this->fragment ? '#' . urlencode($this->fragment) : '' );\n    }\n\n}\n", "<?php\n\n    /*\n     * This file is part of the Ariadne Component Library.\n     *\n     * (c) Muze <info@muze.nl>\n     *\n     * For the full copyright and license information, please view the LICENSE\n     * file that was distributed with this source code.\n\n     */\n\n\n    class TestUrl extends PHPUnit_Framework_TestCase\n    {\n        function testSafeUrl()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?frop=1';\n            $url = \\arc\\url::safeUrl($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals( $starturl, (string)$url);\n\n            $starturl = 'http://www.ariadne-cms.org/?frop=1&frop=2';\n            $url = \\arc\\url::safeUrl($starturl);\n            $url->fragment = 'test123';\n            $this->assertEquals( $starturl .'#test123', (string)$url);\n\n            $starturl = 'http://www.ariadne-cms.org/view.html?some%20thing';\n            $url = \\arc\\url::safeUrl($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals( $starturl, (string)$url);\n            $this->assertEquals( 'some thing', $url->query[0] );\n\n            $starturl = 'http://www.ariadne-cms.org/view.html?some%20thing';\n            $url = \\arc\\url::safeUrl($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals('some thing', $url->query[0] );\n        }\n\n        function testparseUrlQueryMultipleElements()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?test=test&test=frop';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertInstanceOf( '\\arc\\url\\PHPQuery', $url->query );\n            $this->assertEquals( 'frop', ''.$url->query['test'], \"PHP url parser, the second instance has precedence\");\n            $this->assertNotEquals( $starturl, ''.$url );\n        }\n\n        function testparseUrlQueryUnnumberedElements()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?test[]=test&test[]=frop';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertInstanceOf( '\\arc\\url\\PHPQuery', $url->query );\n            $this->assertEquals( ['test', 'frop'], $url->query['test'], \"Auto indexed array from query\");\n            $this->assertEquals( (string)$url, (string) \\arc\\url::url($url) );\n        }\n\n        function testparseUrlQueryNumberedElements()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?test[1]=test&test[0]=frop';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertInstanceOf( '\\arc\\url\\PHPQuery', $url->query );\n            $this->assertEquals( ['frop', 'test'], $url->query['test'], \"manual index array from query\");\n            $this->assertEquals( (string)$url, (string) \\arc\\url::url($url) );\n        }\n\n        function testparseUrlQueryWithEncodedSpace()\n        {\n            $starturl = 'http://www.ariadne-cms.org/view.html?foo=some+thing';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertNotEquals( $starturl, (string)$url, '+ signed should be encoded with %20 conform rfc 3986' );\n            $this->assertEquals( $starturl, str_replace('%20','+',(string)$url ));\n            $this->assertEquals( 'some thing', $url->query['foo']);\n\n        }\n\n        function testParseAuthority()\n        {\n            $starturl = 'http://foo:bar@www.ariadne-cms.org:80/';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals( $starturl, $url);\n        }\n\n        function testParseCommonURLS()\n        {\n            $commonUrls = [\n                'ftp://ftp.is.co.za/rfc/rfc1808.txt',\n                'http://www.ietf.org/rfc/rfc2396.txt',\n                'ldap://[2001:db8::7]/c=GB?objectClass?one',\n                'mailto:John.Doe@example.com',\n                'news:comp.infosystems.www.servers.unix',\n                'tel:+1-816-555-1212',\n                'telnet://192.0.2.16:80/',\n                'urn:oasis:names:specification:docbook:dtd:xml:4.1.2',\n                '//google.com',\n                '../../relative/',\n                'file:///C:/',\n                'http://www.ariadne-cms.org/~user/page'\n            ];\n            $parsedUrls = array_map( function($url) {\n                return (string)\\arc\\url::safeUrl($url);\n            }, $commonUrls);\n\n            $this->assertEquals( $commonUrls, $parsedUrls);\n        }\n\n    }\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Ariadne Component Library.\n *\n * (c) Muze <info@muze.nl>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace arc\\url;\n\n/**\n * Url parses a URL string and returns an object with the seperate parts. You can change\n * these and when cast to a string Url will regenerate the URL string and make sure it\n * is valid.\n *\n * Usage:\n *    $url = new \\arc\\url\\Url( 'http://www.ariadne-cms.org/' );\n *    $url->path = '/docs/search/';\n *    $url->query = 'a=1&a=2';\n *    echo $url; // => 'http://www.ariadne-cms.org/docs/search/?a=1&a=2'\n * @property Query $query The query arguments\n */\nclass Url\n{\n    /**\n     * All parts of the URL format, as returned by parse_url.\n     * scheme://user:pass@host:port/path?query#fragment\n     */\n    public $scheme, $user, $pass, $host, $port, $path, $fragment;\n    private $query;\n\n    /**\n     * @param string $url The URL to parse, the query part will remain a string.\n     * @param QueryInterface queryObject Optional. An object that parses the query string.\n     */\n    public function __construct($url, $queryObject = null)\n    {\n        $componentList = [\n            'scheme', 'host', 'port', 'user', 'pass', 'path', 'query', 'fragment'\n        ];\n        $this->importUrlComponents( parse_url( $url ), $componentList );\n        if ($this->scheme!='ldap' && strpos($this->host, ':')) {\n            // parse_url allows ':' in host when it occurs more than once\\\n            $this->host = substr($this->host, 0, strpos($this->host, ':'));\n        }\n        if ( isset( $queryObject ) ) {\n            $this->query = $queryObject->import( $this->query );\n        }\n    }\n\n    /**\n     * @return string\n     */\n    public function __toString()\n    {\n        switch ($this->scheme) {\n            case 'file':\n                return $this->getScheme() . '//' . $this->host . $this->getFilePath();\n            break;\n            case 'mailto':\n            case 'news':\n                return ( $this->path ? $this->getScheme() . $this->getPath() : '' );\n            break;\n            case 'ldap':\n                return $this->getSchemeAndAuthority() . $this->getPath() . $this->getLdapQuery();\n            break;\n            default:\n                return $this->getSchemeAndAuthority() . $this->getPath() . $this->getQuery() . $this->getFragment();\n            break;\n        }\n    }\n\n    /**\n     * @param $name\n     * @return mixed\n     */\n    public function __get($name)\n    {\n        switch ( (string) $name ) {\n            case 'password':\n                return $this->pass;\n            break;\n            case 'query':\n                return $this->query;\n            break;\n        }\n    }\n\n    /**\n     * @param $name\n     * @param $value\n     */\n    public function __set($name, $value)\n    {\n        switch ( (string) $name ) {\n            case 'password':\n                $this->pass = $value;\n            break;\n            case 'query':\n                if ( is_object( $this->query ) ) {\n                    $this->query->reset()->import( $value );\n                } else {\n                    $this->query = $value;\n                }\n            break;\n        }\n    }\n\n    /**\n     *\n     */\n    public function __clone()\n    {\n        if ( is_object( $this->query ) ) {\n            $this->query = clone $this->query;\n        }\n    }\n\n    /**\n     * @param $components\n     * @param $validComponents\n     */\n    private function importUrlComponents($components, $validComponents)\n    {\n        array_walk( $validComponents, function ($componentName) use ($components) {\n            $this->{$componentName} = ( isset( $components[$componentName] ) ? $components[$componentName] : '' );\n        } );\n    }\n\n    /**\n     * @return string\n     */\n    private function getSchemeAndAuthority()\n    {\n        // note: both '//google.com/' and 'file:///C:/' are valid URL's - so if either a scheme or host is set, add the // part\n        return ( ( $this->scheme || $this->host ) ? $this->getScheme() . $this->getAuthority() : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getScheme()\n    {\n        return ( $this->scheme ? $this->scheme . ':' : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getAuthority()\n    {\n        return ( $this->host ? '//' . $this->getUser() . $this->host . $this->getPort() : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getUser()\n    {\n        return ( $this->user ? rawurlencode( $this->user ) . $this->getPassword() . '@' : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getPassword()\n    {\n        return ( $this->user && $this->pass ?  ':' . rawurlencode( $this->pass ) : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getPort()\n    {\n        return ( $this->port ? ':' . (int) $this->port : '' );\n    }\n\n    /**\n     * @return mixed|string\n     */\n    private function getPath()\n    {\n        if (!$this->path) {\n            return '';\n        }\n        $path = $this->path;\n        if ( $this->host && ( !$path || $path[0] !== '/' ) ) {\n            // note: if a host is set, the path _must_ be made absolute or the URL will be invalid\n            $path = '/' . $path;\n        }\n        // urlencode encodes too many characters for the path part, so we decode them back to get readable urls.\n        return str_replace( [ '%3D', '%2B', '%3A', '%40', '%7E'], [ '=', '+', ':', '@', '~'], $path = join( '/', array_map( 'urlencode', explode( '/', $path ) ) ) );\n    }\n\n    /**\n     * @return mixed|string\n     */\n    private function getFilePath()\n    {\n        // in the file: scheme, a path must start with a '/' even if no host is set. This contradicts with the email: scheme.\n        $path = $this->getPath();\n        if ($path && $path[0]!=='/') {\n            $path = '/' . $path;\n        }\n\n        return $path;\n    }\n\n    /**\n     * @return string\n     */\n    private function getQuery()\n    {\n        // queries are assumed to handle themselves, so no encoding here.\n        $query = (string) $this->query; // convert explicitly to string first, because the query object may exist but still return an empty string\n\n        return ( $query ? '?' . $query : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getLdapQuery()\n    {\n        // ldap queries may contain multiple ? tokens - so these are unencoded here.\n        $query = (string) $this->query; // convert explicitly to string first, because the query object may exist but still return an empty string\n\n        return ( $query ? '?' . str_replace( '%3F', '?', $query ) : '' );\n    }\n\n    /**\n     * @return string\n     */\n    private function getFragment()\n    {\n        return ( $this->fragment ? '#' . urlencode($this->fragment) : '' );\n    }\n\n}\n", "<?php\n\n    /*\n     * This file is part of the Ariadne Component Library.\n     *\n     * (c) Muze <info@muze.nl>\n     *\n     * For the full copyright and license information, please view the LICENSE\n     * file that was distributed with this source code.\n\n     */\n\n\n    class TestUrl extends PHPUnit_Framework_TestCase\n    {\n        function testSafeUrl()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?frop=1';\n            $url = \\arc\\url::safeUrl($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals( $starturl, (string)$url);\n\n            $starturl = 'http://www.ariadne-cms.org/?frop=1&frop=2';\n            $url = \\arc\\url::safeUrl($starturl);\n            $url->fragment = 'test123';\n            $this->assertEquals( $starturl .'#test123', (string)$url);\n\n            $starturl = 'http://www.ariadne-cms.org/view.html?some%20thing';\n            $url = \\arc\\url::safeUrl($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals( $starturl, (string)$url);\n            $this->assertEquals( 'some thing', $url->query[0] );\n\n            $starturl = 'http://www.ariadne-cms.org/view.html?some%20thing';\n            $url = \\arc\\url::safeUrl($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals('some thing', $url->query[0] );\n        }\n\n        function testparseUrlQueryMultipleElements()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?test=test&test=frop';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertInstanceOf( '\\arc\\url\\PHPQuery', $url->query );\n            $this->assertEquals( 'frop', ''.$url->query['test'], \"PHP url parser, the second instance has precedence\");\n            $this->assertNotEquals( $starturl, ''.$url );\n        }\n\n        function testparseUrlQueryUnnumberedElements()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?test[]=test&test[]=frop';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertInstanceOf( '\\arc\\url\\PHPQuery', $url->query );\n            $this->assertEquals( ['test', 'frop'], $url->query['test'], \"Auto indexed array from query\");\n            $this->assertEquals( (string)$url, (string) \\arc\\url::url($url) );\n        }\n\n        function testparseUrlQueryNumberedElements()\n        {\n            $starturl = 'http://www.ariadne-cms.org/?test[1]=test&test[0]=frop';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertInstanceOf( '\\arc\\url\\PHPQuery', $url->query );\n            $this->assertEquals( ['frop', 'test'], $url->query['test'], \"manual index array from query\");\n            $this->assertEquals( (string)$url, (string) \\arc\\url::url($url) );\n        }\n\n        function testparseUrlQueryWithEncodedSpace()\n        {\n            $starturl = 'http://www.ariadne-cms.org/view.html?foo=some+thing';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertNotEquals( $starturl, (string)$url, '+ signed should be encoded with %20 conform rfc 3986' );\n            $this->assertEquals( $starturl, str_replace('%20','+',(string)$url ));\n            $this->assertEquals( 'some thing', $url->query['foo']);\n\n        }\n\n        function testParseAuthority()\n        {\n            $starturl = 'http://foo:bar@www.ariadne-cms.org:80/';\n            $url = \\arc\\url::url($starturl);\n            $this->assertInstanceOf('\\arc\\url\\Url', $url);\n            $this->assertEquals( $starturl, $url);\n        }\n\n        function testParseCommonURLS()\n        {\n            $commonUrls = [\n                'ftp://ftp.is.co.za/rfc/rfc1808.txt',\n                'http://www.ietf.org/rfc/rfc2396.txt',\n                'ldap://[2001:db8::7]/c=GB?objectClass?one',\n                'mailto:John.Doe@example.com',\n                'news:comp.infosystems.www.servers.unix',\n                'tel:+1-816-555-1212',\n                'telnet://192.0.2.16:80/',\n                'urn:oasis:names:specification:docbook:dtd:xml:4.1.2',\n                '//google.com',\n                '../../relative/',\n                'file:///C:/',\n                'http://www.ariadne-cms.org/~user/page'\n            ];\n            $parsedUrls = array_map( function($url) {\n                return (string)\\arc\\url::safeUrl($url);\n            }, $commonUrls);\n\n            $this->assertEquals( $commonUrls, $parsedUrls);\n        }\n\n      function testEvilURL1()\n      {\n         $evilURL = 'http://127.0.0.1:11211:80/';\n         $parsed = \\arc\\url::url($evilURL);\n         $this->assertEquals( $parsed->port, 80 );\n         $parsedSafe = \\arc\\url::safeUrl($evilURL);\n         $this->assertEquals( $parsedSafe->port, 80 );\n         $safeURL = (string) $parsed;\n         $this->assertEquals( 'http://127.0.0.1:80/', $safeURL);\n      }\n\n      function testEvilURL2()\n      {\n         $evilURL = 'http://google.com#@evil.com/';\n         $parsed = \\arc\\url::url($evilURL);\n         $this->assertEquals( $parsed->host, 'google.com' );\n         $parsedSafe = \\arc\\url::safeUrl($evilURL);\n         $this->assertEquals( $parsedSafe->host, 'google.com');\n         $safeURL = (string) $parsed;\n         $this->assertEquals( 'http://google.com#%40evil.com%2F', $safeURL);\n      }\n\n      function testEvilURL3()\n      {\n         $evilURL = 'http://foo@evil.com:80@google.com/';\n         $parsed = \\arc\\url::url($evilURL);\n         $this->assertEquals( $parsed->host, 'google.com' );\n         $parsedSafe = \\arc\\url::safeUrl($evilURL);\n         $this->assertEquals( $parsedSafe->host, 'google.com');\n         $safeURL = (string) $parsed;\n         $this->assertEquals( 'http://foo%40evil.com:80@google.com/', $safeURL);\n      }\n\n      function testEvilURL4()\n      {\n         $evilURL = 'http://foo@127.0.0.1 @google.com/';\n         $parsed = \\arc\\url::url($evilURL);\n         $this->assertEquals( $parsed->host, 'google.com' );\n         $parsedSafe = \\arc\\url::safeUrl($evilURL);\n         $this->assertEquals( $parsedSafe->host, 'google.com');\n         $safeURL = (string) $parsed;\n         $this->assertEquals( 'http://foo%40127.0.0.1%20@google.com/', $safeURL);\n      }\n\n      function testEvilURL5()\n      {\n         $evilURL = 'http://127.0.0.1:11211#@google.com:80/';\n         $parsed = \\arc\\url::url($evilURL);\n         $this->assertEquals( $parsed->host, '127.0.0.1' );\n         $parsedSafe = \\arc\\url::safeUrl($evilURL);\n         $this->assertEquals( $parsedSafe->host, '127.0.0.1');\n         $safeURL = (string) $parsed;\n         $this->assertEquals( 'http://127.0.0.1:11211#%40google.com%3A80%2F', $safeURL);\n      }\n\n    }\n"], "filenames": ["src/url/Url.php", "tests/url.Test.php"], "buggy_code_start_loc": [15, 111], "buggy_code_end_loc": [44, 111], "fixing_code_start_loc": [15, 112], "fixing_code_end_loc": [49, 167], "type": "CWE-918", "message": "A vulnerability was found in Ariadne Component Library up to 2.x. It has been classified as critical. Affected is an unknown function of the file src/url/Url.php. The manipulation leads to server-side request forgery. Upgrading to version 3.0 is able to address this issue. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217140.", "other": {"cve": {"id": "CVE-2017-20157", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-31T10:15:13.073", "lastModified": "2023-01-06T21:46:24.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Ariadne Component Library up to 2.x. It has been classified as critical. Affected is an unknown function of the file src/url/Url.php. The manipulation leads to server-side request forgery. Upgrading to version 3.0 is able to address this issue. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217140."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ariadne-cms:ariadne_component_library:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0", "matchCriteriaId": "56CE1ADC-A3FC-45B7-9FDA-B3AF9CA54991"}]}]}], "references": [{"url": "https://github.com/Ariadne-CMS/arc-web/commit/1feb1cc11e6c9f218408f15f53f537ea0d788656", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Ariadne-CMS/arc-web/releases/tag/3.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217140", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217140", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Ariadne-CMS/arc-web/commit/1feb1cc11e6c9f218408f15f53f537ea0d788656"}}