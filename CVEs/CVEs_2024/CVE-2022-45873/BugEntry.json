{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#if HAVE_ELFUTILS\n\n#include <dwarf.h>\n#include <elfutils/libdwelf.h>\n#include <elfutils/libdwfl.h>\n#include <libelf.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"dlfcn-util.h\"\n#include \"elf-util.h\"\n#include \"errno-util.h\"\n#include \"fileio.h\"\n#include \"fd-util.h\"\n#include \"format-util.h\"\n#include \"hexdecoct.h\"\n#include \"io-util.h\"\n#include \"macro.h\"\n#include \"process-util.h\"\n#include \"rlimit-util.h\"\n#include \"string-util.h\"\n#include \"util.h\"\n\n#define FRAMES_MAX 64\n#define THREADS_MAX 64\n#define ELF_PACKAGE_METADATA_ID 0xcafe1a7e\n\nstatic void *dw_dl = NULL;\nstatic void *elf_dl = NULL;\n\n/* libdw symbols */\nDwarf_Attribute *(*sym_dwarf_attr_integrate)(Dwarf_Die *, unsigned int, Dwarf_Attribute *);\nconst char *(*sym_dwarf_diename)(Dwarf_Die *);\nconst char *(*sym_dwarf_formstring)(Dwarf_Attribute *);\nint (*sym_dwarf_getscopes)(Dwarf_Die *, Dwarf_Addr, Dwarf_Die **);\nint (*sym_dwarf_getscopes_die)(Dwarf_Die *, Dwarf_Die **);\nElf *(*sym_dwelf_elf_begin)(int);\n#if HAVE_DWELF_ELF_E_MACHINE_STRING\nconst char *(*sym_dwelf_elf_e_machine_string)(int);\n#endif\nssize_t (*sym_dwelf_elf_gnu_build_id)(Elf *, const void **);\nint (*sym_dwarf_tag)(Dwarf_Die *);\nDwfl_Module *(*sym_dwfl_addrmodule)(Dwfl *, Dwarf_Addr);\nDwfl *(*sym_dwfl_begin)(const Dwfl_Callbacks *);\nint (*sym_dwfl_build_id_find_elf)(Dwfl_Module *, void **, const char *, Dwarf_Addr, char **, Elf **);\nint (*sym_dwfl_core_file_attach)(Dwfl *, Elf *);\nint (*sym_dwfl_core_file_report)(Dwfl *, Elf *, const char *);\nvoid (*sym_dwfl_end)(Dwfl *);\nconst char *(*sym_dwfl_errmsg)(int);\nint (*sym_dwfl_errno)(void);\nbool (*sym_dwfl_frame_pc)(Dwfl_Frame *, Dwarf_Addr *, bool *);\nptrdiff_t (*sym_dwfl_getmodules)(Dwfl *, int (*)(Dwfl_Module *, void **, const char *, Dwarf_Addr, void *), void *, ptrdiff_t);\nint (*sym_dwfl_getthreads)(Dwfl *, int (*)(Dwfl_Thread *, void *), void *);\nDwarf_Die *(*sym_dwfl_module_addrdie)(Dwfl_Module *, Dwarf_Addr, Dwarf_Addr *);\nconst char *(*sym_dwfl_module_addrname)(Dwfl_Module *, GElf_Addr);\nint (*sym_dwfl_module_build_id)(Dwfl_Module *, const unsigned char **, GElf_Addr *);\nElf *(*sym_dwfl_module_getelf)(Dwfl_Module *, GElf_Addr *);\nconst char *(*sym_dwfl_module_info)(Dwfl_Module *, void ***, Dwarf_Addr *, Dwarf_Addr *, Dwarf_Addr *, Dwarf_Addr *, const char **, const char **);\nint (*sym_dwfl_offline_section_address)(Dwfl_Module *, void **, const char *, Dwarf_Addr, const char *, GElf_Word, const GElf_Shdr *, Dwarf_Addr *);\nint (*sym_dwfl_report_end)(Dwfl *, int (*)(Dwfl_Module *, void *, const char *, Dwarf_Addr, void *), void *);\nint (*sym_dwfl_standard_find_debuginfo)(Dwfl_Module *, void **, const char *, Dwarf_Addr, const char *, const char *, GElf_Word, char **);\nint (*sym_dwfl_thread_getframes)(Dwfl_Thread *, int (*)(Dwfl_Frame *, void *), void *);\npid_t (*sym_dwfl_thread_tid)(Dwfl_Thread *);\n\n/* libelf symbols */\nElf *(*sym_elf_begin)(int, Elf_Cmd, Elf *);\nint (*sym_elf_end)(Elf *);\nElf_Data *(*sym_elf_getdata_rawchunk)(Elf *, int64_t, size_t, Elf_Type);\nGElf_Ehdr *(*sym_gelf_getehdr)(Elf *, GElf_Ehdr *);\nint (*sym_elf_getphdrnum)(Elf *, size_t *);\nconst char *(*sym_elf_errmsg)(int);\nint (*sym_elf_errno)(void);\nElf *(*sym_elf_memory)(char *, size_t);\nunsigned int (*sym_elf_version)(unsigned int);\nGElf_Phdr *(*sym_gelf_getphdr)(Elf *, int, GElf_Phdr *);\nsize_t (*sym_gelf_getnote)(Elf_Data *, size_t, GElf_Nhdr *, size_t *, size_t *);\n\nint dlopen_dw(void) {\n        int r;\n\n        r = dlopen_many_sym_or_warn(\n                        &dw_dl, \"libdw.so.1\", LOG_DEBUG,\n                        DLSYM_ARG(dwarf_getscopes),\n                        DLSYM_ARG(dwarf_getscopes_die),\n                        DLSYM_ARG(dwarf_tag),\n                        DLSYM_ARG(dwarf_attr_integrate),\n                        DLSYM_ARG(dwarf_formstring),\n                        DLSYM_ARG(dwarf_diename),\n                        DLSYM_ARG(dwelf_elf_gnu_build_id),\n                        DLSYM_ARG(dwelf_elf_begin),\n#if HAVE_DWELF_ELF_E_MACHINE_STRING\n                        DLSYM_ARG(dwelf_elf_e_machine_string),\n#endif\n                        DLSYM_ARG(dwfl_addrmodule),\n                        DLSYM_ARG(dwfl_frame_pc),\n                        DLSYM_ARG(dwfl_module_addrdie),\n                        DLSYM_ARG(dwfl_module_addrname),\n                        DLSYM_ARG(dwfl_module_info),\n                        DLSYM_ARG(dwfl_module_build_id),\n                        DLSYM_ARG(dwfl_module_getelf),\n                        DLSYM_ARG(dwfl_begin),\n                        DLSYM_ARG(dwfl_core_file_report),\n                        DLSYM_ARG(dwfl_report_end),\n                        DLSYM_ARG(dwfl_getmodules),\n                        DLSYM_ARG(dwfl_core_file_attach),\n                        DLSYM_ARG(dwfl_end),\n                        DLSYM_ARG(dwfl_errmsg),\n                        DLSYM_ARG(dwfl_errno),\n                        DLSYM_ARG(dwfl_build_id_find_elf),\n                        DLSYM_ARG(dwfl_standard_find_debuginfo),\n                        DLSYM_ARG(dwfl_thread_tid),\n                        DLSYM_ARG(dwfl_thread_getframes),\n                        DLSYM_ARG(dwfl_getthreads),\n                        DLSYM_ARG(dwfl_offline_section_address));\n        if (r <= 0)\n                return r;\n\n        return 1;\n}\n\nint dlopen_elf(void) {\n        int r;\n\n        r = dlopen_many_sym_or_warn(\n                        &elf_dl, \"libelf.so.1\", LOG_DEBUG,\n                        DLSYM_ARG(elf_begin),\n                        DLSYM_ARG(elf_end),\n                        DLSYM_ARG(elf_getphdrnum),\n                        DLSYM_ARG(elf_getdata_rawchunk),\n                        DLSYM_ARG(elf_errmsg),\n                        DLSYM_ARG(elf_errno),\n                        DLSYM_ARG(elf_memory),\n                        DLSYM_ARG(elf_version),\n                        DLSYM_ARG(gelf_getehdr),\n                        DLSYM_ARG(gelf_getphdr),\n                        DLSYM_ARG(gelf_getnote));\n        if (r <= 0)\n                return r;\n\n        return 1;\n}\n\ntypedef struct StackContext {\n        FILE *f;\n        Dwfl *dwfl;\n        Elf *elf;\n        unsigned n_thread;\n        unsigned n_frame;\n        JsonVariant **package_metadata;\n        Set **modules;\n} StackContext;\n\nstatic StackContext* stack_context_destroy(StackContext *c) {\n        if (!c)\n                return NULL;\n\n        c->f = safe_fclose(c->f);\n\n        if (c->dwfl) {\n                sym_dwfl_end(c->dwfl);\n                c->dwfl = NULL;\n        }\n\n        if (c->elf) {\n                sym_elf_end(c->elf);\n                c->elf = NULL;\n        }\n\n        return NULL;\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(Elf *, sym_elf_end, NULL);\n\nstatic int frame_callback(Dwfl_Frame *frame, void *userdata) {\n        StackContext *c = ASSERT_PTR(userdata);\n        Dwarf_Addr pc, pc_adjusted;\n        const char *fname = NULL, *symbol = NULL;\n        Dwfl_Module *module;\n        bool is_activation;\n        uint64_t module_offset = 0;\n\n        assert(frame);\n\n        if (c->n_frame >= FRAMES_MAX)\n                return DWARF_CB_ABORT;\n\n        if (!sym_dwfl_frame_pc(frame, &pc, &is_activation))\n                return DWARF_CB_ABORT;\n\n        pc_adjusted = pc - (is_activation ? 0 : 1);\n\n        module = sym_dwfl_addrmodule(c->dwfl, pc_adjusted);\n        if (module) {\n                Dwarf_Addr start, bias = 0;\n                Dwarf_Die *cudie;\n\n                cudie = sym_dwfl_module_addrdie(module, pc_adjusted, &bias);\n                if (cudie) {\n                        _cleanup_free_ Dwarf_Die *scopes = NULL;\n                        int n;\n\n                        n = sym_dwarf_getscopes(cudie, pc_adjusted - bias, &scopes);\n                        if (n > 0)\n                                for (Dwarf_Die *s = scopes; s && s < scopes + n; s++) {\n                                        Dwarf_Attribute *a, space;\n\n                                        if (!IN_SET(sym_dwarf_tag(s), DW_TAG_subprogram, DW_TAG_inlined_subroutine, DW_TAG_entry_point))\n                                                continue;\n\n                                        a = sym_dwarf_attr_integrate(s, DW_AT_MIPS_linkage_name, &space);\n                                        if (!a)\n                                                a = sym_dwarf_attr_integrate(s, DW_AT_linkage_name, &space);\n                                        if (a)\n                                                symbol = sym_dwarf_formstring(a);\n                                        if (!symbol)\n                                                symbol = sym_dwarf_diename(s);\n\n                                        if (symbol)\n                                                break;\n                                }\n                }\n\n                if (!symbol)\n                        symbol = sym_dwfl_module_addrname(module, pc_adjusted);\n\n                fname = sym_dwfl_module_info(module, NULL, &start, NULL, NULL, NULL, NULL, NULL);\n                module_offset = pc - start;\n        }\n\n        if (c->f)\n                fprintf(c->f, \"#%-2u 0x%016\" PRIx64 \" %s (%s + 0x%\" PRIx64 \")\\n\", c->n_frame, (uint64_t) pc, strna(symbol), strna(fname), module_offset);\n        c->n_frame++;\n\n        return DWARF_CB_OK;\n}\n\nstatic int thread_callback(Dwfl_Thread *thread, void *userdata) {\n        StackContext *c = ASSERT_PTR(userdata);\n        pid_t tid;\n\n        assert(thread);\n\n        if (c->n_thread >= THREADS_MAX)\n                return DWARF_CB_ABORT;\n\n        if (c->n_thread != 0 && c->f)\n                fputc('\\n', c->f);\n\n        c->n_frame = 0;\n\n        if (c->f) {\n                tid = sym_dwfl_thread_tid(thread);\n                fprintf(c->f, \"Stack trace of thread \" PID_FMT \":\\n\", tid);\n        }\n\n        if (sym_dwfl_thread_getframes(thread, frame_callback, c) < 0)\n                return DWARF_CB_ABORT;\n\n        c->n_thread++;\n\n        return DWARF_CB_OK;\n}\n\nstatic char* build_package_reference(\n                const char *type,\n                const char *name,\n                const char *version,\n                const char *arch) {\n\n        /* Construct an identifier for a specific version of the package. The syntax is most suitable for\n         * rpm: the resulting string can be used directly in queries and rpm/dnf/yum commands. For dpkg and\n         * other systems, it might not be usable directly, but users should still be able to figure out the\n         * meaning.\n         */\n\n        return strjoin(type ?: \"package\",\n                       \" \",\n                       name,\n\n                       version ? \"-\" : \"\",\n                       strempty(version),\n\n                       /* arch is meaningful even without version, so always print it */\n                       arch ? \".\" : \"\",\n                       strempty(arch));\n}\n\nstatic void report_module_metadata(StackContext *c, const char *name, JsonVariant *metadata) {\n        assert(c);\n        assert(name);\n\n        if (!c->f)\n                return;\n\n        fprintf(c->f, \"Module %s\", name);\n\n        if (metadata) {\n                const char\n                        *build_id = json_variant_string(json_variant_by_key(metadata, \"buildId\")),\n                        *type = json_variant_string(json_variant_by_key(metadata, \"type\")),\n                        *package = json_variant_string(json_variant_by_key(metadata, \"name\")),\n                        *version = json_variant_string(json_variant_by_key(metadata, \"version\")),\n                        *arch = json_variant_string(json_variant_by_key(metadata, \"architecture\"));\n\n                if (package) {\n                        /* Version/architecture is only meaningful with a package name.\n                         * Skip the detailed fields if package is unknown. */\n                        _cleanup_free_ char *id = build_package_reference(type, package, version, arch);\n                        fprintf(c->f, \" from %s\", strnull(id));\n                }\n\n                if (build_id && !(package && version))\n                        fprintf(c->f, \", build-id=%s\", build_id);\n        }\n\n        fputs(\"\\n\", c->f);\n}\n\nstatic int parse_package_metadata(const char *name, JsonVariant *id_json, Elf *elf, bool *ret_interpreter_found, StackContext *c) {\n        bool interpreter_found = false;\n        size_t n_program_headers;\n        int r;\n\n        assert(name);\n        assert(elf);\n        assert(c);\n\n        /* When iterating over PT_LOAD we will visit modules more than once */\n        if (set_contains(*c->modules, name))\n                return 0;\n\n        r = sym_elf_getphdrnum(elf, &n_program_headers);\n        if (r < 0) /* Not the handle we are looking for - that's ok, skip it */\n                return 0;\n\n        /* Iterate over all program headers in that ELF object. These will have been copied by\n         * the kernel verbatim when the core file is generated. */\n        for (size_t i = 0; i < n_program_headers; ++i) {\n                GElf_Phdr mem, *program_header;\n                GElf_Nhdr note_header;\n                Elf_Data *data;\n\n                /* Package metadata is in PT_NOTE headers. */\n                program_header = sym_gelf_getphdr(elf, i, &mem);\n                if (!program_header || (program_header->p_type != PT_NOTE && program_header->p_type != PT_INTERP))\n                        continue;\n\n                if (program_header->p_type == PT_INTERP) {\n                        interpreter_found = true;\n                        continue;\n                }\n\n                /* Fortunately there is an iterator we can use to walk over the\n                 * elements of a PT_NOTE program header. We are interested in the\n                 * note with type. */\n                data = sym_elf_getdata_rawchunk(elf,\n                                                program_header->p_offset,\n                                                program_header->p_filesz,\n                                                ELF_T_NHDR);\n                if (!data)\n                        continue;\n\n                for (size_t note_offset = 0, name_offset, desc_offset;\n                     note_offset < data->d_size &&\n                     (note_offset = sym_gelf_getnote(data, note_offset, &note_header, &name_offset, &desc_offset)) > 0;) {\n\n                        _cleanup_(json_variant_unrefp) JsonVariant *v = NULL, *w = NULL;\n                        const char *payload = (const char *)data->d_buf + desc_offset;\n\n                        if (note_header.n_namesz == 0 || note_header.n_descsz == 0)\n                                continue;\n\n                        /* Package metadata might have different owners, but the\n                         * magic ID is always the same. */\n                        if (note_header.n_type != ELF_PACKAGE_METADATA_ID)\n                                continue;\n\n                        _cleanup_free_ char *payload_0suffixed = NULL;\n                        assert(note_offset > desc_offset);\n                        size_t payload_len = note_offset - desc_offset;\n\n                        /* If we are lucky and the payload is NUL-padded, we don't need to copy the string.\n                         * But if happens to go all the way until the end of the buffer, make a copy. */\n                        if (payload[payload_len-1] != '\\0') {\n                                payload_0suffixed = memdup_suffix0(payload, payload_len);\n                                if (!payload_0suffixed)\n                                        return log_oom();\n                                payload = payload_0suffixed;\n                        }\n\n                        r = json_parse(payload, 0, &v, NULL, NULL);\n                        if (r < 0)\n                                return log_error_errno(r, \"json_parse on %s failed: %m\", payload);\n\n                        /* If we have a build-id, merge it in the same JSON object so that it appears all\n                         * nicely together in the logs/metadata. */\n                        if (id_json) {\n                                r = json_variant_merge(&v, id_json);\n                                if (r < 0)\n                                        return log_error_errno(r, \"json_variant_merge of package meta with buildId failed: %m\");\n                        }\n\n                        /* Pretty-print to the buffer, so that the metadata goes as plaintext in the\n                         * journal. */\n                        report_module_metadata(c, name, v);\n\n                        /* Then we build a new object using the module name as the key, and merge it\n                         * with the previous parses, so that in the end it all fits together in a single\n                         * JSON blob. */\n                        r = json_build(&w, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(name, JSON_BUILD_VARIANT(v))));\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to build JSON object: %m\");\n\n                        r = json_variant_merge(c->package_metadata, w);\n                        if (r < 0)\n                                return log_error_errno(r, \"json_variant_merge of package meta with buildId failed: %m\");\n\n                        /* Finally stash the name, so we avoid double visits. */\n                        r = set_put_strdup(c->modules, name);\n                        if (r < 0)\n                                return log_error_errno(r, \"set_put_strdup failed: %m\");\n\n                        if (ret_interpreter_found)\n                                *ret_interpreter_found = interpreter_found;\n\n                        return 1;\n                }\n        }\n\n        if (ret_interpreter_found)\n                *ret_interpreter_found = interpreter_found;\n\n        /* Didn't find package metadata for this module - that's ok, just go to the next. */\n        return 0;\n}\n\n/* Get the build-id out of an ELF object or a dwarf core module. */\nstatic int parse_buildid(Dwfl_Module *mod, Elf *elf, const char *name, StackContext *c, JsonVariant **ret_id_json) {\n        _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;\n        const unsigned char *id;\n        GElf_Addr id_vaddr;\n        ssize_t id_len;\n        int r;\n\n        assert(mod || elf);\n        assert(name);\n        assert(c);\n\n        if (mod)\n                id_len = sym_dwfl_module_build_id(mod, &id, &id_vaddr);\n        else\n                id_len = sym_dwelf_elf_gnu_build_id(elf, (const void **)&id);\n        if (id_len <= 0) {\n                /* If we don't find a build-id, note it in the journal message, and try\n                 * anyway to find the package metadata. It's unlikely to have the latter\n                 * without the former, but there's no hard rule. */\n                if (c->f)\n                        fprintf(c->f, \"Module %s without build-id.\\n\", name);\n        } else {\n                /* We will later parse package metadata json and pass it to our caller. Prepare the\n                * build-id in json format too, so that it can be appended and parsed cleanly. It\n                * will then be added as metadata to the journal message with the stack trace. */\n                r = json_build(&id_json, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(\"buildId\", JSON_BUILD_HEX(id, id_len))));\n                if (r < 0)\n                        return log_error_errno(r, \"json_build on buildId failed: %m\");\n        }\n\n        if (ret_id_json)\n                *ret_id_json = TAKE_PTR(id_json);\n\n        return 0;\n}\n\nstatic int module_callback(Dwfl_Module *mod, void **userdata, const char *name, Dwarf_Addr start, void *arg) {\n        _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;\n        StackContext *c = ASSERT_PTR(arg);\n        size_t n_program_headers;\n        GElf_Addr bias;\n        int r;\n        Elf *elf;\n\n        assert(mod);\n\n        if (!name)\n                name = \"(unnamed)\"; /* For logging purposes */\n\n        /* We are iterating on each \"module\", which is what dwfl calls ELF objects contained in the\n         * core file, and extracting the build-id first and then the package metadata.\n         * We proceed in a best-effort fashion - not all ELF objects might contain both or either.\n         * The build-id is easy, as libdwfl parses it during the sym_dwfl_core_file_report() call and\n         * stores it separately in an internal library struct. */\n        r = parse_buildid(mod, NULL, name, c, &id_json);\n        if (r < 0)\n                return DWARF_CB_ABORT;\n\n        /* The .note.package metadata is more difficult. From the module, we need to get a reference\n         * to the ELF object first. We might be lucky and just get it from elfutils. */\n        elf = sym_dwfl_module_getelf(mod, &bias);\n        if (elf) {\n                r = parse_package_metadata(name, id_json, elf, NULL, c);\n                if (r < 0)\n                        return DWARF_CB_ABORT;\n                if (r > 0)\n                        return DWARF_CB_OK;\n        } else\n                elf = c->elf;\n\n        /* We did not get the ELF object, or it's just a reference to the core. That is likely\n         * because we didn't get direct access to the executable, and the version of elfutils does\n         * not yet support parsing it out of the core file directly.\n         * So fallback to manual extraction - get the PT_LOAD section from the core,\n         * and if it's the right one we can interpret it as an Elf object, and parse\n         * its notes manually. */\n\n        r = sym_elf_getphdrnum(elf, &n_program_headers);\n        if (r < 0) {\n                log_warning(\"Could not parse number of program headers from core file: %s\",\n                            sym_elf_errmsg(-1)); /* -1 retrieves the most recent error */\n                report_module_metadata(c, name, id_json);\n\n                return DWARF_CB_OK;\n        }\n\n        for (size_t i = 0; i < n_program_headers; ++i) {\n                GElf_Phdr mem, *program_header;\n                Elf_Data *data;\n\n                /* The core file stores the ELF files in the PT_LOAD segment. */\n                program_header = sym_gelf_getphdr(elf, i, &mem);\n                if (!program_header || program_header->p_type != PT_LOAD)\n                        continue;\n\n                /* Now get a usable Elf reference, and parse the notes from it. */\n                data = sym_elf_getdata_rawchunk(elf,\n                                                program_header->p_offset,\n                                                program_header->p_filesz,\n                                                ELF_T_NHDR);\n                if (!data)\n                        continue;\n\n                _cleanup_(sym_elf_endp) Elf *memelf = sym_elf_memory(data->d_buf, data->d_size);\n                if (!memelf)\n                        continue;\n                r = parse_package_metadata(name, id_json, memelf, NULL, c);\n                if (r < 0)\n                        return DWARF_CB_ABORT;\n                if (r > 0)\n                        break;\n        }\n\n        return DWARF_CB_OK;\n}\n\nstatic int parse_core(int fd, const char *executable, char **ret, JsonVariant **ret_package_metadata) {\n\n        const Dwfl_Callbacks callbacks = {\n                .find_elf = sym_dwfl_build_id_find_elf,\n                .section_address = sym_dwfl_offline_section_address,\n                .find_debuginfo = sym_dwfl_standard_find_debuginfo,\n        };\n\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;\n        _cleanup_(set_freep) Set *modules = NULL;\n        _cleanup_free_ char *buf = NULL; /* buf should be freed last, c.f closed first (via stack_context_destroy) */\n        _cleanup_(stack_context_destroy) StackContext c = {\n                .package_metadata = &package_metadata,\n                .modules = &modules,\n        };\n        size_t sz = 0;\n        int r;\n\n        assert(fd >= 0);\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_warning_errno(errno, \"Failed to seek to beginning of the core file: %m\");\n\n        if (ret) {\n                c.f = open_memstream_unlocked(&buf, &sz);\n                if (!c.f)\n                        return log_oom();\n        }\n\n        sym_elf_version(EV_CURRENT);\n\n        c.elf = sym_elf_begin(fd, ELF_C_READ_MMAP, NULL);\n        if (!c.elf)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, elf_begin() failed: %s\", sym_elf_errmsg(sym_elf_errno()));\n\n        c.dwfl = sym_dwfl_begin(&callbacks);\n        if (!c.dwfl)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_begin() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_core_file_report(c.dwfl, c.elf, executable) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_core_file_report() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_report_end(c.dwfl, NULL, NULL) != 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_report_end() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_getmodules(c.dwfl, &module_callback, &c, 0) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_getmodules() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_core_file_attach(c.dwfl, c.elf) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_core_file_attach() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_getthreads(c.dwfl, thread_callback, &c) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_getthreads() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (ret) {\n                r = fflush_and_check(c.f);\n                if (r < 0)\n                        return log_warning_errno(r, \"Could not parse core file, flushing file buffer failed: %m\");\n\n                c.f = safe_fclose(c.f);\n                *ret = TAKE_PTR(buf);\n        }\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}\n\nstatic int parse_elf(int fd, const char *executable, char **ret, JsonVariant **ret_package_metadata) {\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL, *elf_metadata = NULL;\n        _cleanup_(set_freep) Set *modules = NULL;\n        _cleanup_free_ char *buf = NULL; /* buf should be freed last, c.f closed first (via stack_context_destroy) */\n        _cleanup_(stack_context_destroy) StackContext c = {\n                .package_metadata = &package_metadata,\n                .modules = &modules,\n        };\n        const char *elf_type;\n        GElf_Ehdr elf_header;\n        size_t sz = 0;\n        int r;\n\n        assert(fd >= 0);\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_warning_errno(errno, \"Failed to seek to beginning of the ELF file: %m\");\n\n        if (ret) {\n                c.f = open_memstream_unlocked(&buf, &sz);\n                if (!c.f)\n                        return log_oom();\n        }\n\n        sym_elf_version(EV_CURRENT);\n\n        c.elf = sym_elf_begin(fd, ELF_C_READ_MMAP, NULL);\n        if (!c.elf)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse ELF file, elf_begin() failed: %s\", sym_elf_errmsg(sym_elf_errno()));\n\n        if (!sym_gelf_getehdr(c.elf, &elf_header))\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse ELF file, gelf_getehdr() failed: %s\", sym_elf_errmsg(sym_elf_errno()));\n\n        if (elf_header.e_type == ET_CORE) {\n                _cleanup_free_ char *out = NULL;\n\n                r = parse_core(fd, executable, ret ? &out : NULL, &package_metadata);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to inspect core file: %m\");\n\n                if (out)\n                        fprintf(c.f, \"%s\", out);\n\n                elf_type = \"coredump\";\n        } else {\n                _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;\n                const char *e = executable ?: \"(unnamed)\";\n                bool interpreter_found = false;\n\n                r = parse_buildid(NULL, c.elf, e, &c, &id_json);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to parse build-id of ELF file: %m\");\n\n                r = parse_package_metadata(e, id_json, c.elf, &interpreter_found, &c);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to parse package metadata of ELF file: %m\");\n\n                /* If we found a build-id and nothing else, return at least that. */\n                if (!package_metadata && id_json) {\n                        r = json_build(&package_metadata, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(e, JSON_BUILD_VARIANT(id_json))));\n                        if (r < 0)\n                                return log_warning_errno(r, \"Failed to build JSON object: %m\");\n                }\n\n                if (interpreter_found)\n                        elf_type = \"executable\";\n                else\n                        elf_type = \"library\";\n        }\n\n        /* Note that e_type is always DYN for both executables and libraries, so we can't tell them apart from the header,\n         * but we will search for the PT_INTERP section when parsing the metadata. */\n        r = json_build(&elf_metadata, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(\"elfType\", JSON_BUILD_STRING(elf_type))));\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to build JSON object: %m\");\n\n#if HAVE_DWELF_ELF_E_MACHINE_STRING\n        const char *elf_architecture = sym_dwelf_elf_e_machine_string(elf_header.e_machine);\n        if (elf_architecture) {\n                _cleanup_(json_variant_unrefp) JsonVariant *json_architecture = NULL;\n\n                r = json_build(&json_architecture,\n                                JSON_BUILD_OBJECT(JSON_BUILD_PAIR(\"elfArchitecture\", JSON_BUILD_STRING(elf_architecture))));\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to build JSON object: %m\");\n\n                r = json_variant_merge(&elf_metadata, json_architecture);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to merge JSON objects: %m\");\n\n                if (ret)\n                        fprintf(c.f, \"ELF object binary architecture: %s\\n\", elf_architecture);\n        }\n#endif\n\n        /* We always at least have the ELF type, so merge that (and possibly the arch). */\n        r = json_variant_merge(&elf_metadata, package_metadata);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to merge JSON objects: %m\");\n\n        if (ret) {\n                r = fflush_and_check(c.f);\n                if (r < 0)\n                        return log_warning_errno(r, \"Could not parse ELF file, flushing file buffer failed: %m\");\n\n                c.f = safe_fclose(c.f);\n                *ret = TAKE_PTR(buf);\n        }\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(elf_metadata);\n\n        return 0;\n}\n\nint parse_elf_object(int fd, const char *executable, bool fork_disable_dump, char **ret, JsonVariant **ret_package_metadata) {\n        _cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 };\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;\n        _cleanup_free_ char *buf = NULL;\n        int r;\n\n        assert(fd >= 0);\n\n        r = dlopen_dw();\n        if (r < 0)\n                return r;\n\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. */\n        r = safe_fork_full(\"(sd-parse-elf)\",\n                           (int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] },\n                           4,\n                           FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG,\n                           NULL);\n        if (r < 0) {\n                if (r == -EPROTO) { /* We should have the errno from the child, but don't clobber original error */\n                        int e, k;\n\n                        k = read(error_pipe[0], &e, sizeof(e));\n                        if (k < 0 && errno != EAGAIN) /* Pipe is non-blocking, EAGAIN means there's nothing */\n                                return -errno;\n                        if (k == sizeof(e))\n                                return e; /* propagate error sent to us from child */\n                        if (k != 0)\n                                return -EIO;\n                }\n\n                return r;\n        }\n        if (r == 0) {\n                /* We want to avoid loops, given this can be called from systemd-coredump */\n                if (fork_disable_dump) {\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        r = loop_write(return_pipe[1], buf, strlen(buf), false);\n                        if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n        return_pipe[1] = safe_close(return_pipe[1]);\n        json_pipe[1] = safe_close(json_pipe[1]);\n\n        if (ret) {\n                _cleanup_fclose_ FILE *in = NULL;\n\n                in = take_fdopen(&return_pipe[0], \"r\");\n                if (!in)\n                        return -errno;\n\n                r = read_full_stream(in, &buf, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        return r;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}\n\n#endif\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#if HAVE_ELFUTILS\n\n#include <dwarf.h>\n#include <elfutils/libdwelf.h>\n#include <elfutils/libdwfl.h>\n#include <libelf.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"dlfcn-util.h\"\n#include \"elf-util.h\"\n#include \"errno-util.h\"\n#include \"fileio.h\"\n#include \"fd-util.h\"\n#include \"format-util.h\"\n#include \"hexdecoct.h\"\n#include \"io-util.h\"\n#include \"macro.h\"\n#include \"process-util.h\"\n#include \"rlimit-util.h\"\n#include \"string-util.h\"\n#include \"util.h\"\n\n#define FRAMES_MAX 64\n#define THREADS_MAX 64\n#define ELF_PACKAGE_METADATA_ID 0xcafe1a7e\n\n/* The amount of data we're willing to write to each of the output pipes. */\n#define COREDUMP_PIPE_MAX (1024*1024U)\n\nstatic void *dw_dl = NULL;\nstatic void *elf_dl = NULL;\n\n/* libdw symbols */\nDwarf_Attribute *(*sym_dwarf_attr_integrate)(Dwarf_Die *, unsigned int, Dwarf_Attribute *);\nconst char *(*sym_dwarf_diename)(Dwarf_Die *);\nconst char *(*sym_dwarf_formstring)(Dwarf_Attribute *);\nint (*sym_dwarf_getscopes)(Dwarf_Die *, Dwarf_Addr, Dwarf_Die **);\nint (*sym_dwarf_getscopes_die)(Dwarf_Die *, Dwarf_Die **);\nElf *(*sym_dwelf_elf_begin)(int);\n#if HAVE_DWELF_ELF_E_MACHINE_STRING\nconst char *(*sym_dwelf_elf_e_machine_string)(int);\n#endif\nssize_t (*sym_dwelf_elf_gnu_build_id)(Elf *, const void **);\nint (*sym_dwarf_tag)(Dwarf_Die *);\nDwfl_Module *(*sym_dwfl_addrmodule)(Dwfl *, Dwarf_Addr);\nDwfl *(*sym_dwfl_begin)(const Dwfl_Callbacks *);\nint (*sym_dwfl_build_id_find_elf)(Dwfl_Module *, void **, const char *, Dwarf_Addr, char **, Elf **);\nint (*sym_dwfl_core_file_attach)(Dwfl *, Elf *);\nint (*sym_dwfl_core_file_report)(Dwfl *, Elf *, const char *);\nvoid (*sym_dwfl_end)(Dwfl *);\nconst char *(*sym_dwfl_errmsg)(int);\nint (*sym_dwfl_errno)(void);\nbool (*sym_dwfl_frame_pc)(Dwfl_Frame *, Dwarf_Addr *, bool *);\nptrdiff_t (*sym_dwfl_getmodules)(Dwfl *, int (*)(Dwfl_Module *, void **, const char *, Dwarf_Addr, void *), void *, ptrdiff_t);\nint (*sym_dwfl_getthreads)(Dwfl *, int (*)(Dwfl_Thread *, void *), void *);\nDwarf_Die *(*sym_dwfl_module_addrdie)(Dwfl_Module *, Dwarf_Addr, Dwarf_Addr *);\nconst char *(*sym_dwfl_module_addrname)(Dwfl_Module *, GElf_Addr);\nint (*sym_dwfl_module_build_id)(Dwfl_Module *, const unsigned char **, GElf_Addr *);\nElf *(*sym_dwfl_module_getelf)(Dwfl_Module *, GElf_Addr *);\nconst char *(*sym_dwfl_module_info)(Dwfl_Module *, void ***, Dwarf_Addr *, Dwarf_Addr *, Dwarf_Addr *, Dwarf_Addr *, const char **, const char **);\nint (*sym_dwfl_offline_section_address)(Dwfl_Module *, void **, const char *, Dwarf_Addr, const char *, GElf_Word, const GElf_Shdr *, Dwarf_Addr *);\nint (*sym_dwfl_report_end)(Dwfl *, int (*)(Dwfl_Module *, void *, const char *, Dwarf_Addr, void *), void *);\nint (*sym_dwfl_standard_find_debuginfo)(Dwfl_Module *, void **, const char *, Dwarf_Addr, const char *, const char *, GElf_Word, char **);\nint (*sym_dwfl_thread_getframes)(Dwfl_Thread *, int (*)(Dwfl_Frame *, void *), void *);\npid_t (*sym_dwfl_thread_tid)(Dwfl_Thread *);\n\n/* libelf symbols */\nElf *(*sym_elf_begin)(int, Elf_Cmd, Elf *);\nint (*sym_elf_end)(Elf *);\nElf_Data *(*sym_elf_getdata_rawchunk)(Elf *, int64_t, size_t, Elf_Type);\nGElf_Ehdr *(*sym_gelf_getehdr)(Elf *, GElf_Ehdr *);\nint (*sym_elf_getphdrnum)(Elf *, size_t *);\nconst char *(*sym_elf_errmsg)(int);\nint (*sym_elf_errno)(void);\nElf *(*sym_elf_memory)(char *, size_t);\nunsigned int (*sym_elf_version)(unsigned int);\nGElf_Phdr *(*sym_gelf_getphdr)(Elf *, int, GElf_Phdr *);\nsize_t (*sym_gelf_getnote)(Elf_Data *, size_t, GElf_Nhdr *, size_t *, size_t *);\n\nint dlopen_dw(void) {\n        int r;\n\n        r = dlopen_many_sym_or_warn(\n                        &dw_dl, \"libdw.so.1\", LOG_DEBUG,\n                        DLSYM_ARG(dwarf_getscopes),\n                        DLSYM_ARG(dwarf_getscopes_die),\n                        DLSYM_ARG(dwarf_tag),\n                        DLSYM_ARG(dwarf_attr_integrate),\n                        DLSYM_ARG(dwarf_formstring),\n                        DLSYM_ARG(dwarf_diename),\n                        DLSYM_ARG(dwelf_elf_gnu_build_id),\n                        DLSYM_ARG(dwelf_elf_begin),\n#if HAVE_DWELF_ELF_E_MACHINE_STRING\n                        DLSYM_ARG(dwelf_elf_e_machine_string),\n#endif\n                        DLSYM_ARG(dwfl_addrmodule),\n                        DLSYM_ARG(dwfl_frame_pc),\n                        DLSYM_ARG(dwfl_module_addrdie),\n                        DLSYM_ARG(dwfl_module_addrname),\n                        DLSYM_ARG(dwfl_module_info),\n                        DLSYM_ARG(dwfl_module_build_id),\n                        DLSYM_ARG(dwfl_module_getelf),\n                        DLSYM_ARG(dwfl_begin),\n                        DLSYM_ARG(dwfl_core_file_report),\n                        DLSYM_ARG(dwfl_report_end),\n                        DLSYM_ARG(dwfl_getmodules),\n                        DLSYM_ARG(dwfl_core_file_attach),\n                        DLSYM_ARG(dwfl_end),\n                        DLSYM_ARG(dwfl_errmsg),\n                        DLSYM_ARG(dwfl_errno),\n                        DLSYM_ARG(dwfl_build_id_find_elf),\n                        DLSYM_ARG(dwfl_standard_find_debuginfo),\n                        DLSYM_ARG(dwfl_thread_tid),\n                        DLSYM_ARG(dwfl_thread_getframes),\n                        DLSYM_ARG(dwfl_getthreads),\n                        DLSYM_ARG(dwfl_offline_section_address));\n        if (r <= 0)\n                return r;\n\n        return 1;\n}\n\nint dlopen_elf(void) {\n        int r;\n\n        r = dlopen_many_sym_or_warn(\n                        &elf_dl, \"libelf.so.1\", LOG_DEBUG,\n                        DLSYM_ARG(elf_begin),\n                        DLSYM_ARG(elf_end),\n                        DLSYM_ARG(elf_getphdrnum),\n                        DLSYM_ARG(elf_getdata_rawchunk),\n                        DLSYM_ARG(elf_errmsg),\n                        DLSYM_ARG(elf_errno),\n                        DLSYM_ARG(elf_memory),\n                        DLSYM_ARG(elf_version),\n                        DLSYM_ARG(gelf_getehdr),\n                        DLSYM_ARG(gelf_getphdr),\n                        DLSYM_ARG(gelf_getnote));\n        if (r <= 0)\n                return r;\n\n        return 1;\n}\n\ntypedef struct StackContext {\n        FILE *f;\n        Dwfl *dwfl;\n        Elf *elf;\n        unsigned n_thread;\n        unsigned n_frame;\n        JsonVariant **package_metadata;\n        Set **modules;\n} StackContext;\n\nstatic StackContext* stack_context_destroy(StackContext *c) {\n        if (!c)\n                return NULL;\n\n        c->f = safe_fclose(c->f);\n\n        if (c->dwfl) {\n                sym_dwfl_end(c->dwfl);\n                c->dwfl = NULL;\n        }\n\n        if (c->elf) {\n                sym_elf_end(c->elf);\n                c->elf = NULL;\n        }\n\n        return NULL;\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(Elf *, sym_elf_end, NULL);\n\nstatic int frame_callback(Dwfl_Frame *frame, void *userdata) {\n        StackContext *c = ASSERT_PTR(userdata);\n        Dwarf_Addr pc, pc_adjusted;\n        const char *fname = NULL, *symbol = NULL;\n        Dwfl_Module *module;\n        bool is_activation;\n        uint64_t module_offset = 0;\n\n        assert(frame);\n\n        if (c->n_frame >= FRAMES_MAX)\n                return DWARF_CB_ABORT;\n\n        if (!sym_dwfl_frame_pc(frame, &pc, &is_activation))\n                return DWARF_CB_ABORT;\n\n        pc_adjusted = pc - (is_activation ? 0 : 1);\n\n        module = sym_dwfl_addrmodule(c->dwfl, pc_adjusted);\n        if (module) {\n                Dwarf_Addr start, bias = 0;\n                Dwarf_Die *cudie;\n\n                cudie = sym_dwfl_module_addrdie(module, pc_adjusted, &bias);\n                if (cudie) {\n                        _cleanup_free_ Dwarf_Die *scopes = NULL;\n                        int n;\n\n                        n = sym_dwarf_getscopes(cudie, pc_adjusted - bias, &scopes);\n                        if (n > 0)\n                                for (Dwarf_Die *s = scopes; s && s < scopes + n; s++) {\n                                        Dwarf_Attribute *a, space;\n\n                                        if (!IN_SET(sym_dwarf_tag(s), DW_TAG_subprogram, DW_TAG_inlined_subroutine, DW_TAG_entry_point))\n                                                continue;\n\n                                        a = sym_dwarf_attr_integrate(s, DW_AT_MIPS_linkage_name, &space);\n                                        if (!a)\n                                                a = sym_dwarf_attr_integrate(s, DW_AT_linkage_name, &space);\n                                        if (a)\n                                                symbol = sym_dwarf_formstring(a);\n                                        if (!symbol)\n                                                symbol = sym_dwarf_diename(s);\n\n                                        if (symbol)\n                                                break;\n                                }\n                }\n\n                if (!symbol)\n                        symbol = sym_dwfl_module_addrname(module, pc_adjusted);\n\n                fname = sym_dwfl_module_info(module, NULL, &start, NULL, NULL, NULL, NULL, NULL);\n                module_offset = pc - start;\n        }\n\n        if (c->f)\n                fprintf(c->f, \"#%-2u 0x%016\" PRIx64 \" %s (%s + 0x%\" PRIx64 \")\\n\", c->n_frame, (uint64_t) pc, strna(symbol), strna(fname), module_offset);\n        c->n_frame++;\n\n        return DWARF_CB_OK;\n}\n\nstatic int thread_callback(Dwfl_Thread *thread, void *userdata) {\n        StackContext *c = ASSERT_PTR(userdata);\n        pid_t tid;\n\n        assert(thread);\n\n        if (c->n_thread >= THREADS_MAX)\n                return DWARF_CB_ABORT;\n\n        if (c->n_thread != 0 && c->f)\n                fputc('\\n', c->f);\n\n        c->n_frame = 0;\n\n        if (c->f) {\n                tid = sym_dwfl_thread_tid(thread);\n                fprintf(c->f, \"Stack trace of thread \" PID_FMT \":\\n\", tid);\n        }\n\n        if (sym_dwfl_thread_getframes(thread, frame_callback, c) < 0)\n                return DWARF_CB_ABORT;\n\n        c->n_thread++;\n\n        return DWARF_CB_OK;\n}\n\nstatic char* build_package_reference(\n                const char *type,\n                const char *name,\n                const char *version,\n                const char *arch) {\n\n        /* Construct an identifier for a specific version of the package. The syntax is most suitable for\n         * rpm: the resulting string can be used directly in queries and rpm/dnf/yum commands. For dpkg and\n         * other systems, it might not be usable directly, but users should still be able to figure out the\n         * meaning.\n         */\n\n        return strjoin(type ?: \"package\",\n                       \" \",\n                       name,\n\n                       version ? \"-\" : \"\",\n                       strempty(version),\n\n                       /* arch is meaningful even without version, so always print it */\n                       arch ? \".\" : \"\",\n                       strempty(arch));\n}\n\nstatic void report_module_metadata(StackContext *c, const char *name, JsonVariant *metadata) {\n        assert(c);\n        assert(name);\n\n        if (!c->f)\n                return;\n\n        fprintf(c->f, \"Module %s\", name);\n\n        if (metadata) {\n                const char\n                        *build_id = json_variant_string(json_variant_by_key(metadata, \"buildId\")),\n                        *type = json_variant_string(json_variant_by_key(metadata, \"type\")),\n                        *package = json_variant_string(json_variant_by_key(metadata, \"name\")),\n                        *version = json_variant_string(json_variant_by_key(metadata, \"version\")),\n                        *arch = json_variant_string(json_variant_by_key(metadata, \"architecture\"));\n\n                if (package) {\n                        /* Version/architecture is only meaningful with a package name.\n                         * Skip the detailed fields if package is unknown. */\n                        _cleanup_free_ char *id = build_package_reference(type, package, version, arch);\n                        fprintf(c->f, \" from %s\", strnull(id));\n                }\n\n                if (build_id && !(package && version))\n                        fprintf(c->f, \", build-id=%s\", build_id);\n        }\n\n        fputs(\"\\n\", c->f);\n}\n\nstatic int parse_package_metadata(const char *name, JsonVariant *id_json, Elf *elf, bool *ret_interpreter_found, StackContext *c) {\n        bool interpreter_found = false;\n        size_t n_program_headers;\n        int r;\n\n        assert(name);\n        assert(elf);\n        assert(c);\n\n        /* When iterating over PT_LOAD we will visit modules more than once */\n        if (set_contains(*c->modules, name))\n                return 0;\n\n        r = sym_elf_getphdrnum(elf, &n_program_headers);\n        if (r < 0) /* Not the handle we are looking for - that's ok, skip it */\n                return 0;\n\n        /* Iterate over all program headers in that ELF object. These will have been copied by\n         * the kernel verbatim when the core file is generated. */\n        for (size_t i = 0; i < n_program_headers; ++i) {\n                GElf_Phdr mem, *program_header;\n                GElf_Nhdr note_header;\n                Elf_Data *data;\n\n                /* Package metadata is in PT_NOTE headers. */\n                program_header = sym_gelf_getphdr(elf, i, &mem);\n                if (!program_header || (program_header->p_type != PT_NOTE && program_header->p_type != PT_INTERP))\n                        continue;\n\n                if (program_header->p_type == PT_INTERP) {\n                        interpreter_found = true;\n                        continue;\n                }\n\n                /* Fortunately there is an iterator we can use to walk over the\n                 * elements of a PT_NOTE program header. We are interested in the\n                 * note with type. */\n                data = sym_elf_getdata_rawchunk(elf,\n                                                program_header->p_offset,\n                                                program_header->p_filesz,\n                                                ELF_T_NHDR);\n                if (!data)\n                        continue;\n\n                for (size_t note_offset = 0, name_offset, desc_offset;\n                     note_offset < data->d_size &&\n                     (note_offset = sym_gelf_getnote(data, note_offset, &note_header, &name_offset, &desc_offset)) > 0;) {\n\n                        _cleanup_(json_variant_unrefp) JsonVariant *v = NULL, *w = NULL;\n                        const char *payload = (const char *)data->d_buf + desc_offset;\n\n                        if (note_header.n_namesz == 0 || note_header.n_descsz == 0)\n                                continue;\n\n                        /* Package metadata might have different owners, but the\n                         * magic ID is always the same. */\n                        if (note_header.n_type != ELF_PACKAGE_METADATA_ID)\n                                continue;\n\n                        _cleanup_free_ char *payload_0suffixed = NULL;\n                        assert(note_offset > desc_offset);\n                        size_t payload_len = note_offset - desc_offset;\n\n                        /* If we are lucky and the payload is NUL-padded, we don't need to copy the string.\n                         * But if happens to go all the way until the end of the buffer, make a copy. */\n                        if (payload[payload_len-1] != '\\0') {\n                                payload_0suffixed = memdup_suffix0(payload, payload_len);\n                                if (!payload_0suffixed)\n                                        return log_oom();\n                                payload = payload_0suffixed;\n                        }\n\n                        r = json_parse(payload, 0, &v, NULL, NULL);\n                        if (r < 0)\n                                return log_error_errno(r, \"json_parse on %s failed: %m\", payload);\n\n                        /* If we have a build-id, merge it in the same JSON object so that it appears all\n                         * nicely together in the logs/metadata. */\n                        if (id_json) {\n                                r = json_variant_merge(&v, id_json);\n                                if (r < 0)\n                                        return log_error_errno(r, \"json_variant_merge of package meta with buildId failed: %m\");\n                        }\n\n                        /* Pretty-print to the buffer, so that the metadata goes as plaintext in the\n                         * journal. */\n                        report_module_metadata(c, name, v);\n\n                        /* Then we build a new object using the module name as the key, and merge it\n                         * with the previous parses, so that in the end it all fits together in a single\n                         * JSON blob. */\n                        r = json_build(&w, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(name, JSON_BUILD_VARIANT(v))));\n                        if (r < 0)\n                                return log_error_errno(r, \"Failed to build JSON object: %m\");\n\n                        r = json_variant_merge(c->package_metadata, w);\n                        if (r < 0)\n                                return log_error_errno(r, \"json_variant_merge of package meta with buildId failed: %m\");\n\n                        /* Finally stash the name, so we avoid double visits. */\n                        r = set_put_strdup(c->modules, name);\n                        if (r < 0)\n                                return log_error_errno(r, \"set_put_strdup failed: %m\");\n\n                        if (ret_interpreter_found)\n                                *ret_interpreter_found = interpreter_found;\n\n                        return 1;\n                }\n        }\n\n        if (ret_interpreter_found)\n                *ret_interpreter_found = interpreter_found;\n\n        /* Didn't find package metadata for this module - that's ok, just go to the next. */\n        return 0;\n}\n\n/* Get the build-id out of an ELF object or a dwarf core module. */\nstatic int parse_buildid(Dwfl_Module *mod, Elf *elf, const char *name, StackContext *c, JsonVariant **ret_id_json) {\n        _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;\n        const unsigned char *id;\n        GElf_Addr id_vaddr;\n        ssize_t id_len;\n        int r;\n\n        assert(mod || elf);\n        assert(name);\n        assert(c);\n\n        if (mod)\n                id_len = sym_dwfl_module_build_id(mod, &id, &id_vaddr);\n        else\n                id_len = sym_dwelf_elf_gnu_build_id(elf, (const void **)&id);\n        if (id_len <= 0) {\n                /* If we don't find a build-id, note it in the journal message, and try\n                 * anyway to find the package metadata. It's unlikely to have the latter\n                 * without the former, but there's no hard rule. */\n                if (c->f)\n                        fprintf(c->f, \"Module %s without build-id.\\n\", name);\n        } else {\n                /* We will later parse package metadata json and pass it to our caller. Prepare the\n                * build-id in json format too, so that it can be appended and parsed cleanly. It\n                * will then be added as metadata to the journal message with the stack trace. */\n                r = json_build(&id_json, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(\"buildId\", JSON_BUILD_HEX(id, id_len))));\n                if (r < 0)\n                        return log_error_errno(r, \"json_build on buildId failed: %m\");\n        }\n\n        if (ret_id_json)\n                *ret_id_json = TAKE_PTR(id_json);\n\n        return 0;\n}\n\nstatic int module_callback(Dwfl_Module *mod, void **userdata, const char *name, Dwarf_Addr start, void *arg) {\n        _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;\n        StackContext *c = ASSERT_PTR(arg);\n        size_t n_program_headers;\n        GElf_Addr bias;\n        int r;\n        Elf *elf;\n\n        assert(mod);\n\n        if (!name)\n                name = \"(unnamed)\"; /* For logging purposes */\n\n        /* We are iterating on each \"module\", which is what dwfl calls ELF objects contained in the\n         * core file, and extracting the build-id first and then the package metadata.\n         * We proceed in a best-effort fashion - not all ELF objects might contain both or either.\n         * The build-id is easy, as libdwfl parses it during the sym_dwfl_core_file_report() call and\n         * stores it separately in an internal library struct. */\n        r = parse_buildid(mod, NULL, name, c, &id_json);\n        if (r < 0)\n                return DWARF_CB_ABORT;\n\n        /* The .note.package metadata is more difficult. From the module, we need to get a reference\n         * to the ELF object first. We might be lucky and just get it from elfutils. */\n        elf = sym_dwfl_module_getelf(mod, &bias);\n        if (elf) {\n                r = parse_package_metadata(name, id_json, elf, NULL, c);\n                if (r < 0)\n                        return DWARF_CB_ABORT;\n                if (r > 0)\n                        return DWARF_CB_OK;\n        } else\n                elf = c->elf;\n\n        /* We did not get the ELF object, or it's just a reference to the core. That is likely\n         * because we didn't get direct access to the executable, and the version of elfutils does\n         * not yet support parsing it out of the core file directly.\n         * So fallback to manual extraction - get the PT_LOAD section from the core,\n         * and if it's the right one we can interpret it as an Elf object, and parse\n         * its notes manually. */\n\n        r = sym_elf_getphdrnum(elf, &n_program_headers);\n        if (r < 0) {\n                log_warning(\"Could not parse number of program headers from core file: %s\",\n                            sym_elf_errmsg(-1)); /* -1 retrieves the most recent error */\n                report_module_metadata(c, name, id_json);\n\n                return DWARF_CB_OK;\n        }\n\n        for (size_t i = 0; i < n_program_headers; ++i) {\n                GElf_Phdr mem, *program_header;\n                Elf_Data *data;\n\n                /* The core file stores the ELF files in the PT_LOAD segment. */\n                program_header = sym_gelf_getphdr(elf, i, &mem);\n                if (!program_header || program_header->p_type != PT_LOAD)\n                        continue;\n\n                /* Now get a usable Elf reference, and parse the notes from it. */\n                data = sym_elf_getdata_rawchunk(elf,\n                                                program_header->p_offset,\n                                                program_header->p_filesz,\n                                                ELF_T_NHDR);\n                if (!data)\n                        continue;\n\n                _cleanup_(sym_elf_endp) Elf *memelf = sym_elf_memory(data->d_buf, data->d_size);\n                if (!memelf)\n                        continue;\n                r = parse_package_metadata(name, id_json, memelf, NULL, c);\n                if (r < 0)\n                        return DWARF_CB_ABORT;\n                if (r > 0)\n                        break;\n        }\n\n        return DWARF_CB_OK;\n}\n\nstatic int parse_core(int fd, const char *executable, char **ret, JsonVariant **ret_package_metadata) {\n\n        const Dwfl_Callbacks callbacks = {\n                .find_elf = sym_dwfl_build_id_find_elf,\n                .section_address = sym_dwfl_offline_section_address,\n                .find_debuginfo = sym_dwfl_standard_find_debuginfo,\n        };\n\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;\n        _cleanup_(set_freep) Set *modules = NULL;\n        _cleanup_free_ char *buf = NULL; /* buf should be freed last, c.f closed first (via stack_context_destroy) */\n        _cleanup_(stack_context_destroy) StackContext c = {\n                .package_metadata = &package_metadata,\n                .modules = &modules,\n        };\n        size_t sz = 0;\n        int r;\n\n        assert(fd >= 0);\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_warning_errno(errno, \"Failed to seek to beginning of the core file: %m\");\n\n        if (ret) {\n                c.f = open_memstream_unlocked(&buf, &sz);\n                if (!c.f)\n                        return log_oom();\n        }\n\n        sym_elf_version(EV_CURRENT);\n\n        c.elf = sym_elf_begin(fd, ELF_C_READ_MMAP, NULL);\n        if (!c.elf)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, elf_begin() failed: %s\", sym_elf_errmsg(sym_elf_errno()));\n\n        c.dwfl = sym_dwfl_begin(&callbacks);\n        if (!c.dwfl)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_begin() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_core_file_report(c.dwfl, c.elf, executable) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_core_file_report() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_report_end(c.dwfl, NULL, NULL) != 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_report_end() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_getmodules(c.dwfl, &module_callback, &c, 0) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_getmodules() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_core_file_attach(c.dwfl, c.elf) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_core_file_attach() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (sym_dwfl_getthreads(c.dwfl, thread_callback, &c) < 0)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse core file, dwfl_getthreads() failed: %s\", sym_dwfl_errmsg(sym_dwfl_errno()));\n\n        if (ret) {\n                r = fflush_and_check(c.f);\n                if (r < 0)\n                        return log_warning_errno(r, \"Could not parse core file, flushing file buffer failed: %m\");\n\n                c.f = safe_fclose(c.f);\n                *ret = TAKE_PTR(buf);\n        }\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}\n\nstatic int parse_elf(int fd, const char *executable, char **ret, JsonVariant **ret_package_metadata) {\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL, *elf_metadata = NULL;\n        _cleanup_(set_freep) Set *modules = NULL;\n        _cleanup_free_ char *buf = NULL; /* buf should be freed last, c.f closed first (via stack_context_destroy) */\n        _cleanup_(stack_context_destroy) StackContext c = {\n                .package_metadata = &package_metadata,\n                .modules = &modules,\n        };\n        const char *elf_type;\n        GElf_Ehdr elf_header;\n        size_t sz = 0;\n        int r;\n\n        assert(fd >= 0);\n\n        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)\n                return log_warning_errno(errno, \"Failed to seek to beginning of the ELF file: %m\");\n\n        if (ret) {\n                c.f = open_memstream_unlocked(&buf, &sz);\n                if (!c.f)\n                        return log_oom();\n        }\n\n        sym_elf_version(EV_CURRENT);\n\n        c.elf = sym_elf_begin(fd, ELF_C_READ_MMAP, NULL);\n        if (!c.elf)\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse ELF file, elf_begin() failed: %s\", sym_elf_errmsg(sym_elf_errno()));\n\n        if (!sym_gelf_getehdr(c.elf, &elf_header))\n                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), \"Could not parse ELF file, gelf_getehdr() failed: %s\", sym_elf_errmsg(sym_elf_errno()));\n\n        if (elf_header.e_type == ET_CORE) {\n                _cleanup_free_ char *out = NULL;\n\n                r = parse_core(fd, executable, ret ? &out : NULL, &package_metadata);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to inspect core file: %m\");\n\n                if (out)\n                        fprintf(c.f, \"%s\", out);\n\n                elf_type = \"coredump\";\n        } else {\n                _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;\n                const char *e = executable ?: \"(unnamed)\";\n                bool interpreter_found = false;\n\n                r = parse_buildid(NULL, c.elf, e, &c, &id_json);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to parse build-id of ELF file: %m\");\n\n                r = parse_package_metadata(e, id_json, c.elf, &interpreter_found, &c);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to parse package metadata of ELF file: %m\");\n\n                /* If we found a build-id and nothing else, return at least that. */\n                if (!package_metadata && id_json) {\n                        r = json_build(&package_metadata, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(e, JSON_BUILD_VARIANT(id_json))));\n                        if (r < 0)\n                                return log_warning_errno(r, \"Failed to build JSON object: %m\");\n                }\n\n                if (interpreter_found)\n                        elf_type = \"executable\";\n                else\n                        elf_type = \"library\";\n        }\n\n        /* Note that e_type is always DYN for both executables and libraries, so we can't tell them apart from the header,\n         * but we will search for the PT_INTERP section when parsing the metadata. */\n        r = json_build(&elf_metadata, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(\"elfType\", JSON_BUILD_STRING(elf_type))));\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to build JSON object: %m\");\n\n#if HAVE_DWELF_ELF_E_MACHINE_STRING\n        const char *elf_architecture = sym_dwelf_elf_e_machine_string(elf_header.e_machine);\n        if (elf_architecture) {\n                _cleanup_(json_variant_unrefp) JsonVariant *json_architecture = NULL;\n\n                r = json_build(&json_architecture,\n                                JSON_BUILD_OBJECT(JSON_BUILD_PAIR(\"elfArchitecture\", JSON_BUILD_STRING(elf_architecture))));\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to build JSON object: %m\");\n\n                r = json_variant_merge(&elf_metadata, json_architecture);\n                if (r < 0)\n                        return log_warning_errno(r, \"Failed to merge JSON objects: %m\");\n\n                if (ret)\n                        fprintf(c.f, \"ELF object binary architecture: %s\\n\", elf_architecture);\n        }\n#endif\n\n        /* We always at least have the ELF type, so merge that (and possibly the arch). */\n        r = json_variant_merge(&elf_metadata, package_metadata);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to merge JSON objects: %m\");\n\n        if (ret) {\n                r = fflush_and_check(c.f);\n                if (r < 0)\n                        return log_warning_errno(r, \"Could not parse ELF file, flushing file buffer failed: %m\");\n\n                c.f = safe_fclose(c.f);\n                *ret = TAKE_PTR(buf);\n        }\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(elf_metadata);\n\n        return 0;\n}\n\nint parse_elf_object(int fd, const char *executable, bool fork_disable_dump, char **ret, JsonVariant **ret_package_metadata) {\n        _cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 };\n        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;\n        _cleanup_free_ char *buf = NULL;\n        int r;\n\n        assert(fd >= 0);\n\n        r = dlopen_dw();\n        if (r < 0)\n                return r;\n\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. */\n        r = safe_fork_full(\"(sd-parse-elf)\",\n                           (int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] },\n                           4,\n                           FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG,\n                           NULL);\n        if (r < 0) {\n                if (r == -EPROTO) { /* We should have the errno from the child, but don't clobber original error */\n                        int e, k;\n\n                        k = read(error_pipe[0], &e, sizeof(e));\n                        if (k < 0 && errno != EAGAIN) /* Pipe is non-blocking, EAGAIN means there's nothing */\n                                return -errno;\n                        if (k == sizeof(e))\n                                return e; /* propagate error sent to us from child */\n                        if (k != 0)\n                                return -EIO;\n                }\n\n                return r;\n        }\n        if (r == 0) {\n                /* We want to avoid loops, given this can be called from systemd-coredump */\n                if (fork_disable_dump) {\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        size_t len = strlen(buf);\n\n                        if (len > COREDUMP_PIPE_MAX) {\n                                /* This is iffy. A backtrace can be a few hundred kilobytes, but too much is\n                                 * too much. Let's log a warning and ignore the rest. */\n                                log_warning(\"Generated backtrace is %zu bytes (more than the limit of %u bytes), backtrace will be truncated.\",\n                                            len, COREDUMP_PIPE_MAX);\n                                len = COREDUMP_PIPE_MAX;\n                        }\n\n                        /* Bump the space for the returned string.\n                         * Failure is ignored, because partial output is still useful. */\n                        (void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);\n\n                        r = loop_write(return_pipe[1], buf, len, false);\n                        if (r == -EAGAIN)\n                                log_warning(\"Write failed, backtrace will be truncated.\");\n                        else if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        /* Bump the space for the returned string. We don't know how much space we'll need in\n                         * advance, so we'll just try to write as much as possible and maybe fail later. */\n                        (void) fcntl(json_pipe[1], F_SETPIPE_SZ, COREDUMP_PIPE_MAX);\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        r = json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to write JSON package metadata, ignoring: %m\");\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n        return_pipe[1] = safe_close(return_pipe[1]);\n        json_pipe[1] = safe_close(json_pipe[1]);\n\n        if (ret) {\n                _cleanup_fclose_ FILE *in = NULL;\n\n                in = take_fdopen(&return_pipe[0], \"r\");\n                if (!in)\n                        return -errno;\n\n                r = read_full_stream(in, &buf, NULL);\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        log_warning_errno(r, \"Failed to read or parse json metadata, ignoring: %m\");\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}\n\n#endif\n"], "filenames": ["src/shared/elf-util.c"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [864], "fixing_code_start_loc": [32], "fixing_code_end_loc": [889], "type": "CWE-400", "message": "systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock by triggering a crash that has a long backtrace. This occurs in parse_elf_object in shared/elf-util.c. The exploitation methodology is to crash a binary calling the same function recursively, and put it in a deeply nested directory to make its backtrace large enough to cause the deadlock. This must be done 16 times when MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file.", "other": {"cve": {"id": "CVE-2022-45873", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-23T23:15:10.183", "lastModified": "2023-03-01T14:27:34.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock by triggering a crash that has a long backtrace. This occurs in parse_elf_object in shared/elf-util.c. The exploitation methodology is to crash a binary calling the same function recursively, and put it in a deeply nested directory to make its backtrace large enough to cause the deadlock. This must be done 16 times when MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:*:*:*:*:*:*:*:*", "versionStartIncluding": "250", "versionEndIncluding": "251", "matchCriteriaId": "8AE4E7F2-A943-44CA-B44F-BDE0F8D09B53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:252:rc1:*:*:*:*:*:*", "matchCriteriaId": "55FF285C-8DFC-4A67-A426-1ADE349BEF8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:252:rc2:*:*:*:*:*:*", "matchCriteriaId": "0E0E4355-1411-43F3-8DCE-700BE15FC71C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/systemd/systemd/commit/076b807be472630692c5348c60d0c2b7b28ad437", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/pull/24853#issuecomment-1326561497", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/pull/25055#issuecomment-1313733553", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MS5N5SLYAHKENLAJWYBDKU55ICU3SVZF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/076b807be472630692c5348c60d0c2b7b28ad437"}}