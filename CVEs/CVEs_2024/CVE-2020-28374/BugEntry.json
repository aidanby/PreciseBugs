{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*******************************************************************************\n * Filename: target_core_xcopy.c\n *\n * This file contains support for SPC-4 Extended-Copy offload with generic\n * TCM backends.\n *\n * Copyright (c) 2011-2013 Datera, Inc. All rights reserved.\n *\n * Author:\n * Nicholas A. Bellinger <nab@daterainc.com>\n *\n ******************************************************************************/\n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/configfs.h>\n#include <linux/ratelimit.h>\n#include <scsi/scsi_proto.h>\n#include <asm/unaligned.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n#include \"target_core_xcopy.h\"\n\nstatic struct workqueue_struct *xcopy_wq = NULL;\n\nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop);\n\nstatic int target_xcopy_gen_naa_ieee(struct se_device *dev, unsigned char *buf)\n{\n\tint off = 0;\n\n\tbuf[off++] = (0x6 << 4);\n\tbuf[off++] = 0x01;\n\tbuf[off++] = 0x40;\n\tbuf[off] = (0x5 << 4);\n\n\tspc_parse_naa_6h_vendor_specific(dev, &buf[off]);\n\treturn 0;\n}\n\nstruct xcopy_dev_search_info {\n\tconst unsigned char *dev_wwn;\n\tstruct se_device *found_dev;\n};\n\nstatic int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}\n\nstatic int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,\n\t\t\t\tunsigned char *p, unsigned short cscd_index)\n{\n\tunsigned char *desc = p;\n\tunsigned short ript;\n\tu8 desig_len;\n\t/*\n\t * Extract RELATIVE INITIATOR PORT IDENTIFIER\n\t */\n\tript = get_unaligned_be16(&desc[2]);\n\tpr_debug(\"XCOPY 0xe4: RELATIVE INITIATOR PORT IDENTIFIER: %hu\\n\", ript);\n\t/*\n\t * Check for supported code set, association, and designator type\n\t */\n\tif ((desc[4] & 0x0f) != 0x1) {\n\t\tpr_err(\"XCOPY 0xe4: code set of non binary type not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((desc[5] & 0x30) != 0x00) {\n\t\tpr_err(\"XCOPY 0xe4: association other than LUN not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((desc[5] & 0x0f) != 0x3) {\n\t\tpr_err(\"XCOPY 0xe4: designator type unsupported: 0x%02x\\n\",\n\t\t\t\t(desc[5] & 0x0f));\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Check for matching 16 byte length for NAA IEEE Registered Extended\n\t * Assigned designator\n\t */\n\tdesig_len = desc[7];\n\tif (desig_len != XCOPY_NAA_IEEE_REGEX_LEN) {\n\t\tpr_err(\"XCOPY 0xe4: invalid desig_len: %d\\n\", (int)desig_len);\n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"XCOPY 0xe4: desig_len: %d\\n\", (int)desig_len);\n\t/*\n\t * Check for NAA IEEE Registered Extended Assigned header..\n\t */\n\tif ((desc[8] & 0xf0) != 0x60) {\n\t\tpr_err(\"XCOPY 0xe4: Unsupported DESIGNATOR TYPE: 0x%02x\\n\",\n\t\t\t\t\t(desc[8] & 0xf0));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cscd_index != xop->stdi && cscd_index != xop->dtdi) {\n\t\tpr_debug(\"XCOPY 0xe4: ignoring CSCD entry %d - neither src nor \"\n\t\t\t \"dest\\n\", cscd_index);\n\t\treturn 0;\n\t}\n\n\tif (cscd_index == xop->stdi) {\n\t\tmemcpy(&xop->src_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\n\t\t/*\n\t\t * Determine if the source designator matches the local device\n\t\t */\n\t\tif (!memcmp(&xop->local_dev_wwn[0], &xop->src_tid_wwn[0],\n\t\t\t\tXCOPY_NAA_IEEE_REGEX_LEN)) {\n\t\t\txop->op_origin = XCOL_SOURCE_RECV_OP;\n\t\t\txop->src_dev = se_cmd->se_dev;\n\t\t\tpr_debug(\"XCOPY 0xe4: Set xop->src_dev %p from source\"\n\t\t\t\t\t\" received xop\\n\", xop->src_dev);\n\t\t}\n\t}\n\n\tif (cscd_index == xop->dtdi) {\n\t\tmemcpy(&xop->dst_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\n\t\t/*\n\t\t * Determine if the destination designator matches the local\n\t\t * device. If @cscd_index corresponds to both source (stdi) and\n\t\t * destination (dtdi), or dtdi comes after stdi, then\n\t\t * XCOL_DEST_RECV_OP wins.\n\t\t */\n\t\tif (!memcmp(&xop->local_dev_wwn[0], &xop->dst_tid_wwn[0],\n\t\t\t\tXCOPY_NAA_IEEE_REGEX_LEN)) {\n\t\t\txop->op_origin = XCOL_DEST_RECV_OP;\n\t\t\txop->dst_dev = se_cmd->se_dev;\n\t\t\tpr_debug(\"XCOPY 0xe4: Set xop->dst_dev: %p from destination\"\n\t\t\t\t\" received xop\\n\", xop->dst_dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned short tdll, sense_reason_t *sense_ret)\n{\n\tstruct se_device *local_dev = se_cmd->se_dev;\n\tunsigned char *desc = p;\n\tint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\n\tunsigned short cscd_index = 0;\n\tunsigned short start = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY target descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_TARGET_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\n\t\tpr_err(\"XCOPY target descriptor supports a maximum\"\n\t\t\t\" two src/dest descriptors, tdll: %hu too large..\\n\", tdll);\n\t\t/* spc4r37 6.4.3.4 CSCD DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Generate an IEEE Registered Extended designator based upon the\n\t * se_device the XCOPY was received upon..\n\t */\n\tmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\n\n\twhile (start < tdll) {\n\t\t/*\n\t\t * Check target descriptor identification with 0xE4 type, and\n\t\t * compare the current index with the CSCD descriptor IDs in\n\t\t * the segment descriptor. Use VPD 0x83 WWPN matching ..\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0xe4:\n\t\t\trc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\n\t\t\t\t\t\t\t&desc[0], cscd_index);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto out;\n\t\t\tstart += XCOPY_TARGET_DESC_LEN;\n\t\t\tdesc += XCOPY_TARGET_DESC_LEN;\n\t\t\tcscd_index++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported descriptor type code:\"\n\t\t\t\t\t\" 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (xop->op_origin) {\n\tcase XCOL_SOURCE_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn,\n\t\t\t\t\t\t&xop->dst_dev);\n\t\tbreak;\n\tcase XCOL_DEST_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn,\n\t\t\t\t\t\t&xop->src_dev);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"\n\t\t\t\"stdi: %hu dtdi: %hu\\n\", xop->stdi, xop->dtdi);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\t/*\n\t * If a matching IEEE NAA 0x83 descriptor for the requested device\n\t * is not located on this node, return COPY_ABORTED with ASQ/ASQC\n\t * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the\n\t * initiator to fall back to normal copy method.\n\t */\n\tif (rc < 0) {\n\t\t*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->src_dev, &xop->src_tid_wwn[0]);\n\tpr_debug(\"XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->dst_dev, &xop->dst_tid_wwn[0]);\n\n\treturn cscd_index;\n\nout:\n\treturn -EINVAL;\n}\n\nstatic int target_xcopy_parse_segdesc_02(struct se_cmd *se_cmd, struct xcopy_op *xop,\n\t\t\t\t\tunsigned char *p)\n{\n\tunsigned char *desc = p;\n\tint dc = (desc[1] & 0x02);\n\tunsigned short desc_len;\n\n\tdesc_len = get_unaligned_be16(&desc[2]);\n\tif (desc_len != 0x18) {\n\t\tpr_err(\"XCOPY segment desc 0x02: Illegal desc_len:\"\n\t\t\t\t\" %hu\\n\", desc_len);\n\t\treturn -EINVAL;\n\t}\n\n\txop->stdi = get_unaligned_be16(&desc[4]);\n\txop->dtdi = get_unaligned_be16(&desc[6]);\n\n\tif (xop->stdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX ||\n\t    xop->dtdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX) {\n\t\tpr_err(\"XCOPY segment desc 0x02: unsupported CSCD ID > 0x%x; stdi: %hu dtdi: %hu\\n\",\n\t\t\tXCOPY_CSCD_DESC_ID_LIST_OFF_MAX, xop->stdi, xop->dtdi);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"XCOPY seg desc 0x02: desc_len: %hu stdi: %hu dtdi: %hu, DC: %d\\n\",\n\t\tdesc_len, xop->stdi, xop->dtdi, dc);\n\n\txop->nolb = get_unaligned_be16(&desc[10]);\n\txop->src_lba = get_unaligned_be64(&desc[12]);\n\txop->dst_lba = get_unaligned_be64(&desc[20]);\n\tpr_debug(\"XCOPY seg desc 0x02: nolb: %hu src_lba: %llu dst_lba: %llu\\n\",\n\t\txop->nolb, (unsigned long long)xop->src_lba,\n\t\t(unsigned long long)xop->dst_lba);\n\n\treturn 0;\n}\n\nstatic int target_xcopy_parse_segment_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned int sdll, sense_reason_t *sense_ret)\n{\n\tunsigned char *desc = p;\n\tunsigned int start = 0;\n\tint offset = sdll % XCOPY_SEGMENT_DESC_LEN, rc, ret = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY segment descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_SEGMENT_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (sdll > RCR_OP_MAX_SG_DESC_COUNT * XCOPY_SEGMENT_DESC_LEN) {\n\t\tpr_err(\"XCOPY supports %u segment descriptor(s), sdll: %u too\"\n\t\t\t\" large..\\n\", RCR_OP_MAX_SG_DESC_COUNT, sdll);\n\t\t/* spc4r37 6.4.3.5 SEGMENT DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_SEGMENT_DESCS;\n\t\treturn -EINVAL;\n\t}\n\n\twhile (start < sdll) {\n\t\t/*\n\t\t * Check segment descriptor type code for block -> block\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0x02:\n\t\t\trc = target_xcopy_parse_segdesc_02(se_cmd, xop, desc);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret++;\n\t\t\tstart += XCOPY_SEGMENT_DESC_LEN;\n\t\t\tdesc += XCOPY_SEGMENT_DESC_LEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported segment descriptor\"\n\t\t\t\t\"type: 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn ret;\n\nout:\n\treturn -EINVAL;\n}\n\n/*\n * Start xcopy_pt ops\n */\n\nstruct xcopy_pt_cmd {\n\tstruct se_cmd se_cmd;\n\tstruct completion xpt_passthrough_sem;\n\tunsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];\n};\n\nstruct se_portal_group xcopy_pt_tpg;\nstatic struct se_session xcopy_pt_sess;\nstatic struct se_node_acl xcopy_pt_nacl;\n\nstatic int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)\n{\n        return 0;\n}\n\nstatic void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}\n\nstatic void xcopy_pt_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\n\t\t\t\tstruct xcopy_pt_cmd, se_cmd);\n\n\t/* xpt_cmd is on the stack, nothing to free here */\n\tpr_debug(\"xpt_cmd done: %p\\n\", xpt_cmd);\n}\n\nstatic int xcopy_pt_check_stop_free(struct se_cmd *se_cmd)\n{\n\tstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\n\t\t\t\tstruct xcopy_pt_cmd, se_cmd);\n\n\tcomplete(&xpt_cmd->xpt_passthrough_sem);\n\treturn 0;\n}\n\nstatic int xcopy_pt_write_pending(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int xcopy_pt_queue_data_in(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int xcopy_pt_queue_status(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic const struct target_core_fabric_ops xcopy_pt_tfo = {\n\t.fabric_name\t\t= \"xcopy-pt\",\n\t.get_cmd_state\t\t= xcopy_pt_get_cmd_state,\n\t.release_cmd\t\t= xcopy_pt_release_cmd,\n\t.check_stop_free\t= xcopy_pt_check_stop_free,\n\t.write_pending\t\t= xcopy_pt_write_pending,\n\t.queue_data_in\t\t= xcopy_pt_queue_data_in,\n\t.queue_status\t\t= xcopy_pt_queue_status,\n};\n\n/*\n * End xcopy_pt_ops\n */\n\nint target_xcopy_setup_pt(void)\n{\n\tint ret;\n\n\txcopy_wq = alloc_workqueue(\"xcopy_wq\", WQ_MEM_RECLAIM, 0);\n\tif (!xcopy_wq) {\n\t\tpr_err(\"Unable to allocate xcopy_wq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&xcopy_pt_tpg, 0, sizeof(struct se_portal_group));\n\tINIT_LIST_HEAD(&xcopy_pt_tpg.acl_node_list);\n\tINIT_LIST_HEAD(&xcopy_pt_tpg.tpg_sess_list);\n\n\txcopy_pt_tpg.se_tpg_tfo = &xcopy_pt_tfo;\n\n\tmemset(&xcopy_pt_nacl, 0, sizeof(struct se_node_acl));\n\tINIT_LIST_HEAD(&xcopy_pt_nacl.acl_list);\n\tINIT_LIST_HEAD(&xcopy_pt_nacl.acl_sess_list);\n\tmemset(&xcopy_pt_sess, 0, sizeof(struct se_session));\n\tret = transport_init_session(&xcopy_pt_sess);\n\tif (ret < 0)\n\t\tgoto destroy_wq;\n\n\txcopy_pt_nacl.se_tpg = &xcopy_pt_tpg;\n\txcopy_pt_nacl.nacl_sess = &xcopy_pt_sess;\n\n\txcopy_pt_sess.se_tpg = &xcopy_pt_tpg;\n\txcopy_pt_sess.se_node_acl = &xcopy_pt_nacl;\n\n\treturn 0;\n\ndestroy_wq:\n\tdestroy_workqueue(xcopy_wq);\n\txcopy_wq = NULL;\n\treturn ret;\n}\n\nvoid target_xcopy_release_pt(void)\n{\n\tif (xcopy_wq) {\n\t\tdestroy_workqueue(xcopy_wq);\n\t\ttransport_uninit_session(&xcopy_pt_sess);\n\t}\n}\n\n/*\n * target_xcopy_setup_pt_cmd - set up a pass-through command\n * @xpt_cmd:\t Data structure to initialize.\n * @xop:\t Describes the XCOPY operation received from an initiator.\n * @se_dev:\t Backend device to associate with @xpt_cmd if\n *\t\t @remote_port == true.\n * @cdb:\t SCSI CDB to be copied into @xpt_cmd.\n * @remote_port: If false, use the LUN through which the XCOPY command has\n *\t\t been received. If true, use @se_dev->xcopy_lun.\n *\n * Set up a SCSI command (READ or WRITE) that will be used to execute an\n * XCOPY command.\n */\nstatic int target_xcopy_setup_pt_cmd(\n\tstruct xcopy_pt_cmd *xpt_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *se_dev,\n\tunsigned char *cdb,\n\tbool remote_port)\n{\n\tstruct se_cmd *cmd = &xpt_cmd->se_cmd;\n\n\t/*\n\t * Setup LUN+port to honor reservations based upon xop->op_origin for\n\t * X-COPY PUSH or X-COPY PULL based upon where the CDB was received.\n\t */\n\tif (remote_port) {\n\t\tcmd->se_lun = &se_dev->xcopy_lun;\n\t\tcmd->se_dev = se_dev;\n\t} else {\n\t\tcmd->se_lun = xop->xop_se_cmd->se_lun;\n\t\tcmd->se_dev = xop->xop_se_cmd->se_dev;\n\t}\n\tcmd->se_cmd_flags |= SCF_SE_LUN_CMD;\n\n\tif (target_cmd_init_cdb(cmd, cdb))\n\t\treturn -EINVAL;\n\n\tcmd->tag = 0;\n\tif (target_cmd_parse_cdb(cmd))\n\t\treturn -EINVAL;\n\n\tif (transport_generic_map_mem_to_cmd(cmd, xop->xop_data_sg,\n\t\t\t\t\txop->xop_data_nents, NULL, 0))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Setup PASSTHROUGH_NOALLOC t_data_sg: %p t_data_nents:\"\n\t\t \" %u\\n\", cmd->t_data_sg, cmd->t_data_nents);\n\n\treturn 0;\n}\n\nstatic int target_xcopy_issue_pt_cmd(struct xcopy_pt_cmd *xpt_cmd)\n{\n\tstruct se_cmd *se_cmd = &xpt_cmd->se_cmd;\n\tsense_reason_t sense_rc;\n\n\tsense_rc = transport_generic_new_cmd(se_cmd);\n\tif (sense_rc)\n\t\treturn -EINVAL;\n\n\tif (se_cmd->data_direction == DMA_TO_DEVICE)\n\t\ttarget_execute_cmd(se_cmd);\n\n\twait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);\n\n\tpr_debug(\"target_xcopy_issue_pt_cmd(): SCSI status: 0x%02x\\n\",\n\t\t\tse_cmd->scsi_status);\n\n\treturn (se_cmd->scsi_status) ? -EINVAL : 0;\n}\n\nstatic int target_xcopy_read_source(\n\tstruct se_cmd *ec_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *src_dev,\n\tsector_t src_lba,\n\tu32 src_sectors)\n{\n\tstruct xcopy_pt_cmd xpt_cmd;\n\tstruct se_cmd *se_cmd = &xpt_cmd.se_cmd;\n\tu32 length = (src_sectors * src_dev->dev_attrib.block_size);\n\tint rc;\n\tunsigned char cdb[16];\n\tbool remote_port = (xop->op_origin == XCOL_DEST_RECV_OP);\n\n\tmemset(&xpt_cmd, 0, sizeof(xpt_cmd));\n\tinit_completion(&xpt_cmd.xpt_passthrough_sem);\n\n\tmemset(&cdb[0], 0, 16);\n\tcdb[0] = READ_16;\n\tput_unaligned_be64(src_lba, &cdb[2]);\n\tput_unaligned_be32(src_sectors, &cdb[10]);\n\tpr_debug(\"XCOPY: Built READ_16: LBA: %llu Sectors: %u Length: %u\\n\",\n\t\t(unsigned long long)src_lba, src_sectors, length);\n\n\ttransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, length,\n\t\t\t      DMA_FROM_DEVICE, 0, &xpt_cmd.sense_buffer[0], 0);\n\n\trc = target_xcopy_setup_pt_cmd(&xpt_cmd, xop, src_dev, &cdb[0],\n\t\t\t\tremote_port);\n\tif (rc < 0) {\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY-READ: Saved xop->xop_data_sg: %p, num: %u for READ\"\n\t\t\" memory\\n\", xop->xop_data_sg, xop->xop_data_nents);\n\n\trc = target_xcopy_issue_pt_cmd(&xpt_cmd);\n\tif (rc < 0)\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\nout:\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn rc;\n}\n\nstatic int target_xcopy_write_destination(\n\tstruct se_cmd *ec_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *dst_dev,\n\tsector_t dst_lba,\n\tu32 dst_sectors)\n{\n\tstruct xcopy_pt_cmd xpt_cmd;\n\tstruct se_cmd *se_cmd = &xpt_cmd.se_cmd;\n\tu32 length = (dst_sectors * dst_dev->dev_attrib.block_size);\n\tint rc;\n\tunsigned char cdb[16];\n\tbool remote_port = (xop->op_origin == XCOL_SOURCE_RECV_OP);\n\n\tmemset(&xpt_cmd, 0, sizeof(xpt_cmd));\n\tinit_completion(&xpt_cmd.xpt_passthrough_sem);\n\n\tmemset(&cdb[0], 0, 16);\n\tcdb[0] = WRITE_16;\n\tput_unaligned_be64(dst_lba, &cdb[2]);\n\tput_unaligned_be32(dst_sectors, &cdb[10]);\n\tpr_debug(\"XCOPY: Built WRITE_16: LBA: %llu Sectors: %u Length: %u\\n\",\n\t\t(unsigned long long)dst_lba, dst_sectors, length);\n\n\ttransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, length,\n\t\t\t      DMA_TO_DEVICE, 0, &xpt_cmd.sense_buffer[0], 0);\n\n\trc = target_xcopy_setup_pt_cmd(&xpt_cmd, xop, dst_dev, &cdb[0],\n\t\t\t\tremote_port);\n\tif (rc < 0) {\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\n\t\tgoto out;\n\t}\n\n\trc = target_xcopy_issue_pt_cmd(&xpt_cmd);\n\tif (rc < 0)\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\nout:\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn rc;\n}\n\nstatic void target_xcopy_do_work(struct work_struct *work)\n{\n\tstruct xcopy_op *xop = container_of(work, struct xcopy_op, xop_work);\n\tstruct se_cmd *ec_cmd = xop->xop_se_cmd;\n\tstruct se_device *src_dev, *dst_dev;\n\tsector_t src_lba, dst_lba, end_lba;\n\tunsigned int max_sectors;\n\tint rc = 0;\n\tunsigned short nolb, max_nolb, copied_nolb = 0;\n\n\tif (target_parse_xcopy_cmd(xop) != TCM_NO_SENSE)\n\t\tgoto err_free;\n\n\tif (WARN_ON_ONCE(!xop->src_dev) || WARN_ON_ONCE(!xop->dst_dev))\n\t\tgoto err_free;\n\n\tsrc_dev = xop->src_dev;\n\tdst_dev = xop->dst_dev;\n\tsrc_lba = xop->src_lba;\n\tdst_lba = xop->dst_lba;\n\tnolb = xop->nolb;\n\tend_lba = src_lba + nolb;\n\t/*\n\t * Break up XCOPY I/O into hw_max_sectors sized I/O based on the\n\t * smallest max_sectors between src_dev + dev_dev, or\n\t */\n\tmax_sectors = min(src_dev->dev_attrib.hw_max_sectors,\n\t\t\t  dst_dev->dev_attrib.hw_max_sectors);\n\tmax_sectors = min_t(u32, max_sectors, XCOPY_MAX_SECTORS);\n\n\tmax_nolb = min_t(u16, max_sectors, ((u16)(~0U)));\n\n\tpr_debug(\"target_xcopy_do_work: nolb: %hu, max_nolb: %hu end_lba: %llu\\n\",\n\t\t\tnolb, max_nolb, (unsigned long long)end_lba);\n\tpr_debug(\"target_xcopy_do_work: Starting src_lba: %llu, dst_lba: %llu\\n\",\n\t\t\t(unsigned long long)src_lba, (unsigned long long)dst_lba);\n\n\twhile (src_lba < end_lba) {\n\t\tunsigned short cur_nolb = min(nolb, max_nolb);\n\t\tu32 cur_bytes = cur_nolb * src_dev->dev_attrib.block_size;\n\n\t\tif (cur_bytes != xop->xop_data_bytes) {\n\t\t\t/*\n\t\t\t * (Re)allocate a buffer large enough to hold the XCOPY\n\t\t\t * I/O size, which can be reused each read / write loop.\n\t\t\t */\n\t\t\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\t\t\trc = target_alloc_sgl(&xop->xop_data_sg,\n\t\t\t\t\t      &xop->xop_data_nents,\n\t\t\t\t\t      cur_bytes,\n\t\t\t\t\t      false, false);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\txop->xop_data_bytes = cur_bytes;\n\t\t}\n\n\t\tpr_debug(\"target_xcopy_do_work: Calling read src_dev: %p src_lba: %llu,\"\n\t\t\t\" cur_nolb: %hu\\n\", src_dev, (unsigned long long)src_lba, cur_nolb);\n\n\t\trc = target_xcopy_read_source(ec_cmd, xop, src_dev, src_lba, cur_nolb);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tsrc_lba += cur_nolb;\n\t\tpr_debug(\"target_xcopy_do_work: Incremented READ src_lba to %llu\\n\",\n\t\t\t\t(unsigned long long)src_lba);\n\n\t\tpr_debug(\"target_xcopy_do_work: Calling write dst_dev: %p dst_lba: %llu,\"\n\t\t\t\" cur_nolb: %hu\\n\", dst_dev, (unsigned long long)dst_lba, cur_nolb);\n\n\t\trc = target_xcopy_write_destination(ec_cmd, xop, dst_dev,\n\t\t\t\t\t\tdst_lba, cur_nolb);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tdst_lba += cur_nolb;\n\t\tpr_debug(\"target_xcopy_do_work: Incremented WRITE dst_lba to %llu\\n\",\n\t\t\t\t(unsigned long long)dst_lba);\n\n\t\tcopied_nolb += cur_nolb;\n\t\tnolb -= cur_nolb;\n\t}\n\n\txcopy_pt_undepend_remotedev(xop);\n\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\tkfree(xop);\n\n\tpr_debug(\"target_xcopy_do_work: Final src_lba: %llu, dst_lba: %llu\\n\",\n\t\t(unsigned long long)src_lba, (unsigned long long)dst_lba);\n\tpr_debug(\"target_xcopy_do_work: Blocks copied: %hu, Bytes Copied: %u\\n\",\n\t\tcopied_nolb, copied_nolb * dst_dev->dev_attrib.block_size);\n\n\tpr_debug(\"target_xcopy_do_work: Setting X-COPY GOOD status -> sending response\\n\");\n\ttarget_complete_cmd(ec_cmd, SAM_STAT_GOOD);\n\treturn;\n\nout:\n\txcopy_pt_undepend_remotedev(xop);\n\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\nerr_free:\n\tkfree(xop);\n\t/*\n\t * Don't override an error scsi status if it has already been set\n\t */\n\tif (ec_cmd->scsi_status == SAM_STAT_GOOD) {\n\t\tpr_warn_ratelimited(\"target_xcopy_do_work: rc: %d, Setting X-COPY\"\n\t\t\t\" CHECK_CONDITION -> sending response\\n\", rc);\n\t\tec_cmd->scsi_status = SAM_STAT_CHECK_CONDITION;\n\t}\n\ttarget_complete_cmd(ec_cmd, ec_cmd->scsi_status);\n}\n\n/*\n * Returns TCM_NO_SENSE upon success or a sense code != TCM_NO_SENSE if parsing\n * fails.\n */\nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop)\n{\n\tstruct se_cmd *se_cmd = xop->xop_se_cmd;\n\tunsigned char *p = NULL, *seg_desc;\n\tunsigned int list_id, list_id_usage, sdll, inline_dl;\n\tsense_reason_t ret = TCM_INVALID_PARAMETER_LIST;\n\tint rc;\n\tunsigned short tdll;\n\n\tp = transport_kmap_data_sg(se_cmd);\n\tif (!p) {\n\t\tpr_err(\"transport_kmap_data_sg() failed in target_do_xcopy\\n\");\n\t\treturn TCM_OUT_OF_RESOURCES;\n\t}\n\n\tlist_id = p[0];\n\tlist_id_usage = (p[1] & 0x18) >> 3;\n\n\t/*\n\t * Determine TARGET DESCRIPTOR LIST LENGTH + SEGMENT DESCRIPTOR LIST LENGTH\n\t */\n\ttdll = get_unaligned_be16(&p[2]);\n\tsdll = get_unaligned_be32(&p[8]);\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\tpr_err(\"XCOPY descriptor list length %u exceeds maximum %u\\n\",\n\t\t       tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tinline_dl = get_unaligned_be32(&p[12]);\n\tif (inline_dl != 0) {\n\t\tpr_err(\"XCOPY with non zero inline data length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (se_cmd->data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\tpr_err(\"XCOPY parameter truncation: data length %u too small \"\n\t\t\t\"for tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t\tse_cmd->data_length, tdll, sdll, inline_dl);\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"Processing XCOPY with list_id: 0x%02x list_id_usage: 0x%02x\"\n\t\t\" tdll: %hu sdll: %u inline_dl: %u\\n\", list_id, list_id_usage,\n\t\ttdll, sdll, inline_dl);\n\n\t/*\n\t * skip over the target descriptors until segment descriptors\n\t * have been passed - CSCD ids are needed to determine src and dest.\n\t */\n\tseg_desc = &p[16] + tdll;\n\n\trc = target_xcopy_parse_segment_descriptors(se_cmd, xop, seg_desc,\n\t\t\t\t\t\t    sdll, &ret);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tpr_debug(\"XCOPY: Processed %d segment descriptors, length: %u\\n\", rc,\n\t\t\t\trc * XCOPY_SEGMENT_DESC_LEN);\n\n\trc = target_xcopy_parse_target_descriptors(se_cmd, xop, &p[16], tdll, &ret);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tif (xop->src_dev->dev_attrib.block_size !=\n\t    xop->dst_dev->dev_attrib.block_size) {\n\t\tpr_err(\"XCOPY: Non matching src_dev block_size: %u + dst_dev\"\n\t\t       \" block_size: %u currently unsupported\\n\",\n\t\t\txop->src_dev->dev_attrib.block_size,\n\t\t\txop->dst_dev->dev_attrib.block_size);\n\t\txcopy_pt_undepend_remotedev(xop);\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY: Processed %d target descriptors, length: %u\\n\", rc,\n\t\t\t\trc * XCOPY_TARGET_DESC_LEN);\n\ttransport_kunmap_data_sg(se_cmd);\n\treturn TCM_NO_SENSE;\n\nout:\n\tif (p)\n\t\ttransport_kunmap_data_sg(se_cmd);\n\treturn ret;\n}\n\nsense_reason_t target_do_xcopy(struct se_cmd *se_cmd)\n{\n\tstruct se_device *dev = se_cmd->se_dev;\n\tstruct xcopy_op *xop;\n\tunsigned int sa;\n\n\tif (!dev->dev_attrib.emulate_3pc) {\n\t\tpr_err(\"EXTENDED_COPY operation explicitly disabled\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tsa = se_cmd->t_task_cdb[1] & 0x1f;\n\tif (sa != 0x00) {\n\t\tpr_err(\"EXTENDED_COPY(LID4) not supported\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tif (se_cmd->data_length == 0) {\n\t\ttarget_complete_cmd(se_cmd, SAM_STAT_GOOD);\n\t\treturn TCM_NO_SENSE;\n\t}\n\tif (se_cmd->data_length < XCOPY_HDR_LEN) {\n\t\tpr_err(\"XCOPY parameter truncation: length %u < hdr_len %u\\n\",\n\t\t\t\tse_cmd->data_length, XCOPY_HDR_LEN);\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t}\n\n\txop = kzalloc(sizeof(struct xcopy_op), GFP_KERNEL);\n\tif (!xop)\n\t\tgoto err;\n\txop->xop_se_cmd = se_cmd;\n\tINIT_WORK(&xop->xop_work, target_xcopy_do_work);\n\tif (WARN_ON_ONCE(!queue_work(xcopy_wq, &xop->xop_work)))\n\t\tgoto free;\n\treturn TCM_NO_SENSE;\n\nfree:\n\tkfree(xop);\n\nerr:\n\treturn TCM_OUT_OF_RESOURCES;\n}\n\nstatic sense_reason_t target_rcr_operating_parameters(struct se_cmd *se_cmd)\n{\n\tunsigned char *p;\n\n\tp = transport_kmap_data_sg(se_cmd);\n\tif (!p) {\n\t\tpr_err(\"transport_kmap_data_sg failed in\"\n\t\t       \" target_rcr_operating_parameters\\n\");\n\t\treturn TCM_OUT_OF_RESOURCES;\n\t}\n\n\tif (se_cmd->data_length < 54) {\n\t\tpr_err(\"Receive Copy Results Op Parameters length\"\n\t\t       \" too small: %u\\n\", se_cmd->data_length);\n\t\ttransport_kunmap_data_sg(se_cmd);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\t/*\n\t * Set SNLID=1 (Supports no List ID)\n\t */\n\tp[4] = 0x1;\n\t/*\n\t * MAXIMUM TARGET DESCRIPTOR COUNT\n\t */\n\tput_unaligned_be16(RCR_OP_MAX_TARGET_DESC_COUNT, &p[8]);\n\t/*\n\t * MAXIMUM SEGMENT DESCRIPTOR COUNT\n\t */\n\tput_unaligned_be16(RCR_OP_MAX_SG_DESC_COUNT, &p[10]);\n\t/*\n\t * MAXIMUM DESCRIPTOR LIST LENGTH\n\t */\n\tput_unaligned_be32(RCR_OP_MAX_DESC_LIST_LEN, &p[12]);\n\t/*\n\t * MAXIMUM SEGMENT LENGTH\n\t */\n\tput_unaligned_be32(RCR_OP_MAX_SEGMENT_LEN, &p[16]);\n\t/*\n\t * MAXIMUM INLINE DATA LENGTH for SA 0x04 (NOT SUPPORTED)\n\t */\n\tput_unaligned_be32(0x0, &p[20]);\n\t/*\n\t * HELD DATA LIMIT\n\t */\n\tput_unaligned_be32(0x0, &p[24]);\n\t/*\n\t * MAXIMUM STREAM DEVICE TRANSFER SIZE\n\t */\n\tput_unaligned_be32(0x0, &p[28]);\n\t/*\n\t * TOTAL CONCURRENT COPIES\n\t */\n\tput_unaligned_be16(RCR_OP_TOTAL_CONCURR_COPIES, &p[34]);\n\t/*\n\t * MAXIMUM CONCURRENT COPIES\n\t */\n\tp[36] = RCR_OP_MAX_CONCURR_COPIES;\n\t/*\n\t * DATA SEGMENT GRANULARITY (log 2)\n\t */\n\tp[37] = RCR_OP_DATA_SEG_GRAN_LOG2;\n\t/*\n\t * INLINE DATA GRANULARITY log 2)\n\t */\n\tp[38] = RCR_OP_INLINE_DATA_GRAN_LOG2;\n\t/*\n\t * HELD DATA GRANULARITY\n\t */\n\tp[39] = RCR_OP_HELD_DATA_GRAN_LOG2;\n\t/*\n\t * IMPLEMENTED DESCRIPTOR LIST LENGTH\n\t */\n\tp[43] = 0x2;\n\t/*\n\t * List of implemented descriptor type codes (ordered)\n\t */\n\tp[44] = 0x02; /* Copy Block to Block device */\n\tp[45] = 0xe4; /* Identification descriptor target descriptor */\n\n\t/*\n\t * AVAILABLE DATA (n-3)\n\t */\n\tput_unaligned_be32(42, &p[0]);\n\n\ttransport_kunmap_data_sg(se_cmd);\n\ttarget_complete_cmd(se_cmd, GOOD);\n\n\treturn TCM_NO_SENSE;\n}\n\nsense_reason_t target_do_receive_copy_results(struct se_cmd *se_cmd)\n{\n\tunsigned char *cdb = &se_cmd->t_task_cdb[0];\n\tint sa = (cdb[1] & 0x1f), list_id = cdb[2];\n\tsense_reason_t rc = TCM_NO_SENSE;\n\n\tpr_debug(\"Entering target_do_receive_copy_results: SA: 0x%02x, List ID:\"\n\t\t\" 0x%02x, AL: %u\\n\", sa, list_id, se_cmd->data_length);\n\n\tif (list_id != 0) {\n\t\tpr_err(\"Receive Copy Results with non zero list identifier\"\n\t\t       \" not supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tswitch (sa) {\n\tcase RCR_SA_OPERATING_PARAMETERS:\n\t\trc = target_rcr_operating_parameters(se_cmd);\n\t\tbreak;\n\tcase RCR_SA_COPY_STATUS:\n\tcase RCR_SA_RECEIVE_DATA:\n\tcase RCR_SA_FAILED_SEGMENT_DETAILS:\n\tdefault:\n\t\tpr_err(\"Unsupported SA for receive copy results: 0x%02x\\n\", sa);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\treturn rc;\n}\n", "/* SPDX-License-Identifier: GPL-2.0 */\n#include <target/target_core_base.h>\n\n#define XCOPY_HDR_LEN\t\t\t16\n#define XCOPY_TARGET_DESC_LEN\t\t32\n#define XCOPY_SEGMENT_DESC_LEN\t\t28\n#define XCOPY_NAA_IEEE_REGEX_LEN\t16\n#define XCOPY_MAX_SECTORS\t\t4096\n\n/*\n * SPC4r37 6.4.6.1\n * Table 150 \u2014 CSCD descriptor ID values\n */\n#define XCOPY_CSCD_DESC_ID_LIST_OFF_MAX\t0x07FF\n\nenum xcopy_origin_list {\n\tXCOL_SOURCE_RECV_OP = 0x01,\n\tXCOL_DEST_RECV_OP = 0x02,\n};\n\nstruct xcopy_op {\n\tint op_origin;\n\n\tstruct se_cmd *xop_se_cmd;\n\tstruct se_device *src_dev;\n\tunsigned char src_tid_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tstruct se_device *dst_dev;\n\tunsigned char dst_tid_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tunsigned char local_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\n\tsector_t src_lba;\n\tsector_t dst_lba;\n\tunsigned short stdi;\n\tunsigned short dtdi;\n\tunsigned short nolb;\n\n\tu32 xop_data_bytes;\n\tu32 xop_data_nents;\n\tstruct scatterlist *xop_data_sg;\n\tstruct work_struct xop_work;\n};\n\n/*\n * Receive Copy Results Sevice Actions\n */\n#define RCR_SA_COPY_STATUS\t\t0x00\n#define RCR_SA_RECEIVE_DATA\t\t0x01\n#define RCR_SA_OPERATING_PARAMETERS\t0x03\n#define RCR_SA_FAILED_SEGMENT_DETAILS\t0x04\n\n/*\n * Receive Copy Results defs for Operating Parameters\n */\n#define RCR_OP_MAX_TARGET_DESC_COUNT\t0x2\n#define RCR_OP_MAX_SG_DESC_COUNT\t0x1\n#define RCR_OP_MAX_DESC_LIST_LEN\t1024\n#define RCR_OP_MAX_SEGMENT_LEN\t\t268435456 /* 256 MB */\n#define RCR_OP_TOTAL_CONCURR_COPIES\t0x1 /* Must be <= 16384 */\n#define RCR_OP_MAX_CONCURR_COPIES\t0x1 /* Must be <= 255 */\n#define RCR_OP_DATA_SEG_GRAN_LOG2\t9 /* 512 bytes in log 2 */\n#define RCR_OP_INLINE_DATA_GRAN_LOG2\t9 /* 512 bytes in log 2 */\n#define RCR_OP_HELD_DATA_GRAN_LOG2\t9 /* 512 bytes in log 2 */\n\nextern int target_xcopy_setup_pt(void);\nextern void target_xcopy_release_pt(void);\nextern sense_reason_t target_do_xcopy(struct se_cmd *);\nextern sense_reason_t target_do_receive_copy_results(struct se_cmd *);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*******************************************************************************\n * Filename: target_core_xcopy.c\n *\n * This file contains support for SPC-4 Extended-Copy offload with generic\n * TCM backends.\n *\n * Copyright (c) 2011-2013 Datera, Inc. All rights reserved.\n *\n * Author:\n * Nicholas A. Bellinger <nab@daterainc.com>\n *\n ******************************************************************************/\n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/configfs.h>\n#include <linux/ratelimit.h>\n#include <scsi/scsi_proto.h>\n#include <asm/unaligned.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n#include \"target_core_xcopy.h\"\n\nstatic struct workqueue_struct *xcopy_wq = NULL;\n\nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop);\n\nstatic int target_xcopy_gen_naa_ieee(struct se_device *dev, unsigned char *buf)\n{\n\tint off = 0;\n\n\tbuf[off++] = (0x6 << 4);\n\tbuf[off++] = 0x01;\n\tbuf[off++] = 0x40;\n\tbuf[off] = (0x5 << 4);\n\n\tspc_parse_naa_6h_vendor_specific(dev, &buf[off]);\n\treturn 0;\n}\n\n/**\n * target_xcopy_locate_se_dev_e4_iter - compare XCOPY NAA device identifiers\n *\n * @se_dev: device being considered for match\n * @dev_wwn: XCOPY requested NAA dev_wwn\n * @return: 1 on match, 0 on no-match\n */\nstatic int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      const unsigned char *dev_wwn)\n{\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc) {\n\t\tpr_debug(\"XCOPY: emulate_3pc disabled on se_dev %p\\n\", se_dev);\n\t\treturn 0;\n\t}\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0) {\n\t\tpr_debug(\"XCOPY: skip non-matching: %*ph\\n\",\n\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);\n\t\treturn 0;\n\t}\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\treturn 1;\n}\n\nstatic int target_xcopy_locate_se_dev_e4(struct se_session *sess,\n\t\t\t\t\tconst unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **_found_dev,\n\t\t\t\t\tstruct percpu_ref **_found_lun_ref)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_node_acl *nacl;\n\tstruct se_lun *this_lun = NULL;\n\tstruct se_device *found_dev = NULL;\n\n\t/* cmd with NULL sess indicates no associated $FABRIC_MOD */\n\tif (!sess)\n\t\tgoto err_out;\n\n\tpr_debug(\"XCOPY 0xe4: searching for: %*ph\\n\",\n\t\t XCOPY_NAA_IEEE_REGEX_LEN, dev_wwn);\n\n\tnacl = sess->se_node_acl;\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\n\t\tstruct se_device *this_dev;\n\t\tint rc;\n\n\t\tthis_lun = rcu_dereference(deve->se_lun);\n\t\tthis_dev = rcu_dereference_raw(this_lun->lun_se_dev);\n\n\t\trc = target_xcopy_locate_se_dev_e4_iter(this_dev, dev_wwn);\n\t\tif (rc) {\n\t\t\tif (percpu_ref_tryget_live(&this_lun->lun_ref))\n\t\t\t\tfound_dev = this_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (found_dev == NULL)\n\t\tgoto err_out;\n\n\tpr_debug(\"lun_ref held for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t found_dev, &found_dev->dev_group);\n\t*_found_dev = found_dev;\n\t*_found_lun_ref = &this_lun->lun_ref;\n\treturn 0;\nerr_out:\n\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\treturn -EINVAL;\n}\n\nstatic int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,\n\t\t\t\tunsigned char *p, unsigned short cscd_index)\n{\n\tunsigned char *desc = p;\n\tunsigned short ript;\n\tu8 desig_len;\n\t/*\n\t * Extract RELATIVE INITIATOR PORT IDENTIFIER\n\t */\n\tript = get_unaligned_be16(&desc[2]);\n\tpr_debug(\"XCOPY 0xe4: RELATIVE INITIATOR PORT IDENTIFIER: %hu\\n\", ript);\n\t/*\n\t * Check for supported code set, association, and designator type\n\t */\n\tif ((desc[4] & 0x0f) != 0x1) {\n\t\tpr_err(\"XCOPY 0xe4: code set of non binary type not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((desc[5] & 0x30) != 0x00) {\n\t\tpr_err(\"XCOPY 0xe4: association other than LUN not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((desc[5] & 0x0f) != 0x3) {\n\t\tpr_err(\"XCOPY 0xe4: designator type unsupported: 0x%02x\\n\",\n\t\t\t\t(desc[5] & 0x0f));\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Check for matching 16 byte length for NAA IEEE Registered Extended\n\t * Assigned designator\n\t */\n\tdesig_len = desc[7];\n\tif (desig_len != XCOPY_NAA_IEEE_REGEX_LEN) {\n\t\tpr_err(\"XCOPY 0xe4: invalid desig_len: %d\\n\", (int)desig_len);\n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"XCOPY 0xe4: desig_len: %d\\n\", (int)desig_len);\n\t/*\n\t * Check for NAA IEEE Registered Extended Assigned header..\n\t */\n\tif ((desc[8] & 0xf0) != 0x60) {\n\t\tpr_err(\"XCOPY 0xe4: Unsupported DESIGNATOR TYPE: 0x%02x\\n\",\n\t\t\t\t\t(desc[8] & 0xf0));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cscd_index != xop->stdi && cscd_index != xop->dtdi) {\n\t\tpr_debug(\"XCOPY 0xe4: ignoring CSCD entry %d - neither src nor \"\n\t\t\t \"dest\\n\", cscd_index);\n\t\treturn 0;\n\t}\n\n\tif (cscd_index == xop->stdi) {\n\t\tmemcpy(&xop->src_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\n\t\t/*\n\t\t * Determine if the source designator matches the local device\n\t\t */\n\t\tif (!memcmp(&xop->local_dev_wwn[0], &xop->src_tid_wwn[0],\n\t\t\t\tXCOPY_NAA_IEEE_REGEX_LEN)) {\n\t\t\txop->op_origin = XCOL_SOURCE_RECV_OP;\n\t\t\txop->src_dev = se_cmd->se_dev;\n\t\t\tpr_debug(\"XCOPY 0xe4: Set xop->src_dev %p from source\"\n\t\t\t\t\t\" received xop\\n\", xop->src_dev);\n\t\t}\n\t}\n\n\tif (cscd_index == xop->dtdi) {\n\t\tmemcpy(&xop->dst_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\n\t\t/*\n\t\t * Determine if the destination designator matches the local\n\t\t * device. If @cscd_index corresponds to both source (stdi) and\n\t\t * destination (dtdi), or dtdi comes after stdi, then\n\t\t * XCOL_DEST_RECV_OP wins.\n\t\t */\n\t\tif (!memcmp(&xop->local_dev_wwn[0], &xop->dst_tid_wwn[0],\n\t\t\t\tXCOPY_NAA_IEEE_REGEX_LEN)) {\n\t\t\txop->op_origin = XCOL_DEST_RECV_OP;\n\t\t\txop->dst_dev = se_cmd->se_dev;\n\t\t\tpr_debug(\"XCOPY 0xe4: Set xop->dst_dev: %p from destination\"\n\t\t\t\t\" received xop\\n\", xop->dst_dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned short tdll, sense_reason_t *sense_ret)\n{\n\tstruct se_device *local_dev = se_cmd->se_dev;\n\tunsigned char *desc = p;\n\tint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\n\tunsigned short cscd_index = 0;\n\tunsigned short start = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY target descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_TARGET_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\n\t\tpr_err(\"XCOPY target descriptor supports a maximum\"\n\t\t\t\" two src/dest descriptors, tdll: %hu too large..\\n\", tdll);\n\t\t/* spc4r37 6.4.3.4 CSCD DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Generate an IEEE Registered Extended designator based upon the\n\t * se_device the XCOPY was received upon..\n\t */\n\tmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\n\n\twhile (start < tdll) {\n\t\t/*\n\t\t * Check target descriptor identification with 0xE4 type, and\n\t\t * compare the current index with the CSCD descriptor IDs in\n\t\t * the segment descriptor. Use VPD 0x83 WWPN matching ..\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0xe4:\n\t\t\trc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\n\t\t\t\t\t\t\t&desc[0], cscd_index);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto out;\n\t\t\tstart += XCOPY_TARGET_DESC_LEN;\n\t\t\tdesc += XCOPY_TARGET_DESC_LEN;\n\t\t\tcscd_index++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported descriptor type code:\"\n\t\t\t\t\t\" 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (xop->op_origin) {\n\tcase XCOL_SOURCE_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->dst_tid_wwn,\n\t\t\t\t\t\t&xop->dst_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tcase XCOL_DEST_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->src_tid_wwn,\n\t\t\t\t\t\t&xop->src_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"\n\t\t\t\"stdi: %hu dtdi: %hu\\n\", xop->stdi, xop->dtdi);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\t/*\n\t * If a matching IEEE NAA 0x83 descriptor for the requested device\n\t * is not located on this node, return COPY_ABORTED with ASQ/ASQC\n\t * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the\n\t * initiator to fall back to normal copy method.\n\t */\n\tif (rc < 0) {\n\t\t*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->src_dev, &xop->src_tid_wwn[0]);\n\tpr_debug(\"XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->dst_dev, &xop->dst_tid_wwn[0]);\n\n\treturn cscd_index;\n\nout:\n\treturn -EINVAL;\n}\n\nstatic int target_xcopy_parse_segdesc_02(struct se_cmd *se_cmd, struct xcopy_op *xop,\n\t\t\t\t\tunsigned char *p)\n{\n\tunsigned char *desc = p;\n\tint dc = (desc[1] & 0x02);\n\tunsigned short desc_len;\n\n\tdesc_len = get_unaligned_be16(&desc[2]);\n\tif (desc_len != 0x18) {\n\t\tpr_err(\"XCOPY segment desc 0x02: Illegal desc_len:\"\n\t\t\t\t\" %hu\\n\", desc_len);\n\t\treturn -EINVAL;\n\t}\n\n\txop->stdi = get_unaligned_be16(&desc[4]);\n\txop->dtdi = get_unaligned_be16(&desc[6]);\n\n\tif (xop->stdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX ||\n\t    xop->dtdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX) {\n\t\tpr_err(\"XCOPY segment desc 0x02: unsupported CSCD ID > 0x%x; stdi: %hu dtdi: %hu\\n\",\n\t\t\tXCOPY_CSCD_DESC_ID_LIST_OFF_MAX, xop->stdi, xop->dtdi);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"XCOPY seg desc 0x02: desc_len: %hu stdi: %hu dtdi: %hu, DC: %d\\n\",\n\t\tdesc_len, xop->stdi, xop->dtdi, dc);\n\n\txop->nolb = get_unaligned_be16(&desc[10]);\n\txop->src_lba = get_unaligned_be64(&desc[12]);\n\txop->dst_lba = get_unaligned_be64(&desc[20]);\n\tpr_debug(\"XCOPY seg desc 0x02: nolb: %hu src_lba: %llu dst_lba: %llu\\n\",\n\t\txop->nolb, (unsigned long long)xop->src_lba,\n\t\t(unsigned long long)xop->dst_lba);\n\n\treturn 0;\n}\n\nstatic int target_xcopy_parse_segment_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned int sdll, sense_reason_t *sense_ret)\n{\n\tunsigned char *desc = p;\n\tunsigned int start = 0;\n\tint offset = sdll % XCOPY_SEGMENT_DESC_LEN, rc, ret = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY segment descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_SEGMENT_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (sdll > RCR_OP_MAX_SG_DESC_COUNT * XCOPY_SEGMENT_DESC_LEN) {\n\t\tpr_err(\"XCOPY supports %u segment descriptor(s), sdll: %u too\"\n\t\t\t\" large..\\n\", RCR_OP_MAX_SG_DESC_COUNT, sdll);\n\t\t/* spc4r37 6.4.3.5 SEGMENT DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_SEGMENT_DESCS;\n\t\treturn -EINVAL;\n\t}\n\n\twhile (start < sdll) {\n\t\t/*\n\t\t * Check segment descriptor type code for block -> block\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0x02:\n\t\t\trc = target_xcopy_parse_segdesc_02(se_cmd, xop, desc);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret++;\n\t\t\tstart += XCOPY_SEGMENT_DESC_LEN;\n\t\t\tdesc += XCOPY_SEGMENT_DESC_LEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported segment descriptor\"\n\t\t\t\t\"type: 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn ret;\n\nout:\n\treturn -EINVAL;\n}\n\n/*\n * Start xcopy_pt ops\n */\n\nstruct xcopy_pt_cmd {\n\tstruct se_cmd se_cmd;\n\tstruct completion xpt_passthrough_sem;\n\tunsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];\n};\n\nstruct se_portal_group xcopy_pt_tpg;\nstatic struct se_session xcopy_pt_sess;\nstatic struct se_node_acl xcopy_pt_nacl;\n\nstatic int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)\n{\n        return 0;\n}\n\nstatic void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tpr_debug(\"putting dst lun_ref for %p\\n\", xop->dst_dev);\n\telse\n\t\tpr_debug(\"putting src lun_ref for %p\\n\", xop->src_dev);\n\n\tpercpu_ref_put(xop->remote_lun_ref);\n}\n\nstatic void xcopy_pt_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\n\t\t\t\tstruct xcopy_pt_cmd, se_cmd);\n\n\t/* xpt_cmd is on the stack, nothing to free here */\n\tpr_debug(\"xpt_cmd done: %p\\n\", xpt_cmd);\n}\n\nstatic int xcopy_pt_check_stop_free(struct se_cmd *se_cmd)\n{\n\tstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\n\t\t\t\tstruct xcopy_pt_cmd, se_cmd);\n\n\tcomplete(&xpt_cmd->xpt_passthrough_sem);\n\treturn 0;\n}\n\nstatic int xcopy_pt_write_pending(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int xcopy_pt_queue_data_in(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int xcopy_pt_queue_status(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic const struct target_core_fabric_ops xcopy_pt_tfo = {\n\t.fabric_name\t\t= \"xcopy-pt\",\n\t.get_cmd_state\t\t= xcopy_pt_get_cmd_state,\n\t.release_cmd\t\t= xcopy_pt_release_cmd,\n\t.check_stop_free\t= xcopy_pt_check_stop_free,\n\t.write_pending\t\t= xcopy_pt_write_pending,\n\t.queue_data_in\t\t= xcopy_pt_queue_data_in,\n\t.queue_status\t\t= xcopy_pt_queue_status,\n};\n\n/*\n * End xcopy_pt_ops\n */\n\nint target_xcopy_setup_pt(void)\n{\n\tint ret;\n\n\txcopy_wq = alloc_workqueue(\"xcopy_wq\", WQ_MEM_RECLAIM, 0);\n\tif (!xcopy_wq) {\n\t\tpr_err(\"Unable to allocate xcopy_wq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&xcopy_pt_tpg, 0, sizeof(struct se_portal_group));\n\tINIT_LIST_HEAD(&xcopy_pt_tpg.acl_node_list);\n\tINIT_LIST_HEAD(&xcopy_pt_tpg.tpg_sess_list);\n\n\txcopy_pt_tpg.se_tpg_tfo = &xcopy_pt_tfo;\n\n\tmemset(&xcopy_pt_nacl, 0, sizeof(struct se_node_acl));\n\tINIT_LIST_HEAD(&xcopy_pt_nacl.acl_list);\n\tINIT_LIST_HEAD(&xcopy_pt_nacl.acl_sess_list);\n\tmemset(&xcopy_pt_sess, 0, sizeof(struct se_session));\n\tret = transport_init_session(&xcopy_pt_sess);\n\tif (ret < 0)\n\t\tgoto destroy_wq;\n\n\txcopy_pt_nacl.se_tpg = &xcopy_pt_tpg;\n\txcopy_pt_nacl.nacl_sess = &xcopy_pt_sess;\n\n\txcopy_pt_sess.se_tpg = &xcopy_pt_tpg;\n\txcopy_pt_sess.se_node_acl = &xcopy_pt_nacl;\n\n\treturn 0;\n\ndestroy_wq:\n\tdestroy_workqueue(xcopy_wq);\n\txcopy_wq = NULL;\n\treturn ret;\n}\n\nvoid target_xcopy_release_pt(void)\n{\n\tif (xcopy_wq) {\n\t\tdestroy_workqueue(xcopy_wq);\n\t\ttransport_uninit_session(&xcopy_pt_sess);\n\t}\n}\n\n/*\n * target_xcopy_setup_pt_cmd - set up a pass-through command\n * @xpt_cmd:\t Data structure to initialize.\n * @xop:\t Describes the XCOPY operation received from an initiator.\n * @se_dev:\t Backend device to associate with @xpt_cmd if\n *\t\t @remote_port == true.\n * @cdb:\t SCSI CDB to be copied into @xpt_cmd.\n * @remote_port: If false, use the LUN through which the XCOPY command has\n *\t\t been received. If true, use @se_dev->xcopy_lun.\n *\n * Set up a SCSI command (READ or WRITE) that will be used to execute an\n * XCOPY command.\n */\nstatic int target_xcopy_setup_pt_cmd(\n\tstruct xcopy_pt_cmd *xpt_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *se_dev,\n\tunsigned char *cdb,\n\tbool remote_port)\n{\n\tstruct se_cmd *cmd = &xpt_cmd->se_cmd;\n\n\t/*\n\t * Setup LUN+port to honor reservations based upon xop->op_origin for\n\t * X-COPY PUSH or X-COPY PULL based upon where the CDB was received.\n\t */\n\tif (remote_port) {\n\t\tcmd->se_lun = &se_dev->xcopy_lun;\n\t\tcmd->se_dev = se_dev;\n\t} else {\n\t\tcmd->se_lun = xop->xop_se_cmd->se_lun;\n\t\tcmd->se_dev = xop->xop_se_cmd->se_dev;\n\t}\n\tcmd->se_cmd_flags |= SCF_SE_LUN_CMD;\n\n\tif (target_cmd_init_cdb(cmd, cdb))\n\t\treturn -EINVAL;\n\n\tcmd->tag = 0;\n\tif (target_cmd_parse_cdb(cmd))\n\t\treturn -EINVAL;\n\n\tif (transport_generic_map_mem_to_cmd(cmd, xop->xop_data_sg,\n\t\t\t\t\txop->xop_data_nents, NULL, 0))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Setup PASSTHROUGH_NOALLOC t_data_sg: %p t_data_nents:\"\n\t\t \" %u\\n\", cmd->t_data_sg, cmd->t_data_nents);\n\n\treturn 0;\n}\n\nstatic int target_xcopy_issue_pt_cmd(struct xcopy_pt_cmd *xpt_cmd)\n{\n\tstruct se_cmd *se_cmd = &xpt_cmd->se_cmd;\n\tsense_reason_t sense_rc;\n\n\tsense_rc = transport_generic_new_cmd(se_cmd);\n\tif (sense_rc)\n\t\treturn -EINVAL;\n\n\tif (se_cmd->data_direction == DMA_TO_DEVICE)\n\t\ttarget_execute_cmd(se_cmd);\n\n\twait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);\n\n\tpr_debug(\"target_xcopy_issue_pt_cmd(): SCSI status: 0x%02x\\n\",\n\t\t\tse_cmd->scsi_status);\n\n\treturn (se_cmd->scsi_status) ? -EINVAL : 0;\n}\n\nstatic int target_xcopy_read_source(\n\tstruct se_cmd *ec_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *src_dev,\n\tsector_t src_lba,\n\tu32 src_sectors)\n{\n\tstruct xcopy_pt_cmd xpt_cmd;\n\tstruct se_cmd *se_cmd = &xpt_cmd.se_cmd;\n\tu32 length = (src_sectors * src_dev->dev_attrib.block_size);\n\tint rc;\n\tunsigned char cdb[16];\n\tbool remote_port = (xop->op_origin == XCOL_DEST_RECV_OP);\n\n\tmemset(&xpt_cmd, 0, sizeof(xpt_cmd));\n\tinit_completion(&xpt_cmd.xpt_passthrough_sem);\n\n\tmemset(&cdb[0], 0, 16);\n\tcdb[0] = READ_16;\n\tput_unaligned_be64(src_lba, &cdb[2]);\n\tput_unaligned_be32(src_sectors, &cdb[10]);\n\tpr_debug(\"XCOPY: Built READ_16: LBA: %llu Sectors: %u Length: %u\\n\",\n\t\t(unsigned long long)src_lba, src_sectors, length);\n\n\ttransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, length,\n\t\t\t      DMA_FROM_DEVICE, 0, &xpt_cmd.sense_buffer[0], 0);\n\n\trc = target_xcopy_setup_pt_cmd(&xpt_cmd, xop, src_dev, &cdb[0],\n\t\t\t\tremote_port);\n\tif (rc < 0) {\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY-READ: Saved xop->xop_data_sg: %p, num: %u for READ\"\n\t\t\" memory\\n\", xop->xop_data_sg, xop->xop_data_nents);\n\n\trc = target_xcopy_issue_pt_cmd(&xpt_cmd);\n\tif (rc < 0)\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\nout:\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn rc;\n}\n\nstatic int target_xcopy_write_destination(\n\tstruct se_cmd *ec_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *dst_dev,\n\tsector_t dst_lba,\n\tu32 dst_sectors)\n{\n\tstruct xcopy_pt_cmd xpt_cmd;\n\tstruct se_cmd *se_cmd = &xpt_cmd.se_cmd;\n\tu32 length = (dst_sectors * dst_dev->dev_attrib.block_size);\n\tint rc;\n\tunsigned char cdb[16];\n\tbool remote_port = (xop->op_origin == XCOL_SOURCE_RECV_OP);\n\n\tmemset(&xpt_cmd, 0, sizeof(xpt_cmd));\n\tinit_completion(&xpt_cmd.xpt_passthrough_sem);\n\n\tmemset(&cdb[0], 0, 16);\n\tcdb[0] = WRITE_16;\n\tput_unaligned_be64(dst_lba, &cdb[2]);\n\tput_unaligned_be32(dst_sectors, &cdb[10]);\n\tpr_debug(\"XCOPY: Built WRITE_16: LBA: %llu Sectors: %u Length: %u\\n\",\n\t\t(unsigned long long)dst_lba, dst_sectors, length);\n\n\ttransport_init_se_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, length,\n\t\t\t      DMA_TO_DEVICE, 0, &xpt_cmd.sense_buffer[0], 0);\n\n\trc = target_xcopy_setup_pt_cmd(&xpt_cmd, xop, dst_dev, &cdb[0],\n\t\t\t\tremote_port);\n\tif (rc < 0) {\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\n\t\tgoto out;\n\t}\n\n\trc = target_xcopy_issue_pt_cmd(&xpt_cmd);\n\tif (rc < 0)\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\nout:\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn rc;\n}\n\nstatic void target_xcopy_do_work(struct work_struct *work)\n{\n\tstruct xcopy_op *xop = container_of(work, struct xcopy_op, xop_work);\n\tstruct se_cmd *ec_cmd = xop->xop_se_cmd;\n\tstruct se_device *src_dev, *dst_dev;\n\tsector_t src_lba, dst_lba, end_lba;\n\tunsigned int max_sectors;\n\tint rc = 0;\n\tunsigned short nolb, max_nolb, copied_nolb = 0;\n\n\tif (target_parse_xcopy_cmd(xop) != TCM_NO_SENSE)\n\t\tgoto err_free;\n\n\tif (WARN_ON_ONCE(!xop->src_dev) || WARN_ON_ONCE(!xop->dst_dev))\n\t\tgoto err_free;\n\n\tsrc_dev = xop->src_dev;\n\tdst_dev = xop->dst_dev;\n\tsrc_lba = xop->src_lba;\n\tdst_lba = xop->dst_lba;\n\tnolb = xop->nolb;\n\tend_lba = src_lba + nolb;\n\t/*\n\t * Break up XCOPY I/O into hw_max_sectors sized I/O based on the\n\t * smallest max_sectors between src_dev + dev_dev, or\n\t */\n\tmax_sectors = min(src_dev->dev_attrib.hw_max_sectors,\n\t\t\t  dst_dev->dev_attrib.hw_max_sectors);\n\tmax_sectors = min_t(u32, max_sectors, XCOPY_MAX_SECTORS);\n\n\tmax_nolb = min_t(u16, max_sectors, ((u16)(~0U)));\n\n\tpr_debug(\"target_xcopy_do_work: nolb: %hu, max_nolb: %hu end_lba: %llu\\n\",\n\t\t\tnolb, max_nolb, (unsigned long long)end_lba);\n\tpr_debug(\"target_xcopy_do_work: Starting src_lba: %llu, dst_lba: %llu\\n\",\n\t\t\t(unsigned long long)src_lba, (unsigned long long)dst_lba);\n\n\twhile (src_lba < end_lba) {\n\t\tunsigned short cur_nolb = min(nolb, max_nolb);\n\t\tu32 cur_bytes = cur_nolb * src_dev->dev_attrib.block_size;\n\n\t\tif (cur_bytes != xop->xop_data_bytes) {\n\t\t\t/*\n\t\t\t * (Re)allocate a buffer large enough to hold the XCOPY\n\t\t\t * I/O size, which can be reused each read / write loop.\n\t\t\t */\n\t\t\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\t\t\trc = target_alloc_sgl(&xop->xop_data_sg,\n\t\t\t\t\t      &xop->xop_data_nents,\n\t\t\t\t\t      cur_bytes,\n\t\t\t\t\t      false, false);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\txop->xop_data_bytes = cur_bytes;\n\t\t}\n\n\t\tpr_debug(\"target_xcopy_do_work: Calling read src_dev: %p src_lba: %llu,\"\n\t\t\t\" cur_nolb: %hu\\n\", src_dev, (unsigned long long)src_lba, cur_nolb);\n\n\t\trc = target_xcopy_read_source(ec_cmd, xop, src_dev, src_lba, cur_nolb);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tsrc_lba += cur_nolb;\n\t\tpr_debug(\"target_xcopy_do_work: Incremented READ src_lba to %llu\\n\",\n\t\t\t\t(unsigned long long)src_lba);\n\n\t\tpr_debug(\"target_xcopy_do_work: Calling write dst_dev: %p dst_lba: %llu,\"\n\t\t\t\" cur_nolb: %hu\\n\", dst_dev, (unsigned long long)dst_lba, cur_nolb);\n\n\t\trc = target_xcopy_write_destination(ec_cmd, xop, dst_dev,\n\t\t\t\t\t\tdst_lba, cur_nolb);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tdst_lba += cur_nolb;\n\t\tpr_debug(\"target_xcopy_do_work: Incremented WRITE dst_lba to %llu\\n\",\n\t\t\t\t(unsigned long long)dst_lba);\n\n\t\tcopied_nolb += cur_nolb;\n\t\tnolb -= cur_nolb;\n\t}\n\n\txcopy_pt_undepend_remotedev(xop);\n\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\tkfree(xop);\n\n\tpr_debug(\"target_xcopy_do_work: Final src_lba: %llu, dst_lba: %llu\\n\",\n\t\t(unsigned long long)src_lba, (unsigned long long)dst_lba);\n\tpr_debug(\"target_xcopy_do_work: Blocks copied: %hu, Bytes Copied: %u\\n\",\n\t\tcopied_nolb, copied_nolb * dst_dev->dev_attrib.block_size);\n\n\tpr_debug(\"target_xcopy_do_work: Setting X-COPY GOOD status -> sending response\\n\");\n\ttarget_complete_cmd(ec_cmd, SAM_STAT_GOOD);\n\treturn;\n\nout:\n\txcopy_pt_undepend_remotedev(xop);\n\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\nerr_free:\n\tkfree(xop);\n\t/*\n\t * Don't override an error scsi status if it has already been set\n\t */\n\tif (ec_cmd->scsi_status == SAM_STAT_GOOD) {\n\t\tpr_warn_ratelimited(\"target_xcopy_do_work: rc: %d, Setting X-COPY\"\n\t\t\t\" CHECK_CONDITION -> sending response\\n\", rc);\n\t\tec_cmd->scsi_status = SAM_STAT_CHECK_CONDITION;\n\t}\n\ttarget_complete_cmd(ec_cmd, ec_cmd->scsi_status);\n}\n\n/*\n * Returns TCM_NO_SENSE upon success or a sense code != TCM_NO_SENSE if parsing\n * fails.\n */\nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop)\n{\n\tstruct se_cmd *se_cmd = xop->xop_se_cmd;\n\tunsigned char *p = NULL, *seg_desc;\n\tunsigned int list_id, list_id_usage, sdll, inline_dl;\n\tsense_reason_t ret = TCM_INVALID_PARAMETER_LIST;\n\tint rc;\n\tunsigned short tdll;\n\n\tp = transport_kmap_data_sg(se_cmd);\n\tif (!p) {\n\t\tpr_err(\"transport_kmap_data_sg() failed in target_do_xcopy\\n\");\n\t\treturn TCM_OUT_OF_RESOURCES;\n\t}\n\n\tlist_id = p[0];\n\tlist_id_usage = (p[1] & 0x18) >> 3;\n\n\t/*\n\t * Determine TARGET DESCRIPTOR LIST LENGTH + SEGMENT DESCRIPTOR LIST LENGTH\n\t */\n\ttdll = get_unaligned_be16(&p[2]);\n\tsdll = get_unaligned_be32(&p[8]);\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\tpr_err(\"XCOPY descriptor list length %u exceeds maximum %u\\n\",\n\t\t       tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tinline_dl = get_unaligned_be32(&p[12]);\n\tif (inline_dl != 0) {\n\t\tpr_err(\"XCOPY with non zero inline data length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (se_cmd->data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\tpr_err(\"XCOPY parameter truncation: data length %u too small \"\n\t\t\t\"for tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t\tse_cmd->data_length, tdll, sdll, inline_dl);\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"Processing XCOPY with list_id: 0x%02x list_id_usage: 0x%02x\"\n\t\t\" tdll: %hu sdll: %u inline_dl: %u\\n\", list_id, list_id_usage,\n\t\ttdll, sdll, inline_dl);\n\n\t/*\n\t * skip over the target descriptors until segment descriptors\n\t * have been passed - CSCD ids are needed to determine src and dest.\n\t */\n\tseg_desc = &p[16] + tdll;\n\n\trc = target_xcopy_parse_segment_descriptors(se_cmd, xop, seg_desc,\n\t\t\t\t\t\t    sdll, &ret);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tpr_debug(\"XCOPY: Processed %d segment descriptors, length: %u\\n\", rc,\n\t\t\t\trc * XCOPY_SEGMENT_DESC_LEN);\n\n\trc = target_xcopy_parse_target_descriptors(se_cmd, xop, &p[16], tdll, &ret);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tif (xop->src_dev->dev_attrib.block_size !=\n\t    xop->dst_dev->dev_attrib.block_size) {\n\t\tpr_err(\"XCOPY: Non matching src_dev block_size: %u + dst_dev\"\n\t\t       \" block_size: %u currently unsupported\\n\",\n\t\t\txop->src_dev->dev_attrib.block_size,\n\t\t\txop->dst_dev->dev_attrib.block_size);\n\t\txcopy_pt_undepend_remotedev(xop);\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY: Processed %d target descriptors, length: %u\\n\", rc,\n\t\t\t\trc * XCOPY_TARGET_DESC_LEN);\n\ttransport_kunmap_data_sg(se_cmd);\n\treturn TCM_NO_SENSE;\n\nout:\n\tif (p)\n\t\ttransport_kunmap_data_sg(se_cmd);\n\treturn ret;\n}\n\nsense_reason_t target_do_xcopy(struct se_cmd *se_cmd)\n{\n\tstruct se_device *dev = se_cmd->se_dev;\n\tstruct xcopy_op *xop;\n\tunsigned int sa;\n\n\tif (!dev->dev_attrib.emulate_3pc) {\n\t\tpr_err(\"EXTENDED_COPY operation explicitly disabled\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tsa = se_cmd->t_task_cdb[1] & 0x1f;\n\tif (sa != 0x00) {\n\t\tpr_err(\"EXTENDED_COPY(LID4) not supported\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tif (se_cmd->data_length == 0) {\n\t\ttarget_complete_cmd(se_cmd, SAM_STAT_GOOD);\n\t\treturn TCM_NO_SENSE;\n\t}\n\tif (se_cmd->data_length < XCOPY_HDR_LEN) {\n\t\tpr_err(\"XCOPY parameter truncation: length %u < hdr_len %u\\n\",\n\t\t\t\tse_cmd->data_length, XCOPY_HDR_LEN);\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t}\n\n\txop = kzalloc(sizeof(struct xcopy_op), GFP_KERNEL);\n\tif (!xop)\n\t\tgoto err;\n\txop->xop_se_cmd = se_cmd;\n\tINIT_WORK(&xop->xop_work, target_xcopy_do_work);\n\tif (WARN_ON_ONCE(!queue_work(xcopy_wq, &xop->xop_work)))\n\t\tgoto free;\n\treturn TCM_NO_SENSE;\n\nfree:\n\tkfree(xop);\n\nerr:\n\treturn TCM_OUT_OF_RESOURCES;\n}\n\nstatic sense_reason_t target_rcr_operating_parameters(struct se_cmd *se_cmd)\n{\n\tunsigned char *p;\n\n\tp = transport_kmap_data_sg(se_cmd);\n\tif (!p) {\n\t\tpr_err(\"transport_kmap_data_sg failed in\"\n\t\t       \" target_rcr_operating_parameters\\n\");\n\t\treturn TCM_OUT_OF_RESOURCES;\n\t}\n\n\tif (se_cmd->data_length < 54) {\n\t\tpr_err(\"Receive Copy Results Op Parameters length\"\n\t\t       \" too small: %u\\n\", se_cmd->data_length);\n\t\ttransport_kunmap_data_sg(se_cmd);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\t/*\n\t * Set SNLID=1 (Supports no List ID)\n\t */\n\tp[4] = 0x1;\n\t/*\n\t * MAXIMUM TARGET DESCRIPTOR COUNT\n\t */\n\tput_unaligned_be16(RCR_OP_MAX_TARGET_DESC_COUNT, &p[8]);\n\t/*\n\t * MAXIMUM SEGMENT DESCRIPTOR COUNT\n\t */\n\tput_unaligned_be16(RCR_OP_MAX_SG_DESC_COUNT, &p[10]);\n\t/*\n\t * MAXIMUM DESCRIPTOR LIST LENGTH\n\t */\n\tput_unaligned_be32(RCR_OP_MAX_DESC_LIST_LEN, &p[12]);\n\t/*\n\t * MAXIMUM SEGMENT LENGTH\n\t */\n\tput_unaligned_be32(RCR_OP_MAX_SEGMENT_LEN, &p[16]);\n\t/*\n\t * MAXIMUM INLINE DATA LENGTH for SA 0x04 (NOT SUPPORTED)\n\t */\n\tput_unaligned_be32(0x0, &p[20]);\n\t/*\n\t * HELD DATA LIMIT\n\t */\n\tput_unaligned_be32(0x0, &p[24]);\n\t/*\n\t * MAXIMUM STREAM DEVICE TRANSFER SIZE\n\t */\n\tput_unaligned_be32(0x0, &p[28]);\n\t/*\n\t * TOTAL CONCURRENT COPIES\n\t */\n\tput_unaligned_be16(RCR_OP_TOTAL_CONCURR_COPIES, &p[34]);\n\t/*\n\t * MAXIMUM CONCURRENT COPIES\n\t */\n\tp[36] = RCR_OP_MAX_CONCURR_COPIES;\n\t/*\n\t * DATA SEGMENT GRANULARITY (log 2)\n\t */\n\tp[37] = RCR_OP_DATA_SEG_GRAN_LOG2;\n\t/*\n\t * INLINE DATA GRANULARITY log 2)\n\t */\n\tp[38] = RCR_OP_INLINE_DATA_GRAN_LOG2;\n\t/*\n\t * HELD DATA GRANULARITY\n\t */\n\tp[39] = RCR_OP_HELD_DATA_GRAN_LOG2;\n\t/*\n\t * IMPLEMENTED DESCRIPTOR LIST LENGTH\n\t */\n\tp[43] = 0x2;\n\t/*\n\t * List of implemented descriptor type codes (ordered)\n\t */\n\tp[44] = 0x02; /* Copy Block to Block device */\n\tp[45] = 0xe4; /* Identification descriptor target descriptor */\n\n\t/*\n\t * AVAILABLE DATA (n-3)\n\t */\n\tput_unaligned_be32(42, &p[0]);\n\n\ttransport_kunmap_data_sg(se_cmd);\n\ttarget_complete_cmd(se_cmd, GOOD);\n\n\treturn TCM_NO_SENSE;\n}\n\nsense_reason_t target_do_receive_copy_results(struct se_cmd *se_cmd)\n{\n\tunsigned char *cdb = &se_cmd->t_task_cdb[0];\n\tint sa = (cdb[1] & 0x1f), list_id = cdb[2];\n\tsense_reason_t rc = TCM_NO_SENSE;\n\n\tpr_debug(\"Entering target_do_receive_copy_results: SA: 0x%02x, List ID:\"\n\t\t\" 0x%02x, AL: %u\\n\", sa, list_id, se_cmd->data_length);\n\n\tif (list_id != 0) {\n\t\tpr_err(\"Receive Copy Results with non zero list identifier\"\n\t\t       \" not supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tswitch (sa) {\n\tcase RCR_SA_OPERATING_PARAMETERS:\n\t\trc = target_rcr_operating_parameters(se_cmd);\n\t\tbreak;\n\tcase RCR_SA_COPY_STATUS:\n\tcase RCR_SA_RECEIVE_DATA:\n\tcase RCR_SA_FAILED_SEGMENT_DETAILS:\n\tdefault:\n\t\tpr_err(\"Unsupported SA for receive copy results: 0x%02x\\n\", sa);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\treturn rc;\n}\n", "/* SPDX-License-Identifier: GPL-2.0 */\n#include <target/target_core_base.h>\n\n#define XCOPY_HDR_LEN\t\t\t16\n#define XCOPY_TARGET_DESC_LEN\t\t32\n#define XCOPY_SEGMENT_DESC_LEN\t\t28\n#define XCOPY_NAA_IEEE_REGEX_LEN\t16\n#define XCOPY_MAX_SECTORS\t\t4096\n\n/*\n * SPC4r37 6.4.6.1\n * Table 150 \u2014 CSCD descriptor ID values\n */\n#define XCOPY_CSCD_DESC_ID_LIST_OFF_MAX\t0x07FF\n\nenum xcopy_origin_list {\n\tXCOL_SOURCE_RECV_OP = 0x01,\n\tXCOL_DEST_RECV_OP = 0x02,\n};\n\nstruct xcopy_op {\n\tint op_origin;\n\n\tstruct se_cmd *xop_se_cmd;\n\tstruct se_device *src_dev;\n\tunsigned char src_tid_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tstruct se_device *dst_dev;\n\tunsigned char dst_tid_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tunsigned char local_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tstruct percpu_ref *remote_lun_ref;\n\n\tsector_t src_lba;\n\tsector_t dst_lba;\n\tunsigned short stdi;\n\tunsigned short dtdi;\n\tunsigned short nolb;\n\n\tu32 xop_data_bytes;\n\tu32 xop_data_nents;\n\tstruct scatterlist *xop_data_sg;\n\tstruct work_struct xop_work;\n};\n\n/*\n * Receive Copy Results Sevice Actions\n */\n#define RCR_SA_COPY_STATUS\t\t0x00\n#define RCR_SA_RECEIVE_DATA\t\t0x01\n#define RCR_SA_OPERATING_PARAMETERS\t0x03\n#define RCR_SA_FAILED_SEGMENT_DETAILS\t0x04\n\n/*\n * Receive Copy Results defs for Operating Parameters\n */\n#define RCR_OP_MAX_TARGET_DESC_COUNT\t0x2\n#define RCR_OP_MAX_SG_DESC_COUNT\t0x1\n#define RCR_OP_MAX_DESC_LIST_LEN\t1024\n#define RCR_OP_MAX_SEGMENT_LEN\t\t268435456 /* 256 MB */\n#define RCR_OP_TOTAL_CONCURR_COPIES\t0x1 /* Must be <= 16384 */\n#define RCR_OP_MAX_CONCURR_COPIES\t0x1 /* Must be <= 255 */\n#define RCR_OP_DATA_SEG_GRAN_LOG2\t9 /* 512 bytes in log 2 */\n#define RCR_OP_INLINE_DATA_GRAN_LOG2\t9 /* 512 bytes in log 2 */\n#define RCR_OP_HELD_DATA_GRAN_LOG2\t9 /* 512 bytes in log 2 */\n\nextern int target_xcopy_setup_pt(void);\nextern void target_xcopy_release_pt(void);\nextern sense_reason_t target_do_xcopy(struct se_cmd *);\nextern sense_reason_t target_do_receive_copy_results(struct se_cmd *);\n"], "filenames": ["drivers/target/target_core_xcopy.c", "drivers/target/target_core_xcopy.h"], "buggy_code_start_loc": [49, 29], "buggy_code_end_loc": [406, 29], "fixing_code_start_loc": [49, 30], "fixing_code_end_loc": [427, 31], "type": "CWE-22", "message": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.", "other": {"cve": {"id": "CVE-2020-28374", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-13T04:15:12.837", "lastModified": "2021-03-15T22:04:23.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore."}, {"lang": "es", "value": "En el archivo drivers/target/target_core_xcopy.c en el kernel de Linux versiones anteriores a 5.10.7, unos atacantes remotos pueden usar una comprobaci\u00f3n del identificador insuficiente en el c\u00f3digo de destino LIO SCSI para leer o escribir archivos por medio de un salto de directorio en una petici\u00f3n XCOPY, tambi\u00e9n se conoce como CID-2896c93811e3.&#xa0;Por ejemplo, un ataque puede ocurrir en una red si el atacante presenta acceso a un iSCSI LUN.&#xa0;El atacante obtiene el control sobre el acceso a los archivos porque las operaciones de E/S son transferidas por medio de un almac\u00e9n secundario seleccionado por el atacante."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.10.7", "matchCriteriaId": "D20A1B57-8B94-4F54-884A-33AB1EEC87A2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/161229/Kernel-Live-Patch-Security-Notice-LSN-0074-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/01/13/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/01/13/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/attachment.cgi?id=844938", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1178372", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.10.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2896c93811e39d63a4d9b63ccf12a8fbc226e5e4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FZEUPID5DZYLZBIO4BEVLHFUDZZIFL57/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HK7SRTITN5ABAUOOIGFVR7XE5YKYYAVO/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LTGQDYIEO2GOCOOKADBHEITF44GY55QF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210219-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4843", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4"}}