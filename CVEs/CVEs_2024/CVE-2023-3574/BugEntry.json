{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace CustomerManagementFrameworkBundle\\Controller\\Admin;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * @Route(\"/rules\")\n */\nclass RulesController extends \\Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController\n{\n    /**\n     * get saved action trigger rules\n     *\n     * @param Request $request\n     * @Route(\"/list\")\n     */\n    public function listAction(Request $request)\n    {\n        $rules = new \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule\\Listing();\n        $rules->setOrderKey('name');\n        $rules->setOrder('ASC');\n\n        $json = [];\n        foreach ($rules->load() as $rule) {\n            if ($rule->getActive()) {\n                $icon = 'plugin_cmf_icon_rule_enabled';\n                $title = 'active';\n            } else {\n                $icon = 'plugin_cmf_icon_rule_disabled';\n                $title = 'inactive';\n            }\n\n            $json[] = [\n                'iconCls' => $icon,\n                'id' => $rule->getId(),\n                'text' => htmlspecialchars($rule->getName()),\n                'leaf' => true,\n                'qtipCfg' => [\n                    'title' => htmlspecialchars($title),\n                    'text' => htmlspecialchars($rule->getDescription()),\n                ],\n            ];\n        }\n\n        return $this->adminJson($json);\n    }\n\n    /**\n     * get rule config as json\n     *\n     * @param Request $request\n     * @Route(\"/get\")\n     */\n    public function getAction(Request $request)\n    {\n        $rule = \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule::getById((int)$request->get('id'));\n        if ($rule) {\n            // create json config\n            $json = [\n                'id' => $rule->getId(),\n                'name' => $rule->getName(),\n                'description' => $rule->getDescription(),\n                'active' => $rule->getActive(),\n                'trigger' => [],\n                'condition' => [],\n                'actions' => [],\n            ];\n\n            foreach ($rule->getTrigger() as $trigger) {\n                $json['trigger'][] = $trigger->toArray();\n            }\n\n            foreach ($rule->getAction() as $action) {\n                if (class_exists($action->getImplementationClass())) {\n                    $actionData = call_user_func([$action->getImplementationClass(), 'getDataForEditmode'], $action);\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $action->getImplementationClass()));\n                }\n\n                $json['actions'][] = $actionData;\n            }\n\n            foreach ($rule->getCondition() as $condition) {\n                if (class_exists($condition->getImplementationClass())) {\n                    $conditionData = call_user_func(\n                        [$condition->getImplementationClass(), 'getDataForEditmode'],\n                        $condition\n                    );\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $condition->getImplementationClass()));\n                }\n\n                $json['condition'][] = $conditionData;\n            }\n\n            return $this->adminJson($json);\n        }\n\n        return $this->adminJson(['error' => true, 'msg' => 'rule not found']);\n    }\n\n    /**\n     * save rule config\n     *\n     * @param Request $request\n     * @Route(\"/save\", methods={\"PUT\"})\n     */\n    public function saveAction(Request $request)\n    {\n        // send json response\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule config\n        try {\n            $rule = \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule::getById((int)$request->get('id'));\n            $data = json_decode($request->get('data'));\n\n            // apply basic settings\n            $rule->setName($data->settings->name);\n            $rule->setDescription($data->settings->description);\n            $rule->setActive((bool)$data->settings->active);\n\n            // save trigger\n            $arrTrigger = [];\n            foreach ($data->trigger as $setting) {\n                $setting = json_decode(json_encode($setting), true);\n                $trigger = new \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\TriggerDefinition($setting);\n                $arrTrigger[] = $trigger;\n            }\n            $rule->setTrigger($arrTrigger);\n\n            // create a tree from the flat structure\n            $arrCondition = [];\n            foreach ($data->conditions as $setting) {\n                if (class_exists($setting->implementationClass)) {\n                    $condition = call_user_func(\n                        [$setting->implementationClass, 'createConditionDefinitionFromEditmode'],\n                        $setting\n                    );\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $setting->implementationClass));\n                }\n                $arrCondition[] = $condition;\n            }\n\n            $rule->setCondition($arrCondition);\n\n            // save action\n            $arrActions = [];\n            foreach ($data->actions as $setting) {\n                if (class_exists($setting->implementationClass)) {\n                    $action = call_user_func(\n                        [$setting->implementationClass, 'createActionDefinitionFromEditmode'],\n                        $setting\n                    );\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $setting->implementationClass));\n                }\n\n                $arrActions[] = $action;\n            }\n\n            $rule->setAction($arrActions);\n\n            // save rule\n            $rule->save();\n\n            // finish\n            $return['success'] = true;\n            $return['id'] = $rule->getId();\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send response\n        return $this->adminJson($return);\n    }\n\n    /**\n     * add new rule\n     *\n     * @param Request $request\n     * @Route(\"/add\", methods={\"POST\"})\n     */\n    public function addAction(Request $request)\n    {\n        // send json response\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule\n        try {\n            $rule = new \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule();\n            $rule->setName($request->get('name'));\n            if ($rule->save()) {\n                $return['success'] = true;\n                $return['id'] = $rule->getId();\n            }\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n            $return['success'] = false;\n        }\n\n        // send response\n        return $this->adminJson($return);\n    }\n\n    /**\n     * delete exiting rule\n     *\n     * @param Request $request\n     * @Route(\"/delete\", methods={\"DELETE\"})\n     */\n    public function deleteAction(Request $request)\n    {\n        // send json response\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // delete rule\n        try {\n            $rule = \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule::getById((int)$request->get('id'));\n            $rule->delete();\n            $return['success'] = true;\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send response\n        return $this->adminJson($return);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace CustomerManagementFrameworkBundle\\Targeting;\n\nuse CustomerManagementFrameworkBundle\\ActionTrigger\\Event\\SegmentTracked;\nuse CustomerManagementFrameworkBundle\\Model\\CustomerInterface;\nuse CustomerManagementFrameworkBundle\\Model\\CustomerSegmentInterface;\nuse CustomerManagementFrameworkBundle\\SegmentManager\\SegmentManagerInterface;\nuse CustomerManagementFrameworkBundle\\Targeting\\DataProvider\\Customer;\nuse Pimcore\\Targeting\\DataLoaderInterface;\nuse Pimcore\\Targeting\\Model\\VisitorInfo;\nuse Pimcore\\Targeting\\Storage\\TargetingStorageInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * Handles storage of tracked segments to request-persistent targeting storage (e.g. session)\n */\nclass SegmentTracker\n{\n    const KEY_SEGMENTS = 'cmf:sg';\n\n    /**\n     * @var TargetingStorageInterface\n     */\n    private $targetingStorage;\n\n    /**\n     * @var DataLoaderInterface\n     */\n    private $dataLoader;\n\n    /**\n     * @var SegmentManagerInterface\n     */\n    private $segmentManager;\n\n    /**\n     * @var EventDispatcherInterface\n     */\n    private $eventDispatcher;\n\n    public function __construct(\n        TargetingStorageInterface $targetingStorage,\n        DataLoaderInterface $dataLoader,\n        SegmentManagerInterface $segmentManager,\n        EventDispatcherInterface $eventDispatcher\n    ) {\n        $this->targetingStorage = $targetingStorage;\n        $this->dataLoader = $dataLoader;\n        $this->segmentManager = $segmentManager;\n        $this->eventDispatcher = $eventDispatcher;\n    }\n\n    public function trackSegment(VisitorInfo $visitorInfo, CustomerSegmentInterface $segment)\n    {\n        $this->trackSegments($visitorInfo, [$segment]);\n    }\n\n    /**\n     * @param VisitorInfo $visitorInfo\n     * @param CustomerSegmentInterface[] $segments\n     */\n    public function trackSegments(VisitorInfo $visitorInfo, array $segments)\n    {\n        $assignments = [];\n        foreach ($segments as $segment) {\n            if (!$segment instanceof CustomerSegmentInterface) {\n                throw new \\InvalidArgumentException(sprintf(\n                    'Segments is expected to be an array of CustomerSegmentInterface instances, but got a %s',\n                    get_debug_type($segment)\n                ));\n            }\n\n            $assignments[$segment->getId()] = 1;\n        }\n\n        $this->trackAssignments($visitorInfo, $assignments);\n    }\n\n    /**\n     * Raw method to track ID to count assignments. Use trackSegment(s) if possible.\n     *\n     * @param VisitorInfo $visitorInfo\n     * @param array $assignments Segment ID as key, count as value\n     */\n    public function trackAssignments(VisitorInfo $visitorInfo, array $assignments)\n    {\n        $eventData = [];\n\n        $segments = $this->getAssignments($visitorInfo);\n        foreach ($assignments as $segmentId => $count) {\n            if (!isset($segments[$segmentId])) {\n                $segments[$segmentId] = 0;\n            }\n\n            $segments[$segmentId] += $count;\n            $eventData[$segmentId] = $segments[$segmentId];\n        }\n\n        $this->targetingStorage->set(\n            $visitorInfo,\n            TargetingStorageInterface::SCOPE_VISITOR,\n            self::KEY_SEGMENTS,\n            $segments\n        );\n\n        foreach ($eventData as $segmentId => $count) {\n            $this->dispatchTrackEvent($visitorInfo, $segmentId, $count);\n        }\n    }\n\n    /**\n     * Read ID <-> count assignment mapping from storage\n     *\n     * @param VisitorInfo $visitorInfo\n     *\n     * @return array\n     */\n    public function getAssignments(VisitorInfo $visitorInfo): array\n    {\n        return $this->targetingStorage->get(\n            $visitorInfo,\n            TargetingStorageInterface::SCOPE_VISITOR,\n            self::KEY_SEGMENTS,\n            []\n        );\n    }\n\n    /**\n     * Returns assigned segments filtered for $allowedSegmentGroupReferences grouped by segment groups\n     *\n     * @param VisitorInfo $visitorInfo\n     * @param array $allowedSegmentGroupReferences\n     * @param int $limitSegmentCountPerGroup\n     *\n     * @return array\n     */\n    public function getFilteredAssignments(VisitorInfo $visitorInfo, array $allowedSegmentGroupReferences, int $limitSegmentCountPerGroup): array\n    {\n        $trackedSegments = $this->getAssignments($visitorInfo);\n\n        //get relevant segments\n        $segmentCollection = [];\n        foreach ($trackedSegments as $segmentId => $count) {\n            $segment = $this->segmentManager->getSegmentById($segmentId);\n            if ($segment) {\n                $reference = $segment->getGroup()->getReference();\n                if (in_array($reference, $allowedSegmentGroupReferences)) {\n                    $segmentCollection[$reference][] = [\n                        'segment' => $segment,\n                        'count' => $count\n                    ];\n                }\n            }\n        }\n\n        if (empty($segmentCollection)) {\n            return [];\n        }\n\n        //order segments by count, pick $limitSegmentCountPerGroup top segments\n        foreach ($segmentCollection as $group => $groupCollection) {\n            if (!empty($groupCollection)) {\n                usort($groupCollection, function ($left, $right) {\n                    if ($left['count'] === $right['count']) {\n                        return 0;\n                    }\n\n                    return ($left['count'] < $right['count']) ? 1 : -1;\n                });\n\n                $segmentCollection[$group] = array_slice($groupCollection, 0, $limitSegmentCountPerGroup);\n            }\n        }\n\n        return $segmentCollection;\n    }\n\n    private function dispatchTrackEvent(VisitorInfo $visitorInfo, int $segmentId, int $count)\n    {\n        $this->dataLoader->loadDataFromProviders($visitorInfo, [Customer::PROVIDER_KEY]);\n\n        /** @var CustomerInterface|null $customer */\n        $customer = $visitorInfo->get(Customer::PROVIDER_KEY);\n        if (null === $customer) {\n            return;\n        }\n\n        $segment = $this->segmentManager->getSegmentById($segmentId);\n        if (null === $segment) {\n            return;\n        }\n\n        $event = SegmentTracked::create($customer, $segment, $count);\n\n        $this->eventDispatcher->dispatch($event, $event->getName());\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace CustomerManagementFrameworkBundle\\Controller\\Admin;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * @Route(\"/rules\")\n */\nclass RulesController extends AdminController implements KernelControllerEventInterface\n{\n    public function onKernelControllerEvent(ControllerEvent $event)\n    {\n        $this->checkPermission('plugin_cmf_perm_customer_automation_rules');\n    }\n\n    /**\n     * get saved action trigger rules\n     *\n     * @param Request $request\n     * @Route(\"/list\")\n     */\n    public function listAction(Request $request)\n    {\n        $rules = new \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule\\Listing();\n        $rules->setOrderKey('name');\n        $rules->setOrder('ASC');\n\n        $json = [];\n        foreach ($rules->load() as $rule) {\n            if ($rule->getActive()) {\n                $icon = 'plugin_cmf_icon_rule_enabled';\n                $title = 'active';\n            } else {\n                $icon = 'plugin_cmf_icon_rule_disabled';\n                $title = 'inactive';\n            }\n\n            $json[] = [\n                'iconCls' => $icon,\n                'id' => $rule->getId(),\n                'text' => htmlspecialchars($rule->getName()),\n                'leaf' => true,\n                'qtipCfg' => [\n                    'title' => htmlspecialchars($title),\n                    'text' => htmlspecialchars($rule->getDescription()),\n                ],\n            ];\n        }\n\n        return $this->adminJson($json);\n    }\n\n    /**\n     * get rule config as json\n     *\n     * @param Request $request\n     * @Route(\"/get\")\n     */\n    public function getAction(Request $request)\n    {\n        $rule = \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule::getById((int)$request->get('id'));\n        if ($rule) {\n            // create json config\n            $json = [\n                'id' => $rule->getId(),\n                'name' => $rule->getName(),\n                'description' => $rule->getDescription(),\n                'active' => $rule->getActive(),\n                'trigger' => [],\n                'condition' => [],\n                'actions' => [],\n            ];\n\n            foreach ($rule->getTrigger() as $trigger) {\n                $json['trigger'][] = $trigger->toArray();\n            }\n\n            foreach ($rule->getAction() as $action) {\n                if (class_exists($action->getImplementationClass())) {\n                    $actionData = call_user_func([$action->getImplementationClass(), 'getDataForEditmode'], $action);\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $action->getImplementationClass()));\n                }\n\n                $json['actions'][] = $actionData;\n            }\n\n            foreach ($rule->getCondition() as $condition) {\n                if (class_exists($condition->getImplementationClass())) {\n                    $conditionData = call_user_func(\n                        [$condition->getImplementationClass(), 'getDataForEditmode'],\n                        $condition\n                    );\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $condition->getImplementationClass()));\n                }\n\n                $json['condition'][] = $conditionData;\n            }\n\n            return $this->adminJson($json);\n        }\n\n        return $this->adminJson(['error' => true, 'msg' => 'rule not found']);\n    }\n\n    /**\n     * save rule config\n     *\n     * @param Request $request\n     * @Route(\"/save\", methods={\"PUT\"})\n     */\n    public function saveAction(Request $request)\n    {\n        // send json response\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule config\n        try {\n            $rule = \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule::getById((int)$request->get('id'));\n            $data = json_decode($request->get('data'));\n\n            // apply basic settings\n            $rule->setName($data->settings->name);\n            $rule->setDescription($data->settings->description);\n            $rule->setActive((bool)$data->settings->active);\n\n            // save trigger\n            $arrTrigger = [];\n            foreach ($data->trigger as $setting) {\n                $setting = json_decode(json_encode($setting), true);\n                $trigger = new \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\TriggerDefinition($setting);\n                $arrTrigger[] = $trigger;\n            }\n            $rule->setTrigger($arrTrigger);\n\n            // create a tree from the flat structure\n            $arrCondition = [];\n            foreach ($data->conditions as $setting) {\n                if (class_exists($setting->implementationClass)) {\n                    $condition = call_user_func(\n                        [$setting->implementationClass, 'createConditionDefinitionFromEditmode'],\n                        $setting\n                    );\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $setting->implementationClass));\n                }\n                $arrCondition[] = $condition;\n            }\n\n            $rule->setCondition($arrCondition);\n\n            // save action\n            $arrActions = [];\n            foreach ($data->actions as $setting) {\n                if (class_exists($setting->implementationClass)) {\n                    $action = call_user_func(\n                        [$setting->implementationClass, 'createActionDefinitionFromEditmode'],\n                        $setting\n                    );\n                } else {\n                    throw new \\Exception(sprintf(\"class '%s' does not exist\", $setting->implementationClass));\n                }\n\n                $arrActions[] = $action;\n            }\n\n            $rule->setAction($arrActions);\n\n            // save rule\n            $rule->save();\n\n            // finish\n            $return['success'] = true;\n            $return['id'] = $rule->getId();\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send response\n        return $this->adminJson($return);\n    }\n\n    /**\n     * add new rule\n     *\n     * @param Request $request\n     * @Route(\"/add\", methods={\"POST\"})\n     */\n    public function addAction(Request $request)\n    {\n        // send json response\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule\n        try {\n            $rule = new \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule();\n            $rule->setName($request->get('name'));\n            if ($rule->save()) {\n                $return['success'] = true;\n                $return['id'] = $rule->getId();\n            }\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n            $return['success'] = false;\n        }\n\n        // send response\n        return $this->adminJson($return);\n    }\n\n    /**\n     * delete exiting rule\n     *\n     * @param Request $request\n     * @Route(\"/delete\", methods={\"DELETE\"})\n     */\n    public function deleteAction(Request $request)\n    {\n        // send json response\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // delete rule\n        try {\n            $rule = \\CustomerManagementFrameworkBundle\\Model\\ActionTrigger\\Rule::getById((int)$request->get('id'));\n            $rule->delete();\n            $return['success'] = true;\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send response\n        return $this->adminJson($return);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace CustomerManagementFrameworkBundle\\Targeting;\n\nuse CustomerManagementFrameworkBundle\\ActionTrigger\\Event\\SegmentTracked;\nuse CustomerManagementFrameworkBundle\\Model\\CustomerInterface;\nuse CustomerManagementFrameworkBundle\\Model\\CustomerSegmentInterface;\nuse CustomerManagementFrameworkBundle\\SegmentManager\\SegmentManagerInterface;\nuse CustomerManagementFrameworkBundle\\Targeting\\DataProvider\\Customer;\nuse Pimcore\\Targeting\\DataLoaderInterface;\nuse Pimcore\\Targeting\\Model\\VisitorInfo;\nuse Pimcore\\Targeting\\Storage\\TargetingStorageInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * Handles storage of tracked segments to request-persistent targeting storage (e.g. session)\n */\nclass SegmentTracker\n{\n    const KEY_SEGMENTS = 'cmf:sg';\n\n    /**\n     * @var TargetingStorageInterface\n     */\n    private $targetingStorage;\n\n    /**\n     * @var DataLoaderInterface\n     */\n    private $dataLoader;\n\n    /**\n     * @var SegmentManagerInterface\n     */\n    private $segmentManager;\n\n    /**\n     * @var EventDispatcherInterface\n     */\n    private $eventDispatcher;\n\n    public function __construct(\n        TargetingStorageInterface $targetingStorage,\n        DataLoaderInterface $dataLoader,\n        SegmentManagerInterface $segmentManager,\n        EventDispatcherInterface $eventDispatcher\n    ) {\n        $this->targetingStorage = $targetingStorage;\n        $this->dataLoader = $dataLoader;\n        $this->segmentManager = $segmentManager;\n        $this->eventDispatcher = $eventDispatcher;\n    }\n\n    public function trackSegment(VisitorInfo $visitorInfo, CustomerSegmentInterface $segment)\n    {\n        $this->trackSegments($visitorInfo, [$segment]);\n    }\n\n    /**\n     * @param VisitorInfo $visitorInfo\n     * @param CustomerSegmentInterface[] $segments\n     */\n    public function trackSegments(VisitorInfo $visitorInfo, array $segments)\n    {\n        $assignments = [];\n        foreach ($segments as $segment) {\n            if (!$segment instanceof CustomerSegmentInterface) {\n                throw new \\InvalidArgumentException(sprintf(\n                    'Segments is expected to be an array of CustomerSegmentInterface instances, but got a %s',\n                    get_debug_type($segment)\n                ));\n            }\n\n            $assignments[$segment->getId()] = 1;\n        }\n\n        $this->trackAssignments($visitorInfo, $assignments);\n    }\n\n    /**\n     * Raw method to track ID to count assignments. Use trackSegment(s) if possible.\n     *\n     * @param VisitorInfo $visitorInfo\n     * @param array $assignments Segment ID as key, count as value\n     */\n    public function trackAssignments(VisitorInfo $visitorInfo, array $assignments)\n    {\n        $eventData = [];\n\n        $segments = $this->getAssignments($visitorInfo);\n        foreach ($assignments as $segmentId => $count) {\n            if (!isset($segments[$segmentId])) {\n                $segments[$segmentId] = 0;\n            }\n\n            $segments[$segmentId] += $count;\n            $eventData[$segmentId] = $segments[$segmentId];\n        }\n\n        $this->targetingStorage->set(\n            $visitorInfo,\n            TargetingStorageInterface::SCOPE_VISITOR,\n            self::KEY_SEGMENTS,\n            $segments\n        );\n\n        foreach ($eventData as $segmentId => $count) {\n            $this->dispatchTrackEvent($visitorInfo, $segmentId, $count);\n        }\n    }\n\n    /**\n     * Read ID <-> count assignment mapping from storage\n     *\n     * @param VisitorInfo $visitorInfo\n     *\n     * @return array\n     */\n    public function getAssignments(VisitorInfo $visitorInfo): array\n    {\n        return $this->targetingStorage->get(\n            $visitorInfo,\n            TargetingStorageInterface::SCOPE_VISITOR,\n            self::KEY_SEGMENTS,\n            []\n        );\n    }\n\n    /**\n     * Returns assigned segments filtered for $allowedSegmentGroupReferences grouped by segment groups\n     *\n     * @param VisitorInfo $visitorInfo\n     * @param array $allowedSegmentGroupReferences\n     * @param int $limitSegmentCountPerGroup\n     *\n     * @return array\n     */\n    public function getFilteredAssignments(VisitorInfo $visitorInfo, array $allowedSegmentGroupReferences, int $limitSegmentCountPerGroup): array\n    {\n        $trackedSegments = $this->getAssignments($visitorInfo);\n\n        //get relevant segments\n        $segmentCollection = [];\n        foreach ($trackedSegments as $segmentId => $count) {\n            $segment = $this->segmentManager->getSegmentById($segmentId);\n            if ($segment) {\n                $reference = $segment->getGroup()->getReference();\n                if (in_array($reference, $allowedSegmentGroupReferences)) {\n                    $segmentCollection[$reference][] = [\n                        'segment' => $segment,\n                        'count' => $count\n                    ];\n                }\n            }\n        }\n\n        if (empty($segmentCollection)) {\n            return [];\n        }\n\n        //order segments by count, pick $limitSegmentCountPerGroup top segments\n        foreach ($segmentCollection as $group => $groupCollection) {\n            usort($groupCollection, function ($left, $right) {\n                if ($left['count'] === $right['count']) {\n                    return 0;\n                }\n\n                return ($left['count'] < $right['count']) ? 1 : -1;\n            });\n\n            $segmentCollection[$group] = array_slice($groupCollection, 0, $limitSegmentCountPerGroup);\n        }\n\n        return $segmentCollection;\n    }\n\n    private function dispatchTrackEvent(VisitorInfo $visitorInfo, int $segmentId, int $count)\n    {\n        $this->dataLoader->loadDataFromProviders($visitorInfo, [Customer::PROVIDER_KEY]);\n\n        /** @var CustomerInterface|null $customer */\n        $customer = $visitorInfo->get(Customer::PROVIDER_KEY);\n        if (null === $customer) {\n            return;\n        }\n\n        $segment = $this->segmentManager->getSegmentById($segmentId);\n        if (null === $segment) {\n            return;\n        }\n\n        $event = SegmentTracked::create($customer, $segment, $count);\n\n        $this->eventDispatcher->dispatch($event, $event->getName());\n    }\n}\n"], "filenames": ["src/Controller/Admin/RulesController.php", "src/Targeting/SegmentTracker.php"], "buggy_code_start_loc": [17, 178], "buggy_code_end_loc": [25, 189], "fixing_code_start_loc": [18, 178], "fixing_code_end_loc": [34, 187], "type": "NVD-CWE-Other", "message": "Improper Authorization in GitHub repository pimcore/customer-data-framework prior to 3.4.1.", "other": {"cve": {"id": "CVE-2023-3574", "sourceIdentifier": "security@huntr.dev", "published": "2023-07-10T16:15:56.527", "lastModified": "2023-07-19T15:58:24.693", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository pimcore/customer-data-framework prior to 3.4.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:customer_management_framework:*:*:*:*:*:pimcore:*:*", "versionEndExcluding": "3.4.1", "matchCriteriaId": "42F483FD-ED43-48AB-8A38-71820B860CBF"}]}]}], "references": [{"url": "https://github.com/pimcore/customer-data-framework/commit/f15668c86db254e86ba7ac895bc3cdd1a2a3cc45", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/1dcb4f01-e668-4aa3-a6a3-838532e500c6", "source": "security@huntr.dev", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/pimcore/customer-data-framework/commit/f15668c86db254e86ba7ac895bc3cdd1a2a3cc45"}}