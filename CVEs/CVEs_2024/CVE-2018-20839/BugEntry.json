{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/kd.h>\n#include <linux/tiocl.h>\n#include <linux/vt.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/sysmacros.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"copy.h\"\n#include \"def.h\"\n#include \"env-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"io-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"namespace-util.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"proc-cmdline.h\"\n#include \"process-util.h\"\n#include \"socket-util.h\"\n#include \"stat-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n#include \"time-util.h\"\n#include \"util.h\"\n\nstatic volatile unsigned cached_columns = 0;\nstatic volatile unsigned cached_lines = 0;\n\nstatic volatile int cached_on_tty = -1;\nstatic volatile int cached_colors_enabled = -1;\nstatic volatile int cached_underline_enabled = -1;\n\nint chvt(int vt) {\n        _cleanup_close_ int fd;\n\n        /* Switch to the specified vt number. If the VT is specified <= 0 switch to the VT the kernel log messages go,\n         * if that's configured. */\n\n        fd = open_terminal(\"/dev/tty0\", O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return -errno;\n\n        if (vt <= 0) {\n                int tiocl[2] = {\n                        TIOCL_GETKMSGREDIRECT,\n                        0\n                };\n\n                if (ioctl(fd, TIOCLINUX, tiocl) < 0)\n                        return -errno;\n\n                vt = tiocl[0] <= 0 ? 1 : tiocl[0];\n        }\n\n        if (ioctl(fd, VT_ACTIVATE, vt) < 0)\n                return -errno;\n\n        return 0;\n}\n\nint read_one_char(FILE *f, char *ret, usec_t t, bool *need_nl) {\n        _cleanup_free_ char *line = NULL;\n        struct termios old_termios;\n        int r;\n\n        assert(f);\n        assert(ret);\n\n        /* If this is a terminal, then switch canonical mode off, so that we can read a single character */\n        if (tcgetattr(fileno(f), &old_termios) >= 0) {\n                struct termios new_termios = old_termios;\n\n                new_termios.c_lflag &= ~ICANON;\n                new_termios.c_cc[VMIN] = 1;\n                new_termios.c_cc[VTIME] = 0;\n\n                if (tcsetattr(fileno(f), TCSADRAIN, &new_termios) >= 0) {\n                        char c;\n\n                        if (t != USEC_INFINITY) {\n                                if (fd_wait_for_event(fileno(f), POLLIN, t) <= 0) {\n                                        (void) tcsetattr(fileno(f), TCSADRAIN, &old_termios);\n                                        return -ETIMEDOUT;\n                                }\n                        }\n\n                        r = safe_fgetc(f, &c);\n                        (void) tcsetattr(fileno(f), TCSADRAIN, &old_termios);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                return -EIO;\n\n                        if (need_nl)\n                                *need_nl = c != '\\n';\n\n                        *ret = c;\n                        return 0;\n                }\n        }\n\n        if (t != USEC_INFINITY) {\n                if (fd_wait_for_event(fileno(f), POLLIN, t) <= 0)\n                        return -ETIMEDOUT;\n        }\n\n        /* If this is not a terminal, then read a full line instead */\n\n        r = read_line(f, 16, &line); /* longer than necessary, to eat up UTF-8 chars/vt100 key sequences */\n        if (r < 0)\n                return r;\n        if (r == 0)\n                return -EIO;\n\n        if (strlen(line) != 1)\n                return -EBADMSG;\n\n        if (need_nl)\n                *need_nl = false;\n\n        *ret = line[0];\n        return 0;\n}\n\n#define DEFAULT_ASK_REFRESH_USEC (2*USEC_PER_SEC)\n\nint ask_char(char *ret, const char *replies, const char *fmt, ...) {\n        int r;\n\n        assert(ret);\n        assert(replies);\n        assert(fmt);\n\n        for (;;) {\n                va_list ap;\n                char c;\n                bool need_nl = true;\n\n                if (colors_enabled())\n                        fputs(ANSI_HIGHLIGHT, stdout);\n\n                putchar('\\r');\n\n                va_start(ap, fmt);\n                vprintf(fmt, ap);\n                va_end(ap);\n\n                if (colors_enabled())\n                        fputs(ANSI_NORMAL, stdout);\n\n                fflush(stdout);\n\n                r = read_one_char(stdin, &c, DEFAULT_ASK_REFRESH_USEC, &need_nl);\n                if (r < 0) {\n\n                        if (r == -ETIMEDOUT)\n                                continue;\n\n                        if (r == -EBADMSG) {\n                                puts(\"Bad input, please try again.\");\n                                continue;\n                        }\n\n                        putchar('\\n');\n                        return r;\n                }\n\n                if (need_nl)\n                        putchar('\\n');\n\n                if (strchr(replies, c)) {\n                        *ret = c;\n                        return 0;\n                }\n\n                puts(\"Read unexpected character, please try again.\");\n        }\n}\n\nint ask_string(char **ret, const char *text, ...) {\n        int r;\n\n        assert(ret);\n        assert(text);\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL;\n                va_list ap;\n\n                if (colors_enabled())\n                        fputs(ANSI_HIGHLIGHT, stdout);\n\n                va_start(ap, text);\n                vprintf(text, ap);\n                va_end(ap);\n\n                if (colors_enabled())\n                        fputs(ANSI_NORMAL, stdout);\n\n                fflush(stdout);\n\n                r = read_line(stdin, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        return -EIO;\n\n                if (!isempty(line)) {\n                        *ret = TAKE_PTR(line);\n                        return 0;\n                }\n        }\n}\n\nint reset_terminal_fd(int fd, bool switch_to_text) {\n        struct termios termios;\n        int r = 0;\n\n        /* Set terminal to some sane defaults */\n\n        assert(fd >= 0);\n\n        /* We leave locked terminal attributes untouched, so that\n         * Plymouth may set whatever it wants to set, and we don't\n         * interfere with that. */\n\n        /* Disable exclusive mode, just in case */\n        (void) ioctl(fd, TIOCNXCL);\n\n        /* Switch to text mode */\n        if (switch_to_text)\n                (void) ioctl(fd, KDSETMODE, KD_TEXT);\n\n        /* Set default keyboard mode */\n        (void) vt_reset_keyboard(fd);\n\n        if (tcgetattr(fd, &termios) < 0) {\n                r = -errno;\n                goto finish;\n        }\n\n        /* We only reset the stuff that matters to the software. How\n         * hardware is set up we don't touch assuming that somebody\n         * else will do that for us */\n\n        termios.c_iflag &= ~(IGNBRK | BRKINT | ISTRIP | INLCR | IGNCR | IUCLC);\n        termios.c_iflag |= ICRNL | IMAXBEL | IUTF8;\n        termios.c_oflag |= ONLCR;\n        termios.c_cflag |= CREAD;\n        termios.c_lflag = ISIG | ICANON | IEXTEN | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOPRT | ECHOKE;\n\n        termios.c_cc[VINTR]    =   03;  /* ^C */\n        termios.c_cc[VQUIT]    =  034;  /* ^\\ */\n        termios.c_cc[VERASE]   = 0177;\n        termios.c_cc[VKILL]    =  025;  /* ^X */\n        termios.c_cc[VEOF]     =   04;  /* ^D */\n        termios.c_cc[VSTART]   =  021;  /* ^Q */\n        termios.c_cc[VSTOP]    =  023;  /* ^S */\n        termios.c_cc[VSUSP]    =  032;  /* ^Z */\n        termios.c_cc[VLNEXT]   =  026;  /* ^V */\n        termios.c_cc[VWERASE]  =  027;  /* ^W */\n        termios.c_cc[VREPRINT] =  022;  /* ^R */\n        termios.c_cc[VEOL]     =    0;\n        termios.c_cc[VEOL2]    =    0;\n\n        termios.c_cc[VTIME]  = 0;\n        termios.c_cc[VMIN]   = 1;\n\n        if (tcsetattr(fd, TCSANOW, &termios) < 0)\n                r = -errno;\n\nfinish:\n        /* Just in case, flush all crap out */\n        (void) tcflush(fd, TCIOFLUSH);\n\n        return r;\n}\n\nint reset_terminal(const char *name) {\n        _cleanup_close_ int fd = -1;\n\n        /* We open the terminal with O_NONBLOCK here, to ensure we\n         * don't block on carrier if this is a terminal with carrier\n         * configured. */\n\n        fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return fd;\n\n        return reset_terminal_fd(fd, true);\n}\n\nint open_terminal(const char *name, int mode) {\n        unsigned c = 0;\n        int fd;\n\n        /*\n         * If a TTY is in the process of being closed opening it might\n         * cause EIO. This is horribly awful, but unlikely to be\n         * changed in the kernel. Hence we work around this problem by\n         * retrying a couple of times.\n         *\n         * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/554172/comments/245\n         */\n\n        if (mode & O_CREAT)\n                return -EINVAL;\n\n        for (;;) {\n                fd = open(name, mode, 0);\n                if (fd >= 0)\n                        break;\n\n                if (errno != EIO)\n                        return -errno;\n\n                /* Max 1s in total */\n                if (c >= 20)\n                        return -errno;\n\n                usleep(50 * USEC_PER_MSEC);\n                c++;\n        }\n\n        if (isatty(fd) <= 0) {\n                safe_close(fd);\n                return -ENOTTY;\n        }\n\n        return fd;\n}\n\nint acquire_terminal(\n                const char *name,\n                AcquireTerminalFlags flags,\n                usec_t timeout) {\n\n        _cleanup_close_ int notify = -1, fd = -1;\n        usec_t ts = USEC_INFINITY;\n        int r, wd = -1;\n\n        assert(name);\n        assert(IN_SET(flags & ~ACQUIRE_TERMINAL_PERMISSIVE, ACQUIRE_TERMINAL_TRY, ACQUIRE_TERMINAL_FORCE, ACQUIRE_TERMINAL_WAIT));\n\n        /* We use inotify to be notified when the tty is closed. We create the watch before checking if we can actually\n         * acquire it, so that we don't lose any event.\n         *\n         * Note: strictly speaking this actually watches for the device being closed, it does *not* really watch\n         * whether a tty loses its controlling process. However, unless some rogue process uses TIOCNOTTY on /dev/tty\n         * *after* closing its tty otherwise this will not become a problem. As long as the administrator makes sure to\n         * not configure any service on the same tty as an untrusted user this should not be a problem. (Which they\n         * probably should not do anyway.) */\n\n        if ((flags & ~ACQUIRE_TERMINAL_PERMISSIVE) == ACQUIRE_TERMINAL_WAIT) {\n                notify = inotify_init1(IN_CLOEXEC | (timeout != USEC_INFINITY ? IN_NONBLOCK : 0));\n                if (notify < 0)\n                        return -errno;\n\n                wd = inotify_add_watch(notify, name, IN_CLOSE);\n                if (wd < 0)\n                        return -errno;\n\n                if (timeout != USEC_INFINITY)\n                        ts = now(CLOCK_MONOTONIC);\n        }\n\n        for (;;) {\n                struct sigaction sa_old, sa_new = {\n                        .sa_handler = SIG_IGN,\n                        .sa_flags = SA_RESTART,\n                };\n\n                if (notify >= 0) {\n                        r = flush_fd(notify);\n                        if (r < 0)\n                                return r;\n                }\n\n                /* We pass here O_NOCTTY only so that we can check the return value TIOCSCTTY and have a reliable way\n                 * to figure out if we successfully became the controlling process of the tty */\n                fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC);\n                if (fd < 0)\n                        return fd;\n\n                /* Temporarily ignore SIGHUP, so that we don't get SIGHUP'ed if we already own the tty. */\n                assert_se(sigaction(SIGHUP, &sa_new, &sa_old) == 0);\n\n                /* First, try to get the tty */\n                r = ioctl(fd, TIOCSCTTY,\n                          (flags & ~ACQUIRE_TERMINAL_PERMISSIVE) == ACQUIRE_TERMINAL_FORCE) < 0 ? -errno : 0;\n\n                /* Reset signal handler to old value */\n                assert_se(sigaction(SIGHUP, &sa_old, NULL) == 0);\n\n                /* Success? Exit the loop now! */\n                if (r >= 0)\n                        break;\n\n                /* Any failure besides -EPERM? Fail, regardless of the mode. */\n                if (r != -EPERM)\n                        return r;\n\n                if (flags & ACQUIRE_TERMINAL_PERMISSIVE) /* If we are in permissive mode, then EPERM is fine, turn this\n                                                          * into a success. Note that EPERM is also returned if we\n                                                          * already are the owner of the TTY. */\n                        break;\n\n                if (flags != ACQUIRE_TERMINAL_WAIT) /* If we are in TRY or FORCE mode, then propagate EPERM as EPERM */\n                        return r;\n\n                assert(notify >= 0);\n                assert(wd >= 0);\n\n                for (;;) {\n                        union inotify_event_buffer buffer;\n                        struct inotify_event *e;\n                        ssize_t l;\n\n                        if (timeout != USEC_INFINITY) {\n                                usec_t n;\n\n                                assert(ts != USEC_INFINITY);\n\n                                n = now(CLOCK_MONOTONIC);\n                                if (ts + timeout < n)\n                                        return -ETIMEDOUT;\n\n                                r = fd_wait_for_event(notify, POLLIN, ts + timeout - n);\n                                if (r < 0)\n                                        return r;\n                                if (r == 0)\n                                        return -ETIMEDOUT;\n                        }\n\n                        l = read(notify, &buffer, sizeof(buffer));\n                        if (l < 0) {\n                                if (IN_SET(errno, EINTR, EAGAIN))\n                                        continue;\n\n                                return -errno;\n                        }\n\n                        FOREACH_INOTIFY_EVENT(e, buffer, l) {\n                                if (e->mask & IN_Q_OVERFLOW) /* If we hit an inotify queue overflow, simply check if the terminal is up for grabs now. */\n                                        break;\n\n                                if (e->wd != wd || !(e->mask & IN_CLOSE)) /* Safety checks */\n                                        return -EIO;\n                        }\n\n                        break;\n                }\n\n                /* We close the tty fd here since if the old session ended our handle will be dead. It's important that\n                 * we do this after sleeping, so that we don't enter an endless loop. */\n                fd = safe_close(fd);\n        }\n\n        return TAKE_FD(fd);\n}\n\nint release_terminal(void) {\n        static const struct sigaction sa_new = {\n                .sa_handler = SIG_IGN,\n                .sa_flags = SA_RESTART,\n        };\n\n        _cleanup_close_ int fd = -1;\n        struct sigaction sa_old;\n        int r;\n\n        fd = open(\"/dev/tty\", O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return -errno;\n\n        /* Temporarily ignore SIGHUP, so that we don't get SIGHUP'ed\n         * by our own TIOCNOTTY */\n        assert_se(sigaction(SIGHUP, &sa_new, &sa_old) == 0);\n\n        r = ioctl(fd, TIOCNOTTY) < 0 ? -errno : 0;\n\n        assert_se(sigaction(SIGHUP, &sa_old, NULL) == 0);\n\n        return r;\n}\n\nint terminal_vhangup_fd(int fd) {\n        assert(fd >= 0);\n\n        if (ioctl(fd, TIOCVHANGUP) < 0)\n                return -errno;\n\n        return 0;\n}\n\nint terminal_vhangup(const char *name) {\n        _cleanup_close_ int fd;\n\n        fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return fd;\n\n        return terminal_vhangup_fd(fd);\n}\n\nint vt_disallocate(const char *name) {\n        _cleanup_close_ int fd = -1;\n        const char *e, *n;\n        unsigned u;\n        int r;\n\n        /* Deallocate the VT if possible. If not possible\n         * (i.e. because it is the active one), at least clear it\n         * entirely (including the scrollback buffer) */\n\n        e = path_startswith(name, \"/dev/\");\n        if (!e)\n                return -EINVAL;\n\n        if (!tty_is_vc(name)) {\n                /* So this is not a VT. I guess we cannot deallocate\n                 * it then. But let's at least clear the screen */\n\n                fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC);\n                if (fd < 0)\n                        return fd;\n\n                loop_write(fd,\n                           \"\\033[r\"    /* clear scrolling region */\n                           \"\\033[H\"    /* move home */\n                           \"\\033[2J\",  /* clear screen */\n                           10, false);\n                return 0;\n        }\n\n        n = startswith(e, \"tty\");\n        if (!n)\n                return -EINVAL;\n\n        r = safe_atou(n, &u);\n        if (r < 0)\n                return r;\n\n        if (u <= 0)\n                return -EINVAL;\n\n        /* Try to deallocate */\n        fd = open_terminal(\"/dev/tty0\", O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return fd;\n\n        r = ioctl(fd, VT_DISALLOCATE, u);\n        fd = safe_close(fd);\n\n        if (r >= 0)\n                return 0;\n\n        if (errno != EBUSY)\n                return -errno;\n\n        /* Couldn't deallocate, so let's clear it fully with\n         * scrollback */\n        fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC);\n        if (fd < 0)\n                return fd;\n\n        loop_write(fd,\n                   \"\\033[r\"   /* clear scrolling region */\n                   \"\\033[H\"   /* move home */\n                   \"\\033[3J\", /* clear screen including scrollback, requires Linux 2.6.40 */\n                   10, false);\n        return 0;\n}\n\nint make_console_stdio(void) {\n        int fd, r;\n\n        /* Make /dev/console the controlling terminal and stdin/stdout/stderr */\n\n        fd = acquire_terminal(\"/dev/console\", ACQUIRE_TERMINAL_FORCE|ACQUIRE_TERMINAL_PERMISSIVE, USEC_INFINITY);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to acquire terminal: %m\");\n\n        r = reset_terminal_fd(fd, true);\n        if (r < 0)\n                log_warning_errno(r, \"Failed to reset terminal, ignoring: %m\");\n\n        r = rearrange_stdio(fd, fd, fd); /* This invalidates 'fd' both on success and on failure. */\n        if (r < 0)\n                return log_error_errno(r, \"Failed to make terminal stdin/stdout/stderr: %m\");\n\n        reset_terminal_feature_caches();\n\n        return 0;\n}\n\nbool tty_is_vc(const char *tty) {\n        assert(tty);\n\n        return vtnr_from_tty(tty) >= 0;\n}\n\nbool tty_is_console(const char *tty) {\n        assert(tty);\n\n        return streq(skip_dev_prefix(tty), \"console\");\n}\n\nint vtnr_from_tty(const char *tty) {\n        int i, r;\n\n        assert(tty);\n\n        tty = skip_dev_prefix(tty);\n\n        if (!startswith(tty, \"tty\") )\n                return -EINVAL;\n\n        if (tty[3] < '0' || tty[3] > '9')\n                return -EINVAL;\n\n        r = safe_atoi(tty+3, &i);\n        if (r < 0)\n                return r;\n\n        if (i < 0 || i > 63)\n                return -EINVAL;\n\n        return i;\n}\n\n int resolve_dev_console(char **ret) {\n        _cleanup_free_ char *active = NULL;\n        char *tty;\n        int r;\n\n        assert(ret);\n\n        /* Resolve where /dev/console is pointing to, if /sys is actually ours (i.e. not read-only-mounted which is a\n         * sign for container setups) */\n\n        if (path_is_read_only_fs(\"/sys\") > 0)\n                return -ENOMEDIUM;\n\n        r = read_one_line_file(\"/sys/class/tty/console/active\", &active);\n        if (r < 0)\n                return r;\n\n        /* If multiple log outputs are configured the last one is what /dev/console points to */\n        tty = strrchr(active, ' ');\n        if (tty)\n                tty++;\n        else\n                tty = active;\n\n        if (streq(tty, \"tty0\")) {\n                active = mfree(active);\n\n                /* Get the active VC (e.g. tty1) */\n                r = read_one_line_file(\"/sys/class/tty/tty0/active\", &active);\n                if (r < 0)\n                        return r;\n\n                tty = active;\n        }\n\n        if (tty == active)\n                *ret = TAKE_PTR(active);\n        else {\n                char *tmp;\n\n                tmp = strdup(tty);\n                if (!tmp)\n                        return -ENOMEM;\n\n                *ret = tmp;\n        }\n\n        return 0;\n}\n\nint get_kernel_consoles(char ***ret) {\n        _cleanup_strv_free_ char **l = NULL;\n        _cleanup_free_ char *line = NULL;\n        const char *p;\n        int r;\n\n        assert(ret);\n\n        /* If /sys is mounted read-only this means we are running in some kind of container environment. In that\n         * case /sys would reflect the host system, not us, hence ignore the data we can read from it. */\n        if (path_is_read_only_fs(\"/sys\") > 0)\n                goto fallback;\n\n        r = read_one_line_file(\"/sys/class/tty/console/active\", &line);\n        if (r < 0)\n                return r;\n\n        p = line;\n        for (;;) {\n                _cleanup_free_ char *tty = NULL;\n                char *path;\n\n                r = extract_first_word(&p, &tty, NULL, 0);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        break;\n\n                if (streq(tty, \"tty0\")) {\n                        tty = mfree(tty);\n                        r = read_one_line_file(\"/sys/class/tty/tty0/active\", &tty);\n                        if (r < 0)\n                                return r;\n                }\n\n                path = strappend(\"/dev/\", tty);\n                if (!path)\n                        return -ENOMEM;\n\n                if (access(path, F_OK) < 0) {\n                        log_debug_errno(errno, \"Console device %s is not accessible, skipping: %m\", path);\n                        free(path);\n                        continue;\n                }\n\n                r = strv_consume(&l, path);\n                if (r < 0)\n                        return r;\n        }\n\n        if (strv_isempty(l)) {\n                log_debug(\"No devices found for system console\");\n                goto fallback;\n        }\n\n        *ret = TAKE_PTR(l);\n\n        return 0;\n\nfallback:\n        r = strv_extend(&l, \"/dev/console\");\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(l);\n\n        return 0;\n}\n\nbool tty_is_vc_resolve(const char *tty) {\n        _cleanup_free_ char *resolved = NULL;\n\n        assert(tty);\n\n        tty = skip_dev_prefix(tty);\n\n        if (streq(tty, \"console\")) {\n                if (resolve_dev_console(&resolved) < 0)\n                        return false;\n\n                tty = resolved;\n        }\n\n        return tty_is_vc(tty);\n}\n\nconst char *default_term_for_tty(const char *tty) {\n        return tty && tty_is_vc_resolve(tty) ? \"linux\" : \"vt220\";\n}\n\nint fd_columns(int fd) {\n        struct winsize ws = {};\n\n        if (ioctl(fd, TIOCGWINSZ, &ws) < 0)\n                return -errno;\n\n        if (ws.ws_col <= 0)\n                return -EIO;\n\n        return ws.ws_col;\n}\n\nunsigned columns(void) {\n        const char *e;\n        int c;\n\n        if (cached_columns > 0)\n                return cached_columns;\n\n        c = 0;\n        e = getenv(\"COLUMNS\");\n        if (e)\n                (void) safe_atoi(e, &c);\n\n        if (c <= 0 || c > USHRT_MAX) {\n                c = fd_columns(STDOUT_FILENO);\n                if (c <= 0)\n                        c = 80;\n        }\n\n        cached_columns = c;\n        return cached_columns;\n}\n\nint fd_lines(int fd) {\n        struct winsize ws = {};\n\n        if (ioctl(fd, TIOCGWINSZ, &ws) < 0)\n                return -errno;\n\n        if (ws.ws_row <= 0)\n                return -EIO;\n\n        return ws.ws_row;\n}\n\nunsigned lines(void) {\n        const char *e;\n        int l;\n\n        if (cached_lines > 0)\n                return cached_lines;\n\n        l = 0;\n        e = getenv(\"LINES\");\n        if (e)\n                (void) safe_atoi(e, &l);\n\n        if (l <= 0 || l > USHRT_MAX) {\n                l = fd_lines(STDOUT_FILENO);\n                if (l <= 0)\n                        l = 24;\n        }\n\n        cached_lines = l;\n        return cached_lines;\n}\n\n/* intended to be used as a SIGWINCH sighandler */\nvoid columns_lines_cache_reset(int signum) {\n        cached_columns = 0;\n        cached_lines = 0;\n}\n\nvoid reset_terminal_feature_caches(void) {\n        cached_columns = 0;\n        cached_lines = 0;\n\n        cached_colors_enabled = -1;\n        cached_underline_enabled = -1;\n        cached_on_tty = -1;\n}\n\nbool on_tty(void) {\n\n        /* We check both stdout and stderr, so that situations where pipes on the shell are used are reliably\n         * recognized, regardless if only the output or the errors are piped to some place. Since on_tty() is generally\n         * used to default to a safer, non-interactive, non-color mode of operation it's probably good to be defensive\n         * here, and check for both. Note that we don't check for STDIN_FILENO, because it should fine to use fancy\n         * terminal functionality when outputting stuff, even if the input is piped to us. */\n\n        if (cached_on_tty < 0)\n                cached_on_tty =\n                        isatty(STDOUT_FILENO) > 0 &&\n                        isatty(STDERR_FILENO) > 0;\n\n        return cached_on_tty;\n}\n\nint getttyname_malloc(int fd, char **ret) {\n        char path[PATH_MAX], *c; /* PATH_MAX is counted *with* the trailing NUL byte */\n        int r;\n\n        assert(fd >= 0);\n        assert(ret);\n\n        r = ttyname_r(fd, path, sizeof path); /* positive error */\n        assert(r >= 0);\n        if (r == ERANGE)\n                return -ENAMETOOLONG;\n        if (r > 0)\n                return -r;\n\n        c = strdup(skip_dev_prefix(path));\n        if (!c)\n                return -ENOMEM;\n\n        *ret = c;\n        return 0;\n}\n\nint getttyname_harder(int fd, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        int r;\n\n        r = getttyname_malloc(fd, &s);\n        if (r < 0)\n                return r;\n\n        if (streq(s, \"tty\"))\n                return get_ctty(0, NULL, ret);\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint get_ctty_devnr(pid_t pid, dev_t *d) {\n        int r;\n        _cleanup_free_ char *line = NULL;\n        const char *p;\n        unsigned long ttynr;\n\n        assert(pid >= 0);\n\n        p = procfs_file_alloca(pid, \"stat\");\n        r = read_one_line_file(p, &line);\n        if (r < 0)\n                return r;\n\n        p = strrchr(line, ')');\n        if (!p)\n                return -EIO;\n\n        p++;\n\n        if (sscanf(p, \" \"\n                   \"%*c \"  /* state */\n                   \"%*d \"  /* ppid */\n                   \"%*d \"  /* pgrp */\n                   \"%*d \"  /* session */\n                   \"%lu \", /* ttynr */\n                   &ttynr) != 1)\n                return -EIO;\n\n        if (major(ttynr) == 0 && minor(ttynr) == 0)\n                return -ENXIO;\n\n        if (d)\n                *d = (dev_t) ttynr;\n\n        return 0;\n}\n\nint get_ctty(pid_t pid, dev_t *ret_devnr, char **ret) {\n        _cleanup_free_ char *fn = NULL, *b = NULL;\n        dev_t devnr;\n        int r;\n\n        r = get_ctty_devnr(pid, &devnr);\n        if (r < 0)\n                return r;\n\n        r = device_path_make_canonical(S_IFCHR, devnr, &fn);\n        if (r < 0) {\n                if (r != -ENOENT) /* No symlink for this in /dev/char/? */\n                        return r;\n\n                if (major(devnr) == 136) {\n                        /* This is an ugly hack: PTY devices are not listed in /dev/char/, as they don't follow the\n                         * Linux device model. This means we have no nice way to match them up against their actual\n                         * device node. Let's hence do the check by the fixed, assigned major number. Normally we try\n                         * to avoid such fixed major/minor matches, but there appears to nother nice way to handle\n                         * this. */\n\n                        if (asprintf(&b, \"pts/%u\", minor(devnr)) < 0)\n                                return -ENOMEM;\n                } else {\n                        /* Probably something similar to the ptys which have no symlink in /dev/char/. Let's return\n                         * something vaguely useful. */\n\n                        r = device_path_make_major_minor(S_IFCHR, devnr, &fn);\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        if (!b) {\n                const char *w;\n\n                w = path_startswith(fn, \"/dev/\");\n                if (w) {\n                        b = strdup(w);\n                        if (!b)\n                                return -ENOMEM;\n                } else\n                        b = TAKE_PTR(fn);\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(b);\n\n        if (ret_devnr)\n                *ret_devnr = devnr;\n\n        return 0;\n}\n\nint ptsname_malloc(int fd, char **ret) {\n        size_t l = 100;\n\n        assert(fd >= 0);\n        assert(ret);\n\n        for (;;) {\n                char *c;\n\n                c = new(char, l);\n                if (!c)\n                        return -ENOMEM;\n\n                if (ptsname_r(fd, c, l) == 0) {\n                        *ret = c;\n                        return 0;\n                }\n                if (errno != ERANGE) {\n                        free(c);\n                        return -errno;\n                }\n\n                free(c);\n\n                if (l > SIZE_MAX / 2)\n                        return -ENOMEM;\n\n                l *= 2;\n        }\n}\n\nint ptsname_namespace(int pty, char **ret) {\n        int no = -1, r;\n\n        /* Like ptsname(), but doesn't assume that the path is\n         * accessible in the local namespace. */\n\n        r = ioctl(pty, TIOCGPTN, &no);\n        if (r < 0)\n                return -errno;\n\n        if (no < 0)\n                return -EIO;\n\n        if (asprintf(ret, \"/dev/pts/%i\", no) < 0)\n                return -ENOMEM;\n\n        return 0;\n}\n\nint openpt_in_namespace(pid_t pid, int flags) {\n        _cleanup_close_ int pidnsfd = -1, mntnsfd = -1, usernsfd = -1, rootfd = -1;\n        _cleanup_close_pair_ int pair[2] = { -1, -1 };\n        pid_t child;\n        int r;\n\n        assert(pid > 0);\n\n        r = namespace_open(pid, &pidnsfd, &mntnsfd, NULL, &usernsfd, &rootfd);\n        if (r < 0)\n                return r;\n\n        if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pair) < 0)\n                return -errno;\n\n        r = namespace_fork(\"(sd-openptns)\", \"(sd-openpt)\", NULL, 0, FORK_RESET_SIGNALS|FORK_DEATHSIG,\n                           pidnsfd, mntnsfd, -1, usernsfd, rootfd, &child);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                int master;\n\n                pair[0] = safe_close(pair[0]);\n\n                master = posix_openpt(flags|O_NOCTTY|O_CLOEXEC);\n                if (master < 0)\n                        _exit(EXIT_FAILURE);\n\n                if (unlockpt(master) < 0)\n                        _exit(EXIT_FAILURE);\n\n                if (send_one_fd(pair[1], master, 0) < 0)\n                        _exit(EXIT_FAILURE);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        pair[1] = safe_close(pair[1]);\n\n        r = wait_for_terminate_and_check(\"(sd-openptns)\", child, 0);\n        if (r < 0)\n                return r;\n        if (r != EXIT_SUCCESS)\n                return -EIO;\n\n        return receive_one_fd(pair[0], 0);\n}\n\nint open_terminal_in_namespace(pid_t pid, const char *name, int mode) {\n        _cleanup_close_ int pidnsfd = -1, mntnsfd = -1, usernsfd = -1, rootfd = -1;\n        _cleanup_close_pair_ int pair[2] = { -1, -1 };\n        pid_t child;\n        int r;\n\n        r = namespace_open(pid, &pidnsfd, &mntnsfd, NULL, &usernsfd, &rootfd);\n        if (r < 0)\n                return r;\n\n        if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pair) < 0)\n                return -errno;\n\n        r = namespace_fork(\"(sd-terminalns)\", \"(sd-terminal)\", NULL, 0, FORK_RESET_SIGNALS|FORK_DEATHSIG,\n                           pidnsfd, mntnsfd, -1, usernsfd, rootfd, &child);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                int master;\n\n                pair[0] = safe_close(pair[0]);\n\n                master = open_terminal(name, mode|O_NOCTTY|O_CLOEXEC);\n                if (master < 0)\n                        _exit(EXIT_FAILURE);\n\n                if (send_one_fd(pair[1], master, 0) < 0)\n                        _exit(EXIT_FAILURE);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        pair[1] = safe_close(pair[1]);\n\n        r = wait_for_terminate_and_check(\"(sd-terminalns)\", child, 0);\n        if (r < 0)\n                return r;\n        if (r != EXIT_SUCCESS)\n                return -EIO;\n\n        return receive_one_fd(pair[0], 0);\n}\n\nstatic bool getenv_terminal_is_dumb(void) {\n        const char *e;\n\n        e = getenv(\"TERM\");\n        if (!e)\n                return true;\n\n        return streq(e, \"dumb\");\n}\n\nbool terminal_is_dumb(void) {\n        if (!on_tty())\n                return true;\n\n        return getenv_terminal_is_dumb();\n}\n\nbool colors_enabled(void) {\n\n        /* Returns true if colors are considered supported on our stdout. For that we check $SYSTEMD_COLORS first\n         * (which is the explicit way to turn colors on/off). If that didn't work we turn colors off unless we are on a\n         * TTY. And if we are on a TTY we turn it off if $TERM is set to \"dumb\". There's one special tweak though: if\n         * we are PID 1 then we do not check whether we are connected to a TTY, because we don't keep /dev/console open\n         * continuously due to fear of SAK, and hence things are a bit weird. */\n\n        if (cached_colors_enabled < 0) {\n                int val;\n\n                val = getenv_bool(\"SYSTEMD_COLORS\");\n                if (val >= 0)\n                        cached_colors_enabled = val;\n                else if (getpid_cached() == 1)\n                        /* PID1 outputs to the console without holding it open all the time */\n                        cached_colors_enabled = !getenv_terminal_is_dumb();\n                else\n                        cached_colors_enabled = !terminal_is_dumb();\n        }\n\n        return cached_colors_enabled;\n}\n\nbool dev_console_colors_enabled(void) {\n        _cleanup_free_ char *s = NULL;\n        int b;\n\n        /* Returns true if we assume that color is supported on /dev/console.\n         *\n         * For that we first check if we explicitly got told to use colors or not, by checking $SYSTEMD_COLORS. If that\n         * isn't set we check whether PID 1 has $TERM set, and if not, whether TERM is set on the kernel command\n         * line. If we find $TERM set we assume color if it's not set to \"dumb\", similarly to how regular\n         * colors_enabled() operates. */\n\n        b = getenv_bool(\"SYSTEMD_COLORS\");\n        if (b >= 0)\n                return b;\n\n        if (getenv_for_pid(1, \"TERM\", &s) <= 0)\n                (void) proc_cmdline_get_key(\"TERM\", 0, &s);\n\n        return !streq_ptr(s, \"dumb\");\n}\n\nbool underline_enabled(void) {\n\n        if (cached_underline_enabled < 0) {\n\n                /* The Linux console doesn't support underlining, turn it off, but only there. */\n\n                if (colors_enabled())\n                        cached_underline_enabled = !streq_ptr(getenv(\"TERM\"), \"linux\");\n                else\n                        cached_underline_enabled = false;\n        }\n\n        return cached_underline_enabled;\n}\n\nint vt_default_utf8(void) {\n        _cleanup_free_ char *b = NULL;\n        int r;\n\n        /* Read the default VT UTF8 setting from the kernel */\n\n        r = read_one_line_file(\"/sys/module/vt/parameters/default_utf8\", &b);\n        if (r < 0)\n                return r;\n\n        return parse_boolean(b);\n}\n\nint vt_reset_keyboard(int fd) {\n        int kb;\n\n        /* If we can't read the default, then default to unicode. It's 2017 after all. */\n        kb = vt_default_utf8() != 0 ? K_UNICODE : K_XLATE;\n\n        if (ioctl(fd, KDSKBMODE, kb) < 0)\n                return -errno;\n\n        return 0;\n}\n\nint vt_restore(int fd) {\n        static const struct vt_mode mode = {\n                .mode = VT_AUTO,\n        };\n        int r, q = 0;\n\n        r = ioctl(fd, KDSETMODE, KD_TEXT);\n        if (r < 0)\n                q = log_debug_errno(errno, \"Failed to set VT in text mode, ignoring: %m\");\n\n        r = vt_reset_keyboard(fd);\n        if (r < 0) {\n                log_debug_errno(r, \"Failed to reset keyboard mode, ignoring: %m\");\n                if (q >= 0)\n                        q = r;\n        }\n\n        r = ioctl(fd, VT_SETMODE, &mode);\n        if (r < 0) {\n                log_debug_errno(errno, \"Failed to set VT_AUTO mode, ignoring: %m\");\n                if (q >= 0)\n                        q = -errno;\n        }\n\n        r = fchown(fd, 0, (gid_t) -1);\n        if (r < 0) {\n                log_debug_errno(errno, \"Failed to chown VT, ignoring: %m\");\n                if (q >= 0)\n                        q = -errno;\n        }\n\n        return q;\n}\n\nint vt_release(int fd, bool restore) {\n        assert(fd >= 0);\n\n        /* This function releases the VT by acknowledging the VT-switch signal\n         * sent by the kernel and optionally reset the VT in text and auto\n         * VT-switching modes. */\n\n        if (ioctl(fd, VT_RELDISP, 1) < 0)\n                return -errno;\n\n        if (restore)\n                return vt_restore(fd);\n\n        return 0;\n}\n\nvoid get_log_colors(int priority, const char **on, const char **off, const char **highlight) {\n        /* Note that this will initialize output variables only when there's something to output.\n         * The caller must pre-initalize to \"\" or NULL as appropriate. */\n\n        if (priority <= LOG_ERR) {\n                if (on)\n                        *on = ANSI_HIGHLIGHT_RED;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT;\n\n        } else if (priority <= LOG_WARNING) {\n                if (on)\n                        *on = ANSI_HIGHLIGHT_YELLOW;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT;\n\n        } else if (priority <= LOG_NOTICE) {\n                if (on)\n                        *on = ANSI_HIGHLIGHT;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT_RED;\n\n        } else if (priority >= LOG_DEBUG) {\n                if (on)\n                        *on = ANSI_GREY;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT_RED;\n        }\n}\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n#pragma once\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <sys/types.h>\n\n#include \"macro.h\"\n#include \"time-util.h\"\n\n/* Regular colors */\n#define ANSI_BLACK   \"\\x1B[0;30m\"\n#define ANSI_RED     \"\\x1B[0;31m\"\n#define ANSI_GREEN   \"\\x1B[0;32m\"\n#define ANSI_YELLOW  \"\\x1B[0;33m\"\n#define ANSI_BLUE    \"\\x1B[0;34m\"\n#define ANSI_MAGENTA \"\\x1B[0;35m\"\n#define ANSI_CYAN    \"\\x1B[0;36m\"\n#define ANSI_WHITE   \"\\x1B[0;37m\"\n#define ANSI_GREY    \"\\x1B[0;2;37m\"\n\n/* Bold/highlighted */\n#define ANSI_HIGHLIGHT_BLACK   \"\\x1B[0;1;30m\"\n#define ANSI_HIGHLIGHT_RED     \"\\x1B[0;1;31m\"\n#define ANSI_HIGHLIGHT_GREEN   \"\\x1B[0;1;32m\"\n#define ANSI_HIGHLIGHT_YELLOW  \"\\x1B[0;1;33m\"\n#define ANSI_HIGHLIGHT_BLUE    \"\\x1B[0;1;34m\"\n#define ANSI_HIGHLIGHT_MAGENTA \"\\x1B[0;1;35m\"\n#define ANSI_HIGHLIGHT_CYAN    \"\\x1B[0;1;36m\"\n#define ANSI_HIGHLIGHT_WHITE   \"\\x1B[0;1;37m\"\n\n/* Underlined */\n#define ANSI_HIGHLIGHT_BLACK_UNDERLINE   \"\\x1B[0;1;4;30m\"\n#define ANSI_HIGHLIGHT_RED_UNDERLINE     \"\\x1B[0;1;4;31m\"\n#define ANSI_HIGHLIGHT_GREEN_UNDERLINE   \"\\x1B[0;1;4;32m\"\n#define ANSI_HIGHLIGHT_YELLOW_UNDERLINE  \"\\x1B[0;1;4;33m\"\n#define ANSI_HIGHLIGHT_BLUE_UNDERLINE    \"\\x1B[0;1;4;34m\"\n#define ANSI_HIGHLIGHT_MAGENTA_UNDERLINE \"\\x1B[0;1;4;35m\"\n#define ANSI_HIGHLIGHT_CYAN_UNDERLINE    \"\\x1B[0;1;4;36m\"\n#define ANSI_HIGHLIGHT_WHITE_UNDERLINE   \"\\x1B[0;1;4;37m\"\n\n/* Other ANSI codes */\n#define ANSI_UNDERLINE \"\\x1B[0;4m\"\n#define ANSI_HIGHLIGHT \"\\x1B[0;1;39m\"\n#define ANSI_HIGHLIGHT_UNDERLINE \"\\x1B[0;1;4m\"\n\n/* Reset/clear ANSI styles */\n#define ANSI_NORMAL \"\\x1B[0m\"\n\n/* Erase characters until the end of the line */\n#define ANSI_ERASE_TO_END_OF_LINE \"\\x1B[K\"\n\n/* Move cursor up one line */\n#define ANSI_REVERSE_LINEFEED \"\\x1BM\"\n\n/* Set cursor to top left corner and clear screen */\n#define ANSI_HOME_CLEAR \"\\x1B[H\\x1B[2J\"\n\nint reset_terminal_fd(int fd, bool switch_to_text);\nint reset_terminal(const char *name);\n\nint open_terminal(const char *name, int mode);\n\n/* Flags for tweaking the way we become the controlling process of a terminal. */\ntypedef enum AcquireTerminalFlags {\n        /* Try to become the controlling process of the TTY. If we can't return -EPERM. */\n        ACQUIRE_TERMINAL_TRY        = 0,\n\n        /* Tell the kernel to forcibly make us the controlling process of the TTY. Returns -EPERM if the kernel doesn't allow that. */\n        ACQUIRE_TERMINAL_FORCE      = 1,\n\n        /* If we can't become the controlling process of the TTY right-away, then wait until we can. */\n        ACQUIRE_TERMINAL_WAIT       = 2,\n\n        /* Pick one of the above, and then OR this flag in, in order to request permissive behaviour, if we can't become controlling process then don't mind */\n        ACQUIRE_TERMINAL_PERMISSIVE = 1 << 2,\n} AcquireTerminalFlags;\n\nint acquire_terminal(const char *name, AcquireTerminalFlags flags, usec_t timeout);\nint release_terminal(void);\n\nint terminal_vhangup_fd(int fd);\nint terminal_vhangup(const char *name);\n\nint chvt(int vt);\n\nint read_one_char(FILE *f, char *ret, usec_t timeout, bool *need_nl);\nint ask_char(char *ret, const char *replies, const char *text, ...) _printf_(3, 4);\nint ask_string(char **ret, const char *text, ...) _printf_(2, 3);\n\nint vt_disallocate(const char *name);\n\nint resolve_dev_console(char **ret);\nint get_kernel_consoles(char ***ret);\nbool tty_is_vc(const char *tty);\nbool tty_is_vc_resolve(const char *tty);\nbool tty_is_console(const char *tty) _pure_;\nint vtnr_from_tty(const char *tty);\nconst char *default_term_for_tty(const char *tty);\n\nint make_console_stdio(void);\n\nint fd_columns(int fd);\nunsigned columns(void);\nint fd_lines(int fd);\nunsigned lines(void);\n\nvoid columns_lines_cache_reset(int _unused_ signum);\nvoid reset_terminal_feature_caches(void);\n\nbool on_tty(void);\nbool terminal_is_dumb(void);\nbool colors_enabled(void);\nbool underline_enabled(void);\nbool dev_console_colors_enabled(void);\n\n#define DEFINE_ANSI_FUNC(name, NAME)                            \\\n        static inline const char *ansi_##name(void) {           \\\n                return colors_enabled() ? ANSI_##NAME : \"\";     \\\n        }\n\n#define DEFINE_ANSI_FUNC_UNDERLINE(name, NAME, REPLACEMENT)             \\\n        static inline const char *ansi_##name(void) {                   \\\n                return underline_enabled() ? ANSI_##NAME :              \\\n                        colors_enabled() ? ANSI_##REPLACEMENT : \"\";     \\\n        }\n\nDEFINE_ANSI_FUNC(highlight,                  HIGHLIGHT);\nDEFINE_ANSI_FUNC(highlight_red,              HIGHLIGHT_RED);\nDEFINE_ANSI_FUNC(highlight_green,            HIGHLIGHT_GREEN);\nDEFINE_ANSI_FUNC(highlight_yellow,           HIGHLIGHT_YELLOW);\nDEFINE_ANSI_FUNC(highlight_blue,             HIGHLIGHT_BLUE);\nDEFINE_ANSI_FUNC(highlight_magenta,          HIGHLIGHT_MAGENTA);\nDEFINE_ANSI_FUNC(normal,                     NORMAL);\nDEFINE_ANSI_FUNC(grey,                       GREY);\n\nDEFINE_ANSI_FUNC_UNDERLINE(underline,                  UNDERLINE, NORMAL);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_underline,        HIGHLIGHT_UNDERLINE, HIGHLIGHT);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_red_underline,    HIGHLIGHT_RED_UNDERLINE, HIGHLIGHT_RED);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_green_underline,  HIGHLIGHT_GREEN_UNDERLINE, HIGHLIGHT_GREEN);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_yellow_underline, HIGHLIGHT_YELLOW_UNDERLINE, HIGHLIGHT_YELLOW);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_blue_underline,   HIGHLIGHT_BLUE_UNDERLINE, HIGHLIGHT_BLUE);\n\nint get_ctty_devnr(pid_t pid, dev_t *d);\nint get_ctty(pid_t, dev_t *_devnr, char **r);\n\nint getttyname_malloc(int fd, char **r);\nint getttyname_harder(int fd, char **r);\n\nint ptsname_malloc(int fd, char **ret);\nint ptsname_namespace(int pty, char **ret);\n\nint openpt_in_namespace(pid_t pid, int flags);\nint open_terminal_in_namespace(pid_t pid, const char *name, int mode);\n\nint vt_default_utf8(void);\nint vt_reset_keyboard(int fd);\nint vt_restore(int fd);\nint vt_release(int fd, bool restore_vt);\n\nvoid get_log_colors(int priority, const char **on, const char **off, const char **highlight);\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n/***\n  Copyright \u00a9 2016 Michal Soltys <soltys@ziu.info>\n***/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/kd.h>\n#include <linux/tiocl.h>\n#include <linux/vt.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sysexits.h>\n#include <termios.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"env-file.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"io-util.h\"\n#include \"locale-util.h\"\n#include \"log.h\"\n#include \"proc-cmdline.h\"\n#include \"process-util.h\"\n#include \"signal-util.h\"\n#include \"stdio-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n#include \"util.h\"\n#include \"virt.h\"\n\nstatic int verify_vc_device(int fd) {\n        unsigned char data[] = {\n                TIOCL_GETFGCONSOLE,\n        };\n\n        int r;\n\n        r = ioctl(fd, TIOCLINUX, data);\n        if (r < 0)\n                return -errno;\n\n        return r;\n}\n\nstatic int verify_vc_allocation(unsigned idx) {\n        char vcname[sizeof(\"/dev/vcs\") + DECIMAL_STR_MAX(unsigned) - 2];\n\n        xsprintf(vcname, \"/dev/vcs%u\", idx);\n\n        if (access(vcname, F_OK) < 0)\n                return -errno;\n\n        return 0;\n}\n\nstatic int verify_vc_allocation_byfd(int fd) {\n        struct vt_stat vcs = {};\n\n        if (ioctl(fd, VT_GETSTATE, &vcs) < 0)\n                return -errno;\n\n        return verify_vc_allocation(vcs.v_active);\n}\n\nstatic int verify_vc_kbmode(int fd) {\n        int curr_mode;\n\n        /*\n         * Make sure we only adjust consoles in K_XLATE or K_UNICODE mode.\n         * Otherwise we would (likely) interfere with X11's processing of the\n         * key events.\n         *\n         * http://lists.freedesktop.org/archives/systemd-devel/2013-February/008573.html\n         */\n\n        if (ioctl(fd, KDGKBMODE, &curr_mode) < 0)\n                return -errno;\n\n        return IN_SET(curr_mode, K_XLATE, K_UNICODE) ? 0 : -EBUSY;\n}\n\nstatic int toggle_utf8(const char *name, int fd, bool utf8) {\n        int r;\n        struct termios tc = {};\n\n        assert(name);\n\n        r = ioctl(fd, KDSKBMODE, utf8 ? K_UNICODE : K_XLATE);\n        if (r < 0)\n                return log_warning_errno(errno, \"Failed to %s UTF-8 kbdmode on %s: %m\", enable_disable(utf8), name);\n\n        r = loop_write(fd, utf8 ? \"\\033%G\" : \"\\033%@\", 3, false);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to %s UTF-8 term processing on %s: %m\", enable_disable(utf8), name);\n\n        r = tcgetattr(fd, &tc);\n        if (r >= 0) {\n                SET_FLAG(tc.c_iflag, IUTF8, utf8);\n                r = tcsetattr(fd, TCSANOW, &tc);\n        }\n        if (r < 0)\n                return log_warning_errno(errno, \"Failed to %s iutf8 flag on %s: %m\", enable_disable(utf8), name);\n\n        log_debug(\"UTF-8 kbdmode %sd on %s\", enable_disable(utf8), name);\n        return 0;\n}\n\nstatic int toggle_utf8_sysfs(bool utf8) {\n        int r;\n\n        r = write_string_file(\"/sys/module/vt/parameters/default_utf8\", one_zero(utf8), WRITE_STRING_FILE_DISABLE_BUFFER);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to %s sysfs UTF-8 flag: %m\", enable_disable(utf8));\n\n        log_debug(\"Sysfs UTF-8 flag %sd\", enable_disable(utf8));\n        return 0;\n}\n\nstatic int keyboard_load_and_wait(const char *vc, const char *map, const char *map_toggle, bool utf8) {\n        const char *args[8];\n        unsigned i = 0;\n        pid_t pid;\n        int r;\n\n        /* An empty map means kernel map */\n        if (isempty(map))\n                return 0;\n\n        args[i++] = KBD_LOADKEYS;\n        args[i++] = \"-q\";\n        args[i++] = \"-C\";\n        args[i++] = vc;\n        if (utf8)\n                args[i++] = \"-u\";\n        args[i++] = map;\n        if (map_toggle)\n                args[i++] = map_toggle;\n        args[i++] = NULL;\n\n        if (DEBUG_LOGGING) {\n                _cleanup_free_ char *cmd;\n\n                cmd = strv_join((char**) args, \" \");\n                log_debug(\"Executing \\\"%s\\\"...\", strnull(cmd));\n        }\n\n        r = safe_fork(\"(loadkeys)\", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_RLIMIT_NOFILE_SAFE|FORK_LOG, &pid);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                execv(args[0], (char **) args);\n                _exit(EXIT_FAILURE);\n        }\n\n        return wait_for_terminate_and_check(KBD_LOADKEYS, pid, WAIT_LOG);\n}\n\nstatic int font_load_and_wait(const char *vc, const char *font, const char *map, const char *unimap) {\n        const char *args[9];\n        unsigned i = 0;\n        pid_t pid;\n        int r;\n\n        /* Any part can be set independently */\n        if (isempty(font) && isempty(map) && isempty(unimap))\n                return 0;\n\n        args[i++] = KBD_SETFONT;\n        args[i++] = \"-C\";\n        args[i++] = vc;\n        if (!isempty(map)) {\n                args[i++] = \"-m\";\n                args[i++] = map;\n        }\n        if (!isempty(unimap)) {\n                args[i++] = \"-u\";\n                args[i++] = unimap;\n        }\n        if (!isempty(font))\n                args[i++] = font;\n        args[i++] = NULL;\n\n        if (DEBUG_LOGGING) {\n                _cleanup_free_ char *cmd;\n\n                cmd = strv_join((char**) args, \" \");\n                log_debug(\"Executing \\\"%s\\\"...\", strnull(cmd));\n        }\n\n        r = safe_fork(\"(setfont)\", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_RLIMIT_NOFILE_SAFE|FORK_LOG, &pid);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                execv(args[0], (char **) args);\n                _exit(EXIT_FAILURE);\n        }\n\n        return wait_for_terminate_and_check(KBD_SETFONT, pid, WAIT_LOG);\n}\n\n/*\n * A newly allocated VT uses the font from the source VT. Here\n * we update all possibly already allocated VTs with the configured\n * font. It also allows to restart systemd-vconsole-setup.service,\n * to apply a new font to all VTs.\n *\n * We also setup per-console utf8 related stuff: kbdmode, term\n * processing, stty iutf8.\n */\nstatic void setup_remaining_vcs(int src_fd, unsigned src_idx, bool utf8) {\n        struct console_font_op cfo = {\n                .op = KD_FONT_OP_GET,\n                .width = UINT_MAX, .height = UINT_MAX,\n                .charcount = UINT_MAX,\n        };\n        struct unimapinit adv = {};\n        struct unimapdesc unimapd;\n        _cleanup_free_ struct unipair* unipairs = NULL;\n        _cleanup_free_ void *fontbuf = NULL;\n        unsigned i;\n        int r;\n\n        unipairs = new(struct unipair, USHRT_MAX);\n        if (!unipairs) {\n                log_oom();\n                return;\n        }\n\n        /* get metadata of the current font (width, height, count) */\n        r = ioctl(src_fd, KDFONTOP, &cfo);\n        if (r < 0)\n                log_warning_errno(errno, \"KD_FONT_OP_GET failed while trying to get the font metadata: %m\");\n        else {\n                /* verify parameter sanity first */\n                if (cfo.width > 32 || cfo.height > 32 || cfo.charcount > 512)\n                        log_warning(\"Invalid font metadata - width: %u (max 32), height: %u (max 32), count: %u (max 512)\",\n                                    cfo.width, cfo.height, cfo.charcount);\n                else {\n                        /*\n                         * Console fonts supported by the kernel are limited in size to 32 x 32 and maximum 512\n                         * characters. Thus with 1 bit per pixel it requires up to 65536 bytes. The height always\n                         * requires 32 per glyph, regardless of the actual height - see the comment above #define\n                         * max_font_size 65536 in drivers/tty/vt/vt.c for more details.\n                         */\n                        fontbuf = malloc_multiply((cfo.width + 7) / 8 * 32, cfo.charcount);\n                        if (!fontbuf) {\n                                log_oom();\n                                return;\n                        }\n                        /* get fonts from the source console */\n                        cfo.data = fontbuf;\n                        r = ioctl(src_fd, KDFONTOP, &cfo);\n                        if (r < 0)\n                                log_warning_errno(errno, \"KD_FONT_OP_GET failed while trying to read the font data: %m\");\n                        else {\n                                unimapd.entries  = unipairs;\n                                unimapd.entry_ct = USHRT_MAX;\n                                r = ioctl(src_fd, GIO_UNIMAP, &unimapd);\n                                if (r < 0)\n                                        log_warning_errno(errno, \"GIO_UNIMAP failed while trying to read unicode mappings: %m\");\n                                else\n                                        cfo.op = KD_FONT_OP_SET;\n                        }\n                }\n        }\n\n        if (cfo.op != KD_FONT_OP_SET)\n                log_warning(\"Fonts will not be copied to remaining consoles\");\n\n        for (i = 1; i <= 63; i++) {\n                char ttyname[sizeof(\"/dev/tty63\")];\n                _cleanup_close_ int fd_d = -1;\n\n                if (i == src_idx || verify_vc_allocation(i) < 0)\n                        continue;\n\n                /* try to open terminal */\n                xsprintf(ttyname, \"/dev/tty%u\", i);\n                fd_d = open_terminal(ttyname, O_RDWR|O_CLOEXEC|O_NOCTTY);\n                if (fd_d < 0) {\n                        log_warning_errno(fd_d, \"Unable to open tty%u, fonts will not be copied: %m\", i);\n                        continue;\n                }\n\n                if (verify_vc_kbmode(fd_d) < 0)\n                        continue;\n\n                toggle_utf8(ttyname, fd_d, utf8);\n\n                if (cfo.op != KD_FONT_OP_SET)\n                        continue;\n\n                r = ioctl(fd_d, KDFONTOP, &cfo);\n                if (r < 0) {\n                        int last_errno, mode;\n\n                        /* The fonts couldn't have been copied. It might be due to the\n                         * terminal being in graphical mode. In this case the kernel\n                         * returns -EINVAL which is too generic for distinguishing this\n                         * specific case. So we need to retrieve the terminal mode and if\n                         * the graphical mode is in used, let's assume that something else\n                         * is using the terminal and the failure was expected as we\n                         * shouldn't have tried to copy the fonts. */\n\n                        last_errno = errno;\n                        if (ioctl(fd_d, KDGETMODE, &mode) >= 0 && mode != KD_TEXT)\n                                log_debug(\"KD_FONT_OP_SET skipped: tty%u is not in text mode\", i);\n                        else\n                                log_warning_errno(last_errno, \"KD_FONT_OP_SET failed, fonts will not be copied to tty%u: %m\", i);\n\n                        continue;\n                }\n\n                /*\n                 * copy unicode translation table unimapd is a ushort count and a pointer\n                 * to an array of struct unipair { ushort, ushort }\n                 */\n                r = ioctl(fd_d, PIO_UNIMAPCLR, &adv);\n                if (r < 0) {\n                        log_warning_errno(errno, \"PIO_UNIMAPCLR failed, unimaps might be incorrect for tty%u: %m\", i);\n                        continue;\n                }\n\n                r = ioctl(fd_d, PIO_UNIMAP, &unimapd);\n                if (r < 0) {\n                        log_warning_errno(errno, \"PIO_UNIMAP failed, unimaps might be incorrect for tty%u: %m\", i);\n                        continue;\n                }\n\n                log_debug(\"Font and unimap successfully copied to %s\", ttyname);\n        }\n}\n\nstatic int find_source_vc(char **ret_path, unsigned *ret_idx) {\n        _cleanup_free_ char *path = NULL;\n        int r, err = 0;\n        unsigned i;\n\n        path = new(char, sizeof(\"/dev/tty63\"));\n        if (!path)\n                return log_oom();\n\n        for (i = 1; i <= 63; i++) {\n                _cleanup_close_ int fd = -1;\n\n                r = verify_vc_allocation(i);\n                if (r < 0) {\n                        if (!err)\n                                err = -r;\n                        continue;\n                }\n\n                sprintf(path, \"/dev/tty%u\", i);\n                fd = open_terminal(path, O_RDWR|O_CLOEXEC|O_NOCTTY);\n                if (fd < 0) {\n                        if (!err)\n                                err = -fd;\n                        continue;\n                }\n                r = verify_vc_kbmode(fd);\n                if (r < 0) {\n                        if (!err)\n                                err = -r;\n                        continue;\n                }\n\n                /* all checks passed, return this one as a source console */\n                *ret_idx = i;\n                *ret_path = TAKE_PTR(path);\n                return TAKE_FD(fd);\n        }\n\n        return log_error_errno(err, \"No usable source console found: %m\");\n}\n\nstatic int verify_source_vc(char **ret_path, const char *src_vc) {\n        _cleanup_close_ int fd = -1;\n        char *path;\n        int r;\n\n        fd = open_terminal(src_vc, O_RDWR|O_CLOEXEC|O_NOCTTY);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to open %s: %m\", src_vc);\n\n        r = verify_vc_device(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Device %s is not a virtual console: %m\", src_vc);\n\n        r = verify_vc_allocation_byfd(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Virtual console %s is not allocated: %m\", src_vc);\n\n        r = verify_vc_kbmode(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Virtual console %s is not in K_XLATE or K_UNICODE: %m\", src_vc);\n\n        path = strdup(src_vc);\n        if (!path)\n                return log_oom();\n\n        *ret_path = path;\n        return TAKE_FD(fd);\n}\n\nint main(int argc, char **argv) {\n        _cleanup_free_ char\n                *vc = NULL,\n                *vc_keymap = NULL, *vc_keymap_toggle = NULL,\n                *vc_font = NULL, *vc_font_map = NULL, *vc_font_unimap = NULL;\n        _cleanup_close_ int fd = -1;\n        bool utf8, keyboard_ok;\n        unsigned idx = 0;\n        int r;\n\n        log_setup_service();\n\n        umask(0022);\n\n        if (argv[1])\n                fd = verify_source_vc(&vc, argv[1]);\n        else\n                fd = find_source_vc(&vc, &idx);\n        if (fd < 0)\n                return EXIT_FAILURE;\n\n        utf8 = is_locale_utf8();\n\n        r = parse_env_file(NULL, \"/etc/vconsole.conf\",\n                           \"KEYMAP\", &vc_keymap,\n                           \"KEYMAP_TOGGLE\", &vc_keymap_toggle,\n                           \"FONT\", &vc_font,\n                           \"FONT_MAP\", &vc_font_map,\n                           \"FONT_UNIMAP\", &vc_font_unimap);\n        if (r < 0 && r != -ENOENT)\n                log_warning_errno(r, \"Failed to read /etc/vconsole.conf: %m\");\n\n        /* Let the kernel command line override /etc/vconsole.conf */\n        r = proc_cmdline_get_key_many(\n                        PROC_CMDLINE_STRIP_RD_PREFIX,\n                        \"vconsole.keymap\", &vc_keymap,\n                        \"vconsole.keymap_toggle\", &vc_keymap_toggle,\n                        \"vconsole.font\", &vc_font,\n                        \"vconsole.font_map\", &vc_font_map,\n                        \"vconsole.font_unimap\", &vc_font_unimap,\n                        /* compatibility with obsolete multiple-dot scheme */\n                        \"vconsole.keymap.toggle\", &vc_keymap_toggle,\n                        \"vconsole.font.map\", &vc_font_map,\n                        \"vconsole.font.unimap\", &vc_font_unimap);\n        if (r < 0 && r != -ENOENT)\n                log_warning_errno(r, \"Failed to read /proc/cmdline: %m\");\n\n        (void) toggle_utf8_sysfs(utf8);\n        (void) toggle_utf8(vc, fd, utf8);\n\n        r = font_load_and_wait(vc, vc_font, vc_font_map, vc_font_unimap);\n        keyboard_ok = keyboard_load_and_wait(vc, vc_keymap, vc_keymap_toggle, utf8) == 0;\n\n        if (idx > 0) {\n                if (r == 0)\n                        setup_remaining_vcs(fd, idx, utf8);\n                else if (r == EX_OSERR)\n                        /* setfont returns EX_OSERR when ioctl(KDFONTOP/PIO_FONTX/PIO_FONTX) fails.\n                         * This might mean various things, but in particular lack of a graphical\n                         * console. Let's be generous and not treat this as an error. */\n                        log_notice(\"Setting fonts failed with a \\\"system error\\\", ignoring.\");\n                else\n                        log_warning(\"Setting source virtual console failed, ignoring remaining ones\");\n        }\n\n        return IN_SET(r, 0, EX_OSERR) && keyboard_ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/kd.h>\n#include <linux/tiocl.h>\n#include <linux/vt.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/inotify.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/sysmacros.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"copy.h\"\n#include \"def.h\"\n#include \"env-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"fs-util.h\"\n#include \"io-util.h\"\n#include \"log.h\"\n#include \"macro.h\"\n#include \"namespace-util.h\"\n#include \"parse-util.h\"\n#include \"path-util.h\"\n#include \"proc-cmdline.h\"\n#include \"process-util.h\"\n#include \"socket-util.h\"\n#include \"stat-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n#include \"time-util.h\"\n#include \"util.h\"\n\nstatic volatile unsigned cached_columns = 0;\nstatic volatile unsigned cached_lines = 0;\n\nstatic volatile int cached_on_tty = -1;\nstatic volatile int cached_colors_enabled = -1;\nstatic volatile int cached_underline_enabled = -1;\n\nint chvt(int vt) {\n        _cleanup_close_ int fd;\n\n        /* Switch to the specified vt number. If the VT is specified <= 0 switch to the VT the kernel log messages go,\n         * if that's configured. */\n\n        fd = open_terminal(\"/dev/tty0\", O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return -errno;\n\n        if (vt <= 0) {\n                int tiocl[2] = {\n                        TIOCL_GETKMSGREDIRECT,\n                        0\n                };\n\n                if (ioctl(fd, TIOCLINUX, tiocl) < 0)\n                        return -errno;\n\n                vt = tiocl[0] <= 0 ? 1 : tiocl[0];\n        }\n\n        if (ioctl(fd, VT_ACTIVATE, vt) < 0)\n                return -errno;\n\n        return 0;\n}\n\nint read_one_char(FILE *f, char *ret, usec_t t, bool *need_nl) {\n        _cleanup_free_ char *line = NULL;\n        struct termios old_termios;\n        int r;\n\n        assert(f);\n        assert(ret);\n\n        /* If this is a terminal, then switch canonical mode off, so that we can read a single character */\n        if (tcgetattr(fileno(f), &old_termios) >= 0) {\n                struct termios new_termios = old_termios;\n\n                new_termios.c_lflag &= ~ICANON;\n                new_termios.c_cc[VMIN] = 1;\n                new_termios.c_cc[VTIME] = 0;\n\n                if (tcsetattr(fileno(f), TCSADRAIN, &new_termios) >= 0) {\n                        char c;\n\n                        if (t != USEC_INFINITY) {\n                                if (fd_wait_for_event(fileno(f), POLLIN, t) <= 0) {\n                                        (void) tcsetattr(fileno(f), TCSADRAIN, &old_termios);\n                                        return -ETIMEDOUT;\n                                }\n                        }\n\n                        r = safe_fgetc(f, &c);\n                        (void) tcsetattr(fileno(f), TCSADRAIN, &old_termios);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                return -EIO;\n\n                        if (need_nl)\n                                *need_nl = c != '\\n';\n\n                        *ret = c;\n                        return 0;\n                }\n        }\n\n        if (t != USEC_INFINITY) {\n                if (fd_wait_for_event(fileno(f), POLLIN, t) <= 0)\n                        return -ETIMEDOUT;\n        }\n\n        /* If this is not a terminal, then read a full line instead */\n\n        r = read_line(f, 16, &line); /* longer than necessary, to eat up UTF-8 chars/vt100 key sequences */\n        if (r < 0)\n                return r;\n        if (r == 0)\n                return -EIO;\n\n        if (strlen(line) != 1)\n                return -EBADMSG;\n\n        if (need_nl)\n                *need_nl = false;\n\n        *ret = line[0];\n        return 0;\n}\n\n#define DEFAULT_ASK_REFRESH_USEC (2*USEC_PER_SEC)\n\nint ask_char(char *ret, const char *replies, const char *fmt, ...) {\n        int r;\n\n        assert(ret);\n        assert(replies);\n        assert(fmt);\n\n        for (;;) {\n                va_list ap;\n                char c;\n                bool need_nl = true;\n\n                if (colors_enabled())\n                        fputs(ANSI_HIGHLIGHT, stdout);\n\n                putchar('\\r');\n\n                va_start(ap, fmt);\n                vprintf(fmt, ap);\n                va_end(ap);\n\n                if (colors_enabled())\n                        fputs(ANSI_NORMAL, stdout);\n\n                fflush(stdout);\n\n                r = read_one_char(stdin, &c, DEFAULT_ASK_REFRESH_USEC, &need_nl);\n                if (r < 0) {\n\n                        if (r == -ETIMEDOUT)\n                                continue;\n\n                        if (r == -EBADMSG) {\n                                puts(\"Bad input, please try again.\");\n                                continue;\n                        }\n\n                        putchar('\\n');\n                        return r;\n                }\n\n                if (need_nl)\n                        putchar('\\n');\n\n                if (strchr(replies, c)) {\n                        *ret = c;\n                        return 0;\n                }\n\n                puts(\"Read unexpected character, please try again.\");\n        }\n}\n\nint ask_string(char **ret, const char *text, ...) {\n        int r;\n\n        assert(ret);\n        assert(text);\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL;\n                va_list ap;\n\n                if (colors_enabled())\n                        fputs(ANSI_HIGHLIGHT, stdout);\n\n                va_start(ap, text);\n                vprintf(text, ap);\n                va_end(ap);\n\n                if (colors_enabled())\n                        fputs(ANSI_NORMAL, stdout);\n\n                fflush(stdout);\n\n                r = read_line(stdin, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        return -EIO;\n\n                if (!isempty(line)) {\n                        *ret = TAKE_PTR(line);\n                        return 0;\n                }\n        }\n}\n\nint reset_terminal_fd(int fd, bool switch_to_text) {\n        struct termios termios;\n        int r = 0;\n\n        /* Set terminal to some sane defaults */\n\n        assert(fd >= 0);\n\n        /* We leave locked terminal attributes untouched, so that\n         * Plymouth may set whatever it wants to set, and we don't\n         * interfere with that. */\n\n        /* Disable exclusive mode, just in case */\n        (void) ioctl(fd, TIOCNXCL);\n\n        /* Switch to text mode */\n        if (switch_to_text)\n                (void) ioctl(fd, KDSETMODE, KD_TEXT);\n\n        /* Set default keyboard mode */\n        (void) vt_reset_keyboard(fd);\n\n        if (tcgetattr(fd, &termios) < 0) {\n                r = -errno;\n                goto finish;\n        }\n\n        /* We only reset the stuff that matters to the software. How\n         * hardware is set up we don't touch assuming that somebody\n         * else will do that for us */\n\n        termios.c_iflag &= ~(IGNBRK | BRKINT | ISTRIP | INLCR | IGNCR | IUCLC);\n        termios.c_iflag |= ICRNL | IMAXBEL | IUTF8;\n        termios.c_oflag |= ONLCR;\n        termios.c_cflag |= CREAD;\n        termios.c_lflag = ISIG | ICANON | IEXTEN | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOPRT | ECHOKE;\n\n        termios.c_cc[VINTR]    =   03;  /* ^C */\n        termios.c_cc[VQUIT]    =  034;  /* ^\\ */\n        termios.c_cc[VERASE]   = 0177;\n        termios.c_cc[VKILL]    =  025;  /* ^X */\n        termios.c_cc[VEOF]     =   04;  /* ^D */\n        termios.c_cc[VSTART]   =  021;  /* ^Q */\n        termios.c_cc[VSTOP]    =  023;  /* ^S */\n        termios.c_cc[VSUSP]    =  032;  /* ^Z */\n        termios.c_cc[VLNEXT]   =  026;  /* ^V */\n        termios.c_cc[VWERASE]  =  027;  /* ^W */\n        termios.c_cc[VREPRINT] =  022;  /* ^R */\n        termios.c_cc[VEOL]     =    0;\n        termios.c_cc[VEOL2]    =    0;\n\n        termios.c_cc[VTIME]  = 0;\n        termios.c_cc[VMIN]   = 1;\n\n        if (tcsetattr(fd, TCSANOW, &termios) < 0)\n                r = -errno;\n\nfinish:\n        /* Just in case, flush all crap out */\n        (void) tcflush(fd, TCIOFLUSH);\n\n        return r;\n}\n\nint reset_terminal(const char *name) {\n        _cleanup_close_ int fd = -1;\n\n        /* We open the terminal with O_NONBLOCK here, to ensure we\n         * don't block on carrier if this is a terminal with carrier\n         * configured. */\n\n        fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return fd;\n\n        return reset_terminal_fd(fd, true);\n}\n\nint open_terminal(const char *name, int mode) {\n        unsigned c = 0;\n        int fd;\n\n        /*\n         * If a TTY is in the process of being closed opening it might\n         * cause EIO. This is horribly awful, but unlikely to be\n         * changed in the kernel. Hence we work around this problem by\n         * retrying a couple of times.\n         *\n         * https://bugs.launchpad.net/ubuntu/+source/linux/+bug/554172/comments/245\n         */\n\n        if (mode & O_CREAT)\n                return -EINVAL;\n\n        for (;;) {\n                fd = open(name, mode, 0);\n                if (fd >= 0)\n                        break;\n\n                if (errno != EIO)\n                        return -errno;\n\n                /* Max 1s in total */\n                if (c >= 20)\n                        return -errno;\n\n                usleep(50 * USEC_PER_MSEC);\n                c++;\n        }\n\n        if (isatty(fd) <= 0) {\n                safe_close(fd);\n                return -ENOTTY;\n        }\n\n        return fd;\n}\n\nint acquire_terminal(\n                const char *name,\n                AcquireTerminalFlags flags,\n                usec_t timeout) {\n\n        _cleanup_close_ int notify = -1, fd = -1;\n        usec_t ts = USEC_INFINITY;\n        int r, wd = -1;\n\n        assert(name);\n        assert(IN_SET(flags & ~ACQUIRE_TERMINAL_PERMISSIVE, ACQUIRE_TERMINAL_TRY, ACQUIRE_TERMINAL_FORCE, ACQUIRE_TERMINAL_WAIT));\n\n        /* We use inotify to be notified when the tty is closed. We create the watch before checking if we can actually\n         * acquire it, so that we don't lose any event.\n         *\n         * Note: strictly speaking this actually watches for the device being closed, it does *not* really watch\n         * whether a tty loses its controlling process. However, unless some rogue process uses TIOCNOTTY on /dev/tty\n         * *after* closing its tty otherwise this will not become a problem. As long as the administrator makes sure to\n         * not configure any service on the same tty as an untrusted user this should not be a problem. (Which they\n         * probably should not do anyway.) */\n\n        if ((flags & ~ACQUIRE_TERMINAL_PERMISSIVE) == ACQUIRE_TERMINAL_WAIT) {\n                notify = inotify_init1(IN_CLOEXEC | (timeout != USEC_INFINITY ? IN_NONBLOCK : 0));\n                if (notify < 0)\n                        return -errno;\n\n                wd = inotify_add_watch(notify, name, IN_CLOSE);\n                if (wd < 0)\n                        return -errno;\n\n                if (timeout != USEC_INFINITY)\n                        ts = now(CLOCK_MONOTONIC);\n        }\n\n        for (;;) {\n                struct sigaction sa_old, sa_new = {\n                        .sa_handler = SIG_IGN,\n                        .sa_flags = SA_RESTART,\n                };\n\n                if (notify >= 0) {\n                        r = flush_fd(notify);\n                        if (r < 0)\n                                return r;\n                }\n\n                /* We pass here O_NOCTTY only so that we can check the return value TIOCSCTTY and have a reliable way\n                 * to figure out if we successfully became the controlling process of the tty */\n                fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC);\n                if (fd < 0)\n                        return fd;\n\n                /* Temporarily ignore SIGHUP, so that we don't get SIGHUP'ed if we already own the tty. */\n                assert_se(sigaction(SIGHUP, &sa_new, &sa_old) == 0);\n\n                /* First, try to get the tty */\n                r = ioctl(fd, TIOCSCTTY,\n                          (flags & ~ACQUIRE_TERMINAL_PERMISSIVE) == ACQUIRE_TERMINAL_FORCE) < 0 ? -errno : 0;\n\n                /* Reset signal handler to old value */\n                assert_se(sigaction(SIGHUP, &sa_old, NULL) == 0);\n\n                /* Success? Exit the loop now! */\n                if (r >= 0)\n                        break;\n\n                /* Any failure besides -EPERM? Fail, regardless of the mode. */\n                if (r != -EPERM)\n                        return r;\n\n                if (flags & ACQUIRE_TERMINAL_PERMISSIVE) /* If we are in permissive mode, then EPERM is fine, turn this\n                                                          * into a success. Note that EPERM is also returned if we\n                                                          * already are the owner of the TTY. */\n                        break;\n\n                if (flags != ACQUIRE_TERMINAL_WAIT) /* If we are in TRY or FORCE mode, then propagate EPERM as EPERM */\n                        return r;\n\n                assert(notify >= 0);\n                assert(wd >= 0);\n\n                for (;;) {\n                        union inotify_event_buffer buffer;\n                        struct inotify_event *e;\n                        ssize_t l;\n\n                        if (timeout != USEC_INFINITY) {\n                                usec_t n;\n\n                                assert(ts != USEC_INFINITY);\n\n                                n = now(CLOCK_MONOTONIC);\n                                if (ts + timeout < n)\n                                        return -ETIMEDOUT;\n\n                                r = fd_wait_for_event(notify, POLLIN, ts + timeout - n);\n                                if (r < 0)\n                                        return r;\n                                if (r == 0)\n                                        return -ETIMEDOUT;\n                        }\n\n                        l = read(notify, &buffer, sizeof(buffer));\n                        if (l < 0) {\n                                if (IN_SET(errno, EINTR, EAGAIN))\n                                        continue;\n\n                                return -errno;\n                        }\n\n                        FOREACH_INOTIFY_EVENT(e, buffer, l) {\n                                if (e->mask & IN_Q_OVERFLOW) /* If we hit an inotify queue overflow, simply check if the terminal is up for grabs now. */\n                                        break;\n\n                                if (e->wd != wd || !(e->mask & IN_CLOSE)) /* Safety checks */\n                                        return -EIO;\n                        }\n\n                        break;\n                }\n\n                /* We close the tty fd here since if the old session ended our handle will be dead. It's important that\n                 * we do this after sleeping, so that we don't enter an endless loop. */\n                fd = safe_close(fd);\n        }\n\n        return TAKE_FD(fd);\n}\n\nint release_terminal(void) {\n        static const struct sigaction sa_new = {\n                .sa_handler = SIG_IGN,\n                .sa_flags = SA_RESTART,\n        };\n\n        _cleanup_close_ int fd = -1;\n        struct sigaction sa_old;\n        int r;\n\n        fd = open(\"/dev/tty\", O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return -errno;\n\n        /* Temporarily ignore SIGHUP, so that we don't get SIGHUP'ed\n         * by our own TIOCNOTTY */\n        assert_se(sigaction(SIGHUP, &sa_new, &sa_old) == 0);\n\n        r = ioctl(fd, TIOCNOTTY) < 0 ? -errno : 0;\n\n        assert_se(sigaction(SIGHUP, &sa_old, NULL) == 0);\n\n        return r;\n}\n\nint terminal_vhangup_fd(int fd) {\n        assert(fd >= 0);\n\n        if (ioctl(fd, TIOCVHANGUP) < 0)\n                return -errno;\n\n        return 0;\n}\n\nint terminal_vhangup(const char *name) {\n        _cleanup_close_ int fd;\n\n        fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return fd;\n\n        return terminal_vhangup_fd(fd);\n}\n\nint vt_disallocate(const char *name) {\n        _cleanup_close_ int fd = -1;\n        const char *e, *n;\n        unsigned u;\n        int r;\n\n        /* Deallocate the VT if possible. If not possible\n         * (i.e. because it is the active one), at least clear it\n         * entirely (including the scrollback buffer) */\n\n        e = path_startswith(name, \"/dev/\");\n        if (!e)\n                return -EINVAL;\n\n        if (!tty_is_vc(name)) {\n                /* So this is not a VT. I guess we cannot deallocate\n                 * it then. But let's at least clear the screen */\n\n                fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC);\n                if (fd < 0)\n                        return fd;\n\n                loop_write(fd,\n                           \"\\033[r\"    /* clear scrolling region */\n                           \"\\033[H\"    /* move home */\n                           \"\\033[2J\",  /* clear screen */\n                           10, false);\n                return 0;\n        }\n\n        n = startswith(e, \"tty\");\n        if (!n)\n                return -EINVAL;\n\n        r = safe_atou(n, &u);\n        if (r < 0)\n                return r;\n\n        if (u <= 0)\n                return -EINVAL;\n\n        /* Try to deallocate */\n        fd = open_terminal(\"/dev/tty0\", O_RDWR|O_NOCTTY|O_CLOEXEC|O_NONBLOCK);\n        if (fd < 0)\n                return fd;\n\n        r = ioctl(fd, VT_DISALLOCATE, u);\n        fd = safe_close(fd);\n\n        if (r >= 0)\n                return 0;\n\n        if (errno != EBUSY)\n                return -errno;\n\n        /* Couldn't deallocate, so let's clear it fully with\n         * scrollback */\n        fd = open_terminal(name, O_RDWR|O_NOCTTY|O_CLOEXEC);\n        if (fd < 0)\n                return fd;\n\n        loop_write(fd,\n                   \"\\033[r\"   /* clear scrolling region */\n                   \"\\033[H\"   /* move home */\n                   \"\\033[3J\", /* clear screen including scrollback, requires Linux 2.6.40 */\n                   10, false);\n        return 0;\n}\n\nint make_console_stdio(void) {\n        int fd, r;\n\n        /* Make /dev/console the controlling terminal and stdin/stdout/stderr */\n\n        fd = acquire_terminal(\"/dev/console\", ACQUIRE_TERMINAL_FORCE|ACQUIRE_TERMINAL_PERMISSIVE, USEC_INFINITY);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to acquire terminal: %m\");\n\n        r = reset_terminal_fd(fd, true);\n        if (r < 0)\n                log_warning_errno(r, \"Failed to reset terminal, ignoring: %m\");\n\n        r = rearrange_stdio(fd, fd, fd); /* This invalidates 'fd' both on success and on failure. */\n        if (r < 0)\n                return log_error_errno(r, \"Failed to make terminal stdin/stdout/stderr: %m\");\n\n        reset_terminal_feature_caches();\n\n        return 0;\n}\n\nbool tty_is_vc(const char *tty) {\n        assert(tty);\n\n        return vtnr_from_tty(tty) >= 0;\n}\n\nbool tty_is_console(const char *tty) {\n        assert(tty);\n\n        return streq(skip_dev_prefix(tty), \"console\");\n}\n\nint vtnr_from_tty(const char *tty) {\n        int i, r;\n\n        assert(tty);\n\n        tty = skip_dev_prefix(tty);\n\n        if (!startswith(tty, \"tty\") )\n                return -EINVAL;\n\n        if (tty[3] < '0' || tty[3] > '9')\n                return -EINVAL;\n\n        r = safe_atoi(tty+3, &i);\n        if (r < 0)\n                return r;\n\n        if (i < 0 || i > 63)\n                return -EINVAL;\n\n        return i;\n}\n\n int resolve_dev_console(char **ret) {\n        _cleanup_free_ char *active = NULL;\n        char *tty;\n        int r;\n\n        assert(ret);\n\n        /* Resolve where /dev/console is pointing to, if /sys is actually ours (i.e. not read-only-mounted which is a\n         * sign for container setups) */\n\n        if (path_is_read_only_fs(\"/sys\") > 0)\n                return -ENOMEDIUM;\n\n        r = read_one_line_file(\"/sys/class/tty/console/active\", &active);\n        if (r < 0)\n                return r;\n\n        /* If multiple log outputs are configured the last one is what /dev/console points to */\n        tty = strrchr(active, ' ');\n        if (tty)\n                tty++;\n        else\n                tty = active;\n\n        if (streq(tty, \"tty0\")) {\n                active = mfree(active);\n\n                /* Get the active VC (e.g. tty1) */\n                r = read_one_line_file(\"/sys/class/tty/tty0/active\", &active);\n                if (r < 0)\n                        return r;\n\n                tty = active;\n        }\n\n        if (tty == active)\n                *ret = TAKE_PTR(active);\n        else {\n                char *tmp;\n\n                tmp = strdup(tty);\n                if (!tmp)\n                        return -ENOMEM;\n\n                *ret = tmp;\n        }\n\n        return 0;\n}\n\nint get_kernel_consoles(char ***ret) {\n        _cleanup_strv_free_ char **l = NULL;\n        _cleanup_free_ char *line = NULL;\n        const char *p;\n        int r;\n\n        assert(ret);\n\n        /* If /sys is mounted read-only this means we are running in some kind of container environment. In that\n         * case /sys would reflect the host system, not us, hence ignore the data we can read from it. */\n        if (path_is_read_only_fs(\"/sys\") > 0)\n                goto fallback;\n\n        r = read_one_line_file(\"/sys/class/tty/console/active\", &line);\n        if (r < 0)\n                return r;\n\n        p = line;\n        for (;;) {\n                _cleanup_free_ char *tty = NULL;\n                char *path;\n\n                r = extract_first_word(&p, &tty, NULL, 0);\n                if (r < 0)\n                        return r;\n                if (r == 0)\n                        break;\n\n                if (streq(tty, \"tty0\")) {\n                        tty = mfree(tty);\n                        r = read_one_line_file(\"/sys/class/tty/tty0/active\", &tty);\n                        if (r < 0)\n                                return r;\n                }\n\n                path = strappend(\"/dev/\", tty);\n                if (!path)\n                        return -ENOMEM;\n\n                if (access(path, F_OK) < 0) {\n                        log_debug_errno(errno, \"Console device %s is not accessible, skipping: %m\", path);\n                        free(path);\n                        continue;\n                }\n\n                r = strv_consume(&l, path);\n                if (r < 0)\n                        return r;\n        }\n\n        if (strv_isempty(l)) {\n                log_debug(\"No devices found for system console\");\n                goto fallback;\n        }\n\n        *ret = TAKE_PTR(l);\n\n        return 0;\n\nfallback:\n        r = strv_extend(&l, \"/dev/console\");\n        if (r < 0)\n                return r;\n\n        *ret = TAKE_PTR(l);\n\n        return 0;\n}\n\nbool tty_is_vc_resolve(const char *tty) {\n        _cleanup_free_ char *resolved = NULL;\n\n        assert(tty);\n\n        tty = skip_dev_prefix(tty);\n\n        if (streq(tty, \"console\")) {\n                if (resolve_dev_console(&resolved) < 0)\n                        return false;\n\n                tty = resolved;\n        }\n\n        return tty_is_vc(tty);\n}\n\nconst char *default_term_for_tty(const char *tty) {\n        return tty && tty_is_vc_resolve(tty) ? \"linux\" : \"vt220\";\n}\n\nint fd_columns(int fd) {\n        struct winsize ws = {};\n\n        if (ioctl(fd, TIOCGWINSZ, &ws) < 0)\n                return -errno;\n\n        if (ws.ws_col <= 0)\n                return -EIO;\n\n        return ws.ws_col;\n}\n\nunsigned columns(void) {\n        const char *e;\n        int c;\n\n        if (cached_columns > 0)\n                return cached_columns;\n\n        c = 0;\n        e = getenv(\"COLUMNS\");\n        if (e)\n                (void) safe_atoi(e, &c);\n\n        if (c <= 0 || c > USHRT_MAX) {\n                c = fd_columns(STDOUT_FILENO);\n                if (c <= 0)\n                        c = 80;\n        }\n\n        cached_columns = c;\n        return cached_columns;\n}\n\nint fd_lines(int fd) {\n        struct winsize ws = {};\n\n        if (ioctl(fd, TIOCGWINSZ, &ws) < 0)\n                return -errno;\n\n        if (ws.ws_row <= 0)\n                return -EIO;\n\n        return ws.ws_row;\n}\n\nunsigned lines(void) {\n        const char *e;\n        int l;\n\n        if (cached_lines > 0)\n                return cached_lines;\n\n        l = 0;\n        e = getenv(\"LINES\");\n        if (e)\n                (void) safe_atoi(e, &l);\n\n        if (l <= 0 || l > USHRT_MAX) {\n                l = fd_lines(STDOUT_FILENO);\n                if (l <= 0)\n                        l = 24;\n        }\n\n        cached_lines = l;\n        return cached_lines;\n}\n\n/* intended to be used as a SIGWINCH sighandler */\nvoid columns_lines_cache_reset(int signum) {\n        cached_columns = 0;\n        cached_lines = 0;\n}\n\nvoid reset_terminal_feature_caches(void) {\n        cached_columns = 0;\n        cached_lines = 0;\n\n        cached_colors_enabled = -1;\n        cached_underline_enabled = -1;\n        cached_on_tty = -1;\n}\n\nbool on_tty(void) {\n\n        /* We check both stdout and stderr, so that situations where pipes on the shell are used are reliably\n         * recognized, regardless if only the output or the errors are piped to some place. Since on_tty() is generally\n         * used to default to a safer, non-interactive, non-color mode of operation it's probably good to be defensive\n         * here, and check for both. Note that we don't check for STDIN_FILENO, because it should fine to use fancy\n         * terminal functionality when outputting stuff, even if the input is piped to us. */\n\n        if (cached_on_tty < 0)\n                cached_on_tty =\n                        isatty(STDOUT_FILENO) > 0 &&\n                        isatty(STDERR_FILENO) > 0;\n\n        return cached_on_tty;\n}\n\nint getttyname_malloc(int fd, char **ret) {\n        char path[PATH_MAX], *c; /* PATH_MAX is counted *with* the trailing NUL byte */\n        int r;\n\n        assert(fd >= 0);\n        assert(ret);\n\n        r = ttyname_r(fd, path, sizeof path); /* positive error */\n        assert(r >= 0);\n        if (r == ERANGE)\n                return -ENAMETOOLONG;\n        if (r > 0)\n                return -r;\n\n        c = strdup(skip_dev_prefix(path));\n        if (!c)\n                return -ENOMEM;\n\n        *ret = c;\n        return 0;\n}\n\nint getttyname_harder(int fd, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        int r;\n\n        r = getttyname_malloc(fd, &s);\n        if (r < 0)\n                return r;\n\n        if (streq(s, \"tty\"))\n                return get_ctty(0, NULL, ret);\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}\n\nint get_ctty_devnr(pid_t pid, dev_t *d) {\n        int r;\n        _cleanup_free_ char *line = NULL;\n        const char *p;\n        unsigned long ttynr;\n\n        assert(pid >= 0);\n\n        p = procfs_file_alloca(pid, \"stat\");\n        r = read_one_line_file(p, &line);\n        if (r < 0)\n                return r;\n\n        p = strrchr(line, ')');\n        if (!p)\n                return -EIO;\n\n        p++;\n\n        if (sscanf(p, \" \"\n                   \"%*c \"  /* state */\n                   \"%*d \"  /* ppid */\n                   \"%*d \"  /* pgrp */\n                   \"%*d \"  /* session */\n                   \"%lu \", /* ttynr */\n                   &ttynr) != 1)\n                return -EIO;\n\n        if (major(ttynr) == 0 && minor(ttynr) == 0)\n                return -ENXIO;\n\n        if (d)\n                *d = (dev_t) ttynr;\n\n        return 0;\n}\n\nint get_ctty(pid_t pid, dev_t *ret_devnr, char **ret) {\n        _cleanup_free_ char *fn = NULL, *b = NULL;\n        dev_t devnr;\n        int r;\n\n        r = get_ctty_devnr(pid, &devnr);\n        if (r < 0)\n                return r;\n\n        r = device_path_make_canonical(S_IFCHR, devnr, &fn);\n        if (r < 0) {\n                if (r != -ENOENT) /* No symlink for this in /dev/char/? */\n                        return r;\n\n                if (major(devnr) == 136) {\n                        /* This is an ugly hack: PTY devices are not listed in /dev/char/, as they don't follow the\n                         * Linux device model. This means we have no nice way to match them up against their actual\n                         * device node. Let's hence do the check by the fixed, assigned major number. Normally we try\n                         * to avoid such fixed major/minor matches, but there appears to nother nice way to handle\n                         * this. */\n\n                        if (asprintf(&b, \"pts/%u\", minor(devnr)) < 0)\n                                return -ENOMEM;\n                } else {\n                        /* Probably something similar to the ptys which have no symlink in /dev/char/. Let's return\n                         * something vaguely useful. */\n\n                        r = device_path_make_major_minor(S_IFCHR, devnr, &fn);\n                        if (r < 0)\n                                return r;\n                }\n        }\n\n        if (!b) {\n                const char *w;\n\n                w = path_startswith(fn, \"/dev/\");\n                if (w) {\n                        b = strdup(w);\n                        if (!b)\n                                return -ENOMEM;\n                } else\n                        b = TAKE_PTR(fn);\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(b);\n\n        if (ret_devnr)\n                *ret_devnr = devnr;\n\n        return 0;\n}\n\nint ptsname_malloc(int fd, char **ret) {\n        size_t l = 100;\n\n        assert(fd >= 0);\n        assert(ret);\n\n        for (;;) {\n                char *c;\n\n                c = new(char, l);\n                if (!c)\n                        return -ENOMEM;\n\n                if (ptsname_r(fd, c, l) == 0) {\n                        *ret = c;\n                        return 0;\n                }\n                if (errno != ERANGE) {\n                        free(c);\n                        return -errno;\n                }\n\n                free(c);\n\n                if (l > SIZE_MAX / 2)\n                        return -ENOMEM;\n\n                l *= 2;\n        }\n}\n\nint ptsname_namespace(int pty, char **ret) {\n        int no = -1, r;\n\n        /* Like ptsname(), but doesn't assume that the path is\n         * accessible in the local namespace. */\n\n        r = ioctl(pty, TIOCGPTN, &no);\n        if (r < 0)\n                return -errno;\n\n        if (no < 0)\n                return -EIO;\n\n        if (asprintf(ret, \"/dev/pts/%i\", no) < 0)\n                return -ENOMEM;\n\n        return 0;\n}\n\nint openpt_in_namespace(pid_t pid, int flags) {\n        _cleanup_close_ int pidnsfd = -1, mntnsfd = -1, usernsfd = -1, rootfd = -1;\n        _cleanup_close_pair_ int pair[2] = { -1, -1 };\n        pid_t child;\n        int r;\n\n        assert(pid > 0);\n\n        r = namespace_open(pid, &pidnsfd, &mntnsfd, NULL, &usernsfd, &rootfd);\n        if (r < 0)\n                return r;\n\n        if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pair) < 0)\n                return -errno;\n\n        r = namespace_fork(\"(sd-openptns)\", \"(sd-openpt)\", NULL, 0, FORK_RESET_SIGNALS|FORK_DEATHSIG,\n                           pidnsfd, mntnsfd, -1, usernsfd, rootfd, &child);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                int master;\n\n                pair[0] = safe_close(pair[0]);\n\n                master = posix_openpt(flags|O_NOCTTY|O_CLOEXEC);\n                if (master < 0)\n                        _exit(EXIT_FAILURE);\n\n                if (unlockpt(master) < 0)\n                        _exit(EXIT_FAILURE);\n\n                if (send_one_fd(pair[1], master, 0) < 0)\n                        _exit(EXIT_FAILURE);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        pair[1] = safe_close(pair[1]);\n\n        r = wait_for_terminate_and_check(\"(sd-openptns)\", child, 0);\n        if (r < 0)\n                return r;\n        if (r != EXIT_SUCCESS)\n                return -EIO;\n\n        return receive_one_fd(pair[0], 0);\n}\n\nint open_terminal_in_namespace(pid_t pid, const char *name, int mode) {\n        _cleanup_close_ int pidnsfd = -1, mntnsfd = -1, usernsfd = -1, rootfd = -1;\n        _cleanup_close_pair_ int pair[2] = { -1, -1 };\n        pid_t child;\n        int r;\n\n        r = namespace_open(pid, &pidnsfd, &mntnsfd, NULL, &usernsfd, &rootfd);\n        if (r < 0)\n                return r;\n\n        if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pair) < 0)\n                return -errno;\n\n        r = namespace_fork(\"(sd-terminalns)\", \"(sd-terminal)\", NULL, 0, FORK_RESET_SIGNALS|FORK_DEATHSIG,\n                           pidnsfd, mntnsfd, -1, usernsfd, rootfd, &child);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                int master;\n\n                pair[0] = safe_close(pair[0]);\n\n                master = open_terminal(name, mode|O_NOCTTY|O_CLOEXEC);\n                if (master < 0)\n                        _exit(EXIT_FAILURE);\n\n                if (send_one_fd(pair[1], master, 0) < 0)\n                        _exit(EXIT_FAILURE);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        pair[1] = safe_close(pair[1]);\n\n        r = wait_for_terminate_and_check(\"(sd-terminalns)\", child, 0);\n        if (r < 0)\n                return r;\n        if (r != EXIT_SUCCESS)\n                return -EIO;\n\n        return receive_one_fd(pair[0], 0);\n}\n\nstatic bool getenv_terminal_is_dumb(void) {\n        const char *e;\n\n        e = getenv(\"TERM\");\n        if (!e)\n                return true;\n\n        return streq(e, \"dumb\");\n}\n\nbool terminal_is_dumb(void) {\n        if (!on_tty())\n                return true;\n\n        return getenv_terminal_is_dumb();\n}\n\nbool colors_enabled(void) {\n\n        /* Returns true if colors are considered supported on our stdout. For that we check $SYSTEMD_COLORS first\n         * (which is the explicit way to turn colors on/off). If that didn't work we turn colors off unless we are on a\n         * TTY. And if we are on a TTY we turn it off if $TERM is set to \"dumb\". There's one special tweak though: if\n         * we are PID 1 then we do not check whether we are connected to a TTY, because we don't keep /dev/console open\n         * continuously due to fear of SAK, and hence things are a bit weird. */\n\n        if (cached_colors_enabled < 0) {\n                int val;\n\n                val = getenv_bool(\"SYSTEMD_COLORS\");\n                if (val >= 0)\n                        cached_colors_enabled = val;\n                else if (getpid_cached() == 1)\n                        /* PID1 outputs to the console without holding it open all the time */\n                        cached_colors_enabled = !getenv_terminal_is_dumb();\n                else\n                        cached_colors_enabled = !terminal_is_dumb();\n        }\n\n        return cached_colors_enabled;\n}\n\nbool dev_console_colors_enabled(void) {\n        _cleanup_free_ char *s = NULL;\n        int b;\n\n        /* Returns true if we assume that color is supported on /dev/console.\n         *\n         * For that we first check if we explicitly got told to use colors or not, by checking $SYSTEMD_COLORS. If that\n         * isn't set we check whether PID 1 has $TERM set, and if not, whether TERM is set on the kernel command\n         * line. If we find $TERM set we assume color if it's not set to \"dumb\", similarly to how regular\n         * colors_enabled() operates. */\n\n        b = getenv_bool(\"SYSTEMD_COLORS\");\n        if (b >= 0)\n                return b;\n\n        if (getenv_for_pid(1, \"TERM\", &s) <= 0)\n                (void) proc_cmdline_get_key(\"TERM\", 0, &s);\n\n        return !streq_ptr(s, \"dumb\");\n}\n\nbool underline_enabled(void) {\n\n        if (cached_underline_enabled < 0) {\n\n                /* The Linux console doesn't support underlining, turn it off, but only there. */\n\n                if (colors_enabled())\n                        cached_underline_enabled = !streq_ptr(getenv(\"TERM\"), \"linux\");\n                else\n                        cached_underline_enabled = false;\n        }\n\n        return cached_underline_enabled;\n}\n\nint vt_default_utf8(void) {\n        _cleanup_free_ char *b = NULL;\n        int r;\n\n        /* Read the default VT UTF8 setting from the kernel */\n\n        r = read_one_line_file(\"/sys/module/vt/parameters/default_utf8\", &b);\n        if (r < 0)\n                return r;\n\n        return parse_boolean(b);\n}\n\nint vt_verify_kbmode(int fd) {\n        int curr_mode;\n\n        /*\n         * Make sure we only adjust consoles in K_XLATE or K_UNICODE mode.\n         * Otherwise we would (likely) interfere with X11's processing of the\n         * key events.\n         *\n         * http://lists.freedesktop.org/archives/systemd-devel/2013-February/008573.html\n         */\n\n        if (ioctl(fd, KDGKBMODE, &curr_mode) < 0)\n                return -errno;\n\n        return IN_SET(curr_mode, K_XLATE, K_UNICODE) ? 0 : -EBUSY;\n}\n\nint vt_reset_keyboard(int fd) {\n        int kb, r;\n\n        /* If we can't read the default, then default to unicode. It's 2017 after all. */\n        kb = vt_default_utf8() != 0 ? K_UNICODE : K_XLATE;\n\n        r = vt_verify_kbmode(fd);\n        if (r == -EBUSY) {\n                log_debug_errno(r, \"Keyboard is not in XLATE or UNICODE mode, not resetting: %m\");\n                return 0;\n        } else if (r < 0)\n                return r;\n\n        if (ioctl(fd, KDSKBMODE, kb) < 0)\n                return -errno;\n\n        return 0;\n}\n\nint vt_restore(int fd) {\n        static const struct vt_mode mode = {\n                .mode = VT_AUTO,\n        };\n        int r, q = 0;\n\n        r = ioctl(fd, KDSETMODE, KD_TEXT);\n        if (r < 0)\n                q = log_debug_errno(errno, \"Failed to set VT in text mode, ignoring: %m\");\n\n        r = vt_reset_keyboard(fd);\n        if (r < 0) {\n                log_debug_errno(r, \"Failed to reset keyboard mode, ignoring: %m\");\n                if (q >= 0)\n                        q = r;\n        }\n\n        r = ioctl(fd, VT_SETMODE, &mode);\n        if (r < 0) {\n                log_debug_errno(errno, \"Failed to set VT_AUTO mode, ignoring: %m\");\n                if (q >= 0)\n                        q = -errno;\n        }\n\n        r = fchown(fd, 0, (gid_t) -1);\n        if (r < 0) {\n                log_debug_errno(errno, \"Failed to chown VT, ignoring: %m\");\n                if (q >= 0)\n                        q = -errno;\n        }\n\n        return q;\n}\n\nint vt_release(int fd, bool restore) {\n        assert(fd >= 0);\n\n        /* This function releases the VT by acknowledging the VT-switch signal\n         * sent by the kernel and optionally reset the VT in text and auto\n         * VT-switching modes. */\n\n        if (ioctl(fd, VT_RELDISP, 1) < 0)\n                return -errno;\n\n        if (restore)\n                return vt_restore(fd);\n\n        return 0;\n}\n\nvoid get_log_colors(int priority, const char **on, const char **off, const char **highlight) {\n        /* Note that this will initialize output variables only when there's something to output.\n         * The caller must pre-initalize to \"\" or NULL as appropriate. */\n\n        if (priority <= LOG_ERR) {\n                if (on)\n                        *on = ANSI_HIGHLIGHT_RED;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT;\n\n        } else if (priority <= LOG_WARNING) {\n                if (on)\n                        *on = ANSI_HIGHLIGHT_YELLOW;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT;\n\n        } else if (priority <= LOG_NOTICE) {\n                if (on)\n                        *on = ANSI_HIGHLIGHT;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT_RED;\n\n        } else if (priority >= LOG_DEBUG) {\n                if (on)\n                        *on = ANSI_GREY;\n                if (off)\n                        *off = ANSI_NORMAL;\n                if (highlight)\n                        *highlight = ANSI_HIGHLIGHT_RED;\n        }\n}\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n#pragma once\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <syslog.h>\n#include <sys/types.h>\n\n#include \"macro.h\"\n#include \"time-util.h\"\n\n/* Regular colors */\n#define ANSI_BLACK   \"\\x1B[0;30m\"\n#define ANSI_RED     \"\\x1B[0;31m\"\n#define ANSI_GREEN   \"\\x1B[0;32m\"\n#define ANSI_YELLOW  \"\\x1B[0;33m\"\n#define ANSI_BLUE    \"\\x1B[0;34m\"\n#define ANSI_MAGENTA \"\\x1B[0;35m\"\n#define ANSI_CYAN    \"\\x1B[0;36m\"\n#define ANSI_WHITE   \"\\x1B[0;37m\"\n#define ANSI_GREY    \"\\x1B[0;2;37m\"\n\n/* Bold/highlighted */\n#define ANSI_HIGHLIGHT_BLACK   \"\\x1B[0;1;30m\"\n#define ANSI_HIGHLIGHT_RED     \"\\x1B[0;1;31m\"\n#define ANSI_HIGHLIGHT_GREEN   \"\\x1B[0;1;32m\"\n#define ANSI_HIGHLIGHT_YELLOW  \"\\x1B[0;1;33m\"\n#define ANSI_HIGHLIGHT_BLUE    \"\\x1B[0;1;34m\"\n#define ANSI_HIGHLIGHT_MAGENTA \"\\x1B[0;1;35m\"\n#define ANSI_HIGHLIGHT_CYAN    \"\\x1B[0;1;36m\"\n#define ANSI_HIGHLIGHT_WHITE   \"\\x1B[0;1;37m\"\n\n/* Underlined */\n#define ANSI_HIGHLIGHT_BLACK_UNDERLINE   \"\\x1B[0;1;4;30m\"\n#define ANSI_HIGHLIGHT_RED_UNDERLINE     \"\\x1B[0;1;4;31m\"\n#define ANSI_HIGHLIGHT_GREEN_UNDERLINE   \"\\x1B[0;1;4;32m\"\n#define ANSI_HIGHLIGHT_YELLOW_UNDERLINE  \"\\x1B[0;1;4;33m\"\n#define ANSI_HIGHLIGHT_BLUE_UNDERLINE    \"\\x1B[0;1;4;34m\"\n#define ANSI_HIGHLIGHT_MAGENTA_UNDERLINE \"\\x1B[0;1;4;35m\"\n#define ANSI_HIGHLIGHT_CYAN_UNDERLINE    \"\\x1B[0;1;4;36m\"\n#define ANSI_HIGHLIGHT_WHITE_UNDERLINE   \"\\x1B[0;1;4;37m\"\n\n/* Other ANSI codes */\n#define ANSI_UNDERLINE \"\\x1B[0;4m\"\n#define ANSI_HIGHLIGHT \"\\x1B[0;1;39m\"\n#define ANSI_HIGHLIGHT_UNDERLINE \"\\x1B[0;1;4m\"\n\n/* Reset/clear ANSI styles */\n#define ANSI_NORMAL \"\\x1B[0m\"\n\n/* Erase characters until the end of the line */\n#define ANSI_ERASE_TO_END_OF_LINE \"\\x1B[K\"\n\n/* Move cursor up one line */\n#define ANSI_REVERSE_LINEFEED \"\\x1BM\"\n\n/* Set cursor to top left corner and clear screen */\n#define ANSI_HOME_CLEAR \"\\x1B[H\\x1B[2J\"\n\nint reset_terminal_fd(int fd, bool switch_to_text);\nint reset_terminal(const char *name);\n\nint open_terminal(const char *name, int mode);\n\n/* Flags for tweaking the way we become the controlling process of a terminal. */\ntypedef enum AcquireTerminalFlags {\n        /* Try to become the controlling process of the TTY. If we can't return -EPERM. */\n        ACQUIRE_TERMINAL_TRY        = 0,\n\n        /* Tell the kernel to forcibly make us the controlling process of the TTY. Returns -EPERM if the kernel doesn't allow that. */\n        ACQUIRE_TERMINAL_FORCE      = 1,\n\n        /* If we can't become the controlling process of the TTY right-away, then wait until we can. */\n        ACQUIRE_TERMINAL_WAIT       = 2,\n\n        /* Pick one of the above, and then OR this flag in, in order to request permissive behaviour, if we can't become controlling process then don't mind */\n        ACQUIRE_TERMINAL_PERMISSIVE = 1 << 2,\n} AcquireTerminalFlags;\n\nint acquire_terminal(const char *name, AcquireTerminalFlags flags, usec_t timeout);\nint release_terminal(void);\n\nint terminal_vhangup_fd(int fd);\nint terminal_vhangup(const char *name);\n\nint chvt(int vt);\n\nint read_one_char(FILE *f, char *ret, usec_t timeout, bool *need_nl);\nint ask_char(char *ret, const char *replies, const char *text, ...) _printf_(3, 4);\nint ask_string(char **ret, const char *text, ...) _printf_(2, 3);\n\nint vt_disallocate(const char *name);\n\nint resolve_dev_console(char **ret);\nint get_kernel_consoles(char ***ret);\nbool tty_is_vc(const char *tty);\nbool tty_is_vc_resolve(const char *tty);\nbool tty_is_console(const char *tty) _pure_;\nint vtnr_from_tty(const char *tty);\nconst char *default_term_for_tty(const char *tty);\n\nint make_console_stdio(void);\n\nint fd_columns(int fd);\nunsigned columns(void);\nint fd_lines(int fd);\nunsigned lines(void);\n\nvoid columns_lines_cache_reset(int _unused_ signum);\nvoid reset_terminal_feature_caches(void);\n\nbool on_tty(void);\nbool terminal_is_dumb(void);\nbool colors_enabled(void);\nbool underline_enabled(void);\nbool dev_console_colors_enabled(void);\n\n#define DEFINE_ANSI_FUNC(name, NAME)                            \\\n        static inline const char *ansi_##name(void) {           \\\n                return colors_enabled() ? ANSI_##NAME : \"\";     \\\n        }\n\n#define DEFINE_ANSI_FUNC_UNDERLINE(name, NAME, REPLACEMENT)             \\\n        static inline const char *ansi_##name(void) {                   \\\n                return underline_enabled() ? ANSI_##NAME :              \\\n                        colors_enabled() ? ANSI_##REPLACEMENT : \"\";     \\\n        }\n\nDEFINE_ANSI_FUNC(highlight,                  HIGHLIGHT);\nDEFINE_ANSI_FUNC(highlight_red,              HIGHLIGHT_RED);\nDEFINE_ANSI_FUNC(highlight_green,            HIGHLIGHT_GREEN);\nDEFINE_ANSI_FUNC(highlight_yellow,           HIGHLIGHT_YELLOW);\nDEFINE_ANSI_FUNC(highlight_blue,             HIGHLIGHT_BLUE);\nDEFINE_ANSI_FUNC(highlight_magenta,          HIGHLIGHT_MAGENTA);\nDEFINE_ANSI_FUNC(normal,                     NORMAL);\nDEFINE_ANSI_FUNC(grey,                       GREY);\n\nDEFINE_ANSI_FUNC_UNDERLINE(underline,                  UNDERLINE, NORMAL);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_underline,        HIGHLIGHT_UNDERLINE, HIGHLIGHT);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_red_underline,    HIGHLIGHT_RED_UNDERLINE, HIGHLIGHT_RED);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_green_underline,  HIGHLIGHT_GREEN_UNDERLINE, HIGHLIGHT_GREEN);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_yellow_underline, HIGHLIGHT_YELLOW_UNDERLINE, HIGHLIGHT_YELLOW);\nDEFINE_ANSI_FUNC_UNDERLINE(highlight_blue_underline,   HIGHLIGHT_BLUE_UNDERLINE, HIGHLIGHT_BLUE);\n\nint get_ctty_devnr(pid_t pid, dev_t *d);\nint get_ctty(pid_t, dev_t *_devnr, char **r);\n\nint getttyname_malloc(int fd, char **r);\nint getttyname_harder(int fd, char **r);\n\nint ptsname_malloc(int fd, char **ret);\nint ptsname_namespace(int pty, char **ret);\n\nint openpt_in_namespace(pid_t pid, int flags);\nint open_terminal_in_namespace(pid_t pid, const char *name, int mode);\n\nint vt_default_utf8(void);\nint vt_verify_kbmode(int fd);\nint vt_reset_keyboard(int fd);\nint vt_restore(int fd);\nint vt_release(int fd, bool restore_vt);\n\nvoid get_log_colors(int priority, const char **on, const char **off, const char **highlight);\n", "/* SPDX-License-Identifier: LGPL-2.1+ */\n/***\n  Copyright \u00a9 2016 Michal Soltys <soltys@ziu.info>\n***/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/kd.h>\n#include <linux/tiocl.h>\n#include <linux/vt.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sysexits.h>\n#include <termios.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"env-file.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"io-util.h\"\n#include \"locale-util.h\"\n#include \"log.h\"\n#include \"proc-cmdline.h\"\n#include \"process-util.h\"\n#include \"signal-util.h\"\n#include \"stdio-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n#include \"util.h\"\n#include \"virt.h\"\n\nstatic int verify_vc_device(int fd) {\n        unsigned char data[] = {\n                TIOCL_GETFGCONSOLE,\n        };\n\n        int r;\n\n        r = ioctl(fd, TIOCLINUX, data);\n        if (r < 0)\n                return -errno;\n\n        return r;\n}\n\nstatic int verify_vc_allocation(unsigned idx) {\n        char vcname[sizeof(\"/dev/vcs\") + DECIMAL_STR_MAX(unsigned) - 2];\n\n        xsprintf(vcname, \"/dev/vcs%u\", idx);\n\n        if (access(vcname, F_OK) < 0)\n                return -errno;\n\n        return 0;\n}\n\nstatic int verify_vc_allocation_byfd(int fd) {\n        struct vt_stat vcs = {};\n\n        if (ioctl(fd, VT_GETSTATE, &vcs) < 0)\n                return -errno;\n\n        return verify_vc_allocation(vcs.v_active);\n}\n\nstatic int toggle_utf8(const char *name, int fd, bool utf8) {\n        int r;\n        struct termios tc = {};\n\n        assert(name);\n\n        r = vt_verify_kbmode(fd);\n        if (r == -EBUSY) {\n                log_warning_errno(r, \"Virtual console %s is not in K_XLATE or K_UNICODE: %m\", name);\n                return 0;\n        } else if (r < 0)\n                return log_warning_errno(r, \"Failed to verify kbdmode on %s: %m\", name);\n\n        r = ioctl(fd, KDSKBMODE, utf8 ? K_UNICODE : K_XLATE);\n        if (r < 0)\n                return log_warning_errno(errno, \"Failed to %s UTF-8 kbdmode on %s: %m\", enable_disable(utf8), name);\n\n        r = loop_write(fd, utf8 ? \"\\033%G\" : \"\\033%@\", 3, false);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to %s UTF-8 term processing on %s: %m\", enable_disable(utf8), name);\n\n        r = tcgetattr(fd, &tc);\n        if (r >= 0) {\n                SET_FLAG(tc.c_iflag, IUTF8, utf8);\n                r = tcsetattr(fd, TCSANOW, &tc);\n        }\n        if (r < 0)\n                return log_warning_errno(errno, \"Failed to %s iutf8 flag on %s: %m\", enable_disable(utf8), name);\n\n        log_debug(\"UTF-8 kbdmode %sd on %s\", enable_disable(utf8), name);\n        return 0;\n}\n\nstatic int toggle_utf8_sysfs(bool utf8) {\n        int r;\n\n        r = write_string_file(\"/sys/module/vt/parameters/default_utf8\", one_zero(utf8), WRITE_STRING_FILE_DISABLE_BUFFER);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to %s sysfs UTF-8 flag: %m\", enable_disable(utf8));\n\n        log_debug(\"Sysfs UTF-8 flag %sd\", enable_disable(utf8));\n        return 0;\n}\n\nstatic int keyboard_load_and_wait(const char *vc, const char *map, const char *map_toggle, bool utf8) {\n        const char *args[8];\n        unsigned i = 0;\n        pid_t pid;\n        int r;\n\n        /* An empty map means kernel map */\n        if (isempty(map))\n                return 0;\n\n        args[i++] = KBD_LOADKEYS;\n        args[i++] = \"-q\";\n        args[i++] = \"-C\";\n        args[i++] = vc;\n        if (utf8)\n                args[i++] = \"-u\";\n        args[i++] = map;\n        if (map_toggle)\n                args[i++] = map_toggle;\n        args[i++] = NULL;\n\n        if (DEBUG_LOGGING) {\n                _cleanup_free_ char *cmd;\n\n                cmd = strv_join((char**) args, \" \");\n                log_debug(\"Executing \\\"%s\\\"...\", strnull(cmd));\n        }\n\n        r = safe_fork(\"(loadkeys)\", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_RLIMIT_NOFILE_SAFE|FORK_LOG, &pid);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                execv(args[0], (char **) args);\n                _exit(EXIT_FAILURE);\n        }\n\n        return wait_for_terminate_and_check(KBD_LOADKEYS, pid, WAIT_LOG);\n}\n\nstatic int font_load_and_wait(const char *vc, const char *font, const char *map, const char *unimap) {\n        const char *args[9];\n        unsigned i = 0;\n        pid_t pid;\n        int r;\n\n        /* Any part can be set independently */\n        if (isempty(font) && isempty(map) && isempty(unimap))\n                return 0;\n\n        args[i++] = KBD_SETFONT;\n        args[i++] = \"-C\";\n        args[i++] = vc;\n        if (!isempty(map)) {\n                args[i++] = \"-m\";\n                args[i++] = map;\n        }\n        if (!isempty(unimap)) {\n                args[i++] = \"-u\";\n                args[i++] = unimap;\n        }\n        if (!isempty(font))\n                args[i++] = font;\n        args[i++] = NULL;\n\n        if (DEBUG_LOGGING) {\n                _cleanup_free_ char *cmd;\n\n                cmd = strv_join((char**) args, \" \");\n                log_debug(\"Executing \\\"%s\\\"...\", strnull(cmd));\n        }\n\n        r = safe_fork(\"(setfont)\", FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_RLIMIT_NOFILE_SAFE|FORK_LOG, &pid);\n        if (r < 0)\n                return r;\n        if (r == 0) {\n                execv(args[0], (char **) args);\n                _exit(EXIT_FAILURE);\n        }\n\n        return wait_for_terminate_and_check(KBD_SETFONT, pid, WAIT_LOG);\n}\n\n/*\n * A newly allocated VT uses the font from the source VT. Here\n * we update all possibly already allocated VTs with the configured\n * font. It also allows to restart systemd-vconsole-setup.service,\n * to apply a new font to all VTs.\n *\n * We also setup per-console utf8 related stuff: kbdmode, term\n * processing, stty iutf8.\n */\nstatic void setup_remaining_vcs(int src_fd, unsigned src_idx, bool utf8) {\n        struct console_font_op cfo = {\n                .op = KD_FONT_OP_GET,\n                .width = UINT_MAX, .height = UINT_MAX,\n                .charcount = UINT_MAX,\n        };\n        struct unimapinit adv = {};\n        struct unimapdesc unimapd;\n        _cleanup_free_ struct unipair* unipairs = NULL;\n        _cleanup_free_ void *fontbuf = NULL;\n        unsigned i;\n        int r;\n\n        unipairs = new(struct unipair, USHRT_MAX);\n        if (!unipairs) {\n                log_oom();\n                return;\n        }\n\n        /* get metadata of the current font (width, height, count) */\n        r = ioctl(src_fd, KDFONTOP, &cfo);\n        if (r < 0)\n                log_warning_errno(errno, \"KD_FONT_OP_GET failed while trying to get the font metadata: %m\");\n        else {\n                /* verify parameter sanity first */\n                if (cfo.width > 32 || cfo.height > 32 || cfo.charcount > 512)\n                        log_warning(\"Invalid font metadata - width: %u (max 32), height: %u (max 32), count: %u (max 512)\",\n                                    cfo.width, cfo.height, cfo.charcount);\n                else {\n                        /*\n                         * Console fonts supported by the kernel are limited in size to 32 x 32 and maximum 512\n                         * characters. Thus with 1 bit per pixel it requires up to 65536 bytes. The height always\n                         * requires 32 per glyph, regardless of the actual height - see the comment above #define\n                         * max_font_size 65536 in drivers/tty/vt/vt.c for more details.\n                         */\n                        fontbuf = malloc_multiply((cfo.width + 7) / 8 * 32, cfo.charcount);\n                        if (!fontbuf) {\n                                log_oom();\n                                return;\n                        }\n                        /* get fonts from the source console */\n                        cfo.data = fontbuf;\n                        r = ioctl(src_fd, KDFONTOP, &cfo);\n                        if (r < 0)\n                                log_warning_errno(errno, \"KD_FONT_OP_GET failed while trying to read the font data: %m\");\n                        else {\n                                unimapd.entries  = unipairs;\n                                unimapd.entry_ct = USHRT_MAX;\n                                r = ioctl(src_fd, GIO_UNIMAP, &unimapd);\n                                if (r < 0)\n                                        log_warning_errno(errno, \"GIO_UNIMAP failed while trying to read unicode mappings: %m\");\n                                else\n                                        cfo.op = KD_FONT_OP_SET;\n                        }\n                }\n        }\n\n        if (cfo.op != KD_FONT_OP_SET)\n                log_warning(\"Fonts will not be copied to remaining consoles\");\n\n        for (i = 1; i <= 63; i++) {\n                char ttyname[sizeof(\"/dev/tty63\")];\n                _cleanup_close_ int fd_d = -1;\n\n                if (i == src_idx || verify_vc_allocation(i) < 0)\n                        continue;\n\n                /* try to open terminal */\n                xsprintf(ttyname, \"/dev/tty%u\", i);\n                fd_d = open_terminal(ttyname, O_RDWR|O_CLOEXEC|O_NOCTTY);\n                if (fd_d < 0) {\n                        log_warning_errno(fd_d, \"Unable to open tty%u, fonts will not be copied: %m\", i);\n                        continue;\n                }\n\n                if (vt_verify_kbmode(fd_d) < 0)\n                        continue;\n\n                toggle_utf8(ttyname, fd_d, utf8);\n\n                if (cfo.op != KD_FONT_OP_SET)\n                        continue;\n\n                r = ioctl(fd_d, KDFONTOP, &cfo);\n                if (r < 0) {\n                        int last_errno, mode;\n\n                        /* The fonts couldn't have been copied. It might be due to the\n                         * terminal being in graphical mode. In this case the kernel\n                         * returns -EINVAL which is too generic for distinguishing this\n                         * specific case. So we need to retrieve the terminal mode and if\n                         * the graphical mode is in used, let's assume that something else\n                         * is using the terminal and the failure was expected as we\n                         * shouldn't have tried to copy the fonts. */\n\n                        last_errno = errno;\n                        if (ioctl(fd_d, KDGETMODE, &mode) >= 0 && mode != KD_TEXT)\n                                log_debug(\"KD_FONT_OP_SET skipped: tty%u is not in text mode\", i);\n                        else\n                                log_warning_errno(last_errno, \"KD_FONT_OP_SET failed, fonts will not be copied to tty%u: %m\", i);\n\n                        continue;\n                }\n\n                /*\n                 * copy unicode translation table unimapd is a ushort count and a pointer\n                 * to an array of struct unipair { ushort, ushort }\n                 */\n                r = ioctl(fd_d, PIO_UNIMAPCLR, &adv);\n                if (r < 0) {\n                        log_warning_errno(errno, \"PIO_UNIMAPCLR failed, unimaps might be incorrect for tty%u: %m\", i);\n                        continue;\n                }\n\n                r = ioctl(fd_d, PIO_UNIMAP, &unimapd);\n                if (r < 0) {\n                        log_warning_errno(errno, \"PIO_UNIMAP failed, unimaps might be incorrect for tty%u: %m\", i);\n                        continue;\n                }\n\n                log_debug(\"Font and unimap successfully copied to %s\", ttyname);\n        }\n}\n\nstatic int find_source_vc(char **ret_path, unsigned *ret_idx) {\n        _cleanup_free_ char *path = NULL;\n        int r, err = 0;\n        unsigned i;\n\n        path = new(char, sizeof(\"/dev/tty63\"));\n        if (!path)\n                return log_oom();\n\n        for (i = 1; i <= 63; i++) {\n                _cleanup_close_ int fd = -1;\n\n                r = verify_vc_allocation(i);\n                if (r < 0) {\n                        if (!err)\n                                err = -r;\n                        continue;\n                }\n\n                sprintf(path, \"/dev/tty%u\", i);\n                fd = open_terminal(path, O_RDWR|O_CLOEXEC|O_NOCTTY);\n                if (fd < 0) {\n                        if (!err)\n                                err = -fd;\n                        continue;\n                }\n                r = vt_verify_kbmode(fd);\n                if (r < 0) {\n                        if (!err)\n                                err = -r;\n                        continue;\n                }\n\n                /* all checks passed, return this one as a source console */\n                *ret_idx = i;\n                *ret_path = TAKE_PTR(path);\n                return TAKE_FD(fd);\n        }\n\n        return log_error_errno(err, \"No usable source console found: %m\");\n}\n\nstatic int verify_source_vc(char **ret_path, const char *src_vc) {\n        _cleanup_close_ int fd = -1;\n        char *path;\n        int r;\n\n        fd = open_terminal(src_vc, O_RDWR|O_CLOEXEC|O_NOCTTY);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to open %s: %m\", src_vc);\n\n        r = verify_vc_device(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Device %s is not a virtual console: %m\", src_vc);\n\n        r = verify_vc_allocation_byfd(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Virtual console %s is not allocated: %m\", src_vc);\n\n        r = vt_verify_kbmode(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Virtual console %s is not in K_XLATE or K_UNICODE: %m\", src_vc);\n\n        path = strdup(src_vc);\n        if (!path)\n                return log_oom();\n\n        *ret_path = path;\n        return TAKE_FD(fd);\n}\n\nint main(int argc, char **argv) {\n        _cleanup_free_ char\n                *vc = NULL,\n                *vc_keymap = NULL, *vc_keymap_toggle = NULL,\n                *vc_font = NULL, *vc_font_map = NULL, *vc_font_unimap = NULL;\n        _cleanup_close_ int fd = -1;\n        bool utf8, keyboard_ok;\n        unsigned idx = 0;\n        int r;\n\n        log_setup_service();\n\n        umask(0022);\n\n        if (argv[1])\n                fd = verify_source_vc(&vc, argv[1]);\n        else\n                fd = find_source_vc(&vc, &idx);\n        if (fd < 0)\n                return EXIT_FAILURE;\n\n        utf8 = is_locale_utf8();\n\n        r = parse_env_file(NULL, \"/etc/vconsole.conf\",\n                           \"KEYMAP\", &vc_keymap,\n                           \"KEYMAP_TOGGLE\", &vc_keymap_toggle,\n                           \"FONT\", &vc_font,\n                           \"FONT_MAP\", &vc_font_map,\n                           \"FONT_UNIMAP\", &vc_font_unimap);\n        if (r < 0 && r != -ENOENT)\n                log_warning_errno(r, \"Failed to read /etc/vconsole.conf: %m\");\n\n        /* Let the kernel command line override /etc/vconsole.conf */\n        r = proc_cmdline_get_key_many(\n                        PROC_CMDLINE_STRIP_RD_PREFIX,\n                        \"vconsole.keymap\", &vc_keymap,\n                        \"vconsole.keymap_toggle\", &vc_keymap_toggle,\n                        \"vconsole.font\", &vc_font,\n                        \"vconsole.font_map\", &vc_font_map,\n                        \"vconsole.font_unimap\", &vc_font_unimap,\n                        /* compatibility with obsolete multiple-dot scheme */\n                        \"vconsole.keymap.toggle\", &vc_keymap_toggle,\n                        \"vconsole.font.map\", &vc_font_map,\n                        \"vconsole.font.unimap\", &vc_font_unimap);\n        if (r < 0 && r != -ENOENT)\n                log_warning_errno(r, \"Failed to read /proc/cmdline: %m\");\n\n        (void) toggle_utf8_sysfs(utf8);\n        (void) toggle_utf8(vc, fd, utf8);\n\n        r = font_load_and_wait(vc, vc_font, vc_font_map, vc_font_unimap);\n        keyboard_ok = keyboard_load_and_wait(vc, vc_keymap, vc_keymap_toggle, utf8) == 0;\n\n        if (idx > 0) {\n                if (r == 0)\n                        setup_remaining_vcs(fd, idx, utf8);\n                else if (r == EX_OSERR)\n                        /* setfont returns EX_OSERR when ioctl(KDFONTOP/PIO_FONTX/PIO_FONTX) fails.\n                         * This might mean various things, but in particular lack of a graphical\n                         * console. Let's be generous and not treat this as an error. */\n                        log_notice(\"Setting fonts failed with a \\\"system error\\\", ignoring.\");\n                else\n                        log_warning(\"Setting source virtual console failed, ignoring remaining ones\");\n        }\n\n        return IN_SET(r, 0, EX_OSERR) && keyboard_ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"], "filenames": ["src/basic/terminal-util.c", "src/basic/terminal-util.h", "src/vconsole/vconsole-setup.c"], "buggy_code_start_loc": [1251, 158, 73], "buggy_code_end_loc": [1256, 158, 402], "fixing_code_start_loc": [1252, 159, 72], "fixing_code_end_loc": [1281, 160, 392], "type": "CWE-200", "message": "systemd 242 changes the VT1 mode upon a logout, which allows attackers to read cleartext passwords in certain circumstances, such as watching a shutdown, or using Ctrl-Alt-F1 and Ctrl-Alt-F2. This occurs because the KDGKBMODE (aka current keyboard mode) check is mishandled.", "other": {"cve": {"id": "CVE-2018-20839", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-17T04:29:00.933", "lastModified": "2022-02-20T06:10:25.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "systemd 242 changes the VT1 mode upon a logout, which allows attackers to read cleartext passwords in certain circumstances, such as watching a shutdown, or using Ctrl-Alt-F1 and Ctrl-Alt-F2. This occurs because the KDGKBMODE (aka current keyboard mode) check is mishandled."}, {"lang": "es", "value": "El systemd 242 cambia el VT1 mode al terminar la sesi\u00f3n, esto permite a los atacantes leer contrase\u00f1as de texto simple en algunas circunstancias, tales como ver un apagado o usar Ctrl-Alt-F1 y Ctrl-Alt-F2. Esto ocurre porque la comprobaci\u00f3n KDGKBMODE (tambi\u00e9n conocido como modo de teclado actual) es manejada incorrectamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:242:-:*:*:*:*:*:*", "matchCriteriaId": "A00408E2-96BE-44A7-A389-90C6F6DE8157"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:cn1610_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "EB30733E-68FC-49C4-86C0-7FEE75C366BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:cn1610:-:*:*:*:*:*:*:*", "matchCriteriaId": "6361DAC6-600F-4B15-8797-D67F298F46FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapprotect:-:*:*:*:*:*:*:*", "matchCriteriaId": "F74F467A-0C81-40D9-BA06-40FB8EF02C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/108389", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1803993", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/systemd/systemd/pull/12378", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf9fa47ab66495c78bb4120b0754dd9531ca2ff0430f6685ac9b07772@%3Cdev.mina.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190530-0002/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f"}}