{"buggy_code": ["/*\n *  TW5864 driver - video encoding functions\n *\n *  Copyright (C) 2016 Bluecherry, LLC <maintainers@bluecherrydvr.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n#include <linux/module.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"tw5864.h\"\n#include \"tw5864-reg.h\"\n\n#define QUANTIZATION_TABLE_LEN 96\n#define VLC_LOOKUP_TABLE_LEN 1024\n\nstatic const u16 forward_quantization_table[QUANTIZATION_TABLE_LEN] = {\n\t0x3333, 0x1f82, 0x3333, 0x1f82, 0x1f82, 0x147b, 0x1f82, 0x147b,\n\t0x3333, 0x1f82, 0x3333, 0x1f82, 0x1f82, 0x147b, 0x1f82, 0x147b,\n\t0x2e8c, 0x1d42, 0x2e8c, 0x1d42, 0x1d42, 0x1234, 0x1d42, 0x1234,\n\t0x2e8c, 0x1d42, 0x2e8c, 0x1d42, 0x1d42, 0x1234, 0x1d42, 0x1234,\n\t0x2762, 0x199a, 0x2762, 0x199a, 0x199a, 0x1062, 0x199a, 0x1062,\n\t0x2762, 0x199a, 0x2762, 0x199a, 0x199a, 0x1062, 0x199a, 0x1062,\n\t0x2492, 0x16c1, 0x2492, 0x16c1, 0x16c1, 0x0e3f, 0x16c1, 0x0e3f,\n\t0x2492, 0x16c1, 0x2492, 0x16c1, 0x16c1, 0x0e3f, 0x16c1, 0x0e3f,\n\t0x2000, 0x147b, 0x2000, 0x147b, 0x147b, 0x0d1b, 0x147b, 0x0d1b,\n\t0x2000, 0x147b, 0x2000, 0x147b, 0x147b, 0x0d1b, 0x147b, 0x0d1b,\n\t0x1c72, 0x11cf, 0x1c72, 0x11cf, 0x11cf, 0x0b4d, 0x11cf, 0x0b4d,\n\t0x1c72, 0x11cf, 0x1c72, 0x11cf, 0x11cf, 0x0b4d, 0x11cf, 0x0b4d\n};\n\nstatic const u16 inverse_quantization_table[QUANTIZATION_TABLE_LEN] = {\n\t0x800a, 0x800d, 0x800a, 0x800d, 0x800d, 0x8010, 0x800d, 0x8010,\n\t0x800a, 0x800d, 0x800a, 0x800d, 0x800d, 0x8010, 0x800d, 0x8010,\n\t0x800b, 0x800e, 0x800b, 0x800e, 0x800e, 0x8012, 0x800e, 0x8012,\n\t0x800b, 0x800e, 0x800b, 0x800e, 0x800e, 0x8012, 0x800e, 0x8012,\n\t0x800d, 0x8010, 0x800d, 0x8010, 0x8010, 0x8014, 0x8010, 0x8014,\n\t0x800d, 0x8010, 0x800d, 0x8010, 0x8010, 0x8014, 0x8010, 0x8014,\n\t0x800e, 0x8012, 0x800e, 0x8012, 0x8012, 0x8017, 0x8012, 0x8017,\n\t0x800e, 0x8012, 0x800e, 0x8012, 0x8012, 0x8017, 0x8012, 0x8017,\n\t0x8010, 0x8014, 0x8010, 0x8014, 0x8014, 0x8019, 0x8014, 0x8019,\n\t0x8010, 0x8014, 0x8010, 0x8014, 0x8014, 0x8019, 0x8014, 0x8019,\n\t0x8012, 0x8017, 0x8012, 0x8017, 0x8017, 0x801d, 0x8017, 0x801d,\n\t0x8012, 0x8017, 0x8012, 0x8017, 0x8017, 0x801d, 0x8017, 0x801d\n};\n\nstatic const u16 encoder_vlc_lookup_table[VLC_LOOKUP_TABLE_LEN] = {\n\t0x011, 0x000, 0x000, 0x000, 0x065, 0x021, 0x000, 0x000, 0x087, 0x064,\n\t0x031, 0x000, 0x097, 0x086, 0x075, 0x053, 0x0a7, 0x096, 0x085, 0x063,\n\t0x0b7, 0x0a6, 0x095, 0x074, 0x0df, 0x0b6, 0x0a5, 0x084, 0x0db, 0x0de,\n\t0x0b5, 0x094, 0x0d8, 0x0da, 0x0dd, 0x0a4, 0x0ef, 0x0ee, 0x0d9, 0x0b4,\n\t0x0eb, 0x0ea, 0x0ed, 0x0dc, 0x0ff, 0x0fe, 0x0e9, 0x0ec, 0x0fb, 0x0fa,\n\t0x0fd, 0x0e8, 0x10f, 0x0f1, 0x0f9, 0x0fc, 0x10b, 0x10e, 0x10d, 0x0f8,\n\t0x107, 0x10a, 0x109, 0x10c, 0x104, 0x106, 0x105, 0x108, 0x023, 0x000,\n\t0x000, 0x000, 0x06b, 0x022, 0x000, 0x000, 0x067, 0x057, 0x033, 0x000,\n\t0x077, 0x06a, 0x069, 0x045, 0x087, 0x066, 0x065, 0x044, 0x084, 0x076,\n\t0x075, 0x056, 0x097, 0x086, 0x085, 0x068, 0x0bf, 0x096, 0x095, 0x064,\n\t0x0bb, 0x0be, 0x0bd, 0x074, 0x0cf, 0x0ba, 0x0b9, 0x094, 0x0cb, 0x0ce,\n\t0x0cd, 0x0bc, 0x0c8, 0x0ca, 0x0c9, 0x0b8, 0x0df, 0x0de, 0x0dd, 0x0cc,\n\t0x0db, 0x0da, 0x0d9, 0x0dc, 0x0d7, 0x0eb, 0x0d6, 0x0d8, 0x0e9, 0x0e8,\n\t0x0ea, 0x0d1, 0x0e7, 0x0e6, 0x0e5, 0x0e4, 0x04f, 0x000, 0x000, 0x000,\n\t0x06f, 0x04e, 0x000, 0x000, 0x06b, 0x05f, 0x04d, 0x000, 0x068, 0x05c,\n\t0x05e, 0x04c, 0x07f, 0x05a, 0x05b, 0x04b, 0x07b, 0x058, 0x059, 0x04a,\n\t0x079, 0x06e, 0x06d, 0x049, 0x078, 0x06a, 0x069, 0x048, 0x08f, 0x07e,\n\t0x07d, 0x05d, 0x08b, 0x08e, 0x07a, 0x06c, 0x09f, 0x08a, 0x08d, 0x07c,\n\t0x09b, 0x09e, 0x089, 0x08c, 0x098, 0x09a, 0x09d, 0x088, 0x0ad, 0x097,\n\t0x099, 0x09c, 0x0a9, 0x0ac, 0x0ab, 0x0aa, 0x0a5, 0x0a8, 0x0a7, 0x0a6,\n\t0x0a1, 0x0a4, 0x0a3, 0x0a2, 0x021, 0x000, 0x000, 0x000, 0x067, 0x011,\n\t0x000, 0x000, 0x064, 0x066, 0x031, 0x000, 0x063, 0x073, 0x072, 0x065,\n\t0x062, 0x083, 0x082, 0x070, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x011, 0x010,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x011, 0x021, 0x020, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x023, 0x022, 0x021, 0x020, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x023, 0x022, 0x021, 0x031,\n\t0x030, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x023, 0x022, 0x033, 0x032, 0x031, 0x030, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x023, 0x030,\n\t0x031, 0x033, 0x032, 0x035, 0x034, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x037, 0x036, 0x035, 0x034, 0x033, 0x032,\n\t0x031, 0x041, 0x051, 0x061, 0x071, 0x081, 0x091, 0x0a1, 0x0b1, 0x000,\n\t0x002, 0x000, 0x0e4, 0x011, 0x0f4, 0x002, 0x024, 0x003, 0x005, 0x012,\n\t0x034, 0x013, 0x065, 0x024, 0x013, 0x063, 0x015, 0x022, 0x075, 0x034,\n\t0x044, 0x023, 0x023, 0x073, 0x054, 0x033, 0x033, 0x004, 0x043, 0x014,\n\t0x011, 0x043, 0x014, 0x001, 0x025, 0x015, 0x035, 0x025, 0x064, 0x055,\n\t0x045, 0x035, 0x074, 0x065, 0x085, 0x0d5, 0x012, 0x095, 0x055, 0x045,\n\t0x095, 0x0e5, 0x084, 0x075, 0x022, 0x0a5, 0x094, 0x085, 0x032, 0x0b5,\n\t0x003, 0x0c5, 0x001, 0x044, 0x0a5, 0x032, 0x0b5, 0x094, 0x0c5, 0x0a4,\n\t0x0a4, 0x054, 0x0d5, 0x0b4, 0x0b4, 0x064, 0x0f5, 0x0f5, 0x053, 0x0d4,\n\t0x0e5, 0x0c4, 0x105, 0x105, 0x0c4, 0x074, 0x063, 0x0e4, 0x0d4, 0x084,\n\t0x073, 0x0f4, 0x004, 0x005, 0x000, 0x053, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x011, 0x021, 0x031, 0x030, 0x011, 0x021, 0x020, 0x000,\n\t0x011, 0x010, 0x000, 0x000, 0x011, 0x033, 0x032, 0x043, 0x042, 0x053,\n\t0x052, 0x063, 0x062, 0x073, 0x072, 0x083, 0x082, 0x093, 0x092, 0x091,\n\t0x037, 0x036, 0x035, 0x034, 0x033, 0x045, 0x044, 0x043, 0x042, 0x053,\n\t0x052, 0x063, 0x062, 0x061, 0x060, 0x000, 0x045, 0x037, 0x036, 0x035,\n\t0x044, 0x043, 0x034, 0x033, 0x042, 0x053, 0x052, 0x061, 0x051, 0x060,\n\t0x000, 0x000, 0x053, 0x037, 0x045, 0x044, 0x036, 0x035, 0x034, 0x043,\n\t0x033, 0x042, 0x052, 0x051, 0x050, 0x000, 0x000, 0x000, 0x045, 0x044,\n\t0x043, 0x037, 0x036, 0x035, 0x034, 0x033, 0x042, 0x051, 0x041, 0x050,\n\t0x000, 0x000, 0x000, 0x000, 0x061, 0x051, 0x037, 0x036, 0x035, 0x034,\n\t0x033, 0x032, 0x041, 0x031, 0x060, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x061, 0x051, 0x035, 0x034, 0x033, 0x023, 0x032, 0x041, 0x031, 0x060,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x061, 0x041, 0x051, 0x033,\n\t0x023, 0x022, 0x032, 0x031, 0x060, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x061, 0x060, 0x041, 0x023, 0x022, 0x031, 0x021, 0x051,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x051, 0x050,\n\t0x031, 0x023, 0x022, 0x021, 0x041, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x040, 0x041, 0x031, 0x032, 0x011, 0x033,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x040, 0x041, 0x021, 0x011, 0x031, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x030, 0x031, 0x011, 0x021,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x020, 0x021, 0x011, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x010, 0x011,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000\n};\n\nstatic const unsigned int lambda_lookup_table[] = {\n\t0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,\n\t0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,\n\t0x0040, 0x0040, 0x0040, 0x0040, 0x0060, 0x0060, 0x0060, 0x0080,\n\t0x0080, 0x0080, 0x00a0, 0x00c0, 0x00c0, 0x00e0, 0x0100, 0x0120,\n\t0x0140, 0x0160, 0x01a0, 0x01c0, 0x0200, 0x0240, 0x0280, 0x02e0,\n\t0x0320, 0x03a0, 0x0400, 0x0480, 0x0500, 0x05a0, 0x0660, 0x0720,\n\t0x0800, 0x0900, 0x0a20, 0x0b60\n};\n\nstatic const unsigned int intra4x4_lambda3[] = {\n\t1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 2, 2, 2, 3, 3, 3, 4,\n\t4, 4, 5, 6, 6, 7, 8, 9,\n\t10, 11, 13, 14, 16, 18, 20, 23,\n\t25, 29, 32, 36, 40, 45, 51, 57,\n\t64, 72, 81, 91\n};\n\nstatic v4l2_std_id tw5864_get_v4l2_std(enum tw5864_vid_std std);\nstatic enum tw5864_vid_std tw5864_from_v4l2_std(v4l2_std_id v4l2_std);\n\nstatic void tw5864_handle_frame_task(unsigned long data);\nstatic void tw5864_handle_frame(struct tw5864_h264_frame *frame);\nstatic void tw5864_frame_interval_set(struct tw5864_input *input);\n\nstatic int tw5864_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,\n\t\t\t      unsigned int *num_planes, unsigned int sizes[],\n\t\t\t      struct device *alloc_ctxs[])\n{\n\tif (*num_planes)\n\t\treturn sizes[0] < H264_VLC_BUF_SIZE ? -EINVAL : 0;\n\n\tsizes[0] = H264_VLC_BUF_SIZE;\n\t*num_planes = 1;\n\n\treturn 0;\n}\n\nstatic void tw5864_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tw5864_input *dev = vb2_get_drv_priv(vq);\n\tstruct tw5864_buf *buf = container_of(vbuf, struct tw5864_buf, vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tlist_add_tail(&buf->list, &dev->active);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int tw5864_input_std_get(struct tw5864_input *input,\n\t\t\t\tenum tw5864_vid_std *std)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tu8 std_reg = tw_indir_readb(TW5864_INDIR_VIN_E(input->nr));\n\n\t*std = (std_reg & 0x70) >> 4;\n\n\tif (std_reg & 0x80) {\n\t\tdev_dbg(&dev->pci->dev,\n\t\t\t\"Video format detection is in progress, please wait\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int tw5864_enable_input(struct tw5864_input *input)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tint nr = input->nr;\n\tunsigned long flags;\n\tint d1_width = 720;\n\tint d1_height;\n\tint frame_width_bus_value = 0;\n\tint frame_height_bus_value = 0;\n\tint reg_frame_bus = 0x1c;\n\tint fmt_reg_value = 0;\n\tint downscale_enabled = 0;\n\n\tdev_dbg(&dev->pci->dev, \"Enabling channel %d\\n\", nr);\n\n\tinput->frame_seqno = 0;\n\tinput->frame_gop_seqno = 0;\n\tinput->h264_idr_pic_id = 0;\n\n\tinput->reg_dsp_qp = input->qp;\n\tinput->reg_dsp_ref_mvp_lambda = lambda_lookup_table[input->qp];\n\tinput->reg_dsp_i4x4_weight = intra4x4_lambda3[input->qp];\n\tinput->reg_emu = TW5864_EMU_EN_LPF | TW5864_EMU_EN_BHOST\n\t\t| TW5864_EMU_EN_SEN | TW5864_EMU_EN_ME | TW5864_EMU_EN_DDR;\n\tinput->reg_dsp = nr /* channel id */\n\t\t| TW5864_DSP_CHROM_SW\n\t\t| ((0xa << 8) & TW5864_DSP_MB_DELAY)\n\t\t;\n\n\tinput->resolution = D1;\n\n\td1_height = (input->std == STD_NTSC) ? 480 : 576;\n\n\tinput->width = d1_width;\n\tinput->height = d1_height;\n\n\tinput->reg_interlacing = 0x4;\n\n\tswitch (input->resolution) {\n\tcase D1:\n\t\tframe_width_bus_value = 0x2cf;\n\t\tframe_height_bus_value = input->height - 1;\n\t\treg_frame_bus = 0x1c;\n\t\tfmt_reg_value = 0;\n\t\tdownscale_enabled = 0;\n\t\tinput->reg_dsp_codec |= TW5864_CIF_MAP_MD | TW5864_HD1_MAP_MD;\n\t\tinput->reg_emu |= TW5864_DSP_FRAME_TYPE_D1;\n\t\tinput->reg_interlacing = TW5864_DI_EN | TW5864_DSP_INTER_ST;\n\n\t\ttw_setl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\t\tbreak;\n\tcase HD1:\n\t\tinput->height /= 2;\n\t\tinput->width /= 2;\n\t\tframe_width_bus_value = 0x2cf;\n\t\tframe_height_bus_value = input->height * 2 - 1;\n\t\treg_frame_bus = 0x1c;\n\t\tfmt_reg_value = 0;\n\t\tdownscale_enabled = 0;\n\t\tinput->reg_dsp_codec |= TW5864_HD1_MAP_MD;\n\t\tinput->reg_emu |= TW5864_DSP_FRAME_TYPE_D1;\n\n\t\ttw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\n\t\tbreak;\n\tcase CIF:\n\t\tinput->height /= 4;\n\t\tinput->width /= 2;\n\t\tframe_width_bus_value = 0x15f;\n\t\tframe_height_bus_value = input->height * 2 - 1;\n\t\treg_frame_bus = 0x07;\n\t\tfmt_reg_value = 1;\n\t\tdownscale_enabled = 1;\n\t\tinput->reg_dsp_codec |= TW5864_CIF_MAP_MD;\n\n\t\ttw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\t\tbreak;\n\tcase QCIF:\n\t\tinput->height /= 4;\n\t\tinput->width /= 4;\n\t\tframe_width_bus_value = 0x15f;\n\t\tframe_height_bus_value = input->height * 2 - 1;\n\t\treg_frame_bus = 0x07;\n\t\tfmt_reg_value = 1;\n\t\tdownscale_enabled = 1;\n\t\tinput->reg_dsp_codec |= TW5864_CIF_MAP_MD;\n\n\t\ttw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\t\tbreak;\n\t}\n\n\t/* analog input width / 4 */\n\ttw_indir_writeb(TW5864_INDIR_IN_PIC_WIDTH(nr), d1_width / 4);\n\ttw_indir_writeb(TW5864_INDIR_IN_PIC_HEIGHT(nr), d1_height / 4);\n\n\t/* output width / 4 */\n\ttw_indir_writeb(TW5864_INDIR_OUT_PIC_WIDTH(nr), input->width / 4);\n\ttw_indir_writeb(TW5864_INDIR_OUT_PIC_HEIGHT(nr), input->height / 4);\n\n\t/*\n\t * Crop width from 720 to 704.\n\t * Above register settings need value 720 involved.\n\t */\n\tinput->width = 704;\n\ttw_indir_writeb(TW5864_INDIR_CROP_ETC,\n\t\t\ttw_indir_readb(TW5864_INDIR_CROP_ETC) |\n\t\t\tTW5864_INDIR_CROP_ETC_CROP_EN);\n\n\ttw_writel(TW5864_DSP_PIC_MAX_MB,\n\t\t  ((input->width / 16) << 8) | (input->height / 16));\n\n\ttw_writel(TW5864_FRAME_WIDTH_BUS_A(nr),\n\t\t  frame_width_bus_value);\n\ttw_writel(TW5864_FRAME_WIDTH_BUS_B(nr),\n\t\t  frame_width_bus_value);\n\ttw_writel(TW5864_FRAME_HEIGHT_BUS_A(nr),\n\t\t  frame_height_bus_value);\n\ttw_writel(TW5864_FRAME_HEIGHT_BUS_B(nr),\n\t\t  (frame_height_bus_value + 1) / 2 - 1);\n\n\ttw5864_frame_interval_set(input);\n\n\tif (downscale_enabled)\n\t\ttw_setl(TW5864_H264EN_CH_DNS, 1 << nr);\n\n\ttw_mask_shift_writel(TW5864_H264EN_CH_FMT_REG1, 0x3, 2 * nr,\n\t\t\t     fmt_reg_value);\n\n\ttw_mask_shift_writel((nr < 2\n\t\t\t      ? TW5864_H264EN_RATE_MAX_LINE_REG1\n\t\t\t      : TW5864_H264EN_RATE_MAX_LINE_REG2),\n\t\t\t     0x1f, 5 * (nr % 2),\n\t\t\t     input->std == STD_NTSC ? 29 : 24);\n\n\ttw_mask_shift_writel((nr < 2) ? TW5864_FRAME_BUS1 :\n\t\t\t     TW5864_FRAME_BUS2, 0xff, (nr % 2) * 8,\n\t\t\t     reg_frame_bus);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tinput->enabled = 1;\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\treturn 0;\n}\n\nvoid tw5864_request_encoded_frame(struct tw5864_input *input)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tu32 enc_buf_id_new;\n\n\ttw_setl(TW5864_DSP_CODEC, TW5864_CIF_MAP_MD | TW5864_HD1_MAP_MD);\n\ttw_writel(TW5864_EMU, input->reg_emu);\n\ttw_writel(TW5864_INTERLACING, input->reg_interlacing);\n\ttw_writel(TW5864_DSP, input->reg_dsp);\n\n\ttw_writel(TW5864_DSP_QP, input->reg_dsp_qp);\n\ttw_writel(TW5864_DSP_REF_MVP_LAMBDA, input->reg_dsp_ref_mvp_lambda);\n\ttw_writel(TW5864_DSP_I4x4_WEIGHT, input->reg_dsp_i4x4_weight);\n\ttw_mask_shift_writel(TW5864_DSP_INTRA_MODE, TW5864_DSP_INTRA_MODE_MASK,\n\t\t\t     TW5864_DSP_INTRA_MODE_SHIFT,\n\t\t\t     TW5864_DSP_INTRA_MODE_16x16);\n\n\tif (input->frame_gop_seqno == 0) {\n\t\t/* Produce I-frame */\n\t\ttw_writel(TW5864_MOTION_SEARCH_ETC, TW5864_INTRA_EN);\n\t\tinput->h264_idr_pic_id++;\n\t\tinput->h264_idr_pic_id &= TW5864_DSP_REF_FRM;\n\t} else {\n\t\t/* Produce P-frame */\n\t\ttw_writel(TW5864_MOTION_SEARCH_ETC, TW5864_INTRA_EN |\n\t\t\t  TW5864_ME_EN | BIT(5) /* SRCH_OPT default */);\n\t}\n\ttw5864_prepare_frame_headers(input);\n\ttw_writel(TW5864_VLC,\n\t\t  TW5864_VLC_PCI_SEL |\n\t\t  ((input->tail_nb_bits + 24) << TW5864_VLC_BIT_ALIGN_SHIFT) |\n\t\t  input->reg_dsp_qp);\n\n\tenc_buf_id_new = tw_mask_shift_readl(TW5864_ENC_BUF_PTR_REC1, 0x3,\n\t\t\t\t\t     2 * input->nr);\n\ttw_writel(TW5864_DSP_ENC_ORG_PTR_REG,\n\t\t  enc_buf_id_new << TW5864_DSP_ENC_ORG_PTR_SHIFT);\n\ttw_writel(TW5864_DSP_ENC_REC,\n\t\t  enc_buf_id_new << 12 | ((enc_buf_id_new + 3) & 3));\n\n\ttw_writel(TW5864_SLICE, TW5864_START_NSLICE);\n\ttw_writel(TW5864_SLICE, 0);\n}\n\nstatic int tw5864_disable_input(struct tw5864_input *input)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tunsigned long flags;\n\n\tdev_dbg(&dev->pci->dev, \"Disabling channel %d\\n\", input->nr);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tinput->enabled = 0;\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\treturn 0;\n}\n\nstatic int tw5864_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct tw5864_input *input = vb2_get_drv_priv(q);\n\tint ret;\n\n\tret = tw5864_enable_input(input);\n\tif (!ret)\n\t\treturn 0;\n\n\twhile (!list_empty(&input->active)) {\n\t\tstruct tw5864_buf *buf = list_entry(input->active.next,\n\t\t\t\t\t\t    struct tw5864_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\treturn ret;\n}\n\nstatic void tw5864_stop_streaming(struct vb2_queue *q)\n{\n\tunsigned long flags;\n\tstruct tw5864_input *input = vb2_get_drv_priv(q);\n\n\ttw5864_disable_input(input);\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tif (input->vb) {\n\t\tvb2_buffer_done(&input->vb->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tinput->vb = NULL;\n\t}\n\twhile (!list_empty(&input->active)) {\n\t\tstruct tw5864_buf *buf = list_entry(input->active.next,\n\t\t\t\t\t\t    struct tw5864_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&input->slock, flags);\n}\n\nstatic const struct vb2_ops tw5864_video_qops = {\n\t.queue_setup = tw5864_queue_setup,\n\t.buf_queue = tw5864_buf_queue,\n\t.start_streaming = tw5864_start_streaming,\n\t.stop_streaming = tw5864_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int tw5864_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct tw5864_input *input =\n\t\tcontainer_of(ctrl->handler, struct tw5864_input, hdl);\n\tstruct tw5864_dev *dev = input->root;\n\tunsigned long flags;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_A_BRIGHT(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_7_HUE(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_9_CNTRST(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_B_SAT_U(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_C_SAT_V(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tinput->gop = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\n\t\tspin_lock_irqsave(&input->slock, flags);\n\t\tinput->qp = ctrl->val;\n\t\tinput->reg_dsp_qp = input->qp;\n\t\tinput->reg_dsp_ref_mvp_lambda = lambda_lookup_table[input->qp];\n\t\tinput->reg_dsp_i4x4_weight = intra4x4_lambda3[input->qp];\n\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD:\n\t\tmemset(input->md_threshold_grid_values, ctrl->val,\n\t\t       sizeof(input->md_threshold_grid_values));\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_MODE:\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_THRESHOLD_GRID:\n\t\t/* input->md_threshold_grid_ctrl->p_new.p_u16 contains data */\n\t\tmemcpy(input->md_threshold_grid_values,\n\t\t       input->md_threshold_grid_ctrl->p_new.p_u16,\n\t\t       sizeof(input->md_threshold_grid_values));\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int tw5864_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\tf->fmt.pix.width = 704;\n\tswitch (input->std) {\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\tcase STD_NTSC:\n\t\tf->fmt.pix.height = 480;\n\t\tbreak;\n\tcase STD_PAL:\n\tcase STD_SECAM:\n\t\tf->fmt.pix.height = 576;\n\t\tbreak;\n\t}\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_H264;\n\tf->fmt.pix.sizeimage = H264_VLC_BUF_SIZE;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int tw5864_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tu8 indir_0x000 = tw_indir_readb(TW5864_INDIR_VIN_0(input->nr));\n\tu8 indir_0x00d = tw_indir_readb(TW5864_INDIR_VIN_D(input->nr));\n\tu8 v1 = indir_0x000;\n\tu8 v2 = indir_0x00d;\n\n\tif (i->index)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tsnprintf(i->name, sizeof(i->name), \"Encoder %d\", input->nr);\n\ti->std = TW5864_NORMS;\n\tif (v1 & (1 << 7))\n\t\ti->status |= V4L2_IN_ST_NO_SYNC;\n\tif (!(v1 & (1 << 6)))\n\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\tif (v1 & (1 << 2))\n\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\tif (v1 & (1 << 1))\n\t\ti->status |= V4L2_IN_ST_NO_COLOR;\n\tif (v2 & (1 << 2))\n\t\ti->status |= V4L2_IN_ST_MACROVISION;\n\n\treturn 0;\n}\n\nstatic int tw5864_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int tw5864_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int tw5864_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"tw5864\", sizeof(cap->driver));\n\tsnprintf(cap->card, sizeof(cap->card), \"TW5864 Encoder %d\",\n\t\t input->nr);\n\tsprintf(cap->bus_info, \"PCI:%s\", pci_name(input->root->pci));\n\treturn 0;\n}\n\nstatic int tw5864_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tenum tw5864_vid_std tw_std;\n\tint ret;\n\n\tret = tw5864_input_std_get(input, &tw_std);\n\tif (ret)\n\t\treturn ret;\n\t*std = tw5864_get_v4l2_std(tw_std);\n\n\treturn 0;\n}\n\nstatic int tw5864_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\t*std = input->v4l2_std;\n\treturn 0;\n}\n\nstatic int tw5864_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tinput->v4l2_std = std;\n\tinput->std = tw5864_from_v4l2_std(std);\n\ttw_indir_writeb(TW5864_INDIR_VIN_E(input->nr), input->std);\n\treturn 0;\n}\n\nstatic int tw5864_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_H264;\n\n\treturn 0;\n}\n\nstatic int tw5864_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_MOTION_DET:\n\t\t/*\n\t\t * Allow for up to 30 events (1 second for NTSC) to be stored.\n\t\t */\n\t\treturn v4l2_event_subscribe(fh, sub, 30, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic void tw5864_frame_interval_set(struct tw5864_input *input)\n{\n\t/*\n\t * This register value seems to follow such approach: In each second\n\t * interval, when processing Nth frame, it checks Nth bit of register\n\t * value and, if the bit is 1, it processes the frame, otherwise the\n\t * frame is discarded.\n\t * So unary representation would work, but more or less equal gaps\n\t * between the frames should be preserved.\n\t *\n\t * For 1 FPS - 0x00000001\n\t * 00000000 00000000 00000000 00000001\n\t *\n\t * For max FPS - set all 25/30 lower bits:\n\t * 00111111 11111111 11111111 11111111 (NTSC)\n\t * 00000001 11111111 11111111 11111111 (PAL)\n\t *\n\t * For half of max FPS - use such pattern:\n\t * 00010101 01010101 01010101 01010101 (NTSC)\n\t * 00000001 01010101 01010101 01010101 (PAL)\n\t *\n\t * Et cetera.\n\t *\n\t * The value supplied to hardware is capped by mask of 25/30 lower bits.\n\t */\n\tstruct tw5864_dev *dev = input->root;\n\tu32 unary_framerate = 0;\n\tint shift = 0;\n\tint std_max_fps = input->std == STD_NTSC ? 30 : 25;\n\n\tfor (shift = 0; shift < std_max_fps; shift += input->frame_interval)\n\t\tunary_framerate |= 0x00000001 << shift;\n\n\ttw_writel(TW5864_H264EN_RATE_CNTL_LO_WORD(input->nr, 0),\n\t\t  unary_framerate >> 16);\n\ttw_writel(TW5864_H264EN_RATE_CNTL_HI_WORD(input->nr, 0),\n\t\t  unary_framerate & 0xffff);\n}\n\nstatic int tw5864_frameinterval_get(struct tw5864_input *input,\n\t\t\t\t    struct v4l2_fract *frameinterval)\n{\n\tstruct tw5864_dev *dev = input->root;\n\n\tswitch (input->std) {\n\tcase STD_NTSC:\n\t\tframeinterval->numerator = 1001;\n\t\tframeinterval->denominator = 30000;\n\t\tbreak;\n\tcase STD_PAL:\n\tcase STD_SECAM:\n\t\tframeinterval->numerator = 1;\n\t\tframeinterval->denominator = 25;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->pci->dev, \"tw5864_frameinterval_get requested for unknown std %d\\n\",\n\t\t\t input->std);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tw5864_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\tif (fsize->pixel_format != V4L2_PIX_FMT_H264)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = 704;\n\tfsize->discrete.height = input->std == STD_NTSC ? 480 : 576;\n\n\treturn 0;\n}\n\nstatic int tw5864_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_frmivalenum *fintv)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct v4l2_fract frameinterval;\n\tint std_max_fps = input->std == STD_NTSC ? 30 : 25;\n\tstruct v4l2_frmsizeenum fsize = { .index = fintv->index,\n\t\t.pixel_format = fintv->pixel_format };\n\tint ret;\n\n\tret = tw5864_enum_framesizes(file, priv, &fsize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fintv->width != fsize.discrete.width ||\n\t    fintv->height != fsize.discrete.height)\n\t\treturn -EINVAL;\n\n\tfintv->type = V4L2_FRMIVAL_TYPE_STEPWISE;\n\n\tret = tw5864_frameinterval_get(input, &frameinterval);\n\tfintv->stepwise.step = frameinterval;\n\tfintv->stepwise.min = frameinterval;\n\tfintv->stepwise.max = frameinterval;\n\tfintv->stepwise.max.numerator *= std_max_fps;\n\n\treturn ret;\n}\n\nstatic int tw5864_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct v4l2_captureparm *cp = &sp->parm.capture;\n\tint ret;\n\n\tcp->capability = V4L2_CAP_TIMEPERFRAME;\n\n\tret = tw5864_frameinterval_get(input, &cp->timeperframe);\n\tcp->timeperframe.numerator *= input->frame_interval;\n\tcp->capturemode = 0;\n\tcp->readbuffers = 2;\n\n\treturn ret;\n}\n\nstatic int tw5864_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct v4l2_fract *t = &sp->parm.capture.timeperframe;\n\tstruct v4l2_fract time_base;\n\tint ret;\n\n\tret = tw5864_frameinterval_get(input, &time_base);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!t->numerator || !t->denominator) {\n\t\tt->numerator = time_base.numerator * input->frame_interval;\n\t\tt->denominator = time_base.denominator;\n\t} else if (t->denominator != time_base.denominator) {\n\t\tt->numerator = t->numerator * time_base.denominator /\n\t\t\tt->denominator;\n\t\tt->denominator = time_base.denominator;\n\t}\n\n\tinput->frame_interval = t->numerator / time_base.numerator;\n\tif (input->frame_interval < 1)\n\t\tinput->frame_interval = 1;\n\ttw5864_frame_interval_set(input);\n\treturn tw5864_g_parm(file, priv, sp);\n}\n\nstatic const struct v4l2_ctrl_ops tw5864_ctrl_ops = {\n\t.s_ctrl = tw5864_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations video_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\n#define INDIR_SPACE_MAP_SHIFT 0x100000\n\nstatic int tw5864_g_reg(struct file *file, void *fh,\n\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tif (reg->reg < INDIR_SPACE_MAP_SHIFT) {\n\t\tif (reg->reg > 0x87fff)\n\t\t\treturn -EINVAL;\n\t\treg->size = 4;\n\t\treg->val = tw_readl(reg->reg);\n\t} else {\n\t\t__u64 indir_addr = reg->reg - INDIR_SPACE_MAP_SHIFT;\n\n\t\tif (indir_addr > 0xefe)\n\t\t\treturn -EINVAL;\n\t\treg->size = 1;\n\t\treg->val = tw_indir_readb(reg->reg);\n\t}\n\treturn 0;\n}\n\nstatic int tw5864_s_reg(struct file *file, void *fh,\n\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tif (reg->reg < INDIR_SPACE_MAP_SHIFT) {\n\t\tif (reg->reg > 0x87fff)\n\t\t\treturn -EINVAL;\n\t\ttw_writel(reg->reg, reg->val);\n\t} else {\n\t\t__u64 indir_addr = reg->reg - INDIR_SPACE_MAP_SHIFT;\n\n\t\tif (indir_addr > 0xefe)\n\t\t\treturn -EINVAL;\n\t\ttw_indir_writeb(reg->reg, reg->val);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap = tw5864_querycap,\n\t.vidioc_enum_fmt_vid_cap = tw5864_enum_fmt_vid_cap,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_querystd = tw5864_querystd,\n\t.vidioc_s_std = tw5864_s_std,\n\t.vidioc_g_std = tw5864_g_std,\n\t.vidioc_enum_input = tw5864_enum_input,\n\t.vidioc_g_input = tw5864_g_input,\n\t.vidioc_s_input = tw5864_s_input,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_try_fmt_vid_cap = tw5864_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = tw5864_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = tw5864_fmt_vid_cap,\n\t.vidioc_log_status = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = tw5864_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_enum_framesizes = tw5864_enum_framesizes,\n\t.vidioc_enum_frameintervals = tw5864_enum_frameintervals,\n\t.vidioc_s_parm = tw5864_s_parm,\n\t.vidioc_g_parm = tw5864_g_parm,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register = tw5864_g_reg,\n\t.vidioc_s_register = tw5864_s_reg,\n#endif\n};\n\nstatic const struct video_device tw5864_video_template = {\n\t.name = \"tw5864_video\",\n\t.fops = &video_fops,\n\t.ioctl_ops = &video_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.tvnorms = TW5864_NORMS,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_STREAMING,\n};\n\n/* Motion Detection Threshold matrix */\nstatic const struct v4l2_ctrl_config tw5864_md_thresholds = {\n\t.ops = &tw5864_ctrl_ops,\n\t.id = V4L2_CID_DETECT_MD_THRESHOLD_GRID,\n\t.dims = {MD_CELLS_HOR, MD_CELLS_VERT},\n\t.def = 14,\n\t/* See tw5864_md_metric_from_mvd() */\n\t.max = 2 * 0x0f,\n\t.step = 1,\n};\n\nstatic int tw5864_video_input_init(struct tw5864_input *dev, int video_nr);\nstatic void tw5864_video_input_fini(struct tw5864_input *dev);\nstatic void tw5864_encoder_tables_upload(struct tw5864_dev *dev);\n\nint tw5864_video_init(struct tw5864_dev *dev, int *video_nr)\n{\n\tint i;\n\tint ret;\n\tunsigned long flags;\n\tint last_dma_allocated = -1;\n\tint last_input_nr_registered = -1;\n\n\tfor (i = 0; i < H264_BUF_CNT; i++) {\n\t\tstruct tw5864_h264_frame *frame = &dev->h264_buf[i];\n\n\t\tframe->vlc.addr = dma_alloc_coherent(&dev->pci->dev,\n\t\t\t\t\t\t     H264_VLC_BUF_SIZE,\n\t\t\t\t\t\t     &frame->vlc.dma_addr,\n\t\t\t\t\t\t     GFP_KERNEL | GFP_DMA32);\n\t\tif (!frame->vlc.addr) {\n\t\t\tdev_err(&dev->pci->dev, \"dma alloc fail\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_dma;\n\t\t}\n\t\tframe->mv.addr = dma_alloc_coherent(&dev->pci->dev,\n\t\t\t\t\t\t    H264_MV_BUF_SIZE,\n\t\t\t\t\t\t    &frame->mv.dma_addr,\n\t\t\t\t\t\t    GFP_KERNEL | GFP_DMA32);\n\t\tif (!frame->mv.addr) {\n\t\t\tdev_err(&dev->pci->dev, \"dma alloc fail\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tdma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\n\t\t\t\t\t  frame->vlc.addr, frame->vlc.dma_addr);\n\t\t\tgoto free_dma;\n\t\t}\n\t\tlast_dma_allocated = i;\n\t}\n\n\ttw5864_encoder_tables_upload(dev);\n\n\t/* Picture is distorted without this block */\n\t/* use falling edge to sample 54M to 108M */\n\ttw_indir_writeb(TW5864_INDIR_VD_108_POL, TW5864_INDIR_VD_108_POL_BOTH);\n\ttw_indir_writeb(TW5864_INDIR_CLK0_SEL, 0x00);\n\n\ttw_indir_writeb(TW5864_INDIR_DDRA_DLL_DQS_SEL0, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRA_DLL_DQS_SEL1, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRA_DLL_CLK90_SEL, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRB_DLL_DQS_SEL0, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRB_DLL_DQS_SEL1, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRB_DLL_CLK90_SEL, 0x02);\n\n\t/* video input reset */\n\ttw_indir_writeb(TW5864_INDIR_RESET, 0);\n\ttw_indir_writeb(TW5864_INDIR_RESET, TW5864_INDIR_RESET_VD |\n\t\t\tTW5864_INDIR_RESET_DLL | TW5864_INDIR_RESET_MUX_CORE);\n\tmsleep(20);\n\n\t/*\n\t * Select Part A mode for all channels.\n\t * tw_setl instead of tw_clearl for Part B mode.\n\t *\n\t * I guess \"Part B\" is primarily for downscaled version of same channel\n\t * which goes in Part A of same bus\n\t */\n\ttw_writel(TW5864_FULL_HALF_MODE_SEL, 0);\n\n\ttw_indir_writeb(TW5864_INDIR_PV_VD_CK_POL,\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(0) |\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(1) |\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(2) |\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(3));\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tdev->encoder_busy = 0;\n\tdev->h264_buf_r_index = 0;\n\tdev->h264_buf_w_index = 0;\n\ttw_writel(TW5864_VLC_STREAM_BASE_ADDR,\n\t\t  dev->h264_buf[dev->h264_buf_w_index].vlc.dma_addr);\n\ttw_writel(TW5864_MV_STREAM_BASE_ADDR,\n\t\t  dev->h264_buf[dev->h264_buf_w_index].mv.dma_addr);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\ttw_writel(TW5864_SEN_EN_CH, 0x000f);\n\ttw_writel(TW5864_H264EN_CH_EN, 0x000f);\n\n\ttw_writel(TW5864_H264EN_BUS0_MAP, 0x00000000);\n\ttw_writel(TW5864_H264EN_BUS1_MAP, 0x00001111);\n\ttw_writel(TW5864_H264EN_BUS2_MAP, 0x00002222);\n\ttw_writel(TW5864_H264EN_BUS3_MAP, 0x00003333);\n\n\t/*\n\t * Quote from Intersil (manufacturer):\n\t * 0x0038 is managed by HW, and by default it won't pass the pointer set\n\t * at 0x0010. So if you don't do encoding, 0x0038 should stay at '3'\n\t * (with 4 frames in buffer). If you encode one frame and then move\n\t * 0x0010 to '1' for example, HW will take one more frame and set it to\n\t * buffer #0, and then you should see 0x0038 is set to '0'.  There is\n\t * only one HW encoder engine, so 4 channels cannot get encoded\n\t * simultaneously. But each channel does have its own buffer (for\n\t * original frames and reconstructed frames). So there is no problem to\n\t * manage encoding for 4 channels at same time and no need to force\n\t * I-frames in switching channels.\n\t * End of quote.\n\t *\n\t * If we set 0x0010 (TW5864_ENC_BUF_PTR_REC1) to 0 (for any channel), we\n\t * have no \"rolling\" (until we change this value).\n\t * If we set 0x0010 (TW5864_ENC_BUF_PTR_REC1) to 0x3, it starts to roll\n\t * continuously together with 0x0038.\n\t */\n\ttw_writel(TW5864_ENC_BUF_PTR_REC1, 0x00ff);\n\ttw_writel(TW5864_PCI_INTTM_SCALE, 0);\n\n\ttw_writel(TW5864_INTERLACING, TW5864_DI_EN);\n\ttw_writel(TW5864_MASTER_ENB_REG, TW5864_PCI_VLC_INTR_ENB);\n\ttw_writel(TW5864_PCI_INTR_CTL,\n\t\t  TW5864_TIMER_INTR_ENB | TW5864_PCI_MAST_ENB |\n\t\t  TW5864_MVD_VLC_MAST_ENB);\n\n\tdev->irqmask |= TW5864_INTR_VLC_DONE | TW5864_INTR_TIMER;\n\ttw5864_irqmask_apply(dev);\n\n\ttasklet_init(&dev->tasklet, tw5864_handle_frame_task,\n\t\t     (unsigned long)dev);\n\n\tfor (i = 0; i < TW5864_INPUTS; i++) {\n\t\tdev->inputs[i].root = dev;\n\t\tdev->inputs[i].nr = i;\n\t\tret = tw5864_video_input_init(&dev->inputs[i], video_nr[i]);\n\t\tif (ret)\n\t\t\tgoto fini_video_inputs;\n\t\tlast_input_nr_registered = i;\n\t}\n\n\treturn 0;\n\nfini_video_inputs:\n\tfor (i = last_input_nr_registered; i >= 0; i--)\n\t\ttw5864_video_input_fini(&dev->inputs[i]);\n\n\ttasklet_kill(&dev->tasklet);\n\nfree_dma:\n\tfor (i = last_dma_allocated; i >= 0; i--) {\n\t\tdma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].vlc.addr,\n\t\t\t\t  dev->h264_buf[i].vlc.dma_addr);\n\t\tdma_free_coherent(&dev->pci->dev, H264_MV_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].mv.addr,\n\t\t\t\t  dev->h264_buf[i].mv.dma_addr);\n\t}\n\n\treturn ret;\n}\n\nstatic int tw5864_video_input_init(struct tw5864_input *input, int video_nr)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tint ret;\n\tstruct v4l2_ctrl_handler *hdl = &input->hdl;\n\n\tmutex_init(&input->lock);\n\tspin_lock_init(&input->slock);\n\n\t/* setup video buffers queue */\n\tINIT_LIST_HEAD(&input->active);\n\tinput->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tinput->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tinput->vidq.io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tinput->vidq.ops = &tw5864_video_qops;\n\tinput->vidq.mem_ops = &vb2_dma_contig_memops;\n\tinput->vidq.drv_priv = input;\n\tinput->vidq.gfp_flags = 0;\n\tinput->vidq.buf_struct_size = sizeof(struct tw5864_buf);\n\tinput->vidq.lock = &input->lock;\n\tinput->vidq.min_buffers_needed = 2;\n\tinput->vidq.dev = &input->root->pci->dev;\n\tret = vb2_queue_init(&input->vidq);\n\tif (ret)\n\t\tgoto free_mutex;\n\n\tinput->vdev = tw5864_video_template;\n\tinput->vdev.v4l2_dev = &input->root->v4l2_dev;\n\tinput->vdev.lock = &input->lock;\n\tinput->vdev.queue = &input->vidq;\n\tvideo_set_drvdata(&input->vdev, input);\n\n\t/* Initialize the device control structures */\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 100);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops, V4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops, V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t\t  1, MAX_GOP_SIZE, 1, GOP_SIZE);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_MIN_QP, 28, 51, 1, QP_VALUE);\n\tv4l2_ctrl_new_std_menu(hdl, &tw5864_ctrl_ops,\n\t\t\t       V4L2_CID_DETECT_MD_MODE,\n\t\t\t       V4L2_DETECT_MD_MODE_THRESHOLD_GRID, 0,\n\t\t\t       V4L2_DETECT_MD_MODE_DISABLED);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD,\n\t\t\t  tw5864_md_thresholds.min, tw5864_md_thresholds.max,\n\t\t\t  tw5864_md_thresholds.step, tw5864_md_thresholds.def);\n\tinput->md_threshold_grid_ctrl =\n\t\tv4l2_ctrl_new_custom(hdl, &tw5864_md_thresholds, NULL);\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto free_v4l2_hdl;\n\t}\n\tinput->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tinput->qp = QP_VALUE;\n\tinput->gop = GOP_SIZE;\n\tinput->frame_interval = 1;\n\n\tret = video_register_device(&input->vdev, VFL_TYPE_GRABBER, video_nr);\n\tif (ret)\n\t\tgoto free_v4l2_hdl;\n\n\tdev_info(&input->root->pci->dev, \"Registered video device %s\\n\",\n\t\t video_device_node_name(&input->vdev));\n\n\t/*\n\t * Set default video standard. Doesn't matter which, the detected value\n\t * will be found out by VIDIOC_QUERYSTD handler.\n\t */\n\tinput->v4l2_std = V4L2_STD_NTSC_M;\n\tinput->std = STD_NTSC;\n\n\ttw_indir_writeb(TW5864_INDIR_VIN_E(video_nr), 0x07);\n\t/* to initiate auto format recognition */\n\ttw_indir_writeb(TW5864_INDIR_VIN_F(video_nr), 0xff);\n\n\treturn 0;\n\nfree_v4l2_hdl:\n\tv4l2_ctrl_handler_free(hdl);\n\tvb2_queue_release(&input->vidq);\nfree_mutex:\n\tmutex_destroy(&input->lock);\n\n\treturn ret;\n}\n\nstatic void tw5864_video_input_fini(struct tw5864_input *dev)\n{\n\tvideo_unregister_device(&dev->vdev);\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tvb2_queue_release(&dev->vidq);\n}\n\nvoid tw5864_video_fini(struct tw5864_dev *dev)\n{\n\tint i;\n\n\ttasklet_kill(&dev->tasklet);\n\n\tfor (i = 0; i < TW5864_INPUTS; i++)\n\t\ttw5864_video_input_fini(&dev->inputs[i]);\n\n\tfor (i = 0; i < H264_BUF_CNT; i++) {\n\t\tdma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].vlc.addr,\n\t\t\t\t  dev->h264_buf[i].vlc.dma_addr);\n\t\tdma_free_coherent(&dev->pci->dev, H264_MV_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].mv.addr,\n\t\t\t\t  dev->h264_buf[i].mv.dma_addr);\n\t}\n}\n\nvoid tw5864_prepare_frame_headers(struct tw5864_input *input)\n{\n\tstruct tw5864_buf *vb = input->vb;\n\tu8 *dst;\n\tsize_t dst_space;\n\tunsigned long flags;\n\n\tif (!vb) {\n\t\tspin_lock_irqsave(&input->slock, flags);\n\t\tif (list_empty(&input->active)) {\n\t\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t\t\tinput->vb = NULL;\n\t\t\treturn;\n\t\t}\n\t\tvb = list_first_entry(&input->active, struct tw5864_buf, list);\n\t\tlist_del(&vb->list);\n\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t}\n\n\tdst = vb2_plane_vaddr(&vb->vb.vb2_buf, 0);\n\tdst_space = vb2_plane_size(&vb->vb.vb2_buf, 0);\n\n\t/*\n\t * Low-level bitstream writing functions don't have a fine way to say\n\t * correctly that supplied buffer is too small. So we just check there\n\t * and warn, and don't care at lower level.\n\t * Currently all headers take below 32 bytes.\n\t * The buffer is supposed to have plenty of free space at this point,\n\t * anyway.\n\t */\n\tif (WARN_ON_ONCE(dst_space < 128))\n\t\treturn;\n\n\t/*\n\t * Generate H264 headers:\n\t * If this is first frame, put SPS and PPS\n\t */\n\tif (input->frame_gop_seqno == 0)\n\t\ttw5864_h264_put_stream_header(&dst, &dst_space, input->qp,\n\t\t\t\t\t      input->width, input->height);\n\n\t/* Put slice header */\n\ttw5864_h264_put_slice_header(&dst, &dst_space, input->h264_idr_pic_id,\n\t\t\t\t     input->frame_gop_seqno,\n\t\t\t\t     &input->tail_nb_bits, &input->tail);\n\tinput->vb = vb;\n\tinput->buf_cur_ptr = dst;\n\tinput->buf_cur_space_left = dst_space;\n}\n\n/*\n * Returns heuristic motion detection metric value from known components of\n * hardware-provided Motion Vector Data.\n */\nstatic unsigned int tw5864_md_metric_from_mvd(u32 mvd)\n{\n\t/*\n\t * Format of motion vector data exposed by tw5864, according to\n\t * manufacturer:\n\t * mv_x 10 bits\n\t * mv_y 10 bits\n\t * non_zero_members 8 bits\n\t * mb_type 3 bits\n\t * reserved 1 bit\n\t *\n\t * non_zero_members: number of non-zero residuals in each macro block\n\t * after quantization\n\t *\n\t * unsigned int reserved = mvd >> 31;\n\t * unsigned int mb_type = (mvd >> 28) & 0x7;\n\t * unsigned int non_zero_members = (mvd >> 20) & 0xff;\n\t */\n\tunsigned int mv_y = (mvd >> 10) & 0x3ff;\n\tunsigned int mv_x = mvd & 0x3ff;\n\n\t/* heuristic: */\n\tmv_x &= 0x0f;\n\tmv_y &= 0x0f;\n\n\treturn mv_y + mv_x;\n}\n\nstatic int tw5864_is_motion_triggered(struct tw5864_h264_frame *frame)\n{\n\tstruct tw5864_input *input = frame->input;\n\tu32 *mv = (u32 *)frame->mv.addr;\n\tint i;\n\tint detected = 0;\n\n\tfor (i = 0; i < MD_CELLS; i++) {\n\t\tconst u16 thresh = input->md_threshold_grid_values[i];\n\t\tconst unsigned int metric = tw5864_md_metric_from_mvd(mv[i]);\n\n\t\tif (metric > thresh)\n\t\t\tdetected = 1;\n\n\t\tif (detected)\n\t\t\tbreak;\n\t}\n\treturn detected;\n}\n\nstatic void tw5864_handle_frame_task(unsigned long data)\n{\n\tstruct tw5864_dev *dev = (struct tw5864_dev *)data;\n\tunsigned long flags;\n\tint batch_size = H264_BUF_CNT;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (dev->h264_buf_r_index != dev->h264_buf_w_index && batch_size--) {\n\t\tstruct tw5864_h264_frame *frame =\n\t\t\t&dev->h264_buf[dev->h264_buf_r_index];\n\n\t\tspin_unlock_irqrestore(&dev->slock, flags);\n\t\tdma_sync_single_for_cpu(&dev->pci->dev, frame->vlc.dma_addr,\n\t\t\t\t\tH264_VLC_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tdma_sync_single_for_cpu(&dev->pci->dev, frame->mv.dma_addr,\n\t\t\t\t\tH264_MV_BUF_SIZE, DMA_FROM_DEVICE);\n\t\ttw5864_handle_frame(frame);\n\t\tdma_sync_single_for_device(&dev->pci->dev, frame->vlc.dma_addr,\n\t\t\t\t\t   H264_VLC_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tdma_sync_single_for_device(&dev->pci->dev, frame->mv.dma_addr,\n\t\t\t\t\t   H264_MV_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tspin_lock_irqsave(&dev->slock, flags);\n\n\t\tdev->h264_buf_r_index++;\n\t\tdev->h264_buf_r_index %= H264_BUF_CNT;\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\n#ifdef DEBUG\nstatic u32 tw5864_vlc_checksum(u32 *data, int len)\n{\n\tu32 val, count_len = len;\n\n\tval = *data++;\n\twhile (((count_len >> 2) - 1) > 0) {\n\t\tval ^= *data++;\n\t\tcount_len -= 4;\n\t}\n\tval ^= htonl((len >> 2));\n\treturn val;\n}\n#endif\n\nstatic void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nstatic v4l2_std_id tw5864_get_v4l2_std(enum tw5864_vid_std std)\n{\n\tswitch (std) {\n\tcase STD_NTSC:    return V4L2_STD_NTSC_M;\n\tcase STD_PAL:     return V4L2_STD_PAL_B;\n\tcase STD_SECAM:   return V4L2_STD_SECAM_B;\n\tcase STD_NTSC443: return V4L2_STD_NTSC_443;\n\tcase STD_PAL_M:   return V4L2_STD_PAL_M;\n\tcase STD_PAL_CN:  return V4L2_STD_PAL_Nc;\n\tcase STD_PAL_60:  return V4L2_STD_PAL_60;\n\tcase STD_INVALID: return V4L2_STD_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic enum tw5864_vid_std tw5864_from_v4l2_std(v4l2_std_id v4l2_std)\n{\n\tif (v4l2_std & V4L2_STD_NTSC_M)\n\t\treturn STD_NTSC;\n\tif (v4l2_std & V4L2_STD_PAL_B)\n\t\treturn STD_PAL;\n\tif (v4l2_std & V4L2_STD_SECAM_B)\n\t\treturn STD_SECAM;\n\tif (v4l2_std & V4L2_STD_NTSC_443)\n\t\treturn STD_NTSC443;\n\tif (v4l2_std & V4L2_STD_PAL_M)\n\t\treturn STD_PAL_M;\n\tif (v4l2_std & V4L2_STD_PAL_Nc)\n\t\treturn STD_PAL_CN;\n\tif (v4l2_std & V4L2_STD_PAL_60)\n\t\treturn STD_PAL_60;\n\n\treturn STD_INVALID;\n}\n\nstatic void tw5864_encoder_tables_upload(struct tw5864_dev *dev)\n{\n\tint i;\n\n\ttw_writel(TW5864_VLC_RD, 0x1);\n\tfor (i = 0; i < VLC_LOOKUP_TABLE_LEN; i++) {\n\t\ttw_writel((TW5864_VLC_STREAM_MEM_START + i * 4),\n\t\t\t  encoder_vlc_lookup_table[i]);\n\t}\n\ttw_writel(TW5864_VLC_RD, 0x0);\n\n\tfor (i = 0; i < QUANTIZATION_TABLE_LEN; i++) {\n\t\ttw_writel((TW5864_QUAN_TAB + i * 4),\n\t\t\t  forward_quantization_table[i]);\n\t}\n\n\tfor (i = 0; i < QUANTIZATION_TABLE_LEN; i++) {\n\t\ttw_writel((TW5864_QUAN_TAB + i * 4),\n\t\t\t  inverse_quantization_table[i]);\n\t}\n}\n"], "fixing_code": ["/*\n *  TW5864 driver - video encoding functions\n *\n *  Copyright (C) 2016 Bluecherry, LLC <maintainers@bluecherrydvr.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n#include <linux/module.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-dma-contig.h>\n\n#include \"tw5864.h\"\n#include \"tw5864-reg.h\"\n\n#define QUANTIZATION_TABLE_LEN 96\n#define VLC_LOOKUP_TABLE_LEN 1024\n\nstatic const u16 forward_quantization_table[QUANTIZATION_TABLE_LEN] = {\n\t0x3333, 0x1f82, 0x3333, 0x1f82, 0x1f82, 0x147b, 0x1f82, 0x147b,\n\t0x3333, 0x1f82, 0x3333, 0x1f82, 0x1f82, 0x147b, 0x1f82, 0x147b,\n\t0x2e8c, 0x1d42, 0x2e8c, 0x1d42, 0x1d42, 0x1234, 0x1d42, 0x1234,\n\t0x2e8c, 0x1d42, 0x2e8c, 0x1d42, 0x1d42, 0x1234, 0x1d42, 0x1234,\n\t0x2762, 0x199a, 0x2762, 0x199a, 0x199a, 0x1062, 0x199a, 0x1062,\n\t0x2762, 0x199a, 0x2762, 0x199a, 0x199a, 0x1062, 0x199a, 0x1062,\n\t0x2492, 0x16c1, 0x2492, 0x16c1, 0x16c1, 0x0e3f, 0x16c1, 0x0e3f,\n\t0x2492, 0x16c1, 0x2492, 0x16c1, 0x16c1, 0x0e3f, 0x16c1, 0x0e3f,\n\t0x2000, 0x147b, 0x2000, 0x147b, 0x147b, 0x0d1b, 0x147b, 0x0d1b,\n\t0x2000, 0x147b, 0x2000, 0x147b, 0x147b, 0x0d1b, 0x147b, 0x0d1b,\n\t0x1c72, 0x11cf, 0x1c72, 0x11cf, 0x11cf, 0x0b4d, 0x11cf, 0x0b4d,\n\t0x1c72, 0x11cf, 0x1c72, 0x11cf, 0x11cf, 0x0b4d, 0x11cf, 0x0b4d\n};\n\nstatic const u16 inverse_quantization_table[QUANTIZATION_TABLE_LEN] = {\n\t0x800a, 0x800d, 0x800a, 0x800d, 0x800d, 0x8010, 0x800d, 0x8010,\n\t0x800a, 0x800d, 0x800a, 0x800d, 0x800d, 0x8010, 0x800d, 0x8010,\n\t0x800b, 0x800e, 0x800b, 0x800e, 0x800e, 0x8012, 0x800e, 0x8012,\n\t0x800b, 0x800e, 0x800b, 0x800e, 0x800e, 0x8012, 0x800e, 0x8012,\n\t0x800d, 0x8010, 0x800d, 0x8010, 0x8010, 0x8014, 0x8010, 0x8014,\n\t0x800d, 0x8010, 0x800d, 0x8010, 0x8010, 0x8014, 0x8010, 0x8014,\n\t0x800e, 0x8012, 0x800e, 0x8012, 0x8012, 0x8017, 0x8012, 0x8017,\n\t0x800e, 0x8012, 0x800e, 0x8012, 0x8012, 0x8017, 0x8012, 0x8017,\n\t0x8010, 0x8014, 0x8010, 0x8014, 0x8014, 0x8019, 0x8014, 0x8019,\n\t0x8010, 0x8014, 0x8010, 0x8014, 0x8014, 0x8019, 0x8014, 0x8019,\n\t0x8012, 0x8017, 0x8012, 0x8017, 0x8017, 0x801d, 0x8017, 0x801d,\n\t0x8012, 0x8017, 0x8012, 0x8017, 0x8017, 0x801d, 0x8017, 0x801d\n};\n\nstatic const u16 encoder_vlc_lookup_table[VLC_LOOKUP_TABLE_LEN] = {\n\t0x011, 0x000, 0x000, 0x000, 0x065, 0x021, 0x000, 0x000, 0x087, 0x064,\n\t0x031, 0x000, 0x097, 0x086, 0x075, 0x053, 0x0a7, 0x096, 0x085, 0x063,\n\t0x0b7, 0x0a6, 0x095, 0x074, 0x0df, 0x0b6, 0x0a5, 0x084, 0x0db, 0x0de,\n\t0x0b5, 0x094, 0x0d8, 0x0da, 0x0dd, 0x0a4, 0x0ef, 0x0ee, 0x0d9, 0x0b4,\n\t0x0eb, 0x0ea, 0x0ed, 0x0dc, 0x0ff, 0x0fe, 0x0e9, 0x0ec, 0x0fb, 0x0fa,\n\t0x0fd, 0x0e8, 0x10f, 0x0f1, 0x0f9, 0x0fc, 0x10b, 0x10e, 0x10d, 0x0f8,\n\t0x107, 0x10a, 0x109, 0x10c, 0x104, 0x106, 0x105, 0x108, 0x023, 0x000,\n\t0x000, 0x000, 0x06b, 0x022, 0x000, 0x000, 0x067, 0x057, 0x033, 0x000,\n\t0x077, 0x06a, 0x069, 0x045, 0x087, 0x066, 0x065, 0x044, 0x084, 0x076,\n\t0x075, 0x056, 0x097, 0x086, 0x085, 0x068, 0x0bf, 0x096, 0x095, 0x064,\n\t0x0bb, 0x0be, 0x0bd, 0x074, 0x0cf, 0x0ba, 0x0b9, 0x094, 0x0cb, 0x0ce,\n\t0x0cd, 0x0bc, 0x0c8, 0x0ca, 0x0c9, 0x0b8, 0x0df, 0x0de, 0x0dd, 0x0cc,\n\t0x0db, 0x0da, 0x0d9, 0x0dc, 0x0d7, 0x0eb, 0x0d6, 0x0d8, 0x0e9, 0x0e8,\n\t0x0ea, 0x0d1, 0x0e7, 0x0e6, 0x0e5, 0x0e4, 0x04f, 0x000, 0x000, 0x000,\n\t0x06f, 0x04e, 0x000, 0x000, 0x06b, 0x05f, 0x04d, 0x000, 0x068, 0x05c,\n\t0x05e, 0x04c, 0x07f, 0x05a, 0x05b, 0x04b, 0x07b, 0x058, 0x059, 0x04a,\n\t0x079, 0x06e, 0x06d, 0x049, 0x078, 0x06a, 0x069, 0x048, 0x08f, 0x07e,\n\t0x07d, 0x05d, 0x08b, 0x08e, 0x07a, 0x06c, 0x09f, 0x08a, 0x08d, 0x07c,\n\t0x09b, 0x09e, 0x089, 0x08c, 0x098, 0x09a, 0x09d, 0x088, 0x0ad, 0x097,\n\t0x099, 0x09c, 0x0a9, 0x0ac, 0x0ab, 0x0aa, 0x0a5, 0x0a8, 0x0a7, 0x0a6,\n\t0x0a1, 0x0a4, 0x0a3, 0x0a2, 0x021, 0x000, 0x000, 0x000, 0x067, 0x011,\n\t0x000, 0x000, 0x064, 0x066, 0x031, 0x000, 0x063, 0x073, 0x072, 0x065,\n\t0x062, 0x083, 0x082, 0x070, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x011, 0x010,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x011, 0x021, 0x020, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x023, 0x022, 0x021, 0x020, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x023, 0x022, 0x021, 0x031,\n\t0x030, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x023, 0x022, 0x033, 0x032, 0x031, 0x030, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x023, 0x030,\n\t0x031, 0x033, 0x032, 0x035, 0x034, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x037, 0x036, 0x035, 0x034, 0x033, 0x032,\n\t0x031, 0x041, 0x051, 0x061, 0x071, 0x081, 0x091, 0x0a1, 0x0b1, 0x000,\n\t0x002, 0x000, 0x0e4, 0x011, 0x0f4, 0x002, 0x024, 0x003, 0x005, 0x012,\n\t0x034, 0x013, 0x065, 0x024, 0x013, 0x063, 0x015, 0x022, 0x075, 0x034,\n\t0x044, 0x023, 0x023, 0x073, 0x054, 0x033, 0x033, 0x004, 0x043, 0x014,\n\t0x011, 0x043, 0x014, 0x001, 0x025, 0x015, 0x035, 0x025, 0x064, 0x055,\n\t0x045, 0x035, 0x074, 0x065, 0x085, 0x0d5, 0x012, 0x095, 0x055, 0x045,\n\t0x095, 0x0e5, 0x084, 0x075, 0x022, 0x0a5, 0x094, 0x085, 0x032, 0x0b5,\n\t0x003, 0x0c5, 0x001, 0x044, 0x0a5, 0x032, 0x0b5, 0x094, 0x0c5, 0x0a4,\n\t0x0a4, 0x054, 0x0d5, 0x0b4, 0x0b4, 0x064, 0x0f5, 0x0f5, 0x053, 0x0d4,\n\t0x0e5, 0x0c4, 0x105, 0x105, 0x0c4, 0x074, 0x063, 0x0e4, 0x0d4, 0x084,\n\t0x073, 0x0f4, 0x004, 0x005, 0x000, 0x053, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x011, 0x021, 0x031, 0x030, 0x011, 0x021, 0x020, 0x000,\n\t0x011, 0x010, 0x000, 0x000, 0x011, 0x033, 0x032, 0x043, 0x042, 0x053,\n\t0x052, 0x063, 0x062, 0x073, 0x072, 0x083, 0x082, 0x093, 0x092, 0x091,\n\t0x037, 0x036, 0x035, 0x034, 0x033, 0x045, 0x044, 0x043, 0x042, 0x053,\n\t0x052, 0x063, 0x062, 0x061, 0x060, 0x000, 0x045, 0x037, 0x036, 0x035,\n\t0x044, 0x043, 0x034, 0x033, 0x042, 0x053, 0x052, 0x061, 0x051, 0x060,\n\t0x000, 0x000, 0x053, 0x037, 0x045, 0x044, 0x036, 0x035, 0x034, 0x043,\n\t0x033, 0x042, 0x052, 0x051, 0x050, 0x000, 0x000, 0x000, 0x045, 0x044,\n\t0x043, 0x037, 0x036, 0x035, 0x034, 0x033, 0x042, 0x051, 0x041, 0x050,\n\t0x000, 0x000, 0x000, 0x000, 0x061, 0x051, 0x037, 0x036, 0x035, 0x034,\n\t0x033, 0x032, 0x041, 0x031, 0x060, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x061, 0x051, 0x035, 0x034, 0x033, 0x023, 0x032, 0x041, 0x031, 0x060,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x061, 0x041, 0x051, 0x033,\n\t0x023, 0x022, 0x032, 0x031, 0x060, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x061, 0x060, 0x041, 0x023, 0x022, 0x031, 0x021, 0x051,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x051, 0x050,\n\t0x031, 0x023, 0x022, 0x021, 0x041, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x040, 0x041, 0x031, 0x032, 0x011, 0x033,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x040, 0x041, 0x021, 0x011, 0x031, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x030, 0x031, 0x011, 0x021,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x020, 0x021, 0x011, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x010, 0x011,\n\t0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,\n\t0x000, 0x000, 0x000, 0x000\n};\n\nstatic const unsigned int lambda_lookup_table[] = {\n\t0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,\n\t0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,\n\t0x0040, 0x0040, 0x0040, 0x0040, 0x0060, 0x0060, 0x0060, 0x0080,\n\t0x0080, 0x0080, 0x00a0, 0x00c0, 0x00c0, 0x00e0, 0x0100, 0x0120,\n\t0x0140, 0x0160, 0x01a0, 0x01c0, 0x0200, 0x0240, 0x0280, 0x02e0,\n\t0x0320, 0x03a0, 0x0400, 0x0480, 0x0500, 0x05a0, 0x0660, 0x0720,\n\t0x0800, 0x0900, 0x0a20, 0x0b60\n};\n\nstatic const unsigned int intra4x4_lambda3[] = {\n\t1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1,\n\t2, 2, 2, 2, 3, 3, 3, 4,\n\t4, 4, 5, 6, 6, 7, 8, 9,\n\t10, 11, 13, 14, 16, 18, 20, 23,\n\t25, 29, 32, 36, 40, 45, 51, 57,\n\t64, 72, 81, 91\n};\n\nstatic v4l2_std_id tw5864_get_v4l2_std(enum tw5864_vid_std std);\nstatic enum tw5864_vid_std tw5864_from_v4l2_std(v4l2_std_id v4l2_std);\n\nstatic void tw5864_handle_frame_task(unsigned long data);\nstatic void tw5864_handle_frame(struct tw5864_h264_frame *frame);\nstatic void tw5864_frame_interval_set(struct tw5864_input *input);\n\nstatic int tw5864_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,\n\t\t\t      unsigned int *num_planes, unsigned int sizes[],\n\t\t\t      struct device *alloc_ctxs[])\n{\n\tif (*num_planes)\n\t\treturn sizes[0] < H264_VLC_BUF_SIZE ? -EINVAL : 0;\n\n\tsizes[0] = H264_VLC_BUF_SIZE;\n\t*num_planes = 1;\n\n\treturn 0;\n}\n\nstatic void tw5864_buf_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct vb2_queue *vq = vb->vb2_queue;\n\tstruct tw5864_input *dev = vb2_get_drv_priv(vq);\n\tstruct tw5864_buf *buf = container_of(vbuf, struct tw5864_buf, vb);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tlist_add_tail(&buf->list, &dev->active);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\nstatic int tw5864_input_std_get(struct tw5864_input *input,\n\t\t\t\tenum tw5864_vid_std *std)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tu8 std_reg = tw_indir_readb(TW5864_INDIR_VIN_E(input->nr));\n\n\t*std = (std_reg & 0x70) >> 4;\n\n\tif (std_reg & 0x80) {\n\t\tdev_dbg(&dev->pci->dev,\n\t\t\t\"Video format detection is in progress, please wait\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int tw5864_enable_input(struct tw5864_input *input)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tint nr = input->nr;\n\tunsigned long flags;\n\tint d1_width = 720;\n\tint d1_height;\n\tint frame_width_bus_value = 0;\n\tint frame_height_bus_value = 0;\n\tint reg_frame_bus = 0x1c;\n\tint fmt_reg_value = 0;\n\tint downscale_enabled = 0;\n\n\tdev_dbg(&dev->pci->dev, \"Enabling channel %d\\n\", nr);\n\n\tinput->frame_seqno = 0;\n\tinput->frame_gop_seqno = 0;\n\tinput->h264_idr_pic_id = 0;\n\n\tinput->reg_dsp_qp = input->qp;\n\tinput->reg_dsp_ref_mvp_lambda = lambda_lookup_table[input->qp];\n\tinput->reg_dsp_i4x4_weight = intra4x4_lambda3[input->qp];\n\tinput->reg_emu = TW5864_EMU_EN_LPF | TW5864_EMU_EN_BHOST\n\t\t| TW5864_EMU_EN_SEN | TW5864_EMU_EN_ME | TW5864_EMU_EN_DDR;\n\tinput->reg_dsp = nr /* channel id */\n\t\t| TW5864_DSP_CHROM_SW\n\t\t| ((0xa << 8) & TW5864_DSP_MB_DELAY)\n\t\t;\n\n\tinput->resolution = D1;\n\n\td1_height = (input->std == STD_NTSC) ? 480 : 576;\n\n\tinput->width = d1_width;\n\tinput->height = d1_height;\n\n\tinput->reg_interlacing = 0x4;\n\n\tswitch (input->resolution) {\n\tcase D1:\n\t\tframe_width_bus_value = 0x2cf;\n\t\tframe_height_bus_value = input->height - 1;\n\t\treg_frame_bus = 0x1c;\n\t\tfmt_reg_value = 0;\n\t\tdownscale_enabled = 0;\n\t\tinput->reg_dsp_codec |= TW5864_CIF_MAP_MD | TW5864_HD1_MAP_MD;\n\t\tinput->reg_emu |= TW5864_DSP_FRAME_TYPE_D1;\n\t\tinput->reg_interlacing = TW5864_DI_EN | TW5864_DSP_INTER_ST;\n\n\t\ttw_setl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\t\tbreak;\n\tcase HD1:\n\t\tinput->height /= 2;\n\t\tinput->width /= 2;\n\t\tframe_width_bus_value = 0x2cf;\n\t\tframe_height_bus_value = input->height * 2 - 1;\n\t\treg_frame_bus = 0x1c;\n\t\tfmt_reg_value = 0;\n\t\tdownscale_enabled = 0;\n\t\tinput->reg_dsp_codec |= TW5864_HD1_MAP_MD;\n\t\tinput->reg_emu |= TW5864_DSP_FRAME_TYPE_D1;\n\n\t\ttw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\n\t\tbreak;\n\tcase CIF:\n\t\tinput->height /= 4;\n\t\tinput->width /= 2;\n\t\tframe_width_bus_value = 0x15f;\n\t\tframe_height_bus_value = input->height * 2 - 1;\n\t\treg_frame_bus = 0x07;\n\t\tfmt_reg_value = 1;\n\t\tdownscale_enabled = 1;\n\t\tinput->reg_dsp_codec |= TW5864_CIF_MAP_MD;\n\n\t\ttw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\t\tbreak;\n\tcase QCIF:\n\t\tinput->height /= 4;\n\t\tinput->width /= 4;\n\t\tframe_width_bus_value = 0x15f;\n\t\tframe_height_bus_value = input->height * 2 - 1;\n\t\treg_frame_bus = 0x07;\n\t\tfmt_reg_value = 1;\n\t\tdownscale_enabled = 1;\n\t\tinput->reg_dsp_codec |= TW5864_CIF_MAP_MD;\n\n\t\ttw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\n\t\tbreak;\n\t}\n\n\t/* analog input width / 4 */\n\ttw_indir_writeb(TW5864_INDIR_IN_PIC_WIDTH(nr), d1_width / 4);\n\ttw_indir_writeb(TW5864_INDIR_IN_PIC_HEIGHT(nr), d1_height / 4);\n\n\t/* output width / 4 */\n\ttw_indir_writeb(TW5864_INDIR_OUT_PIC_WIDTH(nr), input->width / 4);\n\ttw_indir_writeb(TW5864_INDIR_OUT_PIC_HEIGHT(nr), input->height / 4);\n\n\t/*\n\t * Crop width from 720 to 704.\n\t * Above register settings need value 720 involved.\n\t */\n\tinput->width = 704;\n\ttw_indir_writeb(TW5864_INDIR_CROP_ETC,\n\t\t\ttw_indir_readb(TW5864_INDIR_CROP_ETC) |\n\t\t\tTW5864_INDIR_CROP_ETC_CROP_EN);\n\n\ttw_writel(TW5864_DSP_PIC_MAX_MB,\n\t\t  ((input->width / 16) << 8) | (input->height / 16));\n\n\ttw_writel(TW5864_FRAME_WIDTH_BUS_A(nr),\n\t\t  frame_width_bus_value);\n\ttw_writel(TW5864_FRAME_WIDTH_BUS_B(nr),\n\t\t  frame_width_bus_value);\n\ttw_writel(TW5864_FRAME_HEIGHT_BUS_A(nr),\n\t\t  frame_height_bus_value);\n\ttw_writel(TW5864_FRAME_HEIGHT_BUS_B(nr),\n\t\t  (frame_height_bus_value + 1) / 2 - 1);\n\n\ttw5864_frame_interval_set(input);\n\n\tif (downscale_enabled)\n\t\ttw_setl(TW5864_H264EN_CH_DNS, 1 << nr);\n\n\ttw_mask_shift_writel(TW5864_H264EN_CH_FMT_REG1, 0x3, 2 * nr,\n\t\t\t     fmt_reg_value);\n\n\ttw_mask_shift_writel((nr < 2\n\t\t\t      ? TW5864_H264EN_RATE_MAX_LINE_REG1\n\t\t\t      : TW5864_H264EN_RATE_MAX_LINE_REG2),\n\t\t\t     0x1f, 5 * (nr % 2),\n\t\t\t     input->std == STD_NTSC ? 29 : 24);\n\n\ttw_mask_shift_writel((nr < 2) ? TW5864_FRAME_BUS1 :\n\t\t\t     TW5864_FRAME_BUS2, 0xff, (nr % 2) * 8,\n\t\t\t     reg_frame_bus);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tinput->enabled = 1;\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\treturn 0;\n}\n\nvoid tw5864_request_encoded_frame(struct tw5864_input *input)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tu32 enc_buf_id_new;\n\n\ttw_setl(TW5864_DSP_CODEC, TW5864_CIF_MAP_MD | TW5864_HD1_MAP_MD);\n\ttw_writel(TW5864_EMU, input->reg_emu);\n\ttw_writel(TW5864_INTERLACING, input->reg_interlacing);\n\ttw_writel(TW5864_DSP, input->reg_dsp);\n\n\ttw_writel(TW5864_DSP_QP, input->reg_dsp_qp);\n\ttw_writel(TW5864_DSP_REF_MVP_LAMBDA, input->reg_dsp_ref_mvp_lambda);\n\ttw_writel(TW5864_DSP_I4x4_WEIGHT, input->reg_dsp_i4x4_weight);\n\ttw_mask_shift_writel(TW5864_DSP_INTRA_MODE, TW5864_DSP_INTRA_MODE_MASK,\n\t\t\t     TW5864_DSP_INTRA_MODE_SHIFT,\n\t\t\t     TW5864_DSP_INTRA_MODE_16x16);\n\n\tif (input->frame_gop_seqno == 0) {\n\t\t/* Produce I-frame */\n\t\ttw_writel(TW5864_MOTION_SEARCH_ETC, TW5864_INTRA_EN);\n\t\tinput->h264_idr_pic_id++;\n\t\tinput->h264_idr_pic_id &= TW5864_DSP_REF_FRM;\n\t} else {\n\t\t/* Produce P-frame */\n\t\ttw_writel(TW5864_MOTION_SEARCH_ETC, TW5864_INTRA_EN |\n\t\t\t  TW5864_ME_EN | BIT(5) /* SRCH_OPT default */);\n\t}\n\ttw5864_prepare_frame_headers(input);\n\ttw_writel(TW5864_VLC,\n\t\t  TW5864_VLC_PCI_SEL |\n\t\t  ((input->tail_nb_bits + 24) << TW5864_VLC_BIT_ALIGN_SHIFT) |\n\t\t  input->reg_dsp_qp);\n\n\tenc_buf_id_new = tw_mask_shift_readl(TW5864_ENC_BUF_PTR_REC1, 0x3,\n\t\t\t\t\t     2 * input->nr);\n\ttw_writel(TW5864_DSP_ENC_ORG_PTR_REG,\n\t\t  enc_buf_id_new << TW5864_DSP_ENC_ORG_PTR_SHIFT);\n\ttw_writel(TW5864_DSP_ENC_REC,\n\t\t  enc_buf_id_new << 12 | ((enc_buf_id_new + 3) & 3));\n\n\ttw_writel(TW5864_SLICE, TW5864_START_NSLICE);\n\ttw_writel(TW5864_SLICE, 0);\n}\n\nstatic int tw5864_disable_input(struct tw5864_input *input)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tunsigned long flags;\n\n\tdev_dbg(&dev->pci->dev, \"Disabling channel %d\\n\", input->nr);\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tinput->enabled = 0;\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\treturn 0;\n}\n\nstatic int tw5864_start_streaming(struct vb2_queue *q, unsigned int count)\n{\n\tstruct tw5864_input *input = vb2_get_drv_priv(q);\n\tint ret;\n\n\tret = tw5864_enable_input(input);\n\tif (!ret)\n\t\treturn 0;\n\n\twhile (!list_empty(&input->active)) {\n\t\tstruct tw5864_buf *buf = list_entry(input->active.next,\n\t\t\t\t\t\t    struct tw5864_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\n\t}\n\treturn ret;\n}\n\nstatic void tw5864_stop_streaming(struct vb2_queue *q)\n{\n\tunsigned long flags;\n\tstruct tw5864_input *input = vb2_get_drv_priv(q);\n\n\ttw5864_disable_input(input);\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tif (input->vb) {\n\t\tvb2_buffer_done(&input->vb->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\tinput->vb = NULL;\n\t}\n\twhile (!list_empty(&input->active)) {\n\t\tstruct tw5864_buf *buf = list_entry(input->active.next,\n\t\t\t\t\t\t    struct tw5864_buf, list);\n\n\t\tlist_del(&buf->list);\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tspin_unlock_irqrestore(&input->slock, flags);\n}\n\nstatic const struct vb2_ops tw5864_video_qops = {\n\t.queue_setup = tw5864_queue_setup,\n\t.buf_queue = tw5864_buf_queue,\n\t.start_streaming = tw5864_start_streaming,\n\t.stop_streaming = tw5864_stop_streaming,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int tw5864_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct tw5864_input *input =\n\t\tcontainer_of(ctrl->handler, struct tw5864_input, hdl);\n\tstruct tw5864_dev *dev = input->root;\n\tunsigned long flags;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_A_BRIGHT(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_7_HUE(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_9_CNTRST(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_B_SAT_U(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\ttw_indir_writeb(TW5864_INDIR_VIN_C_SAT_V(input->nr),\n\t\t\t\t(u8)ctrl->val);\n\t\tbreak;\n\tcase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\n\t\tinput->gop = ctrl->val;\n\t\treturn 0;\n\tcase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\n\t\tspin_lock_irqsave(&input->slock, flags);\n\t\tinput->qp = ctrl->val;\n\t\tinput->reg_dsp_qp = input->qp;\n\t\tinput->reg_dsp_ref_mvp_lambda = lambda_lookup_table[input->qp];\n\t\tinput->reg_dsp_i4x4_weight = intra4x4_lambda3[input->qp];\n\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD:\n\t\tmemset(input->md_threshold_grid_values, ctrl->val,\n\t\t       sizeof(input->md_threshold_grid_values));\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_MODE:\n\t\treturn 0;\n\tcase V4L2_CID_DETECT_MD_THRESHOLD_GRID:\n\t\t/* input->md_threshold_grid_ctrl->p_new.p_u16 contains data */\n\t\tmemcpy(input->md_threshold_grid_values,\n\t\t       input->md_threshold_grid_ctrl->p_new.p_u16,\n\t\t       sizeof(input->md_threshold_grid_values));\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int tw5864_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *f)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\tf->fmt.pix.width = 704;\n\tswitch (input->std) {\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\tcase STD_NTSC:\n\t\tf->fmt.pix.height = 480;\n\t\tbreak;\n\tcase STD_PAL:\n\tcase STD_SECAM:\n\t\tf->fmt.pix.height = 576;\n\t\tbreak;\n\t}\n\tf->fmt.pix.field = V4L2_FIELD_INTERLACED;\n\tf->fmt.pix.pixelformat = V4L2_PIX_FMT_H264;\n\tf->fmt.pix.sizeimage = H264_VLC_BUF_SIZE;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\n\treturn 0;\n}\n\nstatic int tw5864_enum_input(struct file *file, void *priv,\n\t\t\t     struct v4l2_input *i)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tu8 indir_0x000 = tw_indir_readb(TW5864_INDIR_VIN_0(input->nr));\n\tu8 indir_0x00d = tw_indir_readb(TW5864_INDIR_VIN_D(input->nr));\n\tu8 v1 = indir_0x000;\n\tu8 v2 = indir_0x00d;\n\n\tif (i->index)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tsnprintf(i->name, sizeof(i->name), \"Encoder %d\", input->nr);\n\ti->std = TW5864_NORMS;\n\tif (v1 & (1 << 7))\n\t\ti->status |= V4L2_IN_ST_NO_SYNC;\n\tif (!(v1 & (1 << 6)))\n\t\ti->status |= V4L2_IN_ST_NO_H_LOCK;\n\tif (v1 & (1 << 2))\n\t\ti->status |= V4L2_IN_ST_NO_SIGNAL;\n\tif (v1 & (1 << 1))\n\t\ti->status |= V4L2_IN_ST_NO_COLOR;\n\tif (v2 & (1 << 2))\n\t\ti->status |= V4L2_IN_ST_MACROVISION;\n\n\treturn 0;\n}\n\nstatic int tw5864_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\t*i = 0;\n\treturn 0;\n}\n\nstatic int tw5864_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tif (i)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int tw5864_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\tstrscpy(cap->driver, \"tw5864\", sizeof(cap->driver));\n\tsnprintf(cap->card, sizeof(cap->card), \"TW5864 Encoder %d\",\n\t\t input->nr);\n\tsprintf(cap->bus_info, \"PCI:%s\", pci_name(input->root->pci));\n\treturn 0;\n}\n\nstatic int tw5864_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tenum tw5864_vid_std tw_std;\n\tint ret;\n\n\tret = tw5864_input_std_get(input, &tw_std);\n\tif (ret)\n\t\treturn ret;\n\t*std = tw5864_get_v4l2_std(tw_std);\n\n\treturn 0;\n}\n\nstatic int tw5864_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\t*std = input->v4l2_std;\n\treturn 0;\n}\n\nstatic int tw5864_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tinput->v4l2_std = std;\n\tinput->std = tw5864_from_v4l2_std(std);\n\ttw_indir_writeb(TW5864_INDIR_VIN_E(input->nr), input->std);\n\treturn 0;\n}\n\nstatic int tw5864_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_fmtdesc *f)\n{\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_H264;\n\n\treturn 0;\n}\n\nstatic int tw5864_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_MOTION_DET:\n\t\t/*\n\t\t * Allow for up to 30 events (1 second for NTSC) to be stored.\n\t\t */\n\t\treturn v4l2_event_subscribe(fh, sub, 30, NULL);\n\tdefault:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\t}\n}\n\nstatic void tw5864_frame_interval_set(struct tw5864_input *input)\n{\n\t/*\n\t * This register value seems to follow such approach: In each second\n\t * interval, when processing Nth frame, it checks Nth bit of register\n\t * value and, if the bit is 1, it processes the frame, otherwise the\n\t * frame is discarded.\n\t * So unary representation would work, but more or less equal gaps\n\t * between the frames should be preserved.\n\t *\n\t * For 1 FPS - 0x00000001\n\t * 00000000 00000000 00000000 00000001\n\t *\n\t * For max FPS - set all 25/30 lower bits:\n\t * 00111111 11111111 11111111 11111111 (NTSC)\n\t * 00000001 11111111 11111111 11111111 (PAL)\n\t *\n\t * For half of max FPS - use such pattern:\n\t * 00010101 01010101 01010101 01010101 (NTSC)\n\t * 00000001 01010101 01010101 01010101 (PAL)\n\t *\n\t * Et cetera.\n\t *\n\t * The value supplied to hardware is capped by mask of 25/30 lower bits.\n\t */\n\tstruct tw5864_dev *dev = input->root;\n\tu32 unary_framerate = 0;\n\tint shift = 0;\n\tint std_max_fps = input->std == STD_NTSC ? 30 : 25;\n\n\tfor (shift = 0; shift < std_max_fps; shift += input->frame_interval)\n\t\tunary_framerate |= 0x00000001 << shift;\n\n\ttw_writel(TW5864_H264EN_RATE_CNTL_LO_WORD(input->nr, 0),\n\t\t  unary_framerate >> 16);\n\ttw_writel(TW5864_H264EN_RATE_CNTL_HI_WORD(input->nr, 0),\n\t\t  unary_framerate & 0xffff);\n}\n\nstatic int tw5864_frameinterval_get(struct tw5864_input *input,\n\t\t\t\t    struct v4l2_fract *frameinterval)\n{\n\tstruct tw5864_dev *dev = input->root;\n\n\tswitch (input->std) {\n\tcase STD_NTSC:\n\t\tframeinterval->numerator = 1001;\n\t\tframeinterval->denominator = 30000;\n\t\tbreak;\n\tcase STD_PAL:\n\tcase STD_SECAM:\n\t\tframeinterval->numerator = 1;\n\t\tframeinterval->denominator = 25;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->pci->dev, \"tw5864_frameinterval_get requested for unknown std %d\\n\",\n\t\t\t input->std);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tw5864_enum_framesizes(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_frmsizeenum *fsize)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\n\tif (fsize->index > 0)\n\t\treturn -EINVAL;\n\tif (fsize->pixel_format != V4L2_PIX_FMT_H264)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = 704;\n\tfsize->discrete.height = input->std == STD_NTSC ? 480 : 576;\n\n\treturn 0;\n}\n\nstatic int tw5864_enum_frameintervals(struct file *file, void *priv,\n\t\t\t\t      struct v4l2_frmivalenum *fintv)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct v4l2_fract frameinterval;\n\tint std_max_fps = input->std == STD_NTSC ? 30 : 25;\n\tstruct v4l2_frmsizeenum fsize = { .index = fintv->index,\n\t\t.pixel_format = fintv->pixel_format };\n\tint ret;\n\n\tret = tw5864_enum_framesizes(file, priv, &fsize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fintv->width != fsize.discrete.width ||\n\t    fintv->height != fsize.discrete.height)\n\t\treturn -EINVAL;\n\n\tfintv->type = V4L2_FRMIVAL_TYPE_STEPWISE;\n\n\tret = tw5864_frameinterval_get(input, &frameinterval);\n\tfintv->stepwise.step = frameinterval;\n\tfintv->stepwise.min = frameinterval;\n\tfintv->stepwise.max = frameinterval;\n\tfintv->stepwise.max.numerator *= std_max_fps;\n\n\treturn ret;\n}\n\nstatic int tw5864_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct v4l2_captureparm *cp = &sp->parm.capture;\n\tint ret;\n\n\tcp->capability = V4L2_CAP_TIMEPERFRAME;\n\n\tret = tw5864_frameinterval_get(input, &cp->timeperframe);\n\tcp->timeperframe.numerator *= input->frame_interval;\n\tcp->capturemode = 0;\n\tcp->readbuffers = 2;\n\n\treturn ret;\n}\n\nstatic int tw5864_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *sp)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct v4l2_fract *t = &sp->parm.capture.timeperframe;\n\tstruct v4l2_fract time_base;\n\tint ret;\n\n\tret = tw5864_frameinterval_get(input, &time_base);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!t->numerator || !t->denominator) {\n\t\tt->numerator = time_base.numerator * input->frame_interval;\n\t\tt->denominator = time_base.denominator;\n\t} else if (t->denominator != time_base.denominator) {\n\t\tt->numerator = t->numerator * time_base.denominator /\n\t\t\tt->denominator;\n\t\tt->denominator = time_base.denominator;\n\t}\n\n\tinput->frame_interval = t->numerator / time_base.numerator;\n\tif (input->frame_interval < 1)\n\t\tinput->frame_interval = 1;\n\ttw5864_frame_interval_set(input);\n\treturn tw5864_g_parm(file, priv, sp);\n}\n\nstatic const struct v4l2_ctrl_ops tw5864_ctrl_ops = {\n\t.s_ctrl = tw5864_s_ctrl,\n};\n\nstatic const struct v4l2_file_operations video_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.read = vb2_fop_read,\n\t.poll = vb2_fop_poll,\n\t.mmap = vb2_fop_mmap,\n\t.unlocked_ioctl = video_ioctl2,\n};\n\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\n#define INDIR_SPACE_MAP_SHIFT 0x100000\n\nstatic int tw5864_g_reg(struct file *file, void *fh,\n\t\t\tstruct v4l2_dbg_register *reg)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tif (reg->reg < INDIR_SPACE_MAP_SHIFT) {\n\t\tif (reg->reg > 0x87fff)\n\t\t\treturn -EINVAL;\n\t\treg->size = 4;\n\t\treg->val = tw_readl(reg->reg);\n\t} else {\n\t\t__u64 indir_addr = reg->reg - INDIR_SPACE_MAP_SHIFT;\n\n\t\tif (indir_addr > 0xefe)\n\t\t\treturn -EINVAL;\n\t\treg->size = 1;\n\t\treg->val = tw_indir_readb(reg->reg);\n\t}\n\treturn 0;\n}\n\nstatic int tw5864_s_reg(struct file *file, void *fh,\n\t\t\tconst struct v4l2_dbg_register *reg)\n{\n\tstruct tw5864_input *input = video_drvdata(file);\n\tstruct tw5864_dev *dev = input->root;\n\n\tif (reg->reg < INDIR_SPACE_MAP_SHIFT) {\n\t\tif (reg->reg > 0x87fff)\n\t\t\treturn -EINVAL;\n\t\ttw_writel(reg->reg, reg->val);\n\t} else {\n\t\t__u64 indir_addr = reg->reg - INDIR_SPACE_MAP_SHIFT;\n\n\t\tif (indir_addr > 0xefe)\n\t\t\treturn -EINVAL;\n\t\ttw_indir_writeb(reg->reg, reg->val);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic const struct v4l2_ioctl_ops video_ioctl_ops = {\n\t.vidioc_querycap = tw5864_querycap,\n\t.vidioc_enum_fmt_vid_cap = tw5864_enum_fmt_vid_cap,\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_querystd = tw5864_querystd,\n\t.vidioc_s_std = tw5864_s_std,\n\t.vidioc_g_std = tw5864_g_std,\n\t.vidioc_enum_input = tw5864_enum_input,\n\t.vidioc_g_input = tw5864_g_input,\n\t.vidioc_s_input = tw5864_s_input,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\t.vidioc_try_fmt_vid_cap = tw5864_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = tw5864_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = tw5864_fmt_vid_cap,\n\t.vidioc_log_status = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = tw5864_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n\t.vidioc_enum_framesizes = tw5864_enum_framesizes,\n\t.vidioc_enum_frameintervals = tw5864_enum_frameintervals,\n\t.vidioc_s_parm = tw5864_s_parm,\n\t.vidioc_g_parm = tw5864_g_parm,\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\t.vidioc_g_register = tw5864_g_reg,\n\t.vidioc_s_register = tw5864_s_reg,\n#endif\n};\n\nstatic const struct video_device tw5864_video_template = {\n\t.name = \"tw5864_video\",\n\t.fops = &video_fops,\n\t.ioctl_ops = &video_ioctl_ops,\n\t.release = video_device_release_empty,\n\t.tvnorms = TW5864_NORMS,\n\t.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\tV4L2_CAP_STREAMING,\n};\n\n/* Motion Detection Threshold matrix */\nstatic const struct v4l2_ctrl_config tw5864_md_thresholds = {\n\t.ops = &tw5864_ctrl_ops,\n\t.id = V4L2_CID_DETECT_MD_THRESHOLD_GRID,\n\t.dims = {MD_CELLS_HOR, MD_CELLS_VERT},\n\t.def = 14,\n\t/* See tw5864_md_metric_from_mvd() */\n\t.max = 2 * 0x0f,\n\t.step = 1,\n};\n\nstatic int tw5864_video_input_init(struct tw5864_input *dev, int video_nr);\nstatic void tw5864_video_input_fini(struct tw5864_input *dev);\nstatic void tw5864_encoder_tables_upload(struct tw5864_dev *dev);\n\nint tw5864_video_init(struct tw5864_dev *dev, int *video_nr)\n{\n\tint i;\n\tint ret;\n\tunsigned long flags;\n\tint last_dma_allocated = -1;\n\tint last_input_nr_registered = -1;\n\n\tfor (i = 0; i < H264_BUF_CNT; i++) {\n\t\tstruct tw5864_h264_frame *frame = &dev->h264_buf[i];\n\n\t\tframe->vlc.addr = dma_alloc_coherent(&dev->pci->dev,\n\t\t\t\t\t\t     H264_VLC_BUF_SIZE,\n\t\t\t\t\t\t     &frame->vlc.dma_addr,\n\t\t\t\t\t\t     GFP_KERNEL | GFP_DMA32);\n\t\tif (!frame->vlc.addr) {\n\t\t\tdev_err(&dev->pci->dev, \"dma alloc fail\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_dma;\n\t\t}\n\t\tframe->mv.addr = dma_alloc_coherent(&dev->pci->dev,\n\t\t\t\t\t\t    H264_MV_BUF_SIZE,\n\t\t\t\t\t\t    &frame->mv.dma_addr,\n\t\t\t\t\t\t    GFP_KERNEL | GFP_DMA32);\n\t\tif (!frame->mv.addr) {\n\t\t\tdev_err(&dev->pci->dev, \"dma alloc fail\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tdma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\n\t\t\t\t\t  frame->vlc.addr, frame->vlc.dma_addr);\n\t\t\tgoto free_dma;\n\t\t}\n\t\tlast_dma_allocated = i;\n\t}\n\n\ttw5864_encoder_tables_upload(dev);\n\n\t/* Picture is distorted without this block */\n\t/* use falling edge to sample 54M to 108M */\n\ttw_indir_writeb(TW5864_INDIR_VD_108_POL, TW5864_INDIR_VD_108_POL_BOTH);\n\ttw_indir_writeb(TW5864_INDIR_CLK0_SEL, 0x00);\n\n\ttw_indir_writeb(TW5864_INDIR_DDRA_DLL_DQS_SEL0, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRA_DLL_DQS_SEL1, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRA_DLL_CLK90_SEL, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRB_DLL_DQS_SEL0, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRB_DLL_DQS_SEL1, 0x02);\n\ttw_indir_writeb(TW5864_INDIR_DDRB_DLL_CLK90_SEL, 0x02);\n\n\t/* video input reset */\n\ttw_indir_writeb(TW5864_INDIR_RESET, 0);\n\ttw_indir_writeb(TW5864_INDIR_RESET, TW5864_INDIR_RESET_VD |\n\t\t\tTW5864_INDIR_RESET_DLL | TW5864_INDIR_RESET_MUX_CORE);\n\tmsleep(20);\n\n\t/*\n\t * Select Part A mode for all channels.\n\t * tw_setl instead of tw_clearl for Part B mode.\n\t *\n\t * I guess \"Part B\" is primarily for downscaled version of same channel\n\t * which goes in Part A of same bus\n\t */\n\ttw_writel(TW5864_FULL_HALF_MODE_SEL, 0);\n\n\ttw_indir_writeb(TW5864_INDIR_PV_VD_CK_POL,\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(0) |\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(1) |\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(2) |\n\t\t\tTW5864_INDIR_PV_VD_CK_POL_VD(3));\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\tdev->encoder_busy = 0;\n\tdev->h264_buf_r_index = 0;\n\tdev->h264_buf_w_index = 0;\n\ttw_writel(TW5864_VLC_STREAM_BASE_ADDR,\n\t\t  dev->h264_buf[dev->h264_buf_w_index].vlc.dma_addr);\n\ttw_writel(TW5864_MV_STREAM_BASE_ADDR,\n\t\t  dev->h264_buf[dev->h264_buf_w_index].mv.dma_addr);\n\tspin_unlock_irqrestore(&dev->slock, flags);\n\n\ttw_writel(TW5864_SEN_EN_CH, 0x000f);\n\ttw_writel(TW5864_H264EN_CH_EN, 0x000f);\n\n\ttw_writel(TW5864_H264EN_BUS0_MAP, 0x00000000);\n\ttw_writel(TW5864_H264EN_BUS1_MAP, 0x00001111);\n\ttw_writel(TW5864_H264EN_BUS2_MAP, 0x00002222);\n\ttw_writel(TW5864_H264EN_BUS3_MAP, 0x00003333);\n\n\t/*\n\t * Quote from Intersil (manufacturer):\n\t * 0x0038 is managed by HW, and by default it won't pass the pointer set\n\t * at 0x0010. So if you don't do encoding, 0x0038 should stay at '3'\n\t * (with 4 frames in buffer). If you encode one frame and then move\n\t * 0x0010 to '1' for example, HW will take one more frame and set it to\n\t * buffer #0, and then you should see 0x0038 is set to '0'.  There is\n\t * only one HW encoder engine, so 4 channels cannot get encoded\n\t * simultaneously. But each channel does have its own buffer (for\n\t * original frames and reconstructed frames). So there is no problem to\n\t * manage encoding for 4 channels at same time and no need to force\n\t * I-frames in switching channels.\n\t * End of quote.\n\t *\n\t * If we set 0x0010 (TW5864_ENC_BUF_PTR_REC1) to 0 (for any channel), we\n\t * have no \"rolling\" (until we change this value).\n\t * If we set 0x0010 (TW5864_ENC_BUF_PTR_REC1) to 0x3, it starts to roll\n\t * continuously together with 0x0038.\n\t */\n\ttw_writel(TW5864_ENC_BUF_PTR_REC1, 0x00ff);\n\ttw_writel(TW5864_PCI_INTTM_SCALE, 0);\n\n\ttw_writel(TW5864_INTERLACING, TW5864_DI_EN);\n\ttw_writel(TW5864_MASTER_ENB_REG, TW5864_PCI_VLC_INTR_ENB);\n\ttw_writel(TW5864_PCI_INTR_CTL,\n\t\t  TW5864_TIMER_INTR_ENB | TW5864_PCI_MAST_ENB |\n\t\t  TW5864_MVD_VLC_MAST_ENB);\n\n\tdev->irqmask |= TW5864_INTR_VLC_DONE | TW5864_INTR_TIMER;\n\ttw5864_irqmask_apply(dev);\n\n\ttasklet_init(&dev->tasklet, tw5864_handle_frame_task,\n\t\t     (unsigned long)dev);\n\n\tfor (i = 0; i < TW5864_INPUTS; i++) {\n\t\tdev->inputs[i].root = dev;\n\t\tdev->inputs[i].nr = i;\n\t\tret = tw5864_video_input_init(&dev->inputs[i], video_nr[i]);\n\t\tif (ret)\n\t\t\tgoto fini_video_inputs;\n\t\tlast_input_nr_registered = i;\n\t}\n\n\treturn 0;\n\nfini_video_inputs:\n\tfor (i = last_input_nr_registered; i >= 0; i--)\n\t\ttw5864_video_input_fini(&dev->inputs[i]);\n\n\ttasklet_kill(&dev->tasklet);\n\nfree_dma:\n\tfor (i = last_dma_allocated; i >= 0; i--) {\n\t\tdma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].vlc.addr,\n\t\t\t\t  dev->h264_buf[i].vlc.dma_addr);\n\t\tdma_free_coherent(&dev->pci->dev, H264_MV_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].mv.addr,\n\t\t\t\t  dev->h264_buf[i].mv.dma_addr);\n\t}\n\n\treturn ret;\n}\n\nstatic int tw5864_video_input_init(struct tw5864_input *input, int video_nr)\n{\n\tstruct tw5864_dev *dev = input->root;\n\tint ret;\n\tstruct v4l2_ctrl_handler *hdl = &input->hdl;\n\n\tmutex_init(&input->lock);\n\tspin_lock_init(&input->slock);\n\n\t/* setup video buffers queue */\n\tINIT_LIST_HEAD(&input->active);\n\tinput->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tinput->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tinput->vidq.io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\n\tinput->vidq.ops = &tw5864_video_qops;\n\tinput->vidq.mem_ops = &vb2_dma_contig_memops;\n\tinput->vidq.drv_priv = input;\n\tinput->vidq.gfp_flags = 0;\n\tinput->vidq.buf_struct_size = sizeof(struct tw5864_buf);\n\tinput->vidq.lock = &input->lock;\n\tinput->vidq.min_buffers_needed = 2;\n\tinput->vidq.dev = &input->root->pci->dev;\n\tret = vb2_queue_init(&input->vidq);\n\tif (ret)\n\t\tgoto free_mutex;\n\n\tinput->vdev = tw5864_video_template;\n\tinput->vdev.v4l2_dev = &input->root->v4l2_dev;\n\tinput->vdev.lock = &input->lock;\n\tinput->vdev.queue = &input->vidq;\n\tvideo_set_drvdata(&input->vdev, input);\n\n\t/* Initialize the device control structures */\n\tv4l2_ctrl_handler_init(hdl, 6);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 100);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 128);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops, V4L2_CID_HUE, -128, 127, 1, 0);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops, V4L2_CID_MPEG_VIDEO_GOP_SIZE,\n\t\t\t  1, MAX_GOP_SIZE, 1, GOP_SIZE);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_MPEG_VIDEO_H264_MIN_QP, 28, 51, 1, QP_VALUE);\n\tv4l2_ctrl_new_std_menu(hdl, &tw5864_ctrl_ops,\n\t\t\t       V4L2_CID_DETECT_MD_MODE,\n\t\t\t       V4L2_DETECT_MD_MODE_THRESHOLD_GRID, 0,\n\t\t\t       V4L2_DETECT_MD_MODE_DISABLED);\n\tv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\n\t\t\t  V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD,\n\t\t\t  tw5864_md_thresholds.min, tw5864_md_thresholds.max,\n\t\t\t  tw5864_md_thresholds.step, tw5864_md_thresholds.def);\n\tinput->md_threshold_grid_ctrl =\n\t\tv4l2_ctrl_new_custom(hdl, &tw5864_md_thresholds, NULL);\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto free_v4l2_hdl;\n\t}\n\tinput->vdev.ctrl_handler = hdl;\n\tv4l2_ctrl_handler_setup(hdl);\n\n\tinput->qp = QP_VALUE;\n\tinput->gop = GOP_SIZE;\n\tinput->frame_interval = 1;\n\n\tret = video_register_device(&input->vdev, VFL_TYPE_GRABBER, video_nr);\n\tif (ret)\n\t\tgoto free_v4l2_hdl;\n\n\tdev_info(&input->root->pci->dev, \"Registered video device %s\\n\",\n\t\t video_device_node_name(&input->vdev));\n\n\t/*\n\t * Set default video standard. Doesn't matter which, the detected value\n\t * will be found out by VIDIOC_QUERYSTD handler.\n\t */\n\tinput->v4l2_std = V4L2_STD_NTSC_M;\n\tinput->std = STD_NTSC;\n\n\ttw_indir_writeb(TW5864_INDIR_VIN_E(video_nr), 0x07);\n\t/* to initiate auto format recognition */\n\ttw_indir_writeb(TW5864_INDIR_VIN_F(video_nr), 0xff);\n\n\treturn 0;\n\nfree_v4l2_hdl:\n\tv4l2_ctrl_handler_free(hdl);\n\tvb2_queue_release(&input->vidq);\nfree_mutex:\n\tmutex_destroy(&input->lock);\n\n\treturn ret;\n}\n\nstatic void tw5864_video_input_fini(struct tw5864_input *dev)\n{\n\tvideo_unregister_device(&dev->vdev);\n\tv4l2_ctrl_handler_free(&dev->hdl);\n\tvb2_queue_release(&dev->vidq);\n}\n\nvoid tw5864_video_fini(struct tw5864_dev *dev)\n{\n\tint i;\n\n\ttasklet_kill(&dev->tasklet);\n\n\tfor (i = 0; i < TW5864_INPUTS; i++)\n\t\ttw5864_video_input_fini(&dev->inputs[i]);\n\n\tfor (i = 0; i < H264_BUF_CNT; i++) {\n\t\tdma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].vlc.addr,\n\t\t\t\t  dev->h264_buf[i].vlc.dma_addr);\n\t\tdma_free_coherent(&dev->pci->dev, H264_MV_BUF_SIZE,\n\t\t\t\t  dev->h264_buf[i].mv.addr,\n\t\t\t\t  dev->h264_buf[i].mv.dma_addr);\n\t}\n}\n\nvoid tw5864_prepare_frame_headers(struct tw5864_input *input)\n{\n\tstruct tw5864_buf *vb = input->vb;\n\tu8 *dst;\n\tsize_t dst_space;\n\tunsigned long flags;\n\n\tif (!vb) {\n\t\tspin_lock_irqsave(&input->slock, flags);\n\t\tif (list_empty(&input->active)) {\n\t\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t\t\tinput->vb = NULL;\n\t\t\treturn;\n\t\t}\n\t\tvb = list_first_entry(&input->active, struct tw5864_buf, list);\n\t\tlist_del(&vb->list);\n\t\tspin_unlock_irqrestore(&input->slock, flags);\n\t}\n\n\tdst = vb2_plane_vaddr(&vb->vb.vb2_buf, 0);\n\tdst_space = vb2_plane_size(&vb->vb.vb2_buf, 0);\n\n\t/*\n\t * Low-level bitstream writing functions don't have a fine way to say\n\t * correctly that supplied buffer is too small. So we just check there\n\t * and warn, and don't care at lower level.\n\t * Currently all headers take below 32 bytes.\n\t * The buffer is supposed to have plenty of free space at this point,\n\t * anyway.\n\t */\n\tif (WARN_ON_ONCE(dst_space < 128))\n\t\treturn;\n\n\t/*\n\t * Generate H264 headers:\n\t * If this is first frame, put SPS and PPS\n\t */\n\tif (input->frame_gop_seqno == 0)\n\t\ttw5864_h264_put_stream_header(&dst, &dst_space, input->qp,\n\t\t\t\t\t      input->width, input->height);\n\n\t/* Put slice header */\n\ttw5864_h264_put_slice_header(&dst, &dst_space, input->h264_idr_pic_id,\n\t\t\t\t     input->frame_gop_seqno,\n\t\t\t\t     &input->tail_nb_bits, &input->tail);\n\tinput->vb = vb;\n\tinput->buf_cur_ptr = dst;\n\tinput->buf_cur_space_left = dst_space;\n}\n\n/*\n * Returns heuristic motion detection metric value from known components of\n * hardware-provided Motion Vector Data.\n */\nstatic unsigned int tw5864_md_metric_from_mvd(u32 mvd)\n{\n\t/*\n\t * Format of motion vector data exposed by tw5864, according to\n\t * manufacturer:\n\t * mv_x 10 bits\n\t * mv_y 10 bits\n\t * non_zero_members 8 bits\n\t * mb_type 3 bits\n\t * reserved 1 bit\n\t *\n\t * non_zero_members: number of non-zero residuals in each macro block\n\t * after quantization\n\t *\n\t * unsigned int reserved = mvd >> 31;\n\t * unsigned int mb_type = (mvd >> 28) & 0x7;\n\t * unsigned int non_zero_members = (mvd >> 20) & 0xff;\n\t */\n\tunsigned int mv_y = (mvd >> 10) & 0x3ff;\n\tunsigned int mv_x = mvd & 0x3ff;\n\n\t/* heuristic: */\n\tmv_x &= 0x0f;\n\tmv_y &= 0x0f;\n\n\treturn mv_y + mv_x;\n}\n\nstatic int tw5864_is_motion_triggered(struct tw5864_h264_frame *frame)\n{\n\tstruct tw5864_input *input = frame->input;\n\tu32 *mv = (u32 *)frame->mv.addr;\n\tint i;\n\tint detected = 0;\n\n\tfor (i = 0; i < MD_CELLS; i++) {\n\t\tconst u16 thresh = input->md_threshold_grid_values[i];\n\t\tconst unsigned int metric = tw5864_md_metric_from_mvd(mv[i]);\n\n\t\tif (metric > thresh)\n\t\t\tdetected = 1;\n\n\t\tif (detected)\n\t\t\tbreak;\n\t}\n\treturn detected;\n}\n\nstatic void tw5864_handle_frame_task(unsigned long data)\n{\n\tstruct tw5864_dev *dev = (struct tw5864_dev *)data;\n\tunsigned long flags;\n\tint batch_size = H264_BUF_CNT;\n\n\tspin_lock_irqsave(&dev->slock, flags);\n\twhile (dev->h264_buf_r_index != dev->h264_buf_w_index && batch_size--) {\n\t\tstruct tw5864_h264_frame *frame =\n\t\t\t&dev->h264_buf[dev->h264_buf_r_index];\n\n\t\tspin_unlock_irqrestore(&dev->slock, flags);\n\t\tdma_sync_single_for_cpu(&dev->pci->dev, frame->vlc.dma_addr,\n\t\t\t\t\tH264_VLC_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tdma_sync_single_for_cpu(&dev->pci->dev, frame->mv.dma_addr,\n\t\t\t\t\tH264_MV_BUF_SIZE, DMA_FROM_DEVICE);\n\t\ttw5864_handle_frame(frame);\n\t\tdma_sync_single_for_device(&dev->pci->dev, frame->vlc.dma_addr,\n\t\t\t\t\t   H264_VLC_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tdma_sync_single_for_device(&dev->pci->dev, frame->mv.dma_addr,\n\t\t\t\t\t   H264_MV_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tspin_lock_irqsave(&dev->slock, flags);\n\n\t\tdev->h264_buf_r_index++;\n\t\tdev->h264_buf_r_index %= H264_BUF_CNT;\n\t}\n\tspin_unlock_irqrestore(&dev->slock, flags);\n}\n\n#ifdef DEBUG\nstatic u32 tw5864_vlc_checksum(u32 *data, int len)\n{\n\tu32 val, count_len = len;\n\n\tval = *data++;\n\twhile (((count_len >> 2) - 1) > 0) {\n\t\tval ^= *data++;\n\t\tcount_len -= 4;\n\t}\n\tval ^= htonl((len >> 2));\n\treturn val;\n}\n#endif\n\nstatic void tw5864_handle_frame(struct tw5864_h264_frame *frame)\n{\n#define SKIP_VLCBUF_BYTES 3\n\tstruct tw5864_input *input = frame->input;\n\tstruct tw5864_dev *dev = input->root;\n\tstruct tw5864_buf *vb;\n\tstruct vb2_v4l2_buffer *v4l2_buf;\n\tint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\n\tu8 *dst = input->buf_cur_ptr;\n\tu8 tail_mask, vlc_mask = 0;\n\tint i;\n\tu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\n\tunsigned long flags;\n\tint zero_run;\n\tu8 *src;\n\tu8 *src_end;\n\n#ifdef DEBUG\n\tif (frame->checksum !=\n\t    tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\n\t\tdev_err(&dev->pci->dev,\n\t\t\t\"Checksum of encoded frame doesn't match!\\n\");\n#endif\n\n\tspin_lock_irqsave(&input->slock, flags);\n\tvb = input->vb;\n\tinput->vb = NULL;\n\tspin_unlock_irqrestore(&input->slock, flags);\n\n\tif (!vb) { /* Gone because of disabling */\n\t\tdev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");\n\t\treturn;\n\t}\n\n\tv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\n\n\t/*\n\t * Check for space.\n\t * Mind the overhead of startcode emulation prevention.\n\t */\n\tif (input->buf_cur_space_left < frame_len * 5 / 4) {\n\t\tdev_err_once(&dev->pci->dev,\n\t\t\t     \"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\\n\",\n\t\t\t     input->buf_cur_space_left, frame_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8 - input->tail_nb_bits; i++)\n\t\tvlc_mask |= 1 << i;\n\ttail_mask = (~vlc_mask) & 0xff;\n\n\tdst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\n\tframe_len--;\n\tdst++;\n\n\t/* H.264 startcode emulation prevention */\n\tsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\n\tsrc_end = src + frame_len;\n\tzero_run = 0;\n\tfor (; src < src_end; src++) {\n\t\tif (zero_run < 2) {\n\t\t\tif (*src == 0)\n\t\t\t\t++zero_run;\n\t\t\telse\n\t\t\t\tzero_run = 0;\n\t\t} else {\n\t\t\tif ((*src & ~0x03) == 0)\n\t\t\t\t*dst++ = 0x03;\n\t\t\tzero_run = *src == 0;\n\t\t}\n\t\t*dst++ = *src;\n\t}\n\n\tvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\n\t\t\t      dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\n\n\tvb->vb.vb2_buf.timestamp = frame->timestamp;\n\tv4l2_buf->field = V4L2_FIELD_INTERLACED;\n\tv4l2_buf->sequence = frame->seqno;\n\n\t/* Check for motion flags */\n\tif (frame->gop_seqno /* P-frame */ &&\n\t    tw5864_is_motion_triggered(frame)) {\n\t\tstruct v4l2_event ev = {\n\t\t\t.type = V4L2_EVENT_MOTION_DET,\n\t\t\t.u.motion_det = {\n\t\t\t\t.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\n\t\t\t\t.frame_sequence = v4l2_buf->sequence,\n\t\t\t},\n\t\t};\n\n\t\tv4l2_event_queue(&input->vdev, &ev);\n\t}\n\n\tvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nstatic v4l2_std_id tw5864_get_v4l2_std(enum tw5864_vid_std std)\n{\n\tswitch (std) {\n\tcase STD_NTSC:    return V4L2_STD_NTSC_M;\n\tcase STD_PAL:     return V4L2_STD_PAL_B;\n\tcase STD_SECAM:   return V4L2_STD_SECAM_B;\n\tcase STD_NTSC443: return V4L2_STD_NTSC_443;\n\tcase STD_PAL_M:   return V4L2_STD_PAL_M;\n\tcase STD_PAL_CN:  return V4L2_STD_PAL_Nc;\n\tcase STD_PAL_60:  return V4L2_STD_PAL_60;\n\tcase STD_INVALID: return V4L2_STD_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic enum tw5864_vid_std tw5864_from_v4l2_std(v4l2_std_id v4l2_std)\n{\n\tif (v4l2_std & V4L2_STD_NTSC_M)\n\t\treturn STD_NTSC;\n\tif (v4l2_std & V4L2_STD_PAL_B)\n\t\treturn STD_PAL;\n\tif (v4l2_std & V4L2_STD_SECAM_B)\n\t\treturn STD_SECAM;\n\tif (v4l2_std & V4L2_STD_NTSC_443)\n\t\treturn STD_NTSC443;\n\tif (v4l2_std & V4L2_STD_PAL_M)\n\t\treturn STD_PAL_M;\n\tif (v4l2_std & V4L2_STD_PAL_Nc)\n\t\treturn STD_PAL_CN;\n\tif (v4l2_std & V4L2_STD_PAL_60)\n\t\treturn STD_PAL_60;\n\n\treturn STD_INVALID;\n}\n\nstatic void tw5864_encoder_tables_upload(struct tw5864_dev *dev)\n{\n\tint i;\n\n\ttw_writel(TW5864_VLC_RD, 0x1);\n\tfor (i = 0; i < VLC_LOOKUP_TABLE_LEN; i++) {\n\t\ttw_writel((TW5864_VLC_STREAM_MEM_START + i * 4),\n\t\t\t  encoder_vlc_lookup_table[i]);\n\t}\n\ttw_writel(TW5864_VLC_RD, 0x0);\n\n\tfor (i = 0; i < QUANTIZATION_TABLE_LEN; i++) {\n\t\ttw_writel((TW5864_QUAN_TAB + i * 4),\n\t\t\t  forward_quantization_table[i]);\n\t}\n\n\tfor (i = 0; i < QUANTIZATION_TABLE_LEN; i++) {\n\t\ttw_writel((TW5864_QUAN_TAB + i * 4),\n\t\t\t  inverse_quantization_table[i]);\n\t}\n}\n"], "filenames": ["drivers/media/pci/tw5864/tw5864-video.c"], "buggy_code_start_loc": [1398], "buggy_code_end_loc": [1403], "fixing_code_start_loc": [1397], "fixing_code_end_loc": [1404], "type": "CWE-476", "message": "An issue was discovered in the Linux kernel before 5.2. There is a NULL pointer dereference in tw5864_handle_frame() in drivers/media/pci/tw5864/tw5864-video.c, which may cause denial of service, aka CID-2e7682ebfc75.", "other": {"cve": {"id": "CVE-2019-20806", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-27T12:15:10.067", "lastModified": "2020-06-19T11:15:09.447", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.2. There is a NULL pointer dereference in tw5864_handle_frame() in drivers/media/pci/tw5864/tw5864-video.c, which may cause denial of service, aka CID-2e7682ebfc75."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el kernel de Linux versiones anteriores a la versi\u00f3n 5.2. Tiene una desreferencia del puntero NULL en la funci\u00f3n tw5864_handle_frame() en el archivo drivers/media/pci/tw5864/tw5864-video.c, que puede causar una denegaci\u00f3n de servicio, tambi\u00e9n se conoce como CID-2e7682ebfc75."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.2", "matchCriteriaId": "D045CBEB-1802-47E4-AEDB-310B5DF2E8AA"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2e7682ebfc750177a4944eeb56e97a3f05734528", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200619-0001/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4698", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2e7682ebfc750177a4944eeb56e97a3f05734528"}}