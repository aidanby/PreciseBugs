{"buggy_code": ["# frozen_string_literal: true\n\nclass UsersController < ApplicationController\n  skip_before_action :authorize_mini_profiler, only: [:avatar]\n\n  requires_login only: [\n    :username, :update, :upload_user_image,\n    :pick_avatar, :destroy_user_image, :destroy, :check_emails,\n    :topic_tracking_state, :preferences, :create_second_factor_totp,\n    :enable_second_factor_totp, :disable_second_factor, :list_second_factors,\n    :update_second_factor, :create_second_factor_backup, :select_avatar,\n    :notification_level, :revoke_auth_token, :register_second_factor_security_key,\n    :create_second_factor_security_key, :feature_topic, :clear_featured_topic,\n    :bookmarks, :invited, :check_sso_email, :check_sso_payload,\n    :recent_searches, :reset_recent_searches\n  ]\n\n  skip_before_action :check_xhr, only: [\n    :show, :badges, :password_reset_show, :password_reset_update, :update, :account_created,\n    :activate_account, :perform_account_activation, :avatar,\n    :my_redirect, :toggle_anon, :admin_login, :confirm_admin, :email_login, :summary,\n    :feature_topic, :clear_featured_topic, :bookmarks\n  ]\n\n  before_action :second_factor_check_confirmed_password, only: [\n                  :create_second_factor_totp, :enable_second_factor_totp,\n                  :disable_second_factor, :update_second_factor, :create_second_factor_backup,\n                  :register_second_factor_security_key, :create_second_factor_security_key\n                ]\n\n  before_action :respond_to_suspicious_request, only: [:create]\n\n  # we need to allow account creation with bad CSRF tokens, if people are caching, the CSRF token on the\n  #  page is going to be empty, this means that server will see an invalid CSRF and blow the session\n  #  once that happens you can't log in with social\n  skip_before_action :verify_authenticity_token, only: [:create]\n  skip_before_action :redirect_to_login_if_required, only: [:check_username,\n                                                            :check_email,\n                                                            :create,\n                                                            :account_created,\n                                                            :activate_account,\n                                                            :perform_account_activation,\n                                                            :send_activation_email,\n                                                            :update_activation_email,\n                                                            :password_reset_show,\n                                                            :password_reset_update,\n                                                            :confirm_email_token,\n                                                            :email_login,\n                                                            :admin_login,\n                                                            :confirm_admin]\n\n  after_action :add_noindex_header, only: [:show, :my_redirect]\n\n  MAX_RECENT_SEARCHES = 5\n\n  def index\n  end\n\n  def show(for_card: false)\n    return redirect_to path('/login') if SiteSetting.hide_user_profiles_from_public && !current_user\n\n    @user = fetch_user_from_params(\n      include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts)\n    )\n\n    user_serializer = nil\n    if guardian.can_see_profile?(@user)\n      serializer_class = for_card ? UserCardSerializer : UserSerializer\n      user_serializer = serializer_class.new(@user, scope: guardian, root: 'user')\n\n      topic_id = params[:include_post_count_for].to_i\n      if topic_id != 0\n        user_serializer.topic_post_count = { topic_id => Post.secured(guardian).where(topic_id: topic_id, user_id: @user.id).count }\n      end\n    else\n      user_serializer = HiddenProfileSerializer.new(@user, scope: guardian, root: 'user')\n    end\n\n    if !params[:skip_track_visit] && (@user != current_user)\n      track_visit_to_user_profile\n    end\n\n    # This is a hack to get around a Rails issue where values with periods aren't handled correctly\n    # when used as part of a route.\n    if params[:external_id] && params[:external_id].ends_with?('.json')\n      return render_json_dump(user_serializer)\n    end\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        store_preloaded(\"user_#{@user.username}\", MultiJson.dump(user_serializer))\n        render :show\n      end\n\n      format.json do\n        render_json_dump(user_serializer)\n      end\n    end\n  end\n\n  def show_card\n    show(for_card: true)\n  end\n\n  def cards\n    return redirect_to path('/login') if SiteSetting.hide_user_profiles_from_public && !current_user\n\n    user_ids = params.require(:user_ids).split(\",\").map(&:to_i)\n    raise Discourse::InvalidParameters.new(:user_ids) if user_ids.length > 50\n\n    users = User.where(id: user_ids).includes(:user_option,\n                                              :user_stat,\n                                              :default_featured_user_badges,\n                                              :user_profile,\n                                              :card_background_upload,\n                                              :primary_group,\n                                              :flair_group,\n                                              :primary_email\n                                            )\n\n    users = users.filter { |u| guardian.can_see_profile?(u) }\n\n    preload_fields = User.allowed_user_custom_fields(guardian) + UserField.all.pluck(:id).map { |fid| \"#{User::USER_FIELD_PREFIX}#{fid}\" }\n    User.preload_custom_fields(users, preload_fields)\n    User.preload_recent_time_read(users)\n\n    render json: users, each_serializer: UserCardSerializer\n  end\n\n  def badges\n    raise Discourse::NotFound unless SiteSetting.enable_badges?\n    show\n  end\n\n  def update\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    attributes = user_params\n\n    # We can't update the username via this route. Use the username route\n    attributes.delete(:username)\n\n    if params[:user_fields].present?\n      attributes[:custom_fields] ||= {}\n\n      fields = UserField.all\n      fields = fields.where(editable: true) unless current_user.staff?\n      fields.each do |field|\n        field_id = field.id.to_s\n        next unless params[:user_fields].has_key?(field_id)\n\n        value = clean_custom_field_values(field)\n        value = nil if value === \"false\"\n        value = value[0...UserField.max_length] if value\n\n        return render_json_error(I18n.t(\"login.missing_user_field\")) if value.blank? && field.required?\n        attributes[:custom_fields][\"#{User::USER_FIELD_PREFIX}#{field.id}\"] = value\n      end\n    end\n\n    json_result(user, serializer: UserSerializer, additional_errors: [:user_profile, :user_option]) do |u|\n      updater = UserUpdater.new(current_user, user)\n      updater.update(attributes.permit!)\n    end\n  end\n\n  def username\n    params.require(:new_username)\n\n    if clashing_with_existing_route?(params[:new_username]) || User.reserved_username?(params[:new_username])\n      return render_json_error(I18n.t(\"login.reserved_username\"))\n    end\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_username!(user)\n\n    result = UsernameChanger.change(user, params[:new_username], current_user)\n\n    if result\n      render json: { id: user.id, username: user.username }\n    else\n      render_json_error(user.errors.full_messages.join(','))\n    end\n  rescue Discourse::InvalidAccess\n    if current_user&.staff?\n      render_json_error(I18n.t('errors.messages.auth_overrides_username'))\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def check_emails\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_emails!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email, *secondary_emails = user.emails\n    unconfirmed_emails = user.unconfirmed_emails\n\n    render json: {\n      email: email,\n      secondary_emails: secondary_emails,\n      unconfirmed_emails: unconfirmed_emails,\n      associated_accounts: user.associated_accounts\n    }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_email\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_sso_details!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email = user&.single_sign_on_record&.external_email\n    email = I18n.t(\"user.email.does_not_exist\") if email.blank?\n\n    render json: { email: email }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_payload\n    user = fetch_user_from_params(include_inactive: true)\n\n    guardian.ensure_can_check_sso_details!(user)\n    unless user == current_user\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    payload = user&.single_sign_on_record&.last_payload\n    payload = I18n.t(\"user.email.does_not_exist\") if payload.blank?\n\n    render json: { payload: payload }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def update_primary_email\n    if !SiteSetting.enable_secondary_emails\n      return render json: failed_json, status: 410\n    end\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_email!(user)\n\n    old_primary = user.primary_email\n    if old_primary.email == params[:email]\n      return render json: success_json\n    end\n\n    new_primary = user.user_emails.find_by(email: params[:email])\n    if new_primary.blank?\n      return render json: failed_json.merge(errors: [I18n.t(\"change_email.doesnt_exist\")]), status: 428\n    end\n\n    User.transaction do\n      old_primary.update!(primary: false)\n      new_primary.update!(primary: true)\n      DiscourseEvent.trigger(:user_updated, user)\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_update_email(user)\n      else\n        UserHistory.create!(action: UserHistory.actions[:update_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def destroy_email\n    if !SiteSetting.enable_secondary_emails\n      return render json: failed_json, status: 410\n    end\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    ActiveRecord::Base.transaction do\n      if change_requests = user.email_change_requests.where(new_email: params[:email]).presence\n        change_requests.destroy_all\n      elsif user.user_emails.where(email: params[:email], primary: false).destroy_all.present?\n        DiscourseEvent.trigger(:user_updated, user)\n      else\n        return render json: failed_json, status: 428\n      end\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_destroy_email(user)\n      else\n        UserHistory.create(action: UserHistory.actions[:destroy_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = TopicTrackingState.report(user)\n    serializer = ActiveModel::ArraySerializer.new(\n      report, each_serializer: TopicTrackingStateSerializer, scope: guardian\n    )\n\n    render json: MultiJson.dump(serializer)\n  end\n\n  def private_message_topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = PrivateMessageTopicTrackingState.report(user)\n\n    serializer = ActiveModel::ArraySerializer.new(\n      report,\n      each_serializer: PrivateMessageTopicTrackingStateSerializer,\n      scope: guardian\n    )\n\n    render json: MultiJson.dump(serializer)\n  end\n\n  def badge_title\n    params.require(:user_badge_id)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    user_badge = UserBadge.find_by(id: params[:user_badge_id])\n    previous_title = user.title\n    if user_badge && user_badge.user == user && user_badge.badge.allow_title?\n      user.title = user_badge.badge.display_name\n      user.save!\n\n      log_params = {\n        details: \"title matching badge id #{user_badge.badge.id}\",\n        previous_value: previous_title,\n        new_value: user.title\n      }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_title_change(user, log_params)\n      else\n        UserHistory.create!(log_params.merge(target_user_id: user.id, action: UserHistory.actions[:change_title]))\n      end\n    else\n      user.title = ''\n      user.save!\n\n      log_params = {\n        previous_value: previous_title\n      }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger\n          .new(current_user)\n          .log_title_revoke(user, log_params.merge(revoke_reason: 'user title was same as revoked badge name or custom badge name'))\n      else\n        UserHistory.create!(log_params.merge(target_user_id: user.id, action: UserHistory.actions[:revoke_title]))\n      end\n    end\n\n    render body: nil\n  end\n\n  def preferences\n    render body: nil\n  end\n\n  def my_redirect\n    raise Discourse::NotFound if params[:path] !~ /^[a-z_\\-\\/]+$/\n\n    if current_user.blank?\n      cookies[:destination_url] = path(\"/my/#{params[:path]}\")\n      redirect_to path(\"/login-preferences\")\n    else\n      redirect_to(path(\"/u/#{current_user.encoded_username}/#{params[:path]}\"))\n    end\n  end\n\n  def profile_hidden\n    render nothing: true\n  end\n\n  def summary\n    @user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts))\n    raise Discourse::NotFound unless guardian.can_see_profile?(@user)\n\n    response.headers['X-Robots-Tag'] = 'noindex'\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        render :show\n      end\n      format.json do\n        summary_json = Discourse.cache.fetch(summary_cache_key(@user), expires_in: 1.hour) do\n          summary = UserSummary.new(@user, guardian)\n          serializer = UserSummarySerializer.new(summary, scope: guardian)\n          MultiJson.dump(serializer)\n        end\n        render json: summary_json\n      end\n    end\n  end\n\n  def invited\n    if guardian.can_invite_to_forum?\n      filter = params[:filter] || \"redeemed\"\n      inviter = fetch_user_from_params(include_inactive: current_user.staff? || SiteSetting.show_inactive_accounts)\n\n      invites = if filter == \"pending\" && guardian.can_see_invite_details?(inviter)\n        Invite.includes(:topics, :groups).pending(inviter)\n      elsif filter == \"expired\"\n        Invite.expired(inviter)\n      elsif filter == \"redeemed\"\n        Invite.redeemed_users(inviter)\n      else\n        Invite.none\n      end\n\n      invites = invites.offset(params[:offset].to_i || 0).limit(SiteSetting.invites_per_page)\n\n      show_emails = guardian.can_see_invite_emails?(inviter)\n      if params[:search].present? && invites.present?\n        filter_sql = '(LOWER(users.username) LIKE :filter)'\n        filter_sql = '(LOWER(invites.email) LIKE :filter) or (LOWER(users.username) LIKE :filter)' if show_emails\n        invites = invites.where(filter_sql, filter: \"%#{params[:search].downcase}%\")\n      end\n\n      pending_count = Invite.pending(inviter).reorder(nil).count.to_i\n      expired_count = Invite.expired(inviter).reorder(nil).count.to_i\n      redeemed_count = Invite.redeemed_users(inviter).reorder(nil).count.to_i\n\n      render json: MultiJson.dump(InvitedSerializer.new(\n        OpenStruct.new(\n          invite_list: invites.to_a,\n          show_emails: show_emails,\n          inviter: inviter,\n          type: filter,\n          counts: {\n            pending: pending_count,\n            expired: expired_count,\n            redeemed: redeemed_count,\n            total: pending_count + expired_count\n          }\n        ),\n        scope: guardian,\n        root: false\n      ))\n    elsif current_user&.staff?\n      message = if SiteSetting.enable_discourse_connect\n        I18n.t(\"invite.disabled_errors.discourse_connect_enabled\")\n      end\n\n      render_invite_error(message)\n    else\n      render_json_error(I18n.t(\"invite.disabled_errors.invalid_access\"))\n    end\n  end\n\n  def is_local_username\n    usernames = params[:usernames] if params[:usernames].present?\n    usernames = [params[:username]] if params[:username].present?\n\n    raise Discourse::InvalidParameters.new(:usernames) if !usernames.kind_of?(Array) || usernames.size > 20\n\n    groups = Group.where(name: usernames).pluck(:name)\n    mentionable_groups =\n      if current_user\n        Group.mentionable(current_user, include_public: false)\n          .where(name: usernames)\n          .pluck(:name, :user_count)\n          .map do |name, user_count|\n          {\n            name: name,\n            user_count: user_count\n          }\n        end\n      end\n\n    usernames -= groups\n    usernames.each(&:downcase!)\n\n    users = User\n      .where(staged: false, username_lower: usernames)\n      .index_by(&:username_lower)\n\n    cannot_see = {}\n    here_count = nil\n\n    topic_id = params[:topic_id]\n    if topic_id.present? && topic = Topic.find_by(id: topic_id)\n      topic_muted_by = TopicUser\n        .where(topic: topic)\n        .where(user_id: users.values.map(&:id))\n        .where(notification_level: TopicUser.notification_levels[:muted])\n        .pluck(:user_id)\n        .to_set\n\n      if topic.private_message?\n        topic_allowed_user_ids = TopicAllowedUser\n          .where(topic: topic)\n          .where(user_id: users.values.map(&:id))\n          .pluck(:user_id)\n          .to_set\n\n        topic_allowed_group_ids = TopicAllowedGroup\n          .where(topic: topic)\n          .pluck(:group_id)\n          .to_set\n      end\n\n      usernames.each do |username|\n        user = users[username]\n        next if user.blank?\n\n        cannot_see_reason = nil\n        if !user.guardian.can_see?(topic)\n          cannot_see_reason = topic.private_message? ? :private : :category\n        elsif topic_muted_by.include?(user.id)\n          cannot_see_reason = :muted_topic\n        elsif topic.private_message? && !topic_allowed_user_ids.include?(user.id) && !user.group_ids.any? { |group_id| topic_allowed_group_ids.include?(group_id) }\n          cannot_see_reason = :not_allowed\n        end\n\n        if !guardian.is_staff? && cannot_see_reason.present? && cannot_see_reason != :private && cannot_see_reason != :category\n          cannot_see_reason = nil # do not leak private information\n        end\n\n        cannot_see[username] = cannot_see_reason if cannot_see_reason.present?\n      end\n\n      if usernames.include?(SiteSetting.here_mention) && guardian.can_mention_here?\n        here_count = PostAlerter.new.expand_here_mention(topic.first_post, exclude_ids: [current_user.id]).size\n      end\n    end\n\n    render json: {\n      valid: users.keys,\n      valid_groups: groups,\n      mentionable_groups: mentionable_groups,\n      cannot_see: cannot_see,\n      here_count: here_count,\n      max_users_notified_per_group_mention: SiteSetting.max_users_notified_per_group_mention\n    }\n  end\n\n  def render_available_true\n    render(json: { available: true })\n  end\n\n  def changing_case_of_own_username(target_user, username)\n    target_user && username.downcase == (target_user.username.downcase)\n  end\n\n  # Used for checking availability of a username and will return suggestions\n  # if the username is not available.\n  def check_username\n    if !params[:username].present?\n      params.require(:username) if !params[:email].present?\n      return render(json: success_json)\n    end\n    username = params[:username]&.unicode_normalize\n\n    target_user = user_from_params_or_current_user\n\n    # The special case where someone is changing the case of their own username\n    return render_available_true if changing_case_of_own_username(target_user, username)\n\n    checker = UsernameCheckerService.new\n    email = params[:email] || target_user.try(:email)\n    render json: checker.check_username(username, email)\n  end\n\n  def check_email\n    begin\n      RateLimiter.new(nil, \"check-email-#{request.remote_ip}\", 10, 1.minute).performed!\n    rescue RateLimiter::LimitExceeded\n      return render json: success_json\n    end\n\n    email = Email.downcase((params[:email] || \"\").strip)\n\n    if email.blank? || SiteSetting.hide_email_address_taken?\n      return render json: success_json\n    end\n\n    if !(email =~ EmailValidator.email_regex)\n      error = User.new.errors.full_message(:email, I18n.t(:'user.email.invalid'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if !EmailValidator.allowed?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:'user.email.not_allowed'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if ScreenedEmail.should_block?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:'user.email.blocked'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if User.where(staged: false).find_by_email(email).present?\n      error = User.new.errors.full_message(:email, I18n.t(:'errors.messages.taken'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    render json: success_json\n  end\n\n  def user_from_params_or_current_user\n    params[:for_user_id] ? User.find(params[:for_user_id]) : current_user\n  end\n\n  def create\n    params.require(:email)\n    params.require(:username)\n    params.require(:invite_code) if SiteSetting.require_invite_code\n    params.permit(:user_fields)\n\n    unless SiteSetting.allow_new_registrations\n      return fail_with(\"login.new_registrations_disabled\")\n    end\n\n    if params[:password] && params[:password].length > User.max_password_length\n      return fail_with(\"login.password_too_long\")\n    end\n\n    if params[:email].length > 254 + 1 + 253\n      return fail_with(\"login.email_too_long\")\n    end\n\n    if SiteSetting.require_invite_code && SiteSetting.invite_code.strip.downcase != params[:invite_code].strip.downcase\n      return fail_with(\"login.wrong_invite_code\")\n    end\n\n    if clashing_with_existing_route?(params[:username]) || User.reserved_username?(params[:username])\n      return fail_with(\"login.reserved_username\")\n    end\n\n    params[:locale] ||= I18n.locale unless current_user\n\n    new_user_params = user_params.except(:timezone)\n\n    user = User.where(staged: true).with_email(new_user_params[:email].strip.downcase).first\n\n    if user\n      user.active = false\n      user.unstage!\n    end\n\n    user ||= User.new\n    user.attributes = new_user_params\n\n    # Handle API approval and\n    # auto approve users based on auto_approve_email_domains setting\n    if user.approved? || EmailValidator.can_auto_approve_user?(user.email)\n      ReviewableUser.set_approved_fields!(user, current_user)\n    end\n\n    # Handle custom fields\n    user_fields = UserField.all\n    if user_fields.present?\n      field_params = params[:user_fields] || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        if field_val.blank?\n          return fail_with(\"login.missing_user_field\") if f.required?\n        else\n          fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[0...UserField.max_length]\n        end\n      end\n\n      user.custom_fields = fields\n    end\n\n    authentication = UserAuthenticator.new(user, session)\n\n    if !authentication.has_authenticator? && !SiteSetting.enable_local_logins && !(current_user&.admin? && is_api?)\n      return render body: nil, status: :forbidden\n    end\n\n    authentication.start\n\n    if authentication.email_valid? && !authentication.authenticated?\n      # posted email is different that the already validated one?\n      return fail_with('login.incorrect_username_email_or_password')\n    end\n\n    activation = UserActivator.new(user, request, session, cookies)\n    activation.start\n\n    # just assign a password if we have an authenticator and no password\n    # this is the case for Twitter\n    user.password = SecureRandom.hex if user.password.blank? && authentication.has_authenticator?\n\n    if user.save\n      authentication.finish\n      activation.finish\n      user.update_timezone_if_missing(params[:timezone])\n\n      secure_session[HONEYPOT_KEY] = nil\n      secure_session[CHALLENGE_KEY] = nil\n\n      # save user email in session, to show on account-created page\n      session[\"user_created_message\"] = activation.message\n      session[SessionController::ACTIVATE_USER_KEY] = user.id\n\n      # If the user was created as active this will\n      # ensure their email is confirmed and\n      # add them to the review queue if they need to be approved\n      user.activate if user.active?\n\n      render json: {\n        success: true,\n        active: user.active?,\n        message: activation.message,\n      }.merge(SiteSetting.hide_email_address_taken ? {} : { user_id: user.id })\n    elsif SiteSetting.hide_email_address_taken && user.errors[:primary_email]&.include?(I18n.t('errors.messages.taken'))\n      session[\"user_created_message\"] = activation.success_message\n\n      if existing_user = User.find_by_email(user.primary_email&.email)\n        Jobs.enqueue(:critical_user_email, type: :account_exists, user_id: existing_user.id)\n      end\n\n      render json: {\n        success: true,\n        active: false,\n        message: activation.success_message\n      }\n    else\n      errors = user.errors.to_hash\n      errors[:email] = errors.delete(:primary_email) if errors[:primary_email]\n\n      render json: {\n        success: false,\n        message: I18n.t(\n          'login.errors',\n          errors: user.errors.full_messages.join(\"\\n\")\n        ),\n        errors: errors,\n        values: {\n          name: user.name,\n          username: user.username,\n          email: user.primary_email&.email\n        },\n        is_developer: UsernameCheckerService.is_developer?(user.email)\n      }\n    end\n  rescue ActiveRecord::StatementInvalid\n    render json: {\n      success: false,\n      message: I18n.t(\"login.something_already_taken\")\n    }\n  end\n\n  def password_reset_show\n    expires_now\n    token = params[:token]\n\n    password_reset_find_user(token, committing_change: false)\n\n    if !@error\n      security_params = {\n        is_developer: UsernameCheckerService.is_developer?(@user.email),\n        admin: @user.admin?,\n        second_factor_required: @user.totp_enabled?,\n        security_key_required: @user.security_keys_enabled?,\n        backup_enabled: @user.backup_codes_enabled?,\n        multiple_second_factor_methods: @user.has_multiple_second_factor_methods?\n      }\n    end\n\n    respond_to do |format|\n      format.html do\n        return render 'password_reset', layout: 'no_ember' if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        store_preloaded(\n          \"password_reset\",\n          MultiJson.dump(security_params.merge(Webauthn.allowed_credentials(@user, secure_session)))\n        )\n\n        render 'password_reset'\n      end\n\n      format.json do\n        return render json: { message: @error } if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        render json: security_params.merge(Webauthn.allowed_credentials(@user, secure_session))\n      end\n    end\n  end\n\n  def password_reset_update\n    expires_now\n    token = params[:token]\n    password_reset_find_user(token, committing_change: true)\n\n    rate_limit_second_factor!(@user)\n\n    # no point doing anything else if we can't even find\n    # a user from the token\n    if @user\n      if !secure_session[\"second-factor-#{token}\"]\n        second_factor_authentication_result = @user.authenticate_second_factor(params, secure_session)\n        if !second_factor_authentication_result.ok\n          user_error_key = second_factor_authentication_result.reason == \"invalid_security_key\" ? :user_second_factors : :security_keys\n          @user.errors.add(user_error_key, :invalid)\n          @error = second_factor_authentication_result.error\n        else\n\n          # this must be set because the first call we authenticate e.g. TOTP, and we do\n          # not want to re-authenticate on the second call to change the password as this\n          # will cause a TOTP error saying the code has already been used\n          secure_session[\"second-factor-#{token}\"] = true\n        end\n      end\n\n      if @invalid_password = params[:password].blank? || params[:password].size > User.max_password_length\n        @user.errors.add(:password, :invalid)\n      end\n\n      # if we have run into no errors then the user is a-ok to\n      # change the password\n      if @user.errors.empty?\n        @user.update_timezone_if_missing(params[:timezone]) if params[:timezone]\n        @user.password = params[:password]\n        @user.password_required!\n        @user.user_auth_tokens.destroy_all\n        if @user.save\n          Invite.invalidate_for_email(@user.email) # invite link can't be used to log in anymore\n          secure_session[\"password-#{token}\"] = nil\n          secure_session[\"second-factor-#{token}\"] = nil\n          UserHistory.create!(\n            target_user: @user,\n            acting_user: @user,\n            action: UserHistory.actions[:change_password]\n          )\n          logon_after_password_reset\n        end\n      end\n    end\n\n    respond_to do |format|\n      format.html do\n        return render 'password_reset', layout: 'no_ember' if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n\n        security_params = {\n          is_developer: UsernameCheckerService.is_developer?(@user.email),\n          admin: @user.admin?,\n          second_factor_required: @user.totp_enabled?,\n          security_key_required: @user.security_keys_enabled?,\n          backup_enabled: @user.backup_codes_enabled?,\n          multiple_second_factor_methods: @user.has_multiple_second_factor_methods?\n        }.merge(Webauthn.allowed_credentials(@user, secure_session))\n\n        store_preloaded(\"password_reset\", MultiJson.dump(security_params))\n\n        return redirect_to(wizard_path) if Wizard.user_requires_completion?(@user)\n\n        render 'password_reset'\n      end\n\n      format.json do\n        if @error || @user&.errors&.any?\n          render json: {\n            success: false,\n            message: @error,\n            errors: @user&.errors&.to_hash,\n            is_developer: UsernameCheckerService.is_developer?(@user&.email),\n            admin: @user&.admin?\n          }\n        else\n          render json: {\n            success: true,\n            message: @success,\n            requires_approval: !Guardian.new(@user).can_access_forum?,\n            redirect_to: Wizard.user_requires_completion?(@user) ? wizard_path : nil\n          }\n        end\n      end\n    end\n  end\n\n  def confirm_email_token\n    expires_now\n    EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n    render json: success_json\n  end\n\n  def logon_after_password_reset\n    message =\n      if Guardian.new(@user).can_access_forum?\n        # Log in the user\n        log_on_user(@user)\n        'password_reset.success'\n      else\n        @requires_approval = true\n        'password_reset.success_unapproved'\n      end\n\n    @success = I18n.t(message)\n  end\n\n  def admin_login\n    return redirect_to(path(\"/\")) if current_user\n\n    if request.put? && params[:email].present?\n      RateLimiter.new(nil, \"admin-login-hr-#{request.remote_ip}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"admin-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n\n      if user = User.with_email(params[:email]).admins.human_users.first\n        email_token = user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n        Jobs.enqueue(:critical_user_email, type: :admin_login, user_id: user.id, email_token: email_token.token)\n        @message = I18n.t(\"admin_login.success\")\n      else\n        @message = I18n.t(\"admin_login.errors.unknown_email_address\")\n      end\n    end\n\n    render layout: 'no_ember'\n  rescue RateLimiter::LimitExceeded\n    @message = I18n.t(\"rate_limiter.slow_down\")\n    render layout: 'no_ember'\n  end\n\n  def email_login\n    raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email\n    return redirect_to path(\"/\") if current_user\n\n    expires_now\n    params.require(:login)\n\n    RateLimiter.new(nil, \"email-login-hour-#{request.remote_ip}\", 6, 1.hour).performed!\n    RateLimiter.new(nil, \"email-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n    user = User.human_users.find_by_username_or_email(params[:login])\n    user_presence = user.present? && !user.staged\n\n    if user\n      RateLimiter.new(nil, \"email-login-hour-#{user.id}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"email-login-min-#{user.id}\", 3, 1.minute).performed!\n\n      if user_presence\n        DiscourseEvent.trigger(:before_email_login, user)\n\n        email_token = user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n\n        Jobs.enqueue(:critical_user_email,\n          type: :email_login,\n          user_id: user.id,\n          email_token: email_token.token\n        )\n      end\n    end\n\n    json = success_json\n    json[:hide_taken] = SiteSetting.hide_email_address_taken\n    json[:user_found] = user_presence unless SiteSetting.hide_email_address_taken\n    render json: json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def toggle_anon\n    user = AnonymousShadowCreator.get_master(current_user) ||\n           AnonymousShadowCreator.get(current_user)\n\n    if user\n      log_on_user(user)\n      render json: success_json\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def account_created\n    if current_user.present?\n      if SiteSetting.enable_discourse_connect_provider && payload = cookies.delete(:sso_payload)\n        return redirect_to(session_sso_provider_url + \"?\" + payload)\n      elsif destination_url = cookies.delete(:destination_url)\n        return redirect_to(destination_url)\n      else\n        return redirect_to(path('/'))\n      end\n    end\n\n    @custom_body_class = \"static-account-created\"\n    @message = session['user_created_message'] || I18n.t('activation.missing_session')\n    @account_created = { message: @message, show_controls: false }\n\n    if session_user_id = session[SessionController::ACTIVATE_USER_KEY]\n      if user = User.where(id: session_user_id.to_i).first\n        @account_created[:username] = user.username\n        @account_created[:email] = user.email\n        @account_created[:show_controls] = !user.from_staged?\n      end\n    end\n\n    store_preloaded(\"accountCreated\", MultiJson.dump(@account_created))\n    expires_now\n\n    respond_to do |format|\n      format.html { render \"default/empty\" }\n      format.json { render json: success_json }\n    end\n  end\n\n  def activate_account\n    expires_now\n    render layout: 'no_ember'\n  end\n\n  def perform_account_activation\n    raise Discourse::InvalidAccess.new if honeypot_or_challenge_fails?(params)\n\n    if @user = EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n      # Log in the user unless they need to be approved\n      if Guardian.new(@user).can_access_forum?\n        @user.enqueue_welcome_message('welcome_user') if @user.send_welcome_message\n        log_on_user(@user)\n\n        if Wizard.user_requires_completion?(@user)\n          return redirect_to(wizard_path)\n        elsif destination_url = cookies[:destination_url]\n          cookies[:destination_url] = nil\n          return redirect_to(destination_url)\n        elsif SiteSetting.enable_discourse_connect_provider && payload = cookies.delete(:sso_payload)\n          return redirect_to(session_sso_provider_url + \"?\" + payload)\n        end\n      else\n        @needs_approval = true\n      end\n    else\n      flash.now[:error] = I18n.t('activation.already_done')\n    end\n\n    render layout: 'no_ember'\n  end\n\n  def update_activation_email\n    RateLimiter.new(nil, \"activate-edit-email-hr-#{request.remote_ip}\", 5, 1.hour).performed!\n\n    if params[:username].present?\n      @user = User.find_by_username_or_email(params[:username])\n      raise Discourse::InvalidAccess.new unless @user.present?\n      raise Discourse::InvalidAccess.new unless @user.confirm_password?(params[:password])\n    elsif user_key = session[SessionController::ACTIVATE_USER_KEY]\n      @user = User.where(id: user_key.to_i).first\n    end\n\n    if @user.blank? || @user.active? || current_user.present? || @user.from_staged?\n      raise Discourse::InvalidAccess.new\n    end\n\n    User.transaction do\n      primary_email = @user.primary_email\n      primary_email.email = params[:email]\n      primary_email.skip_validate_email = false\n\n      if primary_email.save\n        @email_token = @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n        render json: success_json\n      else\n        render_json_error(primary_email)\n      end\n    end\n  end\n\n  def send_activation_email\n    if current_user.blank? || !current_user.staff?\n      RateLimiter.new(nil, \"activate-hr-#{request.remote_ip}\", 30, 1.hour).performed!\n      RateLimiter.new(nil, \"activate-min-#{request.remote_ip}\", 6, 1.minute).performed!\n    end\n\n    raise Discourse::InvalidAccess.new if SiteSetting.must_approve_users?\n\n    if params[:username].present?\n      @user = User.find_by_username_or_email(params[:username].to_s)\n    end\n\n    raise Discourse::NotFound unless @user\n\n    if !current_user&.staff? && @user.id != session[SessionController::ACTIVATE_USER_KEY]\n      raise Discourse::InvalidAccess.new\n    end\n\n    session.delete(SessionController::ACTIVATE_USER_KEY)\n\n    if @user.active && @user.email_confirmed?\n      render_json_error(I18n.t('activation.activated'), status: 409)\n    else\n      @email_token = @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n      EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n      render body: nil\n    end\n  end\n\n  def search_users\n    term = params[:term].to_s.strip\n\n    topic_id = params[:topic_id].to_i if params[:topic_id].present?\n    category_id = params[:category_id].to_i if params[:category_id].present?\n\n    topic_allowed_users = params[:topic_allowed_users] || false\n\n    group_names = params[:groups] || []\n    group_names << params[:group] if params[:group]\n    @groups = Group.where(name: group_names) if group_names.present?\n\n    options = {\n     topic_allowed_users: topic_allowed_users,\n     searching_user: current_user,\n     groups: @groups\n    }\n\n    options[:include_staged_users] = !!ActiveModel::Type::Boolean.new.cast(params[:include_staged_users])\n    options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users])\n    if params[:limit].present?\n      options[:limit] = params[:limit].to_i\n      raise Discourse::InvalidParameters.new(:limit) if options[:limit] <= 0\n    end\n    options[:topic_id] = topic_id if topic_id\n    options[:category_id] = category_id if category_id\n\n    results = UserSearch.new(term, options).search\n\n    user_fields = [:username, :upload_avatar_template]\n    user_fields << :name if SiteSetting.enable_names?\n\n    to_render = { users: results.as_json(only: user_fields, methods: [:avatar_template]) }\n\n    # blank term is only handy for in-topic search of users after @\n    # we do not want group results ever if term is blank\n    groups =\n      if term.present? && current_user\n        if params[:include_groups] == 'true'\n          Group.visible_groups(current_user)\n        elsif params[:include_mentionable_groups] == 'true'\n          Group.mentionable(current_user)\n        elsif params[:include_messageable_groups] == 'true'\n          Group.messageable(current_user)\n        end\n      end\n\n    if groups\n      DiscoursePluginRegistry.groups_callback_for_users_search_controller_action.each do |param_name, block|\n        if params[param_name.to_s]\n          groups = block.call(groups, current_user)\n        end\n      end\n\n      groups = Group.search_groups(term, groups: groups)\n      groups = groups.order('groups.name asc')\n\n      to_render[:groups] = groups.map do |m|\n        { name: m.name, full_name: m.full_name }\n      end\n    end\n\n    render json: to_render\n  end\n\n  AVATAR_TYPES_WITH_UPLOAD ||= %w{uploaded custom gravatar}\n\n  def pick_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    if SiteSetting.discourse_connect_overrides_avatar\n      return render json: failed_json, status: 422\n    end\n\n    type = params[:type]\n\n    invalid_type = type.present? && !AVATAR_TYPES_WITH_UPLOAD.include?(type) && type != 'system'\n    if invalid_type\n      return render json: failed_json, status: 422\n    end\n\n    if type.blank? || type == 'system'\n      upload_id = nil\n    elsif !TrustLevelAndStaffAndDisabledSetting.matches?(SiteSetting.allow_uploaded_avatars, user)\n      return render json: failed_json, status: 422\n    else\n      upload_id = params[:upload_id]\n      upload = Upload.find_by(id: upload_id)\n\n      if upload.nil?\n        return render_json_error I18n.t('avatar.missing')\n      end\n\n      # old safeguard\n      user.create_user_avatar unless user.user_avatar\n\n      guardian.ensure_can_pick_avatar!(user.user_avatar, upload)\n\n      if type == 'gravatar'\n        user.user_avatar.gravatar_upload_id = upload_id\n      else\n        user.user_avatar.custom_upload_id = upload_id\n      end\n    end\n\n    if user.is_system_user?\n      SiteSetting.use_site_small_logo_as_system_avatar = false\n    end\n\n    user.uploaded_avatar_id = upload_id\n    user.save!\n    user.user_avatar.save!\n\n    render json: success_json\n  end\n\n  def select_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    url = params[:url]\n\n    if url.blank?\n      return render json: failed_json, status: 422\n    end\n\n    unless SiteSetting.selectable_avatars_enabled\n      return render json: failed_json, status: 422\n    end\n\n    if SiteSetting.selectable_avatars.blank?\n      return render json: failed_json, status: 422\n    end\n\n    unless upload = Upload.get_from_url(url)\n      return render json: failed_json, status: 422\n    end\n\n    unless SiteSetting.selectable_avatars.include?(upload)\n      return render json: failed_json, status: 422\n    end\n\n    user.uploaded_avatar_id = upload.id\n\n    if user.is_system_user?\n      SiteSetting.use_site_small_logo_as_system_avatar = false\n    end\n\n    user.save!\n\n    avatar = user.user_avatar || user.create_user_avatar\n    avatar.custom_upload_id = upload.id\n    avatar.save!\n\n    render json: {\n      avatar_template: user.avatar_template,\n      custom_avatar_template: user.avatar_template,\n      uploaded_avatar_id: upload.id,\n    }\n  end\n\n  def destroy_user_image\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    case params.require(:type)\n    when \"profile_background\"\n      user.user_profile.clear_profile_background\n    when \"card_background\"\n      user.user_profile.clear_card_background\n    else\n      raise Discourse::InvalidParameters.new(:type)\n    end\n\n    render json: success_json\n  end\n\n  def destroy\n    @user = fetch_user_from_params\n    guardian.ensure_can_delete_user!(@user)\n\n    UserDestroyer.new(current_user).destroy(@user, delete_posts: true, context: params[:context])\n\n    render json: success_json\n  end\n\n  def notification_level\n    user = fetch_user_from_params\n\n    if params[:notification_level] == \"ignore\"\n      @error_message = \"ignore_error\"\n      guardian.ensure_can_ignore_user!(user)\n      MutedUser.where(user: current_user, muted_user: user).delete_all\n      ignored_user = IgnoredUser.find_by(user: current_user, ignored_user: user)\n      if ignored_user.present?\n        ignored_user.update(expiring_at: DateTime.parse(params[:expiring_at]))\n      else\n        IgnoredUser.create!(user: current_user, ignored_user: user, expiring_at: Time.parse(params[:expiring_at]))\n      end\n    elsif params[:notification_level] == \"mute\"\n      @error_message = \"mute_error\"\n      guardian.ensure_can_mute_user!(user)\n      IgnoredUser.where(user: current_user, ignored_user: user).delete_all\n      MutedUser.find_or_create_by!(user: current_user, muted_user: user)\n    elsif params[:notification_level] == \"normal\"\n      MutedUser.where(user: current_user, muted_user: user).delete_all\n      IgnoredUser.where(user: current_user, ignored_user: user).delete_all\n    end\n\n    render json: success_json\n  rescue Discourse::InvalidAccess => e\n    render_json_error(I18n.t(\"notification_level.#{@error_message}\"))\n  end\n\n  def read_faq\n    if user = current_user\n      user.user_stat.read_faq = 1.second.ago\n      user.user_stat.save\n    end\n\n    render json: success_json\n  end\n\n  def recent_searches\n    if !SiteSetting.log_search_queries\n      return render json: failed_json.merge(\n                      error: I18n.t(\"user_activity.no_log_search_queries\")\n                    ), status: 403\n    end\n\n    query = SearchLog.where(user_id: current_user.id)\n\n    if current_user.user_option.oldest_search_log_date\n      query = query\n        .where(\"created_at > ?\", current_user.user_option.oldest_search_log_date)\n    end\n\n    results = query.group(:term)\n      .order(\"max(created_at) DESC\")\n      .limit(MAX_RECENT_SEARCHES)\n      .pluck(:term)\n\n    render json: success_json.merge(recent_searches: results)\n  end\n\n  def reset_recent_searches\n    current_user.user_option.update!(oldest_search_log_date: 1.second.ago)\n    render json: success_json\n  end\n\n  def staff_info\n    @user = fetch_user_from_params(include_inactive: true)\n    guardian.ensure_can_see_staff_info!(@user)\n\n    result = {}\n\n    %W{\n      number_of_deleted_posts number_of_flagged_posts number_of_flags_given\n      number_of_suspensions warnings_received_count number_of_rejected_posts\n    }.each do |info|\n      result[info] = @user.public_send(info)\n    end\n\n    render json: result\n  end\n\n  def confirm_admin\n    @confirmation = AdminConfirmation.find_by_code(params[:token])\n\n    raise Discourse::NotFound unless @confirmation\n    raise Discourse::InvalidAccess.new unless\n      @confirmation.performed_by.id == (current_user&.id || @confirmation.performed_by.id)\n\n    if request.post?\n      @confirmation.email_confirmed!\n      @confirmed = true\n    end\n\n    respond_to do |format|\n      format.json { render json: success_json }\n      format.html { render layout: 'no_ember' }\n    end\n  end\n\n  def list_second_factors\n    raise Discourse::NotFound if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n\n    unless params[:password].empty?\n      RateLimiter.new(nil, \"login-hr-#{request.remote_ip}\", SiteSetting.max_logins_per_ip_per_hour, 1.hour).performed!\n      RateLimiter.new(nil, \"login-min-#{request.remote_ip}\", SiteSetting.max_logins_per_ip_per_minute, 1.minute).performed!\n      unless current_user.confirm_password?(params[:password])\n        return render json: failed_json.merge(\n                        error: I18n.t(\"login.incorrect_password\")\n                      )\n      end\n      confirm_secure_session\n    end\n\n    if secure_session_confirmed?\n      totp_second_factors = current_user.totps\n        .select(:id, :name, :last_used, :created_at, :method)\n        .where(enabled: true).order(:created_at)\n\n      security_keys = current_user.security_keys.where(factor_type: UserSecurityKey.factor_types[:second_factor]).order(:created_at)\n\n      render json: success_json.merge(\n               totps: totp_second_factors,\n               security_keys: security_keys\n             )\n    else\n      render json: success_json.merge(\n               password_required: true\n             )\n    end\n  end\n\n  def create_second_factor_backup\n    backup_codes = current_user.generate_backup_codes\n\n    render json: success_json.merge(\n      backup_codes: backup_codes\n    )\n  end\n\n  def create_second_factor_totp\n    require 'rotp' if !defined? ROTP\n    totp_data = ROTP::Base32.random\n    secure_session[\"staged-totp-#{current_user.id}\"] = totp_data\n    qrcode_png = RQRCode::QRCode.new(current_user.totp_provisioning_uri(totp_data)).as_png(\n      border_modules: 1,\n      size: 240\n    )\n\n    render json: success_json.merge(\n             key: totp_data.scan(/.{4}/).join(\" \"),\n             qr: qrcode_png.to_data_url\n           )\n  end\n\n  def create_second_factor_security_key\n    challenge_session = Webauthn.stage_challenge(current_user, secure_session)\n    render json: success_json.merge(\n      challenge: challenge_session.challenge,\n      rp_id: challenge_session.rp_id,\n      rp_name: challenge_session.rp_name,\n      supported_algorithms: ::Webauthn::SUPPORTED_ALGORITHMS,\n      user_secure_id: current_user.create_or_fetch_secure_identifier,\n      existing_active_credential_ids: current_user.second_factor_security_key_credential_ids\n    )\n  end\n\n  def register_second_factor_security_key\n    params.require(:name)\n    params.require(:attestation)\n    params.require(:clientData)\n\n    ::Webauthn::SecurityKeyRegistrationService.new(\n      current_user,\n      params,\n      challenge: Webauthn.challenge(current_user, secure_session),\n      rp_id: Webauthn.rp_id(current_user, secure_session),\n      origin: Discourse.base_url\n    ).register_second_factor_security_key\n    render json: success_json\n  rescue ::Webauthn::SecurityKeyError => err\n    render json: failed_json.merge(error: err.message)\n  end\n\n  def update_security_key\n    user_security_key = current_user.security_keys.find_by(id: params[:id].to_i)\n    raise Discourse::InvalidParameters unless user_security_key\n\n    if params[:name] && !params[:name].blank?\n      user_security_key.update!(name: params[:name])\n    end\n    if params[:disable] == \"true\"\n      user_security_key.update!(enabled: false)\n    end\n\n    render json: success_json\n  end\n\n  def enable_second_factor_totp\n    if params[:second_factor_token].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_code\"))\n    end\n    if params[:name].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_name\"))\n    end\n    auth_token = params[:second_factor_token]\n\n    totp_data = secure_session[\"staged-totp-#{current_user.id}\"]\n    totp_object = current_user.get_totp_object(totp_data)\n\n    rate_limit_second_factor!(current_user)\n\n    authenticated = !auth_token.blank? && totp_object.verify(\n      auth_token,\n      drift_ahead: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS,\n      drift_behind: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS\n    )\n    unless authenticated\n      return render json: failed_json.merge(\n                      error: I18n.t(\"login.invalid_second_factor_code\")\n                    )\n    end\n    current_user.create_totp(data: totp_data, name: params[:name], enabled: true)\n    render json: success_json\n  end\n\n  def disable_second_factor\n    # delete all second factors for a user\n    current_user.user_second_factors.destroy_all\n    current_user.security_keys.destroy_all\n\n    Jobs.enqueue(\n      :critical_user_email,\n      type: :account_second_factor_disabled,\n      user_id: current_user.id\n    )\n\n    render json: success_json\n  end\n\n  def update_second_factor\n    params.require(:second_factor_target)\n    update_second_factor_method = params[:second_factor_target].to_i\n\n    if update_second_factor_method == UserSecondFactor.methods[:totp]\n      params.require(:id)\n      second_factor_id = params[:id].to_i\n      user_second_factor = current_user.user_second_factors.totps.find_by(id: second_factor_id)\n    elsif update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n      user_second_factor = current_user.user_second_factors.backup_codes\n    end\n\n    raise Discourse::InvalidParameters unless user_second_factor\n\n    if params[:name] && !params[:name].blank?\n      user_second_factor.update!(name: params[:name])\n    end\n    if params[:disable] == \"true\"\n      # Disabling backup codes deletes *all* backup codes\n      if update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n        current_user.user_second_factors.where(method: UserSecondFactor.methods[:backup_codes]).destroy_all\n      else\n        user_second_factor.update!(enabled: false)\n      end\n\n    end\n\n    render json: success_json\n  end\n\n  def second_factor_check_confirmed_password\n    raise Discourse::NotFound if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n\n    raise Discourse::InvalidAccess.new unless current_user && secure_session_confirmed?\n  end\n\n  def revoke_account\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    provider_name = params.require(:provider_name)\n\n    # Using Discourse.authenticators rather than Discourse.enabled_authenticators so users can\n    # revoke permissions even if the admin has temporarily disabled that type of login\n    authenticator = Discourse.authenticators.find { |a| a.name == provider_name }\n    raise Discourse::NotFound if authenticator.nil? || !authenticator.can_revoke?\n\n    skip_remote = params.permit(:skip_remote)\n\n    # We're likely going to contact the remote auth provider, so hijack request\n    hijack do\n      DiscourseEvent.trigger(:before_auth_revoke, authenticator, user)\n      result = authenticator.revoke(user, skip_remote: skip_remote)\n      if result\n        render json: success_json\n      else\n        render json: {\n          success: false,\n          message: I18n.t(\"associated_accounts.revoke_failed\", provider_name: provider_name)\n        }\n      end\n    end\n  end\n\n  def revoke_auth_token\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    if params[:token_id]\n      token = UserAuthToken.find_by(id: params[:token_id], user_id: user.id)\n      # The user should not be able to revoke the auth token of current session.\n      raise Discourse::InvalidParameters.new(:token_id) if !token || guardian.auth_token == token.auth_token\n      UserAuthToken.where(id: params[:token_id], user_id: user.id).each(&:destroy!)\n\n      MessageBus.publish \"/file-change\", [\"refresh\"], user_ids: [user.id]\n    else\n      UserAuthToken.where(user_id: user.id).each(&:destroy!)\n    end\n\n    render json: success_json\n  end\n\n  def feature_topic\n    user = fetch_user_from_params\n    topic = Topic.find(params[:topic_id].to_i)\n\n    if !guardian.can_feature_topic?(user, topic)\n      return render_json_error(I18n.t('activerecord.errors.models.user_profile.attributes.featured_topic_id.invalid'), 403)\n    end\n\n    user.user_profile.update(featured_topic_id: topic.id)\n    render json: success_json\n  end\n\n  def clear_featured_topic\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    user.user_profile.update(featured_topic_id: nil)\n    render json: success_json\n  end\n\n  def bookmarks\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    respond_to do |format|\n      format.json do\n        bookmark_list = UserBookmarkList.new(user: user, guardian: guardian, params: params)\n        bookmark_list.load\n\n        if bookmark_list.bookmarks.empty?\n          render json: {\n            bookmarks: []\n          }\n        else\n          page = params[:page].to_i + 1\n          bookmark_list.more_bookmarks_url = \"#{Discourse.base_path}/u/#{params[:username]}/bookmarks.json?page=#{page}\"\n          render_serialized(bookmark_list, UserBookmarkListSerializer)\n        end\n      end\n      format.ics do\n        @bookmark_reminders = Bookmark.with_reminders\n          .where(user_id: user.id)\n          .includes(:topic)\n          .order(:reminder_at)\n      end\n    end\n  end\n\n  private\n\n  def clean_custom_field_values(field)\n    field_values = params[:user_fields][field.id.to_s]\n\n    return field_values if field_values.nil? || field_values.empty?\n\n    if field.field_type == \"dropdown\"\n      field.user_field_options.find_by_value(field_values)&.value\n    elsif field.field_type == \"multiselect\"\n      field_values = Array.wrap(field_values)\n      bad_values = field_values - field.user_field_options.map(&:value)\n      field_values - bad_values\n    else\n      field_values\n    end\n  end\n\n  def password_reset_find_user(token, committing_change:)\n    @user = if committing_change\n      EmailToken.confirm(token, scope: EmailToken.scopes[:password_reset])\n    else\n      EmailToken.confirmable(token, scope: EmailToken.scopes[:password_reset])&.user\n    end\n\n    if @user\n      secure_session[\"password-#{token}\"] = @user.id\n    else\n      user_id = secure_session[\"password-#{token}\"].to_i\n      @user = User.find(user_id) if user_id > 0\n    end\n\n    @error = I18n.t('password_reset.no_token') if !@user\n  end\n\n  def respond_to_suspicious_request\n    if suspicious?(params)\n      render json: {\n        success: true,\n        active: false,\n        message: I18n.t(\"login.activate_email\", email: params[:email])\n      }\n    end\n  end\n\n  def suspicious?(params)\n    return false if current_user && is_api? && current_user.admin?\n    honeypot_or_challenge_fails?(params) || SiteSetting.invite_only?\n  end\n\n  def honeypot_or_challenge_fails?(params)\n    return false if is_api?\n    params[:password_confirmation] != honeypot_value ||\n    params[:challenge] != challenge_value.try(:reverse)\n  end\n\n  def user_params\n    permitted = [\n      :name,\n      :email,\n      :password,\n      :username,\n      :title,\n      :date_of_birth,\n      :muted_usernames,\n      :allowed_pm_usernames,\n      :theme_ids,\n      :locale,\n      :bio_raw,\n      :location,\n      :website,\n      :dismissed_banner_key,\n      :profile_background_upload_url,\n      :card_background_upload_url,\n      :primary_group_id,\n      :flair_group_id,\n      :featured_topic_id\n    ]\n\n    editable_custom_fields = User.editable_user_custom_fields(by_staff: current_user.try(:staff?))\n    permitted << { custom_fields: editable_custom_fields } unless editable_custom_fields.blank?\n    permitted.concat UserUpdater::OPTION_ATTR\n    permitted.concat UserUpdater::CATEGORY_IDS.keys.map { |k| { k => [] } }\n    permitted.concat UserUpdater::TAG_NAMES.keys\n    permitted << UserUpdater::NOTIFICATION_SCHEDULE_ATTRS\n\n    result = params\n      .permit(permitted, theme_ids: [])\n      .reverse_merge(\n        ip_address: request.remote_ip,\n        registration_ip_address: request.remote_ip\n      )\n\n    if !UsernameCheckerService.is_developer?(result['email']) &&\n        is_api? &&\n        current_user.present? &&\n        current_user.admin?\n\n      result.merge!(params.permit(:active, :staged, :approved))\n    end\n\n    modify_user_params(result)\n  end\n\n  # Plugins can use this to modify user parameters\n  def modify_user_params(attrs)\n    attrs\n  end\n\n  def fail_with(key)\n    render json: { success: false, message: I18n.t(key) }\n  end\n\n  def track_visit_to_user_profile\n    user_profile_id = @user.user_profile.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n\n    Scheduler::Defer.later 'Track profile view visit' do\n      UserProfileView.add(user_profile_id, ip, user_id)\n    end\n  end\n\n  def clashing_with_existing_route?(username)\n    normalized_username = User.normalize_username(username)\n    http_verbs = %w[GET POST PUT DELETE PATCH]\n    allowed_actions = %w[show update destroy]\n\n    http_verbs.any? do |verb|\n      begin\n        path = Rails.application.routes.recognize_path(\"/u/#{normalized_username}\", method: verb)\n        allowed_actions.exclude?(path[:action])\n      rescue ActionController::RoutingError\n        false\n      end\n    end\n  end\n\n  def confirm_secure_session\n    secure_session[\"confirmed-password-#{current_user.id}\"] = \"true\"\n  end\n\n  def secure_session_confirmed?\n    secure_session[\"confirmed-password-#{current_user.id}\"] == \"true\"\n  end\n\n  def summary_cache_key(user)\n    \"user_summary:#{user.id}:#{current_user ? current_user.id : 0}\"\n  end\n\n  def render_invite_error(message)\n    render json: {\n      invites: [],\n      can_see_invite_details: false,\n      error: message\n    }\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'rotp'\n\ndescribe UsersController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user1) { Fabricate(:user) }\n  fab!(:another_user) { Fabricate(:user) }\n  fab!(:invitee) { Fabricate(:user) }\n  fab!(:inviter) { Fabricate(:user) }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:inactive_user) { Fabricate(:inactive_user) }\n\n  # Unfortunately, there are tests that depend on the user being created too\n  # late for fab! to work.\n  let(:user_deferred) { Fabricate(:user) }\n\n  describe \"#full account registration flow\" do\n    it \"will correctly handle honeypot and challenge\" do\n\n      get '/session/hp.json'\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      params = {\n        email: 'jane@jane.com',\n        name: 'jane',\n        username: 'jane',\n        password_confirmation: json['value'],\n        challenge: json['challenge'].reverse,\n        password: SecureRandom.hex\n      }\n\n      secure_session = SecureSession.new(session[\"secure_session_id\"])\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(json[\"value\"])\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(json[\"challenge\"])\n\n      post '/u.json', params: params\n\n      expect(response.status).to eq(200)\n\n      jane = User.find_by(username: 'jane')\n\n      expect(jane.email).to eq('jane@jane.com')\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(nil)\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(nil)\n    end\n  end\n\n  describe '#perform_account_activation' do\n    let(:email_token) { Fabricate(:email_token, user: user_deferred) }\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false)\n    end\n\n    context 'invalid token' do\n      it 'return success' do\n        put \"/u/activate-account/invalid-tooken\"\n        expect(response.status).to eq(200)\n        expect(flash[:error]).to be_present\n      end\n    end\n\n    context 'valid token' do\n      context 'welcome message' do\n        it 'enqueues a welcome message if the user object indicates so' do\n          SiteSetting.send_welcome_message = true\n          user_deferred.update(active: false)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(Jobs::SendSystemMessage.jobs.first[\"args\"].first[\"message_type\"]).to eq(\"welcome_user\")\n        end\n\n        it \"doesn't enqueue the welcome message if the object returns false\" do\n          user_deferred.update(active: true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n        end\n      end\n\n      context \"honeypot\" do\n        it \"raises an error if the honeypot is invalid\" do\n          UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'response' do\n        it 'correctly logs on user' do\n          email_token\n\n          events = DiscourseEvent.track_events do\n            put \"/u/activate-account/#{email_token.token}\"\n          end\n\n          expect(events.map { |event| event[:event_name] }).to contain_exactly(\n            :user_confirmed_email, :user_first_logged_in, :user_logged_in\n          )\n\n          expect(response.status).to eq(200)\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_present\n\n          expect(CGI.unescapeHTML(response.body))\n            .to_not include(I18n.t('activation.approval_required'))\n        end\n      end\n\n      context 'user is not approved' do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it 'should return the right response' do\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n\n          expect(CGI.unescapeHTML(response.body))\n            .to include(I18n.t('activation.approval_required'))\n\n          expect(response.body).to_not have_tag(:script, with: {\n            src: '/assets/application.js'\n          })\n\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_blank\n        end\n      end\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n  end\n\n  describe '#password_reset' do\n    let(:token) { SecureRandom.hex }\n\n    context \"you can view it even if login is required\" do\n      it \"returns success\" do\n        SiteSetting.login_required = true\n        get \"/u/password-reset/#{token}\"\n        expect(response.status).to eq(200)\n        expect(CGI.unescapeHTML(response.body)).to include(I18n.t('password_reset.no_token'))\n      end\n    end\n\n    context 'missing token' do\n      it 'disallows login' do\n        get \"/u/password-reset/#{token}\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        get \"/u/password-reset/#{token}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'invalid token' do\n      it 'disallows login' do\n        get \"/u/password-reset/ev!l_trout@!\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        put \"/u/password-reset/evil_trout!.json\", params: { password: \"awesomeSecretPassword\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'valid token' do\n      let!(:user_auth_token) { UserAuthToken.generate!(user_id: user1.id) }\n      let!(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      context 'when rendered' do\n        it 'renders referrer never on get requests' do\n          get \"/u/password-reset/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(response.body).to include('<meta name=\"referrer\" content=\"never\">')\n        end\n      end\n\n      it 'returns success' do\n        events = DiscourseEvent.track_events do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98o' }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to contain_exactly(\n          :user_logged_in, :user_first_logged_in, :user_confirmed_email\n        )\n\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":false,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n        end\n\n        expect(session[\"password-#{email_token.token}\"]).to be_blank\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(0)\n      end\n\n      it 'disallows double password reset' do\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yHG32O' }\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'test123987AsdfXYZ' }\n        expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(true)\n        expect(user1.user_auth_tokens.count).to eq(1)\n      end\n\n      it \"doesn't redirect to wizard on get\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response).not_to redirect_to(wizard_path)\n      end\n\n      it \"redirects to the wizard if you're the first admin\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}\"\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        expect(response).to redirect_to(wizard_path)\n      end\n\n      it \"sets the users timezone if the param is present\" do\n        get \"/u/password-reset/#{email_token.token}\"\n        expect(user1.user_option.timezone).to eq(nil)\n\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger', timezone: \"America/Chicago\" }\n        expect(user1.user_option.reload.timezone).to eq(\"America/Chicago\")\n      end\n\n      it \"logs the password change\" do\n        get \"/u/password-reset/#{email_token.token}\"\n\n        expect do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        end.to change { UserHistory.count }.by (1)\n\n        user_history = UserHistory.last\n        expect(user_history.target_user_id).to eq(user1.id)\n        expect(user_history.action).to eq(UserHistory.actions[:change_password])\n      end\n\n      it \"doesn't invalidate the token when loading the page\" do\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response.status).to eq(200)\n        expect(email_token.reload.confirmed).to eq(false)\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(1)\n      end\n\n      context \"rate limiting\" do\n        before { RateLimiter.clear_all!; RateLimiter.enable }\n\n        it \"rate limits reset passwords\" do\n          freeze_time\n\n          6.times do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"rate limits reset passwords by username\" do\n          freeze_time\n\n          6.times do |x|\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\" }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }, env: { \"REMOTE_ADDR\": \"1.2.3.4\" }\n\n          expect(response.status).to eq(429)\n        end\n      end\n\n      context '2 factor authentication required' do\n        fab!(:second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n        it 'does not change with an invalid token' do\n          user1.user_auth_tokens.destroy_all\n\n          get \"/u/password-reset/#{email_token.token}\"\n\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":true,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: '000000',\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          expect(response.body).to include(I18n.t(\"login.invalid_second_factor_code\"))\n\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).not_to eq(true)\n          expect(user1.user_auth_tokens.count).not_to eq(1)\n        end\n\n        it 'changes password with valid 2-factor tokens' do\n          get \"/u/password-reset/#{email_token.token}\"\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: ROTP::TOTP.new(second_factor.data).now,\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          user1.reload\n          expect(response.status).to eq(200)\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n      end\n\n      context 'security key authentication required' do\n        let!(:user_security_key) do\n          Fabricate(\n            :user_security_key,\n            user: user1,\n            credential_id: valid_security_key_data[:credential_id],\n            public_key: valid_security_key_data[:public_key]\n          )\n        end\n\n        before do\n          simulate_localhost_webauthn_challenge\n\n          # store challenge in secure session by visiting the email login page\n          get \"/u/password-reset/#{email_token.token}\"\n        end\n\n        it 'preloads with a security key challenge and allowed credential ids' do\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            password_reset = JSON.parse(json['password_reset'])\n            expect(password_reset['challenge']).not_to eq(nil)\n            expect(password_reset['allowed_credential_ids']).to eq([user_security_key.credential_id])\n            expect(password_reset['security_key_required']).to eq(true)\n          end\n        end\n\n        it 'stages a webauthn challenge and rp-id for the user' do\n          secure_session = SecureSession.new(session[\"secure_session_id\"])\n          expect(Webauthn.challenge(user1, secure_session)).not_to eq(nil)\n          expect(Webauthn.rp_id(user1, secure_session)).to eq(Discourse.current_hostname)\n        end\n\n        it 'changes password with valid security key challenge and authentication' do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: valid_security_key_auth_post_data,\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n\n        it \"does not change a password if a fake TOTP token is provided\" do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: 'blah',\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n        end\n\n        context \"when security key authentication fails\" do\n          it 'shows an error message and does not change password' do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              password: 'hg9ow8yHG32O',\n              second_factor_token: {\n                signature: 'bad',\n                clientData: 'bad',\n                authenticatorData: 'bad',\n                credentialId: 'bad'\n              },\n              second_factor_method: UserSecondFactor.methods[:security_key]\n            }\n\n            expect(response.status).to eq(200)\n            expect(response.body).to include(I18n.t(\"webauthn.validation.not_found_error\"))\n            expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n          end\n        end\n      end\n    end\n\n    context 'submit change' do\n      let(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      it \"fails when the password is blank\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: '' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"fails when the password is too long\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: ('x' * (User.max_password_length + 1)) }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"logs in the user\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"doesn't log in the user when not approved\" do\n        SiteSetting.must_approve_users = true\n        user1.update!(approved: false)\n\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n  end\n\n  describe '#confirm_email_token' do\n    let!(:email_token) { Fabricate(:email_token, user: user1) }\n\n    it \"token doesn't match any records\" do\n      get \"/u/confirm-email-token/#{SecureRandom.hex}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(false)\n    end\n\n    it \"token matches\" do\n      get \"/u/confirm-email-token/#{email_token.token}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(true)\n    end\n  end\n\n  describe '#admin_login' do\n    context 'enqueues mail' do\n      it 'enqueues mail with admin email and sso enabled' do\n        put \"/u/admin-login\", params: { email: admin.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"user_id\"]).to eq(admin.id)\n      end\n    end\n\n    context 'when email is incorrect' do\n      it 'should return the right response' do\n        put \"/u/admin-login\", params: { email: 'random' }\n\n        expect(response.status).to eq(200)\n\n        response_body = response.body\n\n        expect(response_body).to match(I18n.t(\"admin_login.errors.unknown_email_address\"))\n        expect(response_body).to_not match(I18n.t(\"login.second_factor_description\"))\n      end\n    end\n  end\n\n  describe '#toggle_anon' do\n    it 'allows you to toggle anon if enabled' do\n      SiteSetting.allow_anonymous_posting = true\n\n      user = sign_in(Fabricate(:user))\n      user.trust_level = 1\n      user.save!\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(AnonymousShadowCreator.get(user).id)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(user.id)\n    end\n  end\n\n  describe '#create' do\n    def honeypot_magic(params)\n      get '/session/hp.json'\n      json = response.parsed_body\n      params[:password_confirmation] = json[\"value\"]\n      params[:challenge] = json[\"challenge\"].reverse\n      params\n    end\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n      SiteSetting.allow_new_registrations = true\n      @user = Fabricate.build(:user, email: \"foobar@example.com\", password: \"strongpassword\")\n    end\n\n    let(:post_user_params) do\n      { name: @user.name,\n        username: @user.username,\n        password: \"strongpassword\",\n        email: @user.email }\n    end\n\n    def post_user(extra_params = {})\n      post \"/u.json\", params: post_user_params.merge(extra_params)\n    end\n\n    context 'when email params is missing' do\n      it 'should raise the right error' do\n        post \"/u.json\", params: {\n          name: @user.name,\n          username: @user.username,\n          password: 'testing12352343'\n        }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when creating a user' do\n      it 'sets the user locale to I18n.locale' do\n        SiteSetting.default_locale = 'en'\n        I18n.stubs(:locale).returns(:fr)\n        post_user\n        expect(User.find_by(username: @user.username).locale).to eq('fr')\n      end\n\n      it 'requires invite code when specified' do\n        expect(SiteSetting.require_invite_code).to eq(false)\n        SiteSetting.invite_code = \"abc def\"\n        expect(SiteSetting.require_invite_code).to eq(true)\n\n        post_user(invite_code: \"abcd\")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n\n        # case insensitive and stripped of leading/ending spaces\n        post_user(invite_code: \" AbC deF \")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n      end\n\n      context \"when timezone is provided as a guess on signup\" do\n\n        it \"sets the timezone\" do\n          post_user(timezone: \"Australia/Brisbane\")\n          expect(response.status).to eq(200)\n          expect(User.find_by(username: @user.username).user_option.timezone).to eq(\"Australia/Brisbane\")\n        end\n      end\n\n      context \"with local logins disabled\" do\n        before do\n          SiteSetting.enable_local_logins = false\n          SiteSetting.enable_google_oauth2_logins = true\n        end\n\n        it \"blocks registration without authenticator information\" do\n          post_user\n          expect(response.status).to eq(403)\n        end\n\n        it \"blocks with a regular api key\" do\n          api_key = Fabricate(:api_key, user: user1)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(403)\n        end\n\n        it \"works with an admin api key\" do\n          api_key = Fabricate(:api_key, user: admin)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    context 'when creating a non active user (unconfirmed email)' do\n      it 'returns 403 forbidden when local logins are disabled' do\n        SiteSetting.enable_local_logins = false\n        post_user\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      it 'creates a user correctly' do\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n        expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"type\"]).to eq(\"signup\")\n      end\n\n      context \"`must approve users` site setting is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it 'creates a user correctly' do\n          post_user\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body['active']).to be_falsey\n\n          # should save user_created_message in session\n          expect(session[\"user_created_message\"]).to be_present\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n          args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n          expect(args[\"type\"]).to eq(\"signup\")\n        end\n      end\n\n      context 'users already exists with given email' do\n        let!(:existing) { Fabricate(:user, email: post_user_params[:email]) }\n\n        it 'returns an error if hide_email_address_taken is disabled' do\n          SiteSetting.hide_email_address_taken = false\n\n          post_user\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it 'returns success if hide_email_address_taken is enabled' do\n          SiteSetting.hide_email_address_taken = true\n          expect {\n            post_user\n          }.to_not change { User.count }\n\n          expect(response.status).to eq(200)\n          expect(session[\"user_created_message\"]).to be_present\n\n          json = response.parsed_body\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n\n          existing.destroy!\n          expect {\n            post_user\n          }.to change { User.count }\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n        end\n      end\n    end\n\n    context \"creating as active\" do\n      it \"won't create the user as active\" do\n        post \"/u.json\", params: post_user_params.merge(active: true)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as active with a regular key\" do\n          post \"/u.json\",\n            params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsey\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        it \"creates the user as active with a an admin key\" do\n          SiteSetting.send_welcome_message = true\n          SiteSetting.must_approve_users = true\n\n          #Sidekiq::Client.expects(:enqueue).never\n          post \"/u.json\", params: post_user_params.merge(approved: true, active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_truthy\n          new_user = User.find(response.parsed_body[\"user_id\"])\n          expect(new_user.active).to eq(true)\n          expect(new_user.approved).to eq(true)\n          expect(new_user.approved_by_id).to eq(admin.id)\n          expect(new_user.approved_at).to_not eq(nil)\n          expect(new_user.email_tokens.where(confirmed: true, email: new_user.email)).to exist\n        end\n\n        it \"will create a reviewable when a user is created as active but not approved\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_present\n        end\n\n        it \"won't create a reviewable when a user is not active\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to eq(false)\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n\n        it \"won't create the developer as active\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsy\n        end\n\n        it \"won't set the new user's locale to the admin's locale\" do\n          SiteSetting.allow_user_locale = true\n          admin.update!(locale: :fr)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          new_user = User.find(json[\"user_id\"])\n          expect(new_user.locale).not_to eq(\"fr\")\n        end\n\n        it \"will auto approve user if the user email domain matches auto_approve_email_domains setting\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n          SiteSetting.auto_approve_email_domains = \"example.com\"\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to be_truthy\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n      end\n    end\n\n    context \"creating as staged\" do\n      it \"won't create the user as staged\" do\n        post \"/u.json\", params: post_user_params.merge(staged: true)\n        expect(response.status).to eq(200)\n        new_user = User.where(username: post_user_params[:username]).first\n        expect(new_user.staged?).to eq(false)\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:user) { admin }\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }\n\n        it \"creates the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(true)\n        end\n\n        it \"won't create the developer as staged\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n    end\n\n    context 'when creating an active user (confirmed email)' do\n      before { User.any_instance.stubs(:active?).returns(true) }\n\n      it 'enqueues a welcome email' do\n        User.any_instance.expects(:enqueue_welcome_message).with('welcome_user')\n\n        post_user\n        expect(response.status).to eq(200)\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n      end\n\n      it \"shows the 'active' message\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(\n          I18n.t 'login.active'\n        )\n      end\n\n      it \"should be logged in\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it 'indicates the user is active in the response' do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_truthy\n      end\n\n      it 'doesn\\'t succeed when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      context 'authentication records for' do\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              email: \"osama@mail.com\",\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it 'should create twitter user info if required' do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          expect(UserAssociatedAccount.where(provider_name: \"twitter\").count).to eq(1)\n        end\n\n        it \"returns an error when email has been changed from the validated email address\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"unvalidatedemail@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it \"will create the user successfully if email validation is required\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n\n        it \"doesn't use provided username/name if sso_overrides is enabled\" do\n          SiteSetting.auth_overrides_username = true\n          SiteSetting.auth_overrides_name = true\n          post \"/u.json\", params: {\n            username: \"attemptednewname\",\n            name: \"Attempt At New Name\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n\n          user = User.last\n\n          expect(user.username).to eq('testosama')\n          expect(user.name).to eq('Osama Test')\n        end\n\n      end\n\n      context \"with no email in the auth payload\" do\n        before do\n          OmniAuth.config.test_mode = true\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"will create the user successfully\" do\n          Rails.application.env_config[\"omniauth.auth\"].info.email = nil\n\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n      end\n    end\n\n    it \"creates user successfully but doesn't activate the account\" do\n      post_user\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"success\"]).to eq(true)\n      expect(User.find_by(username: @user.username).active).to eq(false)\n    end\n\n    shared_examples 'honeypot fails' do\n      it 'should not create a new user' do\n        User.any_instance.expects(:enqueue_welcome_message).never\n\n        expect {\n          post \"/u.json\", params: create_params\n        }.to_not change { User.count }\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when honeypot value is wrong' do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, password_confirmation: 'wrong' } }\n      include_examples 'honeypot fails'\n    end\n\n    context 'when challenge answer is wrong' do\n      before do\n        UsersController.any_instance.stubs(:challenge_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, challenge: 'abc' } }\n      include_examples 'honeypot fails'\n    end\n\n    context \"when 'invite only' setting is enabled\" do\n      before { SiteSetting.invite_only = true }\n\n      let(:create_params) { {\n        name: @user.name,\n        username: @user.username,\n        password: 'strongpassword',\n        email: @user.email\n      }}\n\n      include_examples 'honeypot fails'\n    end\n\n    shared_examples 'failed signup' do\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(200)\n      end\n\n      it 'should report failed' do\n        post \"/u.json\", params: create_params\n        json = response.parsed_body\n        expect(json[\"success\"]).not_to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when password is blank' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"\", email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password is too long' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"x\" * (User.max_password_length + 1), email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password param is missing' do\n      let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a reserved username' do\n      let(:create_params) { { name: @user.name, username: 'Reserved', email: @user.email, password: 'strongpassword' } }\n      before { SiteSetting.reserved_usernames = 'a|reserved|b' }\n      include_examples 'failed signup'\n    end\n\n    context 'with a username that matches a user route' do\n      let(:create_params) { { name: @user.name, username: 'account-created', email: @user.email, password: 'strongpassword' } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a missing username' do\n      let(:create_params) { { name: @user.name, email: @user.email, password: \"x\" * 20 } }\n\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when an Exception is raised' do\n      before { User.any_instance.stubs(:save).raises(ActiveRecord::StatementInvalid.new('Oh no')) }\n\n      let(:create_params) {\n        { name: @user.name, username: @user.username,\n          password: \"strongpassword\", email: @user.email }\n      }\n\n      include_examples 'failed signup'\n    end\n\n    context \"with custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field) }\n      fab!(:another_field) { Fabricate(:user_field) }\n      fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n      context \"without a value for the fields\" do\n        let(:create_params) { { name: @user.name, password: 'watwatwat', username: @user.username, email: @user.email } }\n        include_examples 'failed signup'\n      end\n\n      context \"with values for the fields\" do\n        let(:update_user_url) { \"/u/#{user1.username}.json\" }\n        let(:field_id) { user_field.id.to_s }\n\n        before { sign_in(user1) }\n\n        context \"with multple select fields\" do\n          let(:valid_options) { %w[Axe Sword] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'multiselect') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Axe'),\n                  Fabricate(:user_field_option, value: 'Sword')\n                ]\n              end\n            end\n          end\n\n          it \"should allow single values and not just arrays\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Axe' } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to('Axe')\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from('Axe').to(%w[Axe Sword])\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Juice] } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"should filter valid values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"value can't be nil or empty if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can nil or empty if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options).to(nil)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"\")\n          end\n\n        end\n\n        context \"with dropdown fields\" do\n          let(:valid_options) { ['Black Mesa', 'Fox Hound'] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'dropdown') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Black Mesa'),\n                  Fabricate(:user_field_option, value: 'Fox Hound')\n                ]\n              end\n            end\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Umbrella Corporation' } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options.first)\n          end\n\n          it \"value can't be nil if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can be set to nil if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options.last } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options.last).to(nil)\n          end\n        end\n\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n          user_fields: {\n            user_field.id.to_s => 'value1',\n            another_field.id.to_s => 'value2',\n          }\n        } }\n\n        it \"should succeed without the optional field\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to be_blank\n        end\n\n        it \"should succeed with the optional field\" do\n          create_params[:user_fields][optional_field.id.to_s] = 'value3'\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value3')\n        end\n\n        it \"trims excessively long fields\" do\n          create_params[:user_fields][optional_field.id.to_s] = ('x' * 3000)\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n\n          val = inserted.custom_fields[\"user_field_#{optional_field.id}\"]\n          expect(val.length).to eq(UserField.max_length)\n        end\n      end\n    end\n\n    context \"with only optional custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field, required: false) }\n\n      context \"without values for the fields\" do\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n        } }\n\n        it \"should succeed\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).not_to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to be_blank\n        end\n      end\n    end\n\n    context \"when taking over a staged account\" do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        UsersController.any_instance.stubs(:challenge_value).returns(\"efg\")\n        SessionController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        SessionController.any_instance.stubs(:challenge_value).returns(\"efg\")\n      end\n\n      fab!(:staged) { Fabricate(:staged, email: \"staged@account.com\", active: true) }\n\n      it \"succeeds\" do\n        post '/u.json', params: honeypot_magic(\n          email: staged.email,\n          username: \"zogstrip\",\n          password: \"P4ssw0rd$$\"\n        )\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        # do not allow emails changes please\n\n        put \"/u/update-activation-email.json\", params: { email: 'bob@bob.com' }\n\n        created_user.reload\n        expect(created_user.email).to eq(\"staged@account.com\")\n        expect(response.status).to eq(403)\n      end\n    end\n  end\n\n  describe '#username' do\n    it 'raises an error when not logged in' do\n      put \"/u/somename/preferences/username.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:old_username) { \"OrigUsername\" }\n      let(:new_username) { \"#{old_username}1234\" }\n      fab!(:user) { Fabricate(:user, username: \"OrigUsername\") }\n\n      before do\n        user.username = old_username\n        sign_in(user)\n      end\n\n      it 'raises an error without a new_username param' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { username: user.username }\n        expect(response.status).to eq(400)\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when you don\\'t have permission to change the username' do\n        Guardian.any_instance.expects(:can_edit_username?).with(user).returns(false)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when change_username fails' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: '@' }\n\n        expect(response.status).to eq(422)\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t(\n          'user.username.short', min: User.username_length.begin\n        ))\n\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should succeed in normal circumstances' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'raises an error when the username clashes with an existing user route' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'account-created' }\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'raises an error when the username is in the reserved list' do\n        SiteSetting.reserved_usernames = 'reserved'\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'reserved' }\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'should fail if the user is old' do\n        # Older than the change period and >1 post\n        user.created_at = Time.now - (SiteSetting.username_change_period + 1).days\n        PostCreator.new(user,\n          title: 'This is a test topic',\n          raw: 'This is a test this is a test'\n        ).create\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should create a staff action log when a staff member changes the username' do\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(UserHistory.where(action: UserHistory.actions[:change_username], target_user_id: user.id, acting_user_id: acting_user.id)).to be_present\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'should return a JSON response with the updated username' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.parsed_body['username']).to eq(new_username)\n      end\n\n      it 'should respond with proper error message if auth_overrides_username is enabled' do\n        SiteSetting.discourse_connect_url = 'http://someurl.com'\n        SiteSetting.enable_discourse_connect = true\n        SiteSetting.auth_overrides_username = true\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors'].first).to include(I18n.t('errors.messages.auth_overrides_username'))\n      end\n    end\n  end\n\n  describe '#check_username' do\n    it 'raises an error without any parameters' do\n      get \"/u/check_username.json\"\n      expect(response.status).to eq(400)\n    end\n\n    shared_examples 'when username is unavailable' do\n      it 'should return available as false in the JSON and return a suggested username' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(false)\n        expect(response.parsed_body['suggestion']).to be_present\n      end\n    end\n\n    shared_examples 'when username is available' do\n      it 'should return available in the JSON' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(true)\n      end\n    end\n\n    it 'returns nothing when given an email param but no username' do\n      get \"/u/check_username.json\", params: { email: 'dood@example.com' }\n      expect(response.status).to eq(200)\n    end\n\n    context 'username is available' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'BruceWayne' }\n      end\n      include_examples 'when username is available'\n    end\n\n    context 'username is unavailable' do\n      before do\n        get \"/u/check_username.json\", params: { username: user1.username }\n      end\n      include_examples 'when username is unavailable'\n    end\n\n    shared_examples 'checking an invalid username' do\n      it 'should not return an available key but should return an error message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(nil)\n        expect(response.parsed_body['errors']).to be_present\n      end\n    end\n\n    context 'has invalid characters' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'bad username' }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the invalid characters message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.characters'))\n      end\n    end\n\n    context 'is too long' do\n      before do\n        get \"/u/check_username.json\", params: { username: SecureRandom.alphanumeric(SiteSetting.max_username_length.to_i + 1) }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the \"too long\" message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.long', max: SiteSetting.max_username_length))\n      end\n    end\n\n    describe 'different case of existing username' do\n      context \"it's my username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(user)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is available'\n      end\n\n      context \"it's someone else's username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        fab!(:someone_else) { Fabricate(:user) }\n        before do\n          sign_in(someone_else)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is unavailable'\n      end\n\n      context \"an admin changing it for someone else\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(admin)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo', for_user_id: user.id }\n        end\n        include_examples 'when username is available'\n      end\n    end\n  end\n\n  describe '#check_email' do\n    it 'returns success if hide_email_address_taken is true' do\n      SiteSetting.hide_email_address_taken = true\n\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns success if email is empty' do\n      get \"/u/check_email.json\"\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns failure if email is not valid' do\n      get \"/u/check_email.json\", params: { email: \"invalid\" }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns failure if email exists' do\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"failed\"]).to be_present\n\n      get \"/u/check_email.json\", params: { email: user1.email.upcase }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns success if email does not exists' do\n      get \"/u/check_email.json\", params: { email: \"available@example.com\" }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'return success if user email is taken by staged user' do\n      get \"/u/check_email.json\", params: { email: Fabricate(:staged).email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n  end\n\n  describe '#invited' do\n    it 'fails for anonymous users' do\n      get \"/u/#{user1.username}/invited.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns success' do\n      user = Fabricate(:user, trust_level: 2)\n      Fabricate(:invite, invited_by: user)\n\n      sign_in(user)\n      get \"/u/#{user.username}/invited.json\", params: { username: user.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"counts\"][\"pending\"]).to eq(1)\n      expect(response.parsed_body[\"counts\"][\"total\"]).to eq(1)\n    end\n\n    it 'filters by all if viewing self' do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(inviter)\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites.first).to include('email' => 'billybob@example.com')\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"doesn't filter by email if another regular user\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(Fabricate(:user, trust_level: 2))\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(0)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"filters by email if staff\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(moderator)\n\n      invite_1 = Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      invitee_1 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_1, user: invitee_1)\n      invite_2 = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      invitee_2 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_2, user: invitee_2)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to include('id' => invitee_1.id)\n    end\n\n    context 'with guest' do\n      context 'with pending invites' do\n        it 'does not return invites' do\n          Fabricate(:invite, invited_by: inviter)\n\n          get \"/u/#{user1.username}/invited/pending.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invited_users' do\n          inviter = Fabricate(:user, trust_level: 2)\n          sign_in(inviter)\n          invite = Fabricate(:invite, invited_by: inviter)\n          invited_user = Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with pending invites' do\n        context 'with permission to see pending invites' do\n          it 'returns invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            invite = Fabricate(:invite, invited_by: inviter)\n            sign_in(inviter)\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"email\" => invite.email)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see pending invites' do\n          it 'does not return invites' do\n            user = sign_in(Fabricate(:user))\n            Fabricate(:invite, invited_by: inviter)\n            stub_guardian(user) do |guardian|\n              guardian.stubs(:can_see_invite_details?).\n                with(inviter).returns(false)\n            end\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(422)\n          end\n        end\n\n        context 'with permission to see invite links' do\n          it 'returns own invites' do\n            inviter = sign_in(Fabricate(:user, trust_level: 2))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n\n          it 'allows admin to see invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            admin = sign_in(Fabricate(:admin))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see invite links' do\n          it 'does not return invites' do\n            user = Fabricate(:user, trust_level: 2)\n            inviter = admin\n            Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(403)\n          end\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invites' do\n          sign_in(moderator)\n          invite = Fabricate(:invite, invited_by: inviter)\n          Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n  end\n\n  describe '#update' do\n    context 'with guest' do\n      it 'raises an error' do\n        put \"/u/guest.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    it \"does not allow name to be updated if auth auth_overrides_name is enabled\" do\n      SiteSetting.auth_overrides_name = true\n\n      sign_in(user1)\n\n      put \"/u/#{user1.username}\", params: { name: 'test.test' }\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.name).to_not eq('test.test')\n    end\n\n    context \"when username contains a period\" do\n      before do\n        sign_in(user)\n      end\n\n      fab!(:user) { Fabricate(:user, username: 'test.test', name: \"Test User\") }\n\n      it \"should be able to update a user\" do\n        put \"/u/#{user.username}\", params: { name: 'test.test' }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.name).to eq('test.test')\n      end\n    end\n\n    context \"as a staff user\" do\n      context \"uneditable field\" do\n        fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n        it \"allows staff to edit the field\" do\n          sign_in(admin)\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            title: \"foobar\",\n            user_fields: { user_field.id.to_s => 'happy' }\n          }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n          expect(user.title).to eq(\"foobar\")\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with permission to update' do\n        fab!(:upload) { Fabricate(:upload) }\n        fab!(:user) { Fabricate(:user) }\n\n        before do\n          sign_in(user)\n        end\n\n        it 'allows the update' do\n          SiteSetting.tagging_enabled = true\n          user2 = Fabricate(:user)\n          user3 = Fabricate(:user)\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            muted_usernames: \"#{user2.username},#{user3.username}\",\n            watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n            card_background_upload_url: upload.url,\n            profile_background_upload_url: upload.url\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['user']['watched_tags'].count).to eq(2)\n\n          user.reload\n\n          expect(user.name).to eq 'Jim Tom'\n          expect(user.muted_users.pluck(:username).sort).to eq [user2.username, user3.username].sort\n\n          expect(TagUser.where(\n            user: user,\n            notification_level: TagUser.notification_levels[:watching]\n          ).pluck(:tag_id)).to contain_exactly(tags[0].id, tags[1].id)\n\n          theme = Fabricate(:theme, user_selectable: true)\n\n          put \"/u/#{user.username}.json\", params: {\n            muted_usernames: \"\",\n            theme_ids: [theme.id],\n            email_level: UserOption.email_level_types[:always]\n          }\n\n          user.reload\n\n          expect(user.muted_users.pluck(:username).sort).to be_empty\n          expect(user.user_option.theme_ids).to eq([theme.id])\n          expect(user.user_option.email_level).to eq(UserOption.email_level_types[:always])\n          expect(user.profile_background_upload).to eq(upload)\n          expect(user.card_background_upload).to eq(upload)\n        end\n\n        it 'updates watched tags in everyone tag group' do\n          SiteSetting.tagging_enabled = true\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          group = Fabricate(:group, name: 'group', mentionable_level: Group::ALIAS_LEVELS[:everyone])\n          tag_group = Fabricate(:tag_group, tags: tags)\n          Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\", params: {\n            watched_tags: \"#{tags[0].name},#{tag_synonym.name}\"\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['user']['watched_tags'].count).to eq(2)\n        end\n\n        context 'a locale is chosen that differs from I18n.locale' do\n          before do\n            SiteSetting.allow_user_locale = true\n          end\n\n          it \"updates the user's locale\" do\n            I18n.locale = :fr\n            put \"/u/#{user.username}.json\", params: { locale: :fa_IR }\n            expect(user.reload.locale).to eq('fa_IR')\n          end\n\n          it \"updates the title\" do\n            BadgeGranter.enable_queue\n            user.update!(locale: :fr)\n            user.change_trust_level!(TrustLevel[4])\n            BadgeGranter.process_queue!\n\n            leader_title = I18n.t(\"badges.leader.name\", locale: :fr)\n            put \"/u/#{user.username}.json\", params: { title: leader_title }\n            expect(user.reload.title).to eq(leader_title)\n          ensure\n            BadgeGranter.disable_queue\n            BadgeGranter.clear_queue!\n          end\n        end\n\n        context \"with user fields\" do\n          context \"an editable field\" do\n            fab!(:user_field) { Fabricate(:user_field) }\n            fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n            it \"should update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq 'happy'\n            end\n\n            it \"cannot be updated to blank\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => '' } }\n\n              expect(response.status).to eq(422)\n              expect(user.user_fields[user_field.id.to_s]).not_to eq('happy')\n            end\n\n            it \"trims excessively large fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => ('x' * 3000) } }\n\n              expect(user.user_fields[user_field.id.to_s].size).to eq(UserField.max_length)\n            end\n\n            it \"should retain existing user fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy', optional_field.id.to_s => 'feet' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'sad' } }\n\n              expect(response.status).to eq(200)\n\n              user.reload\n\n              expect(user.user_fields[user_field.id.to_s]).to eq('sad')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n            end\n          end\n\n          context \"with user_notification_schedule attributes\" do\n            it \"updates the user's notification schedule\" do\n              params = {\n                user_notification_schedule: {\n                  enabled: true,\n                  day_0_start_time: 30,\n                  day_0_end_time: 60,\n                  day_1_start_time: 30,\n                  day_1_end_time: 60,\n                  day_2_start_time: 30,\n                  day_2_end_time: 60,\n                  day_3_start_time: 30,\n                  day_3_end_time: 60,\n                  day_4_start_time: 30,\n                  day_4_end_time: 60,\n                  day_5_start_time: 30,\n                  day_5_end_time: 60,\n                  day_6_start_time: 30,\n                  day_6_end_time: 60,\n                }\n              }\n              put \"/u/#{user.username}.json\", params: params\n\n              user.reload\n              expect(user.user_notification_schedule.enabled).to eq(true)\n              expect(user.user_notification_schedule.day_0_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_0_end_time).to eq(60)\n              expect(user.user_notification_schedule.day_6_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_6_end_time).to eq(60)\n            end\n          end\n\n          context \"uneditable field\" do\n            fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n            it \"does not update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to be_blank\n            end\n          end\n\n          context \"custom_field\" do\n            before do\n              plugin = Plugin::Instance.new\n              plugin.register_editable_user_custom_field :test2\n              plugin.register_editable_user_custom_field :test3, staff_only: true\n            end\n\n            after do\n              DiscoursePluginRegistry.reset!\n            end\n\n            it \"only updates allowed user fields\" do\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to be_blank\n            end\n\n            it \"works alongside a user field\" do\n              user_field = Fabricate(:user_field, editable: true)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 }, user_fields: { user_field.id.to_s => 'happy' } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(nil)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n            end\n\n            it \"works alongside a user field during creation\" do\n              api_key = Fabricate(:api_key, user: admin)\n              user_field = Fabricate(:user_field, editable: true)\n              post \"/u.json\", params: {\n                name: \"Test User\",\n                username: \"testuser\",\n                email: \"user@mail.com\",\n                password: 'supersecure',\n                active: true,\n                custom_fields: {\n                  test2: 'custom field value'\n                },\n                user_fields: {\n                  user_field.id.to_s => 'user field value'\n                }\n              }, headers: {\n                HTTP_API_KEY: api_key.key\n              }\n              expect(response.status).to eq(200)\n              u = User.find_by_email('user@mail.com')\n\n              val = u.custom_fields[\"user_field_#{user_field.id}\"]\n              expect(val).to eq('user field value')\n\n              val = u.custom_fields[\"test2\"]\n              expect(val).to eq('custom field value')\n            end\n\n            it \"is secure when there are no registered editable fields\" do\n              DiscoursePluginRegistry.reset!\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to be_blank\n              expect(user.custom_fields[\"test3\"]).to be_blank\n\n              put \"/u/#{user.username}.json\", params: { custom_fields: [\"arrayitem1\", \"arrayitem2\"] }\n              expect(response.status).to eq(200)\n            end\n\n            it \"allows staff to edit staff-editable fields\" do\n              sign_in(admin)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(\"hello3\")\n            end\n\n          end\n        end\n\n        it 'returns user JSON' do\n          put \"/u/#{user.username}.json\"\n\n          json = response.parsed_body\n          expect(json['user']['id']).to eq user.id\n        end\n      end\n\n      context 'without permission to update' do\n        it 'does not allow the update' do\n          user = Fabricate(:user, name: 'Billy Bob')\n          sign_in(Fabricate(:user))\n\n          put \"/u/#{user.username}.json\", params: { name: 'Jim Tom' }\n\n          expect(response).to be_forbidden\n          expect(user.reload.name).not_to eq 'Jim Tom'\n        end\n      end\n    end\n  end\n\n  describe '#badge_title' do\n    fab!(:badge) { Fabricate(:badge) }\n    let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n    it \"sets the user's title to the badge name if it is titleable\" do\n      sign_in(user1)\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).not_to eq(badge.display_name)\n      badge.update allow_title: true\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).to eq(badge.display_name)\n      expect(user1.user_profile.badge_granted_title).to eq(true)\n      expect(user1.user_profile.granted_title_badge_id).to eq(badge.id)\n\n      badge.update allow_title: false\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      user1.reload\n      user1.user_profile.reload\n      expect(user1.title).to eq('')\n      expect(user1.user_profile.badge_granted_title).to eq(false)\n      expect(user1.user_profile.granted_title_badge_id).to eq(nil)\n    end\n\n    it \"is not raising an erroring when user revokes title\" do\n      sign_in(user1)\n      badge.update allow_title: true\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: 0 }\n      expect(response.status).to eq(200)\n    end\n\n    context \"with overridden name\" do\n      fab!(:badge) { Fabricate(:badge, name: 'Demogorgon', allow_title: true) }\n      let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n      before do\n        TranslationOverride.upsert!('en', 'badges.demogorgon.name', 'Boss')\n      end\n\n      after do\n        TranslationOverride.revert!('en', ['badges.demogorgon.name'])\n      end\n\n      it \"uses the badge display name as user title\" do\n        sign_in(user1)\n\n        put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n        expect(user1.reload.title).to eq(badge.display_name)\n      end\n    end\n  end\n\n  describe '#send_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"dsdsds@sasa.com\"\n      }\n\n      User.find_by(username: \"osamatest\")\n    end\n\n    context 'for an existing user' do\n      context 'for an activated account with email confirmed' do\n        it 'fails' do\n          user = post_user\n          email_token = Fabricate(:email_token, user: user).token\n          EmailToken.confirm(email_token)\n\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(409)\n          expect(response.parsed_body['errors']).to include(I18n.t(\n            'activation.activated'\n          ))\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'for an activated account with unconfirmed email' do\n        it 'should send an email' do\n          user = post_user\n          user.update!(active: true)\n          Fabricate(:email_token, user: user)\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup, to_address: user.email }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"approval is enabled\" do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it \"should raise an error\" do\n          user = post_user\n          user.update(active: true)\n          user.save!\n          Fabricate(:email_token, user: user1)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe 'when user does not have a valid session' do\n        it 'should not be valid' do\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(403)\n        end\n\n        it 'should allow staff regardless' do\n          sign_in(admin)\n          user = Fabricate(:user, active: false)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context 'with a valid email_token' do\n        it 'should send the activation email' do\n          user = post_user\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'without an existing email_token' do\n        let(:user) { post_user }\n        before do\n          user.email_tokens.each { |t| t.destroy }\n          user.reload\n        end\n\n        it 'should generate a new token' do\n          expect {\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          }.to change { user.reload.email_tokens.count }.by(1)\n        end\n\n        it 'should send an email' do\n          expect do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end.to change { Jobs::CriticalUserEmail.jobs.size }.by(1)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n    end\n\n    context 'when username does not exist' do\n      it 'should not send an email' do\n        post \"/u/action/send_activation_email.json\", params: { username: 'nopenopenopenope' }\n        expect(response.status).to eq(404)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n      end\n    end\n  end\n\n  describe '#pick_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/pick.json\", params: { avatar_id: 1, type: \"custom\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:upload) do\n        Fabricate(:upload, user: user1)\n      end\n\n      it \"raises an error when you don't have permission to toggle the avatar\" do\n        put \"/u/#{another_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when discourse_connect_overrides_avatar is disabled\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is disabled\" do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is admin\" do\n        SiteSetting.allow_uploaded_avatars = 'admin'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(admin: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is staff\" do\n        SiteSetting.allow_uploaded_avatars = 'staff'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(moderator: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is a trust level\" do\n        SiteSetting.allow_uploaded_avatars = '3'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(trust_level: 3)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it 'ignores the upload if picking a system avatar' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"system\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'raises an error if the type is invalid' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"x\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it 'can successfully pick the system avatar' do\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n        system_user = Discourse.system_user\n        SiteSetting.use_site_small_logo_as_system_avatar = true\n        another_upload = Fabricate(:upload, user: system_user)\n        sign_in(system_user)\n\n        put \"/u/#{system_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"uploaded\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n      end\n\n      it 'can successfully pick a gravatar' do\n\n        user1.user_avatar.update_columns(gravatar_upload_id: upload.id)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"gravatar\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.gravatar_upload_id).to eq(upload.id)\n      end\n\n      it 'can not pick uploads that were not created by user' do\n        upload2 = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload2.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'can successfully pick a custom avatar' do\n        events = DiscourseEvent.track_events do\n          put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n            upload_id: upload.id, type: \"custom\"\n          }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.custom_upload_id).to eq(upload.id)\n      end\n    end\n  end\n\n  describe '#select_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/select.json\", params: { url: \"https://meta.discourse.org\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:avatar1) { Fabricate(:upload) }\n      fab!(:avatar2) { Fabricate(:upload) }\n      let(:url) { \"https://www.discourse.org\" }\n\n      it 'raises an error when url is blank' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: \"\" }\n        expect(response.status).to eq(422)\n      end\n\n      it 'raises an error when selectable avatars is disabled' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n        expect(response.status).to eq(422)\n      end\n\n      context 'selectable avatars is enabled' do\n\n        before do\n          SiteSetting.selectable_avatars = [avatar1, avatar2]\n          SiteSetting.selectable_avatars_enabled = true\n        end\n\n        it 'raises an error when selectable avatars is empty' do\n          SiteSetting.selectable_avatars = \"\"\n          put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n          expect(response.status).to eq(422)\n        end\n\n        context 'selectable avatars is properly setup' do\n          it 'raises an error when url is not in selectable avatars list' do\n            put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n            expect(response.status).to eq(422)\n          end\n\n          it 'can successfully select an avatar' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: avatar1.url }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'can successfully select an avatar using a cooked URL' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: UrlHelper.cook_url(avatar1.url) }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n            system_user = Discourse.system_user\n            SiteSetting.use_site_small_logo_as_system_avatar = true\n            sign_in(system_user)\n\n            put \"/u/#{system_user.username}/preferences/avatar/select.json\", params: {\n              url: UrlHelper.cook_url(avatar1.url)\n            }\n\n            expect(response.status).to eq(200)\n            expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n          end\n        end\n      end\n    end\n  end\n\n  describe '#destroy_user_image' do\n\n    it 'raises an error when not logged in' do\n      delete \"/u/asdf/preferences/user_image.json\", params: { type: 'profile_background' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you don\\'t have permission to clear the profile background' do\n        delete \"/u/#{another_user.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the `type` param\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"only allows certain `types`\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'wat' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'can clear the profile background' do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n\n        expect(user1.reload.profile_background_upload).to eq(nil)\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#destroy' do\n    it 'raises an error when not logged in' do\n      delete \"/u/nobody.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you cannot delete your account' do\n        UserDestroyer.any_instance.expects(:destroy).never\n        stat = user1.user_stat\n        stat.post_count = 3\n        stat.save!\n        delete \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when you try to delete someone else's account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        delete \"/u/#{another_user.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes your account when you're allowed to\" do\n        UserDestroyer.any_instance.expects(:destroy).with(user1, anything).returns(user1)\n        delete \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#ignore' do\n    it 'raises an error when not logged in' do\n      put \"/u/#{user1.username}/notification_level.json\", params: { notification_level: \"\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:user) { Fabricate(:user, trust_level: 2) }\n      before do\n        sign_in(user)\n      end\n\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: user, ignored_user: another_user) }\n      fab!(:muted_user) { Fabricate(:muted_user, user: user, muted_user: another_user) }\n\n      context \"when you can't change the notification\" do\n        fab!(:staff_user) { admin }\n\n        it \"ignoring includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'ignore' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.ignore_error\"))\n        end\n\n        it \"muting includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'mute' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.mute_error\"))\n        end\n      end\n\n      context 'when changing notification level to normal' do\n        it 'changes notification level to normal' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"normal\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.count).to eq(0)\n        end\n      end\n\n      context 'when changing notification level to mute' do\n        it 'changes notification level to mute' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"mute\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.find_by(user_id: user.id, muted_user_id: another_user.id)).to be_present\n        end\n      end\n\n      context 'when changing notification level to ignore' do\n        it 'changes notification level to ignore' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\" }\n          expect(MutedUser.count).to eq(0)\n          expect(IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)).to be_present\n        end\n\n        context 'when expiring_at param is set' do\n          it 'changes notification level to ignore' do\n            freeze_time(Time.now) do\n              expiring_at = 3.days.from_now\n              put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\", expiring_at: expiring_at }\n\n              ignored_user = IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)\n              expect(ignored_user).to be_present\n              expect(ignored_user.expiring_at.to_i).to eq(expiring_at.to_i)\n              expect(MutedUser.count).to eq(0)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  describe \"for user with period in username\" do\n    fab!(:user_with_period) { Fabricate(:user, username: \"myname.test\") }\n\n    it \"still works\" do\n      sign_in(user_with_period)\n      UserDestroyer.any_instance.expects(:destroy).with(user_with_period, anything).returns(user_with_period)\n      delete \"/u/#{user_with_period.username}\", xhr: true\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe '#my_redirect' do\n    it \"redirects if the user is not logged in\" do\n      get \"/my/wat\"\n      expect(response).to redirect_to(\"/login-preferences\")\n      expect(response.cookies).to have_key(\"destination_url\")\n      expect(response.cookies[\"destination_url\"]).to eq(\"/my/wat\")\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n    end\n\n    context \"when the user is logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it \"will not redirect to an invalid path\" do\n        get \"/my/wat/..password.txt\"\n        expect(response).not_to be_redirect\n      end\n\n      it \"will redirect to an valid path\" do\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/preferences\")\n      end\n\n      it \"permits forward slashes\" do\n        get \"/my/activity/posts\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/activity/posts\")\n      end\n\n      it \"correctly redirects for Unicode usernames\" do\n        SiteSetting.unicode_usernames = true\n        user = sign_in(Fabricate(:unicode_user))\n\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences\")\n      end\n    end\n  end\n\n  describe '#check_emails' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/emails.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check emails\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{Fabricate(:user).username}/emails.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts for self\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in(user)\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in_admin\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"works on inactive users\" do\n        inactive_user = Fabricate(:user, active: false)\n        Fabricate(:email_change_request, user: inactive_user)\n        sign_in_admin\n\n        get \"/u/#{inactive_user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(inactive_user.email)\n        expect(json[\"secondary_emails\"]).to eq(inactive_user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(inactive_user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n    end\n  end\n\n  describe '#check_sso_email' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-email.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso email\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-email.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"looks good\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-email.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"email\"]).to eq(\"foobar@example.com\")\n      end\n    end\n  end\n\n  describe '#check_sso_payload' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-payload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso payload\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-payload.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns SSO payload when you're allowed to see\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"foobar\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-payload.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"payload\"]).to eq(\"foobar\")\n      end\n    end\n  end\n\n  describe '#update_primary_email' do\n    let(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"changes user's primary email\" do\n      put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(true)\n      expect(other_email.reload.primary).to eq(false)\n\n      event = DiscourseEvent.track_events {\n        expect { put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:update_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(false)\n      expect(other_email.reload.primary).to eq(true)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n  end\n\n  describe '#destroy_email' do\n    fab!(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"can destroy secondary emails\" do\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(428)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n\n      event = DiscourseEvent.track_events {\n        expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:destroy_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n\n    it \"can destroy unconfirmed emails\" do\n      request_1 = EmailChangeRequest.create!(\n        user: user1,\n        new_email: user_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email }\n\n      expect(user1.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n      expect(user1.email_change_requests).to contain_exactly(request_1)\n    end\n\n    it \"can destroy associated email tokens\" do\n      new_email = 'new.n.cool@example.com'\n      updater = EmailUpdater.new(guardian: user1.guardian, user: user1)\n\n      expect { updater.change_to(new_email) }\n        .to change { user1.email_tokens.count }.by(1)\n\n      expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: new_email } }\n        .to change { user1.email_tokens.count }.by(-1)\n\n      expect(user1.email_tokens.first.email).to eq(user1.email)\n    end\n  end\n\n  describe '#is_local_username' do\n    fab!(:group) { Fabricate(:group, name: \"Discourse\", mentionable_level: Group::ALIAS_LEVELS[:everyone]) }\n    let(:unmentionable) {\n      Fabricate(:group, name: \"Unmentionable\", mentionable_level: Group::ALIAS_LEVELS[:nobody])\n    }\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: allowed_user) }\n\n    it \"finds the user\" do\n      get \"/u/is_local_username.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid\"][0]).to eq(user1.username)\n    end\n\n    it \"finds the group\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: group.name }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid_groups\"]).to include(group.name)\n      expect(response.parsed_body[\"mentionable_groups\"].find { |g| g['name'] == group.name }).to be_present\n    end\n\n    it \"finds unmentionable groups\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: unmentionable.name }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid_groups\"]).to include(unmentionable.name)\n      expect(response.parsed_body[\"mentionable_groups\"]).to be_blank\n    end\n\n    it \"supports multiples usernames\" do\n      get \"/u/is_local_username.json\", params: { usernames: [user1.username, \"system\"] }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid\"]).to contain_exactly(user1.username, \"system\")\n    end\n\n    it \"never includes staged accounts\" do\n      staged = Fabricate(:user, staged: true)\n\n      get \"/u/is_local_username.json\", params: { usernames: [staged.username] }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid\"]).to be_blank\n    end\n\n    it \"returns user who cannot see topic\" do\n      Guardian.any_instance.expects(:can_see?).with(topic).returns(false)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][user1.username]).to eq(\"category\")\n    end\n\n    it \"never returns a user who can see the topic\" do\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"]).to be_blank\n    end\n\n    it \"returns user who cannot see a private topic\" do\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][user1.username]).to eq(\"private\")\n    end\n\n    it \"returns user who was not invited to topic\" do\n      sign_in(Fabricate(:admin))\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [admin.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][admin.username]).to eq(\"not_allowed\")\n    end\n\n    it \"never returns a user who can see the topic\" do\n      get \"/u/is_local_username.json\", params: {\n        usernames: [allowed_user.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"]).to be_blank\n    end\n\n    it \"returns the appropriate reason why user cannot see the topic\" do\n      TopicUser.create!(user_id: user1.id, topic_id: topic.id, notification_level: TopicUser.notification_levels[:muted])\n\n      sign_in(admin)\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][user1.username]).to eq(\"muted_topic\")\n    end\n  end\n\n  describe '#topic_tracking_state' do\n    context 'anon' do\n      it \"raises an error on anon for topic_tracking_state\" do\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'logged on' do\n      it \"detects new topic\" do\n        sign_in(user1)\n\n        topic = Fabricate(:topic)\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n\n        expect(response.status).to eq(200)\n        states = response.parsed_body\n        expect(states[0][\"topic_id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe '#summary' do\n    it \"generates summary info\" do\n      create_post(user: user)\n\n      get \"/u/#{user.username_lower}/summary.json\"\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json[\"user_summary\"][\"topic_count\"]).to eq(1)\n      expect(json[\"user_summary\"][\"post_count\"]).to eq(0)\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before_all do\n        user1.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"returns 404\" do\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns summary info if `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context 'avatar flair in Most... sections' do\n      it \"returns data for automatic groups flair\" do\n        liker = Fabricate(:user, admin: true, moderator: true, trust_level: 1)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"admin\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"moderator\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"trust_level\"]).to eq(1)\n      end\n\n      it \"returns data for flair when an icon is used\" do\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_color: \"#999999\", flair_icon: \"icon\")\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(\"icon\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_color\"]).to eq(\"#999999\")\n      end\n\n      it \"returns data for flair when an image is used\" do\n        upload = Fabricate(:upload)\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_upload: upload)\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(upload.url)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n      end\n\n      def create_and_like_post(likee, liker)\n        UserActionManager.enable\n        post = create_post(user: likee)\n        PostActionCreator.like(liker, post)\n      end\n    end\n  end\n\n  describe '#confirm_admin' do\n    it \"fails without a valid token\" do\n      get \"/u/confirm-admin/invalid-token.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"fails with a missing token\" do\n      get \"/u/confirm-admin/a0a0a0a0a0.json\"\n      expect(response).to_not be_successful\n    end\n\n    it \"succeeds with a valid code as anonymous\" do\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"succeeds with a valid code when logged in as that user\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\", params: { token: ac.token }\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"fails if you're logged in as a different account\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, Fabricate(:admin))\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response).to_not be_successful\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    describe \"post\" do\n      it \"gives the user admin access when POSTed\" do\n        ac = AdminConfirmation.new(user1, admin)\n        ac.create_confirmation\n        post \"/u/confirm-admin/#{ac.token}.json\"\n        expect(response.status).to eq(200)\n\n        user1.reload\n        expect(user1.admin?).to eq(true)\n      end\n    end\n  end\n\n  describe '#update_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"osama@example.com\"\n      }\n      user = User.where(username: \"osamatest\").first\n      user.active = false\n      user.save!\n      user\n    end\n\n    context \"with a session variable\" do\n      it \"raises an error with an invalid session value\" do\n        post_user\n\n        post \"/u.json\", params: {\n          username: \"osamatest2\",\n          password: \"strongpassword2\",\n          email: \"osama22@example.com\"\n        }\n        user = User.where(username: \"osamatest2\").first\n        user.destroy\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osamaupdated@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        user = post_user\n        user.update(active: true)\n        user.save!\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osama@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        active_user = Fabricate(:user)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: active_user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when the email is blocklisted\" do\n        post_user\n        SiteSetting.blocked_email_domains = 'example.com'\n        put \"/u/update-activation-email.json\", params: { email: 'test@example.com' }\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = post_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n    end\n\n    context \"with a username and password\" do\n      it \"raises an error with an invalid username\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: 'eviltrout',\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error with an invalid password\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: Fabricate(:walter_white).username,\n          password: 'letscook',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = inactive_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          username: user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n    end\n  end\n\n  describe '#show' do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed['username']).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"returns a hidden profile\" do\n        user.user_option.update_column(:hide_profile_and_presence, true)\n\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to eq(true)\n        expect(parsed[\"trust_level\"]).to be_blank\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}.json\"\n        expect(response).to redirect_to '/login'\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for an anon user\" do\n          get \"/\"\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, nil)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns success' do\n        get \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers['X-Robots-Tag']).to eq('noindex')\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"has_title_badges\"]).to eq(false)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns not found when the user is inactive' do\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns success when show_inactive_accounts is true and user is logged in' do\n        SiteSetting.show_inactive_accounts = true\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for a signed in user\" do\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, user1.id)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"should not track a user profile view for a user viewing his own profile\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n\n      context \"fetching a user by external_id\" do\n        before { user1.create_single_sign_on_record(external_id: '997', last_payload: '') }\n\n        it \"returns fetch for a matching external_id\" do\n          get \"/u/by-external/997.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n        end\n\n        it \"returns not found when external_id doesn't match\" do\n          get \"/u/by-external/99.json\"\n          expect(response).not_to be_successful\n        end\n\n        context \"for an external provider\" do\n          before do\n            sign_in(admin)\n            SiteSetting.enable_google_oauth2_logins = true\n            UserAssociatedAccount.create!(user: user1, provider_uid: 'myuid', provider_name: 'google_oauth2')\n          end\n\n          it \"doesn't work for non-admin\" do\n            sign_in(user1)\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(403)\n          end\n\n          it \"can fetch the user\" do\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n          end\n\n          it \"fails for disabled provider\" do\n            SiteSetting.enable_google_oauth2_logins = false\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(404)\n          end\n\n          it \"returns 404 for missing user\" do\n            get \"/u/by-external/google_oauth2/myotheruid.json\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"include_post_count_for\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        before_all do\n          Fabricate(:post, user: user1, topic: topic)\n          Fabricate(:post, user: admin, topic: topic)\n          Fabricate(:post, user: admin, topic: topic, post_type: Post.types[:whisper])\n        end\n\n        it \"includes only visible posts\" do\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(1)\n        end\n\n        it \"includes all post types for staff members\" do\n          sign_in(admin)\n\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(2)\n        end\n      end\n    end\n\n    it \"should be able to view a user\" do\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).to include(user1.username)\n    end\n\n    it \"should not be able to view a private user profile\" do\n      user1.user_profile.update!(bio_raw: \"Hello world!\")\n      user1.user_option.update!(hide_profile_and_presence: true)\n\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"Hello world!\")\n    end\n\n    describe 'when username contains a period' do\n      before_all do\n        user1.update!(username: 'test.test')\n      end\n\n      it \"should be able to view a user\" do\n        get \"/u/#{user1.username}\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(user1.username)\n      end\n    end\n  end\n\n  describe \"#show_card\" do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to redirect_to '/login'\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'works correctly' do\n        get \"/u/#{user1.username}/card.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"associated_accounts\"]).to eq(nil) # Not serialized in card\n        expect(json[\"user\"][\"username\"]).to eq(user1.username)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity/card.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}/card.json\"\n        expect(response).to be_forbidden\n      end\n    end\n  end\n\n  describe \"#cards\" do\n    fab!(:user) { Discourse.system_user }\n    fab!(:user2) { Fabricate(:user) }\n\n    it \"returns success\" do\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body[\"users\"]\n\n      expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n    end\n\n    it \"should redirect to login page for anonymous user when profiles are hidden\" do\n      SiteSetting.hide_user_profiles_from_public = true\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response).to redirect_to '/login'\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before do\n        user2.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"does not include hidden profiles\" do\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username)\n      end\n\n      it \"does include hidden profiles when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n      end\n    end\n  end\n\n  describe '#badges' do\n    it \"renders fine by default\" do\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"fails if badges are disabled\" do\n      SiteSetting.enable_badges = false\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#account_created\" do\n    it \"returns a message when no session is present\" do\n      get \"/u/account-created\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to match(I18n.t('activation.missing_session'))\n    end\n\n    it \"redirects when the user is logged in\" do\n      sign_in(user1)\n\n      get \"/u/account-created\"\n\n      expect(response).to redirect_to(\"/\")\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        sign_in(user1)\n\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        get \"/u/account-created\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when the user account is created\" do\n      include ApplicationHelper\n\n      it \"returns the message when set in the session\" do\n        user1 = create_user\n        get \"/u/account-created\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['accountCreated']).to include(\n            \"{\\\"message\\\":\\\"#{I18n.t(\"login.activate_email\", email: user1.email).gsub!(\"</\", \"<\\\\/\")}\\\",\\\"show_controls\\\":true,\\\"username\\\":\\\"#{user1.username}\\\",\\\"email\\\":\\\"#{user1.email}\\\"}\"\n          )\n        end\n      end\n    end\n  end\n\n  describe '#search_users' do\n    fab!(:topic) { Fabricate :topic }\n    let(:user)  { Fabricate :user, username: \"joecabot\", name: \"Lawrence Tierney\" }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:staged_user) { Fabricate(:user, staged: true) }\n\n    before do\n      SearchIndexer.enable\n      post1\n    end\n\n    it \"searches when provided the term only\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the topic only\" do\n      get \"/u/search/users.json\", params: { topic_id: topic.id }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the term and topic\" do\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches only for users who have access to private topic\" do\n      searching_user = Fabricate(:user)\n      privileged_user = Fabricate(:user, trust_level: 4, username: \"joecabit\", name: \"Lawrence Tierney\")\n      privileged_group = Fabricate(:group)\n      privileged_group.add(searching_user)\n      privileged_group.add(privileged_user)\n      privileged_group.save\n\n      category = Fabricate(:category)\n      category.set_permissions(privileged_group => :readonly)\n      category.save\n\n      private_topic = Fabricate(:topic, category: category)\n\n      sign_in(searching_user)\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: private_topic.id, topic_allowed_users: \"true\"\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to_not include(user.username)\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(privileged_user.username)\n    end\n\n    it \"interprets blank category id correctly\" do\n      pm_topic = Fabricate(:private_message_post).topic\n      sign_in(pm_topic.user)\n      get \"/u/search/users.json\", params: {\n        term: \"\", topic_id: pm_topic.id, category_id: \"\"\n      }\n      expect(response.status).to eq(200)\n    end\n\n    context 'limit' do\n      it \"returns an error if value is invalid\" do\n        get \"/u/search/users.json\", params: { limit: '-1' }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when `enable_names` is true\" do\n      before do\n        SiteSetting.enable_names = true\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(user.name)\n      end\n    end\n\n    context \"when `enable_names` is false\" do\n      before do\n        SiteSetting.enable_names = false\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(user.name)\n      end\n    end\n\n    context 'groups' do\n      fab!(:mentionable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:public],\n          name: 'aaa1'\n        )\n      end\n\n      fab!(:mentionable_group_2) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa2'\n        )\n      end\n\n      fab!(:messageable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:nobody],\n          messageable_level: Group::ALIAS_LEVELS[:everyone],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa3'\n        )\n      end\n\n      fab!(:private_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          messageable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          visibility_level: Group.visibility_levels[:members],\n          name: 'aaa4'\n        )\n      end\n\n      describe 'when signed in' do\n        before do\n          sign_in(user)\n        end\n\n        it \"does not search for groups if there is no term\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq(nil)\n        end\n\n        it \"only returns visible groups\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: 'a' }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to_not include(private_group.name)\n        end\n\n        it 'allows plugins to register custom groups filter' do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups.count).to eq(6)\n\n          plugin = Plugin::Instance.new\n          plugin.register_groups_callback_for_users_search_controller_action(:admins_filter) do |original_groups, user|\n            original_groups.where(name: \"admins\")\n          end\n          get \"/u/search/users.json\", params: { include_groups: \"true\", admins_filter: \"true\", term: \"a\" }\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq([{ \"name\" => \"admins\", \"full_name\" => nil }])\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"doesn't search for groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n\n        it \"searches for messageable groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"groups\"].map { |group| group['name'] })\n            .to contain_exactly(messageable_group.name, Group.find(Group::AUTO_GROUPS[:moderators]).name)\n        end\n\n        it 'searches for mentionable groups' do\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to contain_exactly(mentionable_group.name, mentionable_group_2.name)\n        end\n      end\n\n      describe 'when not signed in' do\n        it 'should not include mentionable/messageable groups' do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n      end\n\n      describe 'when searching by group name' do\n        fab!(:exclusive_group) { Fabricate(:group) }\n\n        it 'return results if the user is a group member' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a group member' do\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        it 'returns results if the user is member of one of the groups' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a member of the groups' do\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        def users_found\n          response.parsed_body['users'].map { |u| u['username'] }\n        end\n      end\n    end\n\n    context '`include_staged_users`' do\n      it \"includes staged users when the param is true\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: true }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param is not passed\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param explicitly set to false\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: false }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n    end\n\n    context '`last_seen_users`' do\n      it \"returns results when the param is true\" do\n        get \"/u/search/users.json\", params: { last_seen_users: true }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n      end\n\n      it \"respects limit parameter at the same time\" do\n        limit = 3\n        get \"/u/search/users.json\", params: { last_seen_users: true, limit: limit }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n        expect(json[\"users\"].size).to eq(limit)\n      end\n    end\n  end\n\n  describe '#email_login' do\n    before do\n      SiteSetting.enable_local_logins_via_email = true\n    end\n\n    it \"enqueues the right email\" do\n      post \"/u/email-login.json\", params: { login: user1.email }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_found']).to eq(true)\n\n      job_args = Jobs::CriticalUserEmail.jobs.last[\"args\"].first\n      expect(job_args[\"user_id\"]).to eq(user1.id)\n      expect(job_args[\"type\"]).to eq(\"email_login\")\n      expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(user1.email_tokens.last.token_hash)\n    end\n\n    describe 'when enable_local_logins_via_email is disabled' do\n      before do\n        SiteSetting.enable_local_logins_via_email = false\n      end\n\n      it 'should return the right response' do\n        post \"/u/email-login.json\", params: { login: user1.email }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe 'when username or email is not valid' do\n      it 'should not enqueue the email to login' do\n        post \"/u/email-login.json\", params: { login: '@random' }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json['user_found']).to eq(false)\n        expect(json['hide_taken']).to eq(false)\n        expect(Jobs::CriticalUserEmail.jobs).to eq([])\n      end\n    end\n\n    describe 'when hide_email_address_taken is true' do\n      it 'should return the right response' do\n        SiteSetting.hide_email_address_taken = true\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json.has_key?('user_found')).to eq(false)\n        expect(json['hide_taken']).to eq(true)\n      end\n    end\n\n    describe \"when user is already logged in\" do\n      it 'should redirect to the root path' do\n        sign_in(user1)\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response).to redirect_to(\"/\")\n      end\n    end\n  end\n\n  describe '#create_second_factor_totp' do\n    context 'when not logged in' do\n      it 'should return the right response' do\n        post \"/users/second_factors.json\", params: {\n          password: 'wrongpassword'\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          expect(response_body['key']).to be_present\n          expect(response_body['qr']).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#enable_second_factor_totp\" do\n    before do\n      sign_in(user1)\n    end\n\n    def create_totp\n      stub_secure_session_confirmed\n      post \"/users/create_second_factor_totp.json\"\n    end\n\n    it \"creates a totp for the user successfully\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token }\n\n      expect(response.status).to eq(200)\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"rate limits by IP address\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    it \"rate limits by username\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\"  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    context \"when an incorrect token is provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.invalid_second_factor_code\"))\n      end\n    end\n\n    context \"when a name is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_name\"))\n      end\n    end\n\n    context \"when a token is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_code\"))\n      end\n    end\n  end\n\n  describe '#update_second_factor' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factor.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      context 'when user has totp setup' do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              disable: 'true',\n              second_factor_target: UserSecondFactor.methods[:totp],\n              id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            stub_secure_session_confirmed\n          end\n          it 'should allow second factor for the user to be renamed' do\n            put \"/users/second_factor.json\", params: {\n                  name: 'renamed',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first.name).to eq(\"renamed\")\n          end\n\n          it 'should allow second factor for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  disable: 'true',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first).to eq(nil)\n          end\n        end\n      end\n\n      context \"when user is updating backup codes\" do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              second_factor_target: UserSecondFactor.methods[:backup_codes]\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          end\n          it 'should allow second factor backup for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                  disable: 'true'\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.backup_codes).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#create_second_factor_backup' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factors_backup.json\", params: {\n          second_factor_token: 'wrongtoken',\n          second_factor_method: UserSecondFactor.methods[:totp]\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          # we use SecureRandom.hex(16) for backup codes, ensure this continues to be the case\n          expect(response_body['backup_codes'].map(&:length)).to eq([32] * 10)\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_security_key\" do\n    it \"stores the challenge in the session and returns challenge data, user id, and supported algorithms\" do\n      create_second_factor_security_key\n      secure_session = read_secure_session\n      response_parsed = response.parsed_body\n      expect(response_parsed[\"challenge\"]).to eq(\n        Webauthn.challenge(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_id\"]).to eq(\n        Webauthn.rp_id(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_name\"]).to eq(\n        Webauthn.rp_name(user1, secure_session)\n      )\n      expect(response_parsed[\"user_secure_id\"]).to eq(\n        user1.reload.create_or_fetch_secure_identifier\n      )\n      expect(response_parsed[\"supported_algorithms\"]).to eq(\n        ::Webauthn::SUPPORTED_ALGORITHMS\n      )\n    end\n\n    context \"if the user has security key credentials already\" do\n      fab!(:user_security_key) { Fabricate(:user_security_key_with_random_credential, user: user1) }\n\n      it \"returns those existing active credentials\" do\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n        expect(response_parsed[\"existing_active_credential_ids\"]).to eq(\n          [user_security_key.credential_id]\n        )\n      end\n    end\n  end\n\n  describe \"#register_second_factor_security_key\" do\n    context \"when creation parameters are valid\" do\n      it \"creates a security key for the user\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: valid_security_key_create_post_data\n\n        expect(user1.security_keys.count).to eq(1)\n        expect(user1.security_keys.last.credential_id).to eq(valid_security_key_create_post_data[:rawId])\n        expect(user1.security_keys.last.name).to eq(valid_security_key_create_post_data[:name])\n      end\n    end\n\n    context \"when the creation parameters are invalid\" do\n      it \"shows a security key error and does not create a key\" do\n        stub_as_dev_localhost\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: {\n          id: \"bad id\",\n          rawId: \"bad rawId\",\n          type: \"public-key\",\n          attestation: \"bad attestation\",\n          clientData: Base64.encode64('{\"bad\": \"json\"}'),\n          name: \"My Bad Key\"\n        }\n\n        expect(user1.security_keys.count).to eq(0)\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"webauthn.validation.invalid_type_error\"))\n      end\n    end\n  end\n\n  describe '#disable_second_factor' do\n    context 'when logged in with secure session' do\n      before do\n        sign_in(user1)\n        stub_secure_session_confirmed\n      end\n      context 'when user has a registered totp and security key' do\n        before do\n          totp_second_factor = Fabricate(:user_second_factor_totp, user: user1)\n          security_key_second_factor = Fabricate(:user_security_key, user: user1, factor_type: UserSecurityKey.factor_types[:second_factor])\n        end\n\n        it 'should disable all totp and security keys' do\n          expect_enqueued_with(job: :critical_user_email, args: { type: :account_second_factor_disabled, user_id: user1.id }) do\n            put \"/u/disable_second_factor.json\"\n\n            expect(response.status).to eq(200)\n\n            expect(user1.reload.user_second_factors).to be_empty\n            expect(user1.security_keys).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#revoke_account' do\n    it 'errors for unauthorised users' do\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n\n      sign_in(another_user)\n\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns an error when there is no matching account' do\n        post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n          provider_name: 'facebook'\n        }\n        expect(response.status).to eq(404)\n      end\n\n      context \"with fake provider\" do\n        let(:authenticator) do\n          Class.new(Auth::Authenticator) do\n            attr_accessor :can_revoke\n            def name\n              \"testprovider\"\n            end\n\n            def enabled?\n              true\n            end\n\n            def description_for_user(user)\n              \"an account\"\n            end\n\n            def can_revoke?\n              can_revoke\n            end\n\n            def revoke(user, skip_remote: false)\n              true\n            end\n          end.new\n        end\n\n        before do\n          DiscoursePluginRegistry.register_auth_provider(Auth::AuthProvider.new(authenticator: authenticator))\n        end\n\n        after do\n          DiscoursePluginRegistry.reset!\n        end\n\n        it 'returns an error when revoking is not allowed' do\n          authenticator.can_revoke = false\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(404)\n\n          authenticator.can_revoke = true\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n\n        it 'works' do\n          authenticator.can_revoke = true\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n    end\n\n  end\n\n  describe '#revoke_auth_token' do\n\n    context 'while logged in' do\n      before do\n        2.times { sign_in(user1) }\n      end\n\n      it 'logs user out' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        user1.user_auth_tokens.reload\n        expect(user1.user_auth_tokens.count).to eq(1)\n        expect(user1.user_auth_tokens.first.id).to eq(ids[1])\n      end\n\n      it 'checks if token exists' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(400)\n      end\n\n      it 'does not let user log out of current session' do\n        token = UserAuthToken.generate!(user_id: user1.id)\n        cookie = create_auth_cookie(\n          token: token.unhashed_auth_token,\n          user_id: user1.id,\n          trust_level: user1.trust_level,\n          issued_at: 5.minutes.ago,\n        )\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: token.id },\n          headers: { \"HTTP_COOKIE\" => \"_t=#{cookie}\" }\n\n        expect(token.reload.id).to be_present\n        expect(response.status).to eq(400)\n      end\n\n      it 'logs user out from everywhere if token_id is not present' do\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.user_auth_tokens.count).to eq(0)\n      end\n\n    end\n\n  end\n\n  describe '#list_second_factors' do\n    let(:user) { user1 }\n\n    before do\n      sign_in(user)\n    end\n\n    context 'when SSO is enabled' do\n      before do\n        SiteSetting.discourse_connect_url = 'https://discourse.test/sso'\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when local logins are not enabled' do\n      before do\n        SiteSetting.enable_local_logins = false\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when the site settings allow second factors' do\n      before do\n        SiteSetting.enable_local_logins = true\n        SiteSetting.enable_discourse_connect = false\n      end\n\n      context 'when the password parameter is not provided' do\n        let(:password) { '' }\n\n        before do\n          post \"/u/second_factors.json\", params: { password: password }\n        end\n\n        it 'returns password required response' do\n          expect(response.status).to eq(200)\n          response_body = response.parsed_body\n          expect(response_body['password_required']).to eq(true)\n        end\n      end\n\n      context 'when the password is provided' do\n        fab!(:user) { Fabricate(:user, password: '8555039dd212cc66ec68') }\n\n        context 'when the password is correct' do\n          let(:password) { '8555039dd212cc66ec68' }\n\n          it 'returns a list of enabled totps and security_key second factors' do\n            totp_second_factor = Fabricate(:user_second_factor_totp, user: user)\n            security_key_second_factor = Fabricate(:user_security_key, user: user, factor_type: UserSecurityKey.factor_types[:second_factor])\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            expect(response.status).to eq(200)\n            response_body = response.parsed_body\n            expect(response_body['totps'].map { |second_factor| second_factor['id'] }).to include(totp_second_factor.id)\n            expect(response_body['security_keys'].map { |second_factor| second_factor['id'] }).to include(security_key_second_factor.id)\n          end\n        end\n\n        context 'when the password is not correct' do\n          let(:password) { 'wrongpassword' }\n\n          it 'returns the incorrect password response' do\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            response_body = response.parsed_body\n            expect(response_body['error']).to eq(\n              I18n.t(\"login.incorrect_password\")\n            )\n          end\n        end\n      end\n    end\n  end\n\n  describe '#feature_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:other_topic) { Fabricate(:topic) }\n    fab!(:private_message) { Fabricate(:private_message_topic, user: another_user) }\n    fab!(:category) { Fabricate(:category_with_definition) }\n\n    describe \"site setting enabled\" do\n      before do\n        SiteSetting.allow_featured_topic_on_user_profiles = true\n      end\n\n      it 'requires the user to be logged in' do\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the user tries to set for another user' do\n        sign_in(user1)\n        topic.update(user_id: another_user.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the topic is a PM' do\n        sign_in(another_user)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: private_message.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is not visible\" do\n        sign_in(user1)\n        topic.update_status('visible', false, user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic's category is read_restricted\" do\n        sign_in(user1)\n        category.set_permissions({})\n        topic.update(category_id: category.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'sets featured_topic correctly for user created topic' do\n        sign_in(user1)\n        topic.update(user_id: user1.id)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq topic\n      end\n\n      it 'sets featured_topic correctly for non-user-created topic' do\n        sign_in(user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: other_topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq other_topic\n      end\n\n      describe \"site setting disabled\" do\n        before do\n          SiteSetting.allow_featured_topic_on_user_profiles = false\n        end\n\n        it \"does not allow setting featured_topic for user_profiles\" do\n          sign_in(user1)\n          topic.update(user_id: user1.id)\n          put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe '#clear_featured_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n\n    it 'requires the user to be logged in' do\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns an error if the the current user does not have access' do\n      sign_in(user1)\n      topic.update(user_id: another_user.id)\n      put \"/u/#{another_user.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'clears the user_profiles featured_topic correctly' do\n      sign_in(user1)\n      topic.update(user: user1)\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(200)\n      expect(user1.user_profile.featured_topic).to eq nil\n    end\n  end\n\n  describe \"#bookmarks\" do\n    fab!(:bookmark1) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark2) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark3) { Fabricate(:bookmark) }\n\n    before do\n      TopicUser.change(user1.id, bookmark1.topic_id, total_msecs_viewed: 1)\n      TopicUser.change(user1.id, bookmark2.topic_id, total_msecs_viewed: 1)\n    end\n\n    it \"returns a list of serialized bookmarks for the user\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_bookmark_list']['bookmarks'].map { |b| b['id'] }).to match_array([bookmark1.id, bookmark2.id])\n    end\n\n    it \"returns an .ics file of bookmark reminders for the user in date order\" do\n      bookmark1.update!(name: nil, reminder_at: 1.day.from_now)\n      bookmark2.update!(name: \"Some bookmark note\", reminder_at: 1.week.from_now)\n\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.ics\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(<<~ICS)\n        BEGIN:VCALENDAR\n        VERSION:2.0\n        PRODID:-//Discourse//#{Discourse.current_hostname}//#{Discourse.full_version}//EN\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark1.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark1.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark1.reminder_at_ics}\n        DTEND:#{bookmark1.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark1.topic.title}\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark2.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark2.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark2.reminder_at_ics}\n        DTEND:#{bookmark2.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:Some bookmark note\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        END:VEVENT\n        END:VCALENDAR\n      ICS\n    end\n\n    it \"does not show another user's bookmarks\" do\n      sign_in(user1)\n      get \"/u/#{bookmark3.user.username}/bookmarks.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows a helpful message if no bookmarks are found\" do\n      bookmark1.destroy\n      bookmark2.destroy\n      bookmark3.destroy\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n\n    it \"shows a helpful message if no bookmarks are found for the search\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\", params: {\n        q: 'badsearch'\n      }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n  end\n\n  describe \"#private_message_topic_tracking_state\" do\n    fab!(:user_2) { Fabricate(:user) }\n\n    fab!(:private_message) do\n      create_post(\n        user: user1,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message\n      ).topic\n    end\n\n    before do\n      sign_in(user_2)\n    end\n\n    it 'does not allow an unauthorized user to access the state of another user' do\n      get \"/u/#{user1.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns the right response' do\n      get \"/u/#{user_2.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(200)\n\n      topic_state = response.parsed_body.first\n\n      expect(topic_state[\"topic_id\"]).to eq(private_message.id)\n      expect(topic_state[\"highest_post_number\"]).to eq(1)\n      expect(topic_state[\"last_read_post_number\"]).to eq(nil)\n      expect(topic_state[\"notification_level\"]).to eq(NotificationLevels.all[:watching])\n      expect(topic_state[\"group_ids\"]).to eq([])\n    end\n  end\n\n  describe \"#reset_recent_searches\" do\n    it 'does nothing for anon' do\n      delete \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      delete \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      user1.reload\n      expect(user1.user_option.oldest_search_log_date).to be_within(5.seconds).of(1.second.ago)\n    end\n  end\n\n  describe \"#recent_searches\" do\n    it 'does nothing for anon' do\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = true\n      user1.user_option.update!(oldest_search_log_date: nil)\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"old one\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 5.minutes.ago\n      )\n      SearchLog.create!(\n        term: \"also old\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 15.minutes.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 20.minutes.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 10.seconds.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"new search\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 2.seconds.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"new search\"])\n    end\n\n    it 'shows an error message when log_search_queries are off' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = false\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(403)\n      expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"user_activity.no_log_search_queries\"))\n    end\n  end\n\n  def create_second_factor_security_key\n    sign_in(user1)\n    stub_secure_session_confirmed\n    post \"/u/create_second_factor_security_key.json\"\n  end\n\n  def stub_secure_session_confirmed\n    UsersController.any_instance.stubs(:secure_session_confirmed?).returns(true)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass UsersController < ApplicationController\n  skip_before_action :authorize_mini_profiler, only: [:avatar]\n\n  requires_login only: [\n    :username, :update, :upload_user_image,\n    :pick_avatar, :destroy_user_image, :destroy, :check_emails,\n    :topic_tracking_state, :preferences, :create_second_factor_totp,\n    :enable_second_factor_totp, :disable_second_factor, :list_second_factors,\n    :update_second_factor, :create_second_factor_backup, :select_avatar,\n    :notification_level, :revoke_auth_token, :register_second_factor_security_key,\n    :create_second_factor_security_key, :feature_topic, :clear_featured_topic,\n    :bookmarks, :invited, :check_sso_email, :check_sso_payload,\n    :recent_searches, :reset_recent_searches\n  ]\n\n  skip_before_action :check_xhr, only: [\n    :show, :badges, :password_reset_show, :password_reset_update, :update, :account_created,\n    :activate_account, :perform_account_activation, :avatar,\n    :my_redirect, :toggle_anon, :admin_login, :confirm_admin, :email_login, :summary,\n    :feature_topic, :clear_featured_topic, :bookmarks\n  ]\n\n  before_action :second_factor_check_confirmed_password, only: [\n                  :create_second_factor_totp, :enable_second_factor_totp,\n                  :disable_second_factor, :update_second_factor, :create_second_factor_backup,\n                  :register_second_factor_security_key, :create_second_factor_security_key\n                ]\n\n  before_action :respond_to_suspicious_request, only: [:create]\n\n  # we need to allow account creation with bad CSRF tokens, if people are caching, the CSRF token on the\n  #  page is going to be empty, this means that server will see an invalid CSRF and blow the session\n  #  once that happens you can't log in with social\n  skip_before_action :verify_authenticity_token, only: [:create]\n  skip_before_action :redirect_to_login_if_required, only: [:check_username,\n                                                            :check_email,\n                                                            :create,\n                                                            :account_created,\n                                                            :activate_account,\n                                                            :perform_account_activation,\n                                                            :send_activation_email,\n                                                            :update_activation_email,\n                                                            :password_reset_show,\n                                                            :password_reset_update,\n                                                            :confirm_email_token,\n                                                            :email_login,\n                                                            :admin_login,\n                                                            :confirm_admin]\n\n  after_action :add_noindex_header, only: [:show, :my_redirect]\n\n  MAX_RECENT_SEARCHES = 5\n\n  def index\n  end\n\n  def show(for_card: false)\n    return redirect_to path('/login') if SiteSetting.hide_user_profiles_from_public && !current_user\n\n    @user = fetch_user_from_params(\n      include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts)\n    )\n\n    user_serializer = nil\n    if guardian.can_see_profile?(@user)\n      serializer_class = for_card ? UserCardSerializer : UserSerializer\n      user_serializer = serializer_class.new(@user, scope: guardian, root: 'user')\n\n      topic_id = params[:include_post_count_for].to_i\n      if topic_id != 0\n        user_serializer.topic_post_count = { topic_id => Post.secured(guardian).where(topic_id: topic_id, user_id: @user.id).count }\n      end\n    else\n      user_serializer = HiddenProfileSerializer.new(@user, scope: guardian, root: 'user')\n    end\n\n    if !params[:skip_track_visit] && (@user != current_user)\n      track_visit_to_user_profile\n    end\n\n    # This is a hack to get around a Rails issue where values with periods aren't handled correctly\n    # when used as part of a route.\n    if params[:external_id] && params[:external_id].ends_with?('.json')\n      return render_json_dump(user_serializer)\n    end\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        store_preloaded(\"user_#{@user.username}\", MultiJson.dump(user_serializer))\n        render :show\n      end\n\n      format.json do\n        render_json_dump(user_serializer)\n      end\n    end\n  end\n\n  def show_card\n    show(for_card: true)\n  end\n\n  def cards\n    return redirect_to path('/login') if SiteSetting.hide_user_profiles_from_public && !current_user\n\n    user_ids = params.require(:user_ids).split(\",\").map(&:to_i)\n    raise Discourse::InvalidParameters.new(:user_ids) if user_ids.length > 50\n\n    users = User.where(id: user_ids).includes(:user_option,\n                                              :user_stat,\n                                              :default_featured_user_badges,\n                                              :user_profile,\n                                              :card_background_upload,\n                                              :primary_group,\n                                              :flair_group,\n                                              :primary_email\n                                            )\n\n    users = users.filter { |u| guardian.can_see_profile?(u) }\n\n    preload_fields = User.allowed_user_custom_fields(guardian) + UserField.all.pluck(:id).map { |fid| \"#{User::USER_FIELD_PREFIX}#{fid}\" }\n    User.preload_custom_fields(users, preload_fields)\n    User.preload_recent_time_read(users)\n\n    render json: users, each_serializer: UserCardSerializer\n  end\n\n  def badges\n    raise Discourse::NotFound unless SiteSetting.enable_badges?\n    show\n  end\n\n  def update\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    attributes = user_params\n\n    # We can't update the username via this route. Use the username route\n    attributes.delete(:username)\n\n    if params[:user_fields].present?\n      attributes[:custom_fields] ||= {}\n\n      fields = UserField.all\n      fields = fields.where(editable: true) unless current_user.staff?\n      fields.each do |field|\n        field_id = field.id.to_s\n        next unless params[:user_fields].has_key?(field_id)\n\n        value = clean_custom_field_values(field)\n        value = nil if value === \"false\"\n        value = value[0...UserField.max_length] if value\n\n        return render_json_error(I18n.t(\"login.missing_user_field\")) if value.blank? && field.required?\n        attributes[:custom_fields][\"#{User::USER_FIELD_PREFIX}#{field.id}\"] = value\n      end\n    end\n\n    json_result(user, serializer: UserSerializer, additional_errors: [:user_profile, :user_option]) do |u|\n      updater = UserUpdater.new(current_user, user)\n      updater.update(attributes.permit!)\n    end\n  end\n\n  def username\n    params.require(:new_username)\n\n    if clashing_with_existing_route?(params[:new_username]) || User.reserved_username?(params[:new_username])\n      return render_json_error(I18n.t(\"login.reserved_username\"))\n    end\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_username!(user)\n\n    result = UsernameChanger.change(user, params[:new_username], current_user)\n\n    if result\n      render json: { id: user.id, username: user.username }\n    else\n      render_json_error(user.errors.full_messages.join(','))\n    end\n  rescue Discourse::InvalidAccess\n    if current_user&.staff?\n      render_json_error(I18n.t('errors.messages.auth_overrides_username'))\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def check_emails\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_emails!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email, *secondary_emails = user.emails\n    unconfirmed_emails = user.unconfirmed_emails\n\n    render json: {\n      email: email,\n      secondary_emails: secondary_emails,\n      unconfirmed_emails: unconfirmed_emails,\n      associated_accounts: user.associated_accounts\n    }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_email\n    user = fetch_user_from_params(include_inactive: true)\n\n    unless user == current_user\n      guardian.ensure_can_check_sso_details!(user)\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    email = user&.single_sign_on_record&.external_email\n    email = I18n.t(\"user.email.does_not_exist\") if email.blank?\n\n    render json: { email: email }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def check_sso_payload\n    user = fetch_user_from_params(include_inactive: true)\n\n    guardian.ensure_can_check_sso_details!(user)\n    unless user == current_user\n      StaffActionLogger.new(current_user).log_check_email(user, context: params[:context])\n    end\n\n    payload = user&.single_sign_on_record&.last_payload\n    payload = I18n.t(\"user.email.does_not_exist\") if payload.blank?\n\n    render json: { payload: payload }\n  rescue Discourse::InvalidAccess\n    render json: failed_json, status: 403\n  end\n\n  def update_primary_email\n    if !SiteSetting.enable_secondary_emails\n      return render json: failed_json, status: 410\n    end\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit_email!(user)\n\n    old_primary = user.primary_email\n    if old_primary.email == params[:email]\n      return render json: success_json\n    end\n\n    new_primary = user.user_emails.find_by(email: params[:email])\n    if new_primary.blank?\n      return render json: failed_json.merge(errors: [I18n.t(\"change_email.doesnt_exist\")]), status: 428\n    end\n\n    User.transaction do\n      old_primary.update!(primary: false)\n      new_primary.update!(primary: true)\n      DiscourseEvent.trigger(:user_updated, user)\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_update_email(user)\n      else\n        UserHistory.create!(action: UserHistory.actions[:update_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def destroy_email\n    if !SiteSetting.enable_secondary_emails\n      return render json: failed_json, status: 410\n    end\n\n    params.require(:email)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    ActiveRecord::Base.transaction do\n      if change_requests = user.email_change_requests.where(new_email: params[:email]).presence\n        change_requests.destroy_all\n      elsif user.user_emails.where(email: params[:email], primary: false).destroy_all.present?\n        DiscourseEvent.trigger(:user_updated, user)\n      else\n        return render json: failed_json, status: 428\n      end\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_destroy_email(user)\n      else\n        UserHistory.create(action: UserHistory.actions[:destroy_email], acting_user_id: user.id)\n      end\n    end\n\n    render json: success_json\n  end\n\n  def topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = TopicTrackingState.report(user)\n    serializer = ActiveModel::ArraySerializer.new(\n      report, each_serializer: TopicTrackingStateSerializer, scope: guardian\n    )\n\n    render json: MultiJson.dump(serializer)\n  end\n\n  def private_message_topic_tracking_state\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    report = PrivateMessageTopicTrackingState.report(user)\n\n    serializer = ActiveModel::ArraySerializer.new(\n      report,\n      each_serializer: PrivateMessageTopicTrackingStateSerializer,\n      scope: guardian\n    )\n\n    render json: MultiJson.dump(serializer)\n  end\n\n  def badge_title\n    params.require(:user_badge_id)\n\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    user_badge = UserBadge.find_by(id: params[:user_badge_id])\n    previous_title = user.title\n    if user_badge && user_badge.user == user && user_badge.badge.allow_title?\n      user.title = user_badge.badge.display_name\n      user.save!\n\n      log_params = {\n        details: \"title matching badge id #{user_badge.badge.id}\",\n        previous_value: previous_title,\n        new_value: user.title\n      }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger.new(current_user).log_title_change(user, log_params)\n      else\n        UserHistory.create!(log_params.merge(target_user_id: user.id, action: UserHistory.actions[:change_title]))\n      end\n    else\n      user.title = ''\n      user.save!\n\n      log_params = {\n        previous_value: previous_title\n      }\n\n      if current_user.staff? && current_user != user\n        StaffActionLogger\n          .new(current_user)\n          .log_title_revoke(user, log_params.merge(revoke_reason: 'user title was same as revoked badge name or custom badge name'))\n      else\n        UserHistory.create!(log_params.merge(target_user_id: user.id, action: UserHistory.actions[:revoke_title]))\n      end\n    end\n\n    render body: nil\n  end\n\n  def preferences\n    render body: nil\n  end\n\n  def my_redirect\n    raise Discourse::NotFound if params[:path] !~ /^[a-z_\\-\\/]+$/\n\n    if current_user.blank?\n      cookies[:destination_url] = path(\"/my/#{params[:path]}\")\n      redirect_to path(\"/login-preferences\")\n    else\n      redirect_to(path(\"/u/#{current_user.encoded_username}/#{params[:path]}\"))\n    end\n  end\n\n  def profile_hidden\n    render nothing: true\n  end\n\n  def summary\n    @user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts))\n    raise Discourse::NotFound unless guardian.can_see_profile?(@user)\n\n    response.headers['X-Robots-Tag'] = 'noindex'\n\n    respond_to do |format|\n      format.html do\n        @restrict_fields = guardian.restrict_user_fields?(@user)\n        render :show\n      end\n      format.json do\n        summary_json = Discourse.cache.fetch(summary_cache_key(@user), expires_in: 1.hour) do\n          summary = UserSummary.new(@user, guardian)\n          serializer = UserSummarySerializer.new(summary, scope: guardian)\n          MultiJson.dump(serializer)\n        end\n        render json: summary_json\n      end\n    end\n  end\n\n  def invited\n    if guardian.can_invite_to_forum?\n      filter = params[:filter] || \"redeemed\"\n      inviter = fetch_user_from_params(include_inactive: current_user.staff? || SiteSetting.show_inactive_accounts)\n\n      invites = if filter == \"pending\" && guardian.can_see_invite_details?(inviter)\n        Invite.includes(:topics, :groups).pending(inviter)\n      elsif filter == \"expired\"\n        Invite.expired(inviter)\n      elsif filter == \"redeemed\"\n        Invite.redeemed_users(inviter)\n      else\n        Invite.none\n      end\n\n      invites = invites.offset(params[:offset].to_i || 0).limit(SiteSetting.invites_per_page)\n\n      show_emails = guardian.can_see_invite_emails?(inviter)\n      if params[:search].present? && invites.present?\n        filter_sql = '(LOWER(users.username) LIKE :filter)'\n        filter_sql = '(LOWER(invites.email) LIKE :filter) or (LOWER(users.username) LIKE :filter)' if show_emails\n        invites = invites.where(filter_sql, filter: \"%#{params[:search].downcase}%\")\n      end\n\n      pending_count = Invite.pending(inviter).reorder(nil).count.to_i\n      expired_count = Invite.expired(inviter).reorder(nil).count.to_i\n      redeemed_count = Invite.redeemed_users(inviter).reorder(nil).count.to_i\n\n      render json: MultiJson.dump(InvitedSerializer.new(\n        OpenStruct.new(\n          invite_list: invites.to_a,\n          show_emails: show_emails,\n          inviter: inviter,\n          type: filter,\n          counts: {\n            pending: pending_count,\n            expired: expired_count,\n            redeemed: redeemed_count,\n            total: pending_count + expired_count\n          }\n        ),\n        scope: guardian,\n        root: false\n      ))\n    elsif current_user&.staff?\n      message = if SiteSetting.enable_discourse_connect\n        I18n.t(\"invite.disabled_errors.discourse_connect_enabled\")\n      end\n\n      render_invite_error(message)\n    else\n      render_json_error(I18n.t(\"invite.disabled_errors.invalid_access\"))\n    end\n  end\n\n  def is_local_username\n    usernames = params[:usernames] if params[:usernames].present?\n    usernames = [params[:username]] if params[:username].present?\n\n    raise Discourse::InvalidParameters.new(:usernames) if !usernames.kind_of?(Array) || usernames.size > 20\n\n    groups = Group.where(name: usernames).pluck(:name)\n    mentionable_groups =\n      if current_user\n        Group.mentionable(current_user, include_public: false)\n          .where(name: usernames)\n          .pluck(:name, :user_count)\n          .map do |name, user_count|\n          {\n            name: name,\n            user_count: user_count\n          }\n        end\n      end\n\n    usernames -= groups\n    usernames.each(&:downcase!)\n\n    users = User\n      .where(staged: false, username_lower: usernames)\n      .index_by(&:username_lower)\n\n    cannot_see = {}\n    here_count = nil\n\n    topic_id = params[:topic_id]\n    if topic_id.present? && topic = Topic.find_by(id: topic_id)\n      topic_muted_by = TopicUser\n        .where(topic: topic)\n        .where(user_id: users.values.map(&:id))\n        .where(notification_level: TopicUser.notification_levels[:muted])\n        .pluck(:user_id)\n        .to_set\n\n      if topic.private_message?\n        topic_allowed_user_ids = TopicAllowedUser\n          .where(topic: topic)\n          .where(user_id: users.values.map(&:id))\n          .pluck(:user_id)\n          .to_set\n\n        topic_allowed_group_ids = TopicAllowedGroup\n          .where(topic: topic)\n          .pluck(:group_id)\n          .to_set\n      end\n\n      usernames.each do |username|\n        user = users[username]\n        next if user.blank?\n\n        cannot_see_reason = nil\n        if !user.guardian.can_see?(topic)\n          cannot_see_reason = topic.private_message? ? :private : :category\n        elsif topic_muted_by.include?(user.id)\n          cannot_see_reason = :muted_topic\n        elsif topic.private_message? && !topic_allowed_user_ids.include?(user.id) && !user.group_ids.any? { |group_id| topic_allowed_group_ids.include?(group_id) }\n          cannot_see_reason = :not_allowed\n        end\n\n        if !guardian.is_staff? && cannot_see_reason.present? && cannot_see_reason != :private && cannot_see_reason != :category\n          cannot_see_reason = nil # do not leak private information\n        end\n\n        cannot_see[username] = cannot_see_reason if cannot_see_reason.present?\n      end\n\n      if usernames.include?(SiteSetting.here_mention) && guardian.can_mention_here?\n        here_count = PostAlerter.new.expand_here_mention(topic.first_post, exclude_ids: [current_user.id]).size\n      end\n    end\n\n    render json: {\n      valid: users.keys,\n      valid_groups: groups,\n      mentionable_groups: mentionable_groups,\n      cannot_see: cannot_see,\n      here_count: here_count,\n      max_users_notified_per_group_mention: SiteSetting.max_users_notified_per_group_mention\n    }\n  end\n\n  def render_available_true\n    render(json: { available: true })\n  end\n\n  def changing_case_of_own_username(target_user, username)\n    target_user && username.downcase == (target_user.username.downcase)\n  end\n\n  # Used for checking availability of a username and will return suggestions\n  # if the username is not available.\n  def check_username\n    if !params[:username].present?\n      params.require(:username) if !params[:email].present?\n      return render(json: success_json)\n    end\n    username = params[:username]&.unicode_normalize\n\n    target_user = user_from_params_or_current_user\n\n    # The special case where someone is changing the case of their own username\n    return render_available_true if changing_case_of_own_username(target_user, username)\n\n    checker = UsernameCheckerService.new\n    email = params[:email] || target_user.try(:email)\n    render json: checker.check_username(username, email)\n  end\n\n  def check_email\n    begin\n      RateLimiter.new(nil, \"check-email-#{request.remote_ip}\", 10, 1.minute).performed!\n    rescue RateLimiter::LimitExceeded\n      return render json: success_json\n    end\n\n    email = Email.downcase((params[:email] || \"\").strip)\n\n    if email.blank? || SiteSetting.hide_email_address_taken?\n      return render json: success_json\n    end\n\n    if !(email =~ EmailValidator.email_regex)\n      error = User.new.errors.full_message(:email, I18n.t(:'user.email.invalid'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if !EmailValidator.allowed?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:'user.email.not_allowed'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if ScreenedEmail.should_block?(email)\n      error = User.new.errors.full_message(:email, I18n.t(:'user.email.blocked'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    if User.where(staged: false).find_by_email(email).present?\n      error = User.new.errors.full_message(:email, I18n.t(:'errors.messages.taken'))\n      return render json: failed_json.merge(errors: [error])\n    end\n\n    render json: success_json\n  end\n\n  def user_from_params_or_current_user\n    params[:for_user_id] ? User.find(params[:for_user_id]) : current_user\n  end\n\n  def create\n    params.require(:email)\n    params.require(:username)\n    params.require(:invite_code) if SiteSetting.require_invite_code\n    params.permit(:user_fields)\n\n    unless SiteSetting.allow_new_registrations\n      return fail_with(\"login.new_registrations_disabled\")\n    end\n\n    if params[:password] && params[:password].length > User.max_password_length\n      return fail_with(\"login.password_too_long\")\n    end\n\n    if params[:email].length > 254 + 1 + 253\n      return fail_with(\"login.email_too_long\")\n    end\n\n    if SiteSetting.require_invite_code && SiteSetting.invite_code.strip.downcase != params[:invite_code].strip.downcase\n      return fail_with(\"login.wrong_invite_code\")\n    end\n\n    if clashing_with_existing_route?(params[:username]) || User.reserved_username?(params[:username])\n      return fail_with(\"login.reserved_username\")\n    end\n\n    params[:locale] ||= I18n.locale unless current_user\n\n    new_user_params = user_params.except(:timezone)\n\n    user = User.where(staged: true).with_email(new_user_params[:email].strip.downcase).first\n\n    if user\n      user.active = false\n      user.unstage!\n    end\n\n    user ||= User.new\n    user.attributes = new_user_params\n\n    # Handle API approval and\n    # auto approve users based on auto_approve_email_domains setting\n    if user.approved? || EmailValidator.can_auto_approve_user?(user.email)\n      ReviewableUser.set_approved_fields!(user, current_user)\n    end\n\n    # Handle custom fields\n    user_fields = UserField.all\n    if user_fields.present?\n      field_params = params[:user_fields] || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        if field_val.blank?\n          return fail_with(\"login.missing_user_field\") if f.required?\n        else\n          fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[0...UserField.max_length]\n        end\n      end\n\n      user.custom_fields = fields\n    end\n\n    authentication = UserAuthenticator.new(user, session)\n\n    if !authentication.has_authenticator? && !SiteSetting.enable_local_logins && !(current_user&.admin? && is_api?)\n      return render body: nil, status: :forbidden\n    end\n\n    authentication.start\n\n    if authentication.email_valid? && !authentication.authenticated?\n      # posted email is different that the already validated one?\n      return fail_with('login.incorrect_username_email_or_password')\n    end\n\n    activation = UserActivator.new(user, request, session, cookies)\n    activation.start\n\n    # just assign a password if we have an authenticator and no password\n    # this is the case for Twitter\n    user.password = SecureRandom.hex if user.password.blank? && authentication.has_authenticator?\n\n    if user.save\n      authentication.finish\n      activation.finish\n      user.update_timezone_if_missing(params[:timezone])\n\n      secure_session[HONEYPOT_KEY] = nil\n      secure_session[CHALLENGE_KEY] = nil\n\n      # save user email in session, to show on account-created page\n      session[\"user_created_message\"] = activation.message\n      session[SessionController::ACTIVATE_USER_KEY] = user.id\n\n      # If the user was created as active this will\n      # ensure their email is confirmed and\n      # add them to the review queue if they need to be approved\n      user.activate if user.active?\n\n      render json: {\n        success: true,\n        active: user.active?,\n        message: activation.message,\n      }.merge(SiteSetting.hide_email_address_taken ? {} : { user_id: user.id })\n    elsif SiteSetting.hide_email_address_taken && user.errors[:primary_email]&.include?(I18n.t('errors.messages.taken'))\n      session[\"user_created_message\"] = activation.success_message\n\n      if existing_user = User.find_by_email(user.primary_email&.email)\n        Jobs.enqueue(:critical_user_email, type: :account_exists, user_id: existing_user.id)\n      end\n\n      render json: {\n        success: true,\n        active: false,\n        message: activation.success_message\n      }\n    else\n      errors = user.errors.to_hash\n      errors[:email] = errors.delete(:primary_email) if errors[:primary_email]\n\n      render json: {\n        success: false,\n        message: I18n.t(\n          'login.errors',\n          errors: user.errors.full_messages.join(\"\\n\")\n        ),\n        errors: errors,\n        values: {\n          name: user.name,\n          username: user.username,\n          email: user.primary_email&.email\n        },\n        is_developer: UsernameCheckerService.is_developer?(user.email)\n      }\n    end\n  rescue ActiveRecord::StatementInvalid\n    render json: {\n      success: false,\n      message: I18n.t(\"login.something_already_taken\")\n    }\n  end\n\n  def password_reset_show\n    expires_now\n    token = params[:token]\n\n    password_reset_find_user(token, committing_change: false)\n\n    if !@error\n      security_params = {\n        is_developer: UsernameCheckerService.is_developer?(@user.email),\n        admin: @user.admin?,\n        second_factor_required: @user.totp_enabled?,\n        security_key_required: @user.security_keys_enabled?,\n        backup_enabled: @user.backup_codes_enabled?,\n        multiple_second_factor_methods: @user.has_multiple_second_factor_methods?\n      }\n    end\n\n    respond_to do |format|\n      format.html do\n        return render 'password_reset', layout: 'no_ember' if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        store_preloaded(\n          \"password_reset\",\n          MultiJson.dump(security_params.merge(Webauthn.allowed_credentials(@user, secure_session)))\n        )\n\n        render 'password_reset'\n      end\n\n      format.json do\n        return render json: { message: @error } if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n        render json: security_params.merge(Webauthn.allowed_credentials(@user, secure_session))\n      end\n    end\n  end\n\n  def password_reset_update\n    expires_now\n    token = params[:token]\n    password_reset_find_user(token, committing_change: true)\n\n    rate_limit_second_factor!(@user)\n\n    # no point doing anything else if we can't even find\n    # a user from the token\n    if @user\n      if !secure_session[\"second-factor-#{token}\"]\n        second_factor_authentication_result = @user.authenticate_second_factor(params, secure_session)\n        if !second_factor_authentication_result.ok\n          user_error_key = second_factor_authentication_result.reason == \"invalid_security_key\" ? :user_second_factors : :security_keys\n          @user.errors.add(user_error_key, :invalid)\n          @error = second_factor_authentication_result.error\n        else\n\n          # this must be set because the first call we authenticate e.g. TOTP, and we do\n          # not want to re-authenticate on the second call to change the password as this\n          # will cause a TOTP error saying the code has already been used\n          secure_session[\"second-factor-#{token}\"] = true\n        end\n      end\n\n      if @invalid_password = params[:password].blank? || params[:password].size > User.max_password_length\n        @user.errors.add(:password, :invalid)\n      end\n\n      # if we have run into no errors then the user is a-ok to\n      # change the password\n      if @user.errors.empty?\n        @user.update_timezone_if_missing(params[:timezone]) if params[:timezone]\n        @user.password = params[:password]\n        @user.password_required!\n        @user.user_auth_tokens.destroy_all\n        if @user.save\n          Invite.invalidate_for_email(@user.email) # invite link can't be used to log in anymore\n          secure_session[\"password-#{token}\"] = nil\n          secure_session[\"second-factor-#{token}\"] = nil\n          UserHistory.create!(\n            target_user: @user,\n            acting_user: @user,\n            action: UserHistory.actions[:change_password]\n          )\n          logon_after_password_reset\n        end\n      end\n    end\n\n    respond_to do |format|\n      format.html do\n        return render 'password_reset', layout: 'no_ember' if @error\n\n        Webauthn.stage_challenge(@user, secure_session)\n\n        security_params = {\n          is_developer: UsernameCheckerService.is_developer?(@user.email),\n          admin: @user.admin?,\n          second_factor_required: @user.totp_enabled?,\n          security_key_required: @user.security_keys_enabled?,\n          backup_enabled: @user.backup_codes_enabled?,\n          multiple_second_factor_methods: @user.has_multiple_second_factor_methods?\n        }.merge(Webauthn.allowed_credentials(@user, secure_session))\n\n        store_preloaded(\"password_reset\", MultiJson.dump(security_params))\n\n        return redirect_to(wizard_path) if Wizard.user_requires_completion?(@user)\n\n        render 'password_reset'\n      end\n\n      format.json do\n        if @error || @user&.errors&.any?\n          render json: {\n            success: false,\n            message: @error,\n            errors: @user&.errors&.to_hash,\n            is_developer: UsernameCheckerService.is_developer?(@user&.email),\n            admin: @user&.admin?\n          }\n        else\n          render json: {\n            success: true,\n            message: @success,\n            requires_approval: !Guardian.new(@user).can_access_forum?,\n            redirect_to: Wizard.user_requires_completion?(@user) ? wizard_path : nil\n          }\n        end\n      end\n    end\n  end\n\n  def confirm_email_token\n    expires_now\n    EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n    render json: success_json\n  end\n\n  def logon_after_password_reset\n    message =\n      if Guardian.new(@user).can_access_forum?\n        # Log in the user\n        log_on_user(@user)\n        'password_reset.success'\n      else\n        @requires_approval = true\n        'password_reset.success_unapproved'\n      end\n\n    @success = I18n.t(message)\n  end\n\n  def admin_login\n    return redirect_to(path(\"/\")) if current_user\n\n    if request.put? && params[:email].present?\n      RateLimiter.new(nil, \"admin-login-hr-#{request.remote_ip}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"admin-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n\n      if user = User.with_email(params[:email]).admins.human_users.first\n        email_token = user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n        Jobs.enqueue(:critical_user_email, type: :admin_login, user_id: user.id, email_token: email_token.token)\n        @message = I18n.t(\"admin_login.success\")\n      else\n        @message = I18n.t(\"admin_login.errors.unknown_email_address\")\n      end\n    end\n\n    render layout: 'no_ember'\n  rescue RateLimiter::LimitExceeded\n    @message = I18n.t(\"rate_limiter.slow_down\")\n    render layout: 'no_ember'\n  end\n\n  def email_login\n    raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email\n    return redirect_to path(\"/\") if current_user\n\n    expires_now\n    params.require(:login)\n\n    RateLimiter.new(nil, \"email-login-hour-#{request.remote_ip}\", 6, 1.hour).performed!\n    RateLimiter.new(nil, \"email-login-min-#{request.remote_ip}\", 3, 1.minute).performed!\n    user = User.human_users.find_by_username_or_email(params[:login])\n    user_presence = user.present? && !user.staged\n\n    if user\n      RateLimiter.new(nil, \"email-login-hour-#{user.id}\", 6, 1.hour).performed!\n      RateLimiter.new(nil, \"email-login-min-#{user.id}\", 3, 1.minute).performed!\n\n      if user_presence\n        DiscourseEvent.trigger(:before_email_login, user)\n\n        email_token = user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:email_login])\n\n        Jobs.enqueue(:critical_user_email,\n          type: :email_login,\n          user_id: user.id,\n          email_token: email_token.token\n        )\n      end\n    end\n\n    json = success_json\n    json[:hide_taken] = SiteSetting.hide_email_address_taken\n    json[:user_found] = user_presence unless SiteSetting.hide_email_address_taken\n    render json: json\n  rescue RateLimiter::LimitExceeded\n    render_json_error(I18n.t(\"rate_limiter.slow_down\"))\n  end\n\n  def toggle_anon\n    user = AnonymousShadowCreator.get_master(current_user) ||\n           AnonymousShadowCreator.get(current_user)\n\n    if user\n      log_on_user(user)\n      render json: success_json\n    else\n      render json: failed_json, status: 403\n    end\n  end\n\n  def account_created\n    if current_user.present?\n      if SiteSetting.enable_discourse_connect_provider && payload = cookies.delete(:sso_payload)\n        return redirect_to(session_sso_provider_url + \"?\" + payload)\n      elsif destination_url = cookies.delete(:destination_url)\n        return redirect_to(destination_url)\n      else\n        return redirect_to(path('/'))\n      end\n    end\n\n    @custom_body_class = \"static-account-created\"\n    @message = session['user_created_message'] || I18n.t('activation.missing_session')\n    @account_created = { message: @message, show_controls: false }\n\n    if session_user_id = session[SessionController::ACTIVATE_USER_KEY]\n      if user = User.where(id: session_user_id.to_i).first\n        @account_created[:username] = user.username\n        @account_created[:email] = user.email\n        @account_created[:show_controls] = !user.from_staged?\n      end\n    end\n\n    store_preloaded(\"accountCreated\", MultiJson.dump(@account_created))\n    expires_now\n\n    respond_to do |format|\n      format.html { render \"default/empty\" }\n      format.json { render json: success_json }\n    end\n  end\n\n  def activate_account\n    expires_now\n    render layout: 'no_ember'\n  end\n\n  def perform_account_activation\n    raise Discourse::InvalidAccess.new if honeypot_or_challenge_fails?(params)\n\n    if @user = EmailToken.confirm(params[:token], scope: EmailToken.scopes[:signup])\n      # Log in the user unless they need to be approved\n      if Guardian.new(@user).can_access_forum?\n        @user.enqueue_welcome_message('welcome_user') if @user.send_welcome_message\n        log_on_user(@user)\n\n        if Wizard.user_requires_completion?(@user)\n          return redirect_to(wizard_path)\n        elsif destination_url = cookies[:destination_url]\n          cookies[:destination_url] = nil\n          return redirect_to(destination_url)\n        elsif SiteSetting.enable_discourse_connect_provider && payload = cookies.delete(:sso_payload)\n          return redirect_to(session_sso_provider_url + \"?\" + payload)\n        end\n      else\n        @needs_approval = true\n      end\n    else\n      flash.now[:error] = I18n.t('activation.already_done')\n    end\n\n    render layout: 'no_ember'\n  end\n\n  def update_activation_email\n    RateLimiter.new(nil, \"activate-edit-email-hr-#{request.remote_ip}\", 5, 1.hour).performed!\n\n    if params[:username].present?\n      RateLimiter.new(nil, \"activate-edit-email-hr-username-#{params[:username]}\", 5, 1.hour).performed!\n      @user = User.find_by_username_or_email(params[:username])\n      raise Discourse::InvalidAccess.new unless @user.present?\n      raise Discourse::InvalidAccess.new unless @user.confirm_password?(params[:password])\n    elsif user_key = session[SessionController::ACTIVATE_USER_KEY]\n      RateLimiter.new(nil, \"activate-edit-email-hr-user-key-#{user_key}\", 5, 1.hour).performed!\n      @user = User.where(id: user_key.to_i).first\n    end\n\n    if @user.blank? || @user.active? || current_user.present? || @user.from_staged?\n      raise Discourse::InvalidAccess.new\n    end\n\n    User.transaction do\n      primary_email = @user.primary_email\n      primary_email.email = params[:email]\n      primary_email.skip_validate_email = false\n\n      if primary_email.save\n        @email_token = @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n        EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n        render json: success_json\n      else\n        render_json_error(primary_email)\n      end\n    end\n  end\n\n  def send_activation_email\n    if current_user.blank? || !current_user.staff?\n      RateLimiter.new(nil, \"activate-hr-#{request.remote_ip}\", 30, 1.hour).performed!\n      RateLimiter.new(nil, \"activate-min-#{request.remote_ip}\", 6, 1.minute).performed!\n    end\n\n    raise Discourse::InvalidAccess.new if SiteSetting.must_approve_users?\n\n    if params[:username].present?\n      @user = User.find_by_username_or_email(params[:username].to_s)\n    end\n\n    raise Discourse::NotFound unless @user\n\n    if !current_user&.staff? && @user.id != session[SessionController::ACTIVATE_USER_KEY]\n      raise Discourse::InvalidAccess.new\n    end\n\n    session.delete(SessionController::ACTIVATE_USER_KEY)\n\n    if @user.active && @user.email_confirmed?\n      render_json_error(I18n.t('activation.activated'), status: 409)\n    else\n      @email_token = @user.email_tokens.create!(email: @user.email, scope: EmailToken.scopes[:signup])\n      EmailToken.enqueue_signup_email(@email_token, to_address: @user.email)\n      render body: nil\n    end\n  end\n\n  def search_users\n    term = params[:term].to_s.strip\n\n    topic_id = params[:topic_id].to_i if params[:topic_id].present?\n    category_id = params[:category_id].to_i if params[:category_id].present?\n\n    topic_allowed_users = params[:topic_allowed_users] || false\n\n    group_names = params[:groups] || []\n    group_names << params[:group] if params[:group]\n    @groups = Group.where(name: group_names) if group_names.present?\n\n    options = {\n     topic_allowed_users: topic_allowed_users,\n     searching_user: current_user,\n     groups: @groups\n    }\n\n    options[:include_staged_users] = !!ActiveModel::Type::Boolean.new.cast(params[:include_staged_users])\n    options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users])\n    if params[:limit].present?\n      options[:limit] = params[:limit].to_i\n      raise Discourse::InvalidParameters.new(:limit) if options[:limit] <= 0\n    end\n    options[:topic_id] = topic_id if topic_id\n    options[:category_id] = category_id if category_id\n\n    results = UserSearch.new(term, options).search\n\n    user_fields = [:username, :upload_avatar_template]\n    user_fields << :name if SiteSetting.enable_names?\n\n    to_render = { users: results.as_json(only: user_fields, methods: [:avatar_template]) }\n\n    # blank term is only handy for in-topic search of users after @\n    # we do not want group results ever if term is blank\n    groups =\n      if term.present? && current_user\n        if params[:include_groups] == 'true'\n          Group.visible_groups(current_user)\n        elsif params[:include_mentionable_groups] == 'true'\n          Group.mentionable(current_user)\n        elsif params[:include_messageable_groups] == 'true'\n          Group.messageable(current_user)\n        end\n      end\n\n    if groups\n      DiscoursePluginRegistry.groups_callback_for_users_search_controller_action.each do |param_name, block|\n        if params[param_name.to_s]\n          groups = block.call(groups, current_user)\n        end\n      end\n\n      groups = Group.search_groups(term, groups: groups)\n      groups = groups.order('groups.name asc')\n\n      to_render[:groups] = groups.map do |m|\n        { name: m.name, full_name: m.full_name }\n      end\n    end\n\n    render json: to_render\n  end\n\n  AVATAR_TYPES_WITH_UPLOAD ||= %w{uploaded custom gravatar}\n\n  def pick_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    if SiteSetting.discourse_connect_overrides_avatar\n      return render json: failed_json, status: 422\n    end\n\n    type = params[:type]\n\n    invalid_type = type.present? && !AVATAR_TYPES_WITH_UPLOAD.include?(type) && type != 'system'\n    if invalid_type\n      return render json: failed_json, status: 422\n    end\n\n    if type.blank? || type == 'system'\n      upload_id = nil\n    elsif !TrustLevelAndStaffAndDisabledSetting.matches?(SiteSetting.allow_uploaded_avatars, user)\n      return render json: failed_json, status: 422\n    else\n      upload_id = params[:upload_id]\n      upload = Upload.find_by(id: upload_id)\n\n      if upload.nil?\n        return render_json_error I18n.t('avatar.missing')\n      end\n\n      # old safeguard\n      user.create_user_avatar unless user.user_avatar\n\n      guardian.ensure_can_pick_avatar!(user.user_avatar, upload)\n\n      if type == 'gravatar'\n        user.user_avatar.gravatar_upload_id = upload_id\n      else\n        user.user_avatar.custom_upload_id = upload_id\n      end\n    end\n\n    if user.is_system_user?\n      SiteSetting.use_site_small_logo_as_system_avatar = false\n    end\n\n    user.uploaded_avatar_id = upload_id\n    user.save!\n    user.user_avatar.save!\n\n    render json: success_json\n  end\n\n  def select_avatar\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    url = params[:url]\n\n    if url.blank?\n      return render json: failed_json, status: 422\n    end\n\n    unless SiteSetting.selectable_avatars_enabled\n      return render json: failed_json, status: 422\n    end\n\n    if SiteSetting.selectable_avatars.blank?\n      return render json: failed_json, status: 422\n    end\n\n    unless upload = Upload.get_from_url(url)\n      return render json: failed_json, status: 422\n    end\n\n    unless SiteSetting.selectable_avatars.include?(upload)\n      return render json: failed_json, status: 422\n    end\n\n    user.uploaded_avatar_id = upload.id\n\n    if user.is_system_user?\n      SiteSetting.use_site_small_logo_as_system_avatar = false\n    end\n\n    user.save!\n\n    avatar = user.user_avatar || user.create_user_avatar\n    avatar.custom_upload_id = upload.id\n    avatar.save!\n\n    render json: {\n      avatar_template: user.avatar_template,\n      custom_avatar_template: user.avatar_template,\n      uploaded_avatar_id: upload.id,\n    }\n  end\n\n  def destroy_user_image\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    case params.require(:type)\n    when \"profile_background\"\n      user.user_profile.clear_profile_background\n    when \"card_background\"\n      user.user_profile.clear_card_background\n    else\n      raise Discourse::InvalidParameters.new(:type)\n    end\n\n    render json: success_json\n  end\n\n  def destroy\n    @user = fetch_user_from_params\n    guardian.ensure_can_delete_user!(@user)\n\n    UserDestroyer.new(current_user).destroy(@user, delete_posts: true, context: params[:context])\n\n    render json: success_json\n  end\n\n  def notification_level\n    user = fetch_user_from_params\n\n    if params[:notification_level] == \"ignore\"\n      @error_message = \"ignore_error\"\n      guardian.ensure_can_ignore_user!(user)\n      MutedUser.where(user: current_user, muted_user: user).delete_all\n      ignored_user = IgnoredUser.find_by(user: current_user, ignored_user: user)\n      if ignored_user.present?\n        ignored_user.update(expiring_at: DateTime.parse(params[:expiring_at]))\n      else\n        IgnoredUser.create!(user: current_user, ignored_user: user, expiring_at: Time.parse(params[:expiring_at]))\n      end\n    elsif params[:notification_level] == \"mute\"\n      @error_message = \"mute_error\"\n      guardian.ensure_can_mute_user!(user)\n      IgnoredUser.where(user: current_user, ignored_user: user).delete_all\n      MutedUser.find_or_create_by!(user: current_user, muted_user: user)\n    elsif params[:notification_level] == \"normal\"\n      MutedUser.where(user: current_user, muted_user: user).delete_all\n      IgnoredUser.where(user: current_user, ignored_user: user).delete_all\n    end\n\n    render json: success_json\n  rescue Discourse::InvalidAccess => e\n    render_json_error(I18n.t(\"notification_level.#{@error_message}\"))\n  end\n\n  def read_faq\n    if user = current_user\n      user.user_stat.read_faq = 1.second.ago\n      user.user_stat.save\n    end\n\n    render json: success_json\n  end\n\n  def recent_searches\n    if !SiteSetting.log_search_queries\n      return render json: failed_json.merge(\n                      error: I18n.t(\"user_activity.no_log_search_queries\")\n                    ), status: 403\n    end\n\n    query = SearchLog.where(user_id: current_user.id)\n\n    if current_user.user_option.oldest_search_log_date\n      query = query\n        .where(\"created_at > ?\", current_user.user_option.oldest_search_log_date)\n    end\n\n    results = query.group(:term)\n      .order(\"max(created_at) DESC\")\n      .limit(MAX_RECENT_SEARCHES)\n      .pluck(:term)\n\n    render json: success_json.merge(recent_searches: results)\n  end\n\n  def reset_recent_searches\n    current_user.user_option.update!(oldest_search_log_date: 1.second.ago)\n    render json: success_json\n  end\n\n  def staff_info\n    @user = fetch_user_from_params(include_inactive: true)\n    guardian.ensure_can_see_staff_info!(@user)\n\n    result = {}\n\n    %W{\n      number_of_deleted_posts number_of_flagged_posts number_of_flags_given\n      number_of_suspensions warnings_received_count number_of_rejected_posts\n    }.each do |info|\n      result[info] = @user.public_send(info)\n    end\n\n    render json: result\n  end\n\n  def confirm_admin\n    @confirmation = AdminConfirmation.find_by_code(params[:token])\n\n    raise Discourse::NotFound unless @confirmation\n    raise Discourse::InvalidAccess.new unless\n      @confirmation.performed_by.id == (current_user&.id || @confirmation.performed_by.id)\n\n    if request.post?\n      @confirmation.email_confirmed!\n      @confirmed = true\n    end\n\n    respond_to do |format|\n      format.json { render json: success_json }\n      format.html { render layout: 'no_ember' }\n    end\n  end\n\n  def list_second_factors\n    raise Discourse::NotFound if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n\n    unless params[:password].empty?\n      RateLimiter.new(nil, \"login-hr-#{request.remote_ip}\", SiteSetting.max_logins_per_ip_per_hour, 1.hour).performed!\n      RateLimiter.new(nil, \"login-min-#{request.remote_ip}\", SiteSetting.max_logins_per_ip_per_minute, 1.minute).performed!\n      unless current_user.confirm_password?(params[:password])\n        return render json: failed_json.merge(\n                        error: I18n.t(\"login.incorrect_password\")\n                      )\n      end\n      confirm_secure_session\n    end\n\n    if secure_session_confirmed?\n      totp_second_factors = current_user.totps\n        .select(:id, :name, :last_used, :created_at, :method)\n        .where(enabled: true).order(:created_at)\n\n      security_keys = current_user.security_keys.where(factor_type: UserSecurityKey.factor_types[:second_factor]).order(:created_at)\n\n      render json: success_json.merge(\n               totps: totp_second_factors,\n               security_keys: security_keys\n             )\n    else\n      render json: success_json.merge(\n               password_required: true\n             )\n    end\n  end\n\n  def create_second_factor_backup\n    backup_codes = current_user.generate_backup_codes\n\n    render json: success_json.merge(\n      backup_codes: backup_codes\n    )\n  end\n\n  def create_second_factor_totp\n    require 'rotp' if !defined? ROTP\n    totp_data = ROTP::Base32.random\n    secure_session[\"staged-totp-#{current_user.id}\"] = totp_data\n    qrcode_png = RQRCode::QRCode.new(current_user.totp_provisioning_uri(totp_data)).as_png(\n      border_modules: 1,\n      size: 240\n    )\n\n    render json: success_json.merge(\n             key: totp_data.scan(/.{4}/).join(\" \"),\n             qr: qrcode_png.to_data_url\n           )\n  end\n\n  def create_second_factor_security_key\n    challenge_session = Webauthn.stage_challenge(current_user, secure_session)\n    render json: success_json.merge(\n      challenge: challenge_session.challenge,\n      rp_id: challenge_session.rp_id,\n      rp_name: challenge_session.rp_name,\n      supported_algorithms: ::Webauthn::SUPPORTED_ALGORITHMS,\n      user_secure_id: current_user.create_or_fetch_secure_identifier,\n      existing_active_credential_ids: current_user.second_factor_security_key_credential_ids\n    )\n  end\n\n  def register_second_factor_security_key\n    params.require(:name)\n    params.require(:attestation)\n    params.require(:clientData)\n\n    ::Webauthn::SecurityKeyRegistrationService.new(\n      current_user,\n      params,\n      challenge: Webauthn.challenge(current_user, secure_session),\n      rp_id: Webauthn.rp_id(current_user, secure_session),\n      origin: Discourse.base_url\n    ).register_second_factor_security_key\n    render json: success_json\n  rescue ::Webauthn::SecurityKeyError => err\n    render json: failed_json.merge(error: err.message)\n  end\n\n  def update_security_key\n    user_security_key = current_user.security_keys.find_by(id: params[:id].to_i)\n    raise Discourse::InvalidParameters unless user_security_key\n\n    if params[:name] && !params[:name].blank?\n      user_security_key.update!(name: params[:name])\n    end\n    if params[:disable] == \"true\"\n      user_security_key.update!(enabled: false)\n    end\n\n    render json: success_json\n  end\n\n  def enable_second_factor_totp\n    if params[:second_factor_token].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_code\"))\n    end\n    if params[:name].blank?\n      return render json: failed_json.merge(error: I18n.t(\"login.missing_second_factor_name\"))\n    end\n    auth_token = params[:second_factor_token]\n\n    totp_data = secure_session[\"staged-totp-#{current_user.id}\"]\n    totp_object = current_user.get_totp_object(totp_data)\n\n    rate_limit_second_factor!(current_user)\n\n    authenticated = !auth_token.blank? && totp_object.verify(\n      auth_token,\n      drift_ahead: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS,\n      drift_behind: SecondFactorManager::TOTP_ALLOWED_DRIFT_SECONDS\n    )\n    unless authenticated\n      return render json: failed_json.merge(\n                      error: I18n.t(\"login.invalid_second_factor_code\")\n                    )\n    end\n    current_user.create_totp(data: totp_data, name: params[:name], enabled: true)\n    render json: success_json\n  end\n\n  def disable_second_factor\n    # delete all second factors for a user\n    current_user.user_second_factors.destroy_all\n    current_user.security_keys.destroy_all\n\n    Jobs.enqueue(\n      :critical_user_email,\n      type: :account_second_factor_disabled,\n      user_id: current_user.id\n    )\n\n    render json: success_json\n  end\n\n  def update_second_factor\n    params.require(:second_factor_target)\n    update_second_factor_method = params[:second_factor_target].to_i\n\n    if update_second_factor_method == UserSecondFactor.methods[:totp]\n      params.require(:id)\n      second_factor_id = params[:id].to_i\n      user_second_factor = current_user.user_second_factors.totps.find_by(id: second_factor_id)\n    elsif update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n      user_second_factor = current_user.user_second_factors.backup_codes\n    end\n\n    raise Discourse::InvalidParameters unless user_second_factor\n\n    if params[:name] && !params[:name].blank?\n      user_second_factor.update!(name: params[:name])\n    end\n    if params[:disable] == \"true\"\n      # Disabling backup codes deletes *all* backup codes\n      if update_second_factor_method == UserSecondFactor.methods[:backup_codes]\n        current_user.user_second_factors.where(method: UserSecondFactor.methods[:backup_codes]).destroy_all\n      else\n        user_second_factor.update!(enabled: false)\n      end\n\n    end\n\n    render json: success_json\n  end\n\n  def second_factor_check_confirmed_password\n    raise Discourse::NotFound if SiteSetting.enable_discourse_connect || !SiteSetting.enable_local_logins\n\n    raise Discourse::InvalidAccess.new unless current_user && secure_session_confirmed?\n  end\n\n  def revoke_account\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    provider_name = params.require(:provider_name)\n\n    # Using Discourse.authenticators rather than Discourse.enabled_authenticators so users can\n    # revoke permissions even if the admin has temporarily disabled that type of login\n    authenticator = Discourse.authenticators.find { |a| a.name == provider_name }\n    raise Discourse::NotFound if authenticator.nil? || !authenticator.can_revoke?\n\n    skip_remote = params.permit(:skip_remote)\n\n    # We're likely going to contact the remote auth provider, so hijack request\n    hijack do\n      DiscourseEvent.trigger(:before_auth_revoke, authenticator, user)\n      result = authenticator.revoke(user, skip_remote: skip_remote)\n      if result\n        render json: success_json\n      else\n        render json: {\n          success: false,\n          message: I18n.t(\"associated_accounts.revoke_failed\", provider_name: provider_name)\n        }\n      end\n    end\n  end\n\n  def revoke_auth_token\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    if params[:token_id]\n      token = UserAuthToken.find_by(id: params[:token_id], user_id: user.id)\n      # The user should not be able to revoke the auth token of current session.\n      raise Discourse::InvalidParameters.new(:token_id) if !token || guardian.auth_token == token.auth_token\n      UserAuthToken.where(id: params[:token_id], user_id: user.id).each(&:destroy!)\n\n      MessageBus.publish \"/file-change\", [\"refresh\"], user_ids: [user.id]\n    else\n      UserAuthToken.where(user_id: user.id).each(&:destroy!)\n    end\n\n    render json: success_json\n  end\n\n  def feature_topic\n    user = fetch_user_from_params\n    topic = Topic.find(params[:topic_id].to_i)\n\n    if !guardian.can_feature_topic?(user, topic)\n      return render_json_error(I18n.t('activerecord.errors.models.user_profile.attributes.featured_topic_id.invalid'), 403)\n    end\n\n    user.user_profile.update(featured_topic_id: topic.id)\n    render json: success_json\n  end\n\n  def clear_featured_topic\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n    user.user_profile.update(featured_topic_id: nil)\n    render json: success_json\n  end\n\n  def bookmarks\n    user = fetch_user_from_params\n    guardian.ensure_can_edit!(user)\n\n    respond_to do |format|\n      format.json do\n        bookmark_list = UserBookmarkList.new(user: user, guardian: guardian, params: params)\n        bookmark_list.load\n\n        if bookmark_list.bookmarks.empty?\n          render json: {\n            bookmarks: []\n          }\n        else\n          page = params[:page].to_i + 1\n          bookmark_list.more_bookmarks_url = \"#{Discourse.base_path}/u/#{params[:username]}/bookmarks.json?page=#{page}\"\n          render_serialized(bookmark_list, UserBookmarkListSerializer)\n        end\n      end\n      format.ics do\n        @bookmark_reminders = Bookmark.with_reminders\n          .where(user_id: user.id)\n          .includes(:topic)\n          .order(:reminder_at)\n      end\n    end\n  end\n\n  private\n\n  def clean_custom_field_values(field)\n    field_values = params[:user_fields][field.id.to_s]\n\n    return field_values if field_values.nil? || field_values.empty?\n\n    if field.field_type == \"dropdown\"\n      field.user_field_options.find_by_value(field_values)&.value\n    elsif field.field_type == \"multiselect\"\n      field_values = Array.wrap(field_values)\n      bad_values = field_values - field.user_field_options.map(&:value)\n      field_values - bad_values\n    else\n      field_values\n    end\n  end\n\n  def password_reset_find_user(token, committing_change:)\n    @user = if committing_change\n      EmailToken.confirm(token, scope: EmailToken.scopes[:password_reset])\n    else\n      EmailToken.confirmable(token, scope: EmailToken.scopes[:password_reset])&.user\n    end\n\n    if @user\n      secure_session[\"password-#{token}\"] = @user.id\n    else\n      user_id = secure_session[\"password-#{token}\"].to_i\n      @user = User.find(user_id) if user_id > 0\n    end\n\n    @error = I18n.t('password_reset.no_token') if !@user\n  end\n\n  def respond_to_suspicious_request\n    if suspicious?(params)\n      render json: {\n        success: true,\n        active: false,\n        message: I18n.t(\"login.activate_email\", email: params[:email])\n      }\n    end\n  end\n\n  def suspicious?(params)\n    return false if current_user && is_api? && current_user.admin?\n    honeypot_or_challenge_fails?(params) || SiteSetting.invite_only?\n  end\n\n  def honeypot_or_challenge_fails?(params)\n    return false if is_api?\n    params[:password_confirmation] != honeypot_value ||\n    params[:challenge] != challenge_value.try(:reverse)\n  end\n\n  def user_params\n    permitted = [\n      :name,\n      :email,\n      :password,\n      :username,\n      :title,\n      :date_of_birth,\n      :muted_usernames,\n      :allowed_pm_usernames,\n      :theme_ids,\n      :locale,\n      :bio_raw,\n      :location,\n      :website,\n      :dismissed_banner_key,\n      :profile_background_upload_url,\n      :card_background_upload_url,\n      :primary_group_id,\n      :flair_group_id,\n      :featured_topic_id\n    ]\n\n    editable_custom_fields = User.editable_user_custom_fields(by_staff: current_user.try(:staff?))\n    permitted << { custom_fields: editable_custom_fields } unless editable_custom_fields.blank?\n    permitted.concat UserUpdater::OPTION_ATTR\n    permitted.concat UserUpdater::CATEGORY_IDS.keys.map { |k| { k => [] } }\n    permitted.concat UserUpdater::TAG_NAMES.keys\n    permitted << UserUpdater::NOTIFICATION_SCHEDULE_ATTRS\n\n    result = params\n      .permit(permitted, theme_ids: [])\n      .reverse_merge(\n        ip_address: request.remote_ip,\n        registration_ip_address: request.remote_ip\n      )\n\n    if !UsernameCheckerService.is_developer?(result['email']) &&\n        is_api? &&\n        current_user.present? &&\n        current_user.admin?\n\n      result.merge!(params.permit(:active, :staged, :approved))\n    end\n\n    modify_user_params(result)\n  end\n\n  # Plugins can use this to modify user parameters\n  def modify_user_params(attrs)\n    attrs\n  end\n\n  def fail_with(key)\n    render json: { success: false, message: I18n.t(key) }\n  end\n\n  def track_visit_to_user_profile\n    user_profile_id = @user.user_profile.id\n    ip = request.remote_ip\n    user_id = (current_user.id if current_user)\n\n    Scheduler::Defer.later 'Track profile view visit' do\n      UserProfileView.add(user_profile_id, ip, user_id)\n    end\n  end\n\n  def clashing_with_existing_route?(username)\n    normalized_username = User.normalize_username(username)\n    http_verbs = %w[GET POST PUT DELETE PATCH]\n    allowed_actions = %w[show update destroy]\n\n    http_verbs.any? do |verb|\n      begin\n        path = Rails.application.routes.recognize_path(\"/u/#{normalized_username}\", method: verb)\n        allowed_actions.exclude?(path[:action])\n      rescue ActionController::RoutingError\n        false\n      end\n    end\n  end\n\n  def confirm_secure_session\n    secure_session[\"confirmed-password-#{current_user.id}\"] = \"true\"\n  end\n\n  def secure_session_confirmed?\n    secure_session[\"confirmed-password-#{current_user.id}\"] == \"true\"\n  end\n\n  def summary_cache_key(user)\n    \"user_summary:#{user.id}:#{current_user ? current_user.id : 0}\"\n  end\n\n  def render_invite_error(message)\n    render json: {\n      invites: [],\n      can_see_invite_details: false,\n      error: message\n    }\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'rotp'\n\ndescribe UsersController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user1) { Fabricate(:user) }\n  fab!(:another_user) { Fabricate(:user) }\n  fab!(:invitee) { Fabricate(:user) }\n  fab!(:inviter) { Fabricate(:user) }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:inactive_user) { Fabricate(:inactive_user) }\n\n  # Unfortunately, there are tests that depend on the user being created too\n  # late for fab! to work.\n  let(:user_deferred) { Fabricate(:user) }\n\n  describe \"#full account registration flow\" do\n    it \"will correctly handle honeypot and challenge\" do\n\n      get '/session/hp.json'\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      params = {\n        email: 'jane@jane.com',\n        name: 'jane',\n        username: 'jane',\n        password_confirmation: json['value'],\n        challenge: json['challenge'].reverse,\n        password: SecureRandom.hex\n      }\n\n      secure_session = SecureSession.new(session[\"secure_session_id\"])\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(json[\"value\"])\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(json[\"challenge\"])\n\n      post '/u.json', params: params\n\n      expect(response.status).to eq(200)\n\n      jane = User.find_by(username: 'jane')\n\n      expect(jane.email).to eq('jane@jane.com')\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(nil)\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(nil)\n    end\n  end\n\n  describe '#perform_account_activation' do\n    let(:email_token) { Fabricate(:email_token, user: user_deferred) }\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false)\n    end\n\n    context 'invalid token' do\n      it 'return success' do\n        put \"/u/activate-account/invalid-tooken\"\n        expect(response.status).to eq(200)\n        expect(flash[:error]).to be_present\n      end\n    end\n\n    context 'valid token' do\n      context 'welcome message' do\n        it 'enqueues a welcome message if the user object indicates so' do\n          SiteSetting.send_welcome_message = true\n          user_deferred.update(active: false)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(Jobs::SendSystemMessage.jobs.first[\"args\"].first[\"message_type\"]).to eq(\"welcome_user\")\n        end\n\n        it \"doesn't enqueue the welcome message if the object returns false\" do\n          user_deferred.update(active: true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n        end\n      end\n\n      context \"honeypot\" do\n        it \"raises an error if the honeypot is invalid\" do\n          UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'response' do\n        it 'correctly logs on user' do\n          email_token\n\n          events = DiscourseEvent.track_events do\n            put \"/u/activate-account/#{email_token.token}\"\n          end\n\n          expect(events.map { |event| event[:event_name] }).to contain_exactly(\n            :user_confirmed_email, :user_first_logged_in, :user_logged_in\n          )\n\n          expect(response.status).to eq(200)\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_present\n\n          expect(CGI.unescapeHTML(response.body))\n            .to_not include(I18n.t('activation.approval_required'))\n        end\n      end\n\n      context 'user is not approved' do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it 'should return the right response' do\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n\n          expect(CGI.unescapeHTML(response.body))\n            .to include(I18n.t('activation.approval_required'))\n\n          expect(response.body).to_not have_tag(:script, with: {\n            src: '/assets/application.js'\n          })\n\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_blank\n        end\n      end\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n  end\n\n  describe '#password_reset' do\n    let(:token) { SecureRandom.hex }\n\n    context \"you can view it even if login is required\" do\n      it \"returns success\" do\n        SiteSetting.login_required = true\n        get \"/u/password-reset/#{token}\"\n        expect(response.status).to eq(200)\n        expect(CGI.unescapeHTML(response.body)).to include(I18n.t('password_reset.no_token'))\n      end\n    end\n\n    context 'missing token' do\n      it 'disallows login' do\n        get \"/u/password-reset/#{token}\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        get \"/u/password-reset/#{token}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'invalid token' do\n      it 'disallows login' do\n        get \"/u/password-reset/ev!l_trout@!\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        put \"/u/password-reset/evil_trout!.json\", params: { password: \"awesomeSecretPassword\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'valid token' do\n      let!(:user_auth_token) { UserAuthToken.generate!(user_id: user1.id) }\n      let!(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      context 'when rendered' do\n        it 'renders referrer never on get requests' do\n          get \"/u/password-reset/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(response.body).to include('<meta name=\"referrer\" content=\"never\">')\n        end\n      end\n\n      it 'returns success' do\n        events = DiscourseEvent.track_events do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98o' }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to contain_exactly(\n          :user_logged_in, :user_first_logged_in, :user_confirmed_email\n        )\n\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":false,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n        end\n\n        expect(session[\"password-#{email_token.token}\"]).to be_blank\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(0)\n      end\n\n      it 'disallows double password reset' do\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yHG32O' }\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'test123987AsdfXYZ' }\n        expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(true)\n        expect(user1.user_auth_tokens.count).to eq(1)\n      end\n\n      it \"doesn't redirect to wizard on get\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response).not_to redirect_to(wizard_path)\n      end\n\n      it \"redirects to the wizard if you're the first admin\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}\"\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        expect(response).to redirect_to(wizard_path)\n      end\n\n      it \"sets the users timezone if the param is present\" do\n        get \"/u/password-reset/#{email_token.token}\"\n        expect(user1.user_option.timezone).to eq(nil)\n\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger', timezone: \"America/Chicago\" }\n        expect(user1.user_option.reload.timezone).to eq(\"America/Chicago\")\n      end\n\n      it \"logs the password change\" do\n        get \"/u/password-reset/#{email_token.token}\"\n\n        expect do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        end.to change { UserHistory.count }.by (1)\n\n        user_history = UserHistory.last\n        expect(user_history.target_user_id).to eq(user1.id)\n        expect(user_history.action).to eq(UserHistory.actions[:change_password])\n      end\n\n      it \"doesn't invalidate the token when loading the page\" do\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response.status).to eq(200)\n        expect(email_token.reload.confirmed).to eq(false)\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(1)\n      end\n\n      context \"rate limiting\" do\n        before { RateLimiter.clear_all!; RateLimiter.enable }\n\n        it \"rate limits reset passwords\" do\n          freeze_time\n\n          6.times do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"rate limits reset passwords by username\" do\n          freeze_time\n\n          6.times do |x|\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\" }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }, env: { \"REMOTE_ADDR\": \"1.2.3.4\" }\n\n          expect(response.status).to eq(429)\n        end\n      end\n\n      context '2 factor authentication required' do\n        fab!(:second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n        it 'does not change with an invalid token' do\n          user1.user_auth_tokens.destroy_all\n\n          get \"/u/password-reset/#{email_token.token}\"\n\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":true,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: '000000',\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          expect(response.body).to include(I18n.t(\"login.invalid_second_factor_code\"))\n\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).not_to eq(true)\n          expect(user1.user_auth_tokens.count).not_to eq(1)\n        end\n\n        it 'changes password with valid 2-factor tokens' do\n          get \"/u/password-reset/#{email_token.token}\"\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: ROTP::TOTP.new(second_factor.data).now,\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          user1.reload\n          expect(response.status).to eq(200)\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n      end\n\n      context 'security key authentication required' do\n        let!(:user_security_key) do\n          Fabricate(\n            :user_security_key,\n            user: user1,\n            credential_id: valid_security_key_data[:credential_id],\n            public_key: valid_security_key_data[:public_key]\n          )\n        end\n\n        before do\n          simulate_localhost_webauthn_challenge\n\n          # store challenge in secure session by visiting the email login page\n          get \"/u/password-reset/#{email_token.token}\"\n        end\n\n        it 'preloads with a security key challenge and allowed credential ids' do\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            password_reset = JSON.parse(json['password_reset'])\n            expect(password_reset['challenge']).not_to eq(nil)\n            expect(password_reset['allowed_credential_ids']).to eq([user_security_key.credential_id])\n            expect(password_reset['security_key_required']).to eq(true)\n          end\n        end\n\n        it 'stages a webauthn challenge and rp-id for the user' do\n          secure_session = SecureSession.new(session[\"secure_session_id\"])\n          expect(Webauthn.challenge(user1, secure_session)).not_to eq(nil)\n          expect(Webauthn.rp_id(user1, secure_session)).to eq(Discourse.current_hostname)\n        end\n\n        it 'changes password with valid security key challenge and authentication' do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: valid_security_key_auth_post_data,\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n\n        it \"does not change a password if a fake TOTP token is provided\" do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: 'blah',\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n        end\n\n        context \"when security key authentication fails\" do\n          it 'shows an error message and does not change password' do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              password: 'hg9ow8yHG32O',\n              second_factor_token: {\n                signature: 'bad',\n                clientData: 'bad',\n                authenticatorData: 'bad',\n                credentialId: 'bad'\n              },\n              second_factor_method: UserSecondFactor.methods[:security_key]\n            }\n\n            expect(response.status).to eq(200)\n            expect(response.body).to include(I18n.t(\"webauthn.validation.not_found_error\"))\n            expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n          end\n        end\n      end\n    end\n\n    context 'submit change' do\n      let(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      it \"fails when the password is blank\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: '' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"fails when the password is too long\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: ('x' * (User.max_password_length + 1)) }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"logs in the user\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"doesn't log in the user when not approved\" do\n        SiteSetting.must_approve_users = true\n        user1.update!(approved: false)\n\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n  end\n\n  describe '#confirm_email_token' do\n    let!(:email_token) { Fabricate(:email_token, user: user1) }\n\n    it \"token doesn't match any records\" do\n      get \"/u/confirm-email-token/#{SecureRandom.hex}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(false)\n    end\n\n    it \"token matches\" do\n      get \"/u/confirm-email-token/#{email_token.token}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(true)\n    end\n  end\n\n  describe '#admin_login' do\n    context 'enqueues mail' do\n      it 'enqueues mail with admin email and sso enabled' do\n        put \"/u/admin-login\", params: { email: admin.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"user_id\"]).to eq(admin.id)\n      end\n    end\n\n    context 'when email is incorrect' do\n      it 'should return the right response' do\n        put \"/u/admin-login\", params: { email: 'random' }\n\n        expect(response.status).to eq(200)\n\n        response_body = response.body\n\n        expect(response_body).to match(I18n.t(\"admin_login.errors.unknown_email_address\"))\n        expect(response_body).to_not match(I18n.t(\"login.second_factor_description\"))\n      end\n    end\n  end\n\n  describe '#toggle_anon' do\n    it 'allows you to toggle anon if enabled' do\n      SiteSetting.allow_anonymous_posting = true\n\n      user = sign_in(Fabricate(:user))\n      user.trust_level = 1\n      user.save!\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(AnonymousShadowCreator.get(user).id)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(user.id)\n    end\n  end\n\n  describe '#create' do\n    def honeypot_magic(params)\n      get '/session/hp.json'\n      json = response.parsed_body\n      params[:password_confirmation] = json[\"value\"]\n      params[:challenge] = json[\"challenge\"].reverse\n      params\n    end\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n      SiteSetting.allow_new_registrations = true\n      @user = Fabricate.build(:user, email: \"foobar@example.com\", password: \"strongpassword\")\n    end\n\n    let(:post_user_params) do\n      { name: @user.name,\n        username: @user.username,\n        password: \"strongpassword\",\n        email: @user.email }\n    end\n\n    def post_user(extra_params = {})\n      post \"/u.json\", params: post_user_params.merge(extra_params)\n    end\n\n    context 'when email params is missing' do\n      it 'should raise the right error' do\n        post \"/u.json\", params: {\n          name: @user.name,\n          username: @user.username,\n          password: 'testing12352343'\n        }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when creating a user' do\n      it 'sets the user locale to I18n.locale' do\n        SiteSetting.default_locale = 'en'\n        I18n.stubs(:locale).returns(:fr)\n        post_user\n        expect(User.find_by(username: @user.username).locale).to eq('fr')\n      end\n\n      it 'requires invite code when specified' do\n        expect(SiteSetting.require_invite_code).to eq(false)\n        SiteSetting.invite_code = \"abc def\"\n        expect(SiteSetting.require_invite_code).to eq(true)\n\n        post_user(invite_code: \"abcd\")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n\n        # case insensitive and stripped of leading/ending spaces\n        post_user(invite_code: \" AbC deF \")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n      end\n\n      context \"when timezone is provided as a guess on signup\" do\n\n        it \"sets the timezone\" do\n          post_user(timezone: \"Australia/Brisbane\")\n          expect(response.status).to eq(200)\n          expect(User.find_by(username: @user.username).user_option.timezone).to eq(\"Australia/Brisbane\")\n        end\n      end\n\n      context \"with local logins disabled\" do\n        before do\n          SiteSetting.enable_local_logins = false\n          SiteSetting.enable_google_oauth2_logins = true\n        end\n\n        it \"blocks registration without authenticator information\" do\n          post_user\n          expect(response.status).to eq(403)\n        end\n\n        it \"blocks with a regular api key\" do\n          api_key = Fabricate(:api_key, user: user1)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(403)\n        end\n\n        it \"works with an admin api key\" do\n          api_key = Fabricate(:api_key, user: admin)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    context 'when creating a non active user (unconfirmed email)' do\n      it 'returns 403 forbidden when local logins are disabled' do\n        SiteSetting.enable_local_logins = false\n        post_user\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      it 'creates a user correctly' do\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n        expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"type\"]).to eq(\"signup\")\n      end\n\n      context \"`must approve users` site setting is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it 'creates a user correctly' do\n          post_user\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body['active']).to be_falsey\n\n          # should save user_created_message in session\n          expect(session[\"user_created_message\"]).to be_present\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n          args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n          expect(args[\"type\"]).to eq(\"signup\")\n        end\n      end\n\n      context 'users already exists with given email' do\n        let!(:existing) { Fabricate(:user, email: post_user_params[:email]) }\n\n        it 'returns an error if hide_email_address_taken is disabled' do\n          SiteSetting.hide_email_address_taken = false\n\n          post_user\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it 'returns success if hide_email_address_taken is enabled' do\n          SiteSetting.hide_email_address_taken = true\n          expect {\n            post_user\n          }.to_not change { User.count }\n\n          expect(response.status).to eq(200)\n          expect(session[\"user_created_message\"]).to be_present\n\n          json = response.parsed_body\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n\n          existing.destroy!\n          expect {\n            post_user\n          }.to change { User.count }\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n        end\n      end\n    end\n\n    context \"creating as active\" do\n      it \"won't create the user as active\" do\n        post \"/u.json\", params: post_user_params.merge(active: true)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as active with a regular key\" do\n          post \"/u.json\",\n            params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsey\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        it \"creates the user as active with a an admin key\" do\n          SiteSetting.send_welcome_message = true\n          SiteSetting.must_approve_users = true\n\n          #Sidekiq::Client.expects(:enqueue).never\n          post \"/u.json\", params: post_user_params.merge(approved: true, active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_truthy\n          new_user = User.find(response.parsed_body[\"user_id\"])\n          expect(new_user.active).to eq(true)\n          expect(new_user.approved).to eq(true)\n          expect(new_user.approved_by_id).to eq(admin.id)\n          expect(new_user.approved_at).to_not eq(nil)\n          expect(new_user.email_tokens.where(confirmed: true, email: new_user.email)).to exist\n        end\n\n        it \"will create a reviewable when a user is created as active but not approved\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_present\n        end\n\n        it \"won't create a reviewable when a user is not active\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to eq(false)\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n\n        it \"won't create the developer as active\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsy\n        end\n\n        it \"won't set the new user's locale to the admin's locale\" do\n          SiteSetting.allow_user_locale = true\n          admin.update!(locale: :fr)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          new_user = User.find(json[\"user_id\"])\n          expect(new_user.locale).not_to eq(\"fr\")\n        end\n\n        it \"will auto approve user if the user email domain matches auto_approve_email_domains setting\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n          SiteSetting.auto_approve_email_domains = \"example.com\"\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to be_truthy\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n      end\n    end\n\n    context \"creating as staged\" do\n      it \"won't create the user as staged\" do\n        post \"/u.json\", params: post_user_params.merge(staged: true)\n        expect(response.status).to eq(200)\n        new_user = User.where(username: post_user_params[:username]).first\n        expect(new_user.staged?).to eq(false)\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:user) { admin }\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }\n\n        it \"creates the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(true)\n        end\n\n        it \"won't create the developer as staged\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n    end\n\n    context 'when creating an active user (confirmed email)' do\n      before { User.any_instance.stubs(:active?).returns(true) }\n\n      it 'enqueues a welcome email' do\n        User.any_instance.expects(:enqueue_welcome_message).with('welcome_user')\n\n        post_user\n        expect(response.status).to eq(200)\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n      end\n\n      it \"shows the 'active' message\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(\n          I18n.t 'login.active'\n        )\n      end\n\n      it \"should be logged in\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it 'indicates the user is active in the response' do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_truthy\n      end\n\n      it 'doesn\\'t succeed when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      context 'authentication records for' do\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              email: \"osama@mail.com\",\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it 'should create twitter user info if required' do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          expect(UserAssociatedAccount.where(provider_name: \"twitter\").count).to eq(1)\n        end\n\n        it \"returns an error when email has been changed from the validated email address\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"unvalidatedemail@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it \"will create the user successfully if email validation is required\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n\n        it \"doesn't use provided username/name if sso_overrides is enabled\" do\n          SiteSetting.auth_overrides_username = true\n          SiteSetting.auth_overrides_name = true\n          post \"/u.json\", params: {\n            username: \"attemptednewname\",\n            name: \"Attempt At New Name\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n\n          user = User.last\n\n          expect(user.username).to eq('testosama')\n          expect(user.name).to eq('Osama Test')\n        end\n\n      end\n\n      context \"with no email in the auth payload\" do\n        before do\n          OmniAuth.config.test_mode = true\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"will create the user successfully\" do\n          Rails.application.env_config[\"omniauth.auth\"].info.email = nil\n\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n      end\n    end\n\n    it \"creates user successfully but doesn't activate the account\" do\n      post_user\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"success\"]).to eq(true)\n      expect(User.find_by(username: @user.username).active).to eq(false)\n    end\n\n    shared_examples 'honeypot fails' do\n      it 'should not create a new user' do\n        User.any_instance.expects(:enqueue_welcome_message).never\n\n        expect {\n          post \"/u.json\", params: create_params\n        }.to_not change { User.count }\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when honeypot value is wrong' do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, password_confirmation: 'wrong' } }\n      include_examples 'honeypot fails'\n    end\n\n    context 'when challenge answer is wrong' do\n      before do\n        UsersController.any_instance.stubs(:challenge_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, challenge: 'abc' } }\n      include_examples 'honeypot fails'\n    end\n\n    context \"when 'invite only' setting is enabled\" do\n      before { SiteSetting.invite_only = true }\n\n      let(:create_params) { {\n        name: @user.name,\n        username: @user.username,\n        password: 'strongpassword',\n        email: @user.email\n      }}\n\n      include_examples 'honeypot fails'\n    end\n\n    shared_examples 'failed signup' do\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(200)\n      end\n\n      it 'should report failed' do\n        post \"/u.json\", params: create_params\n        json = response.parsed_body\n        expect(json[\"success\"]).not_to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when password is blank' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"\", email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password is too long' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"x\" * (User.max_password_length + 1), email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password param is missing' do\n      let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a reserved username' do\n      let(:create_params) { { name: @user.name, username: 'Reserved', email: @user.email, password: 'strongpassword' } }\n      before { SiteSetting.reserved_usernames = 'a|reserved|b' }\n      include_examples 'failed signup'\n    end\n\n    context 'with a username that matches a user route' do\n      let(:create_params) { { name: @user.name, username: 'account-created', email: @user.email, password: 'strongpassword' } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a missing username' do\n      let(:create_params) { { name: @user.name, email: @user.email, password: \"x\" * 20 } }\n\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when an Exception is raised' do\n      before { User.any_instance.stubs(:save).raises(ActiveRecord::StatementInvalid.new('Oh no')) }\n\n      let(:create_params) {\n        { name: @user.name, username: @user.username,\n          password: \"strongpassword\", email: @user.email }\n      }\n\n      include_examples 'failed signup'\n    end\n\n    context \"with custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field) }\n      fab!(:another_field) { Fabricate(:user_field) }\n      fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n      context \"without a value for the fields\" do\n        let(:create_params) { { name: @user.name, password: 'watwatwat', username: @user.username, email: @user.email } }\n        include_examples 'failed signup'\n      end\n\n      context \"with values for the fields\" do\n        let(:update_user_url) { \"/u/#{user1.username}.json\" }\n        let(:field_id) { user_field.id.to_s }\n\n        before { sign_in(user1) }\n\n        context \"with multple select fields\" do\n          let(:valid_options) { %w[Axe Sword] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'multiselect') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Axe'),\n                  Fabricate(:user_field_option, value: 'Sword')\n                ]\n              end\n            end\n          end\n\n          it \"should allow single values and not just arrays\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Axe' } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to('Axe')\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from('Axe').to(%w[Axe Sword])\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Juice] } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"should filter valid values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"value can't be nil or empty if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can nil or empty if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options).to(nil)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"\")\n          end\n\n        end\n\n        context \"with dropdown fields\" do\n          let(:valid_options) { ['Black Mesa', 'Fox Hound'] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'dropdown') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Black Mesa'),\n                  Fabricate(:user_field_option, value: 'Fox Hound')\n                ]\n              end\n            end\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Umbrella Corporation' } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options.first)\n          end\n\n          it \"value can't be nil if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can be set to nil if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options.last } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options.last).to(nil)\n          end\n        end\n\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n          user_fields: {\n            user_field.id.to_s => 'value1',\n            another_field.id.to_s => 'value2',\n          }\n        } }\n\n        it \"should succeed without the optional field\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to be_blank\n        end\n\n        it \"should succeed with the optional field\" do\n          create_params[:user_fields][optional_field.id.to_s] = 'value3'\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value3')\n        end\n\n        it \"trims excessively long fields\" do\n          create_params[:user_fields][optional_field.id.to_s] = ('x' * 3000)\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n\n          val = inserted.custom_fields[\"user_field_#{optional_field.id}\"]\n          expect(val.length).to eq(UserField.max_length)\n        end\n      end\n    end\n\n    context \"with only optional custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field, required: false) }\n\n      context \"without values for the fields\" do\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n        } }\n\n        it \"should succeed\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).not_to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to be_blank\n        end\n      end\n    end\n\n    context \"when taking over a staged account\" do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        UsersController.any_instance.stubs(:challenge_value).returns(\"efg\")\n        SessionController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        SessionController.any_instance.stubs(:challenge_value).returns(\"efg\")\n      end\n\n      fab!(:staged) { Fabricate(:staged, email: \"staged@account.com\", active: true) }\n\n      it \"succeeds\" do\n        post '/u.json', params: honeypot_magic(\n          email: staged.email,\n          username: \"zogstrip\",\n          password: \"P4ssw0rd$$\"\n        )\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        # do not allow emails changes please\n\n        put \"/u/update-activation-email.json\", params: { email: 'bob@bob.com' }\n\n        created_user.reload\n        expect(created_user.email).to eq(\"staged@account.com\")\n        expect(response.status).to eq(403)\n      end\n    end\n  end\n\n  describe '#username' do\n    it 'raises an error when not logged in' do\n      put \"/u/somename/preferences/username.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:old_username) { \"OrigUsername\" }\n      let(:new_username) { \"#{old_username}1234\" }\n      fab!(:user) { Fabricate(:user, username: \"OrigUsername\") }\n\n      before do\n        user.username = old_username\n        sign_in(user)\n      end\n\n      it 'raises an error without a new_username param' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { username: user.username }\n        expect(response.status).to eq(400)\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when you don\\'t have permission to change the username' do\n        Guardian.any_instance.expects(:can_edit_username?).with(user).returns(false)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when change_username fails' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: '@' }\n\n        expect(response.status).to eq(422)\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t(\n          'user.username.short', min: User.username_length.begin\n        ))\n\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should succeed in normal circumstances' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'raises an error when the username clashes with an existing user route' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'account-created' }\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'raises an error when the username is in the reserved list' do\n        SiteSetting.reserved_usernames = 'reserved'\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'reserved' }\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'should fail if the user is old' do\n        # Older than the change period and >1 post\n        user.created_at = Time.now - (SiteSetting.username_change_period + 1).days\n        PostCreator.new(user,\n          title: 'This is a test topic',\n          raw: 'This is a test this is a test'\n        ).create\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should create a staff action log when a staff member changes the username' do\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(UserHistory.where(action: UserHistory.actions[:change_username], target_user_id: user.id, acting_user_id: acting_user.id)).to be_present\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'should return a JSON response with the updated username' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.parsed_body['username']).to eq(new_username)\n      end\n\n      it 'should respond with proper error message if auth_overrides_username is enabled' do\n        SiteSetting.discourse_connect_url = 'http://someurl.com'\n        SiteSetting.enable_discourse_connect = true\n        SiteSetting.auth_overrides_username = true\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors'].first).to include(I18n.t('errors.messages.auth_overrides_username'))\n      end\n    end\n  end\n\n  describe '#check_username' do\n    it 'raises an error without any parameters' do\n      get \"/u/check_username.json\"\n      expect(response.status).to eq(400)\n    end\n\n    shared_examples 'when username is unavailable' do\n      it 'should return available as false in the JSON and return a suggested username' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(false)\n        expect(response.parsed_body['suggestion']).to be_present\n      end\n    end\n\n    shared_examples 'when username is available' do\n      it 'should return available in the JSON' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(true)\n      end\n    end\n\n    it 'returns nothing when given an email param but no username' do\n      get \"/u/check_username.json\", params: { email: 'dood@example.com' }\n      expect(response.status).to eq(200)\n    end\n\n    context 'username is available' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'BruceWayne' }\n      end\n      include_examples 'when username is available'\n    end\n\n    context 'username is unavailable' do\n      before do\n        get \"/u/check_username.json\", params: { username: user1.username }\n      end\n      include_examples 'when username is unavailable'\n    end\n\n    shared_examples 'checking an invalid username' do\n      it 'should not return an available key but should return an error message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(nil)\n        expect(response.parsed_body['errors']).to be_present\n      end\n    end\n\n    context 'has invalid characters' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'bad username' }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the invalid characters message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.characters'))\n      end\n    end\n\n    context 'is too long' do\n      before do\n        get \"/u/check_username.json\", params: { username: SecureRandom.alphanumeric(SiteSetting.max_username_length.to_i + 1) }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the \"too long\" message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.long', max: SiteSetting.max_username_length))\n      end\n    end\n\n    describe 'different case of existing username' do\n      context \"it's my username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(user)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is available'\n      end\n\n      context \"it's someone else's username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        fab!(:someone_else) { Fabricate(:user) }\n        before do\n          sign_in(someone_else)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is unavailable'\n      end\n\n      context \"an admin changing it for someone else\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(admin)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo', for_user_id: user.id }\n        end\n        include_examples 'when username is available'\n      end\n    end\n  end\n\n  describe '#check_email' do\n    it 'returns success if hide_email_address_taken is true' do\n      SiteSetting.hide_email_address_taken = true\n\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns success if email is empty' do\n      get \"/u/check_email.json\"\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns failure if email is not valid' do\n      get \"/u/check_email.json\", params: { email: \"invalid\" }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns failure if email exists' do\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"failed\"]).to be_present\n\n      get \"/u/check_email.json\", params: { email: user1.email.upcase }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns success if email does not exists' do\n      get \"/u/check_email.json\", params: { email: \"available@example.com\" }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'return success if user email is taken by staged user' do\n      get \"/u/check_email.json\", params: { email: Fabricate(:staged).email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n  end\n\n  describe '#invited' do\n    it 'fails for anonymous users' do\n      get \"/u/#{user1.username}/invited.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns success' do\n      user = Fabricate(:user, trust_level: 2)\n      Fabricate(:invite, invited_by: user)\n\n      sign_in(user)\n      get \"/u/#{user.username}/invited.json\", params: { username: user.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"counts\"][\"pending\"]).to eq(1)\n      expect(response.parsed_body[\"counts\"][\"total\"]).to eq(1)\n    end\n\n    it 'filters by all if viewing self' do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(inviter)\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites.first).to include('email' => 'billybob@example.com')\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"doesn't filter by email if another regular user\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(Fabricate(:user, trust_level: 2))\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(0)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"filters by email if staff\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(moderator)\n\n      invite_1 = Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      invitee_1 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_1, user: invitee_1)\n      invite_2 = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      invitee_2 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_2, user: invitee_2)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to include('id' => invitee_1.id)\n    end\n\n    context 'with guest' do\n      context 'with pending invites' do\n        it 'does not return invites' do\n          Fabricate(:invite, invited_by: inviter)\n\n          get \"/u/#{user1.username}/invited/pending.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invited_users' do\n          inviter = Fabricate(:user, trust_level: 2)\n          sign_in(inviter)\n          invite = Fabricate(:invite, invited_by: inviter)\n          invited_user = Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with pending invites' do\n        context 'with permission to see pending invites' do\n          it 'returns invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            invite = Fabricate(:invite, invited_by: inviter)\n            sign_in(inviter)\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"email\" => invite.email)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see pending invites' do\n          it 'does not return invites' do\n            user = sign_in(Fabricate(:user))\n            Fabricate(:invite, invited_by: inviter)\n            stub_guardian(user) do |guardian|\n              guardian.stubs(:can_see_invite_details?).\n                with(inviter).returns(false)\n            end\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(422)\n          end\n        end\n\n        context 'with permission to see invite links' do\n          it 'returns own invites' do\n            inviter = sign_in(Fabricate(:user, trust_level: 2))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n\n          it 'allows admin to see invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            admin = sign_in(Fabricate(:admin))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see invite links' do\n          it 'does not return invites' do\n            user = Fabricate(:user, trust_level: 2)\n            inviter = admin\n            Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(403)\n          end\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invites' do\n          sign_in(moderator)\n          invite = Fabricate(:invite, invited_by: inviter)\n          Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n  end\n\n  describe '#update' do\n    context 'with guest' do\n      it 'raises an error' do\n        put \"/u/guest.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    it \"does not allow name to be updated if auth auth_overrides_name is enabled\" do\n      SiteSetting.auth_overrides_name = true\n\n      sign_in(user1)\n\n      put \"/u/#{user1.username}\", params: { name: 'test.test' }\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.name).to_not eq('test.test')\n    end\n\n    context \"when username contains a period\" do\n      before do\n        sign_in(user)\n      end\n\n      fab!(:user) { Fabricate(:user, username: 'test.test', name: \"Test User\") }\n\n      it \"should be able to update a user\" do\n        put \"/u/#{user.username}\", params: { name: 'test.test' }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.name).to eq('test.test')\n      end\n    end\n\n    context \"as a staff user\" do\n      context \"uneditable field\" do\n        fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n        it \"allows staff to edit the field\" do\n          sign_in(admin)\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            title: \"foobar\",\n            user_fields: { user_field.id.to_s => 'happy' }\n          }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n          expect(user.title).to eq(\"foobar\")\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with permission to update' do\n        fab!(:upload) { Fabricate(:upload) }\n        fab!(:user) { Fabricate(:user) }\n\n        before do\n          sign_in(user)\n        end\n\n        it 'allows the update' do\n          SiteSetting.tagging_enabled = true\n          user2 = Fabricate(:user)\n          user3 = Fabricate(:user)\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            muted_usernames: \"#{user2.username},#{user3.username}\",\n            watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n            card_background_upload_url: upload.url,\n            profile_background_upload_url: upload.url\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['user']['watched_tags'].count).to eq(2)\n\n          user.reload\n\n          expect(user.name).to eq 'Jim Tom'\n          expect(user.muted_users.pluck(:username).sort).to eq [user2.username, user3.username].sort\n\n          expect(TagUser.where(\n            user: user,\n            notification_level: TagUser.notification_levels[:watching]\n          ).pluck(:tag_id)).to contain_exactly(tags[0].id, tags[1].id)\n\n          theme = Fabricate(:theme, user_selectable: true)\n\n          put \"/u/#{user.username}.json\", params: {\n            muted_usernames: \"\",\n            theme_ids: [theme.id],\n            email_level: UserOption.email_level_types[:always]\n          }\n\n          user.reload\n\n          expect(user.muted_users.pluck(:username).sort).to be_empty\n          expect(user.user_option.theme_ids).to eq([theme.id])\n          expect(user.user_option.email_level).to eq(UserOption.email_level_types[:always])\n          expect(user.profile_background_upload).to eq(upload)\n          expect(user.card_background_upload).to eq(upload)\n        end\n\n        it 'updates watched tags in everyone tag group' do\n          SiteSetting.tagging_enabled = true\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          group = Fabricate(:group, name: 'group', mentionable_level: Group::ALIAS_LEVELS[:everyone])\n          tag_group = Fabricate(:tag_group, tags: tags)\n          Fabricate(:tag_group_permission, tag_group: tag_group, group: group)\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\", params: {\n            watched_tags: \"#{tags[0].name},#{tag_synonym.name}\"\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['user']['watched_tags'].count).to eq(2)\n        end\n\n        context 'a locale is chosen that differs from I18n.locale' do\n          before do\n            SiteSetting.allow_user_locale = true\n          end\n\n          it \"updates the user's locale\" do\n            I18n.locale = :fr\n            put \"/u/#{user.username}.json\", params: { locale: :fa_IR }\n            expect(user.reload.locale).to eq('fa_IR')\n          end\n\n          it \"updates the title\" do\n            BadgeGranter.enable_queue\n            user.update!(locale: :fr)\n            user.change_trust_level!(TrustLevel[4])\n            BadgeGranter.process_queue!\n\n            leader_title = I18n.t(\"badges.leader.name\", locale: :fr)\n            put \"/u/#{user.username}.json\", params: { title: leader_title }\n            expect(user.reload.title).to eq(leader_title)\n          ensure\n            BadgeGranter.disable_queue\n            BadgeGranter.clear_queue!\n          end\n        end\n\n        context \"with user fields\" do\n          context \"an editable field\" do\n            fab!(:user_field) { Fabricate(:user_field) }\n            fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n            it \"should update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq 'happy'\n            end\n\n            it \"cannot be updated to blank\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => '' } }\n\n              expect(response.status).to eq(422)\n              expect(user.user_fields[user_field.id.to_s]).not_to eq('happy')\n            end\n\n            it \"trims excessively large fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => ('x' * 3000) } }\n\n              expect(user.user_fields[user_field.id.to_s].size).to eq(UserField.max_length)\n            end\n\n            it \"should retain existing user fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy', optional_field.id.to_s => 'feet' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'sad' } }\n\n              expect(response.status).to eq(200)\n\n              user.reload\n\n              expect(user.user_fields[user_field.id.to_s]).to eq('sad')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n            end\n          end\n\n          context \"with user_notification_schedule attributes\" do\n            it \"updates the user's notification schedule\" do\n              params = {\n                user_notification_schedule: {\n                  enabled: true,\n                  day_0_start_time: 30,\n                  day_0_end_time: 60,\n                  day_1_start_time: 30,\n                  day_1_end_time: 60,\n                  day_2_start_time: 30,\n                  day_2_end_time: 60,\n                  day_3_start_time: 30,\n                  day_3_end_time: 60,\n                  day_4_start_time: 30,\n                  day_4_end_time: 60,\n                  day_5_start_time: 30,\n                  day_5_end_time: 60,\n                  day_6_start_time: 30,\n                  day_6_end_time: 60,\n                }\n              }\n              put \"/u/#{user.username}.json\", params: params\n\n              user.reload\n              expect(user.user_notification_schedule.enabled).to eq(true)\n              expect(user.user_notification_schedule.day_0_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_0_end_time).to eq(60)\n              expect(user.user_notification_schedule.day_6_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_6_end_time).to eq(60)\n            end\n          end\n\n          context \"uneditable field\" do\n            fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n            it \"does not update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to be_blank\n            end\n          end\n\n          context \"custom_field\" do\n            before do\n              plugin = Plugin::Instance.new\n              plugin.register_editable_user_custom_field :test2\n              plugin.register_editable_user_custom_field :test3, staff_only: true\n            end\n\n            after do\n              DiscoursePluginRegistry.reset!\n            end\n\n            it \"only updates allowed user fields\" do\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to be_blank\n            end\n\n            it \"works alongside a user field\" do\n              user_field = Fabricate(:user_field, editable: true)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 }, user_fields: { user_field.id.to_s => 'happy' } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(nil)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n            end\n\n            it \"works alongside a user field during creation\" do\n              api_key = Fabricate(:api_key, user: admin)\n              user_field = Fabricate(:user_field, editable: true)\n              post \"/u.json\", params: {\n                name: \"Test User\",\n                username: \"testuser\",\n                email: \"user@mail.com\",\n                password: 'supersecure',\n                active: true,\n                custom_fields: {\n                  test2: 'custom field value'\n                },\n                user_fields: {\n                  user_field.id.to_s => 'user field value'\n                }\n              }, headers: {\n                HTTP_API_KEY: api_key.key\n              }\n              expect(response.status).to eq(200)\n              u = User.find_by_email('user@mail.com')\n\n              val = u.custom_fields[\"user_field_#{user_field.id}\"]\n              expect(val).to eq('user field value')\n\n              val = u.custom_fields[\"test2\"]\n              expect(val).to eq('custom field value')\n            end\n\n            it \"is secure when there are no registered editable fields\" do\n              DiscoursePluginRegistry.reset!\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to be_blank\n              expect(user.custom_fields[\"test3\"]).to be_blank\n\n              put \"/u/#{user.username}.json\", params: { custom_fields: [\"arrayitem1\", \"arrayitem2\"] }\n              expect(response.status).to eq(200)\n            end\n\n            it \"allows staff to edit staff-editable fields\" do\n              sign_in(admin)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(\"hello3\")\n            end\n\n          end\n        end\n\n        it 'returns user JSON' do\n          put \"/u/#{user.username}.json\"\n\n          json = response.parsed_body\n          expect(json['user']['id']).to eq user.id\n        end\n      end\n\n      context 'without permission to update' do\n        it 'does not allow the update' do\n          user = Fabricate(:user, name: 'Billy Bob')\n          sign_in(Fabricate(:user))\n\n          put \"/u/#{user.username}.json\", params: { name: 'Jim Tom' }\n\n          expect(response).to be_forbidden\n          expect(user.reload.name).not_to eq 'Jim Tom'\n        end\n      end\n    end\n  end\n\n  describe '#badge_title' do\n    fab!(:badge) { Fabricate(:badge) }\n    let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n    it \"sets the user's title to the badge name if it is titleable\" do\n      sign_in(user1)\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).not_to eq(badge.display_name)\n      badge.update allow_title: true\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).to eq(badge.display_name)\n      expect(user1.user_profile.badge_granted_title).to eq(true)\n      expect(user1.user_profile.granted_title_badge_id).to eq(badge.id)\n\n      badge.update allow_title: false\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      user1.reload\n      user1.user_profile.reload\n      expect(user1.title).to eq('')\n      expect(user1.user_profile.badge_granted_title).to eq(false)\n      expect(user1.user_profile.granted_title_badge_id).to eq(nil)\n    end\n\n    it \"is not raising an erroring when user revokes title\" do\n      sign_in(user1)\n      badge.update allow_title: true\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: 0 }\n      expect(response.status).to eq(200)\n    end\n\n    context \"with overridden name\" do\n      fab!(:badge) { Fabricate(:badge, name: 'Demogorgon', allow_title: true) }\n      let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n      before do\n        TranslationOverride.upsert!('en', 'badges.demogorgon.name', 'Boss')\n      end\n\n      after do\n        TranslationOverride.revert!('en', ['badges.demogorgon.name'])\n      end\n\n      it \"uses the badge display name as user title\" do\n        sign_in(user1)\n\n        put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n        expect(user1.reload.title).to eq(badge.display_name)\n      end\n    end\n  end\n\n  describe '#send_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"dsdsds@sasa.com\"\n      }\n\n      User.find_by(username: \"osamatest\")\n    end\n\n    context 'for an existing user' do\n      context 'for an activated account with email confirmed' do\n        it 'fails' do\n          user = post_user\n          email_token = Fabricate(:email_token, user: user).token\n          EmailToken.confirm(email_token)\n\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(409)\n          expect(response.parsed_body['errors']).to include(I18n.t(\n            'activation.activated'\n          ))\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'for an activated account with unconfirmed email' do\n        it 'should send an email' do\n          user = post_user\n          user.update!(active: true)\n          Fabricate(:email_token, user: user)\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup, to_address: user.email }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"approval is enabled\" do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it \"should raise an error\" do\n          user = post_user\n          user.update(active: true)\n          user.save!\n          Fabricate(:email_token, user: user1)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe 'when user does not have a valid session' do\n        it 'should not be valid' do\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(403)\n        end\n\n        it 'should allow staff regardless' do\n          sign_in(admin)\n          user = Fabricate(:user, active: false)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context 'with a valid email_token' do\n        it 'should send the activation email' do\n          user = post_user\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'without an existing email_token' do\n        let(:user) { post_user }\n        before do\n          user.email_tokens.each { |t| t.destroy }\n          user.reload\n        end\n\n        it 'should generate a new token' do\n          expect {\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          }.to change { user.reload.email_tokens.count }.by(1)\n        end\n\n        it 'should send an email' do\n          expect do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end.to change { Jobs::CriticalUserEmail.jobs.size }.by(1)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n    end\n\n    context 'when username does not exist' do\n      it 'should not send an email' do\n        post \"/u/action/send_activation_email.json\", params: { username: 'nopenopenopenope' }\n        expect(response.status).to eq(404)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n      end\n    end\n  end\n\n  describe '#pick_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/pick.json\", params: { avatar_id: 1, type: \"custom\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:upload) do\n        Fabricate(:upload, user: user1)\n      end\n\n      it \"raises an error when you don't have permission to toggle the avatar\" do\n        put \"/u/#{another_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when discourse_connect_overrides_avatar is disabled\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is disabled\" do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is admin\" do\n        SiteSetting.allow_uploaded_avatars = 'admin'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(admin: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is staff\" do\n        SiteSetting.allow_uploaded_avatars = 'staff'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(moderator: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is a trust level\" do\n        SiteSetting.allow_uploaded_avatars = '3'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(trust_level: 3)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it 'ignores the upload if picking a system avatar' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"system\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'raises an error if the type is invalid' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"x\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it 'can successfully pick the system avatar' do\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n        system_user = Discourse.system_user\n        SiteSetting.use_site_small_logo_as_system_avatar = true\n        another_upload = Fabricate(:upload, user: system_user)\n        sign_in(system_user)\n\n        put \"/u/#{system_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"uploaded\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n      end\n\n      it 'can successfully pick a gravatar' do\n\n        user1.user_avatar.update_columns(gravatar_upload_id: upload.id)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"gravatar\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.gravatar_upload_id).to eq(upload.id)\n      end\n\n      it 'can not pick uploads that were not created by user' do\n        upload2 = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload2.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'can successfully pick a custom avatar' do\n        events = DiscourseEvent.track_events do\n          put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n            upload_id: upload.id, type: \"custom\"\n          }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.custom_upload_id).to eq(upload.id)\n      end\n    end\n  end\n\n  describe '#select_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/select.json\", params: { url: \"https://meta.discourse.org\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:avatar1) { Fabricate(:upload) }\n      fab!(:avatar2) { Fabricate(:upload) }\n      let(:url) { \"https://www.discourse.org\" }\n\n      it 'raises an error when url is blank' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: \"\" }\n        expect(response.status).to eq(422)\n      end\n\n      it 'raises an error when selectable avatars is disabled' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n        expect(response.status).to eq(422)\n      end\n\n      context 'selectable avatars is enabled' do\n\n        before do\n          SiteSetting.selectable_avatars = [avatar1, avatar2]\n          SiteSetting.selectable_avatars_enabled = true\n        end\n\n        it 'raises an error when selectable avatars is empty' do\n          SiteSetting.selectable_avatars = \"\"\n          put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n          expect(response.status).to eq(422)\n        end\n\n        context 'selectable avatars is properly setup' do\n          it 'raises an error when url is not in selectable avatars list' do\n            put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n            expect(response.status).to eq(422)\n          end\n\n          it 'can successfully select an avatar' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: avatar1.url }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'can successfully select an avatar using a cooked URL' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: UrlHelper.cook_url(avatar1.url) }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n            system_user = Discourse.system_user\n            SiteSetting.use_site_small_logo_as_system_avatar = true\n            sign_in(system_user)\n\n            put \"/u/#{system_user.username}/preferences/avatar/select.json\", params: {\n              url: UrlHelper.cook_url(avatar1.url)\n            }\n\n            expect(response.status).to eq(200)\n            expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n          end\n        end\n      end\n    end\n  end\n\n  describe '#destroy_user_image' do\n\n    it 'raises an error when not logged in' do\n      delete \"/u/asdf/preferences/user_image.json\", params: { type: 'profile_background' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you don\\'t have permission to clear the profile background' do\n        delete \"/u/#{another_user.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the `type` param\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"only allows certain `types`\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'wat' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'can clear the profile background' do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n\n        expect(user1.reload.profile_background_upload).to eq(nil)\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#destroy' do\n    it 'raises an error when not logged in' do\n      delete \"/u/nobody.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you cannot delete your account' do\n        UserDestroyer.any_instance.expects(:destroy).never\n        stat = user1.user_stat\n        stat.post_count = 3\n        stat.save!\n        delete \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when you try to delete someone else's account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        delete \"/u/#{another_user.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes your account when you're allowed to\" do\n        UserDestroyer.any_instance.expects(:destroy).with(user1, anything).returns(user1)\n        delete \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#ignore' do\n    it 'raises an error when not logged in' do\n      put \"/u/#{user1.username}/notification_level.json\", params: { notification_level: \"\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:user) { Fabricate(:user, trust_level: 2) }\n      before do\n        sign_in(user)\n      end\n\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: user, ignored_user: another_user) }\n      fab!(:muted_user) { Fabricate(:muted_user, user: user, muted_user: another_user) }\n\n      context \"when you can't change the notification\" do\n        fab!(:staff_user) { admin }\n\n        it \"ignoring includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'ignore' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.ignore_error\"))\n        end\n\n        it \"muting includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'mute' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.mute_error\"))\n        end\n      end\n\n      context 'when changing notification level to normal' do\n        it 'changes notification level to normal' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"normal\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.count).to eq(0)\n        end\n      end\n\n      context 'when changing notification level to mute' do\n        it 'changes notification level to mute' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"mute\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.find_by(user_id: user.id, muted_user_id: another_user.id)).to be_present\n        end\n      end\n\n      context 'when changing notification level to ignore' do\n        it 'changes notification level to ignore' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\" }\n          expect(MutedUser.count).to eq(0)\n          expect(IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)).to be_present\n        end\n\n        context 'when expiring_at param is set' do\n          it 'changes notification level to ignore' do\n            freeze_time(Time.now) do\n              expiring_at = 3.days.from_now\n              put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\", expiring_at: expiring_at }\n\n              ignored_user = IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)\n              expect(ignored_user).to be_present\n              expect(ignored_user.expiring_at.to_i).to eq(expiring_at.to_i)\n              expect(MutedUser.count).to eq(0)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  describe \"for user with period in username\" do\n    fab!(:user_with_period) { Fabricate(:user, username: \"myname.test\") }\n\n    it \"still works\" do\n      sign_in(user_with_period)\n      UserDestroyer.any_instance.expects(:destroy).with(user_with_period, anything).returns(user_with_period)\n      delete \"/u/#{user_with_period.username}\", xhr: true\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe '#my_redirect' do\n    it \"redirects if the user is not logged in\" do\n      get \"/my/wat\"\n      expect(response).to redirect_to(\"/login-preferences\")\n      expect(response.cookies).to have_key(\"destination_url\")\n      expect(response.cookies[\"destination_url\"]).to eq(\"/my/wat\")\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n    end\n\n    context \"when the user is logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it \"will not redirect to an invalid path\" do\n        get \"/my/wat/..password.txt\"\n        expect(response).not_to be_redirect\n      end\n\n      it \"will redirect to an valid path\" do\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/preferences\")\n      end\n\n      it \"permits forward slashes\" do\n        get \"/my/activity/posts\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/activity/posts\")\n      end\n\n      it \"correctly redirects for Unicode usernames\" do\n        SiteSetting.unicode_usernames = true\n        user = sign_in(Fabricate(:unicode_user))\n\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences\")\n      end\n    end\n  end\n\n  describe '#check_emails' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/emails.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check emails\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{Fabricate(:user).username}/emails.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts for self\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in(user)\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in_admin\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"works on inactive users\" do\n        inactive_user = Fabricate(:user, active: false)\n        Fabricate(:email_change_request, user: inactive_user)\n        sign_in_admin\n\n        get \"/u/#{inactive_user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(inactive_user.email)\n        expect(json[\"secondary_emails\"]).to eq(inactive_user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(inactive_user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n    end\n  end\n\n  describe '#check_sso_email' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-email.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso email\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-email.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"looks good\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-email.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"email\"]).to eq(\"foobar@example.com\")\n      end\n    end\n  end\n\n  describe '#check_sso_payload' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-payload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso payload\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-payload.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns SSO payload when you're allowed to see\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"foobar\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-payload.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"payload\"]).to eq(\"foobar\")\n      end\n    end\n  end\n\n  describe '#update_primary_email' do\n    let(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"changes user's primary email\" do\n      put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(true)\n      expect(other_email.reload.primary).to eq(false)\n\n      event = DiscourseEvent.track_events {\n        expect { put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:update_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(false)\n      expect(other_email.reload.primary).to eq(true)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n  end\n\n  describe '#destroy_email' do\n    fab!(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"can destroy secondary emails\" do\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(428)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n\n      event = DiscourseEvent.track_events {\n        expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:destroy_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n\n    it \"can destroy unconfirmed emails\" do\n      request_1 = EmailChangeRequest.create!(\n        user: user1,\n        new_email: user_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email }\n\n      expect(user1.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n      expect(user1.email_change_requests).to contain_exactly(request_1)\n    end\n\n    it \"can destroy associated email tokens\" do\n      new_email = 'new.n.cool@example.com'\n      updater = EmailUpdater.new(guardian: user1.guardian, user: user1)\n\n      expect { updater.change_to(new_email) }\n        .to change { user1.email_tokens.count }.by(1)\n\n      expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: new_email } }\n        .to change { user1.email_tokens.count }.by(-1)\n\n      expect(user1.email_tokens.first.email).to eq(user1.email)\n    end\n  end\n\n  describe '#is_local_username' do\n    fab!(:group) { Fabricate(:group, name: \"Discourse\", mentionable_level: Group::ALIAS_LEVELS[:everyone]) }\n    let(:unmentionable) {\n      Fabricate(:group, name: \"Unmentionable\", mentionable_level: Group::ALIAS_LEVELS[:nobody])\n    }\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: allowed_user) }\n\n    it \"finds the user\" do\n      get \"/u/is_local_username.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid\"][0]).to eq(user1.username)\n    end\n\n    it \"finds the group\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: group.name }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid_groups\"]).to include(group.name)\n      expect(response.parsed_body[\"mentionable_groups\"].find { |g| g['name'] == group.name }).to be_present\n    end\n\n    it \"finds unmentionable groups\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: unmentionable.name }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid_groups\"]).to include(unmentionable.name)\n      expect(response.parsed_body[\"mentionable_groups\"]).to be_blank\n    end\n\n    it \"supports multiples usernames\" do\n      get \"/u/is_local_username.json\", params: { usernames: [user1.username, \"system\"] }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid\"]).to contain_exactly(user1.username, \"system\")\n    end\n\n    it \"never includes staged accounts\" do\n      staged = Fabricate(:user, staged: true)\n\n      get \"/u/is_local_username.json\", params: { usernames: [staged.username] }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"valid\"]).to be_blank\n    end\n\n    it \"returns user who cannot see topic\" do\n      Guardian.any_instance.expects(:can_see?).with(topic).returns(false)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][user1.username]).to eq(\"category\")\n    end\n\n    it \"never returns a user who can see the topic\" do\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"]).to be_blank\n    end\n\n    it \"returns user who cannot see a private topic\" do\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][user1.username]).to eq(\"private\")\n    end\n\n    it \"returns user who was not invited to topic\" do\n      sign_in(Fabricate(:admin))\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [admin.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][admin.username]).to eq(\"not_allowed\")\n    end\n\n    it \"never returns a user who can see the topic\" do\n      get \"/u/is_local_username.json\", params: {\n        usernames: [allowed_user.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"]).to be_blank\n    end\n\n    it \"returns the appropriate reason why user cannot see the topic\" do\n      TopicUser.create!(user_id: user1.id, topic_id: topic.id, notification_level: TopicUser.notification_levels[:muted])\n\n      sign_in(admin)\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"cannot_see\"][user1.username]).to eq(\"muted_topic\")\n    end\n  end\n\n  describe '#topic_tracking_state' do\n    context 'anon' do\n      it \"raises an error on anon for topic_tracking_state\" do\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'logged on' do\n      it \"detects new topic\" do\n        sign_in(user1)\n\n        topic = Fabricate(:topic)\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n\n        expect(response.status).to eq(200)\n        states = response.parsed_body\n        expect(states[0][\"topic_id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe '#summary' do\n    it \"generates summary info\" do\n      create_post(user: user)\n\n      get \"/u/#{user.username_lower}/summary.json\"\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json[\"user_summary\"][\"topic_count\"]).to eq(1)\n      expect(json[\"user_summary\"][\"post_count\"]).to eq(0)\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before_all do\n        user1.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"returns 404\" do\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns summary info if `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context 'avatar flair in Most... sections' do\n      it \"returns data for automatic groups flair\" do\n        liker = Fabricate(:user, admin: true, moderator: true, trust_level: 1)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"admin\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"moderator\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"trust_level\"]).to eq(1)\n      end\n\n      it \"returns data for flair when an icon is used\" do\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_color: \"#999999\", flair_icon: \"icon\")\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(\"icon\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_color\"]).to eq(\"#999999\")\n      end\n\n      it \"returns data for flair when an image is used\" do\n        upload = Fabricate(:upload)\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_upload: upload)\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(upload.url)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n      end\n\n      def create_and_like_post(likee, liker)\n        UserActionManager.enable\n        post = create_post(user: likee)\n        PostActionCreator.like(liker, post)\n      end\n    end\n  end\n\n  describe '#confirm_admin' do\n    it \"fails without a valid token\" do\n      get \"/u/confirm-admin/invalid-token.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"fails with a missing token\" do\n      get \"/u/confirm-admin/a0a0a0a0a0.json\"\n      expect(response).to_not be_successful\n    end\n\n    it \"succeeds with a valid code as anonymous\" do\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"succeeds with a valid code when logged in as that user\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\", params: { token: ac.token }\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"fails if you're logged in as a different account\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, Fabricate(:admin))\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response).to_not be_successful\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    describe \"post\" do\n      it \"gives the user admin access when POSTed\" do\n        ac = AdminConfirmation.new(user1, admin)\n        ac.create_confirmation\n        post \"/u/confirm-admin/#{ac.token}.json\"\n        expect(response.status).to eq(200)\n\n        user1.reload\n        expect(user1.admin?).to eq(true)\n      end\n    end\n  end\n\n  describe '#update_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"osama@example.com\"\n      }\n      user = User.where(username: \"osamatest\").first\n      user.active = false\n      user.save!\n      user\n    end\n\n    context \"with a session variable\" do\n      it \"raises an error with an invalid session value\" do\n        post_user\n\n        post \"/u.json\", params: {\n          username: \"osamatest2\",\n          password: \"strongpassword2\",\n          email: \"osama22@example.com\"\n        }\n        user = User.where(username: \"osamatest2\").first\n        user.destroy\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osamaupdated@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        user = post_user\n        user.update(active: true)\n        user.save!\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osama@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        active_user = Fabricate(:user)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: active_user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when the email is blocklisted\" do\n        post_user\n        SiteSetting.blocked_email_domains = 'example.com'\n        put \"/u/update-activation-email.json\", params: { email: 'test@example.com' }\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = post_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n\n      it 'tells the user to slow down after many requests' do\n        RateLimiter.enable\n        RateLimiter.clear_all!\n        freeze_time\n\n        user = post_user\n        token = user.email_tokens.first\n\n        6.times do |n|\n          put \"/u/update-activation-email.json\", params: {\n            email: \"updatedemail#{n}@example.com\"\n          }, env: { \"REMOTE_ADDR\": \"1.2.3.#{n}\" }\n        end\n\n        expect(response.status).to eq(429)\n      end\n    end\n\n    context \"with a username and password\" do\n      it \"raises an error with an invalid username\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: 'eviltrout',\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error with an invalid password\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: Fabricate(:walter_white).username,\n          password: 'letscook',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = inactive_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          username: user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n\n      it 'tells the user to slow down after many requests' do\n        RateLimiter.enable\n        RateLimiter.clear_all!\n        freeze_time\n\n        user = inactive_user\n        token = user.email_tokens.first\n\n        6.times do |n|\n          put \"/u/update-activation-email.json\", params: {\n            username: user.username,\n            password: 'qwerqwer123',\n            email: \"updatedemail#{n}@example.com\"\n          }, env: { \"REMOTE_ADDR\": \"1.2.3.#{n}\" }\n        end\n\n        expect(response.status).to eq(429)\n      end\n    end\n  end\n\n  describe '#show' do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed['username']).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"returns a hidden profile\" do\n        user.user_option.update_column(:hide_profile_and_presence, true)\n\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to eq(true)\n        expect(parsed[\"trust_level\"]).to be_blank\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}.json\"\n        expect(response).to redirect_to '/login'\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for an anon user\" do\n          get \"/\"\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, nil)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns success' do\n        get \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers['X-Robots-Tag']).to eq('noindex')\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"has_title_badges\"]).to eq(false)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns not found when the user is inactive' do\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns success when show_inactive_accounts is true and user is logged in' do\n        SiteSetting.show_inactive_accounts = true\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for a signed in user\" do\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, user1.id)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"should not track a user profile view for a user viewing his own profile\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n\n      context \"fetching a user by external_id\" do\n        before { user1.create_single_sign_on_record(external_id: '997', last_payload: '') }\n\n        it \"returns fetch for a matching external_id\" do\n          get \"/u/by-external/997.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n        end\n\n        it \"returns not found when external_id doesn't match\" do\n          get \"/u/by-external/99.json\"\n          expect(response).not_to be_successful\n        end\n\n        context \"for an external provider\" do\n          before do\n            sign_in(admin)\n            SiteSetting.enable_google_oauth2_logins = true\n            UserAssociatedAccount.create!(user: user1, provider_uid: 'myuid', provider_name: 'google_oauth2')\n          end\n\n          it \"doesn't work for non-admin\" do\n            sign_in(user1)\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(403)\n          end\n\n          it \"can fetch the user\" do\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n          end\n\n          it \"fails for disabled provider\" do\n            SiteSetting.enable_google_oauth2_logins = false\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(404)\n          end\n\n          it \"returns 404 for missing user\" do\n            get \"/u/by-external/google_oauth2/myotheruid.json\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"include_post_count_for\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        before_all do\n          Fabricate(:post, user: user1, topic: topic)\n          Fabricate(:post, user: admin, topic: topic)\n          Fabricate(:post, user: admin, topic: topic, post_type: Post.types[:whisper])\n        end\n\n        it \"includes only visible posts\" do\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(1)\n        end\n\n        it \"includes all post types for staff members\" do\n          sign_in(admin)\n\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(2)\n        end\n      end\n    end\n\n    it \"should be able to view a user\" do\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).to include(user1.username)\n    end\n\n    it \"should not be able to view a private user profile\" do\n      user1.user_profile.update!(bio_raw: \"Hello world!\")\n      user1.user_option.update!(hide_profile_and_presence: true)\n\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"Hello world!\")\n    end\n\n    describe 'when username contains a period' do\n      before_all do\n        user1.update!(username: 'test.test')\n      end\n\n      it \"should be able to view a user\" do\n        get \"/u/#{user1.username}\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(user1.username)\n      end\n    end\n  end\n\n  describe \"#show_card\" do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to redirect_to '/login'\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'works correctly' do\n        get \"/u/#{user1.username}/card.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"associated_accounts\"]).to eq(nil) # Not serialized in card\n        expect(json[\"user\"][\"username\"]).to eq(user1.username)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity/card.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}/card.json\"\n        expect(response).to be_forbidden\n      end\n    end\n  end\n\n  describe \"#cards\" do\n    fab!(:user) { Discourse.system_user }\n    fab!(:user2) { Fabricate(:user) }\n\n    it \"returns success\" do\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body[\"users\"]\n\n      expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n    end\n\n    it \"should redirect to login page for anonymous user when profiles are hidden\" do\n      SiteSetting.hide_user_profiles_from_public = true\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response).to redirect_to '/login'\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before do\n        user2.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"does not include hidden profiles\" do\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username)\n      end\n\n      it \"does include hidden profiles when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n      end\n    end\n  end\n\n  describe '#badges' do\n    it \"renders fine by default\" do\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"fails if badges are disabled\" do\n      SiteSetting.enable_badges = false\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#account_created\" do\n    it \"returns a message when no session is present\" do\n      get \"/u/account-created\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to match(I18n.t('activation.missing_session'))\n    end\n\n    it \"redirects when the user is logged in\" do\n      sign_in(user1)\n\n      get \"/u/account-created\"\n\n      expect(response).to redirect_to(\"/\")\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        sign_in(user1)\n\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        get \"/u/account-created\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when the user account is created\" do\n      include ApplicationHelper\n\n      it \"returns the message when set in the session\" do\n        user1 = create_user\n        get \"/u/account-created\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['accountCreated']).to include(\n            \"{\\\"message\\\":\\\"#{I18n.t(\"login.activate_email\", email: user1.email).gsub!(\"</\", \"<\\\\/\")}\\\",\\\"show_controls\\\":true,\\\"username\\\":\\\"#{user1.username}\\\",\\\"email\\\":\\\"#{user1.email}\\\"}\"\n          )\n        end\n      end\n    end\n  end\n\n  describe '#search_users' do\n    fab!(:topic) { Fabricate :topic }\n    let(:user)  { Fabricate :user, username: \"joecabot\", name: \"Lawrence Tierney\" }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:staged_user) { Fabricate(:user, staged: true) }\n\n    before do\n      SearchIndexer.enable\n      post1\n    end\n\n    it \"searches when provided the term only\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the topic only\" do\n      get \"/u/search/users.json\", params: { topic_id: topic.id }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the term and topic\" do\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches only for users who have access to private topic\" do\n      searching_user = Fabricate(:user)\n      privileged_user = Fabricate(:user, trust_level: 4, username: \"joecabit\", name: \"Lawrence Tierney\")\n      privileged_group = Fabricate(:group)\n      privileged_group.add(searching_user)\n      privileged_group.add(privileged_user)\n      privileged_group.save\n\n      category = Fabricate(:category)\n      category.set_permissions(privileged_group => :readonly)\n      category.save\n\n      private_topic = Fabricate(:topic, category: category)\n\n      sign_in(searching_user)\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: private_topic.id, topic_allowed_users: \"true\"\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to_not include(user.username)\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(privileged_user.username)\n    end\n\n    it \"interprets blank category id correctly\" do\n      pm_topic = Fabricate(:private_message_post).topic\n      sign_in(pm_topic.user)\n      get \"/u/search/users.json\", params: {\n        term: \"\", topic_id: pm_topic.id, category_id: \"\"\n      }\n      expect(response.status).to eq(200)\n    end\n\n    context 'limit' do\n      it \"returns an error if value is invalid\" do\n        get \"/u/search/users.json\", params: { limit: '-1' }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when `enable_names` is true\" do\n      before do\n        SiteSetting.enable_names = true\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(user.name)\n      end\n    end\n\n    context \"when `enable_names` is false\" do\n      before do\n        SiteSetting.enable_names = false\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(user.name)\n      end\n    end\n\n    context 'groups' do\n      fab!(:mentionable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:public],\n          name: 'aaa1'\n        )\n      end\n\n      fab!(:mentionable_group_2) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa2'\n        )\n      end\n\n      fab!(:messageable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:nobody],\n          messageable_level: Group::ALIAS_LEVELS[:everyone],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa3'\n        )\n      end\n\n      fab!(:private_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          messageable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          visibility_level: Group.visibility_levels[:members],\n          name: 'aaa4'\n        )\n      end\n\n      describe 'when signed in' do\n        before do\n          sign_in(user)\n        end\n\n        it \"does not search for groups if there is no term\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq(nil)\n        end\n\n        it \"only returns visible groups\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: 'a' }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to_not include(private_group.name)\n        end\n\n        it 'allows plugins to register custom groups filter' do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups.count).to eq(6)\n\n          plugin = Plugin::Instance.new\n          plugin.register_groups_callback_for_users_search_controller_action(:admins_filter) do |original_groups, user|\n            original_groups.where(name: \"admins\")\n          end\n          get \"/u/search/users.json\", params: { include_groups: \"true\", admins_filter: \"true\", term: \"a\" }\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq([{ \"name\" => \"admins\", \"full_name\" => nil }])\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"doesn't search for groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n\n        it \"searches for messageable groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"groups\"].map { |group| group['name'] })\n            .to contain_exactly(messageable_group.name, Group.find(Group::AUTO_GROUPS[:moderators]).name)\n        end\n\n        it 'searches for mentionable groups' do\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to contain_exactly(mentionable_group.name, mentionable_group_2.name)\n        end\n      end\n\n      describe 'when not signed in' do\n        it 'should not include mentionable/messageable groups' do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n      end\n\n      describe 'when searching by group name' do\n        fab!(:exclusive_group) { Fabricate(:group) }\n\n        it 'return results if the user is a group member' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a group member' do\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        it 'returns results if the user is member of one of the groups' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a member of the groups' do\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        def users_found\n          response.parsed_body['users'].map { |u| u['username'] }\n        end\n      end\n    end\n\n    context '`include_staged_users`' do\n      it \"includes staged users when the param is true\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: true }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param is not passed\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param explicitly set to false\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: false }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n    end\n\n    context '`last_seen_users`' do\n      it \"returns results when the param is true\" do\n        get \"/u/search/users.json\", params: { last_seen_users: true }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n      end\n\n      it \"respects limit parameter at the same time\" do\n        limit = 3\n        get \"/u/search/users.json\", params: { last_seen_users: true, limit: limit }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n        expect(json[\"users\"].size).to eq(limit)\n      end\n    end\n  end\n\n  describe '#email_login' do\n    before do\n      SiteSetting.enable_local_logins_via_email = true\n    end\n\n    it \"enqueues the right email\" do\n      post \"/u/email-login.json\", params: { login: user1.email }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_found']).to eq(true)\n\n      job_args = Jobs::CriticalUserEmail.jobs.last[\"args\"].first\n      expect(job_args[\"user_id\"]).to eq(user1.id)\n      expect(job_args[\"type\"]).to eq(\"email_login\")\n      expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(user1.email_tokens.last.token_hash)\n    end\n\n    describe 'when enable_local_logins_via_email is disabled' do\n      before do\n        SiteSetting.enable_local_logins_via_email = false\n      end\n\n      it 'should return the right response' do\n        post \"/u/email-login.json\", params: { login: user1.email }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe 'when username or email is not valid' do\n      it 'should not enqueue the email to login' do\n        post \"/u/email-login.json\", params: { login: '@random' }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json['user_found']).to eq(false)\n        expect(json['hide_taken']).to eq(false)\n        expect(Jobs::CriticalUserEmail.jobs).to eq([])\n      end\n    end\n\n    describe 'when hide_email_address_taken is true' do\n      it 'should return the right response' do\n        SiteSetting.hide_email_address_taken = true\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json.has_key?('user_found')).to eq(false)\n        expect(json['hide_taken']).to eq(true)\n      end\n    end\n\n    describe \"when user is already logged in\" do\n      it 'should redirect to the root path' do\n        sign_in(user1)\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response).to redirect_to(\"/\")\n      end\n    end\n  end\n\n  describe '#create_second_factor_totp' do\n    context 'when not logged in' do\n      it 'should return the right response' do\n        post \"/users/second_factors.json\", params: {\n          password: 'wrongpassword'\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          expect(response_body['key']).to be_present\n          expect(response_body['qr']).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#enable_second_factor_totp\" do\n    before do\n      sign_in(user1)\n    end\n\n    def create_totp\n      stub_secure_session_confirmed\n      post \"/users/create_second_factor_totp.json\"\n    end\n\n    it \"creates a totp for the user successfully\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token }\n\n      expect(response.status).to eq(200)\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"rate limits by IP address\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    it \"rate limits by username\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\"  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    context \"when an incorrect token is provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.invalid_second_factor_code\"))\n      end\n    end\n\n    context \"when a name is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_name\"))\n      end\n    end\n\n    context \"when a token is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_code\"))\n      end\n    end\n  end\n\n  describe '#update_second_factor' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factor.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      context 'when user has totp setup' do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              disable: 'true',\n              second_factor_target: UserSecondFactor.methods[:totp],\n              id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            stub_secure_session_confirmed\n          end\n          it 'should allow second factor for the user to be renamed' do\n            put \"/users/second_factor.json\", params: {\n                  name: 'renamed',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first.name).to eq(\"renamed\")\n          end\n\n          it 'should allow second factor for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  disable: 'true',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first).to eq(nil)\n          end\n        end\n      end\n\n      context \"when user is updating backup codes\" do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              second_factor_target: UserSecondFactor.methods[:backup_codes]\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          end\n          it 'should allow second factor backup for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                  disable: 'true'\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.backup_codes).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#create_second_factor_backup' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factors_backup.json\", params: {\n          second_factor_token: 'wrongtoken',\n          second_factor_method: UserSecondFactor.methods[:totp]\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          # we use SecureRandom.hex(16) for backup codes, ensure this continues to be the case\n          expect(response_body['backup_codes'].map(&:length)).to eq([32] * 10)\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_security_key\" do\n    it \"stores the challenge in the session and returns challenge data, user id, and supported algorithms\" do\n      create_second_factor_security_key\n      secure_session = read_secure_session\n      response_parsed = response.parsed_body\n      expect(response_parsed[\"challenge\"]).to eq(\n        Webauthn.challenge(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_id\"]).to eq(\n        Webauthn.rp_id(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_name\"]).to eq(\n        Webauthn.rp_name(user1, secure_session)\n      )\n      expect(response_parsed[\"user_secure_id\"]).to eq(\n        user1.reload.create_or_fetch_secure_identifier\n      )\n      expect(response_parsed[\"supported_algorithms\"]).to eq(\n        ::Webauthn::SUPPORTED_ALGORITHMS\n      )\n    end\n\n    context \"if the user has security key credentials already\" do\n      fab!(:user_security_key) { Fabricate(:user_security_key_with_random_credential, user: user1) }\n\n      it \"returns those existing active credentials\" do\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n        expect(response_parsed[\"existing_active_credential_ids\"]).to eq(\n          [user_security_key.credential_id]\n        )\n      end\n    end\n  end\n\n  describe \"#register_second_factor_security_key\" do\n    context \"when creation parameters are valid\" do\n      it \"creates a security key for the user\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: valid_security_key_create_post_data\n\n        expect(user1.security_keys.count).to eq(1)\n        expect(user1.security_keys.last.credential_id).to eq(valid_security_key_create_post_data[:rawId])\n        expect(user1.security_keys.last.name).to eq(valid_security_key_create_post_data[:name])\n      end\n    end\n\n    context \"when the creation parameters are invalid\" do\n      it \"shows a security key error and does not create a key\" do\n        stub_as_dev_localhost\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: {\n          id: \"bad id\",\n          rawId: \"bad rawId\",\n          type: \"public-key\",\n          attestation: \"bad attestation\",\n          clientData: Base64.encode64('{\"bad\": \"json\"}'),\n          name: \"My Bad Key\"\n        }\n\n        expect(user1.security_keys.count).to eq(0)\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"webauthn.validation.invalid_type_error\"))\n      end\n    end\n  end\n\n  describe '#disable_second_factor' do\n    context 'when logged in with secure session' do\n      before do\n        sign_in(user1)\n        stub_secure_session_confirmed\n      end\n      context 'when user has a registered totp and security key' do\n        before do\n          totp_second_factor = Fabricate(:user_second_factor_totp, user: user1)\n          security_key_second_factor = Fabricate(:user_security_key, user: user1, factor_type: UserSecurityKey.factor_types[:second_factor])\n        end\n\n        it 'should disable all totp and security keys' do\n          expect_enqueued_with(job: :critical_user_email, args: { type: :account_second_factor_disabled, user_id: user1.id }) do\n            put \"/u/disable_second_factor.json\"\n\n            expect(response.status).to eq(200)\n\n            expect(user1.reload.user_second_factors).to be_empty\n            expect(user1.security_keys).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#revoke_account' do\n    it 'errors for unauthorised users' do\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n\n      sign_in(another_user)\n\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns an error when there is no matching account' do\n        post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n          provider_name: 'facebook'\n        }\n        expect(response.status).to eq(404)\n      end\n\n      context \"with fake provider\" do\n        let(:authenticator) do\n          Class.new(Auth::Authenticator) do\n            attr_accessor :can_revoke\n            def name\n              \"testprovider\"\n            end\n\n            def enabled?\n              true\n            end\n\n            def description_for_user(user)\n              \"an account\"\n            end\n\n            def can_revoke?\n              can_revoke\n            end\n\n            def revoke(user, skip_remote: false)\n              true\n            end\n          end.new\n        end\n\n        before do\n          DiscoursePluginRegistry.register_auth_provider(Auth::AuthProvider.new(authenticator: authenticator))\n        end\n\n        after do\n          DiscoursePluginRegistry.reset!\n        end\n\n        it 'returns an error when revoking is not allowed' do\n          authenticator.can_revoke = false\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(404)\n\n          authenticator.can_revoke = true\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n\n        it 'works' do\n          authenticator.can_revoke = true\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n    end\n\n  end\n\n  describe '#revoke_auth_token' do\n\n    context 'while logged in' do\n      before do\n        2.times { sign_in(user1) }\n      end\n\n      it 'logs user out' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        user1.user_auth_tokens.reload\n        expect(user1.user_auth_tokens.count).to eq(1)\n        expect(user1.user_auth_tokens.first.id).to eq(ids[1])\n      end\n\n      it 'checks if token exists' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(400)\n      end\n\n      it 'does not let user log out of current session' do\n        token = UserAuthToken.generate!(user_id: user1.id)\n        cookie = create_auth_cookie(\n          token: token.unhashed_auth_token,\n          user_id: user1.id,\n          trust_level: user1.trust_level,\n          issued_at: 5.minutes.ago,\n        )\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: token.id },\n          headers: { \"HTTP_COOKIE\" => \"_t=#{cookie}\" }\n\n        expect(token.reload.id).to be_present\n        expect(response.status).to eq(400)\n      end\n\n      it 'logs user out from everywhere if token_id is not present' do\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.user_auth_tokens.count).to eq(0)\n      end\n\n    end\n\n  end\n\n  describe '#list_second_factors' do\n    let(:user) { user1 }\n\n    before do\n      sign_in(user)\n    end\n\n    context 'when SSO is enabled' do\n      before do\n        SiteSetting.discourse_connect_url = 'https://discourse.test/sso'\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when local logins are not enabled' do\n      before do\n        SiteSetting.enable_local_logins = false\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when the site settings allow second factors' do\n      before do\n        SiteSetting.enable_local_logins = true\n        SiteSetting.enable_discourse_connect = false\n      end\n\n      context 'when the password parameter is not provided' do\n        let(:password) { '' }\n\n        before do\n          post \"/u/second_factors.json\", params: { password: password }\n        end\n\n        it 'returns password required response' do\n          expect(response.status).to eq(200)\n          response_body = response.parsed_body\n          expect(response_body['password_required']).to eq(true)\n        end\n      end\n\n      context 'when the password is provided' do\n        fab!(:user) { Fabricate(:user, password: '8555039dd212cc66ec68') }\n\n        context 'when the password is correct' do\n          let(:password) { '8555039dd212cc66ec68' }\n\n          it 'returns a list of enabled totps and security_key second factors' do\n            totp_second_factor = Fabricate(:user_second_factor_totp, user: user)\n            security_key_second_factor = Fabricate(:user_security_key, user: user, factor_type: UserSecurityKey.factor_types[:second_factor])\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            expect(response.status).to eq(200)\n            response_body = response.parsed_body\n            expect(response_body['totps'].map { |second_factor| second_factor['id'] }).to include(totp_second_factor.id)\n            expect(response_body['security_keys'].map { |second_factor| second_factor['id'] }).to include(security_key_second_factor.id)\n          end\n        end\n\n        context 'when the password is not correct' do\n          let(:password) { 'wrongpassword' }\n\n          it 'returns the incorrect password response' do\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            response_body = response.parsed_body\n            expect(response_body['error']).to eq(\n              I18n.t(\"login.incorrect_password\")\n            )\n          end\n        end\n      end\n    end\n  end\n\n  describe '#feature_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:other_topic) { Fabricate(:topic) }\n    fab!(:private_message) { Fabricate(:private_message_topic, user: another_user) }\n    fab!(:category) { Fabricate(:category_with_definition) }\n\n    describe \"site setting enabled\" do\n      before do\n        SiteSetting.allow_featured_topic_on_user_profiles = true\n      end\n\n      it 'requires the user to be logged in' do\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the user tries to set for another user' do\n        sign_in(user1)\n        topic.update(user_id: another_user.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the topic is a PM' do\n        sign_in(another_user)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: private_message.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is not visible\" do\n        sign_in(user1)\n        topic.update_status('visible', false, user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic's category is read_restricted\" do\n        sign_in(user1)\n        category.set_permissions({})\n        topic.update(category_id: category.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'sets featured_topic correctly for user created topic' do\n        sign_in(user1)\n        topic.update(user_id: user1.id)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq topic\n      end\n\n      it 'sets featured_topic correctly for non-user-created topic' do\n        sign_in(user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: other_topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq other_topic\n      end\n\n      describe \"site setting disabled\" do\n        before do\n          SiteSetting.allow_featured_topic_on_user_profiles = false\n        end\n\n        it \"does not allow setting featured_topic for user_profiles\" do\n          sign_in(user1)\n          topic.update(user_id: user1.id)\n          put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe '#clear_featured_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n\n    it 'requires the user to be logged in' do\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns an error if the the current user does not have access' do\n      sign_in(user1)\n      topic.update(user_id: another_user.id)\n      put \"/u/#{another_user.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'clears the user_profiles featured_topic correctly' do\n      sign_in(user1)\n      topic.update(user: user1)\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(200)\n      expect(user1.user_profile.featured_topic).to eq nil\n    end\n  end\n\n  describe \"#bookmarks\" do\n    fab!(:bookmark1) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark2) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark3) { Fabricate(:bookmark) }\n\n    before do\n      TopicUser.change(user1.id, bookmark1.topic_id, total_msecs_viewed: 1)\n      TopicUser.change(user1.id, bookmark2.topic_id, total_msecs_viewed: 1)\n    end\n\n    it \"returns a list of serialized bookmarks for the user\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_bookmark_list']['bookmarks'].map { |b| b['id'] }).to match_array([bookmark1.id, bookmark2.id])\n    end\n\n    it \"returns an .ics file of bookmark reminders for the user in date order\" do\n      bookmark1.update!(name: nil, reminder_at: 1.day.from_now)\n      bookmark2.update!(name: \"Some bookmark note\", reminder_at: 1.week.from_now)\n\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.ics\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(<<~ICS)\n        BEGIN:VCALENDAR\n        VERSION:2.0\n        PRODID:-//Discourse//#{Discourse.current_hostname}//#{Discourse.full_version}//EN\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark1.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark1.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark1.reminder_at_ics}\n        DTEND:#{bookmark1.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark1.topic.title}\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark2.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark2.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark2.reminder_at_ics}\n        DTEND:#{bookmark2.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:Some bookmark note\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        END:VEVENT\n        END:VCALENDAR\n      ICS\n    end\n\n    it \"does not show another user's bookmarks\" do\n      sign_in(user1)\n      get \"/u/#{bookmark3.user.username}/bookmarks.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows a helpful message if no bookmarks are found\" do\n      bookmark1.destroy\n      bookmark2.destroy\n      bookmark3.destroy\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n\n    it \"shows a helpful message if no bookmarks are found for the search\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\", params: {\n        q: 'badsearch'\n      }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n  end\n\n  describe \"#private_message_topic_tracking_state\" do\n    fab!(:user_2) { Fabricate(:user) }\n\n    fab!(:private_message) do\n      create_post(\n        user: user1,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message\n      ).topic\n    end\n\n    before do\n      sign_in(user_2)\n    end\n\n    it 'does not allow an unauthorized user to access the state of another user' do\n      get \"/u/#{user1.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns the right response' do\n      get \"/u/#{user_2.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(200)\n\n      topic_state = response.parsed_body.first\n\n      expect(topic_state[\"topic_id\"]).to eq(private_message.id)\n      expect(topic_state[\"highest_post_number\"]).to eq(1)\n      expect(topic_state[\"last_read_post_number\"]).to eq(nil)\n      expect(topic_state[\"notification_level\"]).to eq(NotificationLevels.all[:watching])\n      expect(topic_state[\"group_ids\"]).to eq([])\n    end\n  end\n\n  describe \"#reset_recent_searches\" do\n    it 'does nothing for anon' do\n      delete \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      delete \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      user1.reload\n      expect(user1.user_option.oldest_search_log_date).to be_within(5.seconds).of(1.second.ago)\n    end\n  end\n\n  describe \"#recent_searches\" do\n    it 'does nothing for anon' do\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = true\n      user1.user_option.update!(oldest_search_log_date: nil)\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"old one\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 5.minutes.ago\n      )\n      SearchLog.create!(\n        term: \"also old\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 15.minutes.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 20.minutes.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 10.seconds.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"new search\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 2.seconds.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"new search\"])\n    end\n\n    it 'shows an error message when log_search_queries are off' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = false\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(403)\n      expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"user_activity.no_log_search_queries\"))\n    end\n  end\n\n  def create_second_factor_security_key\n    sign_in(user1)\n    stub_secure_session_confirmed\n    post \"/u/create_second_factor_security_key.json\"\n  end\n\n  def stub_secure_session_confirmed\n    UsersController.any_instance.stubs(:secure_session_confirmed?).returns(true)\n  end\nend\n"], "filenames": ["app/controllers/users_controller.rb", "spec/requests/users_controller_spec.rb"], "buggy_code_start_loc": [1064, 3444], "buggy_code_end_loc": [1068, 3517], "fixing_code_start_loc": [1065, 3445], "fixing_code_end_loc": [1071, 3554], "type": "CWE-770", "message": "Discourse is the an open source discussion platform. In affected versions an email activation route can be abused to send mass spam emails. A fix has been included in the latest stable, beta and tests-passed versions of Discourse which rate limits emails. Users are advised to upgrade. Users unable to upgrade should manually rate limit email.", "other": {"cve": {"id": "CVE-2022-31184", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T20:15:08.467", "lastModified": "2022-08-09T18:48:58.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is the an open source discussion platform. In affected versions an email activation route can be abused to send mass spam emails. A fix has been included in the latest stable, beta and tests-passed versions of Discourse which rate limits emails. Users are advised to upgrade. Users unable to upgrade should manually rate limit email."}, {"lang": "es", "value": "Discourse es una plataforma de discusi\u00f3n de c\u00f3digo abierto. En las versiones afectadas puede abusarse de una ruta de activaci\u00f3n del correo electr\u00f3nico para enviar correos masivos de spam. Ha sido incluida una correcci\u00f3n en las \u00faltimas versiones estables, beta y de prueba de Discourse que limita los correos electr\u00f3nicos. Es recomendado a usuarios actualizar. Los usuarios que no puedan actualizarse deber\u00e1n limitar manualmente la tasa de los correos electr\u00f3nicos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.6", "matchCriteriaId": "DE6A1B91-52FA-4FFE-96D0-DC25865E15FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "0086484D-0164-449C-8AAE-BE7479CB9706"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "F9D1B031-96C7-44C0-A0A0-F67ABE55C93C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "750D2AD9-35E7-4AC7-9C22-AA90DAA34F3F"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/af1cb735db7fb73217b85d22dbadd1bc824ac0b0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-m5w9-8gp8-2hrf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/af1cb735db7fb73217b85d22dbadd1bc824ac0b0"}}