{"buggy_code": ["\"\"\"HTTP views handle login flow.\n\n# GET /auth/providers\n\nReturn a list of auth providers. Example:\n\n[\n    {\n        \"name\": \"Local\",\n        \"id\": null,\n        \"type\": \"local_provider\",\n    }\n]\n\n\n# POST /auth/login_flow\n\nCreate a login flow. Will return the first step of the flow.\n\nPass in parameter 'client_id' and 'redirect_url' validate by indieauth.\n\nPass in parameter 'handler' to specify the auth provider to use. Auth providers\nare identified by type and id.\n\nAnd optional parameter 'type' has to set as 'link_user' if login flow used for\nlink credential to exist user. Default 'type' is 'authorize'.\n\n{\n    \"client_id\": \"https://hassbian.local:8123/\",\n    \"handler\": [\"local_provider\", null],\n    \"redirect_url\": \"https://hassbian.local:8123/\",\n    \"type': \"authorize\"\n}\n\nReturn value will be a step in a data entry flow. See the docs for data entry\nflow for details.\n\n{\n    \"data_schema\": [\n        {\"name\": \"username\", \"type\": \"string\"},\n        {\"name\": \"password\", \"type\": \"string\"}\n    ],\n    \"errors\": {},\n    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",\n    \"handler\": [\"insecure_example\", null],\n    \"step_id\": \"init\",\n    \"type\": \"form\"\n}\n\n\n# POST /auth/login_flow/{flow_id}\n\nProgress the flow. Most flows will be 1 page, but could optionally add extra\nlogin challenges, like TFA. Once the flow has finished, the returned step will\nhave type FlowResultType.CREATE_ENTRY and \"result\" key will contain an authorization code.\nThe authorization code associated with an authorized user by default, it will\nassociate with an credential if \"type\" set to \"link_user\" in\n\"/auth/login_flow\"\n\n{\n    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",\n    \"handler\": [\"insecure_example\", null],\n    \"result\": \"411ee2f916e648d691e937ae9344681e\",\n    \"title\": \"Example\",\n    \"type\": \"create_entry\",\n    \"version\": 1\n}\n\"\"\"\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\nfrom http import HTTPStatus\nfrom ipaddress import ip_address\nfrom typing import TYPE_CHECKING, Any, cast\n\nfrom aiohttp import web\nimport voluptuous as vol\nimport voluptuous_serialize\n\nfrom homeassistant import data_entry_flow\nfrom homeassistant.auth import AuthManagerFlowManager, InvalidAuthError\nfrom homeassistant.auth.models import Credentials\nfrom homeassistant.components import onboarding\nfrom homeassistant.components.http.auth import async_user_not_allowed_do_auth\nfrom homeassistant.components.http.ban import (\n    log_invalid_auth,\n    process_success_login,\n    process_wrong_login,\n)\nfrom homeassistant.components.http.data_validator import RequestDataValidator\nfrom homeassistant.components.http.view import HomeAssistantView\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.helpers.network import is_cloud_connection\nfrom homeassistant.util.network import is_local\n\nfrom . import indieauth\n\nif TYPE_CHECKING:\n    from homeassistant.auth.providers.trusted_networks import (\n        TrustedNetworksAuthProvider,\n    )\n\n    from . import StoreResultType\n\n\nasync def async_setup(\n    hass: HomeAssistant, store_result: Callable[[str, Credentials], str]\n) -> None:\n    \"\"\"Component to allow users to login.\"\"\"\n    hass.http.register_view(WellKnownOAuthInfoView)\n    hass.http.register_view(AuthProvidersView)\n    hass.http.register_view(LoginFlowIndexView(hass.auth.login_flow, store_result))\n    hass.http.register_view(LoginFlowResourceView(hass.auth.login_flow, store_result))\n\n\nclass WellKnownOAuthInfoView(HomeAssistantView):\n    \"\"\"View to host the OAuth2 information.\"\"\"\n\n    requires_auth = False\n    url = \"/.well-known/oauth-authorization-server\"\n    name = \"well-known/oauth-authorization-server\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Return the well known OAuth2 authorization info.\"\"\"\n        return self.json(\n            {\n                \"authorization_endpoint\": \"/auth/authorize\",\n                \"token_endpoint\": \"/auth/token\",\n                \"revocation_endpoint\": \"/auth/revoke\",\n                \"response_types_supported\": [\"code\"],\n                \"service_documentation\": (\n                    \"https://developers.home-assistant.io/docs/auth_api\"\n                ),\n            }\n        )\n\n\nclass AuthProvidersView(HomeAssistantView):\n    \"\"\"View to get available auth providers.\"\"\"\n\n    url = \"/auth/providers\"\n    name = \"api:auth:providers\"\n    requires_auth = False\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Get available auth providers.\"\"\"\n        hass: HomeAssistant = request.app[\"hass\"]\n        if not onboarding.async_is_user_onboarded(hass):\n            return self.json_message(\n                message=\"Onboarding not finished\",\n                status_code=HTTPStatus.BAD_REQUEST,\n                message_code=\"onboarding_required\",\n            )\n\n        try:\n            remote_address = ip_address(request.remote)  # type: ignore[arg-type]\n        except ValueError:\n            return self.json_message(\n                message=\"Invalid remote IP\",\n                status_code=HTTPStatus.BAD_REQUEST,\n                message_code=\"invalid_remote_ip\",\n            )\n\n        cloud_connection = is_cloud_connection(hass)\n\n        providers = []\n        for provider in hass.auth.auth_providers:\n            additional_data = {}\n\n            if provider.type == \"trusted_networks\":\n                if cloud_connection:\n                    # Skip quickly as trusted networks are not available on cloud\n                    continue\n\n                try:\n                    cast(\"TrustedNetworksAuthProvider\", provider).async_validate_access(\n                        remote_address\n                    )\n                except InvalidAuthError:\n                    # Not a trusted network, so we don't expose that trusted_network authenticator is setup\n                    continue\n            elif (\n                provider.type == \"homeassistant\"\n                and not cloud_connection\n                and is_local(remote_address)\n                and \"person\" in hass.config.components\n            ):\n                # We are local, return user id and username\n                users = await provider.store.async_get_users()\n                additional_data[\"users\"] = {\n                    user.id: credentials.data[\"username\"]\n                    for user in users\n                    for credentials in user.credentials\n                    if (\n                        credentials.auth_provider_type == provider.type\n                        and credentials.auth_provider_id == provider.id\n                    )\n                }\n\n            providers.append(\n                {\n                    \"name\": provider.name,\n                    \"id\": provider.id,\n                    \"type\": provider.type,\n                    **additional_data,\n                }\n            )\n\n        return self.json(providers)\n\n\ndef _prepare_result_json(\n    result: data_entry_flow.FlowResult,\n) -> data_entry_flow.FlowResult:\n    \"\"\"Convert result to JSON.\"\"\"\n    if result[\"type\"] == data_entry_flow.FlowResultType.CREATE_ENTRY:\n        data = result.copy()\n        data.pop(\"result\")\n        data.pop(\"data\")\n        return data\n\n    if result[\"type\"] != data_entry_flow.FlowResultType.FORM:\n        return result\n\n    data = result.copy()\n\n    if (schema := data[\"data_schema\"]) is None:\n        data[\"data_schema\"] = []\n    else:\n        data[\"data_schema\"] = voluptuous_serialize.convert(schema)\n\n    return data\n\n\nclass LoginFlowBaseView(HomeAssistantView):\n    \"\"\"Base class for the login views.\"\"\"\n\n    requires_auth = False\n\n    def __init__(\n        self,\n        flow_mgr: AuthManagerFlowManager,\n        store_result: StoreResultType,\n    ) -> None:\n        \"\"\"Initialize the flow manager index view.\"\"\"\n        self._flow_mgr = flow_mgr\n        self._store_result = store_result\n\n    async def _async_flow_result_to_response(\n        self,\n        request: web.Request,\n        client_id: str,\n        result: data_entry_flow.FlowResult,\n    ) -> web.Response:\n        \"\"\"Convert the flow result to a response.\"\"\"\n        if result[\"type\"] != data_entry_flow.FlowResultType.CREATE_ENTRY:\n            # @log_invalid_auth does not work here since it returns HTTP 200.\n            # We need to manually log failed login attempts.\n            if (\n                result[\"type\"] == data_entry_flow.FlowResultType.FORM\n                and (errors := result.get(\"errors\"))\n                and errors.get(\"base\")\n                in (\n                    \"invalid_auth\",\n                    \"invalid_code\",\n                )\n            ):\n                await process_wrong_login(request)\n            return self.json(_prepare_result_json(result))\n\n        hass: HomeAssistant = request.app[\"hass\"]\n\n        if not await indieauth.verify_redirect_uri(\n            hass, client_id, result[\"context\"][\"redirect_uri\"]\n        ):\n            return self.json_message(\"Invalid redirect URI\", HTTPStatus.FORBIDDEN)\n\n        result.pop(\"data\")\n        result.pop(\"context\")\n\n        result_obj: Credentials = result.pop(\"result\")\n\n        # Result can be None if credential was never linked to a user before.\n        user = await hass.auth.async_get_user_by_credentials(result_obj)\n\n        if user is not None and (\n            user_access_error := async_user_not_allowed_do_auth(hass, user)\n        ):\n            return self.json_message(\n                f\"Login blocked: {user_access_error}\", HTTPStatus.FORBIDDEN\n            )\n\n        process_success_login(request)\n        result[\"result\"] = self._store_result(client_id, result_obj)\n\n        return self.json(result)\n\n\nclass LoginFlowIndexView(LoginFlowBaseView):\n    \"\"\"View to create a login flow.\"\"\"\n\n    url = \"/auth/login_flow\"\n    name = \"api:auth:login_flow\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Do not allow index of flows in progress.\"\"\"\n        return web.Response(status=HTTPStatus.METHOD_NOT_ALLOWED)\n\n    @RequestDataValidator(\n        vol.Schema(\n            {\n                vol.Required(\"client_id\"): str,\n                vol.Required(\"handler\"): vol.Any(str, list),\n                vol.Required(\"redirect_uri\"): str,\n                vol.Optional(\"type\", default=\"authorize\"): str,\n            }\n        )\n    )\n    @log_invalid_auth\n    async def post(self, request: web.Request, data: dict[str, Any]) -> web.Response:\n        \"\"\"Create a new login flow.\"\"\"\n        client_id: str = data[\"client_id\"]\n        redirect_uri: str = data[\"redirect_uri\"]\n\n        if not indieauth.verify_client_id(client_id):\n            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)\n\n        handler: tuple[str, ...] | str\n        if isinstance(data[\"handler\"], list):\n            handler = tuple(data[\"handler\"])\n        else:\n            handler = data[\"handler\"]\n\n        try:\n            result = await self._flow_mgr.async_init(\n                handler,  # type: ignore[arg-type]\n                context={\n                    \"ip_address\": ip_address(request.remote),  # type: ignore[arg-type]\n                    \"credential_only\": data.get(\"type\") == \"link_user\",\n                    \"redirect_uri\": redirect_uri,\n                },\n            )\n        except data_entry_flow.UnknownHandler:\n            return self.json_message(\"Invalid handler specified\", HTTPStatus.NOT_FOUND)\n        except data_entry_flow.UnknownStep:\n            return self.json_message(\n                \"Handler does not support init\", HTTPStatus.BAD_REQUEST\n            )\n\n        return await self._async_flow_result_to_response(request, client_id, result)\n\n\nclass LoginFlowResourceView(LoginFlowBaseView):\n    \"\"\"View to interact with the flow manager.\"\"\"\n\n    url = \"/auth/login_flow/{flow_id}\"\n    name = \"api:auth:login_flow:resource\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Do not allow getting status of a flow in progress.\"\"\"\n        return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)\n\n    @RequestDataValidator(\n        vol.Schema(\n            {vol.Required(\"client_id\"): str},\n            extra=vol.ALLOW_EXTRA,\n        )\n    )\n    @log_invalid_auth\n    async def post(\n        self, request: web.Request, data: dict[str, Any], flow_id: str\n    ) -> web.Response:\n        \"\"\"Handle progressing a login flow request.\"\"\"\n        client_id: str = data.pop(\"client_id\")\n\n        if not indieauth.verify_client_id(client_id):\n            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)\n\n        try:\n            # do not allow change ip during login flow\n            flow = self._flow_mgr.async_get(flow_id)\n            if flow[\"context\"][\"ip_address\"] != ip_address(request.remote):  # type: ignore[arg-type]\n                return self.json_message(\"IP address changed\", HTTPStatus.BAD_REQUEST)\n            result = await self._flow_mgr.async_configure(flow_id, data)\n        except data_entry_flow.UnknownFlow:\n            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)\n        except vol.Invalid:\n            return self.json_message(\"User input malformed\", HTTPStatus.BAD_REQUEST)\n\n        return await self._async_flow_result_to_response(request, client_id, result)\n\n    async def delete(self, request: web.Request, flow_id: str) -> web.Response:\n        \"\"\"Cancel a flow in progress.\"\"\"\n        try:\n            self._flow_mgr.async_abort(flow_id)\n        except data_entry_flow.UnknownFlow:\n            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)\n\n        return self.json_message(\"Flow aborted\")\n", "\"\"\"Support for tracking people.\"\"\"\nfrom __future__ import annotations\n\nfrom http import HTTPStatus\nfrom ipaddress import ip_address\nimport logging\nfrom typing import Any\n\nfrom aiohttp import web\nimport voluptuous as vol\n\nfrom homeassistant.auth import EVENT_USER_REMOVED\nfrom homeassistant.components import persistent_notification, websocket_api\nfrom homeassistant.components.device_tracker import (\n    ATTR_SOURCE_TYPE,\n    DOMAIN as DEVICE_TRACKER_DOMAIN,\n    SourceType,\n)\nfrom homeassistant.components.http.view import HomeAssistantView\nfrom homeassistant.const import (\n    ATTR_EDITABLE,\n    ATTR_ENTITY_ID,\n    ATTR_GPS_ACCURACY,\n    ATTR_ID,\n    ATTR_LATITUDE,\n    ATTR_LONGITUDE,\n    ATTR_NAME,\n    CONF_ID,\n    CONF_NAME,\n    CONF_TYPE,\n    EVENT_HOMEASSISTANT_START,\n    SERVICE_RELOAD,\n    STATE_HOME,\n    STATE_NOT_HOME,\n    STATE_UNAVAILABLE,\n    STATE_UNKNOWN,\n)\nfrom homeassistant.core import (\n    Event,\n    HomeAssistant,\n    ServiceCall,\n    State,\n    callback,\n    split_entity_id,\n)\nfrom homeassistant.helpers import (\n    collection,\n    config_validation as cv,\n    entity_registry as er,\n    service,\n)\nfrom homeassistant.helpers.entity_component import EntityComponent\nfrom homeassistant.helpers.event import async_track_state_change_event\nfrom homeassistant.helpers.network import is_cloud_connection\nfrom homeassistant.helpers.restore_state import RestoreEntity\nfrom homeassistant.helpers.storage import Store\nfrom homeassistant.helpers.typing import ConfigType\nfrom homeassistant.loader import bind_hass\nfrom homeassistant.util.network import is_local\n\n_LOGGER = logging.getLogger(__name__)\n\nATTR_SOURCE = \"source\"\nATTR_USER_ID = \"user_id\"\nATTR_DEVICE_TRACKERS = \"device_trackers\"\n\nCONF_DEVICE_TRACKERS = \"device_trackers\"\nCONF_USER_ID = \"user_id\"\nCONF_PICTURE = \"picture\"\n\nDOMAIN = \"person\"\n\nSTORAGE_KEY = DOMAIN\nSTORAGE_VERSION = 2\n# Device tracker states to ignore\nIGNORE_STATES = (STATE_UNKNOWN, STATE_UNAVAILABLE)\n\nPERSON_SCHEMA = vol.Schema(\n    {\n        vol.Required(CONF_ID): cv.string,\n        vol.Required(CONF_NAME): cv.string,\n        vol.Optional(CONF_USER_ID): cv.string,\n        vol.Optional(CONF_DEVICE_TRACKERS, default=[]): vol.All(\n            cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)\n        ),\n        vol.Optional(CONF_PICTURE): cv.string,\n    }\n)\n\nCONFIG_SCHEMA = vol.Schema(\n    {\n        vol.Optional(DOMAIN, default=[]): vol.All(\n            cv.ensure_list, cv.remove_falsy, [PERSON_SCHEMA]\n        )\n    },\n    extra=vol.ALLOW_EXTRA,\n)\n\n\n@bind_hass\nasync def async_create_person(hass, name, *, user_id=None, device_trackers=None):\n    \"\"\"Create a new person.\"\"\"\n    await hass.data[DOMAIN][1].async_create_item(\n        {\n            ATTR_NAME: name,\n            ATTR_USER_ID: user_id,\n            CONF_DEVICE_TRACKERS: device_trackers or [],\n        }\n    )\n\n\n@bind_hass\nasync def async_add_user_device_tracker(\n    hass: HomeAssistant, user_id: str, device_tracker_entity_id: str\n):\n    \"\"\"Add a device tracker to a person linked to a user.\"\"\"\n    coll: PersonStorageCollection = hass.data[DOMAIN][1]\n\n    for person in coll.async_items():\n        if person.get(ATTR_USER_ID) != user_id:\n            continue\n\n        device_trackers = person[CONF_DEVICE_TRACKERS]\n\n        if device_tracker_entity_id in device_trackers:\n            return\n\n        await coll.async_update_item(\n            person[CONF_ID],\n            {CONF_DEVICE_TRACKERS: device_trackers + [device_tracker_entity_id]},\n        )\n        break\n\n\n@callback\ndef persons_with_entity(hass: HomeAssistant, entity_id: str) -> list[str]:\n    \"\"\"Return all persons that reference the entity.\"\"\"\n    if (\n        DOMAIN not in hass.data\n        or split_entity_id(entity_id)[0] != DEVICE_TRACKER_DOMAIN\n    ):\n        return []\n\n    component: EntityComponent[Person] = hass.data[DOMAIN][2]\n\n    return [\n        person_entity.entity_id\n        for person_entity in component.entities\n        if entity_id in person_entity.device_trackers\n    ]\n\n\n@callback\ndef entities_in_person(hass: HomeAssistant, entity_id: str) -> list[str]:\n    \"\"\"Return all entities belonging to a person.\"\"\"\n    if DOMAIN not in hass.data:\n        return []\n\n    component: EntityComponent[Person] = hass.data[DOMAIN][2]\n\n    if (person_entity := component.get_entity(entity_id)) is None:\n        return []\n\n    return person_entity.device_trackers\n\n\nCREATE_FIELDS = {\n    vol.Required(CONF_NAME): vol.All(str, vol.Length(min=1)),\n    vol.Optional(CONF_USER_ID): vol.Any(str, None),\n    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(\n        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)\n    ),\n    vol.Optional(CONF_PICTURE): vol.Any(str, None),\n}\n\n\nUPDATE_FIELDS = {\n    vol.Optional(CONF_NAME): vol.All(str, vol.Length(min=1)),\n    vol.Optional(CONF_USER_ID): vol.Any(str, None),\n    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(\n        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)\n    ),\n    vol.Optional(CONF_PICTURE): vol.Any(str, None),\n}\n\n\nclass PersonStore(Store):\n    \"\"\"Person storage.\"\"\"\n\n    async def _async_migrate_func(self, old_major_version, old_minor_version, old_data):\n        \"\"\"Migrate to the new version.\n\n        Migrate storage to use format of collection helper.\n        \"\"\"\n        return {\"items\": old_data[\"persons\"]}\n\n\nclass PersonStorageCollection(collection.DictStorageCollection):\n    \"\"\"Person collection stored in storage.\"\"\"\n\n    CREATE_SCHEMA = vol.Schema(CREATE_FIELDS)\n    UPDATE_SCHEMA = vol.Schema(UPDATE_FIELDS)\n\n    def __init__(\n        self,\n        store: Store,\n        id_manager: collection.IDManager,\n        yaml_collection: collection.YamlCollection,\n    ) -> None:\n        \"\"\"Initialize a person storage collection.\"\"\"\n        super().__init__(store, id_manager)\n        self.yaml_collection = yaml_collection\n\n    async def _async_load_data(self) -> collection.SerializedStorageCollection | None:\n        \"\"\"Load the data.\n\n        A past bug caused onboarding to create invalid person objects.\n        This patches it up.\n        \"\"\"\n        data = await super()._async_load_data()\n\n        if data is None:\n            return data\n\n        for person in data[\"items\"]:\n            if person[CONF_DEVICE_TRACKERS] is None:\n                person[CONF_DEVICE_TRACKERS] = []\n\n        return data\n\n    async def async_load(self) -> None:\n        \"\"\"Load the Storage collection.\"\"\"\n        await super().async_load()\n        self.hass.bus.async_listen(\n            er.EVENT_ENTITY_REGISTRY_UPDATED,\n            self._entity_registry_updated,\n            event_filter=self._entity_registry_filter,\n        )\n\n    @callback\n    def _entity_registry_filter(self, event: Event) -> bool:\n        \"\"\"Filter entity registry events.\"\"\"\n        return (\n            event.data[\"action\"] == \"remove\"\n            and split_entity_id(event.data[ATTR_ENTITY_ID])[0] == \"device_tracker\"\n        )\n\n    async def _entity_registry_updated(self, event: Event) -> None:\n        \"\"\"Handle entity registry updated.\"\"\"\n        entity_id = event.data[ATTR_ENTITY_ID]\n        for person in list(self.data.values()):\n            if entity_id not in person[CONF_DEVICE_TRACKERS]:\n                continue\n\n            await self.async_update_item(\n                person[CONF_ID],\n                {\n                    CONF_DEVICE_TRACKERS: [\n                        devt\n                        for devt in person[CONF_DEVICE_TRACKERS]\n                        if devt != entity_id\n                    ]\n                },\n            )\n\n    async def _process_create_data(self, data: dict) -> dict:\n        \"\"\"Validate the config is valid.\"\"\"\n        data = self.CREATE_SCHEMA(data)\n\n        if (user_id := data.get(CONF_USER_ID)) is not None:\n            await self._validate_user_id(user_id)\n\n        return data\n\n    @callback\n    def _get_suggested_id(self, info: dict) -> str:\n        \"\"\"Suggest an ID based on the config.\"\"\"\n        return info[CONF_NAME]\n\n    async def _update_data(self, item: dict, update_data: dict) -> dict:\n        \"\"\"Return a new updated data object.\"\"\"\n        update_data = self.UPDATE_SCHEMA(update_data)\n\n        user_id = update_data.get(CONF_USER_ID)\n\n        if user_id is not None and user_id != item.get(CONF_USER_ID):\n            await self._validate_user_id(user_id)\n\n        return {**item, **update_data}\n\n    async def _validate_user_id(self, user_id):\n        \"\"\"Validate the used user_id.\"\"\"\n        if await self.hass.auth.async_get_user(user_id) is None:\n            raise ValueError(\"User does not exist\")\n\n        for persons in (self.data.values(), self.yaml_collection.async_items()):\n            if any(person for person in persons if person.get(CONF_USER_ID) == user_id):\n                raise ValueError(\"User already taken\")\n\n\nasync def filter_yaml_data(hass: HomeAssistant, persons: list[dict]) -> list[dict]:\n    \"\"\"Validate YAML data that we can't validate via schema.\"\"\"\n    filtered = []\n    person_invalid_user = []\n\n    for person_conf in persons:\n        user_id = person_conf.get(CONF_USER_ID)\n\n        if user_id is not None and await hass.auth.async_get_user(user_id) is None:\n            _LOGGER.error(\n                \"Invalid user_id detected for person %s\",\n                person_conf[CONF_ID],\n            )\n            person_invalid_user.append(\n                f\"- Person {person_conf[CONF_NAME]} (id: {person_conf[CONF_ID]}) points\"\n                f\" at invalid user {user_id}\"\n            )\n            continue\n\n        filtered.append(person_conf)\n\n    if person_invalid_user:\n        persistent_notification.async_create(\n            hass,\n            f\"\"\"\nThe following persons point at invalid users:\n\n{\"- \".join(person_invalid_user)}\n            \"\"\",\n            \"Invalid Person Configuration\",\n            DOMAIN,\n        )\n\n    return filtered\n\n\nasync def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:\n    \"\"\"Set up the person component.\"\"\"\n    entity_component = EntityComponent[Person](_LOGGER, DOMAIN, hass)\n    id_manager = collection.IDManager()\n    yaml_collection = collection.YamlCollection(\n        logging.getLogger(f\"{__name__}.yaml_collection\"), id_manager\n    )\n    storage_collection = PersonStorageCollection(\n        PersonStore(hass, STORAGE_VERSION, STORAGE_KEY),\n        id_manager,\n        yaml_collection,\n    )\n\n    collection.sync_entity_lifecycle(\n        hass, DOMAIN, DOMAIN, entity_component, yaml_collection, Person\n    )\n    collection.sync_entity_lifecycle(\n        hass, DOMAIN, DOMAIN, entity_component, storage_collection, Person\n    )\n\n    await yaml_collection.async_load(\n        await filter_yaml_data(hass, config.get(DOMAIN, []))\n    )\n    await storage_collection.async_load()\n\n    hass.data[DOMAIN] = (yaml_collection, storage_collection, entity_component)\n\n    collection.DictStorageCollectionWebsocket(\n        storage_collection, DOMAIN, DOMAIN, CREATE_FIELDS, UPDATE_FIELDS\n    ).async_setup(hass, create_list=False)\n\n    websocket_api.async_register_command(hass, ws_list_person)\n\n    async def _handle_user_removed(event: Event) -> None:\n        \"\"\"Handle a user being removed.\"\"\"\n        user_id = event.data[ATTR_USER_ID]\n        for person in storage_collection.async_items():\n            if person[CONF_USER_ID] == user_id:\n                await storage_collection.async_update_item(\n                    person[CONF_ID], {CONF_USER_ID: None}\n                )\n\n    hass.bus.async_listen(EVENT_USER_REMOVED, _handle_user_removed)\n\n    async def async_reload_yaml(call: ServiceCall) -> None:\n        \"\"\"Reload YAML.\"\"\"\n        conf = await entity_component.async_prepare_reload(skip_reset=True)\n        if conf is None:\n            return\n        await yaml_collection.async_load(\n            await filter_yaml_data(hass, conf.get(DOMAIN, []))\n        )\n\n    service.async_register_admin_service(\n        hass, DOMAIN, SERVICE_RELOAD, async_reload_yaml\n    )\n\n    hass.http.register_view(ListPersonsView)\n\n    return True\n\n\nclass Person(collection.CollectionEntity, RestoreEntity):\n    \"\"\"Represent a tracked person.\"\"\"\n\n    _entity_component_unrecorded_attributes = frozenset({ATTR_DEVICE_TRACKERS})\n\n    _attr_should_poll = False\n    editable: bool\n\n    def __init__(self, config):\n        \"\"\"Set up person.\"\"\"\n        self._config = config\n        self._latitude = None\n        self._longitude = None\n        self._gps_accuracy = None\n        self._source = None\n        self._state = None\n        self._unsub_track_device = None\n\n    @classmethod\n    def from_storage(cls, config: ConfigType):\n        \"\"\"Return entity instance initialized from storage.\"\"\"\n        person = cls(config)\n        person.editable = True\n        return person\n\n    @classmethod\n    def from_yaml(cls, config: ConfigType):\n        \"\"\"Return entity instance initialized from yaml.\"\"\"\n        person = cls(config)\n        person.editable = False\n        return person\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the entity.\"\"\"\n        return self._config[CONF_NAME]\n\n    @property\n    def entity_picture(self) -> str | None:\n        \"\"\"Return entity picture.\"\"\"\n        return self._config.get(CONF_PICTURE)\n\n    @property\n    def state(self):\n        \"\"\"Return the state of the person.\"\"\"\n        return self._state\n\n    @property\n    def extra_state_attributes(self):\n        \"\"\"Return the state attributes of the person.\"\"\"\n        data = {ATTR_EDITABLE: self.editable, ATTR_ID: self.unique_id}\n        if self._latitude is not None:\n            data[ATTR_LATITUDE] = self._latitude\n        if self._longitude is not None:\n            data[ATTR_LONGITUDE] = self._longitude\n        if self._gps_accuracy is not None:\n            data[ATTR_GPS_ACCURACY] = self._gps_accuracy\n        if self._source is not None:\n            data[ATTR_SOURCE] = self._source\n        if (user_id := self._config.get(CONF_USER_ID)) is not None:\n            data[ATTR_USER_ID] = user_id\n        data[ATTR_DEVICE_TRACKERS] = self.device_trackers\n        return data\n\n    @property\n    def unique_id(self):\n        \"\"\"Return a unique ID for the person.\"\"\"\n        return self._config[CONF_ID]\n\n    @property\n    def device_trackers(self):\n        \"\"\"Return the device trackers for the person.\"\"\"\n        return self._config[CONF_DEVICE_TRACKERS]\n\n    async def async_added_to_hass(self):\n        \"\"\"Register device trackers.\"\"\"\n        await super().async_added_to_hass()\n        if state := await self.async_get_last_state():\n            self._parse_source_state(state)\n\n        if self.hass.is_running:\n            # Update person now if hass is already running.\n            await self.async_update_config(self._config)\n        else:\n            # Wait for hass start to not have race between person\n            # and device trackers finishing setup.\n            async def person_start_hass(now):\n                await self.async_update_config(self._config)\n\n            self.hass.bus.async_listen_once(\n                EVENT_HOMEASSISTANT_START, person_start_hass\n            )\n\n    async def async_update_config(self, config: ConfigType):\n        \"\"\"Handle when the config is updated.\"\"\"\n        self._config = config\n\n        if self._unsub_track_device is not None:\n            self._unsub_track_device()\n            self._unsub_track_device = None\n\n        if trackers := self._config[CONF_DEVICE_TRACKERS]:\n            _LOGGER.debug(\"Subscribe to device trackers for %s\", self.entity_id)\n\n            self._unsub_track_device = async_track_state_change_event(\n                self.hass, trackers, self._async_handle_tracker_update\n            )\n\n        self._update_state()\n\n    @callback\n    def _async_handle_tracker_update(self, event):\n        \"\"\"Handle the device tracker state changes.\"\"\"\n        self._update_state()\n\n    @callback\n    def _update_state(self):\n        \"\"\"Update the state.\"\"\"\n        latest_non_gps_home = latest_not_home = latest_gps = latest = None\n        for entity_id in self._config[CONF_DEVICE_TRACKERS]:\n            state = self.hass.states.get(entity_id)\n\n            if not state or state.state in IGNORE_STATES:\n                continue\n\n            if state.attributes.get(ATTR_SOURCE_TYPE) == SourceType.GPS:\n                latest_gps = _get_latest(latest_gps, state)\n            elif state.state == STATE_HOME:\n                latest_non_gps_home = _get_latest(latest_non_gps_home, state)\n            elif state.state == STATE_NOT_HOME:\n                latest_not_home = _get_latest(latest_not_home, state)\n\n        if latest_non_gps_home:\n            latest = latest_non_gps_home\n        elif latest_gps:\n            latest = latest_gps\n        else:\n            latest = latest_not_home\n\n        if latest:\n            self._parse_source_state(latest)\n        else:\n            self._state = None\n            self._source = None\n            self._latitude = None\n            self._longitude = None\n            self._gps_accuracy = None\n\n        self.async_write_ha_state()\n\n    @callback\n    def _parse_source_state(self, state):\n        \"\"\"Parse source state and set person attributes.\n\n        This is a device tracker state or the restored person state.\n        \"\"\"\n        self._state = state.state\n        self._source = state.entity_id\n        self._latitude = state.attributes.get(ATTR_LATITUDE)\n        self._longitude = state.attributes.get(ATTR_LONGITUDE)\n        self._gps_accuracy = state.attributes.get(ATTR_GPS_ACCURACY)\n\n\n@websocket_api.websocket_command({vol.Required(CONF_TYPE): \"person/list\"})\ndef ws_list_person(\n    hass: HomeAssistant,\n    connection: websocket_api.ActiveConnection,\n    msg: dict[str, Any],\n) -> None:\n    \"\"\"List persons.\"\"\"\n    yaml, storage, _ = hass.data[DOMAIN]\n    connection.send_result(\n        msg[ATTR_ID], {\"storage\": storage.async_items(), \"config\": yaml.async_items()}\n    )\n\n\ndef _get_latest(prev: State | None, curr: State):\n    \"\"\"Get latest state.\"\"\"\n    if prev is None or curr.last_updated > prev.last_updated:\n        return curr\n    return prev\n\n\nclass ListPersonsView(HomeAssistantView):\n    \"\"\"List all persons if request is made from a local network.\"\"\"\n\n    requires_auth = False\n    url = \"/api/person/list\"\n    name = \"api:person:list\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Return a list of persons if request comes from a local IP.\"\"\"\n        try:\n            remote_address = ip_address(request.remote)  # type: ignore[arg-type]\n        except ValueError:\n            return self.json_message(\n                message=\"Invalid remote IP\",\n                status_code=HTTPStatus.BAD_REQUEST,\n                message_code=\"invalid_remote_ip\",\n            )\n\n        hass: HomeAssistant = request.app[\"hass\"]\n        if is_cloud_connection(hass) or not is_local(remote_address):\n            return self.json_message(\n                message=\"Not local\",\n                status_code=HTTPStatus.BAD_REQUEST,\n                message_code=\"not_local\",\n            )\n\n        yaml, storage, _ = hass.data[DOMAIN]\n        persons = [*yaml.async_items(), *storage.async_items()]\n\n        return self.json(\n            {\n                person[ATTR_USER_ID]: {\n                    ATTR_NAME: person[ATTR_NAME],\n                    CONF_PICTURE: person.get(CONF_PICTURE),\n                }\n                for person in persons\n                if person.get(ATTR_USER_ID)\n            }\n        )\n", "\"\"\"Tests for the login flow.\"\"\"\nfrom collections.abc import Callable\nfrom http import HTTPStatus\nfrom typing import Any\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom homeassistant.auth.models import User\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.setup import async_setup_component\n\nfrom . import BASE_CONFIG, async_setup_auth\n\nfrom tests.common import CLIENT_ID, CLIENT_REDIRECT_URI\nfrom tests.typing import ClientSessionGenerator\n\n_TRUSTED_NETWORKS_CONFIG = {\n    \"type\": \"trusted_networks\",\n    \"trusted_networks\": [\"192.168.0.1\"],\n    \"trusted_users\": {\n        \"192.168.0.1\": [\n            \"a1ab982744b64757bf80515589258924\",\n            {\"group\": \"system-group\"},\n        ]\n    },\n}\n\n\n@pytest.mark.parametrize(\n    (\"provider_configs\", \"ip\", \"expected\"),\n    [\n        (\n            BASE_CONFIG,\n            None,\n            [{\"name\": \"Example\", \"type\": \"insecure_example\", \"id\": None}],\n        ),\n        (\n            [_TRUSTED_NETWORKS_CONFIG],\n            None,\n            [],\n        ),\n        (\n            [_TRUSTED_NETWORKS_CONFIG],\n            \"192.168.0.1\",\n            [{\"name\": \"Trusted Networks\", \"type\": \"trusted_networks\", \"id\": None}],\n        ),\n    ],\n)\nasync def test_fetch_auth_providers(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    provider_configs: list[dict[str, Any]],\n    ip: str | None,\n    expected: list[dict[str, Any]],\n) -> None:\n    \"\"\"Test fetching auth providers.\"\"\"\n    client = await async_setup_auth(\n        hass, aiohttp_client, provider_configs, custom_ip=ip\n    )\n    resp = await client.get(\"/auth/providers\")\n    assert resp.status == HTTPStatus.OK\n    assert await resp.json() == expected\n\n\nasync def _test_fetch_auth_providers_home_assistant(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    ip: str,\n    additional_expected_fn: Callable[[User], dict[str, Any]],\n) -> None:\n    \"\"\"Test fetching auth providers for homeassistant auth provider.\"\"\"\n    client = await async_setup_auth(\n        hass, aiohttp_client, [{\"type\": \"homeassistant\"}], custom_ip=ip\n    )\n\n    provider = hass.auth.auth_providers[0]\n    credentials = await provider.async_get_or_create_credentials({\"username\": \"hello\"})\n    user = await hass.auth.async_get_or_create_user(credentials)\n\n    expected = {\n        \"name\": \"Home Assistant Local\",\n        \"type\": \"homeassistant\",\n        \"id\": None,\n        **additional_expected_fn(user),\n    }\n\n    resp = await client.get(\"/auth/providers\")\n    assert resp.status == HTTPStatus.OK\n    assert await resp.json() == [expected]\n\n\n@pytest.mark.parametrize(\n    \"ip\",\n    [\n        \"192.168.0.10\",\n        \"::ffff:192.168.0.10\",\n        \"1.2.3.4\",\n        \"2001:db8::1\",\n    ],\n)\nasync def test_fetch_auth_providers_home_assistant_person_not_loaded(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    ip: str,\n) -> None:\n    \"\"\"Test fetching auth providers for homeassistant auth provider, where person integration is not loaded.\"\"\"\n    await _test_fetch_auth_providers_home_assistant(\n        hass, aiohttp_client, ip, lambda _: {}\n    )\n\n\n@pytest.mark.parametrize(\n    (\"ip\", \"is_local\"),\n    [\n        (\"192.168.0.10\", True),\n        (\"::ffff:192.168.0.10\", True),\n        (\"1.2.3.4\", False),\n        (\"2001:db8::1\", False),\n    ],\n)\nasync def test_fetch_auth_providers_home_assistant_person_loaded(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    ip: str,\n    is_local: bool,\n) -> None:\n    \"\"\"Test fetching auth providers for homeassistant auth provider, where person integration is loaded.\"\"\"\n    domain = \"person\"\n    config = {domain: {\"id\": \"1234\", \"name\": \"test person\"}}\n    assert await async_setup_component(hass, domain, config)\n\n    await _test_fetch_auth_providers_home_assistant(\n        hass,\n        aiohttp_client,\n        ip,\n        lambda user: {\"users\": {user.id: user.name}} if is_local else {},\n    )\n\n\nasync def test_fetch_auth_providers_onboarding(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test fetching auth providers.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client)\n    with patch(\n        \"homeassistant.components.onboarding.async_is_user_onboarded\",\n        return_value=False,\n    ):\n        resp = await client.get(\"/auth/providers\")\n    assert resp.status == HTTPStatus.BAD_REQUEST\n    assert await resp.json() == {\n        \"message\": \"Onboarding not finished\",\n        \"code\": \"onboarding_required\",\n    }\n\n\nasync def test_cannot_get_flows_in_progress(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test we cannot get flows in progress.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, [])\n    resp = await client.get(\"/auth/login_flow\")\n    assert resp.status == HTTPStatus.METHOD_NOT_ALLOWED\n\n\nasync def test_invalid_username_password(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test we cannot get flows in progress.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client)\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    # Incorrect username\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"wrong-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert step[\"step_id\"] == \"init\"\n    assert step[\"errors\"][\"base\"] == \"invalid_auth\"\n\n    # Incorrect password\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"wrong-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert step[\"step_id\"] == \"init\"\n    assert step[\"errors\"][\"base\"] == \"invalid_auth\"\n\n    # Incorrect username and invalid redirect URI fails on wrong login\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"wrong-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert step[\"step_id\"] == \"init\"\n    assert step[\"errors\"][\"base\"] == \"invalid_auth\"\n\n\nasync def test_invalid_redirect_uri(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test invalid redirect URI.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client)\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": \"https://some-other-domain.com\",\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    with patch(\n        \"homeassistant.components.auth.indieauth.fetch_redirect_uris\", return_value=[]\n    ), patch(\n        \"homeassistant.components.http.ban.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.FORBIDDEN\n    data = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert data[\"message\"] == \"Invalid redirect URI\"\n\n\nasync def test_login_exist_user(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in with exist user.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    cred = await hass.auth.auth_providers[0].async_get_or_create_credentials(\n        {\"username\": \"test-user\"}\n    )\n    await hass.auth.async_get_or_create_user(cred)\n\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_success_login\"\n    ) as mock_process_success_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert step[\"type\"] == \"create_entry\"\n    assert len(step[\"result\"]) > 1\n    assert len(mock_process_success_login.mock_calls) == 1\n\n\nasync def test_login_local_only_user(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in with local only user.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    cred = await hass.auth.auth_providers[0].async_get_or_create_credentials(\n        {\"username\": \"test-user\"}\n    )\n    user = await hass.auth.async_get_or_create_user(cred)\n    await hass.auth.async_update_user(user, local_only=True)\n\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    with patch(\n        \"homeassistant.components.auth.login_flow.async_user_not_allowed_do_auth\",\n        return_value=\"User is local only\",\n    ) as mock_not_allowed_do_auth:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.FORBIDDEN\n    assert len(mock_not_allowed_do_auth.mock_calls) == 1\n    assert await resp.json() == {\"message\": \"Login blocked: User is local only\"}\n\n\nasync def test_login_exist_user_ip_changes(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in and the ip address changes results in an rejection.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    cred = await hass.auth.auth_providers[0].async_get_or_create_credentials(\n        {\"username\": \"test-user\"}\n    )\n    await hass.auth.async_get_or_create_user(cred)\n\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == 200\n    step = await resp.json()\n\n    #\n    # Here we modify the ip_address in the context to make sure\n    # when ip address changes in the middle of the login flow we prevent logins.\n    #\n    # This method was chosen because it seemed less likely to break\n    # vs patching aiohttp internals to fake the ip address\n    #\n    for flow_id, flow in hass.auth.login_flow._progress.items():\n        assert flow_id == step[\"flow_id\"]\n        flow.context[\"ip_address\"] = \"10.2.3.1\"\n\n    resp = await client.post(\n        f\"/auth/login_flow/{step['flow_id']}\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n            \"username\": \"test-user\",\n            \"password\": \"test-pass\",\n        },\n    )\n\n    assert resp.status == 400\n    response = await resp.json()\n    assert response == {\"message\": \"IP address changed\"}\n\n\nasync def test_well_known_auth_info(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in and the ip address changes results in an rejection.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    resp = await client.get(\n        \"/.well-known/oauth-authorization-server\",\n    )\n    assert resp.status == 200\n    assert await resp.json() == {\n        \"authorization_endpoint\": \"/auth/authorize\",\n        \"token_endpoint\": \"/auth/token\",\n        \"revocation_endpoint\": \"/auth/revoke\",\n        \"response_types_supported\": [\"code\"],\n        \"service_documentation\": \"https://developers.home-assistant.io/docs/auth_api\",\n    }\n", "\"\"\"The tests for the person component.\"\"\"\nfrom collections.abc import Callable\nfrom http import HTTPStatus\nfrom typing import Any\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom homeassistant.components import person\nfrom homeassistant.components.device_tracker import ATTR_SOURCE_TYPE, SourceType\nfrom homeassistant.components.person import (\n    ATTR_DEVICE_TRACKERS,\n    ATTR_SOURCE,\n    ATTR_USER_ID,\n    DOMAIN,\n)\nfrom homeassistant.const import (\n    ATTR_ENTITY_PICTURE,\n    ATTR_GPS_ACCURACY,\n    ATTR_ID,\n    ATTR_LATITUDE,\n    ATTR_LONGITUDE,\n    EVENT_HOMEASSISTANT_START,\n    SERVICE_RELOAD,\n    STATE_UNKNOWN,\n)\nfrom homeassistant.core import Context, CoreState, HomeAssistant, State\nfrom homeassistant.helpers import entity_registry as er\nfrom homeassistant.setup import async_setup_component\n\nfrom .conftest import DEVICE_TRACKER, DEVICE_TRACKER_2\n\nfrom tests.common import MockUser, mock_component, mock_restore_cache\nfrom tests.test_util import mock_real_ip\nfrom tests.typing import ClientSessionGenerator, WebSocketGenerator\n\n\nasync def test_minimal_setup(hass: HomeAssistant) -> None:\n    \"\"\"Test minimal config with only name.\"\"\"\n    config = {DOMAIN: {\"id\": \"1234\", \"name\": \"test person\"}}\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.test_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) is None\n    assert state.attributes.get(ATTR_ENTITY_PICTURE) is None\n\n\nasync def test_setup_no_id(hass: HomeAssistant) -> None:\n    \"\"\"Test config with no id.\"\"\"\n    config = {DOMAIN: {\"name\": \"test user\"}}\n    assert not await async_setup_component(hass, DOMAIN, config)\n\n\nasync def test_setup_no_name(hass: HomeAssistant) -> None:\n    \"\"\"Test config with no name.\"\"\"\n    config = {DOMAIN: {\"id\": \"1234\"}}\n    assert not await async_setup_component(hass, DOMAIN, config)\n\n\nasync def test_setup_user_id(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test config with user id.\"\"\"\n    user_id = hass_admin_user.id\n    config = {DOMAIN: {\"id\": \"1234\", \"name\": \"test person\", \"user_id\": user_id}}\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.test_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n\n\nasync def test_valid_invalid_user_ids(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test a person with valid user id and a person with invalid user id .\"\"\"\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: [\n            {\"id\": \"1234\", \"name\": \"test valid user\", \"user_id\": user_id},\n            {\"id\": \"5678\", \"name\": \"test bad user\", \"user_id\": \"bad_user_id\"},\n        ]\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.test_valid_user\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    state = hass.states.get(\"person.test_bad_user\")\n    assert state is None\n\n\nasync def test_setup_tracker(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test set up person with one device tracker.\"\"\"\n    hass.state = CoreState.not_running\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": DEVICE_TRACKER,\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [DEVICE_TRACKER]\n\n    hass.states.async_set(\n        DEVICE_TRACKER,\n        \"not_home\",\n        {ATTR_LATITUDE: 10.123456, ATTR_LONGITUDE: 11.123456, ATTR_GPS_ACCURACY: 10},\n    )\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) == 10.123456\n    assert state.attributes.get(ATTR_LONGITUDE) == 11.123456\n    assert state.attributes.get(ATTR_GPS_ACCURACY) == 10\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [DEVICE_TRACKER]\n\n\nasync def test_setup_two_trackers(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test set up person with two device trackers.\"\"\"\n    hass.state = CoreState.not_running\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": [DEVICE_TRACKER, DEVICE_TRACKER_2],\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"home\", {ATTR_SOURCE_TYPE: SourceType.ROUTER})\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_GPS_ACCURACY) is None\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [\n        DEVICE_TRACKER,\n        DEVICE_TRACKER_2,\n    ]\n\n    hass.states.async_set(\n        DEVICE_TRACKER_2,\n        \"not_home\",\n        {\n            ATTR_LATITUDE: 12.123456,\n            ATTR_LONGITUDE: 13.123456,\n            ATTR_GPS_ACCURACY: 12,\n            ATTR_SOURCE_TYPE: SourceType.GPS,\n        },\n    )\n    await hass.async_block_till_done()\n    hass.states.async_set(\n        DEVICE_TRACKER, \"not_home\", {ATTR_SOURCE_TYPE: SourceType.ROUTER}\n    )\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) == 12.123456\n    assert state.attributes.get(ATTR_LONGITUDE) == 13.123456\n    assert state.attributes.get(ATTR_GPS_ACCURACY) == 12\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER_2\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [\n        DEVICE_TRACKER,\n        DEVICE_TRACKER_2,\n    ]\n\n    hass.states.async_set(DEVICE_TRACKER_2, \"zone1\", {ATTR_SOURCE_TYPE: SourceType.GPS})\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"zone1\"\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER_2\n\n    hass.states.async_set(DEVICE_TRACKER, \"home\", {ATTR_SOURCE_TYPE: SourceType.ROUTER})\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER_2, \"zone2\", {ATTR_SOURCE_TYPE: SourceType.GPS})\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n\n\nasync def test_ignore_unavailable_states(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test set up person with two device trackers, one unavailable.\"\"\"\n    hass.state = CoreState.not_running\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": [DEVICE_TRACKER, DEVICE_TRACKER_2],\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"unavailable\")\n    await hass.async_block_till_done()\n\n    # Unknown, as only 1 device tracker has a state, but we ignore that one\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n\n    hass.states.async_set(DEVICE_TRACKER_2, \"not_home\")\n    await hass.async_block_till_done()\n\n    # Take state of tracker 2\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n\n    # state 1 is newer but ignored, keep tracker 2 state\n    hass.states.async_set(DEVICE_TRACKER, \"unknown\")\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n\n\nasync def test_restore_home_state(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test that the state is restored for a person on startup.\"\"\"\n    user_id = hass_admin_user.id\n    attrs = {\n        ATTR_ID: \"1234\",\n        ATTR_LATITUDE: 10.12346,\n        ATTR_LONGITUDE: 11.12346,\n        ATTR_SOURCE: DEVICE_TRACKER,\n        ATTR_USER_ID: user_id,\n    }\n    state = State(\"person.tracked_person\", \"home\", attrs)\n    mock_restore_cache(hass, (state,))\n    hass.state = CoreState.not_running\n    mock_component(hass, \"recorder\")\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": DEVICE_TRACKER,\n            \"picture\": \"/bla\",\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) == 10.12346\n    assert state.attributes.get(ATTR_LONGITUDE) == 11.12346\n    # When restoring state the entity_id of the person will be used as source.\n    assert state.attributes.get(ATTR_SOURCE) == \"person.tracked_person\"\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_ENTITY_PICTURE) == \"/bla\"\n\n\nasync def test_duplicate_ids(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test we don't allow duplicate IDs.\"\"\"\n    config = {\n        DOMAIN: [\n            {\"id\": \"1234\", \"name\": \"test user 1\"},\n            {\"id\": \"1234\", \"name\": \"test user 2\"},\n        ]\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    assert len(hass.states.async_entity_ids(\"person\")) == 1\n    assert hass.states.get(\"person.test_user_1\") is not None\n    assert hass.states.get(\"person.test_user_2\") is None\n\n\nasync def test_create_person_during_run(hass: HomeAssistant) -> None:\n    \"\"\"Test that person is updated if created while hass is running.\"\"\"\n    config = {DOMAIN: {}}\n    assert await async_setup_component(hass, DOMAIN, config)\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n\n    await hass.components.person.async_create_person(\n        \"tracked person\", device_trackers=[DEVICE_TRACKER]\n    )\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n\n\nasync def test_load_person_storage(\n    hass: HomeAssistant, hass_admin_user: MockUser, storage_setup\n) -> None:\n    \"\"\"Test set up person from storage.\"\"\"\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == hass_admin_user.id\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == hass_admin_user.id\n\n\nasync def test_load_person_storage_two_nonlinked(\n    hass: HomeAssistant, hass_storage: dict[str, Any]\n) -> None:\n    \"\"\"Test loading two users with both not having a user linked.\"\"\"\n    hass_storage[DOMAIN] = {\n        \"key\": DOMAIN,\n        \"version\": 1,\n        \"data\": {\n            \"persons\": [\n                {\n                    \"id\": \"1234\",\n                    \"name\": \"tracked person 1\",\n                    \"user_id\": None,\n                    \"device_trackers\": [],\n                },\n                {\n                    \"id\": \"5678\",\n                    \"name\": \"tracked person 2\",\n                    \"user_id\": None,\n                    \"device_trackers\": [],\n                },\n            ]\n        },\n    }\n    await async_setup_component(hass, DOMAIN, {})\n\n    assert len(hass.states.async_entity_ids(\"person\")) == 2\n    assert hass.states.get(\"person.tracked_person_1\") is not None\n    assert hass.states.get(\"person.tracked_person_2\") is not None\n\n\nasync def test_ws_list(\n    hass: HomeAssistant, hass_ws_client: WebSocketGenerator, storage_setup\n) -> None:\n    \"\"\"Test listing via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json({\"id\": 6, \"type\": \"person/list\"})\n    resp = await client.receive_json()\n    assert resp[\"success\"]\n    assert resp[\"result\"][\"storage\"] == manager.async_items()\n    assert len(resp[\"result\"][\"storage\"]) == 1\n    assert len(resp[\"result\"][\"config\"]) == 0\n\n\nasync def test_ws_create(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_read_only_user: MockUser,\n) -> None:\n    \"\"\"Test creating via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/create\",\n            \"name\": \"Hello\",\n            \"device_trackers\": [DEVICE_TRACKER],\n            \"user_id\": hass_read_only_user.id,\n            \"picture\": \"/bla\",\n        }\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 2\n\n    assert resp[\"success\"]\n    assert resp[\"result\"] == persons[1]\n\n\nasync def test_ws_create_requires_admin(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_admin_user: MockUser,\n    hass_read_only_user: MockUser,\n) -> None:\n    \"\"\"Test creating via WS requires admin.\"\"\"\n    hass_admin_user.groups = []\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/create\",\n            \"name\": \"Hello\",\n            \"device_trackers\": [DEVICE_TRACKER],\n            \"user_id\": hass_read_only_user.id,\n        }\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 1\n\n    assert not resp[\"success\"]\n\n\nasync def test_ws_update(\n    hass: HomeAssistant, hass_ws_client: WebSocketGenerator, storage_setup\n) -> None:\n    \"\"\"Test updating via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n    persons = manager.async_items()\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/update\",\n            \"person_id\": persons[0][\"id\"],\n            \"user_id\": persons[0][\"user_id\"],\n        }\n    )\n    resp = await client.receive_json()\n\n    assert resp[\"success\"]\n\n    resp = await client.send_json(\n        {\n            \"id\": 7,\n            \"type\": \"person/update\",\n            \"person_id\": persons[0][\"id\"],\n            \"name\": \"Updated Name\",\n            \"device_trackers\": [DEVICE_TRACKER_2],\n            \"user_id\": None,\n            \"picture\": \"/bla\",\n        }\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 1\n\n    assert resp[\"success\"]\n    assert resp[\"result\"] == persons[0]\n    assert persons[0][\"name\"] == \"Updated Name\"\n    assert persons[0][\"name\"] == \"Updated Name\"\n    assert persons[0][\"device_trackers\"] == [DEVICE_TRACKER_2]\n    assert persons[0][\"user_id\"] is None\n    assert persons[0][\"picture\"] == \"/bla\"\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.name == \"Updated Name\"\n\n\nasync def test_ws_update_require_admin(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_admin_user: MockUser,\n) -> None:\n    \"\"\"Test updating via WS requires admin.\"\"\"\n    hass_admin_user.groups = []\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n    original = dict(manager.async_items()[0])\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/update\",\n            \"person_id\": original[\"id\"],\n            \"name\": \"Updated Name\",\n            \"device_trackers\": [DEVICE_TRACKER_2],\n            \"user_id\": None,\n        }\n    )\n    resp = await client.receive_json()\n    assert not resp[\"success\"]\n\n    not_updated = dict(manager.async_items()[0])\n    assert original == not_updated\n\n\nasync def test_ws_delete(\n    hass: HomeAssistant, hass_ws_client: WebSocketGenerator, storage_setup\n) -> None:\n    \"\"\"Test deleting via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n    persons = manager.async_items()\n\n    resp = await client.send_json(\n        {\"id\": 6, \"type\": \"person/delete\", \"person_id\": persons[0][\"id\"]}\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 0\n\n    assert resp[\"success\"]\n    assert len(hass.states.async_entity_ids(\"person\")) == 0\n    ent_reg = er.async_get(hass)\n    assert not ent_reg.async_is_registered(\"person.tracked_person\")\n\n\nasync def test_ws_delete_require_admin(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_admin_user: MockUser,\n) -> None:\n    \"\"\"Test deleting via WS requires admin.\"\"\"\n    hass_admin_user.groups = []\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/delete\",\n            \"person_id\": manager.async_items()[0][\"id\"],\n            \"name\": \"Updated Name\",\n            \"device_trackers\": [DEVICE_TRACKER_2],\n            \"user_id\": None,\n        }\n    )\n    resp = await client.receive_json()\n    assert not resp[\"success\"]\n\n    persons = manager.async_items()\n    assert len(persons) == 1\n\n\nasync def test_create_invalid_user_id(hass: HomeAssistant, storage_collection) -> None:\n    \"\"\"Test we do not allow invalid user ID during creation.\"\"\"\n    with pytest.raises(ValueError):\n        await storage_collection.async_create_item(\n            {\"name\": \"Hello\", \"user_id\": \"non-existing\"}\n        )\n\n\nasync def test_create_duplicate_user_id(\n    hass: HomeAssistant, hass_admin_user: MockUser, storage_collection\n) -> None:\n    \"\"\"Test we do not allow duplicate user ID during creation.\"\"\"\n    await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"user_id\": hass_admin_user.id}\n    )\n\n    with pytest.raises(ValueError):\n        await storage_collection.async_create_item(\n            {\"name\": \"Hello\", \"user_id\": hass_admin_user.id}\n        )\n\n\nasync def test_update_double_user_id(\n    hass: HomeAssistant, hass_admin_user: MockUser, storage_collection\n) -> None:\n    \"\"\"Test we do not allow double user ID during update.\"\"\"\n    await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"user_id\": hass_admin_user.id}\n    )\n    person = await storage_collection.async_create_item({\"name\": \"Hello\"})\n\n    with pytest.raises(ValueError):\n        await storage_collection.async_update_item(\n            person[\"id\"], {\"user_id\": hass_admin_user.id}\n        )\n\n\nasync def test_update_invalid_user_id(hass: HomeAssistant, storage_collection) -> None:\n    \"\"\"Test updating to invalid user ID.\"\"\"\n    person = await storage_collection.async_create_item({\"name\": \"Hello\"})\n\n    with pytest.raises(ValueError):\n        await storage_collection.async_update_item(\n            person[\"id\"], {\"user_id\": \"non-existing\"}\n        )\n\n\nasync def test_update_person_when_user_removed(\n    hass: HomeAssistant, storage_setup, hass_read_only_user: MockUser\n) -> None:\n    \"\"\"Update person when user is removed.\"\"\"\n    storage_collection = hass.data[DOMAIN][1]\n\n    person = await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"user_id\": hass_read_only_user.id}\n    )\n\n    await hass.auth.async_remove_user(hass_read_only_user)\n    await hass.async_block_till_done()\n\n    assert storage_collection.data[person[\"id\"]][\"user_id\"] is None\n\n\nasync def test_removing_device_tracker(hass: HomeAssistant, storage_setup) -> None:\n    \"\"\"Test we automatically remove removed device trackers.\"\"\"\n    storage_collection = hass.data[DOMAIN][1]\n    reg = er.async_get(hass)\n    entry = reg.async_get_or_create(\n        \"device_tracker\", \"mobile_app\", \"bla\", suggested_object_id=\"pixel\"\n    )\n\n    person = await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"device_trackers\": [entry.entity_id]}\n    )\n\n    reg.async_remove(entry.entity_id)\n    await hass.async_block_till_done()\n\n    assert storage_collection.data[person[\"id\"]][\"device_trackers\"] == []\n\n\nasync def test_add_user_device_tracker(\n    hass: HomeAssistant, storage_setup, hass_read_only_user: MockUser\n) -> None:\n    \"\"\"Test adding a device tracker to a person tied to a user.\"\"\"\n    storage_collection = hass.data[DOMAIN][1]\n    pers = await storage_collection.async_create_item(\n        {\n            \"name\": \"Hello\",\n            \"user_id\": hass_read_only_user.id,\n            \"device_trackers\": [\"device_tracker.on_create\"],\n        }\n    )\n\n    await person.async_add_user_device_tracker(\n        hass, hass_read_only_user.id, \"device_tracker.added\"\n    )\n\n    assert storage_collection.data[pers[\"id\"]][\"device_trackers\"] == [\n        \"device_tracker.on_create\",\n        \"device_tracker.added\",\n    ]\n\n\nasync def test_reload(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test reloading the YAML config.\"\"\"\n    assert await async_setup_component(\n        hass,\n        DOMAIN,\n        {\n            DOMAIN: [\n                {\"name\": \"Person 1\", \"id\": \"id-1\"},\n                {\"name\": \"Person 2\", \"id\": \"id-2\"},\n            ]\n        },\n    )\n\n    assert len(hass.states.async_entity_ids()) == 2\n\n    state_1 = hass.states.get(\"person.person_1\")\n    state_2 = hass.states.get(\"person.person_2\")\n    state_3 = hass.states.get(\"person.person_3\")\n\n    assert state_1 is not None\n    assert state_1.name == \"Person 1\"\n    assert state_2 is not None\n    assert state_2.name == \"Person 2\"\n    assert state_3 is None\n\n    with patch(\n        \"homeassistant.config.load_yaml_config_file\",\n        autospec=True,\n        return_value={\n            DOMAIN: [\n                {\"name\": \"Person 1-updated\", \"id\": \"id-1\"},\n                {\"name\": \"Person 3\", \"id\": \"id-3\"},\n            ]\n        },\n    ):\n        await hass.services.async_call(\n            DOMAIN,\n            SERVICE_RELOAD,\n            blocking=True,\n            context=Context(user_id=hass_admin_user.id),\n        )\n        await hass.async_block_till_done()\n\n    assert len(hass.states.async_entity_ids()) == 2\n\n    state_1 = hass.states.get(\"person.person_1\")\n    state_2 = hass.states.get(\"person.person_2\")\n    state_3 = hass.states.get(\"person.person_3\")\n\n    assert state_1 is not None\n    assert state_1.name == \"Person 1-updated\"\n    assert state_2 is None\n    assert state_3 is not None\n    assert state_3.name == \"Person 3\"\n\n\nasync def test_person_storage_fixing_device_trackers(storage_collection) -> None:\n    \"\"\"Test None device trackers become lists.\"\"\"\n    with patch.object(\n        storage_collection.store,\n        \"async_load\",\n        return_value={\"items\": [{\"id\": \"bla\", \"name\": \"bla\", \"device_trackers\": None}]},\n    ):\n        await storage_collection.async_load()\n\n    assert storage_collection.data[\"bla\"][\"device_trackers\"] == []\n\n\nasync def test_persons_with_entity(hass: HomeAssistant) -> None:\n    \"\"\"Test finding persons with an entity.\"\"\"\n    assert await async_setup_component(\n        hass,\n        \"person\",\n        {\n            \"person\": [\n                {\n                    \"id\": \"abcd\",\n                    \"name\": \"Paulus\",\n                    \"device_trackers\": [\n                        \"device_tracker.paulus_iphone\",\n                        \"device_tracker.paulus_ipad\",\n                    ],\n                },\n                {\n                    \"id\": \"efgh\",\n                    \"name\": \"Anne Therese\",\n                    \"device_trackers\": [\n                        \"device_tracker.at_pixel\",\n                    ],\n                },\n            ]\n        },\n    )\n\n    assert person.persons_with_entity(hass, \"device_tracker.paulus_iphone\") == [\n        \"person.paulus\"\n    ]\n\n\nasync def test_entities_in_person(hass: HomeAssistant) -> None:\n    \"\"\"Test finding entities tracked by person.\"\"\"\n    assert await async_setup_component(\n        hass,\n        \"person\",\n        {\n            \"person\": [\n                {\n                    \"id\": \"abcd\",\n                    \"name\": \"Paulus\",\n                    \"device_trackers\": [\n                        \"device_tracker.paulus_iphone\",\n                        \"device_tracker.paulus_ipad\",\n                    ],\n                }\n            ]\n        },\n    )\n\n    assert person.entities_in_person(hass, \"person.paulus\") == [\n        \"device_tracker.paulus_iphone\",\n        \"device_tracker.paulus_ipad\",\n    ]\n\n\n@pytest.mark.parametrize(\n    (\"ip\", \"status_code\", \"expected_fn\"),\n    [\n        (\n            \"192.168.0.10\",\n            HTTPStatus.OK,\n            lambda user: {\n                user[\"user_id\"]: {\"name\": user[\"name\"], \"picture\": user[\"picture\"]}\n            },\n        ),\n        (\n            \"::ffff:192.168.0.10\",\n            HTTPStatus.OK,\n            lambda user: {\n                user[\"user_id\"]: {\"name\": user[\"name\"], \"picture\": user[\"picture\"]}\n            },\n        ),\n        (\n            \"1.2.3.4\",\n            HTTPStatus.BAD_REQUEST,\n            lambda _: {\"code\": \"not_local\", \"message\": \"Not local\"},\n        ),\n        (\n            \"2001:db8::1\",\n            HTTPStatus.BAD_REQUEST,\n            lambda _: {\"code\": \"not_local\", \"message\": \"Not local\"},\n        ),\n    ],\n)\nasync def test_list_persons(\n    hass: HomeAssistant,\n    hass_client_no_auth: ClientSessionGenerator,\n    hass_admin_user: MockUser,\n    ip: str,\n    status_code: HTTPStatus,\n    expected_fn: Callable[[dict[str, Any]], dict[str, Any]],\n) -> None:\n    \"\"\"Test listing persons from a not local ip address.\"\"\"\n\n    user_id = hass_admin_user.id\n    admin = {\"id\": \"1234\", \"name\": \"Admin\", \"user_id\": user_id, \"picture\": \"/bla\"}\n    config = {\n        DOMAIN: [\n            admin,\n            {\"id\": \"5678\", \"name\": \"Only a person\"},\n        ]\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    await async_setup_component(hass, \"api\", {})\n    mock_real_ip(hass.http.app)(ip)\n    client = await hass_client_no_auth()\n\n    resp = await client.get(\"/api/person/list\")\n\n    assert resp.status == status_code\n    result = await resp.json()\n    assert result == expected_fn(admin)\n"], "fixing_code": ["\"\"\"HTTP views handle login flow.\n\n# GET /auth/providers\n\nReturn a list of auth providers. Example:\n\n[\n    {\n        \"name\": \"Local\",\n        \"id\": null,\n        \"type\": \"local_provider\",\n    }\n]\n\n\n# POST /auth/login_flow\n\nCreate a login flow. Will return the first step of the flow.\n\nPass in parameter 'client_id' and 'redirect_url' validate by indieauth.\n\nPass in parameter 'handler' to specify the auth provider to use. Auth providers\nare identified by type and id.\n\nAnd optional parameter 'type' has to set as 'link_user' if login flow used for\nlink credential to exist user. Default 'type' is 'authorize'.\n\n{\n    \"client_id\": \"https://hassbian.local:8123/\",\n    \"handler\": [\"local_provider\", null],\n    \"redirect_url\": \"https://hassbian.local:8123/\",\n    \"type': \"authorize\"\n}\n\nReturn value will be a step in a data entry flow. See the docs for data entry\nflow for details.\n\n{\n    \"data_schema\": [\n        {\"name\": \"username\", \"type\": \"string\"},\n        {\"name\": \"password\", \"type\": \"string\"}\n    ],\n    \"errors\": {},\n    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",\n    \"handler\": [\"insecure_example\", null],\n    \"step_id\": \"init\",\n    \"type\": \"form\"\n}\n\n\n# POST /auth/login_flow/{flow_id}\n\nProgress the flow. Most flows will be 1 page, but could optionally add extra\nlogin challenges, like TFA. Once the flow has finished, the returned step will\nhave type FlowResultType.CREATE_ENTRY and \"result\" key will contain an authorization code.\nThe authorization code associated with an authorized user by default, it will\nassociate with an credential if \"type\" set to \"link_user\" in\n\"/auth/login_flow\"\n\n{\n    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",\n    \"handler\": [\"insecure_example\", null],\n    \"result\": \"411ee2f916e648d691e937ae9344681e\",\n    \"title\": \"Example\",\n    \"type\": \"create_entry\",\n    \"version\": 1\n}\n\"\"\"\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\nfrom http import HTTPStatus\nfrom ipaddress import ip_address\nfrom typing import TYPE_CHECKING, Any, cast\n\nfrom aiohttp import web\nimport voluptuous as vol\nimport voluptuous_serialize\n\nfrom homeassistant import data_entry_flow\nfrom homeassistant.auth import AuthManagerFlowManager, InvalidAuthError\nfrom homeassistant.auth.models import Credentials\nfrom homeassistant.components import onboarding\nfrom homeassistant.components.http.auth import async_user_not_allowed_do_auth\nfrom homeassistant.components.http.ban import (\n    log_invalid_auth,\n    process_success_login,\n    process_wrong_login,\n)\nfrom homeassistant.components.http.data_validator import RequestDataValidator\nfrom homeassistant.components.http.view import HomeAssistantView\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.helpers.network import is_cloud_connection\n\nfrom . import indieauth\n\nif TYPE_CHECKING:\n    from homeassistant.auth.providers.trusted_networks import (\n        TrustedNetworksAuthProvider,\n    )\n\n    from . import StoreResultType\n\n\nasync def async_setup(\n    hass: HomeAssistant, store_result: Callable[[str, Credentials], str]\n) -> None:\n    \"\"\"Component to allow users to login.\"\"\"\n    hass.http.register_view(WellKnownOAuthInfoView)\n    hass.http.register_view(AuthProvidersView)\n    hass.http.register_view(LoginFlowIndexView(hass.auth.login_flow, store_result))\n    hass.http.register_view(LoginFlowResourceView(hass.auth.login_flow, store_result))\n\n\nclass WellKnownOAuthInfoView(HomeAssistantView):\n    \"\"\"View to host the OAuth2 information.\"\"\"\n\n    requires_auth = False\n    url = \"/.well-known/oauth-authorization-server\"\n    name = \"well-known/oauth-authorization-server\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Return the well known OAuth2 authorization info.\"\"\"\n        return self.json(\n            {\n                \"authorization_endpoint\": \"/auth/authorize\",\n                \"token_endpoint\": \"/auth/token\",\n                \"revocation_endpoint\": \"/auth/revoke\",\n                \"response_types_supported\": [\"code\"],\n                \"service_documentation\": (\n                    \"https://developers.home-assistant.io/docs/auth_api\"\n                ),\n            }\n        )\n\n\nclass AuthProvidersView(HomeAssistantView):\n    \"\"\"View to get available auth providers.\"\"\"\n\n    url = \"/auth/providers\"\n    name = \"api:auth:providers\"\n    requires_auth = False\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Get available auth providers.\"\"\"\n        hass: HomeAssistant = request.app[\"hass\"]\n        if not onboarding.async_is_user_onboarded(hass):\n            return self.json_message(\n                message=\"Onboarding not finished\",\n                status_code=HTTPStatus.BAD_REQUEST,\n                message_code=\"onboarding_required\",\n            )\n\n        try:\n            remote_address = ip_address(request.remote)  # type: ignore[arg-type]\n        except ValueError:\n            return self.json_message(\n                message=\"Invalid remote IP\",\n                status_code=HTTPStatus.BAD_REQUEST,\n                message_code=\"invalid_remote_ip\",\n            )\n\n        cloud_connection = is_cloud_connection(hass)\n\n        providers = []\n        for provider in hass.auth.auth_providers:\n            if provider.type == \"trusted_networks\":\n                if cloud_connection:\n                    # Skip quickly as trusted networks are not available on cloud\n                    continue\n\n                try:\n                    cast(\"TrustedNetworksAuthProvider\", provider).async_validate_access(\n                        remote_address\n                    )\n                except InvalidAuthError:\n                    # Not a trusted network, so we don't expose that trusted_network authenticator is setup\n                    continue\n\n            providers.append(\n                {\n                    \"name\": provider.name,\n                    \"id\": provider.id,\n                    \"type\": provider.type,\n                }\n            )\n\n        return self.json(providers)\n\n\ndef _prepare_result_json(\n    result: data_entry_flow.FlowResult,\n) -> data_entry_flow.FlowResult:\n    \"\"\"Convert result to JSON.\"\"\"\n    if result[\"type\"] == data_entry_flow.FlowResultType.CREATE_ENTRY:\n        data = result.copy()\n        data.pop(\"result\")\n        data.pop(\"data\")\n        return data\n\n    if result[\"type\"] != data_entry_flow.FlowResultType.FORM:\n        return result\n\n    data = result.copy()\n\n    if (schema := data[\"data_schema\"]) is None:\n        data[\"data_schema\"] = []\n    else:\n        data[\"data_schema\"] = voluptuous_serialize.convert(schema)\n\n    return data\n\n\nclass LoginFlowBaseView(HomeAssistantView):\n    \"\"\"Base class for the login views.\"\"\"\n\n    requires_auth = False\n\n    def __init__(\n        self,\n        flow_mgr: AuthManagerFlowManager,\n        store_result: StoreResultType,\n    ) -> None:\n        \"\"\"Initialize the flow manager index view.\"\"\"\n        self._flow_mgr = flow_mgr\n        self._store_result = store_result\n\n    async def _async_flow_result_to_response(\n        self,\n        request: web.Request,\n        client_id: str,\n        result: data_entry_flow.FlowResult,\n    ) -> web.Response:\n        \"\"\"Convert the flow result to a response.\"\"\"\n        if result[\"type\"] != data_entry_flow.FlowResultType.CREATE_ENTRY:\n            # @log_invalid_auth does not work here since it returns HTTP 200.\n            # We need to manually log failed login attempts.\n            if (\n                result[\"type\"] == data_entry_flow.FlowResultType.FORM\n                and (errors := result.get(\"errors\"))\n                and errors.get(\"base\")\n                in (\n                    \"invalid_auth\",\n                    \"invalid_code\",\n                )\n            ):\n                await process_wrong_login(request)\n            return self.json(_prepare_result_json(result))\n\n        hass: HomeAssistant = request.app[\"hass\"]\n\n        if not await indieauth.verify_redirect_uri(\n            hass, client_id, result[\"context\"][\"redirect_uri\"]\n        ):\n            return self.json_message(\"Invalid redirect URI\", HTTPStatus.FORBIDDEN)\n\n        result.pop(\"data\")\n        result.pop(\"context\")\n\n        result_obj: Credentials = result.pop(\"result\")\n\n        # Result can be None if credential was never linked to a user before.\n        user = await hass.auth.async_get_user_by_credentials(result_obj)\n\n        if user is not None and (\n            user_access_error := async_user_not_allowed_do_auth(hass, user)\n        ):\n            return self.json_message(\n                f\"Login blocked: {user_access_error}\", HTTPStatus.FORBIDDEN\n            )\n\n        process_success_login(request)\n        result[\"result\"] = self._store_result(client_id, result_obj)\n\n        return self.json(result)\n\n\nclass LoginFlowIndexView(LoginFlowBaseView):\n    \"\"\"View to create a login flow.\"\"\"\n\n    url = \"/auth/login_flow\"\n    name = \"api:auth:login_flow\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Do not allow index of flows in progress.\"\"\"\n        return web.Response(status=HTTPStatus.METHOD_NOT_ALLOWED)\n\n    @RequestDataValidator(\n        vol.Schema(\n            {\n                vol.Required(\"client_id\"): str,\n                vol.Required(\"handler\"): vol.Any(str, list),\n                vol.Required(\"redirect_uri\"): str,\n                vol.Optional(\"type\", default=\"authorize\"): str,\n            }\n        )\n    )\n    @log_invalid_auth\n    async def post(self, request: web.Request, data: dict[str, Any]) -> web.Response:\n        \"\"\"Create a new login flow.\"\"\"\n        client_id: str = data[\"client_id\"]\n        redirect_uri: str = data[\"redirect_uri\"]\n\n        if not indieauth.verify_client_id(client_id):\n            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)\n\n        handler: tuple[str, ...] | str\n        if isinstance(data[\"handler\"], list):\n            handler = tuple(data[\"handler\"])\n        else:\n            handler = data[\"handler\"]\n\n        try:\n            result = await self._flow_mgr.async_init(\n                handler,  # type: ignore[arg-type]\n                context={\n                    \"ip_address\": ip_address(request.remote),  # type: ignore[arg-type]\n                    \"credential_only\": data.get(\"type\") == \"link_user\",\n                    \"redirect_uri\": redirect_uri,\n                },\n            )\n        except data_entry_flow.UnknownHandler:\n            return self.json_message(\"Invalid handler specified\", HTTPStatus.NOT_FOUND)\n        except data_entry_flow.UnknownStep:\n            return self.json_message(\n                \"Handler does not support init\", HTTPStatus.BAD_REQUEST\n            )\n\n        return await self._async_flow_result_to_response(request, client_id, result)\n\n\nclass LoginFlowResourceView(LoginFlowBaseView):\n    \"\"\"View to interact with the flow manager.\"\"\"\n\n    url = \"/auth/login_flow/{flow_id}\"\n    name = \"api:auth:login_flow:resource\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Do not allow getting status of a flow in progress.\"\"\"\n        return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)\n\n    @RequestDataValidator(\n        vol.Schema(\n            {vol.Required(\"client_id\"): str},\n            extra=vol.ALLOW_EXTRA,\n        )\n    )\n    @log_invalid_auth\n    async def post(\n        self, request: web.Request, data: dict[str, Any], flow_id: str\n    ) -> web.Response:\n        \"\"\"Handle progressing a login flow request.\"\"\"\n        client_id: str = data.pop(\"client_id\")\n\n        if not indieauth.verify_client_id(client_id):\n            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)\n\n        try:\n            # do not allow change ip during login flow\n            flow = self._flow_mgr.async_get(flow_id)\n            if flow[\"context\"][\"ip_address\"] != ip_address(request.remote):  # type: ignore[arg-type]\n                return self.json_message(\"IP address changed\", HTTPStatus.BAD_REQUEST)\n            result = await self._flow_mgr.async_configure(flow_id, data)\n        except data_entry_flow.UnknownFlow:\n            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)\n        except vol.Invalid:\n            return self.json_message(\"User input malformed\", HTTPStatus.BAD_REQUEST)\n\n        return await self._async_flow_result_to_response(request, client_id, result)\n\n    async def delete(self, request: web.Request, flow_id: str) -> web.Response:\n        \"\"\"Cancel a flow in progress.\"\"\"\n        try:\n            self._flow_mgr.async_abort(flow_id)\n        except data_entry_flow.UnknownFlow:\n            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)\n\n        return self.json_message(\"Flow aborted\")\n", "\"\"\"Support for tracking people.\"\"\"\nfrom __future__ import annotations\n\nfrom http import HTTPStatus\nimport logging\nfrom typing import Any\n\nfrom aiohttp import web\nimport voluptuous as vol\n\nfrom homeassistant.auth import EVENT_USER_REMOVED\nfrom homeassistant.components import persistent_notification, websocket_api\nfrom homeassistant.components.device_tracker import (\n    ATTR_SOURCE_TYPE,\n    DOMAIN as DEVICE_TRACKER_DOMAIN,\n    SourceType,\n)\nfrom homeassistant.components.http.view import HomeAssistantView\nfrom homeassistant.const import (\n    ATTR_EDITABLE,\n    ATTR_ENTITY_ID,\n    ATTR_GPS_ACCURACY,\n    ATTR_ID,\n    ATTR_LATITUDE,\n    ATTR_LONGITUDE,\n    ATTR_NAME,\n    CONF_ID,\n    CONF_NAME,\n    CONF_TYPE,\n    EVENT_HOMEASSISTANT_START,\n    SERVICE_RELOAD,\n    STATE_HOME,\n    STATE_NOT_HOME,\n    STATE_UNAVAILABLE,\n    STATE_UNKNOWN,\n)\nfrom homeassistant.core import (\n    Event,\n    HomeAssistant,\n    ServiceCall,\n    State,\n    callback,\n    split_entity_id,\n)\nfrom homeassistant.helpers import (\n    collection,\n    config_validation as cv,\n    entity_registry as er,\n    service,\n)\nfrom homeassistant.helpers.entity_component import EntityComponent\nfrom homeassistant.helpers.event import async_track_state_change_event\nfrom homeassistant.helpers.restore_state import RestoreEntity\nfrom homeassistant.helpers.storage import Store\nfrom homeassistant.helpers.typing import ConfigType\nfrom homeassistant.loader import bind_hass\n\n_LOGGER = logging.getLogger(__name__)\n\nATTR_SOURCE = \"source\"\nATTR_USER_ID = \"user_id\"\nATTR_DEVICE_TRACKERS = \"device_trackers\"\n\nCONF_DEVICE_TRACKERS = \"device_trackers\"\nCONF_USER_ID = \"user_id\"\nCONF_PICTURE = \"picture\"\n\nDOMAIN = \"person\"\n\nSTORAGE_KEY = DOMAIN\nSTORAGE_VERSION = 2\n# Device tracker states to ignore\nIGNORE_STATES = (STATE_UNKNOWN, STATE_UNAVAILABLE)\n\nPERSON_SCHEMA = vol.Schema(\n    {\n        vol.Required(CONF_ID): cv.string,\n        vol.Required(CONF_NAME): cv.string,\n        vol.Optional(CONF_USER_ID): cv.string,\n        vol.Optional(CONF_DEVICE_TRACKERS, default=[]): vol.All(\n            cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)\n        ),\n        vol.Optional(CONF_PICTURE): cv.string,\n    }\n)\n\nCONFIG_SCHEMA = vol.Schema(\n    {\n        vol.Optional(DOMAIN, default=[]): vol.All(\n            cv.ensure_list, cv.remove_falsy, [PERSON_SCHEMA]\n        )\n    },\n    extra=vol.ALLOW_EXTRA,\n)\n\n\n@bind_hass\nasync def async_create_person(hass, name, *, user_id=None, device_trackers=None):\n    \"\"\"Create a new person.\"\"\"\n    await hass.data[DOMAIN][1].async_create_item(\n        {\n            ATTR_NAME: name,\n            ATTR_USER_ID: user_id,\n            CONF_DEVICE_TRACKERS: device_trackers or [],\n        }\n    )\n\n\n@bind_hass\nasync def async_add_user_device_tracker(\n    hass: HomeAssistant, user_id: str, device_tracker_entity_id: str\n):\n    \"\"\"Add a device tracker to a person linked to a user.\"\"\"\n    coll: PersonStorageCollection = hass.data[DOMAIN][1]\n\n    for person in coll.async_items():\n        if person.get(ATTR_USER_ID) != user_id:\n            continue\n\n        device_trackers = person[CONF_DEVICE_TRACKERS]\n\n        if device_tracker_entity_id in device_trackers:\n            return\n\n        await coll.async_update_item(\n            person[CONF_ID],\n            {CONF_DEVICE_TRACKERS: device_trackers + [device_tracker_entity_id]},\n        )\n        break\n\n\n@callback\ndef persons_with_entity(hass: HomeAssistant, entity_id: str) -> list[str]:\n    \"\"\"Return all persons that reference the entity.\"\"\"\n    if (\n        DOMAIN not in hass.data\n        or split_entity_id(entity_id)[0] != DEVICE_TRACKER_DOMAIN\n    ):\n        return []\n\n    component: EntityComponent[Person] = hass.data[DOMAIN][2]\n\n    return [\n        person_entity.entity_id\n        for person_entity in component.entities\n        if entity_id in person_entity.device_trackers\n    ]\n\n\n@callback\ndef entities_in_person(hass: HomeAssistant, entity_id: str) -> list[str]:\n    \"\"\"Return all entities belonging to a person.\"\"\"\n    if DOMAIN not in hass.data:\n        return []\n\n    component: EntityComponent[Person] = hass.data[DOMAIN][2]\n\n    if (person_entity := component.get_entity(entity_id)) is None:\n        return []\n\n    return person_entity.device_trackers\n\n\nCREATE_FIELDS = {\n    vol.Required(CONF_NAME): vol.All(str, vol.Length(min=1)),\n    vol.Optional(CONF_USER_ID): vol.Any(str, None),\n    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(\n        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)\n    ),\n    vol.Optional(CONF_PICTURE): vol.Any(str, None),\n}\n\n\nUPDATE_FIELDS = {\n    vol.Optional(CONF_NAME): vol.All(str, vol.Length(min=1)),\n    vol.Optional(CONF_USER_ID): vol.Any(str, None),\n    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(\n        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)\n    ),\n    vol.Optional(CONF_PICTURE): vol.Any(str, None),\n}\n\n\nclass PersonStore(Store):\n    \"\"\"Person storage.\"\"\"\n\n    async def _async_migrate_func(self, old_major_version, old_minor_version, old_data):\n        \"\"\"Migrate to the new version.\n\n        Migrate storage to use format of collection helper.\n        \"\"\"\n        return {\"items\": old_data[\"persons\"]}\n\n\nclass PersonStorageCollection(collection.DictStorageCollection):\n    \"\"\"Person collection stored in storage.\"\"\"\n\n    CREATE_SCHEMA = vol.Schema(CREATE_FIELDS)\n    UPDATE_SCHEMA = vol.Schema(UPDATE_FIELDS)\n\n    def __init__(\n        self,\n        store: Store,\n        id_manager: collection.IDManager,\n        yaml_collection: collection.YamlCollection,\n    ) -> None:\n        \"\"\"Initialize a person storage collection.\"\"\"\n        super().__init__(store, id_manager)\n        self.yaml_collection = yaml_collection\n\n    async def _async_load_data(self) -> collection.SerializedStorageCollection | None:\n        \"\"\"Load the data.\n\n        A past bug caused onboarding to create invalid person objects.\n        This patches it up.\n        \"\"\"\n        data = await super()._async_load_data()\n\n        if data is None:\n            return data\n\n        for person in data[\"items\"]:\n            if person[CONF_DEVICE_TRACKERS] is None:\n                person[CONF_DEVICE_TRACKERS] = []\n\n        return data\n\n    async def async_load(self) -> None:\n        \"\"\"Load the Storage collection.\"\"\"\n        await super().async_load()\n        self.hass.bus.async_listen(\n            er.EVENT_ENTITY_REGISTRY_UPDATED,\n            self._entity_registry_updated,\n            event_filter=self._entity_registry_filter,\n        )\n\n    @callback\n    def _entity_registry_filter(self, event: Event) -> bool:\n        \"\"\"Filter entity registry events.\"\"\"\n        return (\n            event.data[\"action\"] == \"remove\"\n            and split_entity_id(event.data[ATTR_ENTITY_ID])[0] == \"device_tracker\"\n        )\n\n    async def _entity_registry_updated(self, event: Event) -> None:\n        \"\"\"Handle entity registry updated.\"\"\"\n        entity_id = event.data[ATTR_ENTITY_ID]\n        for person in list(self.data.values()):\n            if entity_id not in person[CONF_DEVICE_TRACKERS]:\n                continue\n\n            await self.async_update_item(\n                person[CONF_ID],\n                {\n                    CONF_DEVICE_TRACKERS: [\n                        devt\n                        for devt in person[CONF_DEVICE_TRACKERS]\n                        if devt != entity_id\n                    ]\n                },\n            )\n\n    async def _process_create_data(self, data: dict) -> dict:\n        \"\"\"Validate the config is valid.\"\"\"\n        data = self.CREATE_SCHEMA(data)\n\n        if (user_id := data.get(CONF_USER_ID)) is not None:\n            await self._validate_user_id(user_id)\n\n        return data\n\n    @callback\n    def _get_suggested_id(self, info: dict) -> str:\n        \"\"\"Suggest an ID based on the config.\"\"\"\n        return info[CONF_NAME]\n\n    async def _update_data(self, item: dict, update_data: dict) -> dict:\n        \"\"\"Return a new updated data object.\"\"\"\n        update_data = self.UPDATE_SCHEMA(update_data)\n\n        user_id = update_data.get(CONF_USER_ID)\n\n        if user_id is not None and user_id != item.get(CONF_USER_ID):\n            await self._validate_user_id(user_id)\n\n        return {**item, **update_data}\n\n    async def _validate_user_id(self, user_id):\n        \"\"\"Validate the used user_id.\"\"\"\n        if await self.hass.auth.async_get_user(user_id) is None:\n            raise ValueError(\"User does not exist\")\n\n        for persons in (self.data.values(), self.yaml_collection.async_items()):\n            if any(person for person in persons if person.get(CONF_USER_ID) == user_id):\n                raise ValueError(\"User already taken\")\n\n\nasync def filter_yaml_data(hass: HomeAssistant, persons: list[dict]) -> list[dict]:\n    \"\"\"Validate YAML data that we can't validate via schema.\"\"\"\n    filtered = []\n    person_invalid_user = []\n\n    for person_conf in persons:\n        user_id = person_conf.get(CONF_USER_ID)\n\n        if user_id is not None and await hass.auth.async_get_user(user_id) is None:\n            _LOGGER.error(\n                \"Invalid user_id detected for person %s\",\n                person_conf[CONF_ID],\n            )\n            person_invalid_user.append(\n                f\"- Person {person_conf[CONF_NAME]} (id: {person_conf[CONF_ID]}) points\"\n                f\" at invalid user {user_id}\"\n            )\n            continue\n\n        filtered.append(person_conf)\n\n    if person_invalid_user:\n        persistent_notification.async_create(\n            hass,\n            f\"\"\"\nThe following persons point at invalid users:\n\n{\"- \".join(person_invalid_user)}\n            \"\"\",\n            \"Invalid Person Configuration\",\n            DOMAIN,\n        )\n\n    return filtered\n\n\nasync def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:\n    \"\"\"Set up the person component.\"\"\"\n    entity_component = EntityComponent[Person](_LOGGER, DOMAIN, hass)\n    id_manager = collection.IDManager()\n    yaml_collection = collection.YamlCollection(\n        logging.getLogger(f\"{__name__}.yaml_collection\"), id_manager\n    )\n    storage_collection = PersonStorageCollection(\n        PersonStore(hass, STORAGE_VERSION, STORAGE_KEY),\n        id_manager,\n        yaml_collection,\n    )\n\n    collection.sync_entity_lifecycle(\n        hass, DOMAIN, DOMAIN, entity_component, yaml_collection, Person\n    )\n    collection.sync_entity_lifecycle(\n        hass, DOMAIN, DOMAIN, entity_component, storage_collection, Person\n    )\n\n    await yaml_collection.async_load(\n        await filter_yaml_data(hass, config.get(DOMAIN, []))\n    )\n    await storage_collection.async_load()\n\n    hass.data[DOMAIN] = (yaml_collection, storage_collection, entity_component)\n\n    collection.DictStorageCollectionWebsocket(\n        storage_collection, DOMAIN, DOMAIN, CREATE_FIELDS, UPDATE_FIELDS\n    ).async_setup(hass, create_list=False)\n\n    websocket_api.async_register_command(hass, ws_list_person)\n\n    async def _handle_user_removed(event: Event) -> None:\n        \"\"\"Handle a user being removed.\"\"\"\n        user_id = event.data[ATTR_USER_ID]\n        for person in storage_collection.async_items():\n            if person[CONF_USER_ID] == user_id:\n                await storage_collection.async_update_item(\n                    person[CONF_ID], {CONF_USER_ID: None}\n                )\n\n    hass.bus.async_listen(EVENT_USER_REMOVED, _handle_user_removed)\n\n    async def async_reload_yaml(call: ServiceCall) -> None:\n        \"\"\"Reload YAML.\"\"\"\n        conf = await entity_component.async_prepare_reload(skip_reset=True)\n        if conf is None:\n            return\n        await yaml_collection.async_load(\n            await filter_yaml_data(hass, conf.get(DOMAIN, []))\n        )\n\n    service.async_register_admin_service(\n        hass, DOMAIN, SERVICE_RELOAD, async_reload_yaml\n    )\n\n    hass.http.register_view(ListPersonsView)\n\n    return True\n\n\nclass Person(collection.CollectionEntity, RestoreEntity):\n    \"\"\"Represent a tracked person.\"\"\"\n\n    _entity_component_unrecorded_attributes = frozenset({ATTR_DEVICE_TRACKERS})\n\n    _attr_should_poll = False\n    editable: bool\n\n    def __init__(self, config):\n        \"\"\"Set up person.\"\"\"\n        self._config = config\n        self._latitude = None\n        self._longitude = None\n        self._gps_accuracy = None\n        self._source = None\n        self._state = None\n        self._unsub_track_device = None\n\n    @classmethod\n    def from_storage(cls, config: ConfigType):\n        \"\"\"Return entity instance initialized from storage.\"\"\"\n        person = cls(config)\n        person.editable = True\n        return person\n\n    @classmethod\n    def from_yaml(cls, config: ConfigType):\n        \"\"\"Return entity instance initialized from yaml.\"\"\"\n        person = cls(config)\n        person.editable = False\n        return person\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the entity.\"\"\"\n        return self._config[CONF_NAME]\n\n    @property\n    def entity_picture(self) -> str | None:\n        \"\"\"Return entity picture.\"\"\"\n        return self._config.get(CONF_PICTURE)\n\n    @property\n    def state(self):\n        \"\"\"Return the state of the person.\"\"\"\n        return self._state\n\n    @property\n    def extra_state_attributes(self):\n        \"\"\"Return the state attributes of the person.\"\"\"\n        data = {ATTR_EDITABLE: self.editable, ATTR_ID: self.unique_id}\n        if self._latitude is not None:\n            data[ATTR_LATITUDE] = self._latitude\n        if self._longitude is not None:\n            data[ATTR_LONGITUDE] = self._longitude\n        if self._gps_accuracy is not None:\n            data[ATTR_GPS_ACCURACY] = self._gps_accuracy\n        if self._source is not None:\n            data[ATTR_SOURCE] = self._source\n        if (user_id := self._config.get(CONF_USER_ID)) is not None:\n            data[ATTR_USER_ID] = user_id\n        data[ATTR_DEVICE_TRACKERS] = self.device_trackers\n        return data\n\n    @property\n    def unique_id(self):\n        \"\"\"Return a unique ID for the person.\"\"\"\n        return self._config[CONF_ID]\n\n    @property\n    def device_trackers(self):\n        \"\"\"Return the device trackers for the person.\"\"\"\n        return self._config[CONF_DEVICE_TRACKERS]\n\n    async def async_added_to_hass(self):\n        \"\"\"Register device trackers.\"\"\"\n        await super().async_added_to_hass()\n        if state := await self.async_get_last_state():\n            self._parse_source_state(state)\n\n        if self.hass.is_running:\n            # Update person now if hass is already running.\n            await self.async_update_config(self._config)\n        else:\n            # Wait for hass start to not have race between person\n            # and device trackers finishing setup.\n            async def person_start_hass(now):\n                await self.async_update_config(self._config)\n\n            self.hass.bus.async_listen_once(\n                EVENT_HOMEASSISTANT_START, person_start_hass\n            )\n\n    async def async_update_config(self, config: ConfigType):\n        \"\"\"Handle when the config is updated.\"\"\"\n        self._config = config\n\n        if self._unsub_track_device is not None:\n            self._unsub_track_device()\n            self._unsub_track_device = None\n\n        if trackers := self._config[CONF_DEVICE_TRACKERS]:\n            _LOGGER.debug(\"Subscribe to device trackers for %s\", self.entity_id)\n\n            self._unsub_track_device = async_track_state_change_event(\n                self.hass, trackers, self._async_handle_tracker_update\n            )\n\n        self._update_state()\n\n    @callback\n    def _async_handle_tracker_update(self, event):\n        \"\"\"Handle the device tracker state changes.\"\"\"\n        self._update_state()\n\n    @callback\n    def _update_state(self):\n        \"\"\"Update the state.\"\"\"\n        latest_non_gps_home = latest_not_home = latest_gps = latest = None\n        for entity_id in self._config[CONF_DEVICE_TRACKERS]:\n            state = self.hass.states.get(entity_id)\n\n            if not state or state.state in IGNORE_STATES:\n                continue\n\n            if state.attributes.get(ATTR_SOURCE_TYPE) == SourceType.GPS:\n                latest_gps = _get_latest(latest_gps, state)\n            elif state.state == STATE_HOME:\n                latest_non_gps_home = _get_latest(latest_non_gps_home, state)\n            elif state.state == STATE_NOT_HOME:\n                latest_not_home = _get_latest(latest_not_home, state)\n\n        if latest_non_gps_home:\n            latest = latest_non_gps_home\n        elif latest_gps:\n            latest = latest_gps\n        else:\n            latest = latest_not_home\n\n        if latest:\n            self._parse_source_state(latest)\n        else:\n            self._state = None\n            self._source = None\n            self._latitude = None\n            self._longitude = None\n            self._gps_accuracy = None\n\n        self.async_write_ha_state()\n\n    @callback\n    def _parse_source_state(self, state):\n        \"\"\"Parse source state and set person attributes.\n\n        This is a device tracker state or the restored person state.\n        \"\"\"\n        self._state = state.state\n        self._source = state.entity_id\n        self._latitude = state.attributes.get(ATTR_LATITUDE)\n        self._longitude = state.attributes.get(ATTR_LONGITUDE)\n        self._gps_accuracy = state.attributes.get(ATTR_GPS_ACCURACY)\n\n\n@websocket_api.websocket_command({vol.Required(CONF_TYPE): \"person/list\"})\ndef ws_list_person(\n    hass: HomeAssistant,\n    connection: websocket_api.ActiveConnection,\n    msg: dict[str, Any],\n) -> None:\n    \"\"\"List persons.\"\"\"\n    yaml, storage, _ = hass.data[DOMAIN]\n    connection.send_result(\n        msg[ATTR_ID], {\"storage\": storage.async_items(), \"config\": yaml.async_items()}\n    )\n\n\ndef _get_latest(prev: State | None, curr: State):\n    \"\"\"Get latest state.\"\"\"\n    if prev is None or curr.last_updated > prev.last_updated:\n        return curr\n    return prev\n\n\nclass ListPersonsView(HomeAssistantView):\n    \"\"\"List all persons if request is made from a local network.\"\"\"\n\n    requires_auth = False\n    url = \"/api/person/list\"\n    name = \"api:person:list\"\n\n    async def get(self, request: web.Request) -> web.Response:\n        \"\"\"Return a list of persons if request comes from a local IP.\"\"\"\n        return self.json_message(\n            message=\"Not local\",\n            status_code=HTTPStatus.BAD_REQUEST,\n            message_code=\"not_local\",\n        )\n", "\"\"\"Tests for the login flow.\"\"\"\nfrom http import HTTPStatus\nfrom typing import Any\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.setup import async_setup_component\n\nfrom . import BASE_CONFIG, async_setup_auth\n\nfrom tests.common import CLIENT_ID, CLIENT_REDIRECT_URI\nfrom tests.typing import ClientSessionGenerator\n\n_TRUSTED_NETWORKS_CONFIG = {\n    \"type\": \"trusted_networks\",\n    \"trusted_networks\": [\"192.168.0.1\"],\n    \"trusted_users\": {\n        \"192.168.0.1\": [\n            \"a1ab982744b64757bf80515589258924\",\n            {\"group\": \"system-group\"},\n        ]\n    },\n}\n\n\n@pytest.mark.parametrize(\n    (\"provider_configs\", \"ip\", \"expected\"),\n    [\n        (\n            BASE_CONFIG,\n            None,\n            [{\"name\": \"Example\", \"type\": \"insecure_example\", \"id\": None}],\n        ),\n        (\n            [_TRUSTED_NETWORKS_CONFIG],\n            None,\n            [],\n        ),\n        (\n            [_TRUSTED_NETWORKS_CONFIG],\n            \"192.168.0.1\",\n            [{\"name\": \"Trusted Networks\", \"type\": \"trusted_networks\", \"id\": None}],\n        ),\n    ],\n)\nasync def test_fetch_auth_providers(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    provider_configs: list[dict[str, Any]],\n    ip: str | None,\n    expected: list[dict[str, Any]],\n) -> None:\n    \"\"\"Test fetching auth providers.\"\"\"\n    client = await async_setup_auth(\n        hass, aiohttp_client, provider_configs, custom_ip=ip\n    )\n    resp = await client.get(\"/auth/providers\")\n    assert resp.status == HTTPStatus.OK\n    assert await resp.json() == expected\n\n\nasync def _test_fetch_auth_providers_home_assistant(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    ip: str,\n) -> None:\n    \"\"\"Test fetching auth providers for homeassistant auth provider.\"\"\"\n    client = await async_setup_auth(\n        hass, aiohttp_client, [{\"type\": \"homeassistant\"}], custom_ip=ip\n    )\n\n    expected = {\n        \"name\": \"Home Assistant Local\",\n        \"type\": \"homeassistant\",\n        \"id\": None,\n    }\n\n    resp = await client.get(\"/auth/providers\")\n    assert resp.status == HTTPStatus.OK\n    assert await resp.json() == [expected]\n\n\n@pytest.mark.parametrize(\n    \"ip\",\n    [\n        \"192.168.0.10\",\n        \"::ffff:192.168.0.10\",\n        \"1.2.3.4\",\n        \"2001:db8::1\",\n    ],\n)\nasync def test_fetch_auth_providers_home_assistant_person_not_loaded(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    ip: str,\n) -> None:\n    \"\"\"Test fetching auth providers for homeassistant auth provider, where person integration is not loaded.\"\"\"\n    await _test_fetch_auth_providers_home_assistant(hass, aiohttp_client, ip)\n\n\n@pytest.mark.parametrize(\n    (\"ip\", \"is_local\"),\n    [\n        (\"192.168.0.10\", True),\n        (\"::ffff:192.168.0.10\", True),\n        (\"1.2.3.4\", False),\n        (\"2001:db8::1\", False),\n    ],\n)\nasync def test_fetch_auth_providers_home_assistant_person_loaded(\n    hass: HomeAssistant,\n    aiohttp_client: ClientSessionGenerator,\n    ip: str,\n    is_local: bool,\n) -> None:\n    \"\"\"Test fetching auth providers for homeassistant auth provider, where person integration is loaded.\"\"\"\n    domain = \"person\"\n    config = {domain: {\"id\": \"1234\", \"name\": \"test person\"}}\n    assert await async_setup_component(hass, domain, config)\n\n    await _test_fetch_auth_providers_home_assistant(\n        hass,\n        aiohttp_client,\n        ip,\n    )\n\n\nasync def test_fetch_auth_providers_onboarding(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test fetching auth providers.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client)\n    with patch(\n        \"homeassistant.components.onboarding.async_is_user_onboarded\",\n        return_value=False,\n    ):\n        resp = await client.get(\"/auth/providers\")\n    assert resp.status == HTTPStatus.BAD_REQUEST\n    assert await resp.json() == {\n        \"message\": \"Onboarding not finished\",\n        \"code\": \"onboarding_required\",\n    }\n\n\nasync def test_cannot_get_flows_in_progress(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test we cannot get flows in progress.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, [])\n    resp = await client.get(\"/auth/login_flow\")\n    assert resp.status == HTTPStatus.METHOD_NOT_ALLOWED\n\n\nasync def test_invalid_username_password(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test we cannot get flows in progress.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client)\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    # Incorrect username\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"wrong-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert step[\"step_id\"] == \"init\"\n    assert step[\"errors\"][\"base\"] == \"invalid_auth\"\n\n    # Incorrect password\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"wrong-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert step[\"step_id\"] == \"init\"\n    assert step[\"errors\"][\"base\"] == \"invalid_auth\"\n\n    # Incorrect username and invalid redirect URI fails on wrong login\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"wrong-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert step[\"step_id\"] == \"init\"\n    assert step[\"errors\"][\"base\"] == \"invalid_auth\"\n\n\nasync def test_invalid_redirect_uri(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test invalid redirect URI.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client)\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": \"https://some-other-domain.com\",\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    with patch(\n        \"homeassistant.components.auth.indieauth.fetch_redirect_uris\", return_value=[]\n    ), patch(\n        \"homeassistant.components.http.ban.process_wrong_login\"\n    ) as mock_process_wrong_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.FORBIDDEN\n    data = await resp.json()\n    assert len(mock_process_wrong_login.mock_calls) == 1\n\n    assert data[\"message\"] == \"Invalid redirect URI\"\n\n\nasync def test_login_exist_user(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in with exist user.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    cred = await hass.auth.auth_providers[0].async_get_or_create_credentials(\n        {\"username\": \"test-user\"}\n    )\n    await hass.auth.async_get_or_create_user(cred)\n\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    with patch(\n        \"homeassistant.components.auth.login_flow.process_success_login\"\n    ) as mock_process_success_login:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n    assert step[\"type\"] == \"create_entry\"\n    assert len(step[\"result\"]) > 1\n    assert len(mock_process_success_login.mock_calls) == 1\n\n\nasync def test_login_local_only_user(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in with local only user.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    cred = await hass.auth.auth_providers[0].async_get_or_create_credentials(\n        {\"username\": \"test-user\"}\n    )\n    user = await hass.auth.async_get_or_create_user(cred)\n    await hass.auth.async_update_user(user, local_only=True)\n\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == HTTPStatus.OK\n    step = await resp.json()\n\n    with patch(\n        \"homeassistant.components.auth.login_flow.async_user_not_allowed_do_auth\",\n        return_value=\"User is local only\",\n    ) as mock_not_allowed_do_auth:\n        resp = await client.post(\n            f\"/auth/login_flow/{step['flow_id']}\",\n            json={\n                \"client_id\": CLIENT_ID,\n                \"username\": \"test-user\",\n                \"password\": \"test-pass\",\n            },\n        )\n\n    assert resp.status == HTTPStatus.FORBIDDEN\n    assert len(mock_not_allowed_do_auth.mock_calls) == 1\n    assert await resp.json() == {\"message\": \"Login blocked: User is local only\"}\n\n\nasync def test_login_exist_user_ip_changes(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in and the ip address changes results in an rejection.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    cred = await hass.auth.auth_providers[0].async_get_or_create_credentials(\n        {\"username\": \"test-user\"}\n    )\n    await hass.auth.async_get_or_create_user(cred)\n\n    resp = await client.post(\n        \"/auth/login_flow\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"handler\": [\"insecure_example\", None],\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n        },\n    )\n    assert resp.status == 200\n    step = await resp.json()\n\n    #\n    # Here we modify the ip_address in the context to make sure\n    # when ip address changes in the middle of the login flow we prevent logins.\n    #\n    # This method was chosen because it seemed less likely to break\n    # vs patching aiohttp internals to fake the ip address\n    #\n    for flow_id, flow in hass.auth.login_flow._progress.items():\n        assert flow_id == step[\"flow_id\"]\n        flow.context[\"ip_address\"] = \"10.2.3.1\"\n\n    resp = await client.post(\n        f\"/auth/login_flow/{step['flow_id']}\",\n        json={\n            \"client_id\": CLIENT_ID,\n            \"redirect_uri\": CLIENT_REDIRECT_URI,\n            \"username\": \"test-user\",\n            \"password\": \"test-pass\",\n        },\n    )\n\n    assert resp.status == 400\n    response = await resp.json()\n    assert response == {\"message\": \"IP address changed\"}\n\n\nasync def test_well_known_auth_info(\n    hass: HomeAssistant, aiohttp_client: ClientSessionGenerator\n) -> None:\n    \"\"\"Test logging in and the ip address changes results in an rejection.\"\"\"\n    client = await async_setup_auth(hass, aiohttp_client, setup_api=True)\n    resp = await client.get(\n        \"/.well-known/oauth-authorization-server\",\n    )\n    assert resp.status == 200\n    assert await resp.json() == {\n        \"authorization_endpoint\": \"/auth/authorize\",\n        \"token_endpoint\": \"/auth/token\",\n        \"revocation_endpoint\": \"/auth/revoke\",\n        \"response_types_supported\": [\"code\"],\n        \"service_documentation\": \"https://developers.home-assistant.io/docs/auth_api\",\n    }\n", "\"\"\"The tests for the person component.\"\"\"\nfrom http import HTTPStatus\nfrom typing import Any\nfrom unittest.mock import patch\n\nimport pytest\n\nfrom homeassistant.components import person\nfrom homeassistant.components.device_tracker import ATTR_SOURCE_TYPE, SourceType\nfrom homeassistant.components.person import (\n    ATTR_DEVICE_TRACKERS,\n    ATTR_SOURCE,\n    ATTR_USER_ID,\n    DOMAIN,\n)\nfrom homeassistant.const import (\n    ATTR_ENTITY_PICTURE,\n    ATTR_GPS_ACCURACY,\n    ATTR_ID,\n    ATTR_LATITUDE,\n    ATTR_LONGITUDE,\n    EVENT_HOMEASSISTANT_START,\n    SERVICE_RELOAD,\n    STATE_UNKNOWN,\n)\nfrom homeassistant.core import Context, CoreState, HomeAssistant, State\nfrom homeassistant.helpers import entity_registry as er\nfrom homeassistant.setup import async_setup_component\n\nfrom .conftest import DEVICE_TRACKER, DEVICE_TRACKER_2\n\nfrom tests.common import MockUser, mock_component, mock_restore_cache\nfrom tests.typing import ClientSessionGenerator, WebSocketGenerator\n\n\nasync def test_minimal_setup(hass: HomeAssistant) -> None:\n    \"\"\"Test minimal config with only name.\"\"\"\n    config = {DOMAIN: {\"id\": \"1234\", \"name\": \"test person\"}}\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.test_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) is None\n    assert state.attributes.get(ATTR_ENTITY_PICTURE) is None\n\n\nasync def test_setup_no_id(hass: HomeAssistant) -> None:\n    \"\"\"Test config with no id.\"\"\"\n    config = {DOMAIN: {\"name\": \"test user\"}}\n    assert not await async_setup_component(hass, DOMAIN, config)\n\n\nasync def test_setup_no_name(hass: HomeAssistant) -> None:\n    \"\"\"Test config with no name.\"\"\"\n    config = {DOMAIN: {\"id\": \"1234\"}}\n    assert not await async_setup_component(hass, DOMAIN, config)\n\n\nasync def test_setup_user_id(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test config with user id.\"\"\"\n    user_id = hass_admin_user.id\n    config = {DOMAIN: {\"id\": \"1234\", \"name\": \"test person\", \"user_id\": user_id}}\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.test_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n\n\nasync def test_valid_invalid_user_ids(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test a person with valid user id and a person with invalid user id .\"\"\"\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: [\n            {\"id\": \"1234\", \"name\": \"test valid user\", \"user_id\": user_id},\n            {\"id\": \"5678\", \"name\": \"test bad user\", \"user_id\": \"bad_user_id\"},\n        ]\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.test_valid_user\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    state = hass.states.get(\"person.test_bad_user\")\n    assert state is None\n\n\nasync def test_setup_tracker(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test set up person with one device tracker.\"\"\"\n    hass.state = CoreState.not_running\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": DEVICE_TRACKER,\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [DEVICE_TRACKER]\n\n    hass.states.async_set(\n        DEVICE_TRACKER,\n        \"not_home\",\n        {ATTR_LATITUDE: 10.123456, ATTR_LONGITUDE: 11.123456, ATTR_GPS_ACCURACY: 10},\n    )\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) == 10.123456\n    assert state.attributes.get(ATTR_LONGITUDE) == 11.123456\n    assert state.attributes.get(ATTR_GPS_ACCURACY) == 10\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [DEVICE_TRACKER]\n\n\nasync def test_setup_two_trackers(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test set up person with two device trackers.\"\"\"\n    hass.state = CoreState.not_running\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": [DEVICE_TRACKER, DEVICE_TRACKER_2],\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"home\", {ATTR_SOURCE_TYPE: SourceType.ROUTER})\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_GPS_ACCURACY) is None\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [\n        DEVICE_TRACKER,\n        DEVICE_TRACKER_2,\n    ]\n\n    hass.states.async_set(\n        DEVICE_TRACKER_2,\n        \"not_home\",\n        {\n            ATTR_LATITUDE: 12.123456,\n            ATTR_LONGITUDE: 13.123456,\n            ATTR_GPS_ACCURACY: 12,\n            ATTR_SOURCE_TYPE: SourceType.GPS,\n        },\n    )\n    await hass.async_block_till_done()\n    hass.states.async_set(\n        DEVICE_TRACKER, \"not_home\", {ATTR_SOURCE_TYPE: SourceType.ROUTER}\n    )\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) == 12.123456\n    assert state.attributes.get(ATTR_LONGITUDE) == 13.123456\n    assert state.attributes.get(ATTR_GPS_ACCURACY) == 12\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER_2\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_DEVICE_TRACKERS) == [\n        DEVICE_TRACKER,\n        DEVICE_TRACKER_2,\n    ]\n\n    hass.states.async_set(DEVICE_TRACKER_2, \"zone1\", {ATTR_SOURCE_TYPE: SourceType.GPS})\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"zone1\"\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER_2\n\n    hass.states.async_set(DEVICE_TRACKER, \"home\", {ATTR_SOURCE_TYPE: SourceType.ROUTER})\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER_2, \"zone2\", {ATTR_SOURCE_TYPE: SourceType.GPS})\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n\n\nasync def test_ignore_unavailable_states(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test set up person with two device trackers, one unavailable.\"\"\"\n    hass.state = CoreState.not_running\n    user_id = hass_admin_user.id\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": [DEVICE_TRACKER, DEVICE_TRACKER_2],\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"unavailable\")\n    await hass.async_block_till_done()\n\n    # Unknown, as only 1 device tracker has a state, but we ignore that one\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n\n    hass.states.async_set(DEVICE_TRACKER_2, \"not_home\")\n    await hass.async_block_till_done()\n\n    # Take state of tracker 2\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n\n    # state 1 is newer but ignored, keep tracker 2 state\n    hass.states.async_set(DEVICE_TRACKER, \"unknown\")\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"not_home\"\n\n\nasync def test_restore_home_state(\n    hass: HomeAssistant, hass_admin_user: MockUser\n) -> None:\n    \"\"\"Test that the state is restored for a person on startup.\"\"\"\n    user_id = hass_admin_user.id\n    attrs = {\n        ATTR_ID: \"1234\",\n        ATTR_LATITUDE: 10.12346,\n        ATTR_LONGITUDE: 11.12346,\n        ATTR_SOURCE: DEVICE_TRACKER,\n        ATTR_USER_ID: user_id,\n    }\n    state = State(\"person.tracked_person\", \"home\", attrs)\n    mock_restore_cache(hass, (state,))\n    hass.state = CoreState.not_running\n    mock_component(hass, \"recorder\")\n    config = {\n        DOMAIN: {\n            \"id\": \"1234\",\n            \"name\": \"tracked person\",\n            \"user_id\": user_id,\n            \"device_trackers\": DEVICE_TRACKER,\n            \"picture\": \"/bla\",\n        }\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) == 10.12346\n    assert state.attributes.get(ATTR_LONGITUDE) == 11.12346\n    # When restoring state the entity_id of the person will be used as source.\n    assert state.attributes.get(ATTR_SOURCE) == \"person.tracked_person\"\n    assert state.attributes.get(ATTR_USER_ID) == user_id\n    assert state.attributes.get(ATTR_ENTITY_PICTURE) == \"/bla\"\n\n\nasync def test_duplicate_ids(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test we don't allow duplicate IDs.\"\"\"\n    config = {\n        DOMAIN: [\n            {\"id\": \"1234\", \"name\": \"test user 1\"},\n            {\"id\": \"1234\", \"name\": \"test user 2\"},\n        ]\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    assert len(hass.states.async_entity_ids(\"person\")) == 1\n    assert hass.states.get(\"person.test_user_1\") is not None\n    assert hass.states.get(\"person.test_user_2\") is None\n\n\nasync def test_create_person_during_run(hass: HomeAssistant) -> None:\n    \"\"\"Test that person is updated if created while hass is running.\"\"\"\n    config = {DOMAIN: {}}\n    assert await async_setup_component(hass, DOMAIN, config)\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n\n    await hass.components.person.async_create_person(\n        \"tracked person\", device_trackers=[DEVICE_TRACKER]\n    )\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n\n\nasync def test_load_person_storage(\n    hass: HomeAssistant, hass_admin_user: MockUser, storage_setup\n) -> None:\n    \"\"\"Test set up person from storage.\"\"\"\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == STATE_UNKNOWN\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) is None\n    assert state.attributes.get(ATTR_USER_ID) == hass_admin_user.id\n\n    hass.bus.async_fire(EVENT_HOMEASSISTANT_START)\n    await hass.async_block_till_done()\n    hass.states.async_set(DEVICE_TRACKER, \"home\")\n    await hass.async_block_till_done()\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.state == \"home\"\n    assert state.attributes.get(ATTR_ID) == \"1234\"\n    assert state.attributes.get(ATTR_LATITUDE) is None\n    assert state.attributes.get(ATTR_LONGITUDE) is None\n    assert state.attributes.get(ATTR_SOURCE) == DEVICE_TRACKER\n    assert state.attributes.get(ATTR_USER_ID) == hass_admin_user.id\n\n\nasync def test_load_person_storage_two_nonlinked(\n    hass: HomeAssistant, hass_storage: dict[str, Any]\n) -> None:\n    \"\"\"Test loading two users with both not having a user linked.\"\"\"\n    hass_storage[DOMAIN] = {\n        \"key\": DOMAIN,\n        \"version\": 1,\n        \"data\": {\n            \"persons\": [\n                {\n                    \"id\": \"1234\",\n                    \"name\": \"tracked person 1\",\n                    \"user_id\": None,\n                    \"device_trackers\": [],\n                },\n                {\n                    \"id\": \"5678\",\n                    \"name\": \"tracked person 2\",\n                    \"user_id\": None,\n                    \"device_trackers\": [],\n                },\n            ]\n        },\n    }\n    await async_setup_component(hass, DOMAIN, {})\n\n    assert len(hass.states.async_entity_ids(\"person\")) == 2\n    assert hass.states.get(\"person.tracked_person_1\") is not None\n    assert hass.states.get(\"person.tracked_person_2\") is not None\n\n\nasync def test_ws_list(\n    hass: HomeAssistant, hass_ws_client: WebSocketGenerator, storage_setup\n) -> None:\n    \"\"\"Test listing via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json({\"id\": 6, \"type\": \"person/list\"})\n    resp = await client.receive_json()\n    assert resp[\"success\"]\n    assert resp[\"result\"][\"storage\"] == manager.async_items()\n    assert len(resp[\"result\"][\"storage\"]) == 1\n    assert len(resp[\"result\"][\"config\"]) == 0\n\n\nasync def test_ws_create(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_read_only_user: MockUser,\n) -> None:\n    \"\"\"Test creating via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/create\",\n            \"name\": \"Hello\",\n            \"device_trackers\": [DEVICE_TRACKER],\n            \"user_id\": hass_read_only_user.id,\n            \"picture\": \"/bla\",\n        }\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 2\n\n    assert resp[\"success\"]\n    assert resp[\"result\"] == persons[1]\n\n\nasync def test_ws_create_requires_admin(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_admin_user: MockUser,\n    hass_read_only_user: MockUser,\n) -> None:\n    \"\"\"Test creating via WS requires admin.\"\"\"\n    hass_admin_user.groups = []\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/create\",\n            \"name\": \"Hello\",\n            \"device_trackers\": [DEVICE_TRACKER],\n            \"user_id\": hass_read_only_user.id,\n        }\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 1\n\n    assert not resp[\"success\"]\n\n\nasync def test_ws_update(\n    hass: HomeAssistant, hass_ws_client: WebSocketGenerator, storage_setup\n) -> None:\n    \"\"\"Test updating via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n    persons = manager.async_items()\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/update\",\n            \"person_id\": persons[0][\"id\"],\n            \"user_id\": persons[0][\"user_id\"],\n        }\n    )\n    resp = await client.receive_json()\n\n    assert resp[\"success\"]\n\n    resp = await client.send_json(\n        {\n            \"id\": 7,\n            \"type\": \"person/update\",\n            \"person_id\": persons[0][\"id\"],\n            \"name\": \"Updated Name\",\n            \"device_trackers\": [DEVICE_TRACKER_2],\n            \"user_id\": None,\n            \"picture\": \"/bla\",\n        }\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 1\n\n    assert resp[\"success\"]\n    assert resp[\"result\"] == persons[0]\n    assert persons[0][\"name\"] == \"Updated Name\"\n    assert persons[0][\"name\"] == \"Updated Name\"\n    assert persons[0][\"device_trackers\"] == [DEVICE_TRACKER_2]\n    assert persons[0][\"user_id\"] is None\n    assert persons[0][\"picture\"] == \"/bla\"\n\n    state = hass.states.get(\"person.tracked_person\")\n    assert state.name == \"Updated Name\"\n\n\nasync def test_ws_update_require_admin(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_admin_user: MockUser,\n) -> None:\n    \"\"\"Test updating via WS requires admin.\"\"\"\n    hass_admin_user.groups = []\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n    original = dict(manager.async_items()[0])\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/update\",\n            \"person_id\": original[\"id\"],\n            \"name\": \"Updated Name\",\n            \"device_trackers\": [DEVICE_TRACKER_2],\n            \"user_id\": None,\n        }\n    )\n    resp = await client.receive_json()\n    assert not resp[\"success\"]\n\n    not_updated = dict(manager.async_items()[0])\n    assert original == not_updated\n\n\nasync def test_ws_delete(\n    hass: HomeAssistant, hass_ws_client: WebSocketGenerator, storage_setup\n) -> None:\n    \"\"\"Test deleting via WS.\"\"\"\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n    persons = manager.async_items()\n\n    resp = await client.send_json(\n        {\"id\": 6, \"type\": \"person/delete\", \"person_id\": persons[0][\"id\"]}\n    )\n    resp = await client.receive_json()\n\n    persons = manager.async_items()\n    assert len(persons) == 0\n\n    assert resp[\"success\"]\n    assert len(hass.states.async_entity_ids(\"person\")) == 0\n    ent_reg = er.async_get(hass)\n    assert not ent_reg.async_is_registered(\"person.tracked_person\")\n\n\nasync def test_ws_delete_require_admin(\n    hass: HomeAssistant,\n    hass_ws_client: WebSocketGenerator,\n    storage_setup,\n    hass_admin_user: MockUser,\n) -> None:\n    \"\"\"Test deleting via WS requires admin.\"\"\"\n    hass_admin_user.groups = []\n    manager = hass.data[DOMAIN][1]\n\n    client = await hass_ws_client(hass)\n\n    resp = await client.send_json(\n        {\n            \"id\": 6,\n            \"type\": \"person/delete\",\n            \"person_id\": manager.async_items()[0][\"id\"],\n            \"name\": \"Updated Name\",\n            \"device_trackers\": [DEVICE_TRACKER_2],\n            \"user_id\": None,\n        }\n    )\n    resp = await client.receive_json()\n    assert not resp[\"success\"]\n\n    persons = manager.async_items()\n    assert len(persons) == 1\n\n\nasync def test_create_invalid_user_id(hass: HomeAssistant, storage_collection) -> None:\n    \"\"\"Test we do not allow invalid user ID during creation.\"\"\"\n    with pytest.raises(ValueError):\n        await storage_collection.async_create_item(\n            {\"name\": \"Hello\", \"user_id\": \"non-existing\"}\n        )\n\n\nasync def test_create_duplicate_user_id(\n    hass: HomeAssistant, hass_admin_user: MockUser, storage_collection\n) -> None:\n    \"\"\"Test we do not allow duplicate user ID during creation.\"\"\"\n    await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"user_id\": hass_admin_user.id}\n    )\n\n    with pytest.raises(ValueError):\n        await storage_collection.async_create_item(\n            {\"name\": \"Hello\", \"user_id\": hass_admin_user.id}\n        )\n\n\nasync def test_update_double_user_id(\n    hass: HomeAssistant, hass_admin_user: MockUser, storage_collection\n) -> None:\n    \"\"\"Test we do not allow double user ID during update.\"\"\"\n    await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"user_id\": hass_admin_user.id}\n    )\n    person = await storage_collection.async_create_item({\"name\": \"Hello\"})\n\n    with pytest.raises(ValueError):\n        await storage_collection.async_update_item(\n            person[\"id\"], {\"user_id\": hass_admin_user.id}\n        )\n\n\nasync def test_update_invalid_user_id(hass: HomeAssistant, storage_collection) -> None:\n    \"\"\"Test updating to invalid user ID.\"\"\"\n    person = await storage_collection.async_create_item({\"name\": \"Hello\"})\n\n    with pytest.raises(ValueError):\n        await storage_collection.async_update_item(\n            person[\"id\"], {\"user_id\": \"non-existing\"}\n        )\n\n\nasync def test_update_person_when_user_removed(\n    hass: HomeAssistant, storage_setup, hass_read_only_user: MockUser\n) -> None:\n    \"\"\"Update person when user is removed.\"\"\"\n    storage_collection = hass.data[DOMAIN][1]\n\n    person = await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"user_id\": hass_read_only_user.id}\n    )\n\n    await hass.auth.async_remove_user(hass_read_only_user)\n    await hass.async_block_till_done()\n\n    assert storage_collection.data[person[\"id\"]][\"user_id\"] is None\n\n\nasync def test_removing_device_tracker(hass: HomeAssistant, storage_setup) -> None:\n    \"\"\"Test we automatically remove removed device trackers.\"\"\"\n    storage_collection = hass.data[DOMAIN][1]\n    reg = er.async_get(hass)\n    entry = reg.async_get_or_create(\n        \"device_tracker\", \"mobile_app\", \"bla\", suggested_object_id=\"pixel\"\n    )\n\n    person = await storage_collection.async_create_item(\n        {\"name\": \"Hello\", \"device_trackers\": [entry.entity_id]}\n    )\n\n    reg.async_remove(entry.entity_id)\n    await hass.async_block_till_done()\n\n    assert storage_collection.data[person[\"id\"]][\"device_trackers\"] == []\n\n\nasync def test_add_user_device_tracker(\n    hass: HomeAssistant, storage_setup, hass_read_only_user: MockUser\n) -> None:\n    \"\"\"Test adding a device tracker to a person tied to a user.\"\"\"\n    storage_collection = hass.data[DOMAIN][1]\n    pers = await storage_collection.async_create_item(\n        {\n            \"name\": \"Hello\",\n            \"user_id\": hass_read_only_user.id,\n            \"device_trackers\": [\"device_tracker.on_create\"],\n        }\n    )\n\n    await person.async_add_user_device_tracker(\n        hass, hass_read_only_user.id, \"device_tracker.added\"\n    )\n\n    assert storage_collection.data[pers[\"id\"]][\"device_trackers\"] == [\n        \"device_tracker.on_create\",\n        \"device_tracker.added\",\n    ]\n\n\nasync def test_reload(hass: HomeAssistant, hass_admin_user: MockUser) -> None:\n    \"\"\"Test reloading the YAML config.\"\"\"\n    assert await async_setup_component(\n        hass,\n        DOMAIN,\n        {\n            DOMAIN: [\n                {\"name\": \"Person 1\", \"id\": \"id-1\"},\n                {\"name\": \"Person 2\", \"id\": \"id-2\"},\n            ]\n        },\n    )\n\n    assert len(hass.states.async_entity_ids()) == 2\n\n    state_1 = hass.states.get(\"person.person_1\")\n    state_2 = hass.states.get(\"person.person_2\")\n    state_3 = hass.states.get(\"person.person_3\")\n\n    assert state_1 is not None\n    assert state_1.name == \"Person 1\"\n    assert state_2 is not None\n    assert state_2.name == \"Person 2\"\n    assert state_3 is None\n\n    with patch(\n        \"homeassistant.config.load_yaml_config_file\",\n        autospec=True,\n        return_value={\n            DOMAIN: [\n                {\"name\": \"Person 1-updated\", \"id\": \"id-1\"},\n                {\"name\": \"Person 3\", \"id\": \"id-3\"},\n            ]\n        },\n    ):\n        await hass.services.async_call(\n            DOMAIN,\n            SERVICE_RELOAD,\n            blocking=True,\n            context=Context(user_id=hass_admin_user.id),\n        )\n        await hass.async_block_till_done()\n\n    assert len(hass.states.async_entity_ids()) == 2\n\n    state_1 = hass.states.get(\"person.person_1\")\n    state_2 = hass.states.get(\"person.person_2\")\n    state_3 = hass.states.get(\"person.person_3\")\n\n    assert state_1 is not None\n    assert state_1.name == \"Person 1-updated\"\n    assert state_2 is None\n    assert state_3 is not None\n    assert state_3.name == \"Person 3\"\n\n\nasync def test_person_storage_fixing_device_trackers(storage_collection) -> None:\n    \"\"\"Test None device trackers become lists.\"\"\"\n    with patch.object(\n        storage_collection.store,\n        \"async_load\",\n        return_value={\"items\": [{\"id\": \"bla\", \"name\": \"bla\", \"device_trackers\": None}]},\n    ):\n        await storage_collection.async_load()\n\n    assert storage_collection.data[\"bla\"][\"device_trackers\"] == []\n\n\nasync def test_persons_with_entity(hass: HomeAssistant) -> None:\n    \"\"\"Test finding persons with an entity.\"\"\"\n    assert await async_setup_component(\n        hass,\n        \"person\",\n        {\n            \"person\": [\n                {\n                    \"id\": \"abcd\",\n                    \"name\": \"Paulus\",\n                    \"device_trackers\": [\n                        \"device_tracker.paulus_iphone\",\n                        \"device_tracker.paulus_ipad\",\n                    ],\n                },\n                {\n                    \"id\": \"efgh\",\n                    \"name\": \"Anne Therese\",\n                    \"device_trackers\": [\n                        \"device_tracker.at_pixel\",\n                    ],\n                },\n            ]\n        },\n    )\n\n    assert person.persons_with_entity(hass, \"device_tracker.paulus_iphone\") == [\n        \"person.paulus\"\n    ]\n\n\nasync def test_entities_in_person(hass: HomeAssistant) -> None:\n    \"\"\"Test finding entities tracked by person.\"\"\"\n    assert await async_setup_component(\n        hass,\n        \"person\",\n        {\n            \"person\": [\n                {\n                    \"id\": \"abcd\",\n                    \"name\": \"Paulus\",\n                    \"device_trackers\": [\n                        \"device_tracker.paulus_iphone\",\n                        \"device_tracker.paulus_ipad\",\n                    ],\n                }\n            ]\n        },\n    )\n\n    assert person.entities_in_person(hass, \"person.paulus\") == [\n        \"device_tracker.paulus_iphone\",\n        \"device_tracker.paulus_ipad\",\n    ]\n\n\nasync def test_list_persons(\n    hass: HomeAssistant,\n    hass_client_no_auth: ClientSessionGenerator,\n    hass_admin_user: MockUser,\n) -> None:\n    \"\"\"Test listing persons from a not local ip address.\"\"\"\n\n    user_id = hass_admin_user.id\n    admin = {\"id\": \"1234\", \"name\": \"Admin\", \"user_id\": user_id, \"picture\": \"/bla\"}\n    config = {\n        DOMAIN: [\n            admin,\n            {\"id\": \"5678\", \"name\": \"Only a person\"},\n        ]\n    }\n    assert await async_setup_component(hass, DOMAIN, config)\n\n    await async_setup_component(hass, \"api\", {})\n    client = await hass_client_no_auth()\n\n    resp = await client.get(\"/api/person/list\")\n\n    assert resp.status == HTTPStatus.BAD_REQUEST\n    result = await resp.json()\n    assert result == {\"code\": \"not_local\", \"message\": \"Not local\"}\n"], "filenames": ["homeassistant/components/auth/login_flow.py", "homeassistant/components/person/__init__.py", "tests/components/auth/test_login_flow.py", "tests/components/person/test_init.py"], "buggy_code_start_loc": [94, 5, 2, 2], "buggy_code_end_loc": [206, 621, 138, 913], "fixing_code_start_loc": [93, 4, 1, 1], "fixing_code_end_loc": [184, 593, 126, 878], "type": "NVD-CWE-noinfo", "message": "Home Assistant is open source home automation software. Prior to version 2023.12.3, the login page discloses all active user accounts to any unauthenticated browsing request originating on the Local Area Network. Version 2023.12.3 contains a patch for this issue.\n\nWhen starting the Home Assistant 2023.12 release, the login page returns all currently active user accounts to browsing requests from the Local Area Network. Tests showed that this occurs when the request is not authenticated and the request originated locally, meaning on the Home Assistant host local subnet or any other private subnet. The rationale behind this is to make the login more user-friendly and an experience better aligned with other applications that have multiple user-profiles.\n\nHowever, as a result, all accounts are displayed regardless of them having logged in or not and for any device that navigates to the server. This disclosure is mitigated by the fact that it only occurs for requests originating from a LAN address. But note that this applies to the local subnet where Home Assistant resides and to any private subnet that can reach it.", "other": {"cve": {"id": "CVE-2023-50715", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-15T03:15:45.127", "lastModified": "2023-12-27T18:39:30.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Home Assistant is open source home automation software. Prior to version 2023.12.3, the login page discloses all active user accounts to any unauthenticated browsing request originating on the Local Area Network. Version 2023.12.3 contains a patch for this issue.\n\nWhen starting the Home Assistant 2023.12 release, the login page returns all currently active user accounts to browsing requests from the Local Area Network. Tests showed that this occurs when the request is not authenticated and the request originated locally, meaning on the Home Assistant host local subnet or any other private subnet. The rationale behind this is to make the login more user-friendly and an experience better aligned with other applications that have multiple user-profiles.\n\nHowever, as a result, all accounts are displayed regardless of them having logged in or not and for any device that navigates to the server. This disclosure is mitigated by the fact that it only occurs for requests originating from a LAN address. But note that this applies to the local subnet where Home Assistant resides and to any private subnet that can reach it."}, {"lang": "es", "value": "Home Assistant es un software de dom\u00f3tica de c\u00f3digo abierto. Antes de la versi\u00f3n 2023.12.3, la p\u00e1gina de inicio de sesi\u00f3n revela todas las cuentas de usuario activas a cualquier solicitud de navegaci\u00f3n no autenticada que se origine en la red de \u00e1rea local. La versi\u00f3n 2023.12.3 contiene un parche para este problema. Al iniciar la versi\u00f3n Home Assistant 2023.12, la p\u00e1gina de inicio de sesi\u00f3n devuelve todas las cuentas de usuario actualmente activas a las solicitudes de navegaci\u00f3n de la red de \u00e1rea local. Las pruebas demostraron que esto ocurre cuando la solicitud no est\u00e1 autenticada y la solicitud se origin\u00f3 localmente, es decir, en la subred local del host de Home Assistant o en cualquier otra subred privada. La raz\u00f3n detr\u00e1s de esto es hacer que el inicio de sesi\u00f3n sea m\u00e1s f\u00e1cil de usar y una experiencia mejor alineada con otras aplicaciones que tienen m\u00faltiples perfiles de usuario. Sin embargo, como resultado, se muestran todas las cuentas independientemente de que hayan iniciado sesi\u00f3n o no y para cualquier dispositivo que navegue hasta el servidor. Esta divulgaci\u00f3n se ve mitigada por el hecho de que solo ocurre para solicitudes que se originan en una direcci\u00f3n LAN. Pero tenga en cuenta que esto se aplica a la subred local donde reside Home Assistant y a cualquier subred privada que pueda acceder a ella."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:home-assistant:home-assistant:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023.12.3", "matchCriteriaId": "FADE988B-E6D6-498D-883F-0DDBFE62EC24"}]}]}], "references": [{"url": "https://github.com/home-assistant/core/commit/dbfc5ea8f96bde6cd165892f5a6a6f9a65731c76", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/home-assistant/core/security/advisories/GHSA-jqpc-rc7g-vf83", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/home-assistant/core/commit/dbfc5ea8f96bde6cd165892f5a6a6f9a65731c76"}}