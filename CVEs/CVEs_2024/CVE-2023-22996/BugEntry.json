{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2019, Linaro Ltd\n */\n#include <linux/clk-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/qcom_aoss.h>\n\n#define QMP_DESC_MAGIC\t\t\t0x0\n#define QMP_DESC_VERSION\t\t0x4\n#define QMP_DESC_FEATURES\t\t0x8\n\n/* AOP-side offsets */\n#define QMP_DESC_UCORE_LINK_STATE\t0xc\n#define QMP_DESC_UCORE_LINK_STATE_ACK\t0x10\n#define QMP_DESC_UCORE_CH_STATE\t\t0x14\n#define QMP_DESC_UCORE_CH_STATE_ACK\t0x18\n#define QMP_DESC_UCORE_MBOX_SIZE\t0x1c\n#define QMP_DESC_UCORE_MBOX_OFFSET\t0x20\n\n/* Linux-side offsets */\n#define QMP_DESC_MCORE_LINK_STATE\t0x24\n#define QMP_DESC_MCORE_LINK_STATE_ACK\t0x28\n#define QMP_DESC_MCORE_CH_STATE\t\t0x2c\n#define QMP_DESC_MCORE_CH_STATE_ACK\t0x30\n#define QMP_DESC_MCORE_MBOX_SIZE\t0x34\n#define QMP_DESC_MCORE_MBOX_OFFSET\t0x38\n\n#define QMP_STATE_UP\t\t\tGENMASK(15, 0)\n#define QMP_STATE_DOWN\t\t\tGENMASK(31, 16)\n\n#define QMP_MAGIC\t\t\t0x4d41494c /* mail */\n#define QMP_VERSION\t\t\t1\n\n/* 64 bytes is enough to store the requests and provides padding to 4 bytes */\n#define QMP_MSG_LEN\t\t\t64\n\n#define QMP_NUM_COOLING_RESOURCES\t2\n\nstatic bool qmp_cdev_max_state = 1;\n\nstruct qmp_cooling_device {\n\tstruct thermal_cooling_device *cdev;\n\tstruct qmp *qmp;\n\tchar *name;\n\tbool state;\n};\n\n/**\n * struct qmp - driver state for QMP implementation\n * @msgram: iomem referencing the message RAM used for communication\n * @dev: reference to QMP device\n * @mbox_client: mailbox client used to ring the doorbell on transmit\n * @mbox_chan: mailbox channel used to ring the doorbell on transmit\n * @offset: offset within @msgram where messages should be written\n * @size: maximum size of the messages to be transmitted\n * @event: wait_queue for synchronization with the IRQ\n * @tx_lock: provides synchronization between multiple callers of qmp_send()\n * @qdss_clk: QDSS clock hw struct\n * @cooling_devs: thermal cooling devices\n */\nstruct qmp {\n\tvoid __iomem *msgram;\n\tstruct device *dev;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tsize_t offset;\n\tsize_t size;\n\n\twait_queue_head_t event;\n\n\tstruct mutex tx_lock;\n\n\tstruct clk_hw qdss_clk;\n\tstruct qmp_cooling_device *cooling_devs;\n};\n\nstatic void qmp_kick(struct qmp *qmp)\n{\n\tmbox_send_message(qmp->mbox_chan, NULL);\n\tmbox_client_txdone(qmp->mbox_chan, 0);\n}\n\nstatic bool qmp_magic_valid(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MAGIC) == QMP_MAGIC;\n}\n\nstatic bool qmp_link_acked(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MCORE_LINK_STATE_ACK) == QMP_STATE_UP;\n}\n\nstatic bool qmp_mcore_channel_acked(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MCORE_CH_STATE_ACK) == QMP_STATE_UP;\n}\n\nstatic bool qmp_ucore_channel_up(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_UCORE_CH_STATE) == QMP_STATE_UP;\n}\n\nstatic int qmp_open(struct qmp *qmp)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!qmp_magic_valid(qmp)) {\n\t\tdev_err(qmp->dev, \"QMP magic doesn't match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(qmp->msgram + QMP_DESC_VERSION);\n\tif (val != QMP_VERSION) {\n\t\tdev_err(qmp->dev, \"unsupported QMP version %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tqmp->offset = readl(qmp->msgram + QMP_DESC_MCORE_MBOX_OFFSET);\n\tqmp->size = readl(qmp->msgram + QMP_DESC_MCORE_MBOX_SIZE);\n\tif (!qmp->size) {\n\t\tdev_err(qmp->dev, \"invalid mailbox size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ack remote core's link state */\n\tval = readl(qmp->msgram + QMP_DESC_UCORE_LINK_STATE);\n\twritel(val, qmp->msgram + QMP_DESC_UCORE_LINK_STATE_ACK);\n\n\t/* Set local core's link state to up */\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_link_acked(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't ack link\\n\");\n\t\tgoto timeout_close_link;\n\t}\n\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_ucore_channel_up(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't open channel\\n\");\n\t\tgoto timeout_close_channel;\n\t}\n\n\t/* Ack remote core's channel state */\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_UCORE_CH_STATE_ACK);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_mcore_channel_acked(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't ack channel\\n\");\n\t\tgoto timeout_close_channel;\n\t}\n\n\treturn 0;\n\ntimeout_close_channel:\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\ntimeout_close_link:\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\tqmp_kick(qmp);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void qmp_close(struct qmp *qmp)\n{\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\tqmp_kick(qmp);\n}\n\nstatic irqreturn_t qmp_intr(int irq, void *data)\n{\n\tstruct qmp *qmp = data;\n\n\twake_up_all(&qmp->event);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool qmp_message_empty(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + qmp->offset) == 0;\n}\n\n/**\n * qmp_send() - send a message to the AOSS\n * @qmp: qmp context\n * @data: message to be sent\n * @len: length of the message\n *\n * Transmit @data to AOSS and wait for the AOSS to acknowledge the message.\n * @len must be a multiple of 4 and not longer than the mailbox size. Access is\n * synchronized by this implementation.\n *\n * Return: 0 on success, negative errno on failure\n */\nint qmp_send(struct qmp *qmp, const void *data, size_t len)\n{\n\tlong time_left;\n\tint ret;\n\n\tif (WARN_ON(IS_ERR_OR_NULL(qmp) || !data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(len + sizeof(u32) > qmp->size))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(len % sizeof(u32)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&qmp->tx_lock);\n\n\t/* The message RAM only implements 32-bit accesses */\n\t__iowrite32_copy(qmp->msgram + qmp->offset + sizeof(u32),\n\t\t\t data, len / sizeof(u32));\n\twritel(len, qmp->msgram + qmp->offset);\n\n\t/* Read back len to confirm data written in message RAM */\n\treadl(qmp->msgram + qmp->offset);\n\tqmp_kick(qmp);\n\n\ttime_left = wait_event_interruptible_timeout(qmp->event,\n\t\t\t\t\t\t     qmp_message_empty(qmp), HZ);\n\tif (!time_left) {\n\t\tdev_err(qmp->dev, \"ucore did not ack channel\\n\");\n\t\tret = -ETIMEDOUT;\n\n\t\t/* Clear message from buffer */\n\t\twritel(0, qmp->msgram + qmp->offset);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tmutex_unlock(&qmp->tx_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qmp_send);\n\nstatic int qmp_qdss_clk_prepare(struct clk_hw *hw)\n{\n\tstatic const char buf[QMP_MSG_LEN] = \"{class: clock, res: qdss, val: 1}\";\n\tstruct qmp *qmp = container_of(hw, struct qmp, qdss_clk);\n\n\treturn qmp_send(qmp, buf, sizeof(buf));\n}\n\nstatic void qmp_qdss_clk_unprepare(struct clk_hw *hw)\n{\n\tstatic const char buf[QMP_MSG_LEN] = \"{class: clock, res: qdss, val: 0}\";\n\tstruct qmp *qmp = container_of(hw, struct qmp, qdss_clk);\n\n\tqmp_send(qmp, buf, sizeof(buf));\n}\n\nstatic const struct clk_ops qmp_qdss_clk_ops = {\n\t.prepare = qmp_qdss_clk_prepare,\n\t.unprepare = qmp_qdss_clk_unprepare,\n};\n\nstatic int qmp_qdss_clk_add(struct qmp *qmp)\n{\n\tstatic const struct clk_init_data qdss_init = {\n\t\t.ops = &qmp_qdss_clk_ops,\n\t\t.name = \"qdss\",\n\t};\n\tint ret;\n\n\tqmp->qdss_clk.init = &qdss_init;\n\tret = clk_hw_register(qmp->dev, &qmp->qdss_clk);\n\tif (ret < 0) {\n\t\tdev_err(qmp->dev, \"failed to register qdss clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_clk_add_hw_provider(qmp->dev->of_node, of_clk_hw_simple_get,\n\t\t\t\t     &qmp->qdss_clk);\n\tif (ret < 0) {\n\t\tdev_err(qmp->dev, \"unable to register of clk hw provider\\n\");\n\t\tclk_hw_unregister(&qmp->qdss_clk);\n\t}\n\n\treturn ret;\n}\n\nstatic void qmp_qdss_clk_remove(struct qmp *qmp)\n{\n\tof_clk_del_provider(qmp->dev->of_node);\n\tclk_hw_unregister(&qmp->qdss_clk);\n}\n\nstatic int qmp_cdev_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\t*state = qmp_cdev_max_state;\n\treturn 0;\n}\n\nstatic int qmp_cdev_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\tstruct qmp_cooling_device *qmp_cdev = cdev->devdata;\n\n\t*state = qmp_cdev->state;\n\treturn 0;\n}\n\nstatic int qmp_cdev_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long state)\n{\n\tstruct qmp_cooling_device *qmp_cdev = cdev->devdata;\n\tchar buf[QMP_MSG_LEN] = {};\n\tbool cdev_state;\n\tint ret;\n\n\t/* Normalize state */\n\tcdev_state = !!state;\n\n\tif (qmp_cdev->state == state)\n\t\treturn 0;\n\n\tsnprintf(buf, sizeof(buf),\n\t\t \"{class: volt_flr, event:zero_temp, res:%s, value:%s}\",\n\t\t\tqmp_cdev->name,\n\t\t\tcdev_state ? \"on\" : \"off\");\n\n\tret = qmp_send(qmp_cdev->qmp, buf, sizeof(buf));\n\n\tif (!ret)\n\t\tqmp_cdev->state = cdev_state;\n\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops qmp_cooling_device_ops = {\n\t.get_max_state = qmp_cdev_get_max_state,\n\t.get_cur_state = qmp_cdev_get_cur_state,\n\t.set_cur_state = qmp_cdev_set_cur_state,\n};\n\nstatic int qmp_cooling_device_add(struct qmp *qmp,\n\t\t\t\t  struct qmp_cooling_device *qmp_cdev,\n\t\t\t\t  struct device_node *node)\n{\n\tchar *cdev_name = (char *)node->name;\n\n\tqmp_cdev->qmp = qmp;\n\tqmp_cdev->state = !qmp_cdev_max_state;\n\tqmp_cdev->name = cdev_name;\n\tqmp_cdev->cdev = devm_thermal_of_cooling_device_register\n\t\t\t\t(qmp->dev, node,\n\t\t\t\tcdev_name,\n\t\t\t\tqmp_cdev, &qmp_cooling_device_ops);\n\n\tif (IS_ERR(qmp_cdev->cdev))\n\t\tdev_err(qmp->dev, \"unable to register %s cooling device\\n\",\n\t\t\tcdev_name);\n\n\treturn PTR_ERR_OR_ZERO(qmp_cdev->cdev);\n}\n\nstatic int qmp_cooling_devices_register(struct qmp *qmp)\n{\n\tstruct device_node *np, *child;\n\tint count = 0;\n\tint ret;\n\n\tnp = qmp->dev->of_node;\n\n\tqmp->cooling_devs = devm_kcalloc(qmp->dev, QMP_NUM_COOLING_RESOURCES,\n\t\t\t\t\t sizeof(*qmp->cooling_devs),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (!qmp->cooling_devs)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (!of_find_property(child, \"#cooling-cells\", NULL))\n\t\t\tcontinue;\n\t\tret = qmp_cooling_device_add(qmp, &qmp->cooling_devs[count++],\n\t\t\t\t\t     child);\n\t\tif (ret)\n\t\t\tgoto unroll;\n\t}\n\n\tif (!count)\n\t\tdevm_kfree(qmp->dev, qmp->cooling_devs);\n\n\treturn 0;\n\nunroll:\n\twhile (--count >= 0)\n\t\tthermal_cooling_device_unregister\n\t\t\t(qmp->cooling_devs[count].cdev);\n\tdevm_kfree(qmp->dev, qmp->cooling_devs);\n\n\treturn ret;\n}\n\nstatic void qmp_cooling_devices_remove(struct qmp *qmp)\n{\n\tint i;\n\n\tfor (i = 0; i < QMP_NUM_COOLING_RESOURCES; i++)\n\t\tthermal_cooling_device_unregister(qmp->cooling_devs[i].cdev);\n}\n\n/**\n * qmp_get() - get a qmp handle from a device\n * @dev: client device pointer\n *\n * Return: handle to qmp device on success, ERR_PTR() on failure\n */\nstruct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL(qmp_get);\n\n/**\n * qmp_put() - release a qmp handle\n * @qmp: qmp handle obtained from qmp_get()\n */\nvoid qmp_put(struct qmp *qmp)\n{\n\t/*\n\t * Match get_device() inside of_find_device_by_node() in\n\t * qmp_get()\n\t */\n\tif (!IS_ERR_OR_NULL(qmp))\n\t\tput_device(qmp->dev);\n}\nEXPORT_SYMBOL(qmp_put);\n\nstatic int qmp_probe(struct platform_device *pdev)\n{\n\tstruct qmp *qmp;\n\tint irq;\n\tint ret;\n\n\tqmp = devm_kzalloc(&pdev->dev, sizeof(*qmp), GFP_KERNEL);\n\tif (!qmp)\n\t\treturn -ENOMEM;\n\n\tqmp->dev = &pdev->dev;\n\tinit_waitqueue_head(&qmp->event);\n\tmutex_init(&qmp->tx_lock);\n\n\tqmp->msgram = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qmp->msgram))\n\t\treturn PTR_ERR(qmp->msgram);\n\n\tqmp->mbox_client.dev = &pdev->dev;\n\tqmp->mbox_client.knows_txdone = true;\n\tqmp->mbox_chan = mbox_request_channel(&qmp->mbox_client, 0);\n\tif (IS_ERR(qmp->mbox_chan)) {\n\t\tdev_err(&pdev->dev, \"failed to acquire ipc mailbox\\n\");\n\t\treturn PTR_ERR(qmp->mbox_chan);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, qmp_intr, IRQF_ONESHOT,\n\t\t\t       \"aoss-qmp\", qmp);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request interrupt\\n\");\n\t\tgoto err_free_mbox;\n\t}\n\n\tret = qmp_open(qmp);\n\tif (ret < 0)\n\t\tgoto err_free_mbox;\n\n\tret = qmp_qdss_clk_add(qmp);\n\tif (ret)\n\t\tgoto err_close_qmp;\n\n\tret = qmp_cooling_devices_register(qmp);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to register aoss cooling devices\\n\");\n\n\tplatform_set_drvdata(pdev, qmp);\n\n\treturn 0;\n\nerr_close_qmp:\n\tqmp_close(qmp);\nerr_free_mbox:\n\tmbox_free_channel(qmp->mbox_chan);\n\n\treturn ret;\n}\n\nstatic int qmp_remove(struct platform_device *pdev)\n{\n\tstruct qmp *qmp = platform_get_drvdata(pdev);\n\n\tqmp_qdss_clk_remove(qmp);\n\tqmp_cooling_devices_remove(qmp);\n\n\tqmp_close(qmp);\n\tmbox_free_channel(qmp->mbox_chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qmp_dt_match[] = {\n\t{ .compatible = \"qcom,sc7180-aoss-qmp\", },\n\t{ .compatible = \"qcom,sc7280-aoss-qmp\", },\n\t{ .compatible = \"qcom,sdm845-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8150-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8250-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8350-aoss-qmp\", },\n\t{ .compatible = \"qcom,aoss-qmp\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qmp_dt_match);\n\nstatic struct platform_driver qmp_driver = {\n\t.driver = {\n\t\t.name\t\t= \"qcom_aoss_qmp\",\n\t\t.of_match_table\t= qmp_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = qmp_probe,\n\t.remove\t= qmp_remove,\n};\nmodule_platform_driver(qmp_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm AOSS QMP driver\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2019, Linaro Ltd\n */\n#include <linux/clk-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/thermal.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/qcom_aoss.h>\n\n#define QMP_DESC_MAGIC\t\t\t0x0\n#define QMP_DESC_VERSION\t\t0x4\n#define QMP_DESC_FEATURES\t\t0x8\n\n/* AOP-side offsets */\n#define QMP_DESC_UCORE_LINK_STATE\t0xc\n#define QMP_DESC_UCORE_LINK_STATE_ACK\t0x10\n#define QMP_DESC_UCORE_CH_STATE\t\t0x14\n#define QMP_DESC_UCORE_CH_STATE_ACK\t0x18\n#define QMP_DESC_UCORE_MBOX_SIZE\t0x1c\n#define QMP_DESC_UCORE_MBOX_OFFSET\t0x20\n\n/* Linux-side offsets */\n#define QMP_DESC_MCORE_LINK_STATE\t0x24\n#define QMP_DESC_MCORE_LINK_STATE_ACK\t0x28\n#define QMP_DESC_MCORE_CH_STATE\t\t0x2c\n#define QMP_DESC_MCORE_CH_STATE_ACK\t0x30\n#define QMP_DESC_MCORE_MBOX_SIZE\t0x34\n#define QMP_DESC_MCORE_MBOX_OFFSET\t0x38\n\n#define QMP_STATE_UP\t\t\tGENMASK(15, 0)\n#define QMP_STATE_DOWN\t\t\tGENMASK(31, 16)\n\n#define QMP_MAGIC\t\t\t0x4d41494c /* mail */\n#define QMP_VERSION\t\t\t1\n\n/* 64 bytes is enough to store the requests and provides padding to 4 bytes */\n#define QMP_MSG_LEN\t\t\t64\n\n#define QMP_NUM_COOLING_RESOURCES\t2\n\nstatic bool qmp_cdev_max_state = 1;\n\nstruct qmp_cooling_device {\n\tstruct thermal_cooling_device *cdev;\n\tstruct qmp *qmp;\n\tchar *name;\n\tbool state;\n};\n\n/**\n * struct qmp - driver state for QMP implementation\n * @msgram: iomem referencing the message RAM used for communication\n * @dev: reference to QMP device\n * @mbox_client: mailbox client used to ring the doorbell on transmit\n * @mbox_chan: mailbox channel used to ring the doorbell on transmit\n * @offset: offset within @msgram where messages should be written\n * @size: maximum size of the messages to be transmitted\n * @event: wait_queue for synchronization with the IRQ\n * @tx_lock: provides synchronization between multiple callers of qmp_send()\n * @qdss_clk: QDSS clock hw struct\n * @cooling_devs: thermal cooling devices\n */\nstruct qmp {\n\tvoid __iomem *msgram;\n\tstruct device *dev;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tsize_t offset;\n\tsize_t size;\n\n\twait_queue_head_t event;\n\n\tstruct mutex tx_lock;\n\n\tstruct clk_hw qdss_clk;\n\tstruct qmp_cooling_device *cooling_devs;\n};\n\nstatic void qmp_kick(struct qmp *qmp)\n{\n\tmbox_send_message(qmp->mbox_chan, NULL);\n\tmbox_client_txdone(qmp->mbox_chan, 0);\n}\n\nstatic bool qmp_magic_valid(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MAGIC) == QMP_MAGIC;\n}\n\nstatic bool qmp_link_acked(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MCORE_LINK_STATE_ACK) == QMP_STATE_UP;\n}\n\nstatic bool qmp_mcore_channel_acked(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_MCORE_CH_STATE_ACK) == QMP_STATE_UP;\n}\n\nstatic bool qmp_ucore_channel_up(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + QMP_DESC_UCORE_CH_STATE) == QMP_STATE_UP;\n}\n\nstatic int qmp_open(struct qmp *qmp)\n{\n\tint ret;\n\tu32 val;\n\n\tif (!qmp_magic_valid(qmp)) {\n\t\tdev_err(qmp->dev, \"QMP magic doesn't match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(qmp->msgram + QMP_DESC_VERSION);\n\tif (val != QMP_VERSION) {\n\t\tdev_err(qmp->dev, \"unsupported QMP version %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tqmp->offset = readl(qmp->msgram + QMP_DESC_MCORE_MBOX_OFFSET);\n\tqmp->size = readl(qmp->msgram + QMP_DESC_MCORE_MBOX_SIZE);\n\tif (!qmp->size) {\n\t\tdev_err(qmp->dev, \"invalid mailbox size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ack remote core's link state */\n\tval = readl(qmp->msgram + QMP_DESC_UCORE_LINK_STATE);\n\twritel(val, qmp->msgram + QMP_DESC_UCORE_LINK_STATE_ACK);\n\n\t/* Set local core's link state to up */\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_link_acked(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't ack link\\n\");\n\t\tgoto timeout_close_link;\n\t}\n\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_ucore_channel_up(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't open channel\\n\");\n\t\tgoto timeout_close_channel;\n\t}\n\n\t/* Ack remote core's channel state */\n\twritel(QMP_STATE_UP, qmp->msgram + QMP_DESC_UCORE_CH_STATE_ACK);\n\n\tqmp_kick(qmp);\n\n\tret = wait_event_timeout(qmp->event, qmp_mcore_channel_acked(qmp), HZ);\n\tif (!ret) {\n\t\tdev_err(qmp->dev, \"ucore didn't ack channel\\n\");\n\t\tgoto timeout_close_channel;\n\t}\n\n\treturn 0;\n\ntimeout_close_channel:\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\ntimeout_close_link:\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\tqmp_kick(qmp);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void qmp_close(struct qmp *qmp)\n{\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_CH_STATE);\n\twritel(QMP_STATE_DOWN, qmp->msgram + QMP_DESC_MCORE_LINK_STATE);\n\tqmp_kick(qmp);\n}\n\nstatic irqreturn_t qmp_intr(int irq, void *data)\n{\n\tstruct qmp *qmp = data;\n\n\twake_up_all(&qmp->event);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool qmp_message_empty(struct qmp *qmp)\n{\n\treturn readl(qmp->msgram + qmp->offset) == 0;\n}\n\n/**\n * qmp_send() - send a message to the AOSS\n * @qmp: qmp context\n * @data: message to be sent\n * @len: length of the message\n *\n * Transmit @data to AOSS and wait for the AOSS to acknowledge the message.\n * @len must be a multiple of 4 and not longer than the mailbox size. Access is\n * synchronized by this implementation.\n *\n * Return: 0 on success, negative errno on failure\n */\nint qmp_send(struct qmp *qmp, const void *data, size_t len)\n{\n\tlong time_left;\n\tint ret;\n\n\tif (WARN_ON(IS_ERR_OR_NULL(qmp) || !data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(len + sizeof(u32) > qmp->size))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(len % sizeof(u32)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&qmp->tx_lock);\n\n\t/* The message RAM only implements 32-bit accesses */\n\t__iowrite32_copy(qmp->msgram + qmp->offset + sizeof(u32),\n\t\t\t data, len / sizeof(u32));\n\twritel(len, qmp->msgram + qmp->offset);\n\n\t/* Read back len to confirm data written in message RAM */\n\treadl(qmp->msgram + qmp->offset);\n\tqmp_kick(qmp);\n\n\ttime_left = wait_event_interruptible_timeout(qmp->event,\n\t\t\t\t\t\t     qmp_message_empty(qmp), HZ);\n\tif (!time_left) {\n\t\tdev_err(qmp->dev, \"ucore did not ack channel\\n\");\n\t\tret = -ETIMEDOUT;\n\n\t\t/* Clear message from buffer */\n\t\twritel(0, qmp->msgram + qmp->offset);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tmutex_unlock(&qmp->tx_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qmp_send);\n\nstatic int qmp_qdss_clk_prepare(struct clk_hw *hw)\n{\n\tstatic const char buf[QMP_MSG_LEN] = \"{class: clock, res: qdss, val: 1}\";\n\tstruct qmp *qmp = container_of(hw, struct qmp, qdss_clk);\n\n\treturn qmp_send(qmp, buf, sizeof(buf));\n}\n\nstatic void qmp_qdss_clk_unprepare(struct clk_hw *hw)\n{\n\tstatic const char buf[QMP_MSG_LEN] = \"{class: clock, res: qdss, val: 0}\";\n\tstruct qmp *qmp = container_of(hw, struct qmp, qdss_clk);\n\n\tqmp_send(qmp, buf, sizeof(buf));\n}\n\nstatic const struct clk_ops qmp_qdss_clk_ops = {\n\t.prepare = qmp_qdss_clk_prepare,\n\t.unprepare = qmp_qdss_clk_unprepare,\n};\n\nstatic int qmp_qdss_clk_add(struct qmp *qmp)\n{\n\tstatic const struct clk_init_data qdss_init = {\n\t\t.ops = &qmp_qdss_clk_ops,\n\t\t.name = \"qdss\",\n\t};\n\tint ret;\n\n\tqmp->qdss_clk.init = &qdss_init;\n\tret = clk_hw_register(qmp->dev, &qmp->qdss_clk);\n\tif (ret < 0) {\n\t\tdev_err(qmp->dev, \"failed to register qdss clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_clk_add_hw_provider(qmp->dev->of_node, of_clk_hw_simple_get,\n\t\t\t\t     &qmp->qdss_clk);\n\tif (ret < 0) {\n\t\tdev_err(qmp->dev, \"unable to register of clk hw provider\\n\");\n\t\tclk_hw_unregister(&qmp->qdss_clk);\n\t}\n\n\treturn ret;\n}\n\nstatic void qmp_qdss_clk_remove(struct qmp *qmp)\n{\n\tof_clk_del_provider(qmp->dev->of_node);\n\tclk_hw_unregister(&qmp->qdss_clk);\n}\n\nstatic int qmp_cdev_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\t*state = qmp_cdev_max_state;\n\treturn 0;\n}\n\nstatic int qmp_cdev_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long *state)\n{\n\tstruct qmp_cooling_device *qmp_cdev = cdev->devdata;\n\n\t*state = qmp_cdev->state;\n\treturn 0;\n}\n\nstatic int qmp_cdev_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t  unsigned long state)\n{\n\tstruct qmp_cooling_device *qmp_cdev = cdev->devdata;\n\tchar buf[QMP_MSG_LEN] = {};\n\tbool cdev_state;\n\tint ret;\n\n\t/* Normalize state */\n\tcdev_state = !!state;\n\n\tif (qmp_cdev->state == state)\n\t\treturn 0;\n\n\tsnprintf(buf, sizeof(buf),\n\t\t \"{class: volt_flr, event:zero_temp, res:%s, value:%s}\",\n\t\t\tqmp_cdev->name,\n\t\t\tcdev_state ? \"on\" : \"off\");\n\n\tret = qmp_send(qmp_cdev->qmp, buf, sizeof(buf));\n\n\tif (!ret)\n\t\tqmp_cdev->state = cdev_state;\n\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops qmp_cooling_device_ops = {\n\t.get_max_state = qmp_cdev_get_max_state,\n\t.get_cur_state = qmp_cdev_get_cur_state,\n\t.set_cur_state = qmp_cdev_set_cur_state,\n};\n\nstatic int qmp_cooling_device_add(struct qmp *qmp,\n\t\t\t\t  struct qmp_cooling_device *qmp_cdev,\n\t\t\t\t  struct device_node *node)\n{\n\tchar *cdev_name = (char *)node->name;\n\n\tqmp_cdev->qmp = qmp;\n\tqmp_cdev->state = !qmp_cdev_max_state;\n\tqmp_cdev->name = cdev_name;\n\tqmp_cdev->cdev = devm_thermal_of_cooling_device_register\n\t\t\t\t(qmp->dev, node,\n\t\t\t\tcdev_name,\n\t\t\t\tqmp_cdev, &qmp_cooling_device_ops);\n\n\tif (IS_ERR(qmp_cdev->cdev))\n\t\tdev_err(qmp->dev, \"unable to register %s cooling device\\n\",\n\t\t\tcdev_name);\n\n\treturn PTR_ERR_OR_ZERO(qmp_cdev->cdev);\n}\n\nstatic int qmp_cooling_devices_register(struct qmp *qmp)\n{\n\tstruct device_node *np, *child;\n\tint count = 0;\n\tint ret;\n\n\tnp = qmp->dev->of_node;\n\n\tqmp->cooling_devs = devm_kcalloc(qmp->dev, QMP_NUM_COOLING_RESOURCES,\n\t\t\t\t\t sizeof(*qmp->cooling_devs),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (!qmp->cooling_devs)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (!of_find_property(child, \"#cooling-cells\", NULL))\n\t\t\tcontinue;\n\t\tret = qmp_cooling_device_add(qmp, &qmp->cooling_devs[count++],\n\t\t\t\t\t     child);\n\t\tif (ret)\n\t\t\tgoto unroll;\n\t}\n\n\tif (!count)\n\t\tdevm_kfree(qmp->dev, qmp->cooling_devs);\n\n\treturn 0;\n\nunroll:\n\twhile (--count >= 0)\n\t\tthermal_cooling_device_unregister\n\t\t\t(qmp->cooling_devs[count].cdev);\n\tdevm_kfree(qmp->dev, qmp->cooling_devs);\n\n\treturn ret;\n}\n\nstatic void qmp_cooling_devices_remove(struct qmp *qmp)\n{\n\tint i;\n\n\tfor (i = 0; i < QMP_NUM_COOLING_RESOURCES; i++)\n\t\tthermal_cooling_device_unregister(qmp->cooling_devs[i].cdev);\n}\n\n/**\n * qmp_get() - get a qmp handle from a device\n * @dev: client device pointer\n *\n * Return: handle to qmp device on success, ERR_PTR() on failure\n */\nstruct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\tif (!qmp) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\treturn qmp;\n}\nEXPORT_SYMBOL(qmp_get);\n\n/**\n * qmp_put() - release a qmp handle\n * @qmp: qmp handle obtained from qmp_get()\n */\nvoid qmp_put(struct qmp *qmp)\n{\n\t/*\n\t * Match get_device() inside of_find_device_by_node() in\n\t * qmp_get()\n\t */\n\tif (!IS_ERR_OR_NULL(qmp))\n\t\tput_device(qmp->dev);\n}\nEXPORT_SYMBOL(qmp_put);\n\nstatic int qmp_probe(struct platform_device *pdev)\n{\n\tstruct qmp *qmp;\n\tint irq;\n\tint ret;\n\n\tqmp = devm_kzalloc(&pdev->dev, sizeof(*qmp), GFP_KERNEL);\n\tif (!qmp)\n\t\treturn -ENOMEM;\n\n\tqmp->dev = &pdev->dev;\n\tinit_waitqueue_head(&qmp->event);\n\tmutex_init(&qmp->tx_lock);\n\n\tqmp->msgram = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qmp->msgram))\n\t\treturn PTR_ERR(qmp->msgram);\n\n\tqmp->mbox_client.dev = &pdev->dev;\n\tqmp->mbox_client.knows_txdone = true;\n\tqmp->mbox_chan = mbox_request_channel(&qmp->mbox_client, 0);\n\tif (IS_ERR(qmp->mbox_chan)) {\n\t\tdev_err(&pdev->dev, \"failed to acquire ipc mailbox\\n\");\n\t\treturn PTR_ERR(qmp->mbox_chan);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, qmp_intr, IRQF_ONESHOT,\n\t\t\t       \"aoss-qmp\", qmp);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request interrupt\\n\");\n\t\tgoto err_free_mbox;\n\t}\n\n\tret = qmp_open(qmp);\n\tif (ret < 0)\n\t\tgoto err_free_mbox;\n\n\tret = qmp_qdss_clk_add(qmp);\n\tif (ret)\n\t\tgoto err_close_qmp;\n\n\tret = qmp_cooling_devices_register(qmp);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to register aoss cooling devices\\n\");\n\n\tplatform_set_drvdata(pdev, qmp);\n\n\treturn 0;\n\nerr_close_qmp:\n\tqmp_close(qmp);\nerr_free_mbox:\n\tmbox_free_channel(qmp->mbox_chan);\n\n\treturn ret;\n}\n\nstatic int qmp_remove(struct platform_device *pdev)\n{\n\tstruct qmp *qmp = platform_get_drvdata(pdev);\n\n\tqmp_qdss_clk_remove(qmp);\n\tqmp_cooling_devices_remove(qmp);\n\n\tqmp_close(qmp);\n\tmbox_free_channel(qmp->mbox_chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qmp_dt_match[] = {\n\t{ .compatible = \"qcom,sc7180-aoss-qmp\", },\n\t{ .compatible = \"qcom,sc7280-aoss-qmp\", },\n\t{ .compatible = \"qcom,sdm845-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8150-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8250-aoss-qmp\", },\n\t{ .compatible = \"qcom,sm8350-aoss-qmp\", },\n\t{ .compatible = \"qcom,aoss-qmp\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qmp_dt_match);\n\nstatic struct platform_driver qmp_driver = {\n\t.driver = {\n\t\t.name\t\t= \"qcom_aoss_qmp\",\n\t\t.of_match_table\t= qmp_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = qmp_probe,\n\t.remove\t= qmp_remove,\n};\nmodule_platform_driver(qmp_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm AOSS QMP driver\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/soc/qcom/qcom_aoss.c"], "buggy_code_start_loc": [454], "buggy_code_end_loc": [455], "fixing_code_start_loc": [454], "fixing_code_end_loc": [459], "type": "CWE-772", "message": "In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not release an of_find_device_by_node reference after use, e.g., with put_device.", "other": {"cve": {"id": "CVE-2023-22996", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-28T21:15:12.057", "lastModified": "2023-03-06T16:27:35.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not release an of_find_device_by_node reference after use, e.g., with put_device."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17.2", "matchCriteriaId": "23C454F5-61F7-44DC-BCFA-17E6C23CF2EB"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/4b41a9d0fe3db5f91078a380f62f0572c3ecf2dd", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4b41a9d0fe3db5f91078a380f62f0572c3ecf2dd"}}