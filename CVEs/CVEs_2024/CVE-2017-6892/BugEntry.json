{"buggy_code": ["/*\n** Copyright (C) 1999-2017 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2005 David Viens <davidv@plogue.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include \"sfconfig.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"sndfile.h\"\n#include \"sfendian.h\"\n#include \"common.h\"\n#include \"chanmap.h\"\n\n/*------------------------------------------------------------------------------\n * Macros to handle big/little endian issues.\n */\n\n#define FORM_MARKER\t\t(MAKE_MARKER ('F', 'O', 'R', 'M'))\n#define AIFF_MARKER\t\t(MAKE_MARKER ('A', 'I', 'F', 'F'))\n#define AIFC_MARKER\t\t(MAKE_MARKER ('A', 'I', 'F', 'C'))\n#define COMM_MARKER\t\t(MAKE_MARKER ('C', 'O', 'M', 'M'))\n#define SSND_MARKER\t\t(MAKE_MARKER ('S', 'S', 'N', 'D'))\n#define MARK_MARKER\t\t(MAKE_MARKER ('M', 'A', 'R', 'K'))\n#define INST_MARKER\t\t(MAKE_MARKER ('I', 'N', 'S', 'T'))\n#define APPL_MARKER\t\t(MAKE_MARKER ('A', 'P', 'P', 'L'))\n#define CHAN_MARKER\t\t(MAKE_MARKER ('C', 'H', 'A', 'N'))\n\n#define c_MARKER\t\t(MAKE_MARKER ('(', 'c', ')', ' '))\n#define NAME_MARKER\t\t(MAKE_MARKER ('N', 'A', 'M', 'E'))\n#define AUTH_MARKER\t\t(MAKE_MARKER ('A', 'U', 'T', 'H'))\n#define ANNO_MARKER\t\t(MAKE_MARKER ('A', 'N', 'N', 'O'))\n#define COMT_MARKER\t\t(MAKE_MARKER ('C', 'O', 'M', 'T'))\n#define FVER_MARKER\t\t(MAKE_MARKER ('F', 'V', 'E', 'R'))\n#define SFX_MARKER\t\t(MAKE_MARKER ('S', 'F', 'X', '!'))\n\n#define PEAK_MARKER\t\t(MAKE_MARKER ('P', 'E', 'A', 'K'))\n#define basc_MARKER\t\t(MAKE_MARKER ('b', 'a', 's', 'c'))\n\n/* Supported AIFC encodings.*/\n#define NONE_MARKER\t\t(MAKE_MARKER ('N', 'O', 'N', 'E'))\n#define sowt_MARKER\t\t(MAKE_MARKER ('s', 'o', 'w', 't'))\n#define twos_MARKER\t\t(MAKE_MARKER ('t', 'w', 'o', 's'))\n#define raw_MARKER\t\t(MAKE_MARKER ('r', 'a', 'w', ' '))\n#define in24_MARKER\t\t(MAKE_MARKER ('i', 'n', '2', '4'))\n#define ni24_MARKER\t\t(MAKE_MARKER ('4', '2', 'n', '1'))\n#define in32_MARKER\t\t(MAKE_MARKER ('i', 'n', '3', '2'))\n#define ni32_MARKER\t\t(MAKE_MARKER ('2', '3', 'n', 'i'))\n\n#define fl32_MARKER\t\t(MAKE_MARKER ('f', 'l', '3', '2'))\n#define FL32_MARKER\t\t(MAKE_MARKER ('F', 'L', '3', '2'))\n#define fl64_MARKER\t\t(MAKE_MARKER ('f', 'l', '6', '4'))\n#define FL64_MARKER\t\t(MAKE_MARKER ('F', 'L', '6', '4'))\n\n#define ulaw_MARKER\t\t(MAKE_MARKER ('u', 'l', 'a', 'w'))\n#define ULAW_MARKER\t\t(MAKE_MARKER ('U', 'L', 'A', 'W'))\n#define alaw_MARKER\t\t(MAKE_MARKER ('a', 'l', 'a', 'w'))\n#define ALAW_MARKER\t\t(MAKE_MARKER ('A', 'L', 'A', 'W'))\n\n#define DWVW_MARKER\t\t(MAKE_MARKER ('D', 'W', 'V', 'W'))\n#define GSM_MARKER\t\t(MAKE_MARKER ('G', 'S', 'M', ' '))\n#define ima4_MARKER\t\t(MAKE_MARKER ('i', 'm', 'a', '4'))\n\n/*\n**\tThis value is officially assigned to Mega Nerd Pty Ltd by Apple\n**\tCorportation as the Application marker for libsndfile.\n**\n**\tSee : http://developer.apple.com/faq/datatype.html\n*/\n#define m3ga_MARKER\t\t(MAKE_MARKER ('m', '3', 'g', 'a'))\n\n/* Unsupported AIFC encodings.*/\n\n#define MAC3_MARKER\t\t(MAKE_MARKER ('M', 'A', 'C', '3'))\n#define MAC6_MARKER\t\t(MAKE_MARKER ('M', 'A', 'C', '6'))\n#define ADP4_MARKER\t\t(MAKE_MARKER ('A', 'D', 'P', '4'))\n\n/* Predfined chunk sizes. */\n#define SIZEOF_AIFF_COMM\t\t18\n#define SIZEOF_AIFC_COMM_MIN\t22\n#define SIZEOF_AIFC_COMM\t\t24\n#define SIZEOF_SSND_CHUNK\t\t8\n#define SIZEOF_INST_CHUNK\t\t20\n\n/* Is it constant? */\n\n/* AIFC/IMA4 defines. */\n#define AIFC_IMA4_BLOCK_LEN\t\t\t\t34\n#define AIFC_IMA4_SAMPLES_PER_BLOCK\t\t64\n\n#define AIFF_PEAK_CHUNK_SIZE(ch)\t(2 * sizeof (int) + ch * (sizeof (float) + sizeof (int)))\n\n/*------------------------------------------------------------------------------\n * Typedefs for file chunks.\n */\n\nenum\n{\tHAVE_FORM\t\t= 0x01,\n\tHAVE_AIFF\t\t= 0x02,\n\tHAVE_AIFC\t\t= 0x04,\n\tHAVE_FVER\t\t= 0x08,\n\tHAVE_COMM\t\t= 0x10,\n\tHAVE_SSND\t\t= 0x20\n} ;\n\ntypedef struct\n{\tuint32_t\tsize ;\n\tint16_t\t\tnumChannels ;\n\tuint32_t\tnumSampleFrames ;\n\tint16_t\t\tsampleSize ;\n\tuint8_t\t\tsampleRate [10] ;\n\tuint32_t\tencoding ;\n\tchar\t\t\tzero_bytes [2] ;\n} COMM_CHUNK ;\n\ntypedef struct\n{\tuint32_t\toffset ;\n\tuint32_t\tblocksize ;\n} SSND_CHUNK ;\n\ntypedef struct\n{\tint16_t\t\tplayMode ;\n\tuint16_t\tbeginLoop ;\n\tuint16_t\tendLoop ;\n} INST_LOOP ;\n\ntypedef struct\n{\tint8_t\t\tbaseNote ;\t\t/* all notes are MIDI note numbers */\n\tint8_t\t\tdetune ;\t\t/* cents off, only -50 to +50 are significant */\n\tint8_t\t\tlowNote ;\n\tint8_t\t\thighNote ;\n\tint8_t\t\tlowVelocity ;\t/* 1 to 127 */\n\tint8_t\t\thighVelocity ;\t/* 1 to 127 */\n\tint16_t\t\tgain ;\t\t\t/* in dB, 0 is normal */\n\tINST_LOOP\tsustain_loop ;\n\tINST_LOOP\trelease_loop ;\n} INST_CHUNK ;\n\n\nenum\n{\tbasc_SCALE_MINOR = 1,\n\tbasc_SCALE_MAJOR,\n\tbasc_SCALE_NEITHER,\n\tbasc_SCALE_BOTH\n} ;\n\nenum\n{\tbasc_TYPE_LOOP = 0,\n\tbasc_TYPE_ONE_SHOT\n} ;\n\n\ntypedef struct\n{\tuint32_t\tversion ;\n\tuint32_t\tnumBeats ;\n\tuint16_t\trootNote ;\n\tuint16_t\tscaleType ;\n\tuint16_t\tsigNumerator ;\n\tuint16_t\tsigDenominator ;\n\tuint16_t\tloopType ;\n} basc_CHUNK ;\n\ntypedef struct\n{\tuint16_t\tmarkerID ;\n\tuint32_t\tposition ;\n} MARK_ID_POS ;\n\ntypedef struct\n{\tsf_count_t\tcomm_offset ;\n\tsf_count_t\tssnd_offset ;\n\n\tint32_t\t\tchanmap_tag ;\n\n\tMARK_ID_POS *markstr ;\n} AIFF_PRIVATE ;\n\n/*------------------------------------------------------------------------------\n * Private static functions.\n */\n\nstatic int\taiff_close (SF_PRIVATE *psf) ;\n\nstatic int\ttenbytefloat2int (uint8_t *bytes) ;\nstatic void uint2tenbytefloat (uint32_t num, uint8_t *bytes) ;\n\nstatic int\taiff_read_comm_chunk (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt) ;\n\nstatic int\taiff_read_header (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt) ;\n\nstatic int\taiff_write_header (SF_PRIVATE *psf, int calc_length) ;\nstatic int\taiff_write_tailer (SF_PRIVATE *psf) ;\nstatic void\taiff_write_strings (SF_PRIVATE *psf, int location) ;\n\nstatic int\taiff_command (SF_PRIVATE *psf, int command, void *data, int datasize) ;\n\nstatic const char *get_loop_mode_str (int16_t mode) ;\n\nstatic int16_t get_loop_mode (int16_t mode) ;\n\nstatic int aiff_read_basc_chunk (SF_PRIVATE * psf, int) ;\n\nstatic int aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword) ;\n\nstatic uint32_t marker_to_position (const MARK_ID_POS *m, uint16_t n, int marksize) ;\n\nstatic int aiff_set_chunk (SF_PRIVATE *psf, const SF_CHUNK_INFO * chunk_info) ;\nstatic SF_CHUNK_ITERATOR * aiff_next_chunk_iterator (SF_PRIVATE *psf, SF_CHUNK_ITERATOR * iterator) ;\nstatic int aiff_get_chunk_size (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\nstatic int aiff_get_chunk_data (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\n\n/*------------------------------------------------------------------------------\n** Public function.\n*/\n\nint\naiff_open (SF_PRIVATE *psf)\n{\tCOMM_CHUNK comm_fmt ;\n\tint error, subformat ;\n\n\tmemset (&comm_fmt, 0, sizeof (comm_fmt)) ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif ((psf->container_data = calloc (1, sizeof (AIFF_PRIVATE))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->filelength > 0))\n\t{\tif ((error = aiff_read_header (psf, &comm_fmt)))\n\t\t\treturn error ;\n\n\t\tpsf->next_chunk_iterator = aiff_next_chunk_iterator ;\n\t\tpsf->get_chunk_size = aiff_get_chunk_size ;\n\t\tpsf->get_chunk_data = aiff_get_chunk_data ;\n\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\tif (psf->is_pipe)\n\t\t\treturn SFE_NO_PIPE_WRITE ;\n\n\t\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_AIFF)\n\t\t\treturn SFE_BAD_OPEN_FORMAT ;\n\n\t\tif (psf->file.mode == SFM_WRITE && (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE))\n\t\t{\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\treturn SFE_MALLOC_FAILED ;\n\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t} ;\n\n\t\tif (psf->file.mode != SFM_RDWR || psf->filelength < 40)\n\t\t{\tpsf->filelength = 0 ;\n\t\t\tpsf->datalength = 0 ;\n\t\t\tpsf->dataoffset = 0 ;\n\t\t\tpsf->sf.frames = 0 ;\n\t\t\t} ;\n\n\t\tpsf->strings.flags = SF_STR_ALLOW_START | SF_STR_ALLOW_END ;\n\n\t\tif ((error = aiff_write_header (psf, SF_FALSE)))\n\t\t\treturn error ;\n\n\t\tpsf->write_header\t= aiff_write_header ;\n\t\tpsf->set_chunk\t\t= aiff_set_chunk ;\n\t\t} ;\n\n\tpsf->container_close = aiff_close ;\n\tpsf->command = aiff_command ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_S8 :\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\terror = ulaw_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\terror = alaw_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\terror = float32_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\terror = double64_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_12 :\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_16 :\n\t\t\t\terror = dwvw_init (psf, 16) ;\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_24 :\n\t\t\t\terror = dwvw_init (psf, 24) ;\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_N :\n\t\t\t\tif (psf->file.mode != SFM_READ)\n\t\t\t\t{\terror = SFE_DWVW_BAD_BITWIDTH ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t} ;\n\t\t\t\tif (comm_fmt.sampleSize >= 8 && comm_fmt.sampleSize < 24)\n\t\t\t\t{\terror = dwvw_init (psf, comm_fmt.sampleSize) ;\n\t\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t} ;\n\t\t\t\tpsf_log_printf (psf, \"AIFC/DWVW : Bad bitwidth %d\\n\", comm_fmt.sampleSize) ;\n\t\t\t\terror = SFE_DWVW_BAD_BITWIDTH ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\t/*\n\t\t\t\t**\tIMA ADPCM encoded AIFF files always have a block length\n\t\t\t\t**\tof 34 which decodes to 64 samples.\n\t\t\t\t*/\n\t\t\t\terror = aiff_ima_init (psf, AIFC_IMA4_BLOCK_LEN, AIFC_IMA4_SAMPLES_PER_BLOCK) ;\n\t\t\t\tbreak ;\n\t\t/* Lite remove end */\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\terror = gsm610_init (psf) ;\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tdefault : return SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (psf->file.mode != SFM_WRITE && psf->sf.frames - comm_fmt.numSampleFrames != 0)\n\t{\tpsf_log_printf (psf,\n\t\t\t\"*** Frame count read from 'COMM' chunk (%u) not equal to frame count\\n\"\n\t\t\t\"*** calculated from length of 'SSND' chunk (%u).\\n\",\n\t\t\tcomm_fmt.numSampleFrames, (uint32_t) psf->sf.frames) ;\n\t\t} ;\n\n\treturn error ;\n} /* aiff_open */\n\n/*==========================================================================================\n** Private functions.\n*/\n\n/* This function ought to check size */\nstatic uint32_t\nmarker_to_position (const MARK_ID_POS *m, uint16_t n, int marksize)\n{\tint i ;\n\n\tfor (i = 0 ; i < marksize ; i++)\n\t\tif (m [i].markerID == n)\n\t\t\treturn m [i].position ;\n\treturn 0 ;\n} /* marker_to_position */\n\nstatic int\naiff_read_header (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt)\n{\tSSND_CHUNK\tssnd_fmt ;\n\tAIFF_PRIVATE *paiff ;\n\tBUF_UNION\tubuf ;\n\tuint32_t\tchunk_size = 0, FORMsize, SSNDsize, bytesread, mark_count = 0 ;\n\tint\t\t\tk, found_chunk = 0, done = 0, error = 0 ;\n\tchar\t\t*cptr ;\n\tint\t\t\tinstr_found = 0, mark_found = 0 ;\n\n\tif (psf->filelength > SF_PLATFORM_S64 (0xffffffff))\n\t\tpsf_log_printf (psf, \"Warning : filelength > 0xffffffff. This is bad!!!!\\n\") ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tpaiff->comm_offset = 0 ;\n\tpaiff->ssnd_offset = 0 ;\n\n\t/* Set position to start of file to begin reading header. */\n\tpsf_binheader_readf (psf, \"p\", 0) ;\n\n\tmemset (comm_fmt, 0, sizeof (COMM_CHUNK)) ;\n\n\t/* Until recently AIF* file were all BIG endian. */\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\t/*\tAIFF files can apparently have their chunks in any order. However, they\n\t**\tmust have a FORM chunk. Approach here is to read all the chunks one by\n\t**\tone and then check for the mandatory chunks at the end.\n\t*/\n\twhile (! done)\n\t{\tunsigned\tmarker ;\n\t\tsize_t jump = chunk_size & 1 ;\n\n\t\tmarker = chunk_size = 0 ;\n\t\tpsf_binheader_readf (psf, \"Ejm4\", jump, &marker, &chunk_size) ;\n\t\tif (marker == 0)\n\t\t{\tsf_count_t pos = psf_ftell (psf) ;\n\t\t\tpsf_log_printf (psf, \"Have 0 marker at position %D (0x%x).\\n\", pos, pos) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (psf->file.mode == SFM_RDWR && (found_chunk & HAVE_SSND))\n\t\t\treturn SFE_AIFF_RW_SSND_NOT_LAST ;\n\n\t\tpsf_store_read_chunk_u32 (&psf->rchunks, marker, psf_ftell (psf), chunk_size) ;\n\n\t\tswitch (marker)\n\t\t{\tcase FORM_MARKER :\n\t\t\t\t\tif (found_chunk)\n\t\t\t\t\t\treturn SFE_AIFF_NO_FORM ;\n\n\t\t\t\t\tFORMsize = chunk_size ;\n\n\t\t\t\t\tfound_chunk |= HAVE_FORM ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"m\", &marker) ;\n\t\t\t\t\tswitch (marker)\n\t\t\t\t\t{\tcase AIFC_MARKER :\n\t\t\t\t\t\tcase AIFF_MARKER :\n\t\t\t\t\t\t\tfound_chunk |= (marker == AIFC_MARKER) ? (HAVE_AIFC | HAVE_AIFF) : HAVE_AIFF ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf->fileoffset > 0 && psf->filelength > FORMsize + 8)\n\t\t\t\t\t{\t/* Set file length. */\n\t\t\t\t\t\tpsf->filelength = FORMsize + 8 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u\\n %M\\n\", FORMsize, marker) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (FORMsize != psf->filelength - 2 * SIGNED_SIZEOF (chunk_size))\n\t\t\t\t\t{\tchunk_size = psf->filelength - 2 * sizeof (chunk_size) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u (should be %u)\\n %M\\n\", FORMsize, chunk_size, marker) ;\n\t\t\t\t\t\tFORMsize = chunk_size ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u\\n %M\\n\", FORMsize, marker) ;\n\t\t\t\t\t/* Set this to 0, so we don't jump a byte when parsing the next marker. */\n\t\t\t\t\tchunk_size = 0 ;\n\t\t\t\t\tbreak ;\n\n\n\t\t\tcase COMM_MARKER :\n\t\t\t\t\tpaiff->comm_offset = psf_ftell (psf) - 8 ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tcomm_fmt->size = chunk_size ;\n\t\t\t\t\tif ((error = aiff_read_comm_chunk (psf, comm_fmt)) != 0)\n\t\t\t\t\t\treturn error ;\n\n\t\t\t\t\tfound_chunk |= HAVE_COMM ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase PEAK_MARKER :\n\t\t\t\t\t/* Must have COMM chunk before PEAK chunk. */\n\t\t\t\t\tif ((found_chunk & (HAVE_FORM | HAVE_AIFF | HAVE_COMM)) != (HAVE_FORM | HAVE_AIFF | HAVE_COMM))\n\t\t\t\t\t\treturn SFE_AIFF_PEAK_B4_COMM ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"%M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tif (chunk_size != AIFF_PEAK_CHUNK_SIZE (psf->sf.channels))\n\t\t\t\t\t{\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** File PEAK chunk too big.\\n\") ;\n\t\t\t\t\t\treturn SFE_WAV_BAD_PEAK ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t/* read in rest of PEAK chunk. */\n\t\t\t\t\tpsf_binheader_readf (psf, \"E44\", &(psf->peak_info->version), &(psf->peak_info->timestamp)) ;\n\n\t\t\t\t\tif (psf->peak_info->version != 1)\n\t\t\t\t\t\tpsf_log_printf (psf, \"  version    : %d *** (should be version 1)\\n\", psf->peak_info->version) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"  version    : %d\\n\", psf->peak_info->version) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"  time stamp : %d\\n\", psf->peak_info->timestamp) ;\n\t\t\t\t\tpsf_log_printf (psf, \"    Ch   Position       Value\\n\") ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\t\t\t{\tfloat value ;\n\t\t\t\t\t\tuint32_t position ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"Ef4\", &value, &position) ;\n\t\t\t\t\t\tpsf->peak_info->peaks [k].value = value ;\n\t\t\t\t\t\tpsf->peak_info->peaks [k].position = position ;\n\n\t\t\t\t\t\tsnprintf (cptr, sizeof (ubuf.scbuf), \"    %2d   %-12\" PRId64 \"   %g\\n\",\n\t\t\t\t\t\t\t\tk, psf->peak_info->peaks [k].position, psf->peak_info->peaks [k].value) ;\n\t\t\t\t\t\tcptr [sizeof (ubuf.scbuf) - 1] = 0 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"%s\", cptr) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf->peak_info->peak_loc = ((found_chunk & HAVE_SSND) == 0) ? SF_PEAK_START : SF_PEAK_END ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase SSND_MARKER :\n\t\t\t\t\tif ((found_chunk & HAVE_AIFC) && (found_chunk & HAVE_FVER) == 0)\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Valid AIFC files should have an FVER chunk.\\n\") ;\n\n\t\t\t\t\tpaiff->ssnd_offset = psf_ftell (psf) - 8 ;\n\t\t\t\t\tSSNDsize = chunk_size ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"E44\", &(ssnd_fmt.offset), &(ssnd_fmt.blocksize)) ;\n\n\t\t\t\t\tpsf->datalength = SSNDsize - sizeof (ssnd_fmt) ;\n\t\t\t\t\tpsf->dataoffset = psf_ftell (psf) ;\n\n\t\t\t\t\tif (psf->datalength > psf->filelength - psf->dataoffset || psf->datalength < 0)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" SSND : %u (should be %D)\\n\", SSNDsize, psf->filelength - psf->dataoffset + sizeof (SSND_CHUNK)) ;\n\t\t\t\t\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \" SSND : %u\\n\", SSNDsize) ;\n\n\t\t\t\t\tif (ssnd_fmt.offset == 0 || psf->dataoffset + ssnd_fmt.offset == ssnd_fmt.blocksize)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Offset     : %u\\n\", ssnd_fmt.offset) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Block Size : %u\\n\", ssnd_fmt.blocksize) ;\n\n\t\t\t\t\t\tpsf->dataoffset += ssnd_fmt.offset ;\n\t\t\t\t\t\tpsf->datalength -= ssnd_fmt.offset ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Offset     : %u\\n\", ssnd_fmt.offset) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Block Size : %u ???\\n\", ssnd_fmt.blocksize) ;\n\t\t\t\t\t\tpsf->dataoffset += ssnd_fmt.offset ;\n\t\t\t\t\t\tpsf->datalength -= ssnd_fmt.offset ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\t/* Only set dataend if there really is data at the end. */\n\t\t\t\t\tif (psf->datalength + psf->dataoffset < psf->filelength)\n\t\t\t\t\t\tpsf->dataend = psf->datalength + psf->dataoffset ;\n\n\t\t\t\t\tfound_chunk |= HAVE_SSND ;\n\n\t\t\t\t\tif (! psf->sf.seekable)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t/* Seek to end of SSND chunk. */\n\t\t\t\t\tpsf_fseek (psf, psf->dataoffset + psf->datalength, SEEK_SET) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase c_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf))\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\n\t\t\t\t\tpsf_sanitize_string (cptr, chunk_size) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_COPYRIGHT, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase AUTH_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 1)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_ARTIST, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase COMT_MARKER :\n\t\t\t\t{\tuint16_t count, id, len ;\n\t\t\t\t\tuint32_t timestamp, bytes ;\n\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tbytes = chunk_size ;\n\t\t\t\t\tbytes -= psf_binheader_readf (psf, \"E2\", &count) ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n  count  : %d\\n\", marker, chunk_size, count) ;\n\n\t\t\t\t\tfor (k = 0 ; k < count ; k++)\n\t\t\t\t\t{\tbytes -= psf_binheader_readf (psf, \"E422\", &timestamp, &id, &len) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"   time   : 0x%x\\n   marker : %x\\n   length : %d\\n\", timestamp, id, len) ;\n\n\t\t\t\t\t\tif (len + 1 > SIGNED_SIZEOF (ubuf.scbuf))\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"\\nError : string length (%d) too big.\\n\", len) ;\n\t\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\t\tbytes -= psf_binheader_readf (psf, \"b\", cptr, len) ;\n\t\t\t\t\t\tcptr [len] = 0 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"   string : %s\\n\", cptr) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (bytes > 0)\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", bytes) ;\n\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase APPL_MARKER :\n\t\t\t\t{\tunsigned appl_marker ;\n\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 1)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %u (too big, skipping)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (chunk_size < 4)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too small, skipping)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"mb\", &appl_marker, cptr, chunk_size + (chunk_size & 1) - 4) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\n\t\t\t\t\tfor (k = 0 ; k < (int) chunk_size ; k++)\n\t\t\t\t\t\tif (! psf_isprint (cptr [k]))\n\t\t\t\t\t\t{\tcptr [k] = 0 ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n  AppSig : %M\\n  Name   : %s\\n\", marker, chunk_size, appl_marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_SOFTWARE, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase NAME_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 2)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_TITLE, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase ANNO_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 2)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_COMMENT, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase INST_MARKER :\n\t\t\t\t\tif (chunk_size != SIZEOF_INST_CHUNK)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (should be %d)\\n\", marker, chunk_size, SIZEOF_INST_CHUNK) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\t{\tuint8_t bytes [6] ;\n\t\t\t\t\t\tint16_t gain ;\n\n\t\t\t\t\t\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"b\", bytes, 6) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Base Note : %u\\n  Detune    : %u\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Low  Note : %u\\n  High Note : %u\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Low  Vel. : %u\\n  High Vel. : %u\\n\",\n\t\t\t\t\t\t\t\t\t\t\tbytes [0], bytes [1], bytes [2], bytes [3], bytes [4], bytes [5]) ;\n\t\t\t\t\t\tpsf->instrument->basenote = bytes [0] ;\n\t\t\t\t\t\tpsf->instrument->detune = bytes [1] ;\n\t\t\t\t\t\tpsf->instrument->key_lo = bytes [2] ;\n\t\t\t\t\t\tpsf->instrument->key_hi = bytes [3] ;\n\t\t\t\t\t\tpsf->instrument->velocity_lo = bytes [4] ;\n\t\t\t\t\t\tpsf->instrument->velocity_hi = bytes [5] ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E2\", &gain) ;\n\t\t\t\t\t\tpsf->instrument->gain = gain ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Gain (dB) : %d\\n\", gain) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t{\tint16_t\tmode ; /* 0 - no loop, 1 - forward looping, 2 - backward looping */\n\t\t\t\t\t\tconst char\t*loop_mode ;\n\t\t\t\t\t\tuint16_t begin, end ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E222\", &mode, &begin, &end) ;\n\t\t\t\t\t\tloop_mode = get_loop_mode_str (mode) ;\n\t\t\t\t\t\tmode = get_loop_mode (mode) ;\n\t\t\t\t\t\tif (mode == SF_LOOP_NONE)\n\t\t\t\t\t\t{\tpsf->instrument->loop_count = 0 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].mode = SF_LOOP_NONE ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\tpsf->instrument->loop_count = 1 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].mode = SF_LOOP_FORWARD ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].start = begin ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].end = end ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].count = 0 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Sustain\\n   mode  : %d => %s\\n   begin : %u\\n   end   : %u\\n\",\n\t\t\t\t\t\t\t\t\t\t\tmode, loop_mode, begin, end) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E222\", &mode, &begin, &end) ;\n\t\t\t\t\t\tloop_mode = get_loop_mode_str (mode) ;\n\t\t\t\t\t\tmode = get_loop_mode (mode) ;\n\t\t\t\t\t\tif (mode == SF_LOOP_NONE)\n\t\t\t\t\t\t\tpsf->instrument->loops [1].mode = SF_LOOP_NONE ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\tpsf->instrument->loop_count += 1 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].mode = SF_LOOP_FORWARD ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].start = begin ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].end = end ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].count = 0 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Release\\n   mode  : %d => %s\\n   begin : %u\\n   end   : %u\\n\",\n\t\t\t\t\t\t\t\t\t\tmode, loop_mode, begin, end) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tinstr_found++ ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase basc_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" basc : %u\\n\", chunk_size) ;\n\n\t\t\t\t\tif ((error = aiff_read_basc_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase MARK_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\t{\tuint16_t mark_id, n = 0 ;\n\t\t\t\t\t\tuint32_t position ;\n\n\t\t\t\t\t\tbytesread = psf_binheader_readf (psf, \"E2\", &n) ;\n\t\t\t\t\t\tmark_count = n ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Count : %u\\n\", mark_count) ;\n\t\t\t\t\t\tif (paiff->markstr != NULL)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"*** Second MARK chunk found. Throwing away the first.\\n\") ;\n\t\t\t\t\t\t\tfree (paiff->markstr) ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpaiff->markstr = calloc (mark_count, sizeof (MARK_ID_POS)) ;\n\t\t\t\t\t\tif (paiff->markstr == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tif (mark_count > 1000)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"  More than 1000 markers, skipping!\\n\") ;\n\t\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tif ((psf->cues = psf_cues_alloc (mark_count)) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tfor (n = 0 ; n < mark_count && bytesread < chunk_size ; n++)\n\t\t\t\t\t\t{\tuint32_t pstr_len ;\n\t\t\t\t\t\t\tuint8_t ch ;\n\n\t\t\t\t\t\t\tbytesread += psf_binheader_readf (psf, \"E241\", &mark_id, &position, &ch) ;\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"   Mark ID  : %u\\n   Position : %u\\n\", mark_id, position) ;\n\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].indx = mark_id ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].position = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].fcc_chunk = MAKE_MARKER ('d', 'a', 't', 'a') ; /* always data */\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].chunk_start = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].block_start = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].sample_offset = position ;\n\n\t\t\t\t\t\t\tpstr_len = (ch & 1) ? ch : ch + 1 ;\n\n\t\t\t\t\t\t\tif (pstr_len < sizeof (ubuf.scbuf) - 1)\n\t\t\t\t\t\t\t{\tbytesread += psf_binheader_readf (psf, \"b\", ubuf.scbuf, pstr_len) ;\n\t\t\t\t\t\t\t\tubuf.scbuf [pstr_len] = 0 ;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\tuint32_t read_len = pstr_len - (sizeof (ubuf.scbuf) - 1) ;\n\t\t\t\t\t\t\t\tbytesread += psf_binheader_readf (psf, \"bj\", ubuf.scbuf, read_len, pstr_len - read_len) ;\n\t\t\t\t\t\t\t\tubuf.scbuf [sizeof (ubuf.scbuf) - 1] = 0 ;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"   Name     : %s\\n\", ubuf.scbuf) ;\n\n\t\t\t\t\t\t\tpsf_strlcpy (psf->cues->cue_points [n].name, sizeof (psf->cues->cue_points [n].name), ubuf.cbuf) ;\n\n\t\t\t\t\t\t\tpaiff->markstr [n].markerID = mark_id ;\n\t\t\t\t\t\t\tpaiff->markstr [n].position = position ;\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t**\tTODO if ubuf.scbuf is equal to\n\t\t\t\t\t\t\t**\teither Beg_loop, Beg loop or beg loop and spam\n\t\t\t\t\t\t\t**\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t\t\t\t\t**\t\treturn SFE_MALLOC_FAILED ;\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tmark_found++ ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase FVER_MARKER :\n\t\t\t\t\tfound_chunk |= HAVE_FVER ;\n\t\t\t\t\t/* Fall through to next case. */\n\n\t\t\tcase SFX_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase NONE_MARKER :\n\t\t\t\t\t/* Fix for broken AIFC files with incorrect COMM chunk length. */\n\t\t\t\t\tchunk_size = (chunk_size >> 24) - 3 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", make_size_t (chunk_size)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase CHAN_MARKER :\n\t\t\t\t\tif (chunk_size < 12)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (should be >= 12)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\n\t\t\t\t\tif ((error = aiff_read_chanmap (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\t\tif (chunk_size >= 0xffff0000)\n\t\t\t\t\t{\tdone = SF_TRUE ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\\n\", marker, psf_ftell (psf) - 8, chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_isprint ((marker >> 24) & 0xFF) && psf_isprint ((marker >> 16) & 0xFF)\n\t\t\t\t\t\t&& psf_isprint ((marker >> 8) & 0xFF) && psf_isprint (marker & 0xFF))\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %u (unknown marker)\\n\", marker, chunk_size) ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_ftell (psf) & 0x03)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Unknown chunk marker at position %D. Resynching.\\n\", psf_ftell (psf) - 8) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", -3) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker %X at position %D. Exiting parser.\\n\", marker, psf_ftell (psf)) ;\n\t\t\t\t\tdone = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\t\t\t} ;\t/* switch (marker) */\n\n\t\tif (chunk_size >= psf->filelength)\n\t\t{\tpsf_log_printf (psf, \"*** Chunk size %u > file length %D. Exiting parser.\\n\", chunk_size, psf->filelength) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif ((! psf->sf.seekable) && (found_chunk & HAVE_SSND))\n\t\t\tbreak ;\n\n\t\tif (psf_ftell (psf) >= psf->filelength - (2 * SIGNED_SIZEOF (int32_t)))\n\t\t\tbreak ;\n\t\t} ; /* while (1) */\n\n\tif (instr_found && mark_found)\n\t{\tint ji, str_index ;\n\t\t/* Next loop will convert markers to loop positions for internal handling */\n\t\tfor (ji = 0 ; ji < psf->instrument->loop_count ; ji ++)\n\t\t{\tif (ji < ARRAY_LEN (psf->instrument->loops))\n\t\t\t{\tpsf->instrument->loops [ji].start = marker_to_position (paiff->markstr, psf->instrument->loops [ji].start, mark_count) ;\n\t\t\t\tpsf->instrument->loops [ji].end = marker_to_position (paiff->markstr, psf->instrument->loops [ji].end, mark_count) ;\n\t\t\t\tpsf->instrument->loops [ji].mode = SF_LOOP_FORWARD ;\n\t\t\t\t} ;\n\t\t\t} ;\n\n\t\t/* The markers that correspond to loop positions can now be removed from cues struct */\n\t\tif (psf->cues->cue_count > (uint32_t) (psf->instrument->loop_count * 2))\n\t\t{\tuint32_t j ;\n\n\t\t\tfor (j = 0 ; j < psf->cues->cue_count - (uint32_t) (psf->instrument->loop_count * 2) ; j ++)\n\t\t\t{\t/* This simply copies the information in cues above loop positions and writes it at current count instead */\n\t\t\t\tpsf->cues->cue_points [j].indx = psf->cues->cue_points [j + psf->instrument->loop_count * 2].indx ;\n\t\t\t\tpsf->cues->cue_points [j].position = psf->cues->cue_points [j + psf->instrument->loop_count * 2].position ;\n\t\t\t\tpsf->cues->cue_points [j].fcc_chunk = psf->cues->cue_points [j + psf->instrument->loop_count * 2].fcc_chunk ;\n\t\t\t\tpsf->cues->cue_points [j].chunk_start = psf->cues->cue_points [j + psf->instrument->loop_count * 2].chunk_start ;\n\t\t\t\tpsf->cues->cue_points [j].block_start = psf->cues->cue_points [j + psf->instrument->loop_count * 2].block_start ;\n\t\t\t\tpsf->cues->cue_points [j].sample_offset = psf->cues->cue_points [j + psf->instrument->loop_count * 2].sample_offset ;\n\t\t\t\tfor (str_index = 0 ; str_index < 256 ; str_index++)\n\t\t\t\t\tpsf->cues->cue_points [j].name [str_index] = psf->cues->cue_points [j + psf->instrument->loop_count * 2].name [str_index] ;\n\t\t\t\t} ;\n\t\t\tpsf->cues->cue_count -= psf->instrument->loop_count * 2 ;\n\t\t\t} else\n\t\t\t{\t/* All the cues were in fact loop positions so we can actually remove the cues altogether */\n\t\t\t\tfree (psf->cues) ;\n\t\t\t\tpsf->cues = NULL ;\n\t\t\t\t}\n\t\t} ;\n\n\tif (psf->sf.channels < 1)\n\t\treturn SFE_CHANNEL_COUNT_ZERO ;\n\n\tif (psf->sf.channels >= SF_MAX_CHANNELS)\n\t\treturn SFE_CHANNEL_COUNT ;\n\n\tif (! (found_chunk & HAVE_FORM))\n\t\treturn SFE_AIFF_NO_FORM ;\n\n\tif (! (found_chunk & HAVE_AIFF))\n\t\treturn SFE_AIFF_COMM_NO_FORM ;\n\n\tif (! (found_chunk & HAVE_COMM))\n\t\treturn SFE_AIFF_SSND_NO_COMM ;\n\n\tif (! psf->dataoffset)\n\t\treturn SFE_AIFF_NO_DATA ;\n\n\treturn 0 ;\n} /* aiff_read_header */\n\nstatic int\naiff_close (SF_PRIVATE *psf)\n{\tAIFF_PRIVATE *paiff = psf->container_data ;\n\n\tif (paiff != NULL && paiff->markstr != NULL)\n\t{\tfree (paiff->markstr) ;\n\t\tpaiff->markstr = NULL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\taiff_write_tailer (psf) ;\n\t\taiff_write_header (psf, SF_TRUE) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* aiff_close */\n\nstatic int\naiff_read_comm_chunk (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt)\n{\tBUF_UNION\tubuf ;\n\tint subformat, samplerate ;\n\n\tubuf.scbuf [0] = 0 ;\n\n\t/* The COMM chunk has an int aligned to an odd word boundary. Some\n\t** procesors are not able to deal with this (ie bus fault) so we have\n\t** to take special care.\n\t*/\n\n\tpsf_binheader_readf (psf, \"E242b\", &(comm_fmt->numChannels), &(comm_fmt->numSampleFrames),\n\t\t\t\t&(comm_fmt->sampleSize), &(comm_fmt->sampleRate), SIGNED_SIZEOF (comm_fmt->sampleRate)) ;\n\n\tif (comm_fmt->size > 0x10000 && (comm_fmt->size & 0xffff) == 0)\n\t{\tpsf_log_printf (psf, \" COMM : %d (0x%x) *** should be \", comm_fmt->size, comm_fmt->size) ;\n\t\tcomm_fmt->size = ENDSWAP_32 (comm_fmt->size) ;\n\t\tpsf_log_printf (psf, \"%d (0x%x)\\n\", comm_fmt->size, comm_fmt->size) ;\n\t\t}\n\telse\n\t\tpsf_log_printf (psf, \" COMM : %d\\n\", comm_fmt->size) ;\n\n\tif (comm_fmt->size == SIZEOF_AIFF_COMM)\n\t\tcomm_fmt->encoding = NONE_MARKER ;\n\telse if (comm_fmt->size == SIZEOF_AIFC_COMM_MIN)\n\t\tpsf_binheader_readf (psf, \"Em\", &(comm_fmt->encoding)) ;\n\telse if (comm_fmt->size >= SIZEOF_AIFC_COMM)\n\t{\tuint8_t encoding_len ;\n\t\tunsigned read_len ;\n\n\t\tpsf_binheader_readf (psf, \"Em1\", &(comm_fmt->encoding), &encoding_len) ;\n\n\t\tcomm_fmt->size = SF_MIN (sizeof (ubuf.scbuf), make_size_t (comm_fmt->size)) ;\n\t\tmemset (ubuf.scbuf, 0, comm_fmt->size) ;\n\t\tread_len = comm_fmt->size - SIZEOF_AIFC_COMM + 1 ;\n\t\tpsf_binheader_readf (psf, \"b\", ubuf.scbuf, read_len) ;\n\t\tubuf.scbuf [read_len + 1] = 0 ;\n\t\t} ;\n\n\tsamplerate = tenbytefloat2int (comm_fmt->sampleRate) ;\n\n\tpsf_log_printf (psf, \"  Sample Rate : %d\\n\", samplerate) ;\n\tpsf_log_printf (psf, \"  Frames      : %u%s\\n\", comm_fmt->numSampleFrames, (comm_fmt->numSampleFrames == 0 && psf->filelength > 104) ? \" (Should not be 0)\" : \"\") ;\n\n\tif (comm_fmt->numChannels < 1 || comm_fmt->numChannels >= SF_MAX_CHANNELS)\n\t{\tpsf_log_printf (psf, \"  Channels    : %d (should be >= 1 and < %d)\\n\", comm_fmt->numChannels, SF_MAX_CHANNELS) ;\n\t\treturn SFE_CHANNEL_COUNT_BAD ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  Channels    : %d\\n\", comm_fmt->numChannels) ;\n\n\t/* Found some broken 'fl32' files with comm.samplesize == 16. Fix it here. */\n\tif ((comm_fmt->encoding == fl32_MARKER || comm_fmt->encoding == FL32_MARKER) && comm_fmt->sampleSize != 32)\n\t{\tpsf_log_printf (psf, \"  Sample Size : %d (should be 32)\\n\", comm_fmt->sampleSize) ;\n\t\tcomm_fmt->sampleSize = 32 ;\n\t\t}\n\telse if ((comm_fmt->encoding == fl64_MARKER || comm_fmt->encoding == FL64_MARKER) && comm_fmt->sampleSize != 64)\n\t{\tpsf_log_printf (psf, \"  Sample Size : %d (should be 64)\\n\", comm_fmt->sampleSize) ;\n\t\tcomm_fmt->sampleSize = 64 ;\n\t\t}\n\telse\n\t\tpsf_log_printf (psf, \"  Sample Size : %d\\n\", comm_fmt->sampleSize) ;\n\n\tsubformat = s_bitwidth_to_subformat (comm_fmt->sampleSize) ;\n\n\tpsf->sf.samplerate = samplerate ;\n\tpsf->sf.frames = comm_fmt->numSampleFrames ;\n\tpsf->sf.channels = comm_fmt->numChannels ;\n\tpsf->bytewidth = BITWIDTH2BYTES (comm_fmt->sampleSize) ;\n\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\tswitch (comm_fmt->encoding)\n\t{\tcase NONE_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | subformat) ;\n\t\t\t\tbreak ;\n\n\t\tcase twos_MARKER :\n\t\tcase in24_MARKER :\n\t\tcase in32_MARKER :\n\t\t\t\tpsf->sf.format = (SF_ENDIAN_BIG | SF_FORMAT_AIFF | subformat) ;\n\t\t\t\tbreak ;\n\n\t\tcase sowt_MARKER :\n\t\tcase ni24_MARKER :\n\t\tcase ni32_MARKER :\n\t\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\t\tpsf->sf.format = (SF_ENDIAN_LITTLE | SF_FORMAT_AIFF | subformat) ;\n\t\t\t\tbreak ;\n\n\t\tcase fl32_MARKER :\n\t\tcase FL32_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_FLOAT) ;\n\t\t\t\tbreak ;\n\n\t\tcase ulaw_MARKER :\n\t\tcase ULAW_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_ULAW) ;\n\t\t\t\tbreak ;\n\n\t\tcase alaw_MARKER :\n\t\tcase ALAW_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_ALAW) ;\n\t\t\t\tbreak ;\n\n\t\tcase fl64_MARKER :\n\t\tcase FL64_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_DOUBLE) ;\n\t\t\t\tbreak ;\n\n\t\tcase raw_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_PCM_U8) ;\n\t\t\t\tbreak ;\n\n\t\tcase DWVW_MARKER :\n\t\t\t\tpsf->sf.format = SF_FORMAT_AIFF ;\n\t\t\t\tswitch (comm_fmt->sampleSize)\n\t\t\t\t{\tcase 12 :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_12 ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tcase 16 :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_16 ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tcase 24 :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_24 ;\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_N ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t} ;\n\t\t\t\tbreak ;\n\n\t\tcase GSM_MARKER :\n\t\t\t\tpsf->sf.format = SF_FORMAT_AIFF ;\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_GSM610) ;\n\t\t\t\tbreak ;\n\n\n\t\tcase ima4_MARKER :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_IMA_ADPCM) ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"AIFC : Unimplemented format : %M\\n\", comm_fmt->encoding) ;\n\t\t\treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (! ubuf.scbuf [0])\n\t\tpsf_log_printf (psf, \"  Encoding    : %M\\n\", comm_fmt->encoding) ;\n\telse\n\t\tpsf_log_printf (psf, \"  Encoding    : %M => %s\\n\", comm_fmt->encoding, ubuf.scbuf) ;\n\n\treturn 0 ;\n} /* aiff_read_comm_chunk */\n\n\n/*==========================================================================================\n*/\n\nstatic void\naiff_rewrite_header (SF_PRIVATE *psf)\n{\n\t/* Assuming here that the header has already been written and just\n\t** needs to be corrected for new data length. That means that we\n\t** only change the length fields of the FORM and SSND chunks ;\n\t** everything else can be skipped over.\n\t*/\n\tint k, ch, comm_size, comm_frames ;\n\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\tpsf_fread (psf->header.ptr, psf->dataoffset, 1, psf) ;\n\n\tpsf->header.indx = 0 ;\n\n\t/* FORM chunk. */\n\tpsf_binheader_writef (psf, \"Etm8\", FORM_MARKER, psf->filelength - 8) ;\n\n\t/* COMM chunk. */\n\tif ((k = psf_find_read_chunk_m32 (&psf->rchunks, COMM_MARKER)) >= 0)\n\t{\tpsf->header.indx = psf->rchunks.chunks [k].offset - 8 ;\n\t\tcomm_frames = psf->sf.frames ;\n\t\tcomm_size = psf->rchunks.chunks [k].len ;\n\t\tpsf_binheader_writef (psf, \"Em42t4\", COMM_MARKER, comm_size, psf->sf.channels, comm_frames) ;\n\t\t} ;\n\n\t/* PEAK chunk. */\n\tif ((k = psf_find_read_chunk_m32 (&psf->rchunks, PEAK_MARKER)) >= 0)\n\t{\tpsf->header.indx = psf->rchunks.chunks [k].offset - 8 ;\n\t\tpsf_binheader_writef (psf, \"Em4\", PEAK_MARKER, AIFF_PEAK_CHUNK_SIZE (psf->sf.channels)) ;\n\t\tpsf_binheader_writef (psf, \"E44\", 1, time (NULL)) ;\n\t\tfor (ch = 0 ; ch < psf->sf.channels ; ch++)\n\t\t\tpsf_binheader_writef (psf, \"Eft8\", (float) psf->peak_info->peaks [ch].value, psf->peak_info->peaks [ch].position) ;\n\t\t} ;\n\n\n\t/* SSND chunk. */\n\tif ((k = psf_find_read_chunk_m32 (&psf->rchunks, SSND_MARKER)) >= 0)\n\t{\tpsf->header.indx = psf->rchunks.chunks [k].offset - 8 ;\n\t\tpsf_binheader_writef (psf, \"Etm8\", SSND_MARKER, psf->datalength + SIZEOF_SSND_CHUNK) ;\n\t\t} ;\n\n\t/* Header mangling complete so write it out. */\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\n\treturn ;\n} /* aiff_rewrite_header */\n\nstatic int\naiff_write_header (SF_PRIVATE *psf, int calc_length)\n{\tsf_count_t\t\tcurrent ;\n\tAIFF_PRIVATE\t*paiff ;\n\tuint8_t\tcomm_sample_rate [10], comm_zero_bytes [2] = { 0, 0 } ;\n\tuint32_t\tcomm_type, comm_size, comm_encoding, comm_frames = 0, uk ;\n\tint\t\t\t\tk, endian, has_data = SF_FALSE ;\n\tint16_t\t\t\tbit_width ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tcurrent = psf_ftell (psf) ;\n\n\tif (current > psf->dataoffset)\n\t\thas_data = SF_TRUE ;\n\n\tif (calc_length)\n\t{\tpsf->filelength = psf_get_filelen (psf) ;\n\n\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\tif (psf->dataend)\n\t\t\tpsf->datalength -= psf->filelength - psf->dataend ;\n\n\t\tif (psf->bytewidth > 0)\n\t\t\tpsf->sf.frames = psf->datalength / (psf->bytewidth * psf->sf.channels) ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_RDWR && psf->dataoffset > 0 && psf->rchunks.count > 0)\n\t{\taiff_rewrite_header (psf) ;\n\t\tif (current > 0)\n\t\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tendian = SF_ENDIAN (psf->sf.format) ;\n\tif (CPU_IS_LITTLE_ENDIAN && endian == SF_ENDIAN_CPU)\n\t\tendian = SF_ENDIAN_LITTLE ;\n\n\t/* Standard value here. */\n\tbit_width = psf->bytewidth * 8 ;\n\tcomm_frames = (psf->sf.frames > 0xFFFFFFFF) ? 0xFFFFFFFF : psf->sf.frames ;\n\n\tswitch (SF_CODEC (psf->sf.format) | endian)\n\t{\tcase SF_FORMAT_PCM_S8 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = twos_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_S8 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = sowt_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = twos_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = sowt_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_24 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = in24_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_24 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = ni24_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_32 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = in32_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_32 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = ni32_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_S8 :\t\t\t/* SF_ENDIAN_FILE */\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFF_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFF_COMM ;\n\t\t\tcomm_encoding = 0 ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_FLOAT :\t\t\t\t\t/* Big endian floating point. */\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = FL32_MARKER ;\t/* Use 'FL32' because its easier to read. */\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\t\t\t\t\t/* Big endian double precision floating point. */\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = FL64_MARKER ;\t/* Use 'FL64' because its easier to read. */\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = ulaw_MARKER ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = alaw_MARKER ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_U8 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = raw_MARKER ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_12 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = DWVW_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 12 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_16 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = DWVW_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 16 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_24 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = DWVW_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 24 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = GSM_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 16 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = ima4_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 16 ;\n\t\t\t\tcomm_frames = psf->sf.frames / AIFC_IMA4_SAMPLES_PER_BLOCK ;\n\t\t\t\tbreak ;\n\n\t\tdefault : return SFE_BAD_OPEN_FORMAT ;\n\t\t} ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\tpsf_binheader_writef (psf, \"Etm8\", FORM_MARKER, psf->filelength - 8) ;\n\n\t/* Write AIFF/AIFC marker and COM chunk. */\n\tif (comm_type == AIFC_MARKER)\n\t\t/* AIFC must have an FVER chunk. */\n\t\tpsf_binheader_writef (psf, \"Emm44\", comm_type, FVER_MARKER, 4, 0xA2805140) ;\n\telse\n\t\tpsf_binheader_writef (psf, \"Em\", comm_type) ;\n\n\tpaiff->comm_offset = psf->header.indx - 8 ;\n\n\tmemset (comm_sample_rate, 0, sizeof (comm_sample_rate)) ;\n\tuint2tenbytefloat (psf->sf.samplerate, comm_sample_rate) ;\n\n\tpsf_binheader_writef (psf, \"Em42t42\", COMM_MARKER, comm_size, psf->sf.channels, comm_frames, bit_width) ;\n\tpsf_binheader_writef (psf, \"b\", comm_sample_rate, sizeof (comm_sample_rate)) ;\n\n\t/* AIFC chunks have some extra data. */\n\tif (comm_type == AIFC_MARKER)\n\t\tpsf_binheader_writef (psf, \"mb\", comm_encoding, comm_zero_bytes, sizeof (comm_zero_bytes)) ;\n\n\tif (psf->channel_map && paiff->chanmap_tag)\n\t\tpsf_binheader_writef (psf, \"Em4444\", CHAN_MARKER, 12, paiff->chanmap_tag, 0, 0) ;\n\n\t/* Check if there's a INST chunk to write */\n\tif (psf->instrument != NULL && psf->cues != NULL)\n\t{\t/* Huge chunk of code removed here because it had egregious errors that were\n\t\t** not detected by either the compiler or the tests. It was found when updating\n\t\t** the way psf_binheader_writef works.\n\t\t*/\n\t\t}\n\telse if (psf->instrument == NULL && psf->cues != NULL)\n\t{\t/* There are cues but no loops */\n\t\tuint32_t idx ;\n\t\tint totalStringLength = 0, stringLength ;\n\n\t\t/* Here we count how many bytes will the pascal strings need */\n\t\tfor (idx = 0 ; idx < psf->cues->cue_count ; idx++)\n\t\t{\tstringLength = strlen (psf->cues->cue_points [idx].name) + 1 ; /* We'll count the first byte also of every pascal string */\n\t\t\ttotalStringLength += stringLength + (stringLength % 2 == 0 ? 0 : 1) ;\n\t\t\t} ;\n\n\t\tpsf_binheader_writef (psf, \"Em42\",\n\t\t\tMARK_MARKER, 2 + psf->cues->cue_count * (2 + 4) + totalStringLength, psf->cues->cue_count) ;\n\n\t\tfor (idx = 0 ; idx < psf->cues->cue_count ; idx++)\n\t\t\tpsf_binheader_writef (psf, \"E24p\", psf->cues->cue_points [idx].indx, psf->cues->cue_points [idx].sample_offset, psf->cues->cue_points [idx].name) ;\n\t\t} ;\n\n\tif (psf->strings.flags & SF_STR_LOCATE_START)\n\t\taiff_write_strings (psf, SF_STR_LOCATE_START) ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_START)\n\t{\tpsf_binheader_writef (psf, \"Em4\", PEAK_MARKER, AIFF_PEAK_CHUNK_SIZE (psf->sf.channels)) ;\n\t\tpsf_binheader_writef (psf, \"E44\", 1, time (NULL)) ;\n\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\tpsf_binheader_writef (psf, \"Eft8\", (float) psf->peak_info->peaks [k].value, psf->peak_info->peaks [k].position) ;\n\t\t} ;\n\n\t/* Write custom headers. */\n\tfor (uk = 0 ; uk < psf->wchunks.used ; uk++)\n\t\tpsf_binheader_writef (psf, \"Em4b\", psf->wchunks.chunks [uk].mark32, psf->wchunks.chunks [uk].len, psf->wchunks.chunks [uk].data, make_size_t (psf->wchunks.chunks [uk].len)) ;\n\n\t/* Write SSND chunk. */\n\tpaiff->ssnd_offset = psf->header.indx ;\n\tpsf_binheader_writef (psf, \"Etm844\", SSND_MARKER, psf->datalength + SIZEOF_SSND_CHUNK, 0, 0) ;\n\n\t/* Header construction complete so write it out. */\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\tif (has_data && psf->dataoffset != psf->header.indx)\n\t\treturn psf->error = SFE_INTERNAL ;\n\n\tpsf->dataoffset = psf->header.indx ;\n\n\tif (! has_data)\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\telse if (current > 0)\n\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\n\treturn psf->error ;\n} /* aiff_write_header */\n\nstatic int\naiff_write_tailer (SF_PRIVATE *psf)\n{\tint\t\tk ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\n\tpsf->dataend = psf_fseek (psf, 0, SEEK_END) ;\n\n\t/* Make sure tailer data starts at even byte offset. Pad if necessary. */\n\tif (psf->dataend % 2 == 1)\n\t{\tpsf_fwrite (psf->header.ptr, 1, 1, psf) ;\n\t\tpsf->dataend ++ ;\n\t\t} ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_END)\n\t{\tpsf_binheader_writef (psf, \"Em4\", PEAK_MARKER, AIFF_PEAK_CHUNK_SIZE (psf->sf.channels)) ;\n\t\tpsf_binheader_writef (psf, \"E44\", 1, time (NULL)) ;\n\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\tpsf_binheader_writef (psf, \"Eft8\", (float) psf->peak_info->peaks [k].value, psf->peak_info->peaks [k].position) ;\n\t\t} ;\n\n\tif (psf->strings.flags & SF_STR_LOCATE_END)\n\t\taiff_write_strings (psf, SF_STR_LOCATE_END) ;\n\n\t/* Write the tailer. */\n\tif (psf->header.indx > 0)\n\t\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\n\treturn 0 ;\n} /* aiff_write_tailer */\n\nstatic void\naiff_write_strings (SF_PRIVATE *psf, int location)\n{\tint\tk, slen ;\n\n\tfor (k = 0 ; k < SF_MAX_STRINGS ; k++)\n\t{\tif (psf->strings.data [k].type == 0)\n\t\t\tbreak ;\n\n\t\tif (psf->strings.data [k].flags != location)\n\t\t\tcontinue ;\n\n\t\tswitch (psf->strings.data [k].type)\n\t\t{\tcase SF_STR_SOFTWARE :\n\t\t\t\tslen = strlen (psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tpsf_binheader_writef (psf, \"Em4mb\", APPL_MARKER, slen + 4, m3ga_MARKER, psf->strings.storage + psf->strings.data [k].offset, make_size_t (slen + (slen & 1))) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_TITLE :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", NAME_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_COPYRIGHT :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", c_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_ARTIST :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", AUTH_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_COMMENT :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", ANNO_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\t/*\n\t\t\tcase SF_STR_DATE :\n\t\t\t\tpsf_binheader_writef (psf, \"Ems\", ICRD_MARKER, psf->strings.data [k].str) ;\n\t\t\t\tbreak ;\n\t\t\t*/\n\t\t\t} ;\n\t\t} ;\n\n\treturn ;\n} /* aiff_write_strings */\n\nstatic int\naiff_command (SF_PRIVATE * psf, int command, void * UNUSED (data), int UNUSED (datasize))\n{\tAIFF_PRIVATE\t*paiff ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tswitch (command)\n\t{\tcase SFC_SET_CHANNEL_MAP_INFO :\n\t\t\tpaiff->chanmap_tag = aiff_caf_find_channel_layout_tag (psf->channel_map, psf->sf.channels) ;\n\t\t\treturn (paiff->chanmap_tag != 0) ;\n\n\t\tdefault :\n\t\t\tbreak ;\n\t} ;\n\n\treturn 0 ;\n} /* aiff_command */\n\nstatic const char*\nget_loop_mode_str (int16_t mode)\n{\tswitch (mode)\n\t{\tcase 0 : return \"none\" ;\n\t\tcase 1 : return \"forward\" ;\n\t\tcase 2 : return \"backward\" ;\n\t\t} ;\n\n\treturn \"*** unknown\" ;\n} /* get_loop_mode_str */\n\nstatic int16_t\nget_loop_mode (int16_t mode)\n{\tswitch (mode)\n\t{\tcase 0 : return SF_LOOP_NONE ;\n\t\tcase 1 : return SF_LOOP_FORWARD ;\n\t\tcase 2 : return SF_LOOP_BACKWARD ;\n\t\t} ;\n\n\treturn SF_LOOP_NONE ;\n} /* get_loop_mode */\n\n/*==========================================================================================\n**\tRough hack at converting from 80 bit IEEE float in AIFF header to an int and\n**\tback again. It assumes that all sample rates are between 1 and 800MHz, which\n**\tshould be OK as other sound file formats use a 32 bit integer to store sample\n**\trate.\n**\tThere is another (probably better) version in the source code to the SoX but it\n**\thas a copyright which probably prevents it from being allowable as GPL/LGPL.\n*/\n\nstatic int\ntenbytefloat2int (uint8_t *bytes)\n{\tint val = 3 ;\n\n\tif (bytes [0] & 0x80)\t/* Negative number. */\n\t\treturn 0 ;\n\n\tif (bytes [0] <= 0x3F)\t/* Less than 1. */\n\t\treturn 1 ;\n\n\tif (bytes [0] > 0x40)\t/* Way too big. */\n\t\treturn 0x4000000 ;\n\n\tif (bytes [0] == 0x40 && bytes [1] > 0x1C) /* Too big. */\n\t\treturn 800000000 ;\n\n\t/* Ok, can handle it. */\n\n\tval = (bytes [2] << 23) | (bytes [3] << 15) | (bytes [4] << 7) | (bytes [5] >> 1) ;\n\n\tval >>= (29 - bytes [1]) ;\n\n\treturn val ;\n} /* tenbytefloat2int */\n\nstatic void\nuint2tenbytefloat (uint32_t num, uint8_t *bytes)\n{\tuint32_t mask = 0x40000000 ;\n\tint\tcount ;\n\n\tif (num <= 1)\n\t{\tbytes [0] = 0x3F ;\n\t\tbytes [1] = 0xFF ;\n\t\tbytes [2] = 0x80 ;\n\t\treturn ;\n\t\t} ;\n\n\tbytes [0] = 0x40 ;\n\n\tif (num >= mask)\n\t{\tbytes [1] = 0x1D ;\n\t\treturn ;\n\t\t} ;\n\n\tfor (count = 0 ; count < 32 ; count ++)\n\t{\tif (num & mask)\n\t\t\tbreak ;\n\t\tmask >>= 1 ;\n\t\t} ;\n\n\tnum = count < 31 ? num << (count + 1) : 0 ;\n\tbytes [1] = 29 - count ;\n\tbytes [2] = (num >> 24) & 0xFF ;\n\tbytes [3] = (num >> 16) & 0xFF ;\n\tbytes [4] = (num >> 8) & 0xFF ;\n\tbytes [5] = num & 0xFF ;\n\n} /* uint2tenbytefloat */\n\nstatic int\naiff_read_basc_chunk (SF_PRIVATE * psf, int datasize)\n{\tconst char * type_str ;\n\tbasc_CHUNK bc ;\n\tint count ;\n\n\tcount = psf_binheader_readf (psf, \"E442\", &bc.version, &bc.numBeats, &bc.rootNote) ;\n\tcount += psf_binheader_readf (psf, \"E222\", &bc.scaleType, &bc.sigNumerator, &bc.sigDenominator) ;\n\tcount += psf_binheader_readf (psf, \"E2j\", &bc.loopType, datasize - sizeof (bc)) ;\n\n\tpsf_log_printf (psf, \"  Version ? : %u\\n  Num Beats : %u\\n  Root Note : 0x%x\\n\",\n\t\t\t\t\t\tbc.version, bc.numBeats, bc.rootNote) ;\n\n\tswitch (bc.scaleType)\n\t{\tcase basc_SCALE_MINOR :\n\t\t\t\ttype_str = \"MINOR\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_MAJOR :\n\t\t\t\ttype_str = \"MAJOR\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_NEITHER :\n\t\t\t\ttype_str = \"NEITHER\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_BOTH :\n\t\t\t\ttype_str = \"BOTH\" ;\n\t\t\t\tbreak ;\n\t\tdefault :\n\t\t\t\ttype_str = \"!!WRONG!!\" ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  ScaleType : 0x%x (%s)\\n\", bc.scaleType, type_str) ;\n\tpsf_log_printf (psf, \"  Time Sig  : %d/%d\\n\", bc.sigNumerator, bc.sigDenominator) ;\n\n\tswitch (bc.loopType)\n\t{\tcase basc_TYPE_ONE_SHOT :\n\t\t\t\ttype_str = \"One Shot\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_TYPE_LOOP :\n\t\t\t\ttype_str = \"Loop\" ;\n\t\t\t\tbreak ;\n\t\tdefault:\n\t\t\t\ttype_str = \"!!WRONG!!\" ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  Loop Type : 0x%x (%s)\\n\", bc.loopType, type_str) ;\n\n\tif ((psf->loop_info = calloc (1, sizeof (SF_LOOP_INFO))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tpsf->loop_info->time_sig_num\t= bc.sigNumerator ;\n\tpsf->loop_info->time_sig_den\t= bc.sigDenominator ;\n\tpsf->loop_info->loop_mode\t\t= (bc.loopType == basc_TYPE_ONE_SHOT) ? SF_LOOP_NONE : SF_LOOP_FORWARD ;\n\tpsf->loop_info->num_beats\t\t= bc.numBeats ;\n\n\t/* Can always be recalculated from other known fields. */\n\tpsf->loop_info->bpm = (1.0 / psf->sf.frames) * psf->sf.samplerate\n\t\t\t\t\t\t\t* ((bc.numBeats * 4.0) / bc.sigDenominator) * 60.0 ;\n\tpsf->loop_info->root_key = bc.rootNote ;\n\n\tif (count < datasize)\n\t\tpsf_binheader_readf (psf, \"j\", datasize - count) ;\n\n\treturn 0 ;\n} /* aiff_read_basc_chunk */\n\n\nstatic int\naiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\n\t\tfree (psf->channel_map) ;\n\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* aiff_read_chanmap */\n\n/*==============================================================================\n*/\n\nstatic int\naiff_set_chunk (SF_PRIVATE *psf, const SF_CHUNK_INFO * chunk_info)\n{\treturn psf_save_write_chunk (&psf->wchunks, chunk_info) ;\n} /* aiff_set_chunk */\n\nstatic SF_CHUNK_ITERATOR *\naiff_next_chunk_iterator (SF_PRIVATE *psf, SF_CHUNK_ITERATOR * iterator)\n{\treturn psf_next_chunk_iterator (&psf->rchunks, iterator) ;\n} /* aiff_next_chunk_iterator */\n\nstatic int\naiff_get_chunk_size (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tint indx ;\n\n\tif ((indx = psf_find_read_chunk_iterator (&psf->rchunks, iterator)) < 0)\n\t\treturn SFE_UNKNOWN_CHUNK ;\n\n\tchunk_info->datalen = psf->rchunks.chunks [indx].len ;\n\n\treturn SFE_NO_ERROR ;\n} /* aiff_get_chunk_size */\n\nstatic int\naiff_get_chunk_data (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tsf_count_t pos ;\n\tint indx ;\n\n\tif ((indx = psf_find_read_chunk_iterator (&psf->rchunks, iterator)) < 0)\n\t\treturn SFE_UNKNOWN_CHUNK ;\n\n\tif (chunk_info->data == NULL)\n\t\treturn SFE_BAD_CHUNK_DATA_PTR ;\n\n\tchunk_info->id_size = psf->rchunks.chunks [indx].id_size ;\n\tmemcpy (chunk_info->id, psf->rchunks.chunks [indx].id, sizeof (chunk_info->id) / sizeof (*chunk_info->id)) ;\n\n\tpos = psf_ftell (psf) ;\n\tpsf_fseek (psf, psf->rchunks.chunks [indx].offset, SEEK_SET) ;\n\tpsf_fread (chunk_info->data, SF_MIN (chunk_info->datalen, psf->rchunks.chunks [indx].len), 1, psf) ;\n\tpsf_fseek (psf, pos, SEEK_SET) ;\n\n\treturn SFE_NO_ERROR ;\n} /* aiff_get_chunk_data */\n"], "fixing_code": ["/*\n** Copyright (C) 1999-2017 Erik de Castro Lopo <erikd@mega-nerd.com>\n** Copyright (C) 2005 David Viens <davidv@plogue.com>\n**\n** This program is free software; you can redistribute it and/or modify\n** it under the terms of the GNU Lesser General Public License as published by\n** the Free Software Foundation; either version 2.1 of the License, or\n** (at your option) any later version.\n**\n** This program is distributed in the hope that it will be useful,\n** but WITHOUT ANY WARRANTY; without even the implied warranty of\n** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n** GNU Lesser General Public License for more details.\n**\n** You should have received a copy of the GNU Lesser General Public License\n** along with this program; if not, write to the Free Software\n** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n#include \"sfconfig.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"sndfile.h\"\n#include \"sfendian.h\"\n#include \"common.h\"\n#include \"chanmap.h\"\n\n/*------------------------------------------------------------------------------\n * Macros to handle big/little endian issues.\n */\n\n#define FORM_MARKER\t\t(MAKE_MARKER ('F', 'O', 'R', 'M'))\n#define AIFF_MARKER\t\t(MAKE_MARKER ('A', 'I', 'F', 'F'))\n#define AIFC_MARKER\t\t(MAKE_MARKER ('A', 'I', 'F', 'C'))\n#define COMM_MARKER\t\t(MAKE_MARKER ('C', 'O', 'M', 'M'))\n#define SSND_MARKER\t\t(MAKE_MARKER ('S', 'S', 'N', 'D'))\n#define MARK_MARKER\t\t(MAKE_MARKER ('M', 'A', 'R', 'K'))\n#define INST_MARKER\t\t(MAKE_MARKER ('I', 'N', 'S', 'T'))\n#define APPL_MARKER\t\t(MAKE_MARKER ('A', 'P', 'P', 'L'))\n#define CHAN_MARKER\t\t(MAKE_MARKER ('C', 'H', 'A', 'N'))\n\n#define c_MARKER\t\t(MAKE_MARKER ('(', 'c', ')', ' '))\n#define NAME_MARKER\t\t(MAKE_MARKER ('N', 'A', 'M', 'E'))\n#define AUTH_MARKER\t\t(MAKE_MARKER ('A', 'U', 'T', 'H'))\n#define ANNO_MARKER\t\t(MAKE_MARKER ('A', 'N', 'N', 'O'))\n#define COMT_MARKER\t\t(MAKE_MARKER ('C', 'O', 'M', 'T'))\n#define FVER_MARKER\t\t(MAKE_MARKER ('F', 'V', 'E', 'R'))\n#define SFX_MARKER\t\t(MAKE_MARKER ('S', 'F', 'X', '!'))\n\n#define PEAK_MARKER\t\t(MAKE_MARKER ('P', 'E', 'A', 'K'))\n#define basc_MARKER\t\t(MAKE_MARKER ('b', 'a', 's', 'c'))\n\n/* Supported AIFC encodings.*/\n#define NONE_MARKER\t\t(MAKE_MARKER ('N', 'O', 'N', 'E'))\n#define sowt_MARKER\t\t(MAKE_MARKER ('s', 'o', 'w', 't'))\n#define twos_MARKER\t\t(MAKE_MARKER ('t', 'w', 'o', 's'))\n#define raw_MARKER\t\t(MAKE_MARKER ('r', 'a', 'w', ' '))\n#define in24_MARKER\t\t(MAKE_MARKER ('i', 'n', '2', '4'))\n#define ni24_MARKER\t\t(MAKE_MARKER ('4', '2', 'n', '1'))\n#define in32_MARKER\t\t(MAKE_MARKER ('i', 'n', '3', '2'))\n#define ni32_MARKER\t\t(MAKE_MARKER ('2', '3', 'n', 'i'))\n\n#define fl32_MARKER\t\t(MAKE_MARKER ('f', 'l', '3', '2'))\n#define FL32_MARKER\t\t(MAKE_MARKER ('F', 'L', '3', '2'))\n#define fl64_MARKER\t\t(MAKE_MARKER ('f', 'l', '6', '4'))\n#define FL64_MARKER\t\t(MAKE_MARKER ('F', 'L', '6', '4'))\n\n#define ulaw_MARKER\t\t(MAKE_MARKER ('u', 'l', 'a', 'w'))\n#define ULAW_MARKER\t\t(MAKE_MARKER ('U', 'L', 'A', 'W'))\n#define alaw_MARKER\t\t(MAKE_MARKER ('a', 'l', 'a', 'w'))\n#define ALAW_MARKER\t\t(MAKE_MARKER ('A', 'L', 'A', 'W'))\n\n#define DWVW_MARKER\t\t(MAKE_MARKER ('D', 'W', 'V', 'W'))\n#define GSM_MARKER\t\t(MAKE_MARKER ('G', 'S', 'M', ' '))\n#define ima4_MARKER\t\t(MAKE_MARKER ('i', 'm', 'a', '4'))\n\n/*\n**\tThis value is officially assigned to Mega Nerd Pty Ltd by Apple\n**\tCorportation as the Application marker for libsndfile.\n**\n**\tSee : http://developer.apple.com/faq/datatype.html\n*/\n#define m3ga_MARKER\t\t(MAKE_MARKER ('m', '3', 'g', 'a'))\n\n/* Unsupported AIFC encodings.*/\n\n#define MAC3_MARKER\t\t(MAKE_MARKER ('M', 'A', 'C', '3'))\n#define MAC6_MARKER\t\t(MAKE_MARKER ('M', 'A', 'C', '6'))\n#define ADP4_MARKER\t\t(MAKE_MARKER ('A', 'D', 'P', '4'))\n\n/* Predfined chunk sizes. */\n#define SIZEOF_AIFF_COMM\t\t18\n#define SIZEOF_AIFC_COMM_MIN\t22\n#define SIZEOF_AIFC_COMM\t\t24\n#define SIZEOF_SSND_CHUNK\t\t8\n#define SIZEOF_INST_CHUNK\t\t20\n\n/* Is it constant? */\n\n/* AIFC/IMA4 defines. */\n#define AIFC_IMA4_BLOCK_LEN\t\t\t\t34\n#define AIFC_IMA4_SAMPLES_PER_BLOCK\t\t64\n\n#define AIFF_PEAK_CHUNK_SIZE(ch)\t(2 * sizeof (int) + ch * (sizeof (float) + sizeof (int)))\n\n/*------------------------------------------------------------------------------\n * Typedefs for file chunks.\n */\n\nenum\n{\tHAVE_FORM\t\t= 0x01,\n\tHAVE_AIFF\t\t= 0x02,\n\tHAVE_AIFC\t\t= 0x04,\n\tHAVE_FVER\t\t= 0x08,\n\tHAVE_COMM\t\t= 0x10,\n\tHAVE_SSND\t\t= 0x20\n} ;\n\ntypedef struct\n{\tuint32_t\tsize ;\n\tint16_t\t\tnumChannels ;\n\tuint32_t\tnumSampleFrames ;\n\tint16_t\t\tsampleSize ;\n\tuint8_t\t\tsampleRate [10] ;\n\tuint32_t\tencoding ;\n\tchar\t\t\tzero_bytes [2] ;\n} COMM_CHUNK ;\n\ntypedef struct\n{\tuint32_t\toffset ;\n\tuint32_t\tblocksize ;\n} SSND_CHUNK ;\n\ntypedef struct\n{\tint16_t\t\tplayMode ;\n\tuint16_t\tbeginLoop ;\n\tuint16_t\tendLoop ;\n} INST_LOOP ;\n\ntypedef struct\n{\tint8_t\t\tbaseNote ;\t\t/* all notes are MIDI note numbers */\n\tint8_t\t\tdetune ;\t\t/* cents off, only -50 to +50 are significant */\n\tint8_t\t\tlowNote ;\n\tint8_t\t\thighNote ;\n\tint8_t\t\tlowVelocity ;\t/* 1 to 127 */\n\tint8_t\t\thighVelocity ;\t/* 1 to 127 */\n\tint16_t\t\tgain ;\t\t\t/* in dB, 0 is normal */\n\tINST_LOOP\tsustain_loop ;\n\tINST_LOOP\trelease_loop ;\n} INST_CHUNK ;\n\n\nenum\n{\tbasc_SCALE_MINOR = 1,\n\tbasc_SCALE_MAJOR,\n\tbasc_SCALE_NEITHER,\n\tbasc_SCALE_BOTH\n} ;\n\nenum\n{\tbasc_TYPE_LOOP = 0,\n\tbasc_TYPE_ONE_SHOT\n} ;\n\n\ntypedef struct\n{\tuint32_t\tversion ;\n\tuint32_t\tnumBeats ;\n\tuint16_t\trootNote ;\n\tuint16_t\tscaleType ;\n\tuint16_t\tsigNumerator ;\n\tuint16_t\tsigDenominator ;\n\tuint16_t\tloopType ;\n} basc_CHUNK ;\n\ntypedef struct\n{\tuint16_t\tmarkerID ;\n\tuint32_t\tposition ;\n} MARK_ID_POS ;\n\ntypedef struct\n{\tsf_count_t\tcomm_offset ;\n\tsf_count_t\tssnd_offset ;\n\n\tint32_t\t\tchanmap_tag ;\n\n\tMARK_ID_POS *markstr ;\n} AIFF_PRIVATE ;\n\n/*------------------------------------------------------------------------------\n * Private static functions.\n */\n\nstatic int\taiff_close (SF_PRIVATE *psf) ;\n\nstatic int\ttenbytefloat2int (uint8_t *bytes) ;\nstatic void uint2tenbytefloat (uint32_t num, uint8_t *bytes) ;\n\nstatic int\taiff_read_comm_chunk (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt) ;\n\nstatic int\taiff_read_header (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt) ;\n\nstatic int\taiff_write_header (SF_PRIVATE *psf, int calc_length) ;\nstatic int\taiff_write_tailer (SF_PRIVATE *psf) ;\nstatic void\taiff_write_strings (SF_PRIVATE *psf, int location) ;\n\nstatic int\taiff_command (SF_PRIVATE *psf, int command, void *data, int datasize) ;\n\nstatic const char *get_loop_mode_str (int16_t mode) ;\n\nstatic int16_t get_loop_mode (int16_t mode) ;\n\nstatic int aiff_read_basc_chunk (SF_PRIVATE * psf, int) ;\n\nstatic int aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword) ;\n\nstatic uint32_t marker_to_position (const MARK_ID_POS *m, uint16_t n, int marksize) ;\n\nstatic int aiff_set_chunk (SF_PRIVATE *psf, const SF_CHUNK_INFO * chunk_info) ;\nstatic SF_CHUNK_ITERATOR * aiff_next_chunk_iterator (SF_PRIVATE *psf, SF_CHUNK_ITERATOR * iterator) ;\nstatic int aiff_get_chunk_size (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\nstatic int aiff_get_chunk_data (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info) ;\n\n/*------------------------------------------------------------------------------\n** Public function.\n*/\n\nint\naiff_open (SF_PRIVATE *psf)\n{\tCOMM_CHUNK comm_fmt ;\n\tint error, subformat ;\n\n\tmemset (&comm_fmt, 0, sizeof (comm_fmt)) ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif ((psf->container_data = calloc (1, sizeof (AIFF_PRIVATE))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->filelength > 0))\n\t{\tif ((error = aiff_read_header (psf, &comm_fmt)))\n\t\t\treturn error ;\n\n\t\tpsf->next_chunk_iterator = aiff_next_chunk_iterator ;\n\t\tpsf->get_chunk_size = aiff_get_chunk_size ;\n\t\tpsf->get_chunk_data = aiff_get_chunk_data ;\n\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\tif (psf->is_pipe)\n\t\t\treturn SFE_NO_PIPE_WRITE ;\n\n\t\tif ((SF_CONTAINER (psf->sf.format)) != SF_FORMAT_AIFF)\n\t\t\treturn SFE_BAD_OPEN_FORMAT ;\n\n\t\tif (psf->file.mode == SFM_WRITE && (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE))\n\t\t{\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\treturn SFE_MALLOC_FAILED ;\n\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t} ;\n\n\t\tif (psf->file.mode != SFM_RDWR || psf->filelength < 40)\n\t\t{\tpsf->filelength = 0 ;\n\t\t\tpsf->datalength = 0 ;\n\t\t\tpsf->dataoffset = 0 ;\n\t\t\tpsf->sf.frames = 0 ;\n\t\t\t} ;\n\n\t\tpsf->strings.flags = SF_STR_ALLOW_START | SF_STR_ALLOW_END ;\n\n\t\tif ((error = aiff_write_header (psf, SF_FALSE)))\n\t\t\treturn error ;\n\n\t\tpsf->write_header\t= aiff_write_header ;\n\t\tpsf->set_chunk\t\t= aiff_set_chunk ;\n\t\t} ;\n\n\tpsf->container_close = aiff_close ;\n\tpsf->command = aiff_command ;\n\n\tswitch (SF_CODEC (psf->sf.format))\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_S8 :\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\terror = ulaw_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\terror = alaw_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\terror = float32_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\terror = double64_init (psf) ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_12 :\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_16 :\n\t\t\t\terror = dwvw_init (psf, 16) ;\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_24 :\n\t\t\t\terror = dwvw_init (psf, 24) ;\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_N :\n\t\t\t\tif (psf->file.mode != SFM_READ)\n\t\t\t\t{\terror = SFE_DWVW_BAD_BITWIDTH ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t} ;\n\t\t\t\tif (comm_fmt.sampleSize >= 8 && comm_fmt.sampleSize < 24)\n\t\t\t\t{\terror = dwvw_init (psf, comm_fmt.sampleSize) ;\n\t\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t} ;\n\t\t\t\tpsf_log_printf (psf, \"AIFC/DWVW : Bad bitwidth %d\\n\", comm_fmt.sampleSize) ;\n\t\t\t\terror = SFE_DWVW_BAD_BITWIDTH ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\t/*\n\t\t\t\t**\tIMA ADPCM encoded AIFF files always have a block length\n\t\t\t\t**\tof 34 which decodes to 64 samples.\n\t\t\t\t*/\n\t\t\t\terror = aiff_ima_init (psf, AIFC_IMA4_BLOCK_LEN, AIFC_IMA4_SAMPLES_PER_BLOCK) ;\n\t\t\t\tbreak ;\n\t\t/* Lite remove end */\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\terror = gsm610_init (psf) ;\n\t\t\t\tif (psf->sf.frames > comm_fmt.numSampleFrames)\n\t\t\t\t\tpsf->sf.frames = comm_fmt.numSampleFrames ;\n\t\t\t\tbreak ;\n\n\t\tdefault : return SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (psf->file.mode != SFM_WRITE && psf->sf.frames - comm_fmt.numSampleFrames != 0)\n\t{\tpsf_log_printf (psf,\n\t\t\t\"*** Frame count read from 'COMM' chunk (%u) not equal to frame count\\n\"\n\t\t\t\"*** calculated from length of 'SSND' chunk (%u).\\n\",\n\t\t\tcomm_fmt.numSampleFrames, (uint32_t) psf->sf.frames) ;\n\t\t} ;\n\n\treturn error ;\n} /* aiff_open */\n\n/*==========================================================================================\n** Private functions.\n*/\n\n/* This function ought to check size */\nstatic uint32_t\nmarker_to_position (const MARK_ID_POS *m, uint16_t n, int marksize)\n{\tint i ;\n\n\tfor (i = 0 ; i < marksize ; i++)\n\t\tif (m [i].markerID == n)\n\t\t\treturn m [i].position ;\n\treturn 0 ;\n} /* marker_to_position */\n\nstatic int\naiff_read_header (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt)\n{\tSSND_CHUNK\tssnd_fmt ;\n\tAIFF_PRIVATE *paiff ;\n\tBUF_UNION\tubuf ;\n\tuint32_t\tchunk_size = 0, FORMsize, SSNDsize, bytesread, mark_count = 0 ;\n\tint\t\t\tk, found_chunk = 0, done = 0, error = 0 ;\n\tchar\t\t*cptr ;\n\tint\t\t\tinstr_found = 0, mark_found = 0 ;\n\n\tif (psf->filelength > SF_PLATFORM_S64 (0xffffffff))\n\t\tpsf_log_printf (psf, \"Warning : filelength > 0xffffffff. This is bad!!!!\\n\") ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tpaiff->comm_offset = 0 ;\n\tpaiff->ssnd_offset = 0 ;\n\n\t/* Set position to start of file to begin reading header. */\n\tpsf_binheader_readf (psf, \"p\", 0) ;\n\n\tmemset (comm_fmt, 0, sizeof (COMM_CHUNK)) ;\n\n\t/* Until recently AIF* file were all BIG endian. */\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\t/*\tAIFF files can apparently have their chunks in any order. However, they\n\t**\tmust have a FORM chunk. Approach here is to read all the chunks one by\n\t**\tone and then check for the mandatory chunks at the end.\n\t*/\n\twhile (! done)\n\t{\tunsigned\tmarker ;\n\t\tsize_t jump = chunk_size & 1 ;\n\n\t\tmarker = chunk_size = 0 ;\n\t\tpsf_binheader_readf (psf, \"Ejm4\", jump, &marker, &chunk_size) ;\n\t\tif (marker == 0)\n\t\t{\tsf_count_t pos = psf_ftell (psf) ;\n\t\t\tpsf_log_printf (psf, \"Have 0 marker at position %D (0x%x).\\n\", pos, pos) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (psf->file.mode == SFM_RDWR && (found_chunk & HAVE_SSND))\n\t\t\treturn SFE_AIFF_RW_SSND_NOT_LAST ;\n\n\t\tpsf_store_read_chunk_u32 (&psf->rchunks, marker, psf_ftell (psf), chunk_size) ;\n\n\t\tswitch (marker)\n\t\t{\tcase FORM_MARKER :\n\t\t\t\t\tif (found_chunk)\n\t\t\t\t\t\treturn SFE_AIFF_NO_FORM ;\n\n\t\t\t\t\tFORMsize = chunk_size ;\n\n\t\t\t\t\tfound_chunk |= HAVE_FORM ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"m\", &marker) ;\n\t\t\t\t\tswitch (marker)\n\t\t\t\t\t{\tcase AIFC_MARKER :\n\t\t\t\t\t\tcase AIFF_MARKER :\n\t\t\t\t\t\t\tfound_chunk |= (marker == AIFC_MARKER) ? (HAVE_AIFC | HAVE_AIFF) : HAVE_AIFF ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf->fileoffset > 0 && psf->filelength > FORMsize + 8)\n\t\t\t\t\t{\t/* Set file length. */\n\t\t\t\t\t\tpsf->filelength = FORMsize + 8 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u\\n %M\\n\", FORMsize, marker) ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (FORMsize != psf->filelength - 2 * SIGNED_SIZEOF (chunk_size))\n\t\t\t\t\t{\tchunk_size = psf->filelength - 2 * sizeof (chunk_size) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u (should be %u)\\n %M\\n\", FORMsize, chunk_size, marker) ;\n\t\t\t\t\t\tFORMsize = chunk_size ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"FORM : %u\\n %M\\n\", FORMsize, marker) ;\n\t\t\t\t\t/* Set this to 0, so we don't jump a byte when parsing the next marker. */\n\t\t\t\t\tchunk_size = 0 ;\n\t\t\t\t\tbreak ;\n\n\n\t\t\tcase COMM_MARKER :\n\t\t\t\t\tpaiff->comm_offset = psf_ftell (psf) - 8 ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tcomm_fmt->size = chunk_size ;\n\t\t\t\t\tif ((error = aiff_read_comm_chunk (psf, comm_fmt)) != 0)\n\t\t\t\t\t\treturn error ;\n\n\t\t\t\t\tfound_chunk |= HAVE_COMM ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase PEAK_MARKER :\n\t\t\t\t\t/* Must have COMM chunk before PEAK chunk. */\n\t\t\t\t\tif ((found_chunk & (HAVE_FORM | HAVE_AIFF | HAVE_COMM)) != (HAVE_FORM | HAVE_AIFF | HAVE_COMM))\n\t\t\t\t\t\treturn SFE_AIFF_PEAK_B4_COMM ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"%M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tif (chunk_size != AIFF_PEAK_CHUNK_SIZE (psf->sf.channels))\n\t\t\t\t\t{\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** File PEAK chunk too big.\\n\") ;\n\t\t\t\t\t\treturn SFE_WAV_BAD_PEAK ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t/* read in rest of PEAK chunk. */\n\t\t\t\t\tpsf_binheader_readf (psf, \"E44\", &(psf->peak_info->version), &(psf->peak_info->timestamp)) ;\n\n\t\t\t\t\tif (psf->peak_info->version != 1)\n\t\t\t\t\t\tpsf_log_printf (psf, \"  version    : %d *** (should be version 1)\\n\", psf->peak_info->version) ;\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \"  version    : %d\\n\", psf->peak_info->version) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \"  time stamp : %d\\n\", psf->peak_info->timestamp) ;\n\t\t\t\t\tpsf_log_printf (psf, \"    Ch   Position       Value\\n\") ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\t\t\t{\tfloat value ;\n\t\t\t\t\t\tuint32_t position ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"Ef4\", &value, &position) ;\n\t\t\t\t\t\tpsf->peak_info->peaks [k].value = value ;\n\t\t\t\t\t\tpsf->peak_info->peaks [k].position = position ;\n\n\t\t\t\t\t\tsnprintf (cptr, sizeof (ubuf.scbuf), \"    %2d   %-12\" PRId64 \"   %g\\n\",\n\t\t\t\t\t\t\t\tk, psf->peak_info->peaks [k].position, psf->peak_info->peaks [k].value) ;\n\t\t\t\t\t\tcptr [sizeof (ubuf.scbuf) - 1] = 0 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"%s\", cptr) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf->peak_info->peak_loc = ((found_chunk & HAVE_SSND) == 0) ? SF_PEAK_START : SF_PEAK_END ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase SSND_MARKER :\n\t\t\t\t\tif ((found_chunk & HAVE_AIFC) && (found_chunk & HAVE_FVER) == 0)\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Valid AIFC files should have an FVER chunk.\\n\") ;\n\n\t\t\t\t\tpaiff->ssnd_offset = psf_ftell (psf) - 8 ;\n\t\t\t\t\tSSNDsize = chunk_size ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"E44\", &(ssnd_fmt.offset), &(ssnd_fmt.blocksize)) ;\n\n\t\t\t\t\tpsf->datalength = SSNDsize - sizeof (ssnd_fmt) ;\n\t\t\t\t\tpsf->dataoffset = psf_ftell (psf) ;\n\n\t\t\t\t\tif (psf->datalength > psf->filelength - psf->dataoffset || psf->datalength < 0)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" SSND : %u (should be %D)\\n\", SSNDsize, psf->filelength - psf->dataoffset + sizeof (SSND_CHUNK)) ;\n\t\t\t\t\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpsf_log_printf (psf, \" SSND : %u\\n\", SSNDsize) ;\n\n\t\t\t\t\tif (ssnd_fmt.offset == 0 || psf->dataoffset + ssnd_fmt.offset == ssnd_fmt.blocksize)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Offset     : %u\\n\", ssnd_fmt.offset) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Block Size : %u\\n\", ssnd_fmt.blocksize) ;\n\n\t\t\t\t\t\tpsf->dataoffset += ssnd_fmt.offset ;\n\t\t\t\t\t\tpsf->datalength -= ssnd_fmt.offset ;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Offset     : %u\\n\", ssnd_fmt.offset) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Block Size : %u ???\\n\", ssnd_fmt.blocksize) ;\n\t\t\t\t\t\tpsf->dataoffset += ssnd_fmt.offset ;\n\t\t\t\t\t\tpsf->datalength -= ssnd_fmt.offset ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\t/* Only set dataend if there really is data at the end. */\n\t\t\t\t\tif (psf->datalength + psf->dataoffset < psf->filelength)\n\t\t\t\t\t\tpsf->dataend = psf->datalength + psf->dataoffset ;\n\n\t\t\t\t\tfound_chunk |= HAVE_SSND ;\n\n\t\t\t\t\tif (! psf->sf.seekable)\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t/* Seek to end of SSND chunk. */\n\t\t\t\t\tpsf_fseek (psf, psf->dataoffset + psf->datalength, SEEK_SET) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase c_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf))\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\n\t\t\t\t\tpsf_sanitize_string (cptr, chunk_size) ;\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_COPYRIGHT, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase AUTH_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 1)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_ARTIST, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase COMT_MARKER :\n\t\t\t\t{\tuint16_t count, id, len ;\n\t\t\t\t\tuint32_t timestamp, bytes ;\n\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tbytes = chunk_size ;\n\t\t\t\t\tbytes -= psf_binheader_readf (psf, \"E2\", &count) ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n  count  : %d\\n\", marker, chunk_size, count) ;\n\n\t\t\t\t\tfor (k = 0 ; k < count ; k++)\n\t\t\t\t\t{\tbytes -= psf_binheader_readf (psf, \"E422\", &timestamp, &id, &len) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"   time   : 0x%x\\n   marker : %x\\n   length : %d\\n\", timestamp, id, len) ;\n\n\t\t\t\t\t\tif (len + 1 > SIGNED_SIZEOF (ubuf.scbuf))\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"\\nError : string length (%d) too big.\\n\", len) ;\n\t\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\t\tbytes -= psf_binheader_readf (psf, \"b\", cptr, len) ;\n\t\t\t\t\t\tcptr [len] = 0 ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"   string : %s\\n\", cptr) ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (bytes > 0)\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", bytes) ;\n\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase APPL_MARKER :\n\t\t\t\t{\tunsigned appl_marker ;\n\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 1)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %u (too big, skipping)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (chunk_size < 4)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too small, skipping)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"mb\", &appl_marker, cptr, chunk_size + (chunk_size & 1) - 4) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\n\t\t\t\t\tfor (k = 0 ; k < (int) chunk_size ; k++)\n\t\t\t\t\t\tif (! psf_isprint (cptr [k]))\n\t\t\t\t\t\t{\tcptr [k] = 0 ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t\t} ;\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n  AppSig : %M\\n  Name   : %s\\n\", marker, chunk_size, appl_marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_SOFTWARE, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\t} ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase NAME_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 2)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_TITLE, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase ANNO_MARKER :\n\t\t\t\t\tif (chunk_size == 0)\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tif (chunk_size >= SIGNED_SIZEOF (ubuf.scbuf) - 2)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (too big)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tcptr = ubuf.cbuf ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"b\", cptr, chunk_size + (chunk_size & 1)) ;\n\t\t\t\t\tcptr [chunk_size] = 0 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %s\\n\", marker, cptr) ;\n\t\t\t\t\tpsf_store_string (psf, SF_STR_COMMENT, cptr) ;\n\t\t\t\t\tchunk_size += chunk_size & 1 ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase INST_MARKER :\n\t\t\t\t\tif (chunk_size != SIZEOF_INST_CHUNK)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (should be %d)\\n\", marker, chunk_size, SIZEOF_INST_CHUNK) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\t{\tuint8_t bytes [6] ;\n\t\t\t\t\t\tint16_t gain ;\n\n\t\t\t\t\t\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"b\", bytes, 6) ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Base Note : %u\\n  Detune    : %u\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Low  Note : %u\\n  High Note : %u\\n\"\n\t\t\t\t\t\t\t\t\t\t\t\"  Low  Vel. : %u\\n  High Vel. : %u\\n\",\n\t\t\t\t\t\t\t\t\t\t\tbytes [0], bytes [1], bytes [2], bytes [3], bytes [4], bytes [5]) ;\n\t\t\t\t\t\tpsf->instrument->basenote = bytes [0] ;\n\t\t\t\t\t\tpsf->instrument->detune = bytes [1] ;\n\t\t\t\t\t\tpsf->instrument->key_lo = bytes [2] ;\n\t\t\t\t\t\tpsf->instrument->key_hi = bytes [3] ;\n\t\t\t\t\t\tpsf->instrument->velocity_lo = bytes [4] ;\n\t\t\t\t\t\tpsf->instrument->velocity_hi = bytes [5] ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E2\", &gain) ;\n\t\t\t\t\t\tpsf->instrument->gain = gain ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Gain (dB) : %d\\n\", gain) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\t{\tint16_t\tmode ; /* 0 - no loop, 1 - forward looping, 2 - backward looping */\n\t\t\t\t\t\tconst char\t*loop_mode ;\n\t\t\t\t\t\tuint16_t begin, end ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E222\", &mode, &begin, &end) ;\n\t\t\t\t\t\tloop_mode = get_loop_mode_str (mode) ;\n\t\t\t\t\t\tmode = get_loop_mode (mode) ;\n\t\t\t\t\t\tif (mode == SF_LOOP_NONE)\n\t\t\t\t\t\t{\tpsf->instrument->loop_count = 0 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].mode = SF_LOOP_NONE ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\tpsf->instrument->loop_count = 1 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].mode = SF_LOOP_FORWARD ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].start = begin ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].end = end ;\n\t\t\t\t\t\t\tpsf->instrument->loops [0].count = 0 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Sustain\\n   mode  : %d => %s\\n   begin : %u\\n   end   : %u\\n\",\n\t\t\t\t\t\t\t\t\t\t\tmode, loop_mode, begin, end) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"E222\", &mode, &begin, &end) ;\n\t\t\t\t\t\tloop_mode = get_loop_mode_str (mode) ;\n\t\t\t\t\t\tmode = get_loop_mode (mode) ;\n\t\t\t\t\t\tif (mode == SF_LOOP_NONE)\n\t\t\t\t\t\t\tpsf->instrument->loops [1].mode = SF_LOOP_NONE ;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\tpsf->instrument->loop_count += 1 ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].mode = SF_LOOP_FORWARD ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].start = begin ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].end = end ;\n\t\t\t\t\t\t\tpsf->instrument->loops [1].count = 0 ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Release\\n   mode  : %d => %s\\n   begin : %u\\n   end   : %u\\n\",\n\t\t\t\t\t\t\t\t\t\tmode, loop_mode, begin, end) ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tinstr_found++ ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase basc_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" basc : %u\\n\", chunk_size) ;\n\n\t\t\t\t\tif ((error = aiff_read_basc_chunk (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase MARK_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\t{\tuint16_t mark_id, n = 0 ;\n\t\t\t\t\t\tuint32_t position ;\n\n\t\t\t\t\t\tbytesread = psf_binheader_readf (psf, \"E2\", &n) ;\n\t\t\t\t\t\tmark_count = n ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"  Count : %u\\n\", mark_count) ;\n\t\t\t\t\t\tif (paiff->markstr != NULL)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"*** Second MARK chunk found. Throwing away the first.\\n\") ;\n\t\t\t\t\t\t\tfree (paiff->markstr) ;\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\tpaiff->markstr = calloc (mark_count, sizeof (MARK_ID_POS)) ;\n\t\t\t\t\t\tif (paiff->markstr == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tif (mark_count > 1000)\n\t\t\t\t\t\t{\tpsf_log_printf (psf, \"  More than 1000 markers, skipping!\\n\") ;\n\t\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\t\tif ((psf->cues = psf_cues_alloc (mark_count)) == NULL)\n\t\t\t\t\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\t\t\t\t\tfor (n = 0 ; n < mark_count && bytesread < chunk_size ; n++)\n\t\t\t\t\t\t{\tuint32_t pstr_len ;\n\t\t\t\t\t\t\tuint8_t ch ;\n\n\t\t\t\t\t\t\tbytesread += psf_binheader_readf (psf, \"E241\", &mark_id, &position, &ch) ;\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"   Mark ID  : %u\\n   Position : %u\\n\", mark_id, position) ;\n\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].indx = mark_id ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].position = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].fcc_chunk = MAKE_MARKER ('d', 'a', 't', 'a') ; /* always data */\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].chunk_start = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].block_start = 0 ;\n\t\t\t\t\t\t\tpsf->cues->cue_points [n].sample_offset = position ;\n\n\t\t\t\t\t\t\tpstr_len = (ch & 1) ? ch : ch + 1 ;\n\n\t\t\t\t\t\t\tif (pstr_len < sizeof (ubuf.scbuf) - 1)\n\t\t\t\t\t\t\t{\tbytesread += psf_binheader_readf (psf, \"b\", ubuf.scbuf, pstr_len) ;\n\t\t\t\t\t\t\t\tubuf.scbuf [pstr_len] = 0 ;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\tuint32_t read_len = pstr_len - (sizeof (ubuf.scbuf) - 1) ;\n\t\t\t\t\t\t\t\tbytesread += psf_binheader_readf (psf, \"bj\", ubuf.scbuf, read_len, pstr_len - read_len) ;\n\t\t\t\t\t\t\t\tubuf.scbuf [sizeof (ubuf.scbuf) - 1] = 0 ;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpsf_log_printf (psf, \"   Name     : %s\\n\", ubuf.scbuf) ;\n\n\t\t\t\t\t\t\tpsf_strlcpy (psf->cues->cue_points [n].name, sizeof (psf->cues->cue_points [n].name), ubuf.cbuf) ;\n\n\t\t\t\t\t\t\tpaiff->markstr [n].markerID = mark_id ;\n\t\t\t\t\t\t\tpaiff->markstr [n].position = position ;\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t**\tTODO if ubuf.scbuf is equal to\n\t\t\t\t\t\t\t**\teither Beg_loop, Beg loop or beg loop and spam\n\t\t\t\t\t\t\t**\tif (psf->instrument == NULL && (psf->instrument = psf_instrument_alloc ()) == NULL)\n\t\t\t\t\t\t\t**\t\treturn SFE_MALLOC_FAILED ;\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t} ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tmark_found++ ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size - bytesread) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase FVER_MARKER :\n\t\t\t\t\tfound_chunk |= HAVE_FVER ;\n\t\t\t\t\t/* Fall through to next case. */\n\n\t\t\tcase SFX_MARKER :\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase NONE_MARKER :\n\t\t\t\t\t/* Fix for broken AIFC files with incorrect COMM chunk length. */\n\t\t\t\t\tchunk_size = (chunk_size >> 24) - 3 ;\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\t\t\t\t\tpsf_binheader_readf (psf, \"j\", make_size_t (chunk_size)) ;\n\t\t\t\t\tbreak ;\n\n\t\t\tcase CHAN_MARKER :\n\t\t\t\t\tif (chunk_size < 12)\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %d (should be >= 12)\\n\", marker, chunk_size) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tpsf_log_printf (psf, \" %M : %d\\n\", marker, chunk_size) ;\n\n\t\t\t\t\tif ((error = aiff_read_chanmap (psf, chunk_size)))\n\t\t\t\t\t\treturn error ;\n\t\t\t\t\tbreak ;\n\n\t\t\tdefault :\n\t\t\t\t\tif (chunk_size >= 0xffff0000)\n\t\t\t\t\t{\tdone = SF_TRUE ;\n\t\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker (%X) at position %D with length %u. Exiting parser.\\n\", marker, psf_ftell (psf) - 8, chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_isprint ((marker >> 24) & 0xFF) && psf_isprint ((marker >> 16) & 0xFF)\n\t\t\t\t\t\t&& psf_isprint ((marker >> 8) & 0xFF) && psf_isprint (marker & 0xFF))\n\t\t\t\t\t{\tpsf_log_printf (psf, \" %M : %u (unknown marker)\\n\", marker, chunk_size) ;\n\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", chunk_size) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\n\t\t\t\t\tif (psf_ftell (psf) & 0x03)\n\t\t\t\t\t{\tpsf_log_printf (psf, \"  Unknown chunk marker at position %D. Resynching.\\n\", psf_ftell (psf) - 8) ;\n\t\t\t\t\t\tpsf_binheader_readf (psf, \"j\", -3) ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t} ;\n\t\t\t\t\tpsf_log_printf (psf, \"*** Unknown chunk marker %X at position %D. Exiting parser.\\n\", marker, psf_ftell (psf)) ;\n\t\t\t\t\tdone = SF_TRUE ;\n\t\t\t\t\tbreak ;\n\t\t\t} ;\t/* switch (marker) */\n\n\t\tif (chunk_size >= psf->filelength)\n\t\t{\tpsf_log_printf (psf, \"*** Chunk size %u > file length %D. Exiting parser.\\n\", chunk_size, psf->filelength) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif ((! psf->sf.seekable) && (found_chunk & HAVE_SSND))\n\t\t\tbreak ;\n\n\t\tif (psf_ftell (psf) >= psf->filelength - (2 * SIGNED_SIZEOF (int32_t)))\n\t\t\tbreak ;\n\t\t} ; /* while (1) */\n\n\tif (instr_found && mark_found)\n\t{\tint ji, str_index ;\n\t\t/* Next loop will convert markers to loop positions for internal handling */\n\t\tfor (ji = 0 ; ji < psf->instrument->loop_count ; ji ++)\n\t\t{\tif (ji < ARRAY_LEN (psf->instrument->loops))\n\t\t\t{\tpsf->instrument->loops [ji].start = marker_to_position (paiff->markstr, psf->instrument->loops [ji].start, mark_count) ;\n\t\t\t\tpsf->instrument->loops [ji].end = marker_to_position (paiff->markstr, psf->instrument->loops [ji].end, mark_count) ;\n\t\t\t\tpsf->instrument->loops [ji].mode = SF_LOOP_FORWARD ;\n\t\t\t\t} ;\n\t\t\t} ;\n\n\t\t/* The markers that correspond to loop positions can now be removed from cues struct */\n\t\tif (psf->cues->cue_count > (uint32_t) (psf->instrument->loop_count * 2))\n\t\t{\tuint32_t j ;\n\n\t\t\tfor (j = 0 ; j < psf->cues->cue_count - (uint32_t) (psf->instrument->loop_count * 2) ; j ++)\n\t\t\t{\t/* This simply copies the information in cues above loop positions and writes it at current count instead */\n\t\t\t\tpsf->cues->cue_points [j].indx = psf->cues->cue_points [j + psf->instrument->loop_count * 2].indx ;\n\t\t\t\tpsf->cues->cue_points [j].position = psf->cues->cue_points [j + psf->instrument->loop_count * 2].position ;\n\t\t\t\tpsf->cues->cue_points [j].fcc_chunk = psf->cues->cue_points [j + psf->instrument->loop_count * 2].fcc_chunk ;\n\t\t\t\tpsf->cues->cue_points [j].chunk_start = psf->cues->cue_points [j + psf->instrument->loop_count * 2].chunk_start ;\n\t\t\t\tpsf->cues->cue_points [j].block_start = psf->cues->cue_points [j + psf->instrument->loop_count * 2].block_start ;\n\t\t\t\tpsf->cues->cue_points [j].sample_offset = psf->cues->cue_points [j + psf->instrument->loop_count * 2].sample_offset ;\n\t\t\t\tfor (str_index = 0 ; str_index < 256 ; str_index++)\n\t\t\t\t\tpsf->cues->cue_points [j].name [str_index] = psf->cues->cue_points [j + psf->instrument->loop_count * 2].name [str_index] ;\n\t\t\t\t} ;\n\t\t\tpsf->cues->cue_count -= psf->instrument->loop_count * 2 ;\n\t\t\t} else\n\t\t\t{\t/* All the cues were in fact loop positions so we can actually remove the cues altogether */\n\t\t\t\tfree (psf->cues) ;\n\t\t\t\tpsf->cues = NULL ;\n\t\t\t\t}\n\t\t} ;\n\n\tif (psf->sf.channels < 1)\n\t\treturn SFE_CHANNEL_COUNT_ZERO ;\n\n\tif (psf->sf.channels >= SF_MAX_CHANNELS)\n\t\treturn SFE_CHANNEL_COUNT ;\n\n\tif (! (found_chunk & HAVE_FORM))\n\t\treturn SFE_AIFF_NO_FORM ;\n\n\tif (! (found_chunk & HAVE_AIFF))\n\t\treturn SFE_AIFF_COMM_NO_FORM ;\n\n\tif (! (found_chunk & HAVE_COMM))\n\t\treturn SFE_AIFF_SSND_NO_COMM ;\n\n\tif (! psf->dataoffset)\n\t\treturn SFE_AIFF_NO_DATA ;\n\n\treturn 0 ;\n} /* aiff_read_header */\n\nstatic int\naiff_close (SF_PRIVATE *psf)\n{\tAIFF_PRIVATE *paiff = psf->container_data ;\n\n\tif (paiff != NULL && paiff->markstr != NULL)\n\t{\tfree (paiff->markstr) ;\n\t\tpaiff->markstr = NULL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\taiff_write_tailer (psf) ;\n\t\taiff_write_header (psf, SF_TRUE) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* aiff_close */\n\nstatic int\naiff_read_comm_chunk (SF_PRIVATE *psf, COMM_CHUNK *comm_fmt)\n{\tBUF_UNION\tubuf ;\n\tint subformat, samplerate ;\n\n\tubuf.scbuf [0] = 0 ;\n\n\t/* The COMM chunk has an int aligned to an odd word boundary. Some\n\t** procesors are not able to deal with this (ie bus fault) so we have\n\t** to take special care.\n\t*/\n\n\tpsf_binheader_readf (psf, \"E242b\", &(comm_fmt->numChannels), &(comm_fmt->numSampleFrames),\n\t\t\t\t&(comm_fmt->sampleSize), &(comm_fmt->sampleRate), SIGNED_SIZEOF (comm_fmt->sampleRate)) ;\n\n\tif (comm_fmt->size > 0x10000 && (comm_fmt->size & 0xffff) == 0)\n\t{\tpsf_log_printf (psf, \" COMM : %d (0x%x) *** should be \", comm_fmt->size, comm_fmt->size) ;\n\t\tcomm_fmt->size = ENDSWAP_32 (comm_fmt->size) ;\n\t\tpsf_log_printf (psf, \"%d (0x%x)\\n\", comm_fmt->size, comm_fmt->size) ;\n\t\t}\n\telse\n\t\tpsf_log_printf (psf, \" COMM : %d\\n\", comm_fmt->size) ;\n\n\tif (comm_fmt->size == SIZEOF_AIFF_COMM)\n\t\tcomm_fmt->encoding = NONE_MARKER ;\n\telse if (comm_fmt->size == SIZEOF_AIFC_COMM_MIN)\n\t\tpsf_binheader_readf (psf, \"Em\", &(comm_fmt->encoding)) ;\n\telse if (comm_fmt->size >= SIZEOF_AIFC_COMM)\n\t{\tuint8_t encoding_len ;\n\t\tunsigned read_len ;\n\n\t\tpsf_binheader_readf (psf, \"Em1\", &(comm_fmt->encoding), &encoding_len) ;\n\n\t\tcomm_fmt->size = SF_MIN (sizeof (ubuf.scbuf), make_size_t (comm_fmt->size)) ;\n\t\tmemset (ubuf.scbuf, 0, comm_fmt->size) ;\n\t\tread_len = comm_fmt->size - SIZEOF_AIFC_COMM + 1 ;\n\t\tpsf_binheader_readf (psf, \"b\", ubuf.scbuf, read_len) ;\n\t\tubuf.scbuf [read_len + 1] = 0 ;\n\t\t} ;\n\n\tsamplerate = tenbytefloat2int (comm_fmt->sampleRate) ;\n\n\tpsf_log_printf (psf, \"  Sample Rate : %d\\n\", samplerate) ;\n\tpsf_log_printf (psf, \"  Frames      : %u%s\\n\", comm_fmt->numSampleFrames, (comm_fmt->numSampleFrames == 0 && psf->filelength > 104) ? \" (Should not be 0)\" : \"\") ;\n\n\tif (comm_fmt->numChannels < 1 || comm_fmt->numChannels >= SF_MAX_CHANNELS)\n\t{\tpsf_log_printf (psf, \"  Channels    : %d (should be >= 1 and < %d)\\n\", comm_fmt->numChannels, SF_MAX_CHANNELS) ;\n\t\treturn SFE_CHANNEL_COUNT_BAD ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  Channels    : %d\\n\", comm_fmt->numChannels) ;\n\n\t/* Found some broken 'fl32' files with comm.samplesize == 16. Fix it here. */\n\tif ((comm_fmt->encoding == fl32_MARKER || comm_fmt->encoding == FL32_MARKER) && comm_fmt->sampleSize != 32)\n\t{\tpsf_log_printf (psf, \"  Sample Size : %d (should be 32)\\n\", comm_fmt->sampleSize) ;\n\t\tcomm_fmt->sampleSize = 32 ;\n\t\t}\n\telse if ((comm_fmt->encoding == fl64_MARKER || comm_fmt->encoding == FL64_MARKER) && comm_fmt->sampleSize != 64)\n\t{\tpsf_log_printf (psf, \"  Sample Size : %d (should be 64)\\n\", comm_fmt->sampleSize) ;\n\t\tcomm_fmt->sampleSize = 64 ;\n\t\t}\n\telse\n\t\tpsf_log_printf (psf, \"  Sample Size : %d\\n\", comm_fmt->sampleSize) ;\n\n\tsubformat = s_bitwidth_to_subformat (comm_fmt->sampleSize) ;\n\n\tpsf->sf.samplerate = samplerate ;\n\tpsf->sf.frames = comm_fmt->numSampleFrames ;\n\tpsf->sf.channels = comm_fmt->numChannels ;\n\tpsf->bytewidth = BITWIDTH2BYTES (comm_fmt->sampleSize) ;\n\n\tpsf->endian = SF_ENDIAN_BIG ;\n\n\tswitch (comm_fmt->encoding)\n\t{\tcase NONE_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | subformat) ;\n\t\t\t\tbreak ;\n\n\t\tcase twos_MARKER :\n\t\tcase in24_MARKER :\n\t\tcase in32_MARKER :\n\t\t\t\tpsf->sf.format = (SF_ENDIAN_BIG | SF_FORMAT_AIFF | subformat) ;\n\t\t\t\tbreak ;\n\n\t\tcase sowt_MARKER :\n\t\tcase ni24_MARKER :\n\t\tcase ni32_MARKER :\n\t\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\t\tpsf->sf.format = (SF_ENDIAN_LITTLE | SF_FORMAT_AIFF | subformat) ;\n\t\t\t\tbreak ;\n\n\t\tcase fl32_MARKER :\n\t\tcase FL32_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_FLOAT) ;\n\t\t\t\tbreak ;\n\n\t\tcase ulaw_MARKER :\n\t\tcase ULAW_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_ULAW) ;\n\t\t\t\tbreak ;\n\n\t\tcase alaw_MARKER :\n\t\tcase ALAW_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_ALAW) ;\n\t\t\t\tbreak ;\n\n\t\tcase fl64_MARKER :\n\t\tcase FL64_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_DOUBLE) ;\n\t\t\t\tbreak ;\n\n\t\tcase raw_MARKER :\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_PCM_U8) ;\n\t\t\t\tbreak ;\n\n\t\tcase DWVW_MARKER :\n\t\t\t\tpsf->sf.format = SF_FORMAT_AIFF ;\n\t\t\t\tswitch (comm_fmt->sampleSize)\n\t\t\t\t{\tcase 12 :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_12 ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tcase 16 :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_16 ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tcase 24 :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_24 ;\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tpsf->sf.format |= SF_FORMAT_DWVW_N ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t} ;\n\t\t\t\tbreak ;\n\n\t\tcase GSM_MARKER :\n\t\t\t\tpsf->sf.format = SF_FORMAT_AIFF ;\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_GSM610) ;\n\t\t\t\tbreak ;\n\n\n\t\tcase ima4_MARKER :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tpsf->sf.format = (SF_FORMAT_AIFF | SF_FORMAT_IMA_ADPCM) ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"AIFC : Unimplemented format : %M\\n\", comm_fmt->encoding) ;\n\t\t\treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (! ubuf.scbuf [0])\n\t\tpsf_log_printf (psf, \"  Encoding    : %M\\n\", comm_fmt->encoding) ;\n\telse\n\t\tpsf_log_printf (psf, \"  Encoding    : %M => %s\\n\", comm_fmt->encoding, ubuf.scbuf) ;\n\n\treturn 0 ;\n} /* aiff_read_comm_chunk */\n\n\n/*==========================================================================================\n*/\n\nstatic void\naiff_rewrite_header (SF_PRIVATE *psf)\n{\n\t/* Assuming here that the header has already been written and just\n\t** needs to be corrected for new data length. That means that we\n\t** only change the length fields of the FORM and SSND chunks ;\n\t** everything else can be skipped over.\n\t*/\n\tint k, ch, comm_size, comm_frames ;\n\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\tpsf_fread (psf->header.ptr, psf->dataoffset, 1, psf) ;\n\n\tpsf->header.indx = 0 ;\n\n\t/* FORM chunk. */\n\tpsf_binheader_writef (psf, \"Etm8\", FORM_MARKER, psf->filelength - 8) ;\n\n\t/* COMM chunk. */\n\tif ((k = psf_find_read_chunk_m32 (&psf->rchunks, COMM_MARKER)) >= 0)\n\t{\tpsf->header.indx = psf->rchunks.chunks [k].offset - 8 ;\n\t\tcomm_frames = psf->sf.frames ;\n\t\tcomm_size = psf->rchunks.chunks [k].len ;\n\t\tpsf_binheader_writef (psf, \"Em42t4\", COMM_MARKER, comm_size, psf->sf.channels, comm_frames) ;\n\t\t} ;\n\n\t/* PEAK chunk. */\n\tif ((k = psf_find_read_chunk_m32 (&psf->rchunks, PEAK_MARKER)) >= 0)\n\t{\tpsf->header.indx = psf->rchunks.chunks [k].offset - 8 ;\n\t\tpsf_binheader_writef (psf, \"Em4\", PEAK_MARKER, AIFF_PEAK_CHUNK_SIZE (psf->sf.channels)) ;\n\t\tpsf_binheader_writef (psf, \"E44\", 1, time (NULL)) ;\n\t\tfor (ch = 0 ; ch < psf->sf.channels ; ch++)\n\t\t\tpsf_binheader_writef (psf, \"Eft8\", (float) psf->peak_info->peaks [ch].value, psf->peak_info->peaks [ch].position) ;\n\t\t} ;\n\n\n\t/* SSND chunk. */\n\tif ((k = psf_find_read_chunk_m32 (&psf->rchunks, SSND_MARKER)) >= 0)\n\t{\tpsf->header.indx = psf->rchunks.chunks [k].offset - 8 ;\n\t\tpsf_binheader_writef (psf, \"Etm8\", SSND_MARKER, psf->datalength + SIZEOF_SSND_CHUNK) ;\n\t\t} ;\n\n\t/* Header mangling complete so write it out. */\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\n\treturn ;\n} /* aiff_rewrite_header */\n\nstatic int\naiff_write_header (SF_PRIVATE *psf, int calc_length)\n{\tsf_count_t\t\tcurrent ;\n\tAIFF_PRIVATE\t*paiff ;\n\tuint8_t\tcomm_sample_rate [10], comm_zero_bytes [2] = { 0, 0 } ;\n\tuint32_t\tcomm_type, comm_size, comm_encoding, comm_frames = 0, uk ;\n\tint\t\t\t\tk, endian, has_data = SF_FALSE ;\n\tint16_t\t\t\tbit_width ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tcurrent = psf_ftell (psf) ;\n\n\tif (current > psf->dataoffset)\n\t\thas_data = SF_TRUE ;\n\n\tif (calc_length)\n\t{\tpsf->filelength = psf_get_filelen (psf) ;\n\n\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\t\tif (psf->dataend)\n\t\t\tpsf->datalength -= psf->filelength - psf->dataend ;\n\n\t\tif (psf->bytewidth > 0)\n\t\t\tpsf->sf.frames = psf->datalength / (psf->bytewidth * psf->sf.channels) ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_RDWR && psf->dataoffset > 0 && psf->rchunks.count > 0)\n\t{\taiff_rewrite_header (psf) ;\n\t\tif (current > 0)\n\t\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tendian = SF_ENDIAN (psf->sf.format) ;\n\tif (CPU_IS_LITTLE_ENDIAN && endian == SF_ENDIAN_CPU)\n\t\tendian = SF_ENDIAN_LITTLE ;\n\n\t/* Standard value here. */\n\tbit_width = psf->bytewidth * 8 ;\n\tcomm_frames = (psf->sf.frames > 0xFFFFFFFF) ? 0xFFFFFFFF : psf->sf.frames ;\n\n\tswitch (SF_CODEC (psf->sf.format) | endian)\n\t{\tcase SF_FORMAT_PCM_S8 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = twos_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_S8 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = sowt_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = twos_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_16 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = sowt_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_24 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = in24_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_24 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = ni24_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_32 | SF_ENDIAN_BIG :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = in32_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_32 | SF_ENDIAN_LITTLE :\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\tcomm_encoding = ni32_MARKER ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_S8 :\t\t\t/* SF_ENDIAN_FILE */\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\tcomm_type = AIFF_MARKER ;\n\t\t\tcomm_size = SIZEOF_AIFF_COMM ;\n\t\t\tcomm_encoding = 0 ;\n\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_FLOAT :\t\t\t\t\t/* Big endian floating point. */\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = FL32_MARKER ;\t/* Use 'FL32' because its easier to read. */\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\t\t\t\t\t/* Big endian double precision floating point. */\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = FL64_MARKER ;\t/* Use 'FL64' because its easier to read. */\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = ulaw_MARKER ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = alaw_MARKER ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_PCM_U8 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = raw_MARKER ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_12 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = DWVW_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 12 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_16 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = DWVW_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 16 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DWVW_24 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = DWVW_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 24 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = GSM_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 16 ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\t\t\tcomm_type = AIFC_MARKER ;\n\t\t\t\tcomm_size = SIZEOF_AIFC_COMM ;\n\t\t\t\tcomm_encoding = ima4_MARKER ;\n\n\t\t\t\t/* Override standard value here.*/\n\t\t\t\tbit_width = 16 ;\n\t\t\t\tcomm_frames = psf->sf.frames / AIFC_IMA4_SAMPLES_PER_BLOCK ;\n\t\t\t\tbreak ;\n\n\t\tdefault : return SFE_BAD_OPEN_FORMAT ;\n\t\t} ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\tpsf_binheader_writef (psf, \"Etm8\", FORM_MARKER, psf->filelength - 8) ;\n\n\t/* Write AIFF/AIFC marker and COM chunk. */\n\tif (comm_type == AIFC_MARKER)\n\t\t/* AIFC must have an FVER chunk. */\n\t\tpsf_binheader_writef (psf, \"Emm44\", comm_type, FVER_MARKER, 4, 0xA2805140) ;\n\telse\n\t\tpsf_binheader_writef (psf, \"Em\", comm_type) ;\n\n\tpaiff->comm_offset = psf->header.indx - 8 ;\n\n\tmemset (comm_sample_rate, 0, sizeof (comm_sample_rate)) ;\n\tuint2tenbytefloat (psf->sf.samplerate, comm_sample_rate) ;\n\n\tpsf_binheader_writef (psf, \"Em42t42\", COMM_MARKER, comm_size, psf->sf.channels, comm_frames, bit_width) ;\n\tpsf_binheader_writef (psf, \"b\", comm_sample_rate, sizeof (comm_sample_rate)) ;\n\n\t/* AIFC chunks have some extra data. */\n\tif (comm_type == AIFC_MARKER)\n\t\tpsf_binheader_writef (psf, \"mb\", comm_encoding, comm_zero_bytes, sizeof (comm_zero_bytes)) ;\n\n\tif (psf->channel_map && paiff->chanmap_tag)\n\t\tpsf_binheader_writef (psf, \"Em4444\", CHAN_MARKER, 12, paiff->chanmap_tag, 0, 0) ;\n\n\t/* Check if there's a INST chunk to write */\n\tif (psf->instrument != NULL && psf->cues != NULL)\n\t{\t/* Huge chunk of code removed here because it had egregious errors that were\n\t\t** not detected by either the compiler or the tests. It was found when updating\n\t\t** the way psf_binheader_writef works.\n\t\t*/\n\t\t}\n\telse if (psf->instrument == NULL && psf->cues != NULL)\n\t{\t/* There are cues but no loops */\n\t\tuint32_t idx ;\n\t\tint totalStringLength = 0, stringLength ;\n\n\t\t/* Here we count how many bytes will the pascal strings need */\n\t\tfor (idx = 0 ; idx < psf->cues->cue_count ; idx++)\n\t\t{\tstringLength = strlen (psf->cues->cue_points [idx].name) + 1 ; /* We'll count the first byte also of every pascal string */\n\t\t\ttotalStringLength += stringLength + (stringLength % 2 == 0 ? 0 : 1) ;\n\t\t\t} ;\n\n\t\tpsf_binheader_writef (psf, \"Em42\",\n\t\t\tMARK_MARKER, 2 + psf->cues->cue_count * (2 + 4) + totalStringLength, psf->cues->cue_count) ;\n\n\t\tfor (idx = 0 ; idx < psf->cues->cue_count ; idx++)\n\t\t\tpsf_binheader_writef (psf, \"E24p\", psf->cues->cue_points [idx].indx, psf->cues->cue_points [idx].sample_offset, psf->cues->cue_points [idx].name) ;\n\t\t} ;\n\n\tif (psf->strings.flags & SF_STR_LOCATE_START)\n\t\taiff_write_strings (psf, SF_STR_LOCATE_START) ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_START)\n\t{\tpsf_binheader_writef (psf, \"Em4\", PEAK_MARKER, AIFF_PEAK_CHUNK_SIZE (psf->sf.channels)) ;\n\t\tpsf_binheader_writef (psf, \"E44\", 1, time (NULL)) ;\n\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\tpsf_binheader_writef (psf, \"Eft8\", (float) psf->peak_info->peaks [k].value, psf->peak_info->peaks [k].position) ;\n\t\t} ;\n\n\t/* Write custom headers. */\n\tfor (uk = 0 ; uk < psf->wchunks.used ; uk++)\n\t\tpsf_binheader_writef (psf, \"Em4b\", psf->wchunks.chunks [uk].mark32, psf->wchunks.chunks [uk].len, psf->wchunks.chunks [uk].data, make_size_t (psf->wchunks.chunks [uk].len)) ;\n\n\t/* Write SSND chunk. */\n\tpaiff->ssnd_offset = psf->header.indx ;\n\tpsf_binheader_writef (psf, \"Etm844\", SSND_MARKER, psf->datalength + SIZEOF_SSND_CHUNK, 0, 0) ;\n\n\t/* Header construction complete so write it out. */\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\tif (has_data && psf->dataoffset != psf->header.indx)\n\t\treturn psf->error = SFE_INTERNAL ;\n\n\tpsf->dataoffset = psf->header.indx ;\n\n\tif (! has_data)\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\telse if (current > 0)\n\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\n\treturn psf->error ;\n} /* aiff_write_header */\n\nstatic int\naiff_write_tailer (SF_PRIVATE *psf)\n{\tint\t\tk ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\n\tpsf->dataend = psf_fseek (psf, 0, SEEK_END) ;\n\n\t/* Make sure tailer data starts at even byte offset. Pad if necessary. */\n\tif (psf->dataend % 2 == 1)\n\t{\tpsf_fwrite (psf->header.ptr, 1, 1, psf) ;\n\t\tpsf->dataend ++ ;\n\t\t} ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_END)\n\t{\tpsf_binheader_writef (psf, \"Em4\", PEAK_MARKER, AIFF_PEAK_CHUNK_SIZE (psf->sf.channels)) ;\n\t\tpsf_binheader_writef (psf, \"E44\", 1, time (NULL)) ;\n\t\tfor (k = 0 ; k < psf->sf.channels ; k++)\n\t\t\tpsf_binheader_writef (psf, \"Eft8\", (float) psf->peak_info->peaks [k].value, psf->peak_info->peaks [k].position) ;\n\t\t} ;\n\n\tif (psf->strings.flags & SF_STR_LOCATE_END)\n\t\taiff_write_strings (psf, SF_STR_LOCATE_END) ;\n\n\t/* Write the tailer. */\n\tif (psf->header.indx > 0)\n\t\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\n\treturn 0 ;\n} /* aiff_write_tailer */\n\nstatic void\naiff_write_strings (SF_PRIVATE *psf, int location)\n{\tint\tk, slen ;\n\n\tfor (k = 0 ; k < SF_MAX_STRINGS ; k++)\n\t{\tif (psf->strings.data [k].type == 0)\n\t\t\tbreak ;\n\n\t\tif (psf->strings.data [k].flags != location)\n\t\t\tcontinue ;\n\n\t\tswitch (psf->strings.data [k].type)\n\t\t{\tcase SF_STR_SOFTWARE :\n\t\t\t\tslen = strlen (psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tpsf_binheader_writef (psf, \"Em4mb\", APPL_MARKER, slen + 4, m3ga_MARKER, psf->strings.storage + psf->strings.data [k].offset, make_size_t (slen + (slen & 1))) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_TITLE :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", NAME_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_COPYRIGHT :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", c_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_ARTIST :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", AUTH_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\tcase SF_STR_COMMENT :\n\t\t\t\tpsf_binheader_writef (psf, \"EmS\", ANNO_MARKER, psf->strings.storage + psf->strings.data [k].offset) ;\n\t\t\t\tbreak ;\n\n\t\t\t/*\n\t\t\tcase SF_STR_DATE :\n\t\t\t\tpsf_binheader_writef (psf, \"Ems\", ICRD_MARKER, psf->strings.data [k].str) ;\n\t\t\t\tbreak ;\n\t\t\t*/\n\t\t\t} ;\n\t\t} ;\n\n\treturn ;\n} /* aiff_write_strings */\n\nstatic int\naiff_command (SF_PRIVATE * psf, int command, void * UNUSED (data), int UNUSED (datasize))\n{\tAIFF_PRIVATE\t*paiff ;\n\n\tif ((paiff = psf->container_data) == NULL)\n\t\treturn SFE_INTERNAL ;\n\n\tswitch (command)\n\t{\tcase SFC_SET_CHANNEL_MAP_INFO :\n\t\t\tpaiff->chanmap_tag = aiff_caf_find_channel_layout_tag (psf->channel_map, psf->sf.channels) ;\n\t\t\treturn (paiff->chanmap_tag != 0) ;\n\n\t\tdefault :\n\t\t\tbreak ;\n\t} ;\n\n\treturn 0 ;\n} /* aiff_command */\n\nstatic const char*\nget_loop_mode_str (int16_t mode)\n{\tswitch (mode)\n\t{\tcase 0 : return \"none\" ;\n\t\tcase 1 : return \"forward\" ;\n\t\tcase 2 : return \"backward\" ;\n\t\t} ;\n\n\treturn \"*** unknown\" ;\n} /* get_loop_mode_str */\n\nstatic int16_t\nget_loop_mode (int16_t mode)\n{\tswitch (mode)\n\t{\tcase 0 : return SF_LOOP_NONE ;\n\t\tcase 1 : return SF_LOOP_FORWARD ;\n\t\tcase 2 : return SF_LOOP_BACKWARD ;\n\t\t} ;\n\n\treturn SF_LOOP_NONE ;\n} /* get_loop_mode */\n\n/*==========================================================================================\n**\tRough hack at converting from 80 bit IEEE float in AIFF header to an int and\n**\tback again. It assumes that all sample rates are between 1 and 800MHz, which\n**\tshould be OK as other sound file formats use a 32 bit integer to store sample\n**\trate.\n**\tThere is another (probably better) version in the source code to the SoX but it\n**\thas a copyright which probably prevents it from being allowable as GPL/LGPL.\n*/\n\nstatic int\ntenbytefloat2int (uint8_t *bytes)\n{\tint val = 3 ;\n\n\tif (bytes [0] & 0x80)\t/* Negative number. */\n\t\treturn 0 ;\n\n\tif (bytes [0] <= 0x3F)\t/* Less than 1. */\n\t\treturn 1 ;\n\n\tif (bytes [0] > 0x40)\t/* Way too big. */\n\t\treturn 0x4000000 ;\n\n\tif (bytes [0] == 0x40 && bytes [1] > 0x1C) /* Too big. */\n\t\treturn 800000000 ;\n\n\t/* Ok, can handle it. */\n\n\tval = (bytes [2] << 23) | (bytes [3] << 15) | (bytes [4] << 7) | (bytes [5] >> 1) ;\n\n\tval >>= (29 - bytes [1]) ;\n\n\treturn val ;\n} /* tenbytefloat2int */\n\nstatic void\nuint2tenbytefloat (uint32_t num, uint8_t *bytes)\n{\tuint32_t mask = 0x40000000 ;\n\tint\tcount ;\n\n\tif (num <= 1)\n\t{\tbytes [0] = 0x3F ;\n\t\tbytes [1] = 0xFF ;\n\t\tbytes [2] = 0x80 ;\n\t\treturn ;\n\t\t} ;\n\n\tbytes [0] = 0x40 ;\n\n\tif (num >= mask)\n\t{\tbytes [1] = 0x1D ;\n\t\treturn ;\n\t\t} ;\n\n\tfor (count = 0 ; count < 32 ; count ++)\n\t{\tif (num & mask)\n\t\t\tbreak ;\n\t\tmask >>= 1 ;\n\t\t} ;\n\n\tnum = count < 31 ? num << (count + 1) : 0 ;\n\tbytes [1] = 29 - count ;\n\tbytes [2] = (num >> 24) & 0xFF ;\n\tbytes [3] = (num >> 16) & 0xFF ;\n\tbytes [4] = (num >> 8) & 0xFF ;\n\tbytes [5] = num & 0xFF ;\n\n} /* uint2tenbytefloat */\n\nstatic int\naiff_read_basc_chunk (SF_PRIVATE * psf, int datasize)\n{\tconst char * type_str ;\n\tbasc_CHUNK bc ;\n\tint count ;\n\n\tcount = psf_binheader_readf (psf, \"E442\", &bc.version, &bc.numBeats, &bc.rootNote) ;\n\tcount += psf_binheader_readf (psf, \"E222\", &bc.scaleType, &bc.sigNumerator, &bc.sigDenominator) ;\n\tcount += psf_binheader_readf (psf, \"E2j\", &bc.loopType, datasize - sizeof (bc)) ;\n\n\tpsf_log_printf (psf, \"  Version ? : %u\\n  Num Beats : %u\\n  Root Note : 0x%x\\n\",\n\t\t\t\t\t\tbc.version, bc.numBeats, bc.rootNote) ;\n\n\tswitch (bc.scaleType)\n\t{\tcase basc_SCALE_MINOR :\n\t\t\t\ttype_str = \"MINOR\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_MAJOR :\n\t\t\t\ttype_str = \"MAJOR\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_NEITHER :\n\t\t\t\ttype_str = \"NEITHER\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_BOTH :\n\t\t\t\ttype_str = \"BOTH\" ;\n\t\t\t\tbreak ;\n\t\tdefault :\n\t\t\t\ttype_str = \"!!WRONG!!\" ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  ScaleType : 0x%x (%s)\\n\", bc.scaleType, type_str) ;\n\tpsf_log_printf (psf, \"  Time Sig  : %d/%d\\n\", bc.sigNumerator, bc.sigDenominator) ;\n\n\tswitch (bc.loopType)\n\t{\tcase basc_TYPE_ONE_SHOT :\n\t\t\t\ttype_str = \"One Shot\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_TYPE_LOOP :\n\t\t\t\ttype_str = \"Loop\" ;\n\t\t\t\tbreak ;\n\t\tdefault:\n\t\t\t\ttype_str = \"!!WRONG!!\" ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  Loop Type : 0x%x (%s)\\n\", bc.loopType, type_str) ;\n\n\tif ((psf->loop_info = calloc (1, sizeof (SF_LOOP_INFO))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tpsf->loop_info->time_sig_num\t= bc.sigNumerator ;\n\tpsf->loop_info->time_sig_den\t= bc.sigDenominator ;\n\tpsf->loop_info->loop_mode\t\t= (bc.loopType == basc_TYPE_ONE_SHOT) ? SF_LOOP_NONE : SF_LOOP_FORWARD ;\n\tpsf->loop_info->num_beats\t\t= bc.numBeats ;\n\n\t/* Can always be recalculated from other known fields. */\n\tpsf->loop_info->bpm = (1.0 / psf->sf.frames) * psf->sf.samplerate\n\t\t\t\t\t\t\t* ((bc.numBeats * 4.0) / bc.sigDenominator) * 60.0 ;\n\tpsf->loop_info->root_key = bc.rootNote ;\n\n\tif (count < datasize)\n\t\tpsf_binheader_readf (psf, \"j\", datasize - count) ;\n\n\treturn 0 ;\n} /* aiff_read_basc_chunk */\n\n\nstatic int\naiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;\n\n\t\tfree (psf->channel_map) ;\n\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\n\treturn 0 ;\n} /* aiff_read_chanmap */\n\n/*==============================================================================\n*/\n\nstatic int\naiff_set_chunk (SF_PRIVATE *psf, const SF_CHUNK_INFO * chunk_info)\n{\treturn psf_save_write_chunk (&psf->wchunks, chunk_info) ;\n} /* aiff_set_chunk */\n\nstatic SF_CHUNK_ITERATOR *\naiff_next_chunk_iterator (SF_PRIVATE *psf, SF_CHUNK_ITERATOR * iterator)\n{\treturn psf_next_chunk_iterator (&psf->rchunks, iterator) ;\n} /* aiff_next_chunk_iterator */\n\nstatic int\naiff_get_chunk_size (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tint indx ;\n\n\tif ((indx = psf_find_read_chunk_iterator (&psf->rchunks, iterator)) < 0)\n\t\treturn SFE_UNKNOWN_CHUNK ;\n\n\tchunk_info->datalen = psf->rchunks.chunks [indx].len ;\n\n\treturn SFE_NO_ERROR ;\n} /* aiff_get_chunk_size */\n\nstatic int\naiff_get_chunk_data (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tsf_count_t pos ;\n\tint indx ;\n\n\tif ((indx = psf_find_read_chunk_iterator (&psf->rchunks, iterator)) < 0)\n\t\treturn SFE_UNKNOWN_CHUNK ;\n\n\tif (chunk_info->data == NULL)\n\t\treturn SFE_BAD_CHUNK_DATA_PTR ;\n\n\tchunk_info->id_size = psf->rchunks.chunks [indx].id_size ;\n\tmemcpy (chunk_info->id, psf->rchunks.chunks [indx].id, sizeof (chunk_info->id) / sizeof (*chunk_info->id)) ;\n\n\tpos = psf_ftell (psf) ;\n\tpsf_fseek (psf, psf->rchunks.chunks [indx].offset, SEEK_SET) ;\n\tpsf_fread (chunk_info->data, SF_MIN (chunk_info->datalen, psf->rchunks.chunks [indx].len), 1, psf) ;\n\tpsf_fseek (psf, pos, SEEK_SET) ;\n\n\treturn SFE_NO_ERROR ;\n} /* aiff_get_chunk_data */\n"], "filenames": ["src/aiff.c"], "buggy_code_start_loc": [1762], "buggy_code_end_loc": [1763], "fixing_code_start_loc": [1762], "fixing_code_end_loc": [1763], "type": "CWE-119", "message": "In libsndfile version 1.0.28, an error in the \"aiff_read_chanmap()\" function (aiff.c) can be exploited to cause an out-of-bounds read memory access via a specially crafted AIFF file.", "other": {"cve": {"id": "CVE-2017-6892", "sourceIdentifier": "PSIRT-CNA@flexerasoftware.com", "published": "2017-06-12T16:29:00.187", "lastModified": "2020-10-29T19:15:13.117", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libsndfile version 1.0.28, an error in the \"aiff_read_chanmap()\" function (aiff.c) can be exploited to cause an out-of-bounds read memory access via a specially crafted AIFF file."}, {"lang": "es", "value": "En libsndfile versi\u00f3n 1.0.28, se puede explotar un error en la funci\u00f3n \"aiff_read_chanmap()\" del archivo (aiff.c) para causar un acceso a memoria de lectura fuera de l\u00edmites por medio de un archivo AIFF especialmente creado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsndfile_project:libsndfile:1.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "233F513A-E8C3-4B55-BA92-6A814D3A7CED"}]}]}], "references": [{"url": "https://github.com/erikd/libsndfile/commit/f833c53cb596e9e1792949f762e0b33661822748", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00030.html", "source": "PSIRT-CNA@flexerasoftware.com"}, {"url": "https://security.gentoo.org/glsa/201811-23", "source": "PSIRT-CNA@flexerasoftware.com"}, {"url": "https://usn.ubuntu.com/4013-1/", "source": "PSIRT-CNA@flexerasoftware.com"}]}, "github_commit_url": "https://github.com/erikd/libsndfile/commit/f833c53cb596e9e1792949f762e0b33661822748"}}