{"buggy_code": ["Jinja2 Changelog\n================\n\nVersion 2.7.2\n-------------\n(bugfix release, release date to be decided)\n\n- Prefix loader was not forwarding the locals properly to\n  inner loaders.  This is now fixed.\n\nVersion 2.7.1\n-------------\n(bugfix release, released on August 7th 2013)\n\n- Fixed a bug with ``call_filter`` not working properly on environment\n  and context filters.\n- Fixed lack of Python 3 support for bytecode caches.\n- Reverted support for defining blocks in included templates as this\n  broke existing templates for users.\n- Fixed some warnings with hashing of undefineds and nodes if Python\n  is run with warnings for Python 3.\n- Added support for properly hashing undefined objects.\n- Fixed a bug with the title filter not working on already uppercase\n  strings.\n\nVersion 2.7\n-----------\n(codename Translation, released on May 20th 2013)\n\n- Choice and prefix loaders now dispatch source and template lookup\n  separately in order to work in combination with module loaders as\n  advertised.\n- Fixed filesizeformat.\n- Added a non-silent option for babel extraction.\n- Added `urlencode` filter that automatically quotes values for\n  URL safe usage with utf-8 as only supported encoding.  If applications\n  want to change this encoding they can override the filter.\n- Added `keep-trailing-newline` configuration to environments and\n  templates to optionally preserve the final trailing newline.\n- Accessing `last` on the loop context no longer causes the iterator\n  to be consumed into a list.\n- Python requirement changed: 2.6, 2.7 or >= 3.3 are required now,\n  supported by same source code, using the \"six\" compatibility library.\n- Allow `contextfunction` and other decorators to be applied to `__call__`.\n- Added support for changing from newline to different signs in the `wordwrap`\n  filter.\n- Added support for ignoring memcache errors silently.\n- Added support for keeping the trailing newline in templates.\n- Added finer grained support for stripping whitespace on the left side\n  of blocks.\n- Added `map`, `select`, `reject`, `selectattr` and `rejectattr`\n  filters.\n- Added support for `loop.depth` to figure out how deep inside a recursive\n  loop the code is.\n- Disabled py_compile for pypy and python 3.\n\nVersion 2.6\n-----------\n(codename Convolution, released on July 24th 2011)\n\n- internal attributes now raise an internal attribute error now instead\n  of returning an undefined.  This fixes problems when passing undefined\n  objects to Python semantics expecting APIs.\n- traceback support now works properly for PyPy.  (Tested with 1.4)\n- implemented operator intercepting for sandboxed environments.  This\n  allows application developers to disable builtin operators for better\n  security.  (For instance limit the mathematical operators to actual\n  integers instead of longs)\n- groupby filter now supports dotted notation for grouping by attributes\n  of attributes.\n- scoped blocks now properly treat toplevel assignments and imports.\n  Previously an import suddenly \"disappeared\" in a scoped block.\n- automatically detect newer Python interpreter versions before loading code\n  from bytecode caches to prevent segfaults on invalid opcodes.  The segfault\n  in earlier Jinja2 versions here was not a Jinja2 bug but a limitation in\n  the underlying Python interpreter.  If you notice Jinja2 segfaulting in\n  earlier versions after an upgrade of the Python interpreter you don't have\n  to upgrade, it's enough to flush the bytecode cache.  This just no longer\n  makes this necessary, Jinja2 will automatically detect these cases now.\n- the sum filter can now sum up values by attribute.  This is a backwards\n  incompatible change.  The argument to the filter previously was the\n  optional starting index which defaultes to zero.  This now became the\n  second argument to the function because it's rarely used.\n- like sum, sort now also makes it possible to order items by attribute.\n- like sum and sort, join now also is able to join attributes of objects\n  as string.\n- the internal eval context now has a reference to the environment.\n- added a mapping test to see if an object is a dict or an object with\n  a similar interface.\n\nVersion 2.5.5\n-------------\n(re-release of 2.5.4 with built documentation removed for filesize.\n Released on October 18th 2010)\n\n- built documentation is no longer part of release.\n\nVersion 2.5.4\n-------------\n(bugfix release, released on October 17th 2010)\n\n- Fixed extensions not loading properly with overlays.\n- Work around a bug in cpython for the debugger that causes segfaults\n  on 64bit big-endian architectures.\n\nVersion 2.5.3\n-------------\n(bugfix release, released on October 17th 2010)\n\n- fixed an operator precedence error introduced in 2.5.2.  Statements\n  like \"-foo.bar\" had their implicit parentheses applied around the\n  first part of the expression (\"(-foo).bar\") instead of the more\n  correct \"-(foo.bar)\".\n\nVersion 2.5.2\n-------------\n(bugfix release, released on August 18th 2010)\n\n- improved setup.py script to better work with assumptions people\n  might still have from it (``--with-speedups``).\n- fixed a packaging error that excluded the new debug support.\n\nVersion 2.5.1\n-------------\n(bugfix release, released on August 17th 2010)\n\n- StopIteration exceptions raised by functions called from templates\n  are now intercepted and converted to undefineds.  This solves a\n  lot of debugging grief.  (StopIteration is used internally to\n  abort template execution)\n- improved performance of macro calls slightly.\n- babel extraction can now properly extract newstyle gettext calls.\n- using the variable `num` in newstyle gettext for something else\n  than the pluralize count will no longer raise a :exc:`KeyError`.\n- removed builtin markup class and switched to markupsafe.  For backwards\n  compatibility the pure Python implementation still exists but is\n  pulled from markupsafe by the Jinja2 developers.  The debug support\n  went into a separate feature called \"debugsupport\" and is disabled\n  by default because it is only relevant for Python 2.4\n- fixed an issue with unary operators having the wrong precendence.\n\nVersion 2.5\n-----------\n(codename Incoherence, relased on May 29th 2010)\n\n- improved the sort filter (should have worked like this for a\n  long time) by adding support for case insensitive searches.\n- fixed a bug for getattribute constant folding.\n- support for newstyle gettext translations which result in a\n  nicer in-template user interface and more consistent\n  catalogs. (:ref:`newstyle-gettext`)\n- it's now possible to register extensions after an environment\n  was created.\n\nVersion 2.4.1\n-------------\n(bugfix release, released on April 20th 2010)\n\n- fixed an error reporting bug for undefineds.\n\nVersion 2.4\n-----------\n(codename Correlation, released on April 13th 2010)\n\n- the environment template loading functions now transparently\n  pass through a template object if it was passed to it.  This\n  makes it possible to import or extend from a template object\n  that was passed to the template.\n- added a :class:`ModuleLoader` that can load templates from\n  precompiled sources.  The environment now features a method\n  to compile the templates from a configured loader into a zip\n  file or folder.\n- the _speedups C extension now supports Python 3.\n- added support for autoescaping toggling sections and support\n  for evaluation contexts (:ref:`eval-context`).\n- extensions have a priority now.\n\nVersion 2.3.1\n-------------\n(bugfix release, released on February 19th 2010)\n\n- fixed an error reporting bug on all python versions\n- fixed an error reporting bug on Python 2.4\n\nVersion 2.3\n-----------\n(3000 Pythons, released on February 10th 2010)\n\n- fixes issue with code generator that causes unbound variables\n  to be generated if set was used in if-blocks and other small\n  identifier problems.\n- include tags are now able to select between multiple templates\n  and take the first that exists, if a list of templates is\n  given.\n- fixed a problem with having call blocks in outer scopes that\n  have an argument that is also used as local variable in an\n  inner frame (#360).\n- greatly improved error message reporting (#339)\n- implicit tuple expressions can no longer be totally empty.\n  This change makes ``{% if %}...{% endif %}`` a syntax error\n  now. (#364)\n- added support for translator comments if extracted via babel.\n- added with-statement extension.\n- experimental Python 3 support.\n\nVersion 2.2.1\n-------------\n(bugfix release, released on September 14th 2009)\n\n- fixes some smaller problems for Jinja2 on Jython.\n\nVersion 2.2\n-----------\n(codename Kong, released on September 13th 2009)\n\n- Include statements can now be marked with ``ignore missing`` to skip\n  non existing templates.\n- Priority of `not` raised.  It's now possible to write `not foo in bar`\n  as an alias to `foo not in bar` like in python.  Previously the grammar\n  required parentheses (`not (foo in bar)`) which was odd.\n- Fixed a bug that caused syntax errors when defining macros or using the\n  `{% call %}` tag inside loops.\n- Fixed a bug in the parser that made ``{{ foo[1, 2] }}`` impossible.\n- Made it possible to refer to names from outer scopes in included templates\n  that were unused in the callers frame (#327)\n- Fixed a bug that caused internal errors if names where used as iteration\n  variable and regular variable *after* the loop if that variable was unused\n  *before* the loop.  (#331)\n- Added support for optional `scoped` modifier to blocks.\n- Added support for line-comments.\n- Added the `meta` module.\n- Renamed (undocumented) attribute \"overlay\" to \"overlayed\" on the\n  environment because it was clashing with a method of the same name.\n- speedup extension is now disabled by default.\n\nVersion 2.1.1\n-------------\n(Bugfix release)\n\n- Fixed a translation error caused by looping over empty recursive loops.\n\nVersion 2.1\n-----------\n(codename Yasuz\u014d, released on November 23rd 2008)\n\n- fixed a bug with nested loops and the special loop variable.  Before the\n  change an inner loop overwrote the loop variable from the outer one after\n  iteration.\n\n- fixed a bug with the i18n extension that caused the explicit pluralization\n  block to look up the wrong variable.\n\n- fixed a limitation in the lexer that made ``{{ foo.0.0 }}`` impossible.\n\n- index based subscribing of variables with a constant value returns an\n  undefined object now instead of raising an index error.  This was a bug\n  caused by eager optimizing.\n\n- the i18n extension looks up `foo.ugettext` now followed by `foo.gettext`\n  if an translations object is installed.  This makes dealing with custom\n  translations classes easier.\n\n- fixed a confusing behavior with conditional extending.  loops were partially\n  executed under some conditions even though they were not part of a visible\n  area.\n\n- added `sort` filter that works like `dictsort` but for arbitrary sequences.\n\n- fixed a bug with empty statements in macros.\n\n- implemented a bytecode cache system.  (:ref:`bytecode-cache`)\n\n- the template context is now weakref-able\n\n- inclusions and imports \"with context\" forward all variables now, not only\n  the initial context.\n\n- added a cycle helper called `cycler`.\n\n- added a joining helper called `joiner`.\n\n- added a `compile_expression` method to the environment that allows compiling\n  of Jinja expressions into callable Python objects.\n\n- fixed an escaping bug in urlize\n\nVersion 2.0\n-----------\n(codename jinjavitus, released on July 17th 2008)\n\n- the subscribing of objects (looking up attributes and items) changed from\n  slightly.  It's now possible to give attributes or items a higher priority\n  by either using dot-notation lookup or the bracket syntax.  This also\n  changed the AST slightly.  `Subscript` is gone and was replaced with\n  :class:`~jinja2.nodes.Getitem` and :class:`~jinja2.nodes.Getattr`.\n\n  For more information see :ref:`the implementation details <notes-on-subscriptions>`.\n\n- added support for preprocessing and token stream filtering for extensions.\n  This would allow extensions to allow simplified gettext calls in template\n  data and something similar.\n\n- added :meth:`jinja2.environment.TemplateStream.dump`.\n\n- added missing support for implicit string literal concatenation.\n  ``{{ \"foo\" \"bar\" }}`` is equivalent to ``{{ \"foobar\" }}``\n\n- `else` is optional for conditional expressions.  If not given it evaluates\n  to `false`.\n\n- improved error reporting for undefined values by providing a position.\n\n- `filesizeformat` filter uses decimal prefixes now per default and can be\n  set to binary mode with the second parameter.\n\n- fixed bug in finalizer\n\nVersion 2.0rc1\n--------------\n(no codename, released on June 9th 2008)\n\n- first release of Jinja2\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.bccache\n    ~~~~~~~~~~~~~~\n\n    This module implements the bytecode cache system Jinja is optionally\n    using.  This is useful if you have very complex template situations and\n    the compiliation of all those templates slow down your application too\n    much.\n\n    Situations where this is useful are often forking web applications that\n    are initialized on the first request.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD.\n\"\"\"\nfrom os import path, listdir\nimport sys\nimport marshal\nimport tempfile\nimport fnmatch\nfrom hashlib import sha1\nfrom jinja2.utils import open_if_exists\nfrom jinja2._compat import BytesIO, pickle, PY2, text_type\n\n\n# marshal works better on 3.x, one hack less required\nif not PY2:\n    marshal_dump = marshal.dump\n    marshal_load = marshal.load\nelse:\n\n    def marshal_dump(code, f):\n        if isinstance(f, file):\n            marshal.dump(code, f)\n        else:\n            f.write(marshal.dumps(code))\n\n    def marshal_load(f):\n        if isinstance(f, file):\n            return marshal.load(f)\n        return marshal.loads(f.read())\n\n\nbc_version = 2\n\n# magic version used to only change with new jinja versions.  With 2.6\n# we change this to also take Python version changes into account.  The\n# reason for this is that Python tends to segfault if fed earlier bytecode\n# versions because someone thought it would be a good idea to reuse opcodes\n# or make Python incompatible with earlier versions.\nbc_magic = 'j2'.encode('ascii') + \\\n    pickle.dumps(bc_version, 2) + \\\n    pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1])\n\n\nclass Bucket(object):\n    \"\"\"Buckets are used to store the bytecode for one template.  It's created\n    and initialized by the bytecode cache and passed to the loading functions.\n\n    The buckets get an internal checksum from the cache assigned and use this\n    to automatically reject outdated cache material.  Individual bytecode\n    cache subclasses don't have to care about cache invalidation.\n    \"\"\"\n\n    def __init__(self, environment, key, checksum):\n        self.environment = environment\n        self.key = key\n        self.checksum = checksum\n        self.reset()\n\n    def reset(self):\n        \"\"\"Resets the bucket (unloads the bytecode).\"\"\"\n        self.code = None\n\n    def load_bytecode(self, f):\n        \"\"\"Loads bytecode from a file or file like object.\"\"\"\n        # make sure the magic header is correct\n        magic = f.read(len(bc_magic))\n        if magic != bc_magic:\n            self.reset()\n            return\n        # the source code of the file changed, we need to reload\n        checksum = pickle.load(f)\n        if self.checksum != checksum:\n            self.reset()\n            return\n        self.code = marshal_load(f)\n\n    def write_bytecode(self, f):\n        \"\"\"Dump the bytecode into the file or file like object passed.\"\"\"\n        if self.code is None:\n            raise TypeError('can\\'t write empty bucket')\n        f.write(bc_magic)\n        pickle.dump(self.checksum, f, 2)\n        marshal_dump(self.code, f)\n\n    def bytecode_from_string(self, string):\n        \"\"\"Load bytecode from a string.\"\"\"\n        self.load_bytecode(BytesIO(string))\n\n    def bytecode_to_string(self):\n        \"\"\"Return the bytecode as string.\"\"\"\n        out = BytesIO()\n        self.write_bytecode(out)\n        return out.getvalue()\n\n\nclass BytecodeCache(object):\n    \"\"\"To implement your own bytecode cache you have to subclass this class\n    and override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of\n    these methods are passed a :class:`~jinja2.bccache.Bucket`.\n\n    A very basic bytecode cache that saves the bytecode on the file system::\n\n        from os import path\n\n        class MyCache(BytecodeCache):\n\n            def __init__(self, directory):\n                self.directory = directory\n\n            def load_bytecode(self, bucket):\n                filename = path.join(self.directory, bucket.key)\n                if path.exists(filename):\n                    with open(filename, 'rb') as f:\n                        bucket.load_bytecode(f)\n\n            def dump_bytecode(self, bucket):\n                filename = path.join(self.directory, bucket.key)\n                with open(filename, 'wb') as f:\n                    bucket.write_bytecode(f)\n\n    A more advanced version of a filesystem based bytecode cache is part of\n    Jinja2.\n    \"\"\"\n\n    def load_bytecode(self, bucket):\n        \"\"\"Subclasses have to override this method to load bytecode into a\n        bucket.  If they are not able to find code in the cache for the\n        bucket, it must not do anything.\n        \"\"\"\n        raise NotImplementedError()\n\n    def dump_bytecode(self, bucket):\n        \"\"\"Subclasses have to override this method to write the bytecode\n        from a bucket back to the cache.  If it unable to do so it must not\n        fail silently but raise an exception.\n        \"\"\"\n        raise NotImplementedError()\n\n    def clear(self):\n        \"\"\"Clears the cache.  This method is not used by Jinja2 but should be\n        implemented to allow applications to clear the bytecode cache used\n        by a particular environment.\n        \"\"\"\n\n    def get_cache_key(self, name, filename=None):\n        \"\"\"Returns the unique hash key for this template name.\"\"\"\n        hash = sha1(name.encode('utf-8'))\n        if filename is not None:\n            filename = '|' + filename\n            if isinstance(filename, text_type):\n                filename = filename.encode('utf-8')\n            hash.update(filename)\n        return hash.hexdigest()\n\n    def get_source_checksum(self, source):\n        \"\"\"Returns a checksum for the source.\"\"\"\n        return sha1(source.encode('utf-8')).hexdigest()\n\n    def get_bucket(self, environment, name, filename, source):\n        \"\"\"Return a cache bucket for the given template.  All arguments are\n        mandatory but filename may be `None`.\n        \"\"\"\n        key = self.get_cache_key(name, filename)\n        checksum = self.get_source_checksum(source)\n        bucket = Bucket(environment, key, checksum)\n        self.load_bytecode(bucket)\n        return bucket\n\n    def set_bucket(self, bucket):\n        \"\"\"Put the bucket into the cache.\"\"\"\n        self.dump_bytecode(bucket)\n\n\nclass FileSystemBytecodeCache(BytecodeCache):\n    \"\"\"A bytecode cache that stores bytecode on the filesystem.  It accepts\n    two arguments: The directory where the cache items are stored and a\n    pattern string that is used to build the filename.\n\n    If no directory is specified the system temporary items folder is used.\n\n    The pattern can be used to have multiple separate caches operate on the\n    same directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``\n    is replaced with the cache key.\n\n    >>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')\n\n    This bytecode cache supports clearing of the cache using the clear method.\n    \"\"\"\n\n    def __init__(self, directory=None, pattern='__jinja2_%s.cache'):\n        if directory is None:\n            directory = tempfile.gettempdir()\n        self.directory = directory\n        self.pattern = pattern\n\n    def _get_cache_filename(self, bucket):\n        return path.join(self.directory, self.pattern % bucket.key)\n\n    def load_bytecode(self, bucket):\n        f = open_if_exists(self._get_cache_filename(bucket), 'rb')\n        if f is not None:\n            try:\n                bucket.load_bytecode(f)\n            finally:\n                f.close()\n\n    def dump_bytecode(self, bucket):\n        f = open(self._get_cache_filename(bucket), 'wb')\n        try:\n            bucket.write_bytecode(f)\n        finally:\n            f.close()\n\n    def clear(self):\n        # imported lazily here because google app-engine doesn't support\n        # write access on the file system and the function does not exist\n        # normally.\n        from os import remove\n        files = fnmatch.filter(listdir(self.directory), self.pattern % '*')\n        for filename in files:\n            try:\n                remove(path.join(self.directory, filename))\n            except OSError:\n                pass\n\n\nclass MemcachedBytecodeCache(BytecodeCache):\n    \"\"\"This class implements a bytecode cache that uses a memcache cache for\n    storing the information.  It does not enforce a specific memcache library\n    (tummy's memcache or cmemcache) but will accept any class that provides\n    the minimal interface required.\n\n    Libraries compatible with this class:\n\n    -   `werkzeug <http://werkzeug.pocoo.org/>`_.contrib.cache\n    -   `python-memcached <http://www.tummy.com/Community/software/python-memcached/>`_\n    -   `cmemcache <http://gijsbert.org/cmemcache/>`_\n\n    (Unfortunately the django cache interface is not compatible because it\n    does not support storing binary data, only unicode.  You can however pass\n    the underlying cache client to the bytecode cache which is available\n    as `django.core.cache.cache._client`.)\n\n    The minimal interface for the client passed to the constructor is this:\n\n    .. class:: MinimalClientInterface\n\n        .. method:: set(key, value[, timeout])\n\n            Stores the bytecode in the cache.  `value` is a string and\n            `timeout` the timeout of the key.  If timeout is not provided\n            a default timeout or no timeout should be assumed, if it's\n            provided it's an integer with the number of seconds the cache\n            item should exist.\n\n        .. method:: get(key)\n\n            Returns the value for the cache key.  If the item does not\n            exist in the cache the return value must be `None`.\n\n    The other arguments to the constructor are the prefix for all keys that\n    is added before the actual cache key and the timeout for the bytecode in\n    the cache system.  We recommend a high (or no) timeout.\n\n    This bytecode cache does not support clearing of used items in the cache.\n    The clear method is a no-operation function.\n\n    .. versionadded:: 2.7\n       Added support for ignoring memcache errors through the\n       `ignore_memcache_errors` parameter.\n    \"\"\"\n\n    def __init__(self, client, prefix='jinja2/bytecode/', timeout=None,\n                 ignore_memcache_errors=True):\n        self.client = client\n        self.prefix = prefix\n        self.timeout = timeout\n        self.ignore_memcache_errors = ignore_memcache_errors\n\n    def load_bytecode(self, bucket):\n        try:\n            code = self.client.get(self.prefix + bucket.key)\n        except Exception:\n            if not self.ignore_memcache_errors:\n                raise\n            code = None\n        if code is not None:\n            bucket.bytecode_from_string(code)\n\n    def dump_bytecode(self, bucket):\n        args = (self.prefix + bucket.key, bucket.bytecode_to_string())\n        if self.timeout is not None:\n            args += (self.timeout,)\n        try:\n            self.client.set(*args)\n        except Exception:\n            if not self.ignore_memcache_errors:\n                raise\n"], "fixing_code": ["Jinja2 Changelog\n================\n\nVersion 2.7.2\n-------------\n(bugfix release, release date to be decided)\n\n- Prefix loader was not forwarding the locals properly to\n  inner loaders.  This is now fixed.\n- Security issue: Changed the default folder for the filesystem cache to be\n  user specific and read and write protected on UNIX systems.  See `Debian bug\n  734747`_ for more information.\n\n.. _Debian bug 734747: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=734747\n\nVersion 2.7.1\n-------------\n(bugfix release, released on August 7th 2013)\n\n- Fixed a bug with ``call_filter`` not working properly on environment\n  and context filters.\n- Fixed lack of Python 3 support for bytecode caches.\n- Reverted support for defining blocks in included templates as this\n  broke existing templates for users.\n- Fixed some warnings with hashing of undefineds and nodes if Python\n  is run with warnings for Python 3.\n- Added support for properly hashing undefined objects.\n- Fixed a bug with the title filter not working on already uppercase\n  strings.\n\nVersion 2.7\n-----------\n(codename Translation, released on May 20th 2013)\n\n- Choice and prefix loaders now dispatch source and template lookup\n  separately in order to work in combination with module loaders as\n  advertised.\n- Fixed filesizeformat.\n- Added a non-silent option for babel extraction.\n- Added `urlencode` filter that automatically quotes values for\n  URL safe usage with utf-8 as only supported encoding.  If applications\n  want to change this encoding they can override the filter.\n- Added `keep-trailing-newline` configuration to environments and\n  templates to optionally preserve the final trailing newline.\n- Accessing `last` on the loop context no longer causes the iterator\n  to be consumed into a list.\n- Python requirement changed: 2.6, 2.7 or >= 3.3 are required now,\n  supported by same source code, using the \"six\" compatibility library.\n- Allow `contextfunction` and other decorators to be applied to `__call__`.\n- Added support for changing from newline to different signs in the `wordwrap`\n  filter.\n- Added support for ignoring memcache errors silently.\n- Added support for keeping the trailing newline in templates.\n- Added finer grained support for stripping whitespace on the left side\n  of blocks.\n- Added `map`, `select`, `reject`, `selectattr` and `rejectattr`\n  filters.\n- Added support for `loop.depth` to figure out how deep inside a recursive\n  loop the code is.\n- Disabled py_compile for pypy and python 3.\n\nVersion 2.6\n-----------\n(codename Convolution, released on July 24th 2011)\n\n- internal attributes now raise an internal attribute error now instead\n  of returning an undefined.  This fixes problems when passing undefined\n  objects to Python semantics expecting APIs.\n- traceback support now works properly for PyPy.  (Tested with 1.4)\n- implemented operator intercepting for sandboxed environments.  This\n  allows application developers to disable builtin operators for better\n  security.  (For instance limit the mathematical operators to actual\n  integers instead of longs)\n- groupby filter now supports dotted notation for grouping by attributes\n  of attributes.\n- scoped blocks now properly treat toplevel assignments and imports.\n  Previously an import suddenly \"disappeared\" in a scoped block.\n- automatically detect newer Python interpreter versions before loading code\n  from bytecode caches to prevent segfaults on invalid opcodes.  The segfault\n  in earlier Jinja2 versions here was not a Jinja2 bug but a limitation in\n  the underlying Python interpreter.  If you notice Jinja2 segfaulting in\n  earlier versions after an upgrade of the Python interpreter you don't have\n  to upgrade, it's enough to flush the bytecode cache.  This just no longer\n  makes this necessary, Jinja2 will automatically detect these cases now.\n- the sum filter can now sum up values by attribute.  This is a backwards\n  incompatible change.  The argument to the filter previously was the\n  optional starting index which defaultes to zero.  This now became the\n  second argument to the function because it's rarely used.\n- like sum, sort now also makes it possible to order items by attribute.\n- like sum and sort, join now also is able to join attributes of objects\n  as string.\n- the internal eval context now has a reference to the environment.\n- added a mapping test to see if an object is a dict or an object with\n  a similar interface.\n\nVersion 2.5.5\n-------------\n(re-release of 2.5.4 with built documentation removed for filesize.\n Released on October 18th 2010)\n\n- built documentation is no longer part of release.\n\nVersion 2.5.4\n-------------\n(bugfix release, released on October 17th 2010)\n\n- Fixed extensions not loading properly with overlays.\n- Work around a bug in cpython for the debugger that causes segfaults\n  on 64bit big-endian architectures.\n\nVersion 2.5.3\n-------------\n(bugfix release, released on October 17th 2010)\n\n- fixed an operator precedence error introduced in 2.5.2.  Statements\n  like \"-foo.bar\" had their implicit parentheses applied around the\n  first part of the expression (\"(-foo).bar\") instead of the more\n  correct \"-(foo.bar)\".\n\nVersion 2.5.2\n-------------\n(bugfix release, released on August 18th 2010)\n\n- improved setup.py script to better work with assumptions people\n  might still have from it (``--with-speedups``).\n- fixed a packaging error that excluded the new debug support.\n\nVersion 2.5.1\n-------------\n(bugfix release, released on August 17th 2010)\n\n- StopIteration exceptions raised by functions called from templates\n  are now intercepted and converted to undefineds.  This solves a\n  lot of debugging grief.  (StopIteration is used internally to\n  abort template execution)\n- improved performance of macro calls slightly.\n- babel extraction can now properly extract newstyle gettext calls.\n- using the variable `num` in newstyle gettext for something else\n  than the pluralize count will no longer raise a :exc:`KeyError`.\n- removed builtin markup class and switched to markupsafe.  For backwards\n  compatibility the pure Python implementation still exists but is\n  pulled from markupsafe by the Jinja2 developers.  The debug support\n  went into a separate feature called \"debugsupport\" and is disabled\n  by default because it is only relevant for Python 2.4\n- fixed an issue with unary operators having the wrong precendence.\n\nVersion 2.5\n-----------\n(codename Incoherence, relased on May 29th 2010)\n\n- improved the sort filter (should have worked like this for a\n  long time) by adding support for case insensitive searches.\n- fixed a bug for getattribute constant folding.\n- support for newstyle gettext translations which result in a\n  nicer in-template user interface and more consistent\n  catalogs. (:ref:`newstyle-gettext`)\n- it's now possible to register extensions after an environment\n  was created.\n\nVersion 2.4.1\n-------------\n(bugfix release, released on April 20th 2010)\n\n- fixed an error reporting bug for undefineds.\n\nVersion 2.4\n-----------\n(codename Correlation, released on April 13th 2010)\n\n- the environment template loading functions now transparently\n  pass through a template object if it was passed to it.  This\n  makes it possible to import or extend from a template object\n  that was passed to the template.\n- added a :class:`ModuleLoader` that can load templates from\n  precompiled sources.  The environment now features a method\n  to compile the templates from a configured loader into a zip\n  file or folder.\n- the _speedups C extension now supports Python 3.\n- added support for autoescaping toggling sections and support\n  for evaluation contexts (:ref:`eval-context`).\n- extensions have a priority now.\n\nVersion 2.3.1\n-------------\n(bugfix release, released on February 19th 2010)\n\n- fixed an error reporting bug on all python versions\n- fixed an error reporting bug on Python 2.4\n\nVersion 2.3\n-----------\n(3000 Pythons, released on February 10th 2010)\n\n- fixes issue with code generator that causes unbound variables\n  to be generated if set was used in if-blocks and other small\n  identifier problems.\n- include tags are now able to select between multiple templates\n  and take the first that exists, if a list of templates is\n  given.\n- fixed a problem with having call blocks in outer scopes that\n  have an argument that is also used as local variable in an\n  inner frame (#360).\n- greatly improved error message reporting (#339)\n- implicit tuple expressions can no longer be totally empty.\n  This change makes ``{% if %}...{% endif %}`` a syntax error\n  now. (#364)\n- added support for translator comments if extracted via babel.\n- added with-statement extension.\n- experimental Python 3 support.\n\nVersion 2.2.1\n-------------\n(bugfix release, released on September 14th 2009)\n\n- fixes some smaller problems for Jinja2 on Jython.\n\nVersion 2.2\n-----------\n(codename Kong, released on September 13th 2009)\n\n- Include statements can now be marked with ``ignore missing`` to skip\n  non existing templates.\n- Priority of `not` raised.  It's now possible to write `not foo in bar`\n  as an alias to `foo not in bar` like in python.  Previously the grammar\n  required parentheses (`not (foo in bar)`) which was odd.\n- Fixed a bug that caused syntax errors when defining macros or using the\n  `{% call %}` tag inside loops.\n- Fixed a bug in the parser that made ``{{ foo[1, 2] }}`` impossible.\n- Made it possible to refer to names from outer scopes in included templates\n  that were unused in the callers frame (#327)\n- Fixed a bug that caused internal errors if names where used as iteration\n  variable and regular variable *after* the loop if that variable was unused\n  *before* the loop.  (#331)\n- Added support for optional `scoped` modifier to blocks.\n- Added support for line-comments.\n- Added the `meta` module.\n- Renamed (undocumented) attribute \"overlay\" to \"overlayed\" on the\n  environment because it was clashing with a method of the same name.\n- speedup extension is now disabled by default.\n\nVersion 2.1.1\n-------------\n(Bugfix release)\n\n- Fixed a translation error caused by looping over empty recursive loops.\n\nVersion 2.1\n-----------\n(codename Yasuz\u014d, released on November 23rd 2008)\n\n- fixed a bug with nested loops and the special loop variable.  Before the\n  change an inner loop overwrote the loop variable from the outer one after\n  iteration.\n\n- fixed a bug with the i18n extension that caused the explicit pluralization\n  block to look up the wrong variable.\n\n- fixed a limitation in the lexer that made ``{{ foo.0.0 }}`` impossible.\n\n- index based subscribing of variables with a constant value returns an\n  undefined object now instead of raising an index error.  This was a bug\n  caused by eager optimizing.\n\n- the i18n extension looks up `foo.ugettext` now followed by `foo.gettext`\n  if an translations object is installed.  This makes dealing with custom\n  translations classes easier.\n\n- fixed a confusing behavior with conditional extending.  loops were partially\n  executed under some conditions even though they were not part of a visible\n  area.\n\n- added `sort` filter that works like `dictsort` but for arbitrary sequences.\n\n- fixed a bug with empty statements in macros.\n\n- implemented a bytecode cache system.  (:ref:`bytecode-cache`)\n\n- the template context is now weakref-able\n\n- inclusions and imports \"with context\" forward all variables now, not only\n  the initial context.\n\n- added a cycle helper called `cycler`.\n\n- added a joining helper called `joiner`.\n\n- added a `compile_expression` method to the environment that allows compiling\n  of Jinja expressions into callable Python objects.\n\n- fixed an escaping bug in urlize\n\nVersion 2.0\n-----------\n(codename jinjavitus, released on July 17th 2008)\n\n- the subscribing of objects (looking up attributes and items) changed from\n  slightly.  It's now possible to give attributes or items a higher priority\n  by either using dot-notation lookup or the bracket syntax.  This also\n  changed the AST slightly.  `Subscript` is gone and was replaced with\n  :class:`~jinja2.nodes.Getitem` and :class:`~jinja2.nodes.Getattr`.\n\n  For more information see :ref:`the implementation details <notes-on-subscriptions>`.\n\n- added support for preprocessing and token stream filtering for extensions.\n  This would allow extensions to allow simplified gettext calls in template\n  data and something similar.\n\n- added :meth:`jinja2.environment.TemplateStream.dump`.\n\n- added missing support for implicit string literal concatenation.\n  ``{{ \"foo\" \"bar\" }}`` is equivalent to ``{{ \"foobar\" }}``\n\n- `else` is optional for conditional expressions.  If not given it evaluates\n  to `false`.\n\n- improved error reporting for undefined values by providing a position.\n\n- `filesizeformat` filter uses decimal prefixes now per default and can be\n  set to binary mode with the second parameter.\n\n- fixed bug in finalizer\n\nVersion 2.0rc1\n--------------\n(no codename, released on June 9th 2008)\n\n- first release of Jinja2\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    jinja2.bccache\n    ~~~~~~~~~~~~~~\n\n    This module implements the bytecode cache system Jinja is optionally\n    using.  This is useful if you have very complex template situations and\n    the compiliation of all those templates slow down your application too\n    much.\n\n    Situations where this is useful are often forking web applications that\n    are initialized on the first request.\n\n    :copyright: (c) 2010 by the Jinja Team.\n    :license: BSD.\n\"\"\"\nfrom os import path, listdir\nimport os\nimport sys\nimport errno\nimport marshal\nimport tempfile\nimport fnmatch\nfrom hashlib import sha1\nfrom jinja2.utils import open_if_exists\nfrom jinja2._compat import BytesIO, pickle, PY2, text_type\n\n\n# marshal works better on 3.x, one hack less required\nif not PY2:\n    marshal_dump = marshal.dump\n    marshal_load = marshal.load\nelse:\n\n    def marshal_dump(code, f):\n        if isinstance(f, file):\n            marshal.dump(code, f)\n        else:\n            f.write(marshal.dumps(code))\n\n    def marshal_load(f):\n        if isinstance(f, file):\n            return marshal.load(f)\n        return marshal.loads(f.read())\n\n\nbc_version = 2\n\n# magic version used to only change with new jinja versions.  With 2.6\n# we change this to also take Python version changes into account.  The\n# reason for this is that Python tends to segfault if fed earlier bytecode\n# versions because someone thought it would be a good idea to reuse opcodes\n# or make Python incompatible with earlier versions.\nbc_magic = 'j2'.encode('ascii') + \\\n    pickle.dumps(bc_version, 2) + \\\n    pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1])\n\n\nclass Bucket(object):\n    \"\"\"Buckets are used to store the bytecode for one template.  It's created\n    and initialized by the bytecode cache and passed to the loading functions.\n\n    The buckets get an internal checksum from the cache assigned and use this\n    to automatically reject outdated cache material.  Individual bytecode\n    cache subclasses don't have to care about cache invalidation.\n    \"\"\"\n\n    def __init__(self, environment, key, checksum):\n        self.environment = environment\n        self.key = key\n        self.checksum = checksum\n        self.reset()\n\n    def reset(self):\n        \"\"\"Resets the bucket (unloads the bytecode).\"\"\"\n        self.code = None\n\n    def load_bytecode(self, f):\n        \"\"\"Loads bytecode from a file or file like object.\"\"\"\n        # make sure the magic header is correct\n        magic = f.read(len(bc_magic))\n        if magic != bc_magic:\n            self.reset()\n            return\n        # the source code of the file changed, we need to reload\n        checksum = pickle.load(f)\n        if self.checksum != checksum:\n            self.reset()\n            return\n        self.code = marshal_load(f)\n\n    def write_bytecode(self, f):\n        \"\"\"Dump the bytecode into the file or file like object passed.\"\"\"\n        if self.code is None:\n            raise TypeError('can\\'t write empty bucket')\n        f.write(bc_magic)\n        pickle.dump(self.checksum, f, 2)\n        marshal_dump(self.code, f)\n\n    def bytecode_from_string(self, string):\n        \"\"\"Load bytecode from a string.\"\"\"\n        self.load_bytecode(BytesIO(string))\n\n    def bytecode_to_string(self):\n        \"\"\"Return the bytecode as string.\"\"\"\n        out = BytesIO()\n        self.write_bytecode(out)\n        return out.getvalue()\n\n\nclass BytecodeCache(object):\n    \"\"\"To implement your own bytecode cache you have to subclass this class\n    and override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of\n    these methods are passed a :class:`~jinja2.bccache.Bucket`.\n\n    A very basic bytecode cache that saves the bytecode on the file system::\n\n        from os import path\n\n        class MyCache(BytecodeCache):\n\n            def __init__(self, directory):\n                self.directory = directory\n\n            def load_bytecode(self, bucket):\n                filename = path.join(self.directory, bucket.key)\n                if path.exists(filename):\n                    with open(filename, 'rb') as f:\n                        bucket.load_bytecode(f)\n\n            def dump_bytecode(self, bucket):\n                filename = path.join(self.directory, bucket.key)\n                with open(filename, 'wb') as f:\n                    bucket.write_bytecode(f)\n\n    A more advanced version of a filesystem based bytecode cache is part of\n    Jinja2.\n    \"\"\"\n\n    def load_bytecode(self, bucket):\n        \"\"\"Subclasses have to override this method to load bytecode into a\n        bucket.  If they are not able to find code in the cache for the\n        bucket, it must not do anything.\n        \"\"\"\n        raise NotImplementedError()\n\n    def dump_bytecode(self, bucket):\n        \"\"\"Subclasses have to override this method to write the bytecode\n        from a bucket back to the cache.  If it unable to do so it must not\n        fail silently but raise an exception.\n        \"\"\"\n        raise NotImplementedError()\n\n    def clear(self):\n        \"\"\"Clears the cache.  This method is not used by Jinja2 but should be\n        implemented to allow applications to clear the bytecode cache used\n        by a particular environment.\n        \"\"\"\n\n    def get_cache_key(self, name, filename=None):\n        \"\"\"Returns the unique hash key for this template name.\"\"\"\n        hash = sha1(name.encode('utf-8'))\n        if filename is not None:\n            filename = '|' + filename\n            if isinstance(filename, text_type):\n                filename = filename.encode('utf-8')\n            hash.update(filename)\n        return hash.hexdigest()\n\n    def get_source_checksum(self, source):\n        \"\"\"Returns a checksum for the source.\"\"\"\n        return sha1(source.encode('utf-8')).hexdigest()\n\n    def get_bucket(self, environment, name, filename, source):\n        \"\"\"Return a cache bucket for the given template.  All arguments are\n        mandatory but filename may be `None`.\n        \"\"\"\n        key = self.get_cache_key(name, filename)\n        checksum = self.get_source_checksum(source)\n        bucket = Bucket(environment, key, checksum)\n        self.load_bytecode(bucket)\n        return bucket\n\n    def set_bucket(self, bucket):\n        \"\"\"Put the bucket into the cache.\"\"\"\n        self.dump_bytecode(bucket)\n\n\nclass FileSystemBytecodeCache(BytecodeCache):\n    \"\"\"A bytecode cache that stores bytecode on the filesystem.  It accepts\n    two arguments: The directory where the cache items are stored and a\n    pattern string that is used to build the filename.\n\n    If no directory is specified a default cache directory is selected.  On\n    Windows the user's temp directory is used, on UNIX systems a directory\n    is created for the user in the system temp directory.\n\n    The pattern can be used to have multiple separate caches operate on the\n    same directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``\n    is replaced with the cache key.\n\n    >>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')\n\n    This bytecode cache supports clearing of the cache using the clear method.\n    \"\"\"\n\n    def __init__(self, directory=None, pattern='__jinja2_%s.cache'):\n        if directory is None:\n            directory = self._get_default_cache_dir()\n        self.directory = directory\n        self.pattern = pattern\n\n    def _get_default_cache_dir(self):\n        tmpdir = tempfile.gettempdir()\n\n        # On windows the temporary directory is used specific unless\n        # explicitly forced otherwise.  We can just use that.\n        if os.name == 'n':\n            return tmpdir\n        if not hasattr(os, 'getuid'):\n            raise RuntimeError('Cannot determine safe temp directory.  You '\n                               'need to explicitly provide one.')\n\n        dirname = '_jinja2-cache-%d' % os.getuid()\n        actual_dir = os.path.join(tmpdir, dirname)\n        try:\n            os.mkdir(actual_dir, 0700)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        return actual_dir\n\n    def _get_cache_filename(self, bucket):\n        return path.join(self.directory, self.pattern % bucket.key)\n\n    def load_bytecode(self, bucket):\n        f = open_if_exists(self._get_cache_filename(bucket), 'rb')\n        if f is not None:\n            try:\n                bucket.load_bytecode(f)\n            finally:\n                f.close()\n\n    def dump_bytecode(self, bucket):\n        f = open(self._get_cache_filename(bucket), 'wb')\n        try:\n            bucket.write_bytecode(f)\n        finally:\n            f.close()\n\n    def clear(self):\n        # imported lazily here because google app-engine doesn't support\n        # write access on the file system and the function does not exist\n        # normally.\n        from os import remove\n        files = fnmatch.filter(listdir(self.directory), self.pattern % '*')\n        for filename in files:\n            try:\n                remove(path.join(self.directory, filename))\n            except OSError:\n                pass\n\n\nclass MemcachedBytecodeCache(BytecodeCache):\n    \"\"\"This class implements a bytecode cache that uses a memcache cache for\n    storing the information.  It does not enforce a specific memcache library\n    (tummy's memcache or cmemcache) but will accept any class that provides\n    the minimal interface required.\n\n    Libraries compatible with this class:\n\n    -   `werkzeug <http://werkzeug.pocoo.org/>`_.contrib.cache\n    -   `python-memcached <http://www.tummy.com/Community/software/python-memcached/>`_\n    -   `cmemcache <http://gijsbert.org/cmemcache/>`_\n\n    (Unfortunately the django cache interface is not compatible because it\n    does not support storing binary data, only unicode.  You can however pass\n    the underlying cache client to the bytecode cache which is available\n    as `django.core.cache.cache._client`.)\n\n    The minimal interface for the client passed to the constructor is this:\n\n    .. class:: MinimalClientInterface\n\n        .. method:: set(key, value[, timeout])\n\n            Stores the bytecode in the cache.  `value` is a string and\n            `timeout` the timeout of the key.  If timeout is not provided\n            a default timeout or no timeout should be assumed, if it's\n            provided it's an integer with the number of seconds the cache\n            item should exist.\n\n        .. method:: get(key)\n\n            Returns the value for the cache key.  If the item does not\n            exist in the cache the return value must be `None`.\n\n    The other arguments to the constructor are the prefix for all keys that\n    is added before the actual cache key and the timeout for the bytecode in\n    the cache system.  We recommend a high (or no) timeout.\n\n    This bytecode cache does not support clearing of used items in the cache.\n    The clear method is a no-operation function.\n\n    .. versionadded:: 2.7\n       Added support for ignoring memcache errors through the\n       `ignore_memcache_errors` parameter.\n    \"\"\"\n\n    def __init__(self, client, prefix='jinja2/bytecode/', timeout=None,\n                 ignore_memcache_errors=True):\n        self.client = client\n        self.prefix = prefix\n        self.timeout = timeout\n        self.ignore_memcache_errors = ignore_memcache_errors\n\n    def load_bytecode(self, bucket):\n        try:\n            code = self.client.get(self.prefix + bucket.key)\n        except Exception:\n            if not self.ignore_memcache_errors:\n                raise\n            code = None\n        if code is not None:\n            bucket.bytecode_from_string(code)\n\n    def dump_bytecode(self, bucket):\n        args = (self.prefix + bucket.key, bucket.bytecode_to_string())\n        if self.timeout is not None:\n            args += (self.timeout,)\n        try:\n            self.client.set(*args)\n        except Exception:\n            if not self.ignore_memcache_errors:\n                raise\n"], "filenames": ["CHANGES", "jinja2/bccache.py"], "buggy_code_start_loc": [9, 17], "buggy_code_end_loc": [9, 207], "fixing_code_start_loc": [10, 18], "fixing_code_end_loc": [15, 233], "type": "CWE-264", "message": "FileSystemBytecodeCache in Jinja2 2.7.2 does not properly create temporary directories, which allows local users to gain privileges by pre-creating a temporary directory with a user's uid. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-1402.", "other": {"cve": {"id": "CVE-2014-0012", "sourceIdentifier": "secalert@redhat.com", "published": "2014-05-19T14:55:10.330", "lastModified": "2023-02-13T00:29:48.200", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FileSystemBytecodeCache in Jinja2 2.7.2 does not properly create temporary directories, which allows local users to gain privileges by pre-creating a temporary directory with a user's uid. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-1402."}, {"lang": "es", "value": "FileSystemBytecodeCache en Jinja2 2.7.2 no crea debidamente directorios temporales, lo que permite a usuarios locales ganar privilegios mediante la previa creaci\u00f3n de un directorio temporal con el identificador de un usuario. NOTA: esta vulnerabilidad existe debido a una soluci\u00f3n incompleta para CVE-2014-1402."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pocoo:jinja2:2.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "2E22D331-9917-4E29-9FDD-4907337D7948"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2014/q1/73", "source": "secalert@redhat.com"}, {"url": "http://www.gentoo.org/security/en/glsa/glsa-201408-13.xml", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1051421", "source": "secalert@redhat.com"}, {"url": "https://github.com/mitsuhiko/jinja2/commit/acb672b6a179567632e032f547582f30fa2f4aa7", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/mitsuhiko/jinja2/pull/292", "source": "secalert@redhat.com"}, {"url": "https://github.com/mitsuhiko/jinja2/pull/296", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/mitsuhiko/jinja2/commit/acb672b6a179567632e032f547582f30fa2f4aa7"}}