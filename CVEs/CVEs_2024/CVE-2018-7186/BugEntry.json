{"buggy_code": ["# Leptonica Library #\n\n[![Build Status](https://travis-ci.org/DanBloomberg/leptonica.svg?branch=master)](https://travis-ci.org/DanBloomberg/leptonica)\n[![Build status](https://ci.appveyor.com/api/projects/status/vsk607rr6n4j2tmk?svg=true)](https://ci.appveyor.com/project/DanBloomberg/leptonica)\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/leptonica/badge.svg)](https://scan.coverity.com/projects/leptonica)\n\nwww.leptonica.org\n\n## The library supports many operations that are useful on ##\n\n  * Document images\n  * Natural images\n\n## Fundamental image processing and image analysis operations ##\n\n  * Rasterop (aka bitblt)\n  * Affine transforms (scaling, translation, rotation, shear) on images of arbitrary pixel depth\n  * Projective and bilinear transforms\n  * Binary and grayscale morphology, rank order filters, and convolution\n  * Seedfill and connected components\n  * Image transformations with changes in pixel depth, both at the same scale and with scale change\n  * Pixelwise masking, blending, enhancement, arithmetic ops, etc.\n\n## Ancillary utilities ##\n\n  * I/O for standard image formats (_jpg_, _png_, _tiff_, _webp_, _jp2_, _bmp_, _pnm_, _gif_, _ps_, _pdf_)\n  * Utilities to handle arrays of image-related data types (e.g., _pixa_, _boxa_, _pta_)\n  * Utilities for stacks, generic arrays, queues, heaps, lists; number and string arrays; etc.\n\n## Examples of some applications enabled and implemented ##\n\n  * Octcube-based color quantization (w/ and w/out dithering)\n  * Modified median cut color quantization (w/ and w/out dithering)\n  * Skew determination of text images\n  * Adaptive normalization and binarization\n  * Segmentation of page images with mixed text and images\n  * Location of baselines and local skew determination\n  * jbig2 unsupervised classifier\n  * Border representations of 1 bpp images and raster conversion for SVG\n  * Postscript generation (levels 1, 2 and 3) of images for device-independent output\n  * PDF generation (G4, DCT, FLATE) of images for device-independent output\n  * Connectivity-preserving thinning and thickening of 1 bpp images\n  * Image warping (captcha, stereoscopic)\n  * Image dewarping based on content (textlines)\n  * Watershed transform\n  * Greedy splitting of components into rectangles\n  * Location of largest fg or bg rectangles in 1 bpp images\n  * Search for least-cost paths on binary and grayscale images\n  * Barcode reader for 1D barcodes (very early version as of 1.55)\n\n## Implementation characteristics ##\n\n  * _Efficient_: image data is packed binary (into 32-bit words); operations on 32-bit data whenever possible\n  * _Simple_: small number of data structures; simplest implementations provided that are efficient\n  * _Consistent_: data allocated on the heap with simple ownership rules; function names usually begin with primary data structure (e.g., _pix_); simple code patterns throughout\n  * _Robust_: all ptr args checked; extensive use of accessors; exit not permitted\n  * _Tested_: thorough regression tests provided for most basic functions; valgrind tested\n  * _ANSI C_: automatically generated prototype header file\n  * _Portable_: endian-independent; builds in Linux, macOS, MinGW, Cygwin, Windows\n  * _Nearly thread-safe_: ref counting on some structs\n  * _Documentation_: large number of in-line comments; doxygen; web pages for further background\n  * _Examples_: many programs provided to test and show usage of approx. 2600 functions in the library\n\n\n## Open Source Projects that use Leptonica ##\n  * [php](http://en.wikipedia.org/wiki/PHP)  (scripting language for dynamic web pages)\n  * [tesseract](https://github.com/tesseract-ocr/tesseract/) (optical character recognition)\n  * [jbig2enc](http://www.imperialviolet.org/jbig2.html) (encodes multipage binary image documents with jbig2 compression)\n\n## Major contributors to Leptonica ##\n  * Tom Powers: Tom has supported Leptonica on Windows for many years.  He has made many contributions to code quality and documentation, including the beautiful \"unofficial documentation\" on the web site. Without his effort, Leptonica would not run today on Windows.\n  * David Bryan: David has worked for years to support Leptonica on multiple platforms. He designed many nice features in Leptonica, such as the severity-based error messaging system, and has identified and fixed countless bugs. And he has built and tested each distribution many times on cross-compilers.\n  * James Le Cuirot: James has written and supported the autotools scripts on Leptonica distributions for many years, and has helped test every distribution since 1.67.\n  * Jeff Breidenbach: Jeff has built every Debian distribution for Leptonica. He has also made many improvements to formatted image I/O, including tiff, png and pdf. He is a continuous advocate for simplification.\n  * Egor Pugin: Egor is co-maintainer of Leptonica on GitHub. He ported everything, including all the old distributions, from Google Code when it shut down. He set Leptonica up for appveyor and travis testing, and has implemented the cppan project, which simplifies building executables on Windows.\n  * J\u00fcrgen Buchm\u00fcller: J\u00fcrgen wrote text converters to modify Leptonica source code so that it generates documentation using doxygen. He also wrote tiff wrappers for memory I/O.\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n * xtractprotos.c\n *\n *   This program accepts a list of C files on the command line\n *   and outputs the C prototypes to stdout.  It uses cpp to\n *   handle the preprocessor macros, and then parses the cpp output.\n *   In leptonica, it is used to make allheaders.h (and optionally\n *   leptprotos.h, which contains just the function prototypes.)\n *   In leptonica, only the file allheaders.h is included with\n *   source files.\n *\n *   An optional 'prestring' can be prepended to each declaration.\n *   And the function prototypes can either be sent to stdout, written\n *   to a named file, or placed in-line within allheaders.h.\n *\n *   The signature is:\n *\n *     xtractprotos [-prestring=<string>] [-protos=<where>] [list of C files]\n *\n *   Without -protos, the prototypes are written to stdout.\n *   With -protos, allheaders.h is rewritten:\n *      * if you use -protos=inline, the prototypes are placed within\n *        allheaders.h.\n *      * if you use -protos=leptprotos.h, the prototypes written to\n *        the file leptprotos.h, and alltypes.h has\n *           #include \"leptprotos.h\"\n *\n *   For constructing allheaders.h, two text files are provided:\n *      allheaders_top.txt\n *      allheaders_bot.txt\n *   The former contains the leptonica version number, so it must\n *   be updated when a new version is made.\n *\n *   For simple C prototype extraction, xtractprotos has essentially\n *   the same functionality as Adam Bryant's cextract, but the latter\n *   has not been officially supported for over 15 years, has been\n *   patched numerous times, and doesn't work with sys/sysmacros.h\n *   for 64 bit architecture.\n *\n *   This is used to extract all prototypes in liblept.\n *   The function that does all the work is parseForProtos(),\n *   which takes as input the output from cpp.\n *\n *   xtractprotos can run in leptonica to do an 'ab initio' generation\n *   of allheaders.h; that is, it can make allheaders.h without\n *   leptprotos.h and with an allheaders.h file of 0 length.\n *   Of course, the usual situation is to run it with a valid allheaders.h,\n *   which includes all the function prototypes.  To avoid including\n *   all the prototypes in the input for each file, cpp runs here\n *   with -DNO_PROTOS, so the prototypes are not included -- this is\n *   much faster.\n *\n *   The xtractprotos version number, defined below, is incremented\n *   whenever a new version is made.\n *\n *   Note: this uses cpp to preprocess the input.  (The name of the cpp\n *   tempfile is constructed below.  It has a \".\" in the tail, which\n *   Cygwin needs to prevent it from appending \".exe\" to the filename.)\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  L_BUF_SIZE = 512;\nstatic const char *version = \"1.5\";\n\n\nint main(int    argc,\n         char **argv)\n{\nchar        *filein, *str, *tempfile, *prestring, *outprotos, *protostr;\nconst char  *spacestr = \" \";\nchar         buf[L_BUF_SIZE];\nl_uint8     *allheaders;\nl_int32      i, maxindex, in_line, nflags, protos_added, firstfile, len, ret;\nsize_t       nbytes;\nL_BYTEA     *ba, *ba2;\nSARRAY      *sa, *safirst;\nstatic char  mainName[] = \"xtractprotos\";\n\n    if (argc == 1) {\n        fprintf(stderr,\n                \"xtractprotos [-prestring=<string>] [-protos=<where>] \"\n                \"[list of C files]\\n\"\n                \"where the prestring is prepended to each prototype, and \\n\"\n                \"protos can be either 'inline' or the name of an output \"\n                \"prototype file\\n\");\n        return 1;\n    }\n\n    /* ---------------------------------------------------------------- */\n    /* Parse input flags and find prestring and outprotos, if requested */\n    /* ---------------------------------------------------------------- */\n    prestring = outprotos = NULL;\n    in_line = FALSE;\n    nflags = 0;\n    maxindex = L_MIN(3, argc);\n    for (i = 1; i < maxindex; i++) {\n        if (argv[i][0] == '-') {\n            if (!strncmp(argv[i], \"-prestring\", 10)) {\n                nflags++;\n                ret = sscanf(argv[i] + 1, \"prestring=%s\", buf);\n                if (ret != 1) {\n                    fprintf(stderr, \"parse failure for prestring\\n\");\n                    return 1;\n                }\n                if ((len = strlen(buf)) > L_BUF_SIZE - 3) {\n                    L_WARNING(\"prestring too large; omitting!\\n\", mainName);\n                } else {\n                    buf[len] = ' ';\n                    buf[len + 1] = '\\0';\n                    prestring = stringNew(buf);\n                }\n            } else if (!strncmp(argv[i], \"-protos\", 7)) {\n                nflags++;\n                ret = sscanf(argv[i] + 1, \"protos=%s\", buf);\n                if (ret != 1) {\n                    fprintf(stderr, \"parse failure for protos\\n\");\n                    return 1;\n                }\n                outprotos = stringNew(buf);\n                if (!strncmp(outprotos, \"inline\", 7))\n                    in_line = TRUE;\n            }\n        }\n    }\n\n    if (argc - nflags < 2) {\n        fprintf(stderr, \"no files specified!\\n\");\n        return 1;\n    }\n\n\n    /* ---------------------------------------------------------------- */\n    /*                   Generate the prototype string                  */\n    /* ---------------------------------------------------------------- */\n    ba = l_byteaCreate(500);\n\n        /* First the extern C head */\n    sa = sarrayCreate(0);\n    sarrayAddString(sa, (char *)\"/*\", L_COPY);\n    snprintf(buf, L_BUF_SIZE,\n             \" *  These prototypes were autogen'd by xtractprotos, v. %s\",\n             version);\n    sarrayAddString(sa, buf, L_COPY);\n    sarrayAddString(sa, (char *)\" */\", L_COPY);\n    sarrayAddString(sa, (char *)\"#ifdef __cplusplus\", L_COPY);\n    sarrayAddString(sa, (char *)\"extern \\\"C\\\" {\", L_COPY);\n    sarrayAddString(sa, (char *)\"#endif  /* __cplusplus */\\n\", L_COPY);\n    str = sarrayToString(sa, 1);\n    l_byteaAppendString(ba, str);\n    lept_free(str);\n    sarrayDestroy(&sa);\n\n        /* Then the prototypes */\n    firstfile = 1 + nflags;\n    protos_added = FALSE;\n    if ((tempfile = l_makeTempFilename()) == NULL) {\n        fprintf(stderr, \"failure to make a writeable temp file\\n\");\n        return 1;\n    }\n    for (i = firstfile; i < argc; i++) {\n        filein = argv[i];\n        len = strlen(filein);\n        if (filein[len - 1] == 'h')  /* skip .h files */\n            continue;\n        snprintf(buf, L_BUF_SIZE, \"cpp -ansi -DNO_PROTOS %s %s\",\n                 filein, tempfile);\n        ret = system(buf);  /* cpp */\n        if (ret) {\n            fprintf(stderr, \"cpp failure for %s; continuing\\n\", filein);\n            continue;\n        }\n\n        if ((str = parseForProtos(tempfile, prestring)) == NULL) {\n            fprintf(stderr, \"parse failure for %s; continuing\\n\", filein);\n            continue;\n        }\n        if (strlen(str) > 1) {  /* strlen(str) == 1 is a file without protos */\n            l_byteaAppendString(ba, str);\n            protos_added = TRUE;\n        }\n        lept_free(str);\n    }\n    lept_rmfile(tempfile);\n    lept_free(tempfile);\n\n        /* Lastly the extern C tail */\n    sa = sarrayCreate(0);\n    sarrayAddString(sa, (char *)\"\\n#ifdef __cplusplus\", L_COPY);\n    sarrayAddString(sa, (char *)\"}\", L_COPY);\n    sarrayAddString(sa, (char *)\"#endif  /* __cplusplus */\", L_COPY);\n    str = sarrayToString(sa, 1);\n    l_byteaAppendString(ba, str);\n    lept_free(str);\n    sarrayDestroy(&sa);\n\n    protostr = (char *)l_byteaCopyData(ba, &nbytes);\n    l_byteaDestroy(&ba);\n\n\n    /* ---------------------------------------------------------------- */\n    /*                       Generate the output                        */\n    /* ---------------------------------------------------------------- */\n    if (!outprotos) {  /* just write to stdout */\n        fprintf(stderr, \"%s\\n\", protostr);\n        lept_free(protostr);\n        return 0;\n    }\n\n        /* If no protos were found, do nothing further */\n    if (!protos_added) {\n        fprintf(stderr, \"No protos found\\n\");\n        lept_free(protostr);\n        return 1;\n    }\n\n        /* Make the output files */\n    ba = l_byteaInitFromFile(\"allheaders_top.txt\");\n    if (!in_line) {\n        snprintf(buf, sizeof(buf), \"#include \\\"%s\\\"\\n\", outprotos);\n        l_byteaAppendString(ba, buf);\n        l_binaryWrite(outprotos, \"w\", protostr, nbytes);\n    } else {\n        l_byteaAppendString(ba, protostr);\n    }\n    ba2 = l_byteaInitFromFile(\"allheaders_bot.txt\");\n    l_byteaJoin(ba, &ba2);\n    l_byteaWrite(\"allheaders.h\", ba, 0, 0);\n    l_byteaDestroy(&ba);\n    lept_free(protostr);\n    return 0;\n}\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file gplot.c\n * <pre>\n *\n *     Basic plotting functions\n *          GPLOT      *gplotCreate()\n *          void        gplotDestroy()\n *          l_int32     gplotAddPlot()\n *          l_int32     gplotSetScaling()\n *          l_int32     gplotMakeOutput()\n *          l_int32     gplotGenCommandFile()\n *          l_int32     gplotGenDataFiles()\n *\n *     Quick and dirty plots\n *          l_int32     gplotSimple1()\n *          l_int32     gplotSimple2()\n *          l_int32     gplotSimpleN()\n *          l_int32     gplotSimpleXY1()\n *          l_int32     gplotSimpleXY2()\n *          l_int32     gplotSimpleXYN()\n *\n *     Serialize for I/O\n *          GPLOT      *gplotRead()\n *          l_int32     gplotWrite()\n *\n *\n *     Utility for programmatic plotting using gnuplot 7.3.2 or later\n *     Enabled:\n *         ~ output to png (color), ps (mono), x11 (color), latex (mono)\n *         ~ optional title for graph\n *         ~ optional x and y axis labels\n *         ~ multiple plots on one frame\n *         ~ optional title for each plot on the frame\n *         ~ optional log scaling on either or both axes\n *         ~ choice of 5 plot styles for each plot\n *         ~ choice of 2 plot modes, either using one input array\n *           (Y vs index) or two input arrays (Y vs X).  This\n *           choice is made implicitly depending on the number of\n *           input arrays.\n *\n *     Usage:\n *         gplotCreate() initializes for plotting\n *         gplotAddPlot() for each plot on the frame\n *         gplotMakeOutput() to generate all output files and run gnuplot\n *         gplotDestroy() to clean up\n *\n *     Example of use:\n *         gplot = gplotCreate(\"tempskew\", GPLOT_PNG, \"Skew score vs angle\",\n *                    \"angle (deg)\", \"score\");\n *         gplotAddPlot(gplot, natheta, nascore1, GPLOT_LINES, \"plot 1\");\n *         gplotAddPlot(gplot, natheta, nascore2, GPLOT_POINTS, \"plot 2\");\n *         gplotSetScaling(gplot, GPLOT_LOG_SCALE_Y);\n *         gplotMakeOutput(gplot);\n *         gplotDestroy(&gplot);\n *\n *     Note for output to GPLOT_LATEX:\n *         This creates latex output of the plot, named <rootname>.tex.\n *         It needs to be placed in a latex file <latexname>.tex\n *         that precedes the plot output with, at a minimum:\n *           \\documentclass{article}\n *           \\begin{document}\n *         and ends with\n *           \\end{document}\n *         You can then generate a dvi file <latexname>.dvi using\n *           latex <latexname>.tex\n *         and a PostScript file <psname>.ps from that using\n *           dvips -o <psname>.ps <latexname>.dvi\n *\n *     N.B. To generate plots, it is necessary to have gnuplot installed on\n *          your Unix system, or wgnuplot on Windows.\n * </pre>\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  L_BUF_SIZE = 512;\n\nconst char  *gplotstylenames[] = {\"with lines\",\n                                  \"with points\",\n                                  \"with impulses\",\n                                  \"with linespoints\",\n                                  \"with dots\"};\nconst char  *gplotfileoutputs[] = {\"\",\n                                   \"PNG\",\n                                   \"PS\",\n                                   \"EPS\",\n                                   \"LATEX\"};\n\n\n/*-----------------------------------------------------------------*\n *                       Basic Plotting Functions                  *\n *-----------------------------------------------------------------*/\n/*!\n * \\brief   gplotCreate()\n *\n * \\param[in]    rootname root for all output files\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    title  [optional] overall title\n * \\param[in]    xlabel [optional] x axis label\n * \\param[in]    ylabel [optional] y axis label\n * \\return  gplot, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This initializes the plot.\n *      (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,\n *          double quotes and backquotes, but not single quotes.\n * </pre>\n */\nGPLOT  *\ngplotCreate(const char  *rootname,\n            l_int32      outformat,\n            const char  *title,\n            const char  *xlabel,\n            const char  *ylabel)\n{\nchar    *newroot;\nchar     buf[L_BUF_SIZE];\nl_int32  badchar;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotCreate\");\n\n    if (!rootname)\n        return (GPLOT *)ERROR_PTR(\"rootname not defined\", procName, NULL);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return (GPLOT *)ERROR_PTR(\"outformat invalid\", procName, NULL);\n    stringCheckForChars(rootname, \"`;&|><\\\"?*\", &badchar);\n    if (badchar)  /* danger of command injection */\n        return (GPLOT *)ERROR_PTR(\"invalid rootname\", procName, NULL);\n\n    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    gplot->cmddata = sarrayCreate(0);\n    gplot->datanames = sarrayCreate(0);\n    gplot->plotdata = sarrayCreate(0);\n    gplot->plottitles = sarrayCreate(0);\n    gplot->plotstyles = numaCreate(0);\n\n        /* Save title, labels, rootname, outformat, cmdname, outname */\n    newroot = genPathname(rootname, NULL);\n    gplot->rootname = newroot;\n    gplot->outformat = outformat;\n    snprintf(buf, L_BUF_SIZE, \"%s.cmd\", rootname);\n    gplot->cmdname = stringNew(buf);\n    if (outformat == GPLOT_PNG)\n        snprintf(buf, L_BUF_SIZE, \"%s.png\", newroot);\n    else if (outformat == GPLOT_PS)\n        snprintf(buf, L_BUF_SIZE, \"%s.ps\", newroot);\n    else if (outformat == GPLOT_EPS)\n        snprintf(buf, L_BUF_SIZE, \"%s.eps\", newroot);\n    else if (outformat == GPLOT_LATEX)\n        snprintf(buf, L_BUF_SIZE, \"%s.tex\", newroot);\n    gplot->outname = stringNew(buf);\n    if (title) gplot->title = stringNew(title);\n    if (xlabel) gplot->xlabel = stringNew(xlabel);\n    if (ylabel) gplot->ylabel = stringNew(ylabel);\n\n    return gplot;\n}\n\n\n/*!\n * \\brief    gplotDestroy()\n *\n * \\param[in,out] pgplot to be nulled\n */\nvoid\ngplotDestroy(GPLOT  **pgplot)\n{\nGPLOT  *gplot;\n\n    PROCNAME(\"gplotDestroy\");\n\n    if (pgplot == NULL) {\n        L_WARNING(\"ptr address is null!\\n\", procName);\n        return;\n    }\n\n    if ((gplot = *pgplot) == NULL)\n        return;\n\n    LEPT_FREE(gplot->rootname);\n    LEPT_FREE(gplot->cmdname);\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n    sarrayDestroy(&gplot->plottitles);\n    numaDestroy(&gplot->plotstyles);\n    LEPT_FREE(gplot->outname);\n    if (gplot->title)\n        LEPT_FREE(gplot->title);\n    if (gplot->xlabel)\n        LEPT_FREE(gplot->xlabel);\n    if (gplot->ylabel)\n        LEPT_FREE(gplot->ylabel);\n\n    LEPT_FREE(gplot);\n    *pgplot = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   gplotAddPlot()\n *\n * \\param[in]    gplot\n * \\param[in]    nax [optional] numa: set to null for Y_VS_I;\n *                   required for Y_VS_X\n * \\param[in]    nay numa: required for both Y_VS_I and Y_VS_X\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    plottitle  [optional] title for individual plot\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) There are 2 options for (x,y) values:\n *            o  To plot an array vs a linear function of the\n *               index, set nax = NULL.\n *            o  To plot one array vs another, use both nax and nay.\n *      (2) If nax is NULL, the x value corresponding to the i-th\n *          value of nay is found from the startx and delx fields\n *          in nay:\n *               x = startx + i * delx\n *          These are set with numaSetParameters().  Their default\n *          values are startx = 0.0, delx = 1.0.\n *      (3) If nax is defined, it must be the same size as nay, and\n *          must have at least one number.\n *      (4) The 'plottitle' string can have spaces, double\n *          quotes and backquotes, but not single quotes.\n * </pre>\n */\nl_int32\ngplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n\n    PROCNAME(\"gplotAddPlot\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n\n        /* Save plotstyle and plottitle */\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n\n        /* Generate and save data filename */\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n\n        /* Generate data and save as a string */\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotSetScaling()\n *\n * \\param[in]    gplot\n * \\param[in]    scaling GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X,\n *                       GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) By default, the x and y axis scaling is linear.\n *      (2) Call this function to set semi-log or log-log scaling.\n * </pre>\n */\nl_int32\ngplotSetScaling(GPLOT   *gplot,\n                l_int32  scaling)\n{\n    PROCNAME(\"gplotSetScaling\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (scaling != GPLOT_LINEAR_SCALE &&\n        scaling != GPLOT_LOG_SCALE_X &&\n        scaling != GPLOT_LOG_SCALE_Y &&\n        scaling != GPLOT_LOG_SCALE_X_Y)\n        return ERROR_INT(\"invalid gplot scaling\", procName, 1);\n    gplot->scaling = scaling;\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotMakeOutput()\n *\n * \\param[in]    gplot\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This uses gplot and the new arrays to add a plot\n *          to the output, by writing a new data file and appending\n *          the appropriate plot commands to the command file.\n *      (2) This is the only function in this file that requires the\n *          gnuplot executable, to actually generate the plot.\n *      (3) The command file name for unix is canonical (i.e., directory /tmp)\n *          but the temp filename paths in the command file must be correct.\n *      (4) The gnuplot program for windows is wgnuplot.exe.\n * </pre>\n */\nl_int32\ngplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  /* _WIN32 */\n\n#ifndef OS_IOS /* iOS 11 does not support system() */\n    ignore = system(buf);  /* gnuplot || wgnuplot */\n#endif /* !OS_IOS */\n\n    LEPT_FREE(cmdname);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotGenCommandFile()\n *\n * \\param[in]    gplot\n * \\return  0 if OK, 1 on error\n */\nl_int32\ngplotGenCommandFile(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdstr, *plottitle, *dataname;\nl_int32  i, plotstyle, nplots;\nFILE    *fp;\n\n    PROCNAME(\"gplotGenCommandFile\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n        /* Remove any previous command data */\n    sarrayClear(gplot->cmddata);\n\n        /* Generate command data instructions */\n    if (gplot->title) {   /* set title */\n        snprintf(buf, L_BUF_SIZE, \"set title '%s'\", gplot->title);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->xlabel) {   /* set xlabel */\n        snprintf(buf, L_BUF_SIZE, \"set xlabel '%s'\", gplot->xlabel);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->ylabel) {   /* set ylabel */\n        snprintf(buf, L_BUF_SIZE, \"set ylabel '%s'\", gplot->ylabel);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n        /* Set terminal type and output */\n    if (gplot->outformat == GPLOT_PNG) {\n        snprintf(buf, L_BUF_SIZE, \"set terminal png; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_PS) {\n        snprintf(buf, L_BUF_SIZE, \"set terminal postscript; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_EPS) {\n        snprintf(buf, L_BUF_SIZE,\n                 \"set terminal postscript eps; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_LATEX) {\n        snprintf(buf, L_BUF_SIZE, \"set terminal latex; set output '%s'\",\n                 gplot->outname);\n    }\n    sarrayAddString(gplot->cmddata, buf, L_COPY);\n\n    if (gplot->scaling == GPLOT_LOG_SCALE_X ||\n        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {\n        snprintf(buf, L_BUF_SIZE, \"set logscale x\");\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->scaling == GPLOT_LOG_SCALE_Y ||\n        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {\n        snprintf(buf, L_BUF_SIZE, \"set logscale y\");\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n    nplots = sarrayGetCount(gplot->datanames);\n    for (i = 0; i < nplots; i++) {\n        plottitle = sarrayGetString(gplot->plottitles, i, L_NOCOPY);\n        dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);\n        numaGetIValue(gplot->plotstyles, i, &plotstyle);\n        if (nplots == 1) {\n            snprintf(buf, L_BUF_SIZE, \"plot '%s' title '%s' %s\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n        } else {\n            if (i == 0)\n                snprintf(buf, L_BUF_SIZE, \"plot '%s' title '%s' %s, \\\\\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n            else if (i < nplots - 1)\n                snprintf(buf, L_BUF_SIZE, \" '%s' title '%s' %s, \\\\\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n            else\n                snprintf(buf, L_BUF_SIZE, \" '%s' title '%s' %s\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n        }\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n        /* Write command data to file */\n    cmdstr = sarrayToString(gplot->cmddata, 1);\n    if ((fp = fopenWriteStream(gplot->cmdname, \"w\")) == NULL) {\n        LEPT_FREE(cmdstr);\n        return ERROR_INT(\"cmd stream not opened\", procName, 1);\n    }\n    fwrite(cmdstr, 1, strlen(cmdstr), fp);\n    fclose(fp);\n    LEPT_FREE(cmdstr);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotGenDataFiles()\n *\n * \\param[in]    gplot\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The pathnames in the gplot command file are actual pathnames,\n *          which can be in temp directories.  Consequently, they must not be\n *          rewritten by calling fopenWriteStream(), and we use fopen().\n * </pre>\n */\nl_int32\ngplotGenDataFiles(GPLOT  *gplot)\n{\nchar    *plotdata, *dataname;\nl_int32  i, nplots;\nFILE    *fp;\n\n    PROCNAME(\"gplotGenDataFiles\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    nplots = sarrayGetCount(gplot->datanames);\n    for (i = 0; i < nplots; i++) {\n        plotdata = sarrayGetString(gplot->plotdata, i, L_NOCOPY);\n        dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);\n        if ((fp = fopen(dataname, \"w\")) == NULL)\n            return ERROR_INT(\"datafile stream not opened\", procName, 1);\n        fwrite(plotdata, 1, strlen(plotdata), fp);\n        fclose(fp);\n    }\n\n    return 0;\n}\n\n\n/*-----------------------------------------------------------------*\n *                       Quick and Dirty Plots                     *\n *-----------------------------------------------------------------*/\n/*!\n * \\brief   gplotSimple1()\n *\n * \\param[in]    na numa; plot Y_VS_I\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional], can be NULL\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a line plot of a numa, where the array value\n *          is plotted vs the array index.  The plot is generated\n *          in the specified output format; the title  is optional.\n *      (2) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimple1(NUMA        *na,\n             l_int32      outformat,\n             const char  *outroot,\n             const char  *title)\n{\n    return gplotSimpleXY1(NULL, na, GPLOT_LINES, outformat, outroot, title);\n}\n\n\n/*!\n * \\brief   gplotSimple2()\n *\n * \\param[in]    na1 numa; plotted with Y_VS_I\n * \\param[in]    na2 ditto\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a line plot of two numa, where the array values\n *          are each plotted vs the array index.  The plot is generated\n *          in the specified output format; the title  is optional.\n *      (2) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimple2(NUMA        *na1,\n             NUMA        *na2,\n             l_int32      outformat,\n             const char  *outroot,\n             const char  *title)\n{\n    return gplotSimpleXY2(NULL, na1, na2, GPLOT_LINES,\n                          outformat, outroot, title);\n}\n\n\n/*!\n * \\brief   gplotSimpleN()\n *\n * \\param[in]    naa numaa; we plotted with Y_VS_I for each numa\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a line plot of all numas in a numaa (array of numa),\n *          where the array values are each plotted vs the array index.\n *          The plot is generated in the specified output format;\n *          the title  is optional.\n *      (2) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleN(NUMAA       *naa,\n             l_int32      outformat,\n             const char  *outroot,\n             const char  *title)\n{\n    return gplotSimpleXYN(NULL, naa, GPLOT_LINES, outformat, outroot, title);\n}\n\n\n/*!\n * \\brief   gplotSimpleXY1()\n *\n * \\param[in]    nax [optional]\n * \\param[in]    nay\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional], can be NULL\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a plot of a %nay vs %nax, generated in\n *          the specified output format.  The title is optional.\n *      (2) Use 0 for default plotstyle (lines).\n *      (3) %nax is optional.  If NULL, %nay is plotted against\n *          the array index.\n *      (4) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleXY1(NUMA        *nax,\n               NUMA        *nay,\n               l_int32      plotstyle,\n               l_int32      outformat,\n               const char  *outroot,\n               const char  *title)\n{\nGPLOT  *gplot;\n\n    PROCNAME(\"gplotSimpleXY1\");\n\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return ERROR_INT(\"invalid outformat\", procName, 1);\n    if (!outroot)\n        return ERROR_INT(\"outroot not specified\", procName, 1);\n\n    if ((gplot = gplotCreate(outroot, outformat, title, NULL, NULL)) == 0)\n        return ERROR_INT(\"gplot not made\", procName, 1);\n    gplotAddPlot(gplot, nax, nay, plotstyle, NULL);\n    gplotMakeOutput(gplot);\n    gplotDestroy(&gplot);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotSimpleXY2()\n *\n * \\param[in]    nax <optional; can be NULL\n * \\param[in]    nay1\n * \\param[in]    nay2\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives plots of %nay1 and %nay2 against nax, generated\n *          in the specified output format.  The title is optional.\n *      (2) Use 0 for default plotstyle (lines).\n *      (3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted\n *          against the array index.\n *      (4) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleXY2(NUMA        *nax,\n               NUMA        *nay1,\n               NUMA        *nay2,\n               l_int32      plotstyle,\n               l_int32      outformat,\n               const char  *outroot,\n               const char  *title)\n{\nGPLOT  *gplot;\n\n    PROCNAME(\"gplotSimpleXY2\");\n\n    if (!nay1 || !nay2)\n        return ERROR_INT(\"nay1 and nay2 not both defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return ERROR_INT(\"invalid outformat\", procName, 1);\n    if (!outroot)\n        return ERROR_INT(\"outroot not specified\", procName, 1);\n\n    if ((gplot = gplotCreate(outroot, outformat, title, NULL, NULL)) == 0)\n        return ERROR_INT(\"gplot not made\", procName, 1);\n    gplotAddPlot(gplot, nax, nay1, plotstyle, NULL);\n    gplotAddPlot(gplot, nax, nay2, plotstyle, NULL);\n    gplotMakeOutput(gplot);\n    gplotDestroy(&gplot);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotSimpleXYN()\n *\n * \\param[in]    nax [optional]; can be NULL\n * \\param[in]    naay numaa of arrays to plot against %nax\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives plots of each Numa in %naa against nax,\n *          generated in the specified output format.  The title is optional.\n *      (2) Use 0 for default plotstyle (lines).\n *      (3) %nax is optional.  If NULL, each Numa array is plotted against\n *          the array index.\n *      (4) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleXYN(NUMA        *nax,\n               NUMAA       *naay,\n               l_int32      plotstyle,\n               l_int32      outformat,\n               const char  *outroot,\n               const char  *title)\n{\nl_int32  i, n;\nGPLOT   *gplot;\nNUMA    *nay;\n\n    PROCNAME(\"gplotSimpleXYN\");\n\n    if (!naay)\n        return ERROR_INT(\"naay not defined\", procName, 1);\n    if ((n = numaaGetCount(naay)) == 0)\n        return ERROR_INT(\"no numa in array\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return ERROR_INT(\"invalid outformat\", procName, 1);\n    if (!outroot)\n        return ERROR_INT(\"outroot not specified\", procName, 1);\n\n    if ((gplot = gplotCreate(outroot, outformat, title, NULL, NULL)) == 0)\n        return ERROR_INT(\"gplot not made\", procName, 1);\n    for (i = 0; i < n; i++) {\n        nay = numaaGetNuma(naay, i, L_CLONE);\n        gplotAddPlot(gplot, nax, nay, plotstyle, NULL);\n        numaDestroy(&nay);\n    }\n    gplotMakeOutput(gplot);\n    gplotDestroy(&gplot);\n    return 0;\n}\n\n\n/*-----------------------------------------------------------------*\n *                           Serialize for I/O                     *\n *-----------------------------------------------------------------*/\n/*!\n * \\brief   gplotRead()\n *\n * \\param[in]    filename\n * \\return  gplot, or NULL on error\n */\nGPLOT *\ngplotRead(const char  *filename)\n{\nchar     buf[L_BUF_SIZE];\nchar    *rootname, *title, *xlabel, *ylabel, *ignores;\nl_int32  outformat, ret, version, ignore;\nFILE    *fp;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotRead\");\n\n    if (!filename)\n        return (GPLOT *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (GPLOT *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ret = fscanf(fp, \"Gplot Version %d\\n\", &version);\n    if (ret != 1) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"not a gplot file\", procName, NULL);\n    }\n    if (version != GPLOT_VERSION_NUMBER) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"invalid gplot version\", procName, NULL);\n    }\n\n    ignore = fscanf(fp, \"Rootname: %s\\n\", buf);\n    rootname = stringNew(buf);\n    ignore = fscanf(fp, \"Output format: %d\\n\", &outformat);\n    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Title: ... */\n    title = stringNew(buf + 7);\n    title[strlen(title) - 1] = '\\0';\n    ignores = fgets(buf, L_BUF_SIZE, fp);   /* X axis label: ... */\n    xlabel = stringNew(buf + 14);\n    xlabel[strlen(xlabel) - 1] = '\\0';\n    ignores = fgets(buf, L_BUF_SIZE, fp);   /* Y axis label: ... */\n    ylabel = stringNew(buf + 14);\n    ylabel[strlen(ylabel) - 1] = '\\0';\n\n    gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);\n    LEPT_FREE(rootname);\n    LEPT_FREE(title);\n    LEPT_FREE(xlabel);\n    LEPT_FREE(ylabel);\n    if (!gplot) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    }\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n    sarrayDestroy(&gplot->plottitles);\n    numaDestroy(&gplot->plotstyles);\n\n    ignore = fscanf(fp, \"Commandfile name: %s\\n\", buf);\n    stringReplace(&gplot->cmdname, buf);\n    ignore = fscanf(fp, \"\\nCommandfile data:\");\n    gplot->cmddata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nDatafile names:\");\n    gplot->datanames = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot data:\");\n    gplot->plotdata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot titles:\");\n    gplot->plottitles = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot styles:\");\n    gplot->plotstyles = numaReadStream(fp);\n\n    ignore = fscanf(fp, \"Number of plots: %d\\n\", &gplot->nplots);\n    ignore = fscanf(fp, \"Output file name: %s\\n\", buf);\n    stringReplace(&gplot->outname, buf);\n    ignore = fscanf(fp, \"Axis scaling: %d\\n\", &gplot->scaling);\n\n    fclose(fp);\n    return gplot;\n}\n\n\n/*!\n * \\brief   gplotWrite()\n *\n * \\param[in]    filename\n * \\param[in]    gplot\n * \\return  0 if OK; 1 on error\n */\nl_int32\ngplotWrite(const char  *filename,\n           GPLOT       *gplot)\n{\nFILE  *fp;\n\n    PROCNAME(\"gplotWrite\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(filename, \"wb\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n\n    fprintf(fp, \"Gplot Version %d\\n\", GPLOT_VERSION_NUMBER);\n    fprintf(fp, \"Rootname: %s\\n\", gplot->rootname);\n    fprintf(fp, \"Output format: %d\\n\", gplot->outformat);\n    fprintf(fp, \"Title: %s\\n\", gplot->title);\n    fprintf(fp, \"X axis label: %s\\n\", gplot->xlabel);\n    fprintf(fp, \"Y axis label: %s\\n\", gplot->ylabel);\n\n    fprintf(fp, \"Commandfile name: %s\\n\", gplot->cmdname);\n    fprintf(fp, \"\\nCommandfile data:\");\n    sarrayWriteStream(fp, gplot->cmddata);\n    fprintf(fp, \"\\nDatafile names:\");\n    sarrayWriteStream(fp, gplot->datanames);\n    fprintf(fp, \"\\nPlot data:\");\n    sarrayWriteStream(fp, gplot->plotdata);\n    fprintf(fp, \"\\nPlot titles:\");\n    sarrayWriteStream(fp, gplot->plottitles);\n    fprintf(fp, \"\\nPlot styles:\");\n    numaWriteStream(fp, gplot->plotstyles);\n\n    fprintf(fp, \"Number of plots: %d\\n\", gplot->nplots);\n    fprintf(fp, \"Output file name: %s\\n\", gplot->outname);\n    fprintf(fp, \"Axis scaling: %d\\n\", gplot->scaling);\n\n    fclose(fp);\n    return 0;\n}\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n\n/*!\n * \\file  ptabasic.c\n * <pre>\n *\n *      Pta creation, destruction, copy, clone, empty\n *           PTA            *ptaCreate()\n *           PTA            *ptaCreateFromNuma()\n *           void            ptaDestroy()\n *           PTA            *ptaCopy()\n *           PTA            *ptaCopyRange()\n *           PTA            *ptaClone()\n *           l_int32         ptaEmpty()\n *\n *      Pta array extension\n *           l_int32         ptaAddPt()\n *           static l_int32  ptaExtendArrays()\n *\n *      Pta insertion and removal\n *           l_int32         ptaInsertPt()\n *           l_int32         ptaRemovePt()\n *\n *      Pta accessors\n *           l_int32         ptaGetRefcount()\n *           l_int32         ptaChangeRefcount()\n *           l_int32         ptaGetCount()\n *           l_int32         ptaGetPt()\n *           l_int32         ptaGetIPt()\n *           l_int32         ptaSetPt()\n *           l_int32         ptaGetArrays()\n *\n *      Pta serialized for I/O\n *           PTA            *ptaRead()\n *           PTA            *ptaReadStream()\n *           PTA            *ptaReadMem()\n *           l_int32         ptaWrite()\n *           l_int32         ptaWriteStream()\n *           l_int32         ptaWriteMem()\n *\n *      Ptaa creation, destruction\n *           PTAA           *ptaaCreate()\n *           void            ptaaDestroy()\n *\n *      Ptaa array extension\n *           l_int32         ptaaAddPta()\n *           static l_int32  ptaaExtendArray()\n *\n *      Ptaa accessors\n *           l_int32         ptaaGetCount()\n *           l_int32         ptaaGetPta()\n *           l_int32         ptaaGetPt()\n *\n *      Ptaa array modifiers\n *           l_int32         ptaaInitFull()\n *           l_int32         ptaaReplacePta()\n *           l_int32         ptaaAddPt()\n *           l_int32         ptaaTruncate()\n *\n *      Ptaa serialized for I/O\n *           PTAA           *ptaaRead()\n *           PTAA           *ptaaReadStream()\n *           PTAA           *ptaaReadMem()\n *           l_int32         ptaaWrite()\n *           l_int32         ptaaWriteStream()\n *           l_int32         ptaaWriteMem()\n * </pre>\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  INITIAL_PTR_ARRAYSIZE = 20;   /* n'import quoi */\n\n    /* Static functions */\nstatic l_int32 ptaExtendArrays(PTA *pta);\nstatic l_int32 ptaaExtendArray(PTAA *ptaa);\n\n\n/*---------------------------------------------------------------------*\n *                Pta creation, destruction, copy, clone               *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaCreate()\n *\n * \\param[in]    n  initial array sizes\n * \\return  pta, or NULL on error.\n */\nPTA *\nptaCreate(l_int32  n)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaCreate\");\n\n    if (n <= 0)\n        n = INITIAL_PTR_ARRAYSIZE;\n\n    pta = (PTA *)LEPT_CALLOC(1, sizeof(PTA));\n    pta->n = 0;\n    pta->nalloc = n;\n    ptaChangeRefcount(pta, 1);  /* sets to 1 */\n\n    pta->x = (l_float32 *)LEPT_CALLOC(n, sizeof(l_float32));\n    pta->y = (l_float32 *)LEPT_CALLOC(n, sizeof(l_float32));\n    if (!pta->x || !pta->y) {\n        ptaDestroy(&pta);\n        return (PTA *)ERROR_PTR(\"x and y arrays not both made\", procName, NULL);\n    }\n\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaCreateFromNuma()\n *\n * \\param[in]    nax [optional] can be null\n * \\param[in]    nay\n * \\return  pta, or NULL on error.\n */\nPTA *\nptaCreateFromNuma(NUMA  *nax,\n                  NUMA  *nay)\n{\nl_int32    i, n;\nl_float32  startx, delx, xval, yval;\nPTA       *pta;\n\n    PROCNAME(\"ptaCreateFromNuma\");\n\n    if (!nay)\n        return (PTA *)ERROR_PTR(\"nay not defined\", procName, NULL);\n    n = numaGetCount(nay);\n    if (nax && numaGetCount(nax) != n)\n        return (PTA *)ERROR_PTR(\"nax and nay sizes differ\", procName, NULL);\n\n    pta = ptaCreate(n);\n    numaGetParameters(nay, &startx, &delx);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &xval);\n        else  /* use implicit x values from nay */\n            xval = startx + i * delx;\n        numaGetFValue(nay, i, &yval);\n        ptaAddPt(pta, xval, yval);\n    }\n\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaDestroy()\n *\n * \\param[in,out]   ppta to be nulled\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) Decrements the ref count and, if 0, destroys the pta.\n *      (2) Always nulls the input ptr.\n * </pre>\n */\nvoid\nptaDestroy(PTA  **ppta)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaDestroy\");\n\n    if (ppta == NULL) {\n        L_WARNING(\"ptr address is NULL!\\n\", procName);\n        return;\n    }\n\n    if ((pta = *ppta) == NULL)\n        return;\n\n    ptaChangeRefcount(pta, -1);\n    if (ptaGetRefcount(pta) <= 0) {\n        LEPT_FREE(pta->x);\n        LEPT_FREE(pta->y);\n        LEPT_FREE(pta);\n    }\n\n    *ppta = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   ptaCopy()\n *\n * \\param[in]    pta\n * \\return  copy of pta, or NULL on error\n */\nPTA *\nptaCopy(PTA  *pta)\n{\nl_int32    i;\nl_float32  x, y;\nPTA       *npta;\n\n    PROCNAME(\"ptaCopy\");\n\n    if (!pta)\n        return (PTA *)ERROR_PTR(\"pta not defined\", procName, NULL);\n\n    if ((npta = ptaCreate(pta->nalloc)) == NULL)\n        return (PTA *)ERROR_PTR(\"npta not made\", procName, NULL);\n\n    for (i = 0; i < pta->n; i++) {\n        ptaGetPt(pta, i, &x, &y);\n        ptaAddPt(npta, x, y);\n    }\n\n    return npta;\n}\n\n\n/*!\n * \\brief   ptaCopyRange()\n *\n * \\param[in]    ptas\n * \\param[in]    istart  starting index in ptas\n * \\param[in]    iend  ending index in ptas; use 0 to copy to end\n * \\return  0 if OK, 1 on error\n */\nPTA *\nptaCopyRange(PTA     *ptas,\n             l_int32  istart,\n             l_int32  iend)\n{\nl_int32  n, i, x, y;\nPTA     *ptad;\n\n    PROCNAME(\"ptaCopyRange\");\n\n    if (!ptas)\n        return (PTA *)ERROR_PTR(\"ptas not defined\", procName, NULL);\n    n = ptaGetCount(ptas);\n    if (istart < 0)\n        istart = 0;\n    if (istart >= n)\n        return (PTA *)ERROR_PTR(\"istart out of bounds\", procName, NULL);\n    if (iend <= 0 || iend >= n)\n        iend = n - 1;\n    if (istart > iend)\n        return (PTA *)ERROR_PTR(\"istart > iend; no pts\", procName, NULL);\n\n    if ((ptad = ptaCreate(iend - istart + 1)) == NULL)\n        return (PTA *)ERROR_PTR(\"ptad not made\", procName, NULL);\n    for (i = istart; i <= iend; i++) {\n        ptaGetIPt(ptas, i, &x, &y);\n        ptaAddPt(ptad, x, y);\n    }\n\n    return ptad;\n}\n\n\n/*!\n * \\brief   ptaClone()\n *\n * \\param[in]    pta\n * \\return  ptr to same pta, or NULL on error\n */\nPTA *\nptaClone(PTA  *pta)\n{\n    PROCNAME(\"ptaClone\");\n\n    if (!pta)\n        return (PTA *)ERROR_PTR(\"pta not defined\", procName, NULL);\n\n    ptaChangeRefcount(pta, 1);\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaEmpty()\n *\n * \\param[in]    pta\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      This only resets the Pta::n field, for reuse\n * </pre>\n */\nl_int32\nptaEmpty(PTA  *pta)\n{\n    PROCNAME(\"ptaEmpty\");\n\n    if (!pta)\n        return ERROR_INT(\"ptad not defined\", procName, 1);\n    pta->n = 0;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                         Pta array extension                         *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaAddPt()\n *\n * \\param[in]    pta\n * \\param[in]    x, y\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaAddPt(PTA       *pta,\n         l_float32  x,\n         l_float32  y)\n{\nl_int32  n;\n\n    PROCNAME(\"ptaAddPt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    n = pta->n;\n    if (n >= pta->nalloc)\n        ptaExtendArrays(pta);\n    pta->x[n] = x;\n    pta->y[n] = y;\n    pta->n++;\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaExtendArrays()\n *\n * \\param[in]    pta\n * \\return  0 if OK; 1 on error\n */\nstatic l_int32\nptaExtendArrays(PTA  *pta)\n{\n    PROCNAME(\"ptaExtendArrays\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    if ((pta->x = (l_float32 *)reallocNew((void **)&pta->x,\n                               sizeof(l_float32) * pta->nalloc,\n                               2 * sizeof(l_float32) * pta->nalloc)) == NULL)\n        return ERROR_INT(\"new x array not returned\", procName, 1);\n    if ((pta->y = (l_float32 *)reallocNew((void **)&pta->y,\n                               sizeof(l_float32) * pta->nalloc,\n                               2 * sizeof(l_float32) * pta->nalloc)) == NULL)\n        return ERROR_INT(\"new y array not returned\", procName, 1);\n\n    pta->nalloc = 2 * pta->nalloc;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                     Pta insertion and removal                       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaInsertPt()\n *\n * \\param[in]    pta\n * \\param[in]    index at which pt is to be inserted\n * \\param[in]    x, y point values\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaInsertPt(PTA     *pta,\n            l_int32  index,\n            l_int32  x,\n            l_int32  y)\n{\nl_int32  i, n;\n\n    PROCNAME(\"ptaInsertPt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaGetCount(pta);\n    if (index < 0 || index > n)\n        return ERROR_INT(\"index not in {0...n}\", procName, 1);\n\n    if (n > pta->nalloc)\n        ptaExtendArrays(pta);\n    pta->n++;\n    for (i = n; i > index; i--) {\n        pta->x[i] = pta->x[i - 1];\n        pta->y[i] = pta->y[i - 1];\n    }\n    pta->x[index] = x;\n    pta->y[index] = y;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaRemovePt()\n *\n * \\param[in]    pta\n * \\param[in]    index of point to be removed\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This shifts pta[i] --> pta[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n * </pre>\n */\nl_int32\nptaRemovePt(PTA     *pta,\n            l_int32  index)\n{\nl_int32  i, n;\n\n    PROCNAME(\"ptaRemovePt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaGetCount(pta);\n    if (index < 0 || index >= n)\n        return ERROR_INT(\"index not in {0...n - 1}\", procName, 1);\n\n        /* Remove the point */\n    for (i = index + 1; i < n; i++) {\n        pta->x[i - 1] = pta->x[i];\n        pta->y[i - 1] = pta->y[i];\n    }\n    pta->n--;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                           Pta accessors                             *\n *---------------------------------------------------------------------*/\nl_int32\nptaGetRefcount(PTA  *pta)\n{\n    PROCNAME(\"ptaGetRefcount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    return pta->refcount;\n}\n\n\nl_int32\nptaChangeRefcount(PTA     *pta,\n                  l_int32  delta)\n{\n    PROCNAME(\"ptaChangeRefcount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    pta->refcount += delta;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaGetCount()\n *\n * \\param[in]    pta\n * \\return  count, or 0 if no pta\n */\nl_int32\nptaGetCount(PTA  *pta)\n{\n    PROCNAME(\"ptaGetCount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 0);\n\n    return pta->n;\n}\n\n\n/*!\n * \\brief   ptaGetPt()\n *\n * \\param[in]    pta\n * \\param[in]    index  into arrays\n * \\param[out]   px [optional] float x value\n * \\param[out]   py [optional] float y value\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaGetPt(PTA        *pta,\n         l_int32     index,\n         l_float32  *px,\n         l_float32  *py)\n{\n    PROCNAME(\"ptaGetPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    if (px) *px = pta->x[index];\n    if (py) *py = pta->y[index];\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaGetIPt()\n *\n * \\param[in]    pta\n * \\param[in]    index  into arrays\n * \\param[out]   px [optional] integer x value\n * \\param[out]   py [optional] integer y value\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaGetIPt(PTA      *pta,\n          l_int32   index,\n          l_int32  *px,\n          l_int32  *py)\n{\n    PROCNAME(\"ptaGetIPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    if (px) *px = (l_int32)(pta->x[index] + 0.5);\n    if (py) *py = (l_int32)(pta->y[index] + 0.5);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaSetPt()\n *\n * \\param[in]    pta\n * \\param[in]    index  into arrays\n * \\param[in]    x, y\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaSetPt(PTA       *pta,\n         l_int32    index,\n         l_float32  x,\n         l_float32  y)\n{\n    PROCNAME(\"ptaSetPt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    pta->x[index] = x;\n    pta->y[index] = y;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaGetArrays()\n *\n * \\param[in]    pta\n * \\param[out]   pnax [optional] numa of x array\n * \\param[out]   pnay [optional] numa of y array\n * \\return  0 if OK; 1 on error or if pta is empty\n *\n * <pre>\n * Notes:\n *      (1) This copies the internal arrays into new Numas.\n * </pre>\n */\nl_int32\nptaGetArrays(PTA    *pta,\n             NUMA  **pnax,\n             NUMA  **pnay)\n{\nl_int32  i, n;\nNUMA    *nax, *nay;\n\n    PROCNAME(\"ptaGetArrays\");\n\n    if (!pnax && !pnay)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (pnax) *pnax = NULL;\n    if (pnay) *pnay = NULL;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if ((n = ptaGetCount(pta)) == 0)\n        return ERROR_INT(\"pta is empty\", procName, 1);\n\n    if (pnax) {\n        if ((nax = numaCreate(n)) == NULL)\n            return ERROR_INT(\"nax not made\", procName, 1);\n        *pnax = nax;\n        for (i = 0; i < n; i++)\n            nax->array[i] = pta->x[i];\n        nax->n = n;\n    }\n    if (pnay) {\n        if ((nay = numaCreate(n)) == NULL)\n            return ERROR_INT(\"nay not made\", procName, 1);\n        *pnay = nay;\n        for (i = 0; i < n; i++)\n            nay->array[i] = pta->y[i];\n        nay->n = n;\n    }\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                       Pta serialized for I/O                        *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaRead()\n *\n * \\param[in]    filename\n * \\return  pta, or NULL on error\n */\nPTA *\nptaRead(const char  *filename)\n{\nFILE  *fp;\nPTA   *pta;\n\n    PROCNAME(\"ptaRead\");\n\n    if (!filename)\n        return (PTA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PTA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    pta = ptaReadStream(fp);\n    fclose(fp);\n    if (!pta)\n        return (PTA *)ERROR_PTR(\"pta not read\", procName, NULL);\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  pta, or NULL on error\n */\nPTA *\nptaReadStream(FILE  *fp)\n{\nchar       typestr[128];\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n\n    PROCNAME(\"ptaReadStream\");\n\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  /* typestr is \"integer\" */\n        type = 1;\n\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  /* data is float */\n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   /* data is integer */\n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaReadMem()\n *\n * \\param[in]    data  serialization in ascii\n * \\param[in]    size  of data in bytes; can use strlen to get it\n * \\return  pta, or NULL on error\n */\nPTA *\nptaReadMem(const l_uint8  *data,\n           size_t          size)\n{\nFILE  *fp;\nPTA   *pta;\n\n    PROCNAME(\"ptaReadMem\");\n\n    if (!data)\n        return (PTA *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if ((fp = fopenReadFromMemory(data, size)) == NULL)\n        return (PTA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    pta = ptaReadStream(fp);\n    fclose(fp);\n    if (!pta) L_ERROR(\"pta not read\\n\", procName);\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaWrite()\n *\n * \\param[in]    filename\n * \\param[in]    pta\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaWrite(const char  *filename,\n         PTA         *pta,\n         l_int32      type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaWrite\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(filename, \"w\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaWriteStream(fp, pta, type);\n    fclose(fp);\n    if (ret)\n        return ERROR_INT(\"pta not written to stream\", procName, 1);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    pta\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaWriteStream(FILE    *fp,\n               PTA     *pta,\n               l_int32  type)\n{\nl_int32    i, n, ix, iy;\nl_float32  x, y;\n\n    PROCNAME(\"ptaWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    n = ptaGetCount(pta);\n    fprintf(fp, \"\\n Pta Version %d\\n\", PTA_VERSION_NUMBER);\n    if (type == 0)\n        fprintf(fp, \" Number of pts = %d; format = float\\n\", n);\n    else  /* type == 1 */\n        fprintf(fp, \" Number of pts = %d; format = integer\\n\", n);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  /* data is float */\n            ptaGetPt(pta, i, &x, &y);\n            fprintf(fp, \"   (%f, %f)\\n\", x, y);\n        } else {   /* data is integer */\n            ptaGetIPt(pta, i, &ix, &iy);\n            fprintf(fp, \"   (%d, %d)\\n\", ix, iy);\n        }\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaWriteMem()\n *\n * \\param[out]   pdata data of serialized pta; ascii\n * \\param[out]   psize size of returned data\n * \\param[in]    pta\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Serializes a pta in memory and puts the result in a buffer.\n * </pre>\n */\nl_int32\nptaWriteMem(l_uint8  **pdata,\n            size_t    *psize,\n            PTA       *pta,\n            l_int32    type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaWriteMem\");\n\n    if (pdata) *pdata = NULL;\n    if (psize) *psize = 0;\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n#if HAVE_FMEMOPEN\n    if ((fp = open_memstream((char **)pdata, psize)) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaWriteStream(fp, pta, type);\n#else\n    L_INFO(\"work-around: writing to a temp file\\n\", procName);\n  #ifdef _WIN32\n    if ((fp = fopenWriteWinTempfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #else\n    if ((fp = tmpfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #endif  /* _WIN32 */\n    ret = ptaWriteStream(fp, pta, type);\n    rewind(fp);\n    *pdata = l_binaryReadStream(fp, psize);\n#endif  /* HAVE_FMEMOPEN */\n    fclose(fp);\n    return ret;\n}\n\n\n/*---------------------------------------------------------------------*\n *                     PTAA creation, destruction                      *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaCreate()\n *\n * \\param[in]    n  initial number of ptrs\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaCreate(l_int32  n)\n{\nPTAA  *ptaa;\n\n    PROCNAME(\"ptaaCreate\");\n\n    if (n <= 0)\n        n = INITIAL_PTR_ARRAYSIZE;\n\n    if ((ptaa = (PTAA *)LEPT_CALLOC(1, sizeof(PTAA))) == NULL)\n        return (PTAA *)ERROR_PTR(\"ptaa not made\", procName, NULL);\n    ptaa->n = 0;\n    ptaa->nalloc = n;\n    if ((ptaa->pta = (PTA **)LEPT_CALLOC(n, sizeof(PTA *))) == NULL) {\n        ptaaDestroy(&ptaa);\n        return (PTAA *)ERROR_PTR(\"pta ptrs not made\", procName, NULL);\n    }\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaDestroy()\n *\n * \\param[in,out]   pptaa to be nulled\n * \\return  void\n */\nvoid\nptaaDestroy(PTAA  **pptaa)\n{\nl_int32  i;\nPTAA    *ptaa;\n\n    PROCNAME(\"ptaaDestroy\");\n\n    if (pptaa == NULL) {\n        L_WARNING(\"ptr address is NULL!\\n\", procName);\n        return;\n    }\n\n    if ((ptaa = *pptaa) == NULL)\n        return;\n\n    for (i = 0; i < ptaa->n; i++)\n        ptaDestroy(&ptaa->pta[i]);\n    LEPT_FREE(ptaa->pta);\n\n    LEPT_FREE(ptaa);\n    *pptaa = NULL;\n    return;\n}\n\n\n/*---------------------------------------------------------------------*\n *                          PTAA array extension                       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaAddPta()\n *\n * \\param[in]    ptaa\n * \\param[in]    pta  to be added\n * \\param[in]    copyflag  L_INSERT, L_COPY, L_CLONE\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaaAddPta(PTAA    *ptaa,\n           PTA     *pta,\n           l_int32  copyflag)\n{\nl_int32  n;\nPTA     *ptac;\n\n    PROCNAME(\"ptaaAddPta\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    if (copyflag == L_INSERT) {\n        ptac = pta;\n    } else if (copyflag == L_COPY) {\n        if ((ptac = ptaCopy(pta)) == NULL)\n            return ERROR_INT(\"ptac not made\", procName, 1);\n    } else if (copyflag == L_CLONE) {\n        if ((ptac = ptaClone(pta)) == NULL)\n            return ERROR_INT(\"pta clone not made\", procName, 1);\n    } else {\n        return ERROR_INT(\"invalid copyflag\", procName, 1);\n    }\n\n    n = ptaaGetCount(ptaa);\n    if (n >= ptaa->nalloc)\n        ptaaExtendArray(ptaa);\n    ptaa->pta[n] = ptac;\n    ptaa->n++;\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaExtendArray()\n *\n * \\param[in]    ptaa\n * \\return  0 if OK, 1 on error\n */\nstatic l_int32\nptaaExtendArray(PTAA  *ptaa)\n{\n    PROCNAME(\"ptaaExtendArray\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    if ((ptaa->pta = (PTA **)reallocNew((void **)&ptaa->pta,\n                             sizeof(PTA *) * ptaa->nalloc,\n                             2 * sizeof(PTA *) * ptaa->nalloc)) == NULL)\n        return ERROR_INT(\"new ptr array not returned\", procName, 1);\n\n    ptaa->nalloc = 2 * ptaa->nalloc;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                          Ptaa accessors                             *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaGetCount()\n *\n * \\param[in]    ptaa\n * \\return  count, or 0 if no ptaa\n */\nl_int32\nptaaGetCount(PTAA  *ptaa)\n{\n    PROCNAME(\"ptaaGetCount\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 0);\n\n    return ptaa->n;\n}\n\n\n/*!\n * \\brief   ptaaGetPta()\n *\n * \\param[in]    ptaa\n * \\param[in]    index  to the i-th pta\n * \\param[in]    accessflag  L_COPY or L_CLONE\n * \\return  pta, or NULL on error\n */\nPTA *\nptaaGetPta(PTAA    *ptaa,\n           l_int32  index,\n           l_int32  accessflag)\n{\n    PROCNAME(\"ptaaGetPta\");\n\n    if (!ptaa)\n        return (PTA *)ERROR_PTR(\"ptaa not defined\", procName, NULL);\n    if (index < 0 || index >= ptaa->n)\n        return (PTA *)ERROR_PTR(\"index not valid\", procName, NULL);\n\n    if (accessflag == L_COPY)\n        return ptaCopy(ptaa->pta[index]);\n    else if (accessflag == L_CLONE)\n        return ptaClone(ptaa->pta[index]);\n    else\n        return (PTA *)ERROR_PTR(\"invalid accessflag\", procName, NULL);\n}\n\n\n/*!\n * \\brief   ptaaGetPt()\n *\n * \\param[in]    ptaa\n * \\param[in]    ipta  to the i-th pta\n * \\param[in]    jpt index to the j-th pt in the pta\n * \\param[out]   px [optional] float x value\n * \\param[out]   py [optional] float y value\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaGetPt(PTAA       *ptaa,\n           l_int32     ipta,\n           l_int32     jpt,\n           l_float32  *px,\n           l_float32  *py)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaaGetPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (ipta < 0 || ipta >= ptaa->n)\n        return ERROR_INT(\"index ipta not valid\", procName, 1);\n\n    pta = ptaaGetPta(ptaa, ipta, L_CLONE);\n    if (jpt < 0 || jpt >= pta->n) {\n        ptaDestroy(&pta);\n        return ERROR_INT(\"index jpt not valid\", procName, 1);\n    }\n\n    ptaGetPt(pta, jpt, px, py);\n    ptaDestroy(&pta);\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                        Ptaa array modifiers                         *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaInitFull()\n *\n * \\param[in]    ptaa can have non-null ptrs in the ptr array\n * \\param[in]    pta to be replicated into the entire ptr array\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaInitFull(PTAA  *ptaa,\n             PTA   *pta)\n{\nl_int32  n, i;\nPTA     *ptat;\n\n    PROCNAME(\"ptaaInitFull\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    n = ptaa->nalloc;\n    ptaa->n = n;\n    for (i = 0; i < n; i++) {\n        ptat = ptaCopy(pta);\n        ptaaReplacePta(ptaa, i, ptat);\n    }\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaReplacePta()\n *\n * \\param[in]    ptaa\n * \\param[in]    index  to the index-th pta\n * \\param[in]    pta insert and replace any existing one\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Any existing pta is destroyed, and the input one\n *          is inserted in its place.\n *      (2) If the index is invalid, return 1 (error)\n * </pre>\n */\nl_int32\nptaaReplacePta(PTAA    *ptaa,\n               l_int32  index,\n               PTA     *pta)\n{\nl_int32  n;\n\n    PROCNAME(\"ptaaReplacePta\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaaGetCount(ptaa);\n    if (index < 0 || index >= n)\n        return ERROR_INT(\"index not valid\", procName, 1);\n\n    ptaDestroy(&ptaa->pta[index]);\n    ptaa->pta[index] = pta;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaAddPt()\n *\n * \\param[in]    ptaa\n * \\param[in]    ipta  to the i-th pta\n * \\param[in]    x,y point coordinates\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaAddPt(PTAA      *ptaa,\n          l_int32    ipta,\n          l_float32  x,\n          l_float32  y)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaaAddPt\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (ipta < 0 || ipta >= ptaa->n)\n        return ERROR_INT(\"index ipta not valid\", procName, 1);\n\n    pta = ptaaGetPta(ptaa, ipta, L_CLONE);\n    ptaAddPt(pta, x, y);\n    ptaDestroy(&pta);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaTruncate()\n *\n * \\param[in]    ptaa\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This identifies the largest index containing a pta that\n *          has any points within it, destroys all pta above that index,\n *          and resets the count.\n * </pre>\n */\nl_int32\nptaaTruncate(PTAA  *ptaa)\n{\nl_int32  i, n, np;\nPTA     *pta;\n\n    PROCNAME(\"ptaaTruncate\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    n = ptaaGetCount(ptaa);\n    for (i = n - 1; i >= 0; i--) {\n        pta = ptaaGetPta(ptaa, i, L_CLONE);\n        if (!pta) {\n            ptaa->n--;\n            continue;\n        }\n        np = ptaGetCount(pta);\n        ptaDestroy(&pta);\n        if (np == 0) {\n            ptaDestroy(&ptaa->pta[i]);\n            ptaa->n--;\n        } else {\n            break;\n        }\n    }\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                       Ptaa serialized for I/O                       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaRead()\n *\n * \\param[in]    filename\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaRead(const char  *filename)\n{\nFILE  *fp;\nPTAA  *ptaa;\n\n    PROCNAME(\"ptaaRead\");\n\n    if (!filename)\n        return (PTAA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PTAA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    ptaa = ptaaReadStream(fp);\n    fclose(fp);\n    if (!ptaa)\n        return (PTAA *)ERROR_PTR(\"ptaa not read\", procName, NULL);\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaReadStream(FILE  *fp)\n{\nl_int32  i, n, version;\nPTA     *pta;\nPTAA    *ptaa;\n\n    PROCNAME(\"ptaaReadStream\");\n\n    if (!fp)\n        return (PTAA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\nPtaa Version %d\\n\", &version) != 1)\n        return (PTAA *)ERROR_PTR(\"not a ptaa file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTAA *)ERROR_PTR(\"invalid ptaa version\", procName, NULL);\n    if (fscanf(fp, \"Number of Pta = %d\\n\", &n) != 1)\n        return (PTAA *)ERROR_PTR(\"not a ptaa file\", procName, NULL);\n\n    if ((ptaa = ptaaCreate(n)) == NULL)\n        return (PTAA *)ERROR_PTR(\"ptaa not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if ((pta = ptaReadStream(fp)) == NULL) {\n            ptaaDestroy(&ptaa);\n            return (PTAA *)ERROR_PTR(\"error reading pta\", procName, NULL);\n        }\n        ptaaAddPta(ptaa, pta, L_INSERT);\n    }\n\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaReadMem()\n *\n * \\param[in]    data  serialization in ascii\n * \\param[in]    size  of data in bytes; can use strlen to get it\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaReadMem(const l_uint8  *data,\n            size_t          size)\n{\nFILE  *fp;\nPTAA  *ptaa;\n\n    PROCNAME(\"ptaaReadMem\");\n\n    if (!data)\n        return (PTAA *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if ((fp = fopenReadFromMemory(data, size)) == NULL)\n        return (PTAA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ptaa = ptaaReadStream(fp);\n    fclose(fp);\n    if (!ptaa) L_ERROR(\"ptaa not read\\n\", procName);\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaWrite()\n *\n * \\param[in]    filename\n * \\param[in]    ptaa\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaaWrite(const char  *filename,\n          PTAA        *ptaa,\n          l_int32      type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaaWrite\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(filename, \"w\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaaWriteStream(fp, ptaa, type);\n    fclose(fp);\n    if (ret)\n        return ERROR_INT(\"ptaa not written to stream\", procName, 1);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    ptaa\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaWriteStream(FILE    *fp,\n                PTAA    *ptaa,\n                l_int32  type)\n{\nl_int32  i, n;\nPTA     *pta;\n\n    PROCNAME(\"ptaaWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    n = ptaaGetCount(ptaa);\n    fprintf(fp, \"\\nPtaa Version %d\\n\", PTA_VERSION_NUMBER);\n    fprintf(fp, \"Number of Pta = %d\\n\", n);\n    for (i = 0; i < n; i++) {\n        pta = ptaaGetPta(ptaa, i, L_CLONE);\n        ptaWriteStream(fp, pta, type);\n        ptaDestroy(&pta);\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaWriteMem()\n *\n * \\param[out]   pdata data of serialized ptaa; ascii\n * \\param[out]   psize size of returned data\n * \\param[in]    ptaa\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Serializes a ptaa in memory and puts the result in a buffer.\n * </pre>\n */\nl_int32\nptaaWriteMem(l_uint8  **pdata,\n             size_t    *psize,\n             PTAA      *ptaa,\n             l_int32    type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaaWriteMem\");\n\n    if (pdata) *pdata = NULL;\n    if (psize) *psize = 0;\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n#if HAVE_FMEMOPEN\n    if ((fp = open_memstream((char **)pdata, psize)) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaaWriteStream(fp, ptaa, type);\n#else\n    L_INFO(\"work-around: writing to a temp file\\n\", procName);\n  #ifdef _WIN32\n    if ((fp = fopenWriteWinTempfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #else\n    if ((fp = tmpfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #endif  /* _WIN32 */\n    ret = ptaaWriteStream(fp, ptaa, type);\n    rewind(fp);\n    *pdata = l_binaryReadStream(fp, psize);\n#endif  /* HAVE_FMEMOPEN */\n    fclose(fp);\n    return ret;\n}\n\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n\n/*!\n * \\file sel1.c\n * <pre>\n *\n *      Basic ops on Sels and Selas\n *\n *         Create/destroy/copy:\n *            SELA      *selaCreate()\n *            void       selaDestroy()\n *            SEL       *selCreate()\n *            void       selDestroy()\n *            SEL       *selCopy()\n *            SEL       *selCreateBrick()\n *            SEL       *selCreateComb()\n *\n *         Helper proc:\n *            l_int32  **create2dIntArray()\n *\n *         Extension of sela:\n *            SELA      *selaAddSel()\n *            static l_int32  selaExtendArray()\n *\n *         Accessors:\n *            l_int32    selaGetCount()\n *            SEL       *selaGetSel()\n *            char      *selGetName()\n *            l_int32    selSetName()\n *            l_int32    selaFindSelByName()\n *            l_int32    selGetElement()\n *            l_int32    selSetElement()\n *            l_int32    selGetParameters()\n *            l_int32    selSetOrigin()\n *            l_int32    selGetTypeAtOrigin()\n *            char      *selaGetBrickName()\n *            char      *selaGetCombName()\n *     static char      *selaComputeCompositeParameters()\n *            l_int32    getCompositeParameters()\n *            SARRAY    *selaGetSelnames()\n *\n *         Max translations for erosion and hmt\n *            l_int32    selFindMaxTranslations()\n *\n *         Rotation by multiples of 90 degrees\n *            SEL       *selRotateOrth()\n *\n *         Sela and Sel serialized I/O\n *            SELA      *selaRead()\n *            SELA      *selaReadStream()\n *            SEL       *selRead()\n *            SEL       *selReadStream()\n *            l_int32    selaWrite()\n *            l_int32    selaWriteStream()\n *            l_int32    selWrite()\n *            l_int32    selWriteStream()\n *\n *         Building custom hit-miss sels from compiled strings\n *            SEL       *selCreateFromString()\n *            char      *selPrintToString()     [for debugging]\n *\n *         Building custom hit-miss sels from a simple file format\n *            SELA      *selaCreateFromFile()\n *            static SEL *selCreateFromSArray()\n *\n *         Making hit-only sels from Pta and Pix\n *            SEL       *selCreateFromPta()\n *            SEL       *selCreateFromPix()\n *\n *         Making hit-miss sels from Pix and image files\n *            SEL       *selReadFromColorImage()\n *            SEL       *selCreateFromColorPix()\n *\n *         Printable display of sel\n *            PIX       *selDisplayInPix()\n *            PIX       *selaDisplayInPix()\n *\n *     Usage notes:\n *        In this file we have seven functions that make sels:\n *          (1)  selCreate(), with input (h, w, [name])\n *               The generic function.  Roll your own, using selSetElement().\n *          (2)  selCreateBrick(), with input (h, w, cy, cx, val)\n *               The most popular function.  Makes a rectangular sel of\n *               all hits, misses or don't-cares.  We have many morphology\n *               operations that create a sel of all hits, use it, and\n *               destroy it.\n *          (3)  selCreateFromString() with input (text, h, w, [name])\n *               Adam Langley's clever function, allows you to make a hit-miss\n *               sel from a string in code that is geometrically laid out\n *               just like the actual sel.\n *          (4)  selaCreateFromFile() with input (filename)\n *               This parses a simple file format to create an array of\n *               hit-miss sels.  The sel data uses the same encoding\n *               as in (3), with geometrical layout enforced.\n *          (5)  selCreateFromPta() with input (pta, cy, cx, [name])\n *               Another way to make a sel with only hits.\n *          (6)  selCreateFromPix() with input (pix, cy, cx, [name])\n *               Yet another way to make a sel from hits.\n *          (7)  selCreateFromColorPix() with input (pix, name).\n *               Another way to make a general hit-miss sel, starting with\n *               an image editor.\n *        In addition, there are three functions in selgen.c that\n *        automatically generate a hit-miss sel from a pix and\n *        a number of parameters.  This is useful for problems like\n *        \"find all patterns that look like this one.\"\n *\n *        Consistency, being the hobgoblin of small minds,\n *        is adhered to here in the dimensioning and accessing of sels.\n *        Everything is done in standard matrix (row, column) order.\n *        When we set specific elements in a sel, we likewise use\n *        (row, col) ordering:\n *             selSetElement(), with input (row, col, type)\n * </pre>\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  L_BUF_SIZE = 256;\nstatic const l_int32  INITIAL_PTR_ARRAYSIZE = 50;  /* n'import quoi */\nstatic const l_int32  MANY_SELS = 1000;\n\n    /* Static functions */\nstatic l_int32 selaExtendArray(SELA *sela);\nstatic SEL *selCreateFromSArray(SARRAY *sa, l_int32 first, l_int32 last);\n\nstruct CompParameterMap\n{\n    l_int32  size;\n    l_int32  size1;\n    l_int32  size2;\n    char     selnameh1[20];\n    char     selnameh2[20];\n    char     selnamev1[20];\n    char     selnamev2[20];\n};\n\nstatic const struct CompParameterMap  comp_parameter_map[] =\n    { { 2, 2, 1, \"sel_2h\", \"\", \"sel_2v\", \"\" },\n      { 3, 3, 1, \"sel_3h\", \"\", \"sel_3v\", \"\" },\n      { 4, 2, 2, \"sel_2h\", \"sel_comb_4h\", \"sel_2v\", \"sel_comb_4v\" },\n      { 5, 5, 1, \"sel_5h\", \"\", \"sel_5v\", \"\" },\n      { 6, 3, 2, \"sel_3h\", \"sel_comb_6h\", \"sel_3v\", \"sel_comb_6v\" },\n      { 7, 7, 1, \"sel_7h\", \"\", \"sel_7v\", \"\" },\n      { 8, 4, 2, \"sel_4h\", \"sel_comb_8h\", \"sel_4v\", \"sel_comb_8v\" },\n      { 9, 3, 3, \"sel_3h\", \"sel_comb_9h\", \"sel_3v\", \"sel_comb_9v\" },\n      { 10, 5, 2, \"sel_5h\", \"sel_comb_10h\", \"sel_5v\", \"sel_comb_10v\" },\n      { 11, 4, 3, \"sel_4h\", \"sel_comb_12h\", \"sel_4v\", \"sel_comb_12v\" },\n      { 12, 4, 3, \"sel_4h\", \"sel_comb_12h\", \"sel_4v\", \"sel_comb_12v\" },\n      { 13, 4, 3, \"sel_4h\", \"sel_comb_12h\", \"sel_4v\", \"sel_comb_12v\" },\n      { 14, 7, 2, \"sel_7h\", \"sel_comb_14h\", \"sel_7v\", \"sel_comb_14v\" },\n      { 15, 5, 3, \"sel_5h\", \"sel_comb_15h\", \"sel_5v\", \"sel_comb_15v\" },\n      { 16, 4, 4, \"sel_4h\", \"sel_comb_16h\", \"sel_4v\", \"sel_comb_16v\" },\n      { 17, 4, 4, \"sel_4h\", \"sel_comb_16h\", \"sel_4v\", \"sel_comb_16v\" },\n      { 18, 6, 3, \"sel_6h\", \"sel_comb_18h\", \"sel_6v\", \"sel_comb_18v\" },\n      { 19, 5, 4, \"sel_5h\", \"sel_comb_20h\", \"sel_5v\", \"sel_comb_20v\" },\n      { 20, 5, 4, \"sel_5h\", \"sel_comb_20h\", \"sel_5v\", \"sel_comb_20v\" },\n      { 21, 7, 3, \"sel_7h\", \"sel_comb_21h\", \"sel_7v\", \"sel_comb_21v\" },\n      { 22, 11, 2, \"sel_11h\", \"sel_comb_22h\", \"sel_11v\", \"sel_comb_22v\" },\n      { 23, 6, 4, \"sel_6h\", \"sel_comb_24h\", \"sel_6v\", \"sel_comb_24v\" },\n      { 24, 6, 4, \"sel_6h\", \"sel_comb_24h\", \"sel_6v\", \"sel_comb_24v\" },\n      { 25, 5, 5, \"sel_5h\", \"sel_comb_25h\", \"sel_5v\", \"sel_comb_25v\" },\n      { 26, 5, 5, \"sel_5h\", \"sel_comb_25h\", \"sel_5v\", \"sel_comb_25v\" },\n      { 27, 9, 3, \"sel_9h\", \"sel_comb_27h\", \"sel_9v\", \"sel_comb_27v\" },\n      { 28, 7, 4, \"sel_7h\", \"sel_comb_28h\", \"sel_7v\", \"sel_comb_28v\" },\n      { 29, 6, 5, \"sel_6h\", \"sel_comb_30h\", \"sel_6v\", \"sel_comb_30v\" },\n      { 30, 6, 5, \"sel_6h\", \"sel_comb_30h\", \"sel_6v\", \"sel_comb_30v\" },\n      { 31, 6, 5, \"sel_6h\", \"sel_comb_30h\", \"sel_6v\", \"sel_comb_30v\" },\n      { 32, 8, 4, \"sel_8h\", \"sel_comb_32h\", \"sel_8v\", \"sel_comb_32v\" },\n      { 33, 11, 3, \"sel_11h\", \"sel_comb_33h\", \"sel_11v\", \"sel_comb_33v\" },\n      { 34, 7, 5, \"sel_7h\", \"sel_comb_35h\", \"sel_7v\", \"sel_comb_35v\" },\n      { 35, 7, 5, \"sel_7h\", \"sel_comb_35h\", \"sel_7v\", \"sel_comb_35v\" },\n      { 36, 6, 6, \"sel_6h\", \"sel_comb_36h\", \"sel_6v\", \"sel_comb_36v\" },\n      { 37, 6, 6, \"sel_6h\", \"sel_comb_36h\", \"sel_6v\", \"sel_comb_36v\" },\n      { 38, 6, 6, \"sel_6h\", \"sel_comb_36h\", \"sel_6v\", \"sel_comb_36v\" },\n      { 39, 13, 3, \"sel_13h\", \"sel_comb_39h\", \"sel_13v\", \"sel_comb_39v\" },\n      { 40, 8, 5, \"sel_8h\", \"sel_comb_40h\", \"sel_8v\", \"sel_comb_40v\" },\n      { 41, 7, 6, \"sel_7h\", \"sel_comb_42h\", \"sel_7v\", \"sel_comb_42v\" },\n      { 42, 7, 6, \"sel_7h\", \"sel_comb_42h\", \"sel_7v\", \"sel_comb_42v\" },\n      { 43, 7, 6, \"sel_7h\", \"sel_comb_42h\", \"sel_7v\", \"sel_comb_42v\" },\n      { 44, 11, 4, \"sel_11h\", \"sel_comb_44h\", \"sel_11v\", \"sel_comb_44v\" },\n      { 45, 9, 5, \"sel_9h\", \"sel_comb_45h\", \"sel_9v\", \"sel_comb_45v\" },\n      { 46, 9, 5, \"sel_9h\", \"sel_comb_45h\", \"sel_9v\", \"sel_comb_45v\" },\n      { 47, 8, 6, \"sel_8h\", \"sel_comb_48h\", \"sel_8v\", \"sel_comb_48v\" },\n      { 48, 8, 6, \"sel_8h\", \"sel_comb_48h\", \"sel_8v\", \"sel_comb_48v\" },\n      { 49, 7, 7, \"sel_7h\", \"sel_comb_49h\", \"sel_7v\", \"sel_comb_49v\" },\n      { 50, 10, 5, \"sel_10h\", \"sel_comb_50h\", \"sel_10v\", \"sel_comb_50v\" },\n      { 51, 10, 5, \"sel_10h\", \"sel_comb_50h\", \"sel_10v\", \"sel_comb_50v\" },\n      { 52, 13, 4, \"sel_13h\", \"sel_comb_52h\", \"sel_13v\", \"sel_comb_52v\" },\n      { 53, 9, 6, \"sel_9h\", \"sel_comb_54h\", \"sel_9v\", \"sel_comb_54v\" },\n      { 54, 9, 6, \"sel_9h\", \"sel_comb_54h\", \"sel_9v\", \"sel_comb_54v\" },\n      { 55, 11, 5, \"sel_11h\", \"sel_comb_55h\", \"sel_11v\", \"sel_comb_55v\" },\n      { 56, 8, 7, \"sel_8h\", \"sel_comb_56h\", \"sel_8v\", \"sel_comb_56v\" },\n      { 57, 8, 7, \"sel_8h\", \"sel_comb_56h\", \"sel_8v\", \"sel_comb_56v\" },\n      { 58, 8, 7, \"sel_8h\", \"sel_comb_56h\", \"sel_8v\", \"sel_comb_56v\" },\n      { 59, 10, 6, \"sel_10h\", \"sel_comb_60h\", \"sel_10v\", \"sel_comb_60v\" },\n      { 60, 10, 6, \"sel_10h\", \"sel_comb_60h\", \"sel_10v\", \"sel_comb_60v\" },\n      { 61, 10, 6, \"sel_10h\", \"sel_comb_60h\", \"sel_10v\", \"sel_comb_60v\" },\n      { 62, 9, 7, \"sel_9h\", \"sel_comb_63h\", \"sel_9v\", \"sel_comb_63v\" },\n      { 63, 9, 7, \"sel_9h\", \"sel_comb_63h\", \"sel_9v\", \"sel_comb_63v\" } };\n\n\n\n/*------------------------------------------------------------------------*\n *                      Create / Destroy / Copy                           *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   selaCreate()\n *\n * \\param[in]    n initial number of sel ptrs; use 0 for default\n * \\return  sela, or NULL on error\n */\nSELA *\nselaCreate(l_int32  n)\n{\nSELA  *sela;\n\n    PROCNAME(\"selaCreate\");\n\n    if (n <= 0)\n        n = INITIAL_PTR_ARRAYSIZE;\n    if (n > MANY_SELS)\n        L_WARNING(\"%d sels\\n\", procName, n);\n\n    if ((sela = (SELA *)LEPT_CALLOC(1, sizeof(SELA))) == NULL)\n        return (SELA *)ERROR_PTR(\"sela not made\", procName, NULL);\n\n    sela->nalloc = n;\n    sela->n = 0;\n\n        /* make array of se ptrs */\n    if ((sela->sel = (SEL **)LEPT_CALLOC(n, sizeof(SEL *))) == NULL) {\n        LEPT_FREE(sela);\n        return (SELA *)ERROR_PTR(\"sel ptrs not made\", procName, NULL);\n    }\n    return sela;\n}\n\n\n/*!\n * \\brief   selaDestroy()\n *\n * \\param[in,out]   psela to be nulled\n * \\return  void\n */\nvoid\nselaDestroy(SELA  **psela)\n{\nSELA    *sela;\nl_int32  i;\n\n    if (!psela) return;\n    if ((sela = *psela) == NULL)\n        return;\n\n    for (i = 0; i < sela->n; i++)\n        selDestroy(&sela->sel[i]);\n    LEPT_FREE(sela->sel);\n    LEPT_FREE(sela);\n    *psela = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   selCreate()\n *\n * \\param[in]    height, width\n * \\param[in]    name [optional] sel name; can be null\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) selCreate() initializes all values to 0.\n *      (2) After this call, (cy,cx) and nonzero data values must be\n *          assigned.  If a text name is not assigned here, it will\n *          be needed later when the sel is put into a sela.\n * </pre>\n */\nSEL *\nselCreate(l_int32      height,\n          l_int32      width,\n          const char  *name)\n{\nSEL  *sel;\n\n    PROCNAME(\"selCreate\");\n\n    if ((sel = (SEL *)LEPT_CALLOC(1, sizeof(SEL))) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    if (name)\n        sel->name = stringNew(name);\n    sel->sy = height;\n    sel->sx = width;\n    if ((sel->data = create2dIntArray(height, width)) == NULL) {\n        LEPT_FREE(sel->name);\n        LEPT_FREE(sel);\n        return (SEL *)ERROR_PTR(\"data not allocated\", procName, NULL);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selDestroy()\n *\n * \\param[in,out]   psel to be nulled\n * \\return  void\n */\nvoid\nselDestroy(SEL  **psel)\n{\nl_int32  i;\nSEL     *sel;\n\n    PROCNAME(\"selDestroy\");\n\n    if (psel == NULL)  {\n        L_WARNING(\"ptr address is NULL!\\n\", procName);\n        return;\n    }\n    if ((sel = *psel) == NULL)\n        return;\n\n    for (i = 0; i < sel->sy; i++)\n        LEPT_FREE(sel->data[i]);\n    LEPT_FREE(sel->data);\n    if (sel->name)\n        LEPT_FREE(sel->name);\n    LEPT_FREE(sel);\n\n    *psel = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   selCopy()\n *\n * \\param[in]    sel\n * \\return  a copy of the sel, or NULL on error\n */\nSEL *\nselCopy(SEL  *sel)\n{\nl_int32  sx, sy, cx, cy, i, j;\nSEL     *csel;\n\n    PROCNAME(\"selCopy\");\n\n    if (!sel)\n        return (SEL *)ERROR_PTR(\"sel not defined\", procName, NULL);\n\n    if ((csel = (SEL *)LEPT_CALLOC(1, sizeof(SEL))) == NULL)\n        return (SEL *)ERROR_PTR(\"csel not made\", procName, NULL);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    csel->sy = sy;\n    csel->sx = sx;\n    csel->cy = cy;\n    csel->cx = cx;\n\n    if ((csel->data = create2dIntArray(sy, sx)) == NULL) {\n        LEPT_FREE(csel);\n        return (SEL *)ERROR_PTR(\"sel data not made\", procName, NULL);\n    }\n\n    for (i = 0; i < sy; i++)\n        for (j = 0; j < sx; j++)\n            csel->data[i][j] = sel->data[i][j];\n\n    if (sel->name)\n        csel->name = stringNew(sel->name);\n\n    return csel;\n}\n\n\n/*!\n * \\brief   selCreateBrick()\n *\n * \\param[in]    h, w    height, width\n * \\param[in]    cy, cx  origin, relative to UL corner at 0,0\n * \\param[in]    type    SEL_HIT, SEL_MISS, or SEL_DONT_CARE\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is a rectangular sel of all hits, misses or don't cares.\n * </pre>\n */\nSEL *\nselCreateBrick(l_int32  h,\n               l_int32  w,\n               l_int32  cy,\n               l_int32  cx,\n               l_int32  type)\n{\nl_int32  i, j;\nSEL     *sel;\n\n    PROCNAME(\"selCreateBrick\");\n\n    if (h <= 0 || w <= 0)\n        return (SEL *)ERROR_PTR(\"h and w must both be > 0\", procName, NULL);\n    if (type != SEL_HIT && type != SEL_MISS && type != SEL_DONT_CARE)\n        return (SEL *)ERROR_PTR(\"invalid sel element type\", procName, NULL);\n\n    if ((sel = selCreate(h, w, NULL)) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < h; i++)\n        for (j = 0; j < w; j++)\n            sel->data[i][j] = type;\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selCreateComb()\n *\n * \\param[in]    factor1 contiguous space between comb tines\n * \\param[in]    factor2 number of comb tines\n * \\param[in]    direction L_HORIZ, L_VERT\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This generates a comb Sel of hits with the origin as\n *          near the center as possible.\n *      (2) In use, this is complemented by a brick sel of size %factor1,\n *          Both brick and comb sels are made by selectComposableSels().\n * </pre>\n */\nSEL *\nselCreateComb(l_int32  factor1,\n              l_int32  factor2,\n              l_int32  direction)\n{\nl_int32  i, size, z;\nSEL     *sel;\n\n    PROCNAME(\"selCreateComb\");\n\n    if (factor1 < 1 || factor2 < 1)\n        return (SEL *)ERROR_PTR(\"factors must be >= 1\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (SEL *)ERROR_PTR(\"invalid direction\", procName, NULL);\n\n    size = factor1 * factor2;\n    if (direction == L_HORIZ) {\n        sel = selCreate(1, size, NULL);\n        selSetOrigin(sel, 0, size / 2);\n    } else {\n        sel = selCreate(size, 1, NULL);\n        selSetOrigin(sel, size / 2, 0);\n    }\n\n        /* Lay down the elements of the comb */\n    for (i = 0; i < factor2; i++) {\n        z = factor1 / 2 + i * factor1;\n/*        fprintf(stderr, \"i = %d, factor1 = %d, factor2 = %d, z = %d\\n\",\n                        i, factor1, factor2, z); */\n        if (direction == L_HORIZ)\n            selSetElement(sel, 0, z, SEL_HIT);\n        else\n            selSetElement(sel, z, 0, SEL_HIT);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   create2dIntArray()\n *\n * \\param[in]    sy rows == height\n * \\param[in]    sx columns == width\n * \\return  doubly indexed array i.e., an array of sy row pointers,\n *              each of which points to an array of sx ints\n *\n * <pre>\n * Notes:\n *      (1) The array[sy][sx] is indexed in standard \"matrix notation\",\n *          with the row index first.\n * </pre>\n */\nl_int32 **\ncreate2dIntArray(l_int32  sy,\n                 l_int32  sx)\n{\nl_int32    i, j, success;\nl_int32  **array;\n\n    PROCNAME(\"create2dIntArray\");\n\n    if ((array = (l_int32 **)LEPT_CALLOC(sy, sizeof(l_int32 *))) == NULL)\n        return (l_int32 **)ERROR_PTR(\"ptr array not made\", procName, NULL);\n\n    success = TRUE;\n    for (i = 0; i < sy; i++) {\n        if ((array[i] = (l_int32 *)LEPT_CALLOC(sx, sizeof(l_int32))) == NULL) {\n            success = FALSE;\n            break;\n        }\n    }\n    if (success) return array;\n\n        /* Cleanup after error */\n    for (j = 0; j < i; j++)\n        LEPT_FREE(array[j]);\n    LEPT_FREE(array);\n    return (l_int32 **)ERROR_PTR(\"array not made\", procName, NULL);\n}\n\n\n\n/*------------------------------------------------------------------------*\n *                           Extension of sela                            *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   selaAddSel()\n *\n * \\param[in]    sela\n * \\param[in]    sel to be added\n * \\param[in]    selname ignored if already defined in sel;\n *                       req'd in sel when added to a sela\n * \\param[in]    copyflag  L_INSERT or L_COPY\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This adds a sel, either inserting or making a copy.\n *      (2) Because every sel in a sela must have a name, it copies\n *          the input name if necessary.  You can input NULL for\n *          selname if the sel already has a name.\n * </pre>\n */\nl_int32\nselaAddSel(SELA        *sela,\n           SEL         *sel,\n           const char  *selname,\n           l_int32      copyflag)\n{\nl_int32  n;\nSEL     *csel;\n\n    PROCNAME(\"selaAddSel\");\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (!sel->name && !selname)\n        return ERROR_INT(\"added sel must have name\", procName, 1);\n    if (copyflag != L_INSERT && copyflag != L_COPY)\n        return ERROR_INT(\"invalid copyflag\", procName, 1);\n\n    if (copyflag == L_COPY) {\n        if ((csel = selCopy(sel)) == NULL)\n            return ERROR_INT(\"csel not made\", procName, 1);\n    } else {  /* copyflag == L_INSERT */\n        csel = sel;\n    }\n    if (!csel->name)\n        csel->name = stringNew(selname);\n\n    n = selaGetCount(sela);\n    if (n >= sela->nalloc)\n        selaExtendArray(sela);\n    sela->sel[n] = csel;\n    sela->n++;\n\n    return 0;\n}\n\n\n/*!\n * \\brief   selaExtendArray()\n *\n * \\param[in]    sela\n * \\return  0 if OK; 1 on error\n */\nstatic l_int32\nselaExtendArray(SELA  *sela)\n{\n    PROCNAME(\"selaExtendArray\");\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    if ((sela->sel = (SEL **)reallocNew((void **)&sela->sel,\n                              sizeof(SEL *) * sela->nalloc,\n                              2 * sizeof(SEL *) * sela->nalloc)) == NULL)\n            return ERROR_INT(\"new ptr array not returned\", procName, 1);\n\n    sela->nalloc = 2 * sela->nalloc;\n    return 0;\n}\n\n\n\n/*----------------------------------------------------------------------*\n *                               Accessors                              *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selaGetCount()\n *\n * \\param[in]    sela\n * \\return  count, or 0 on error\n */\nl_int32\nselaGetCount(SELA  *sela)\n{\n    PROCNAME(\"selaGetCount\");\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 0);\n\n    return sela->n;\n}\n\n\n/*!\n * \\brief   selaGetSel()\n *\n * \\param[in]    sela\n * \\param[in]    i index of sel to be retrieved not copied\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This returns a ptr to the sel, not a copy, so the caller\n *          must not destroy it!\n * </pre>\n */\nSEL *\nselaGetSel(SELA    *sela,\n           l_int32  i)\n{\n    PROCNAME(\"selaGetSel\");\n\n    if (!sela)\n        return (SEL *)ERROR_PTR(\"sela not defined\", procName, NULL);\n\n    if (i < 0 || i >= sela->n)\n        return (SEL *)ERROR_PTR(\"invalid index\", procName, NULL);\n    return sela->sel[i];\n}\n\n\n/*!\n * \\brief   selGetName()\n *\n * \\param[in]    sel\n * \\return  sel name not copied, or NULL if no name or on error\n */\nchar *\nselGetName(SEL  *sel)\n{\n    PROCNAME(\"selGetName\");\n\n    if (!sel)\n        return (char *)ERROR_PTR(\"sel not defined\", procName, NULL);\n\n    return sel->name;\n}\n\n\n/*!\n * \\brief   selSetName()\n *\n * \\param[in]    sel\n * \\param[in]    name [optional]; can be null\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Always frees the existing sel name, if defined.\n *      (2) If name is not defined, just clears any existing sel name.\n * </pre>\n */\nl_int32\nselSetName(SEL         *sel,\n           const char  *name)\n{\n    PROCNAME(\"selSetName\");\n\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n\n    return stringReplace(&sel->name, name);\n}\n\n\n/*!\n * \\brief   selaFindSelByName()\n *\n * \\param[in]    sela\n * \\param[in]    name sel name\n * \\param[out]   pindex [optional]\n * \\param[in]    psel   [optional] sel (not a copy)\n * \\return  0 if OK; 1 on error\n */\nl_int32\nselaFindSelByName(SELA        *sela,\n                  const char  *name,\n                  l_int32     *pindex,\n                  SEL        **psel)\n{\nl_int32  i, n;\nchar    *sname;\nSEL     *sel;\n\n    PROCNAME(\"selaFindSelByName\");\n\n    if (pindex) *pindex = -1;\n    if (psel) *psel = NULL;\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    n = selaGetCount(sela);\n    for (i = 0; i < n; i++)\n    {\n        if ((sel = selaGetSel(sela, i)) == NULL) {\n            L_WARNING(\"missing sel\\n\", procName);\n            continue;\n        }\n\n        sname = selGetName(sel);\n        if (sname && (!strcmp(name, sname))) {\n            if (pindex)\n                *pindex = i;\n            if (psel)\n                *psel = sel;\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n\n/*!\n * \\brief   selGetElement()\n *\n * \\param[in]    sel\n * \\param[in]    row\n * \\param[in]    col\n * \\param[out]   ptype  SEL_HIT, SEL_MISS, SEL_DONT_CARE\n * \\return  0 if OK; 1 on error\n */\nl_int32\nselGetElement(SEL      *sel,\n              l_int32   row,\n              l_int32   col,\n              l_int32  *ptype)\n{\n    PROCNAME(\"selGetElement\");\n\n    if (!ptype)\n        return ERROR_INT(\"&type not defined\", procName, 1);\n    *ptype = SEL_DONT_CARE;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (row < 0 || row >= sel->sy)\n        return ERROR_INT(\"sel row out of bounds\", procName, 1);\n    if (col < 0 || col >= sel->sx)\n        return ERROR_INT(\"sel col out of bounds\", procName, 1);\n\n    *ptype = sel->data[row][col];\n    return 0;\n}\n\n\n/*!\n * \\brief   selSetElement()\n *\n * \\param[in]    sel\n * \\param[in]    row\n * \\param[in]    col\n * \\param[in]    type  SEL_HIT, SEL_MISS, SEL_DONT_CARE\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Because we use row and column to index into an array,\n *          they are always non-negative.  The location of the origin\n *          (and the type of operation) determine the actual\n *          direction of the rasterop.\n * </pre>\n */\nl_int32\nselSetElement(SEL     *sel,\n              l_int32  row,\n              l_int32  col,\n              l_int32  type)\n{\n    PROCNAME(\"selSetElement\");\n\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (type != SEL_HIT && type != SEL_MISS && type != SEL_DONT_CARE)\n        return ERROR_INT(\"invalid sel element type\", procName, 1);\n    if (row < 0 || row >= sel->sy)\n        return ERROR_INT(\"sel row out of bounds\", procName, 1);\n    if (col < 0 || col >= sel->sx)\n        return ERROR_INT(\"sel col out of bounds\", procName, 1);\n\n    sel->data[row][col] = type;\n    return 0;\n}\n\n\n/*!\n * \\brief   selGetParameters()\n *\n * \\param[in]    sel\n * \\param[out]   psy, psx, pcy, pcx [optional]  each can be null\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselGetParameters(SEL      *sel,\n                 l_int32  *psy,\n                 l_int32  *psx,\n                 l_int32  *pcy,\n                 l_int32  *pcx)\n{\n    PROCNAME(\"selGetParameters\");\n\n    if (psy) *psy = 0;\n    if (psx) *psx = 0;\n    if (pcy) *pcy = 0;\n    if (pcx) *pcx = 0;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (psy) *psy = sel->sy;\n    if (psx) *psx = sel->sx;\n    if (pcy) *pcy = sel->cy;\n    if (pcx) *pcx = sel->cx;\n    return 0;\n}\n\n\n/*!\n * \\brief   selSetOrigin()\n *\n * \\param[in]    sel\n * \\param[in]    cy, cx\n * \\return  0 if OK; 1 on error\n */\nl_int32\nselSetOrigin(SEL     *sel,\n             l_int32  cy,\n             l_int32  cx)\n{\n    PROCNAME(\"selSetOrigin\");\n\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    sel->cy = cy;\n    sel->cx = cx;\n    return 0;\n}\n\n\n/*!\n * \\brief   selGetTypeAtOrigin()\n *\n * \\param[in]    sel\n * \\param[out]   ptype  SEL_HIT, SEL_MISS, SEL_DONT_CARE\n * \\return  0 if OK; 1 on error or if origin is not found\n */\nl_int32\nselGetTypeAtOrigin(SEL      *sel,\n                   l_int32  *ptype)\n{\nl_int32  sx, sy, cx, cy, i, j;\n\n    PROCNAME(\"selGetTypeAtOrigin\");\n\n    if (!ptype)\n        return ERROR_INT(\"&type not defined\", procName, 1);\n    *ptype = SEL_DONT_CARE;  /* init */\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            if (i == cy && j == cx) {\n                selGetElement(sel, i, j, ptype);\n                return 0;\n            }\n        }\n    }\n\n    return ERROR_INT(\"sel origin not found\", procName, 1);\n}\n\n\n/*!\n * \\brief   selaGetBrickName()\n *\n * \\param[in]    sela\n * \\param[in]    hsize, vsize of brick sel\n * \\return  sel name new string, or NULL if no name or on error\n */\nchar *\nselaGetBrickName(SELA    *sela,\n                 l_int32  hsize,\n                 l_int32  vsize)\n{\nl_int32  i, nsels, sx, sy;\nSEL     *sel;\n\n    PROCNAME(\"selaGetBrickName\");\n\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (hsize == sx && vsize == sy)\n            return stringNew(selGetName(sel));\n    }\n\n    return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}\n\n\n/*!\n * \\brief   selaGetCombName()\n *\n * \\param[in]    sela\n * \\param[in]    size the product of sizes of the brick and comb parts\n * \\param[in]    direction L_HORIZ, L_VERT\n * \\return  sel name new string, or NULL if name not found or on error\n *\n * <pre>\n * Notes:\n *      (1) Combs are by definition 1-dimensional, either horiz or vert.\n *      (2) Use this with comb Sels; e.g., from selaAddDwaCombs().\n * </pre>\n */\nchar *\nselaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n\n    PROCNAME(\"selaGetCombName\");\n\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n\n        /* Derive the comb name we're looking for */\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  /* direction == L_VERT */\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  /* 2-D; not a comb */\n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}\n\n\n/* --------- Function used to generate code in this file  ---------- */\n#if 0\nstatic void selaComputeCompositeParameters(const char *fileout);\n\n/*!\n * \\brief   selaComputeCompParameters()\n *\n * \\param[in]    output filename\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) This static function was used to construct the comp_parameter_map[]\n *          array at the top of this file.  It is static because it does\n *          not need to be called again.  It remains here to show how\n *          the composite parameter map was computed.\n *      (2) The output file was pasted directly into comp_parameter_map[].\n *          The composite parameter map is used to quickly determine\n *          the linear decomposition parameters and sel names.\n * </pre>\n */\nstatic void\nselaComputeCompositeParameters(const char  *fileout)\n{\nchar    *str, *nameh1, *nameh2, *namev1, *namev2;\nchar     buf[L_BUF_SIZE];\nl_int32  size, size1, size2, len;\nSARRAY  *sa;\nSELA    *selabasic, *selacomb;\n\n    selabasic = selaAddBasic(NULL);\n    selacomb = selaAddDwaCombs(NULL);\n    sa = sarrayCreate(64);\n    for (size = 2; size < 64; size++) {\n        selectComposableSizes(size, &size1, &size2);\n        nameh1 = selaGetBrickName(selabasic, size1, 1);\n        namev1 = selaGetBrickName(selabasic, 1, size1);\n        if (size2 > 1) {\n            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);\n            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);\n        } else {\n            nameh2 = stringNew(\"\");\n            namev2 = stringNew(\"\");\n        }\n        snprintf(buf, L_BUF_SIZE,\n                 \"      { %d, %d, %d, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\",\n                 size, size1, size2, nameh1, nameh2, namev1, namev2);\n        sarrayAddString(sa, buf, L_COPY);\n        LEPT_FREE(nameh1);\n        LEPT_FREE(nameh2);\n        LEPT_FREE(namev1);\n        LEPT_FREE(namev2);\n    }\n    str = sarrayToString(sa, 1);\n    len = strlen(str);\n    l_binaryWrite(fileout, \"w\", str, len + 1);\n    LEPT_FREE(str);\n    sarrayDestroy(&sa);\n    selaDestroy(&selabasic);\n    selaDestroy(&selacomb);\n    return;\n}\n#endif\n/* -------------------------------------------------------------------- */\n\n\n/*!\n * \\brief   getCompositeParameters()\n *\n * \\param[in]    size\n * \\param[out]   psize1 [optional] brick factor size\n * \\param[out]   psize2 [optional] comb factor size\n * \\param[out]   pnameh1 [optional] name of horiz brick\n * \\param[out]   pnameh2 [optional] name of horiz comb\n * \\param[out]   pnamev1 [optional] name of vert brick\n * \\param[out]   pnamev2 [optional] name of vert comb\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This uses the big lookup table at the top of this file.\n *      (2) All returned strings are copies that must be freed.\n * </pre>\n */\nl_int32\ngetCompositeParameters(l_int32   size,\n                       l_int32  *psize1,\n                       l_int32  *psize2,\n                       char    **pnameh1,\n                       char    **pnameh2,\n                       char    **pnamev1,\n                       char    **pnamev2)\n{\nl_int32  index;\n\n    PROCNAME(\"selaGetSelnames\");\n\n    if (psize1) *psize1 = 0;\n    if (psize2) *psize2 = 0;\n    if (pnameh1) *pnameh1 = NULL;\n    if (pnameh2) *pnameh2 = NULL;\n    if (pnamev1) *pnamev1 = NULL;\n    if (pnamev2) *pnamev2 = NULL;\n    if (size < 2 || size > 63)\n        return ERROR_INT(\"valid size range is {2 ... 63}\", procName, 1);\n    index = size - 2;\n    if (psize1)\n        *psize1 = comp_parameter_map[index].size1;\n    if (psize2)\n        *psize2 = comp_parameter_map[index].size2;\n    if (pnameh1)\n        *pnameh1 = stringNew(comp_parameter_map[index].selnameh1);\n    if (pnameh2)\n        *pnameh2 = stringNew(comp_parameter_map[index].selnameh2);\n    if (pnamev1)\n        *pnamev1 = stringNew(comp_parameter_map[index].selnamev1);\n    if (pnamev2)\n        *pnamev2 = stringNew(comp_parameter_map[index].selnamev2);\n    return 0;\n}\n\n\n/*!\n * \\brief   selaGetSelnames()\n *\n * \\param[in]    sela\n * \\return  sa of all sel names, or NULL on error\n */\nSARRAY *\nselaGetSelnames(SELA  *sela)\n{\nchar    *selname;\nl_int32  i, n;\nSEL     *sel;\nSARRAY  *sa;\n\n    PROCNAME(\"selaGetSelnames\");\n\n    if (!sela)\n        return (SARRAY *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if ((n = selaGetCount(sela)) == 0)\n        return (SARRAY *)ERROR_PTR(\"no sels in sela\", procName, NULL);\n\n    if ((sa = sarrayCreate(n)) == NULL)\n        return (SARRAY *)ERROR_PTR(\"sa not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        sel = selaGetSel(sela, i);\n        selname = selGetName(sel);\n        sarrayAddString(sa, selname, L_COPY);\n    }\n\n    return sa;\n}\n\n\n\n/*----------------------------------------------------------------------*\n *                Max translations for erosion and hmt                  *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selFindMaxTranslations()\n *\n * \\param[in]    sel\n * \\param[out]   pxp, pyp, pxn, pyn  max shifts\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n          These are the maximum shifts for the erosion operation.\n *        For example, when j < cx, the shift of the image\n *        is +x to the cx.  This is a positive xp shift.\n * </pre>\n */\nl_int32\nselFindMaxTranslations(SEL      *sel,\n                       l_int32  *pxp,\n                       l_int32  *pyp,\n                       l_int32  *pxn,\n                       l_int32  *pyn)\n{\nl_int32  sx, sy, cx, cy, i, j;\nl_int32  maxxp, maxyp, maxxn, maxyn;\n\n    PROCNAME(\"selaFindMaxTranslations\");\n\n    if (!pxp || !pyp || !pxn || !pyn)\n        return ERROR_INT(\"&xp (etc) defined\", procName, 1);\n    *pxp = *pyp = *pxn = *pyn = 0;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n\n    maxxp = maxyp = maxxn = maxyn = 0;\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            if (sel->data[i][j] == 1) {\n                maxxp = L_MAX(maxxp, cx - j);\n                maxyp = L_MAX(maxyp, cy - i);\n                maxxn = L_MAX(maxxn, j - cx);\n                maxyn = L_MAX(maxyn, i - cy);\n            }\n        }\n    }\n\n    *pxp = maxxp;\n    *pyp = maxyp;\n    *pxn = maxxn;\n    *pyn = maxyn;\n\n    return 0;\n}\n\n\n/*----------------------------------------------------------------------*\n *                   Rotation by multiples of 90 degrees                *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selRotateOrth()\n *\n * \\param[in]    sel\n * \\param[in]    quads 0 - 4; number of 90 degree cw rotations\n * \\return  seld, or NULL on error\n */\nSEL  *\nselRotateOrth(SEL     *sel,\n              l_int32  quads)\n{\nl_int32  i, j, ni, nj, sx, sy, cx, cy, nsx, nsy, ncx, ncy, type;\nSEL     *seld;\n\n    PROCNAME(\"selRotateOrth\");\n\n    if (!sel)\n        return (SEL *)ERROR_PTR(\"sel not defined\", procName, NULL);\n    if (quads < 0 || quads > 4)\n        return (SEL *)ERROR_PTR(\"quads not in {0,1,2,3,4}\", procName, NULL);\n    if (quads == 0 || quads == 4)\n        return selCopy(sel);\n\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    if (quads == 1) {  /* 90 degrees cw */\n        nsx = sy;\n        nsy = sx;\n        ncx = sy - cy - 1;\n        ncy = cx;\n    } else if (quads == 2) {  /* 180 degrees cw */\n        nsx = sx;\n        nsy = sy;\n        ncx = sx - cx - 1;\n        ncy = sy - cy - 1;\n    } else {  /* 270 degrees cw */\n        nsx = sy;\n        nsy = sx;\n        ncx = cy;\n        ncy = sx - cx - 1;\n    }\n    seld = selCreateBrick(nsy, nsx, ncy, ncx, SEL_DONT_CARE);\n    if (sel->name)\n        seld->name = stringNew(sel->name);\n\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            selGetElement(sel, i, j, &type);\n            if (quads == 1) {\n               ni = j;\n               nj = sy - i - 1;\n            } else if (quads == 2) {\n               ni = sy - i - 1;\n               nj = sx - j - 1;\n            } else {  /* quads == 3 */\n               ni = sx - j - 1;\n               nj = i;\n            }\n            selSetElement(seld, ni, nj, type);\n        }\n    }\n\n    return seld;\n}\n\n\n/*----------------------------------------------------------------------*\n *                       Sela and Sel serialized I/O                    *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selaRead()\n *\n * \\param[in]    fname filename\n * \\return  sela, or NULL on error\n */\nSELA  *\nselaRead(const char  *fname)\n{\nFILE  *fp;\nSELA  *sela;\n\n    PROCNAME(\"selaRead\");\n\n    if (!fname)\n        return (SELA *)ERROR_PTR(\"fname not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(fname)) == NULL)\n        return (SELA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if ((sela = selaReadStream(fp)) == NULL) {\n        fclose(fp);\n        return (SELA *)ERROR_PTR(\"sela not returned\", procName, NULL);\n    }\n    fclose(fp);\n\n    return sela;\n}\n\n\n/*!\n * \\brief   selaReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  sela, or NULL on error\n */\nSELA  *\nselaReadStream(FILE  *fp)\n{\nl_int32  i, n, version;\nSEL     *sel;\nSELA    *sela;\n\n    PROCNAME(\"selaReadStream\");\n\n    if (!fp)\n        return (SELA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\nSela Version %d\\n\", &version) != 1)\n        return (SELA *)ERROR_PTR(\"not a sela file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SELA *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n    if (fscanf(fp, \"Number of Sels = %d\\n\\n\", &n) != 1)\n        return (SELA *)ERROR_PTR(\"not a sela file\", procName, NULL);\n\n    if ((sela = selaCreate(n)) == NULL)\n        return (SELA *)ERROR_PTR(\"sela not made\", procName, NULL);\n    sela->nalloc = n;\n\n    for (i = 0; i < n; i++) {\n        if ((sel = selReadStream(fp)) == NULL) {\n            selaDestroy(&sela);\n            return (SELA *)ERROR_PTR(\"sel not read\", procName, NULL);\n        }\n        selaAddSel(sela, sel, NULL, 0);\n    }\n\n    return sela;\n}\n\n\n/*!\n * \\brief   selRead()\n *\n * \\param[in]    fname filename\n * \\return  sel, or NULL on error\n */\nSEL  *\nselRead(const char  *fname)\n{\nFILE  *fp;\nSEL   *sel;\n\n    PROCNAME(\"selRead\");\n\n    if (!fname)\n        return (SEL *)ERROR_PTR(\"fname not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(fname)) == NULL)\n        return (SEL *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if ((sel = selReadStream(fp)) == NULL) {\n        fclose(fp);\n        return (SEL *)ERROR_PTR(\"sela not returned\", procName, NULL);\n    }\n    fclose(fp);\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  sel, or NULL on error\n */\nSEL  *\nselReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[L_BUF_SIZE];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n\n    PROCNAME(\"selReadStream\");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n\n    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %s  ------\", selname);\n\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n\n    LEPT_FREE(selname);\n    return sel;\n}\n\n\n/*!\n * \\brief   selaWrite()\n *\n * \\param[in]    fname filename\n * \\param[in]    sela\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselaWrite(const char  *fname,\n          SELA        *sela)\n{\nFILE  *fp;\n\n    PROCNAME(\"selaWrite\");\n\n    if (!fname)\n        return ERROR_INT(\"fname not defined\", procName, 1);\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(fname, \"wb\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    selaWriteStream(fp, sela);\n    fclose(fp);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   selaWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    sela\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselaWriteStream(FILE  *fp,\n                SELA  *sela)\n{\nl_int32  i, n;\nSEL     *sel;\n\n    PROCNAME(\"selaWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    n = selaGetCount(sela);\n    fprintf(fp, \"\\nSela Version %d\\n\", SEL_VERSION_NUMBER);\n    fprintf(fp, \"Number of Sels = %d\\n\\n\", n);\n    for (i = 0; i < n; i++) {\n        if ((sel = selaGetSel(sela, i)) == NULL)\n            continue;\n        selWriteStream(fp, sel);\n    }\n    return 0;\n}\n\n\n/*!\n * \\brief   selWrite()\n *\n * \\param[in]    fname filename\n * \\param[in]    sel\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselWrite(const char  *fname,\n         SEL         *sel)\n{\nFILE  *fp;\n\n    PROCNAME(\"selWrite\");\n\n    if (!fname)\n        return ERROR_INT(\"fname not defined\", procName, 1);\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(fname, \"wb\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    selWriteStream(fp, sel);\n    fclose(fp);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   selWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    sel\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselWriteStream(FILE  *fp,\n               SEL   *sel)\n{\nl_int32  sx, sy, cx, cy, i, j;\n\n    PROCNAME(\"selWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n\n    fprintf(fp, \"  Sel Version %d\\n\", SEL_VERSION_NUMBER);\n    fprintf(fp, \"  ------  %s  ------\\n\", selGetName(sel));\n    fprintf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\", sy, sx, cy, cx);\n    for (i = 0; i < sy; i++) {\n        fprintf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            fprintf(fp, \"%d\", sel->data[i][j]);\n        fprintf(fp, \"\\n\");\n    }\n    fprintf(fp, \"\\n\");\n\n    return 0;\n}\n\n\n/*----------------------------------------------------------------------*\n *           Building custom hit-miss sels from compiled strings        *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selCreateFromString()\n *\n * \\param[in]    text\n * \\param[in]    h, w  height, width\n * \\param[in]    name  [optional] sel name; can be null\n * \\return  sel of the given size, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The text is an array of chars (in row-major order) where\n *          each char can be one of the following:\n *             'x': hit\n *             'o': miss\n *             ' ': don't-care\n *      (2) When the origin falls on a hit or miss, use an upper case\n *          char (e.g., 'X' or 'O') to indicate it.  When the origin\n *          falls on a don't-care, indicate this with a 'C'.\n *          The string must have exactly one origin specified.\n *      (3) The advantage of this method is that the text can be input\n *          in a format that shows the 2D layout of the Sel; e.g.,\n * \\code\n *              static const char *seltext = \"x    \"\n *                                           \"x Oo \"\n *                                           \"x    \"\n *                                           \"xxxxx\";\n * \\endcode\n * </pre>\n */\nSEL *\nselCreateFromString(const char  *text,\n                    l_int32      h,\n                    l_int32      w,\n                    const char  *name)\n{\nSEL     *sel;\nl_int32  y, x, norig;\nchar     ch;\n\n    PROCNAME(\"selCreateFromString\");\n\n    if (h < 1)\n        return (SEL *)ERROR_PTR(\"height must be > 0\", procName, NULL);\n    if (w < 1)\n        return (SEL *)ERROR_PTR(\"width must be > 0\", procName, NULL);\n\n    sel = selCreate(h, w, name);\n\n    norig = 0;\n    for (y = 0; y < h; ++y) {\n        for (x = 0; x < w; ++x) {\n            ch = *(text++);\n            switch (ch)\n            {\n                case 'X':\n                    norig++;\n                    selSetOrigin(sel, y, x);\n                case 'x':\n                    selSetElement(sel, y, x, SEL_HIT);\n                    break;\n\n                case 'O':\n                    norig++;\n                    selSetOrigin(sel, y, x);\n                case 'o':\n                    selSetElement(sel, y, x, SEL_MISS);\n                    break;\n\n                case 'C':\n                    norig++;\n                    selSetOrigin(sel, y, x);\n                case ' ':\n                    selSetElement(sel, y, x, SEL_DONT_CARE);\n                    break;\n\n                case '\\n':\n                    /* ignored */\n                    continue;\n\n                default:\n                    selDestroy(&sel);\n                    return (SEL *)ERROR_PTR(\"unknown char\", procName, NULL);\n            }\n        }\n    }\n    if (norig != 1) {\n        L_ERROR(\"Exactly one origin must be specified; this string has %d\\n\",\n                procName, norig);\n        selDestroy(&sel);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selPrintToString()\n *\n * \\param[in]    sel\n * \\return  str string; caller must free\n *\n * <pre>\n * Notes:\n *      (1) This is an inverse function of selCreateFromString.\n *          It prints a textual representation of the SEL to a malloc'd\n *          string.  The format is the same as selCreateFromString\n *          except that newlines are inserted into the output\n *          between rows.\n *      (2) This is useful for debugging.  However, if you want to\n *          save some Sels in a file, put them in a Sela and write\n *          them out with selaWrite().  They can then be read in\n *          with selaRead().\n * </pre>\n */\nchar *\nselPrintToString(SEL  *sel)\n{\nchar     is_center;\nchar    *str, *strptr;\nl_int32  type;\nl_int32  sx, sy, cx, cy, x, y;\n\n    PROCNAME(\"selPrintToString\");\n\n    if (!sel)\n        return (char *)ERROR_PTR(\"sel not defined\", procName, NULL);\n\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    if ((str = (char *)LEPT_CALLOC(1, sy * (sx + 1) + 1)) == NULL)\n        return (char *)ERROR_PTR(\"calloc fail for str\", procName, NULL);\n    strptr = str;\n\n    for (y = 0; y < sy; ++y) {\n        for (x = 0; x < sx; ++x) {\n            selGetElement(sel, y, x, &type);\n            is_center = (x == cx && y == cy);\n            switch (type) {\n                case SEL_HIT:\n                    *(strptr++) = is_center ? 'X' : 'x';\n                    break;\n                case SEL_MISS:\n                    *(strptr++) = is_center ? 'O' : 'o';\n                    break;\n                case SEL_DONT_CARE:\n                    *(strptr++) = is_center ? 'C' : ' ';\n                    break;\n            }\n        }\n        *(strptr++) = '\\n';\n    }\n\n    return str;\n}\n\n\n/*----------------------------------------------------------------------*\n *         Building custom hit-miss sels from a simple file format      *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selaCreateFromFile()\n *\n * \\param[in]    filename\n * \\return  sela, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The file contains a sequence of Sel descriptions.\n *      (2) Each Sel is formatted as follows:\n *           ~ Any number of comment lines starting with '#' are ignored\n *           ~ The next line contains the selname\n *           ~ The next lines contain the Sel data.  They must be\n *             formatted similarly to the string format in\n *             selCreateFromString(), with each line beginning and\n *             ending with a double-quote, and showing the 2D layout.\n *           ~ Each Sel ends when a blank line, a comment line, or\n *             the end of file is reached.\n *      (3) See selCreateFromString() for a description of the string\n *          format for the Sel data.  As an example, here are the lines\n *          of is a valid file for a single Sel.  In the file, all lines\n *          are left-justified:\n *                    # diagonal sel\n *                    sel_5diag\n *                    \"x    \"\n *                    \" x   \"\n *                    \"  X  \"\n *                    \"   x \"\n *                    \"    x\"\n * </pre>\n */\nSELA *\nselaCreateFromFile(const char  *filename)\n{\nchar    *filestr, *line;\nl_int32  i, n, first, last, nsel, insel;\nsize_t   nbytes;\nNUMA    *nafirst, *nalast;\nSARRAY  *sa;\nSEL     *sel;\nSELA    *sela;\n\n    PROCNAME(\"selaCreateFromFile\");\n\n    if (!filename)\n        return (SELA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    filestr = (char *)l_binaryRead(filename, &nbytes);\n    sa = sarrayCreateLinesFromString(filestr, 1);\n    LEPT_FREE(filestr);\n    n = sarrayGetCount(sa);\n    sela = selaCreate(0);\n\n        /* Find the start and end lines for each Sel.\n         * We allow the \"blank\" lines to be null strings or\n         * to have standard whitespace (' ','\\t',\\'n') or be '#'. */\n    nafirst = numaCreate(0);\n    nalast = numaCreate(0);\n    insel = FALSE;\n    for (i = 0; i < n; i++) {\n        line = sarrayGetString(sa, i, L_NOCOPY);\n        if (!insel &&\n            (line[0] != '\\0' && line[0] != ' ' &&\n             line[0] != '\\t' && line[0] != '\\n' && line[0] != '#')) {\n            numaAddNumber(nafirst, i);\n            insel = TRUE;\n            continue;\n        }\n        if (insel &&\n            (line[0] == '\\0' || line[0] == ' ' ||\n             line[0] == '\\t' || line[0] == '\\n' || line[0] == '#')) {\n            numaAddNumber(nalast, i - 1);\n            insel = FALSE;\n            continue;\n        }\n    }\n    if (insel)  /* fell off the end of the file */\n        numaAddNumber(nalast, n - 1);\n\n        /* Extract sels */\n    nsel = numaGetCount(nafirst);\n    for (i = 0; i < nsel; i++) {\n        numaGetIValue(nafirst, i, &first);\n        numaGetIValue(nalast, i, &last);\n        if ((sel = selCreateFromSArray(sa, first, last)) == NULL) {\n            fprintf(stderr, \"Error reading sel from %d to %d\\n\", first, last);\n            selaDestroy(&sela);\n            sarrayDestroy(&sa);\n            numaDestroy(&nafirst);\n            numaDestroy(&nalast);\n            return (SELA *)ERROR_PTR(\"bad sela file\", procName, NULL);\n        }\n        selaAddSel(sela, sel, NULL, 0);\n    }\n\n    numaDestroy(&nafirst);\n    numaDestroy(&nalast);\n    sarrayDestroy(&sa);\n    return sela;\n}\n\n\n/*!\n * \\brief   selCreateFromSArray()\n *\n * \\param[in]    sa\n * \\param[in]    first line of sarray where Sel begins\n * \\param[in]    last line of sarray where Sel ends\n * \\return  sela, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The Sel contains the following lines:\n *          ~ The first line is the selname\n *          ~ The remaining lines contain the Sel data.  They must\n *            be formatted similarly to the string format in\n *            selCreateFromString(), with each line beginning and\n *            ending with a double-quote, and showing the 2D layout.\n *          ~ 'last' gives the last line in the Sel data.\n *      (2) See selCreateFromString() for a description of the string\n *          format for the Sel data.  As an example, here are the lines\n *          of is a valid file for a single Sel.  In the file, all lines\n *          are left-justified:\n *                    # diagonal sel\n *                    sel_5diag\n *                    \"x    \"\n *                    \" x   \"\n *                    \"  X  \"\n *                    \"   x \"\n *                    \"    x\"\n * </pre>\n */\nstatic SEL *\nselCreateFromSArray(SARRAY  *sa,\n                    l_int32  first,\n                    l_int32  last)\n{\nchar     ch;\nchar    *name, *line;\nl_int32  n, len, i, w, h, y, x;\nSEL     *sel;\n\n    PROCNAME(\"selCreateFromSArray\");\n\n    if (!sa)\n        return (SEL *)ERROR_PTR(\"sa not defined\", procName, NULL);\n    n = sarrayGetCount(sa);\n    if (first < 0 || first >= n || last <= first || last >= n)\n        return (SEL *)ERROR_PTR(\"invalid range\", procName, NULL);\n\n    name = sarrayGetString(sa, first, L_NOCOPY);\n    h = last - first;\n    line = sarrayGetString(sa, first + 1, L_NOCOPY);\n    len = strlen(line);\n    if (line[0] != '\"' || line[len - 1] != '\"')\n        return (SEL *)ERROR_PTR(\"invalid format\", procName, NULL);\n    w = len - 2;\n    if ((sel = selCreate(h, w, name)) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    for (i = first + 1; i <= last; i++) {\n        line = sarrayGetString(sa, i, L_NOCOPY);\n        y = i - first - 1;\n        for (x = 0; x < w; ++x) {\n            ch = line[x + 1];  /* skip the leading double-quote */\n            switch (ch)\n            {\n                case 'X':\n                    selSetOrigin(sel, y, x);  /* set origin and hit */\n                case 'x':\n                    selSetElement(sel, y, x, SEL_HIT);\n                    break;\n\n                case 'O':\n                    selSetOrigin(sel, y, x);  /* set origin and miss */\n                case 'o':\n                    selSetElement(sel, y, x, SEL_MISS);\n                    break;\n\n                case 'C':\n                    selSetOrigin(sel, y, x);  /* set origin and don't-care */\n                case ' ':\n                    selSetElement(sel, y, x, SEL_DONT_CARE);\n                    break;\n\n                default:\n                    selDestroy(&sel);\n                    return (SEL *)ERROR_PTR(\"unknown char\", procName, NULL);\n            }\n        }\n    }\n\n    return sel;\n}\n\n\n/*----------------------------------------------------------------------*\n *               Making hit-only SELs from Pta and Pix                  *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selCreateFromPta()\n *\n * \\param[in]    pta\n * \\param[in]    cy, cx origin of sel\n * \\param[in]    name [optional] sel name; can be null\n * \\return  sel of minimum required size, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The origin and all points in the pta must be positive.\n * </pre>\n */\nSEL *\nselCreateFromPta(PTA         *pta,\n                 l_int32      cy,\n                 l_int32      cx,\n                 const char  *name)\n{\nl_int32  i, n, x, y, w, h;\nBOX     *box;\nSEL     *sel;\n\n    PROCNAME(\"selCreateFromPta\");\n\n    if (!pta)\n        return (SEL *)ERROR_PTR(\"pta not defined\", procName, NULL);\n    if (cy < 0 || cx < 0)\n        return (SEL *)ERROR_PTR(\"(cy, cx) not both >= 0\", procName, NULL);\n    n = ptaGetCount(pta);\n    if (n == 0)\n        return (SEL *)ERROR_PTR(\"no pts in pta\", procName, NULL);\n\n    box = ptaGetBoundingRegion(pta);\n    boxGetGeometry(box, &x, &y, &w, &h);\n    boxDestroy(&box);\n    if (x < 0 || y < 0)\n        return (SEL *)ERROR_PTR(\"not all x and y >= 0\", procName, NULL);\n\n    sel = selCreate(y + h, x + w, name);\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < n; i++) {\n        ptaGetIPt(pta, i, &x, &y);\n        selSetElement(sel, y, x, SEL_HIT);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selCreateFromPix()\n *\n * \\param[in]    pix\n * \\param[in]    cy, cx origin of sel\n * \\param[in]    name [optional] sel name; can be null\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The origin must be positive.\n * </pre>\n */\nSEL *\nselCreateFromPix(PIX         *pix,\n                 l_int32      cy,\n                 l_int32      cx,\n                 const char  *name)\n{\nSEL      *sel;\nl_int32   i, j, w, h, d;\nl_uint32  val;\n\n    PROCNAME(\"selCreateFromPix\");\n\n    if (!pix)\n        return (SEL *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (cy < 0 || cx < 0)\n        return (SEL *)ERROR_PTR(\"(cy, cx) not both >= 0\", procName, NULL);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (d != 1)\n        return (SEL *)ERROR_PTR(\"pix not 1 bpp\", procName, NULL);\n\n    sel = selCreate(h, w, name);\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            pixGetPixel(pix, j, i, &val);\n            if (val)\n                selSetElement(sel, i, j, SEL_HIT);\n        }\n    }\n\n    return sel;\n}\n\n\n/*----------------------------------------------------------------------*\n *            Making hit-miss sels from color Pix and image files             *\n *----------------------------------------------------------------------*/\n/*!\n *\n *  selReadFromColorImage()\n *\n * \\param[in]    pathname\n * \\return  sel if OK; NULL on error\n *\n * <pre>\n * Notes:\n *      (1) Loads an image from a file and creates a (hit-miss) sel.\n *      (2) The sel name is taken from the pathname without the directory\n *          and extension.\n * </pre>\n */\nSEL *\nselReadFromColorImage(const char  *pathname)\n{\nPIX   *pix;\nSEL   *sel;\nchar  *basename, *selname;\n\n    PROCNAME(\"selReadFromColorImage\");\n\n    splitPathAtExtension (pathname, &basename, NULL);\n    splitPathAtDirectory (basename, NULL, &selname);\n    LEPT_FREE(basename);\n\n    if ((pix = pixRead(pathname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"pix not returned\", procName, NULL);\n    }\n    if ((sel = selCreateFromColorPix(pix, selname)) == NULL)\n        L_ERROR(\"sel not made\\n\", procName);\n\n    LEPT_FREE(selname);\n    pixDestroy(&pix);\n    return sel;\n}\n\n\n/*!\n *\n *  selCreateFromColorPix()\n *\n * \\param[in]    pixs cmapped or rgb\n * \\param[in]    selname [optional] sel name; can be null\n * \\return  sel if OK, NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The sel size is given by the size of pixs.\n *      (2) In pixs, hits are represented by green pixels, misses by red\n *          pixels, and don't-cares by white pixels.\n *      (3) In pixs, there may be no misses, but there must be at least 1 hit.\n *      (4) At most there can be only one origin pixel, which is optionally\n *          specified by using a lower-intensity pixel:\n *            if a hit:  dark green\n *            if a miss: dark red\n *            if a don't care: gray\n *          If there is no such pixel, the origin defaults to the approximate\n *          center of the sel.\n * </pre>\n */\nSEL *\nselCreateFromColorPix(PIX   *pixs,\n                      char  *selname)\n{\nPIXCMAP  *cmap;\nSEL      *sel;\nl_int32   hascolor, hasorigin, nohits;\nl_int32   w, h, d, i, j, red, green, blue;\nl_uint32  pixval;\n\n    PROCNAME(\"selCreateFromColorPix\");\n\n    if (!pixs)\n        return (SEL *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n\n    hascolor = FALSE;\n    cmap = pixGetColormap(pixs);\n    if (cmap)\n        pixcmapHasColor(cmap, &hascolor);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (hascolor == FALSE && d != 32)\n        return (SEL *)ERROR_PTR(\"pixs has no color\", procName, NULL);\n\n    if ((sel = selCreate (h, w, NULL)) == NULL)\n        return (SEL *)ERROR_PTR (\"sel not made\", procName, NULL);\n    selSetOrigin (sel, h / 2, w / 2);\n    selSetName(sel, selname);\n\n    hasorigin = FALSE;\n    nohits = TRUE;\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            pixGetPixel (pixs, j, i, &pixval);\n\n            if (cmap) {\n                pixcmapGetColor (cmap, pixval, &red, &green, &blue);\n            } else {\n                red = GET_DATA_BYTE (&pixval, COLOR_RED);\n                green = GET_DATA_BYTE (&pixval, COLOR_GREEN);\n                blue = GET_DATA_BYTE (&pixval, COLOR_BLUE);\n            }\n\n            if (red < 255 && green < 255 && blue < 255) {\n                if (hasorigin)\n                    L_WARNING(\"multiple origins in sel image\\n\", procName);\n                selSetOrigin (sel, i, j);\n                hasorigin = TRUE;\n            }\n            if (!red && green && !blue) {\n                nohits = FALSE;\n                selSetElement (sel, i, j, SEL_HIT);\n            } else if (red && !green && !blue) {\n                selSetElement (sel, i, j, SEL_MISS);\n            } else if (red && green && blue) {\n                selSetElement (sel, i, j, SEL_DONT_CARE);\n            } else {\n                selDestroy(&sel);\n                return (SEL *)ERROR_PTR(\"invalid color\", procName, NULL);\n            }\n        }\n    }\n\n    if (nohits) {\n        selDestroy(&sel);\n        return (SEL *)ERROR_PTR(\"no hits in sel\", procName, NULL);\n    }\n    return sel;\n}\n\n\n/*----------------------------------------------------------------------*\n *                     Printable display of sel                         *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selDisplayInPix()\n *\n * \\param[in]    sel\n * \\param[in]    size of grid interiors; odd; minimum size of 13 is enforced\n * \\param[in]    gthick grid thickness; minimum size of 2 is enforced\n * \\return  pix display of sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a visual representation of a general (hit-miss) sel.\n *      (2) The empty sel is represented by a grid of intersecting lines.\n *      (3) Three different patterns are generated for the sel elements:\n *          ~ hit (solid black circle)\n *          ~ miss (black ring; inner radius is radius2)\n *          ~ origin (cross, XORed with whatever is there)\n * </pre>\n */\nPIX *\nselDisplayInPix(SEL     *sel,\n                l_int32  size,\n                l_int32  gthick)\n{\nl_int32  i, j, w, h, sx, sy, cx, cy, type, width;\nl_int32  radius1, radius2, shift1, shift2, x0, y0;\nPIX     *pixd, *pix2, *pixh, *pixm, *pixorig;\nPTA     *pta1, *pta2, *pta1t, *pta2t;\n\n    PROCNAME(\"selDisplayInPix\");\n\n    if (!sel)\n        return (PIX *)ERROR_PTR(\"sel not defined\", procName, NULL);\n    if (size < 13) {\n        L_WARNING(\"size < 13; setting to 13\\n\", procName);\n        size = 13;\n    }\n    if (size % 2 == 0)\n        size++;\n    if (gthick < 2) {\n        L_WARNING(\"grid thickness < 2; setting to 2\\n\", procName);\n        gthick = 2;\n    }\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    w = size * sx + gthick * (sx + 1);\n    h = size * sy + gthick * (sy + 1);\n    pixd = pixCreate(w, h, 1);\n\n        /* Generate grid lines */\n    for (i = 0; i <= sy; i++)\n        pixRenderLine(pixd, 0, gthick / 2 + i * (size + gthick),\n                      w - 1, gthick / 2 + i * (size + gthick),\n                      gthick, L_SET_PIXELS);\n    for (j = 0; j <= sx; j++)\n        pixRenderLine(pixd, gthick / 2 + j * (size + gthick), 0,\n                      gthick / 2 + j * (size + gthick), h - 1,\n                      gthick, L_SET_PIXELS);\n\n        /* Generate hit and miss patterns */\n    radius1 = (l_int32)(0.85 * ((size - 1) / 2.0) + 0.5);  /* of hit */\n    radius2 = (l_int32)(0.65 * ((size - 1) / 2.0) + 0.5);  /* of inner miss */\n    pta1 = generatePtaFilledCircle(radius1);\n    pta2 = generatePtaFilledCircle(radius2);\n    shift1 = (size - 1) / 2 - radius1;  /* center circle in square */\n    shift2 = (size - 1) / 2 - radius2;\n    pta1t = ptaTransform(pta1, shift1, shift1, 1.0, 1.0);\n    pta2t = ptaTransform(pta2, shift2, shift2, 1.0, 1.0);\n    pixh = pixGenerateFromPta(pta1t, size, size);  /* hits */\n    pix2 = pixGenerateFromPta(pta2t, size, size);\n    pixm = pixSubtract(NULL, pixh, pix2);\n\n        /* Generate crossed lines for origin pattern */\n    pixorig = pixCreate(size, size, 1);\n    width = size / 8;\n    pixRenderLine(pixorig, size / 2, (l_int32)(0.12 * size),\n                           size / 2, (l_int32)(0.88 * size),\n                           width, L_SET_PIXELS);\n    pixRenderLine(pixorig, (l_int32)(0.15 * size), size / 2,\n                           (l_int32)(0.85 * size), size / 2,\n                           width, L_FLIP_PIXELS);\n    pixRasterop(pixorig, size / 2 - width, size / 2 - width,\n                2 * width, 2 * width, PIX_NOT(PIX_DST), NULL, 0, 0);\n\n        /* Specialize origin pattern for this sel */\n    selGetTypeAtOrigin(sel, &type);\n    if (type == SEL_HIT)\n        pixXor(pixorig, pixorig, pixh);\n    else if (type == SEL_MISS)\n        pixXor(pixorig, pixorig, pixm);\n\n        /* Paste the patterns in */\n    y0 = gthick;\n    for (i = 0; i < sy; i++) {\n        x0 = gthick;\n        for (j = 0; j < sx; j++) {\n            selGetElement(sel, i, j, &type);\n            if (i == cy && j == cx)  /* origin */\n                pixRasterop(pixd, x0, y0, size, size, PIX_SRC, pixorig, 0, 0);\n            else if (type == SEL_HIT)\n                pixRasterop(pixd, x0, y0, size, size, PIX_SRC, pixh, 0, 0);\n            else if (type == SEL_MISS)\n                pixRasterop(pixd, x0, y0, size, size, PIX_SRC, pixm, 0, 0);\n            x0 += size + gthick;\n        }\n        y0 += size + gthick;\n    }\n\n    pixDestroy(&pix2);\n    pixDestroy(&pixh);\n    pixDestroy(&pixm);\n    pixDestroy(&pixorig);\n    ptaDestroy(&pta1);\n    ptaDestroy(&pta1t);\n    ptaDestroy(&pta2);\n    ptaDestroy(&pta2t);\n    return pixd;\n}\n\n\n/*!\n * \\brief   selaDisplayInPix()\n *\n * \\param[in]    sela\n * \\param[in]    size of grid interiors; odd; minimum size of 13 is enforced\n * \\param[in]    gthick grid thickness; minimum size of 2 is enforced\n * \\param[in]    spacing between sels, both horizontally and vertically\n * \\param[in]    ncols number of sels per \"line\"\n * \\return  pix display of all sels in sela, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a visual representation of all the sels in a sela.\n *      (2) See notes in selDisplayInPix() for display params of each sel.\n *      (3) This gives the nicest results when all sels in the sela\n *          are the same size.\n * </pre>\n */\nPIX *\nselaDisplayInPix(SELA    *sela,\n                 l_int32  size,\n                 l_int32  gthick,\n                 l_int32  spacing,\n                 l_int32  ncols)\n{\nl_int32  nsels, i, w, width;\nPIX     *pixt, *pixd;\nPIXA    *pixa;\nSEL     *sel;\n\n    PROCNAME(\"selaDisplayInPix\");\n\n    if (!sela)\n        return (PIX *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (size < 13) {\n        L_WARNING(\"size < 13; setting to 13\\n\", procName);\n        size = 13;\n    }\n    if (size % 2 == 0)\n        size++;\n    if (gthick < 2) {\n        L_WARNING(\"grid thickness < 2; setting to 2\\n\", procName);\n        gthick = 2;\n    }\n    if (spacing < 5) {\n        L_WARNING(\"spacing < 5; setting to 5\\n\", procName);\n        spacing = 5;\n    }\n\n        /* Accumulate the pix of each sel */\n    nsels = selaGetCount(sela);\n    pixa = pixaCreate(nsels);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        pixt = selDisplayInPix(sel, size, gthick);\n        pixaAddPix(pixa, pixt, L_INSERT);\n    }\n\n        /* Find the tiled output width, using just the first\n         * ncols pix in the pixa.   If all pix have the same width,\n         * they will align properly in columns. */\n    width = 0;\n    ncols = L_MIN(nsels, ncols);\n    for (i = 0; i < ncols; i++) {\n        pixt = pixaGetPix(pixa, i, L_CLONE);\n        pixGetDimensions(pixt, &w, NULL, NULL);\n        width += w;\n        pixDestroy(&pixt);\n    }\n    width += (ncols + 1) * spacing;  /* add spacing all around as well */\n\n    pixd = pixaDisplayTiledInRows(pixa, 1, width, 1.0, 0, spacing, 0);\n    pixaDestroy(&pixa);\n    return pixd;\n}\n"], "fixing_code": ["# Leptonica Library #\n\n[![Build Status](https://travis-ci.org/DanBloomberg/leptonica.svg?branch=master)](https://travis-ci.org/DanBloomberg/leptonica)\n[![Build status](https://ci.appveyor.com/api/projects/status/vsk607rr6n4j2tmk?svg=true)](https://ci.appveyor.com/project/DanBloomberg/leptonica)\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/leptonica/badge.svg)](https://scan.coverity.com/projects/leptonica)\n\nwww.leptonica.org\n\n## The library supports many operations that are useful on ##\n\n  * Document images\n  * Natural images\n\n## Fundamental image processing and image analysis operations ##\n\n  * Rasterop (aka bitblt)\n  * Affine transforms (scaling, translation, rotation, shear) on images of arbitrary pixel depth\n  * Projective and bilinear transforms\n  * Binary and grayscale morphology, rank order filters, and convolution\n  * Seedfill and connected components\n  * Image transformations with changes in pixel depth, both at the same scale and with scale change\n  * Pixelwise masking, blending, enhancement, arithmetic ops, etc.\n\n## Ancillary utilities ##\n\n  * I/O for standard image formats (_jpg_, _png_, _tiff_, _webp_, _jp2_, _bmp_, _pnm_, _gif_, _ps_, _pdf_)\n  * Utilities to handle arrays of image-related data types (e.g., _pixa_, _boxa_, _pta_)\n  * Utilities for stacks, generic arrays, queues, heaps, lists; number and string arrays; etc.\n\n## Examples of some applications enabled and implemented ##\n\n  * Octcube-based color quantization (w/ and w/out dithering)\n  * Modified median cut color quantization (w/ and w/out dithering)\n  * Skew determination of text images\n  * Adaptive normalization and binarization\n  * Segmentation of page images with mixed text and images\n  * Location of baselines and local skew determination\n  * jbig2 unsupervised classifier\n  * Border representations of 1 bpp images and raster conversion for SVG\n  * Postscript generation (levels 1, 2 and 3) of images for device-independent output\n  * PDF generation (G4, DCT, FLATE) of images for device-independent output\n  * Connectivity-preserving thinning and thickening of 1 bpp images\n  * Image warping (captcha, stereoscopic)\n  * Image dewarping based on content (textlines)\n  * Watershed transform\n  * Greedy splitting of components into rectangles\n  * Location of largest fg or bg rectangles in 1 bpp images\n  * Search for least-cost paths on binary and grayscale images\n  * Barcode reader for 1D barcodes (very early version as of 1.55)\n\n## Implementation characteristics ##\n\n  * _Efficient_: image data is packed binary (into 32-bit words); operations on 32-bit data whenever possible\n  * _Simple_: small number of data structures; simplest implementations provided that are efficient\n  * _Consistent_: data allocated on the heap with simple ownership rules; function names usually begin with primary data structure (e.g., _pix_); simple code patterns throughout\n  * _Robust_: all ptr args checked; extensive use of accessors; exit not permitted\n  * _Tested_: thorough regression tests provided for most basic functions; valgrind tested\n  * _ANSI C_: automatically generated prototype header file\n  * _Portable_: endian-independent; builds in Linux, macOS, MinGW, Cygwin, Windows\n  * _Nearly thread-safe_: ref counting on some structs\n  * _Documentation_: large number of in-line comments; doxygen; web pages for further background\n  * _Examples_: many programs provided to test and show usage of approx. 2600 functions in the library\n\n\n## Open Source Projects that use Leptonica ##\n  * [tesseract](https://github.com/tesseract-ocr/tesseract/) (optical character recognition)\n  * [OpenCV](https://github.com/opencv/opencv) (computer vision library)\n  * [jbig2enc](http://www.imperialviolet.org/jbig2.html) (encodes multipage binary image documents with jbig2 compression)\n  * [php](http://en.wikipedia.org/wiki/PHP)  (scripting language for dynamic web pages)\n\n## Major contributors to Leptonica ##\n  * Tom Powers: Tom has supported Leptonica on Windows for many years.  He has made many contributions to code quality and documentation, including the beautiful \"unofficial documentation\" on the web site. Without his effort, Leptonica would not run today on Windows.\n  * David Bryan: David has worked for years to support Leptonica on multiple platforms. He designed many nice features in Leptonica, such as the severity-based error messaging system, and has identified and fixed countless bugs. And he has built and tested each distribution many times on cross-compilers.\n  * James Le Cuirot: James has written and supported the autotools scripts on Leptonica distributions for many years, and has helped test every distribution since 1.67.\n  * Jeff Breidenbach: Jeff has built every Debian distribution for Leptonica. He has also made many improvements to formatted image I/O, including tiff, png and pdf. He is a continuous advocate for simplification.\n  * Egor Pugin: Egor is co-maintainer of Leptonica on GitHub. He ported everything, including all the old distributions, from Google Code when it shut down. He set Leptonica up for appveyor and travis testing, and has implemented the cppan project, which simplifies building executables on Windows.\n  * J\u00fcrgen Buchm\u00fcller: J\u00fcrgen wrote text converters to modify Leptonica source code so that it generates documentation using doxygen. He also wrote tiff wrappers for memory I/O.\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n * xtractprotos.c\n *\n *   This program accepts a list of C files on the command line\n *   and outputs the C prototypes to stdout.  It uses cpp to\n *   handle the preprocessor macros, and then parses the cpp output.\n *   In leptonica, it is used to make allheaders.h (and optionally\n *   leptprotos.h, which contains just the function prototypes.)\n *   In leptonica, only the file allheaders.h is included with\n *   source files.\n *\n *   An optional 'prestring' can be prepended to each declaration.\n *   And the function prototypes can either be sent to stdout, written\n *   to a named file, or placed in-line within allheaders.h.\n *\n *   The signature is:\n *\n *     xtractprotos [-prestring=<string>] [-protos=<where>] [list of C files]\n *\n *   Without -protos, the prototypes are written to stdout.\n *   With -protos, allheaders.h is rewritten:\n *      * if you use -protos=inline, the prototypes are placed within\n *        allheaders.h.\n *      * if you use -protos=leptprotos.h, the prototypes written to\n *        the file leptprotos.h, and alltypes.h has\n *           #include \"leptprotos.h\"\n *\n *   For constructing allheaders.h, two text files are provided:\n *      allheaders_top.txt\n *      allheaders_bot.txt\n *   The former contains the leptonica version number, so it must\n *   be updated when a new version is made.\n *\n *   For simple C prototype extraction, xtractprotos has essentially\n *   the same functionality as Adam Bryant's cextract, but the latter\n *   has not been officially supported for over 15 years, has been\n *   patched numerous times, and doesn't work with sys/sysmacros.h\n *   for 64 bit architecture.\n *\n *   This is used to extract all prototypes in liblept.\n *   The function that does all the work is parseForProtos(),\n *   which takes as input the output from cpp.\n *\n *   xtractprotos can run in leptonica to do an 'ab initio' generation\n *   of allheaders.h; that is, it can make allheaders.h without\n *   leptprotos.h and with an allheaders.h file of 0 length.\n *   Of course, the usual situation is to run it with a valid allheaders.h,\n *   which includes all the function prototypes.  To avoid including\n *   all the prototypes in the input for each file, cpp runs here\n *   with -DNO_PROTOS, so the prototypes are not included -- this is\n *   much faster.\n *\n *   The xtractprotos version number, defined below, is incremented\n *   whenever a new version is made.\n *\n *   Note: this uses cpp to preprocess the input.  (The name of the cpp\n *   tempfile is constructed below.  It has a \".\" in the tail, which\n *   Cygwin needs to prevent it from appending \".exe\" to the filename.)\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  L_BUFSIZE = 512;  /* hardcoded below in sscanf() */\nstatic const char *version = \"1.5\";\n\n\nint main(int    argc,\n         char **argv)\n{\nchar        *filein, *str, *tempfile, *prestring, *outprotos, *protostr;\nconst char  *spacestr = \" \";\nchar         buf[L_BUFSIZE];\nl_uint8     *allheaders;\nl_int32      i, maxindex, in_line, nflags, protos_added, firstfile, len, ret;\nsize_t       nbytes;\nL_BYTEA     *ba, *ba2;\nSARRAY      *sa, *safirst;\nstatic char  mainName[] = \"xtractprotos\";\n\n    if (argc == 1) {\n        fprintf(stderr,\n                \"xtractprotos [-prestring=<string>] [-protos=<where>] \"\n                \"[list of C files]\\n\"\n                \"where the prestring is prepended to each prototype, and \\n\"\n                \"protos can be either 'inline' or the name of an output \"\n                \"prototype file\\n\");\n        return 1;\n    }\n\n    /* ---------------------------------------------------------------- */\n    /* Parse input flags and find prestring and outprotos, if requested */\n    /* ---------------------------------------------------------------- */\n    prestring = outprotos = NULL;\n    in_line = FALSE;\n    nflags = 0;\n    maxindex = L_MIN(3, argc);\n    for (i = 1; i < maxindex; i++) {\n        if (argv[i][0] == '-') {\n            if (!strncmp(argv[i], \"-prestring\", 10)) {\n                nflags++;\n                ret = sscanf(argv[i] + 1, \"prestring=%490s\", buf);\n                if (ret != 1) {\n                    fprintf(stderr, \"parse failure for prestring\\n\");\n                    return 1;\n                }\n                if ((len = strlen(buf)) > L_BUFSIZE - 3) {\n                    L_WARNING(\"prestring too large; omitting!\\n\", mainName);\n                } else {\n                    buf[len] = ' ';\n                    buf[len + 1] = '\\0';\n                    prestring = stringNew(buf);\n                }\n            } else if (!strncmp(argv[i], \"-protos\", 7)) {\n                nflags++;\n                ret = sscanf(argv[i] + 1, \"protos=%490s\", buf);\n                if (ret != 1) {\n                    fprintf(stderr, \"parse failure for protos\\n\");\n                    return 1;\n                }\n                outprotos = stringNew(buf);\n                if (!strncmp(outprotos, \"inline\", 7))\n                    in_line = TRUE;\n            }\n        }\n    }\n\n    if (argc - nflags < 2) {\n        fprintf(stderr, \"no files specified!\\n\");\n        return 1;\n    }\n\n\n    /* ---------------------------------------------------------------- */\n    /*                   Generate the prototype string                  */\n    /* ---------------------------------------------------------------- */\n    ba = l_byteaCreate(500);\n\n        /* First the extern C head */\n    sa = sarrayCreate(0);\n    sarrayAddString(sa, (char *)\"/*\", L_COPY);\n    snprintf(buf, L_BUFSIZE,\n             \" *  These prototypes were autogen'd by xtractprotos, v. %s\",\n             version);\n    sarrayAddString(sa, buf, L_COPY);\n    sarrayAddString(sa, (char *)\" */\", L_COPY);\n    sarrayAddString(sa, (char *)\"#ifdef __cplusplus\", L_COPY);\n    sarrayAddString(sa, (char *)\"extern \\\"C\\\" {\", L_COPY);\n    sarrayAddString(sa, (char *)\"#endif  /* __cplusplus */\\n\", L_COPY);\n    str = sarrayToString(sa, 1);\n    l_byteaAppendString(ba, str);\n    lept_free(str);\n    sarrayDestroy(&sa);\n\n        /* Then the prototypes */\n    firstfile = 1 + nflags;\n    protos_added = FALSE;\n    if ((tempfile = l_makeTempFilename()) == NULL) {\n        fprintf(stderr, \"failure to make a writeable temp file\\n\");\n        return 1;\n    }\n    for (i = firstfile; i < argc; i++) {\n        filein = argv[i];\n        len = strlen(filein);\n        if (filein[len - 1] == 'h')  /* skip .h files */\n            continue;\n        snprintf(buf, L_BUFSIZE, \"cpp -ansi -DNO_PROTOS %s %s\",\n                 filein, tempfile);\n        ret = system(buf);  /* cpp */\n        if (ret) {\n            fprintf(stderr, \"cpp failure for %s; continuing\\n\", filein);\n            continue;\n        }\n\n        if ((str = parseForProtos(tempfile, prestring)) == NULL) {\n            fprintf(stderr, \"parse failure for %s; continuing\\n\", filein);\n            continue;\n        }\n        if (strlen(str) > 1) {  /* strlen(str) == 1 is a file without protos */\n            l_byteaAppendString(ba, str);\n            protos_added = TRUE;\n        }\n        lept_free(str);\n    }\n    lept_rmfile(tempfile);\n    lept_free(tempfile);\n\n        /* Lastly the extern C tail */\n    sa = sarrayCreate(0);\n    sarrayAddString(sa, (char *)\"\\n#ifdef __cplusplus\", L_COPY);\n    sarrayAddString(sa, (char *)\"}\", L_COPY);\n    sarrayAddString(sa, (char *)\"#endif  /* __cplusplus */\", L_COPY);\n    str = sarrayToString(sa, 1);\n    l_byteaAppendString(ba, str);\n    lept_free(str);\n    sarrayDestroy(&sa);\n\n    protostr = (char *)l_byteaCopyData(ba, &nbytes);\n    l_byteaDestroy(&ba);\n\n\n    /* ---------------------------------------------------------------- */\n    /*                       Generate the output                        */\n    /* ---------------------------------------------------------------- */\n    if (!outprotos) {  /* just write to stdout */\n        fprintf(stderr, \"%s\\n\", protostr);\n        lept_free(protostr);\n        return 0;\n    }\n\n        /* If no protos were found, do nothing further */\n    if (!protos_added) {\n        fprintf(stderr, \"No protos found\\n\");\n        lept_free(protostr);\n        return 1;\n    }\n\n        /* Make the output files */\n    ba = l_byteaInitFromFile(\"allheaders_top.txt\");\n    if (!in_line) {\n        snprintf(buf, sizeof(buf), \"#include \\\"%s\\\"\\n\", outprotos);\n        l_byteaAppendString(ba, buf);\n        l_binaryWrite(outprotos, \"w\", protostr, nbytes);\n    } else {\n        l_byteaAppendString(ba, protostr);\n    }\n    ba2 = l_byteaInitFromFile(\"allheaders_bot.txt\");\n    l_byteaJoin(ba, &ba2);\n    l_byteaWrite(\"allheaders.h\", ba, 0, 0);\n    l_byteaDestroy(&ba);\n    lept_free(protostr);\n    return 0;\n}\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file gplot.c\n * <pre>\n *\n *     Basic plotting functions\n *          GPLOT      *gplotCreate()\n *          void        gplotDestroy()\n *          l_int32     gplotAddPlot()\n *          l_int32     gplotSetScaling()\n *          l_int32     gplotMakeOutput()\n *          l_int32     gplotGenCommandFile()\n *          l_int32     gplotGenDataFiles()\n *\n *     Quick and dirty plots\n *          l_int32     gplotSimple1()\n *          l_int32     gplotSimple2()\n *          l_int32     gplotSimpleN()\n *          l_int32     gplotSimpleXY1()\n *          l_int32     gplotSimpleXY2()\n *          l_int32     gplotSimpleXYN()\n *\n *     Serialize for I/O\n *          GPLOT      *gplotRead()\n *          l_int32     gplotWrite()\n *\n *\n *     Utility for programmatic plotting using gnuplot 4.6 or later\n *     Enabled:\n *         ~ output to png (color), ps and eps (mono), latex (mono)\n *         ~ optional title for graph\n *         ~ optional x and y axis labels\n *         ~ multiple plots on one frame\n *         ~ optional title for each plot on the frame\n *         ~ optional log scaling on either or both axes\n *         ~ choice of 5 plot styles for each plot\n *         ~ choice of 2 plot modes, either using one input array\n *           (Y vs index) or two input arrays (Y vs X).  This\n *           choice is made implicitly depending on the number of\n *           input arrays.\n *\n *     Usage:\n *         gplotCreate() initializes for plotting\n *         gplotAddPlot() for each plot on the frame\n *         gplotMakeOutput() to generate all output files and run gnuplot\n *         gplotDestroy() to clean up\n *\n *     Example of use:\n *         gplot = gplotCreate(\"tempskew\", GPLOT_PNG, \"Skew score vs angle\",\n *                    \"angle (deg)\", \"score\");\n *         gplotAddPlot(gplot, natheta, nascore1, GPLOT_LINES, \"plot 1\");\n *         gplotAddPlot(gplot, natheta, nascore2, GPLOT_POINTS, \"plot 2\");\n *         gplotSetScaling(gplot, GPLOT_LOG_SCALE_Y);\n *         gplotMakeOutput(gplot);\n *         gplotDestroy(&gplot);\n *\n *     Note for output to GPLOT_LATEX:\n *         This creates latex output of the plot, named <rootname>.tex.\n *         It needs to be placed in a latex file <latexname>.tex\n *         that precedes the plot output with, at a minimum:\n *           \\documentclass{article}\n *           \\begin{document}\n *         and ends with\n *           \\end{document}\n *         You can then generate a dvi file <latexname>.dvi using\n *           latex <latexname>.tex\n *         and a PostScript file <psname>.ps from that using\n *           dvips -o <psname>.ps <latexname>.dvi\n *\n *     N.B. To generate plots, it is necessary to have gnuplot installed on\n *          your Unix system, or wgnuplot on Windows.\n * </pre>\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  L_BUFSIZE = 512;  /* hardcoded below in fscanf */\n\nconst char  *gplotstylenames[] = {\"with lines\",\n                                  \"with points\",\n                                  \"with impulses\",\n                                  \"with linespoints\",\n                                  \"with dots\"};\nconst char  *gplotfileoutputs[] = {\"\",\n                                   \"PNG\",\n                                   \"PS\",\n                                   \"EPS\",\n                                   \"LATEX\"};\n\n\n/*-----------------------------------------------------------------*\n *                       Basic Plotting Functions                  *\n *-----------------------------------------------------------------*/\n/*!\n * \\brief   gplotCreate()\n *\n * \\param[in]    rootname root for all output files\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    title  [optional] overall title\n * \\param[in]    xlabel [optional] x axis label\n * \\param[in]    ylabel [optional] y axis label\n * \\return  gplot, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This initializes the plot.\n *      (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,\n *          double quotes and backquotes, but not single quotes.\n * </pre>\n */\nGPLOT  *\ngplotCreate(const char  *rootname,\n            l_int32      outformat,\n            const char  *title,\n            const char  *xlabel,\n            const char  *ylabel)\n{\nchar    *newroot;\nchar     buf[L_BUFSIZE];\nl_int32  badchar;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotCreate\");\n\n    if (!rootname)\n        return (GPLOT *)ERROR_PTR(\"rootname not defined\", procName, NULL);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return (GPLOT *)ERROR_PTR(\"outformat invalid\", procName, NULL);\n    stringCheckForChars(rootname, \"`;&|><\\\"?*\", &badchar);\n    if (badchar)  /* danger of command injection */\n        return (GPLOT *)ERROR_PTR(\"invalid rootname\", procName, NULL);\n\n    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    gplot->cmddata = sarrayCreate(0);\n    gplot->datanames = sarrayCreate(0);\n    gplot->plotdata = sarrayCreate(0);\n    gplot->plottitles = sarrayCreate(0);\n    gplot->plotstyles = numaCreate(0);\n\n        /* Save title, labels, rootname, outformat, cmdname, outname */\n    newroot = genPathname(rootname, NULL);\n    gplot->rootname = newroot;\n    gplot->outformat = outformat;\n    snprintf(buf, L_BUFSIZE, \"%s.cmd\", rootname);\n    gplot->cmdname = stringNew(buf);\n    if (outformat == GPLOT_PNG)\n        snprintf(buf, L_BUFSIZE, \"%s.png\", newroot);\n    else if (outformat == GPLOT_PS)\n        snprintf(buf, L_BUFSIZE, \"%s.ps\", newroot);\n    else if (outformat == GPLOT_EPS)\n        snprintf(buf, L_BUFSIZE, \"%s.eps\", newroot);\n    else if (outformat == GPLOT_LATEX)\n        snprintf(buf, L_BUFSIZE, \"%s.tex\", newroot);\n    gplot->outname = stringNew(buf);\n    if (title) gplot->title = stringNew(title);\n    if (xlabel) gplot->xlabel = stringNew(xlabel);\n    if (ylabel) gplot->ylabel = stringNew(ylabel);\n\n    return gplot;\n}\n\n\n/*!\n * \\brief    gplotDestroy()\n *\n * \\param[in,out] pgplot to be nulled\n */\nvoid\ngplotDestroy(GPLOT  **pgplot)\n{\nGPLOT  *gplot;\n\n    PROCNAME(\"gplotDestroy\");\n\n    if (pgplot == NULL) {\n        L_WARNING(\"ptr address is null!\\n\", procName);\n        return;\n    }\n\n    if ((gplot = *pgplot) == NULL)\n        return;\n\n    LEPT_FREE(gplot->rootname);\n    LEPT_FREE(gplot->cmdname);\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n    sarrayDestroy(&gplot->plottitles);\n    numaDestroy(&gplot->plotstyles);\n    LEPT_FREE(gplot->outname);\n    if (gplot->title)\n        LEPT_FREE(gplot->title);\n    if (gplot->xlabel)\n        LEPT_FREE(gplot->xlabel);\n    if (gplot->ylabel)\n        LEPT_FREE(gplot->ylabel);\n\n    LEPT_FREE(gplot);\n    *pgplot = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   gplotAddPlot()\n *\n * \\param[in]    gplot\n * \\param[in]    nax [optional] numa: set to null for Y_VS_I;\n *                   required for Y_VS_X\n * \\param[in]    nay numa: required for both Y_VS_I and Y_VS_X\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    plottitle  [optional] title for individual plot\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) There are 2 options for (x,y) values:\n *            o  To plot an array vs a linear function of the\n *               index, set nax = NULL.\n *            o  To plot one array vs another, use both nax and nay.\n *      (2) If nax is NULL, the x value corresponding to the i-th\n *          value of nay is found from the startx and delx fields\n *          in nay:\n *               x = startx + i * delx\n *          These are set with numaSetParameters().  Their default\n *          values are startx = 0.0, delx = 1.0.\n *      (3) If nax is defined, it must be the same size as nay, and\n *          must have at least one number.\n *      (4) The 'plottitle' string can have spaces, double\n *          quotes and backquotes, but not single quotes.\n * </pre>\n */\nl_int32\ngplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUFSIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n\n    PROCNAME(\"gplotAddPlot\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n\n        /* Save plotstyle and plottitle */\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n\n        /* Generate and save data filename */\n    gplot->nplots++;\n    snprintf(buf, L_BUFSIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n\n        /* Generate data and save as a string */\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUFSIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotSetScaling()\n *\n * \\param[in]    gplot\n * \\param[in]    scaling GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X,\n *                       GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) By default, the x and y axis scaling is linear.\n *      (2) Call this function to set semi-log or log-log scaling.\n * </pre>\n */\nl_int32\ngplotSetScaling(GPLOT   *gplot,\n                l_int32  scaling)\n{\n    PROCNAME(\"gplotSetScaling\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (scaling != GPLOT_LINEAR_SCALE &&\n        scaling != GPLOT_LOG_SCALE_X &&\n        scaling != GPLOT_LOG_SCALE_Y &&\n        scaling != GPLOT_LOG_SCALE_X_Y)\n        return ERROR_INT(\"invalid gplot scaling\", procName, 1);\n    gplot->scaling = scaling;\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotMakeOutput()\n *\n * \\param[in]    gplot\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This uses gplot and the new arrays to add a plot\n *          to the output, by writing a new data file and appending\n *          the appropriate plot commands to the command file.\n *      (2) This is the only function in this file that requires the\n *          gnuplot executable, to actually generate the plot.\n *      (3) The command file name for unix is canonical (i.e., directory /tmp)\n *          but the temp filename paths in the command file must be correct.\n *      (4) The gnuplot program for windows is wgnuplot.exe.\n * </pre>\n */\nl_int32\ngplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUFSIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUFSIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUFSIZE, \"wgnuplot %s\", cmdname);\n#endif  /* _WIN32 */\n\n#ifndef OS_IOS /* iOS 11 does not support system() */\n    ignore = system(buf);  /* gnuplot || wgnuplot */\n#endif /* !OS_IOS */\n\n    LEPT_FREE(cmdname);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotGenCommandFile()\n *\n * \\param[in]    gplot\n * \\return  0 if OK, 1 on error\n */\nl_int32\ngplotGenCommandFile(GPLOT  *gplot)\n{\nchar     buf[L_BUFSIZE];\nchar    *cmdstr, *plottitle, *dataname;\nl_int32  i, plotstyle, nplots;\nFILE    *fp;\n\n    PROCNAME(\"gplotGenCommandFile\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n        /* Remove any previous command data */\n    sarrayClear(gplot->cmddata);\n\n        /* Generate command data instructions */\n    if (gplot->title) {   /* set title */\n        snprintf(buf, L_BUFSIZE, \"set title '%s'\", gplot->title);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->xlabel) {   /* set xlabel */\n        snprintf(buf, L_BUFSIZE, \"set xlabel '%s'\", gplot->xlabel);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->ylabel) {   /* set ylabel */\n        snprintf(buf, L_BUFSIZE, \"set ylabel '%s'\", gplot->ylabel);\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n        /* Set terminal type and output */\n    if (gplot->outformat == GPLOT_PNG) {\n        snprintf(buf, L_BUFSIZE, \"set terminal png; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_PS) {\n        snprintf(buf, L_BUFSIZE, \"set terminal postscript; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_EPS) {\n        snprintf(buf, L_BUFSIZE,\n                 \"set terminal postscript eps; set output '%s'\",\n                 gplot->outname);\n    } else if (gplot->outformat == GPLOT_LATEX) {\n        snprintf(buf, L_BUFSIZE, \"set terminal latex; set output '%s'\",\n                 gplot->outname);\n    }\n    sarrayAddString(gplot->cmddata, buf, L_COPY);\n\n    if (gplot->scaling == GPLOT_LOG_SCALE_X ||\n        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {\n        snprintf(buf, L_BUFSIZE, \"set logscale x\");\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n    if (gplot->scaling == GPLOT_LOG_SCALE_Y ||\n        gplot->scaling == GPLOT_LOG_SCALE_X_Y) {\n        snprintf(buf, L_BUFSIZE, \"set logscale y\");\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n    nplots = sarrayGetCount(gplot->datanames);\n    for (i = 0; i < nplots; i++) {\n        plottitle = sarrayGetString(gplot->plottitles, i, L_NOCOPY);\n        dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);\n        numaGetIValue(gplot->plotstyles, i, &plotstyle);\n        if (nplots == 1) {\n            snprintf(buf, L_BUFSIZE, \"plot '%s' title '%s' %s\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n        } else {\n            if (i == 0)\n                snprintf(buf, L_BUFSIZE, \"plot '%s' title '%s' %s, \\\\\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n            else if (i < nplots - 1)\n                snprintf(buf, L_BUFSIZE, \" '%s' title '%s' %s, \\\\\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n            else\n                snprintf(buf, L_BUFSIZE, \" '%s' title '%s' %s\",\n                     dataname, plottitle, gplotstylenames[plotstyle]);\n        }\n        sarrayAddString(gplot->cmddata, buf, L_COPY);\n    }\n\n        /* Write command data to file */\n    cmdstr = sarrayToString(gplot->cmddata, 1);\n    if ((fp = fopenWriteStream(gplot->cmdname, \"w\")) == NULL) {\n        LEPT_FREE(cmdstr);\n        return ERROR_INT(\"cmd stream not opened\", procName, 1);\n    }\n    fwrite(cmdstr, 1, strlen(cmdstr), fp);\n    fclose(fp);\n    LEPT_FREE(cmdstr);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotGenDataFiles()\n *\n * \\param[in]    gplot\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The pathnames in the gplot command file are actual pathnames,\n *          which can be in temp directories.  Consequently, they must not be\n *          rewritten by calling fopenWriteStream(), and we use fopen().\n * </pre>\n */\nl_int32\ngplotGenDataFiles(GPLOT  *gplot)\n{\nchar    *plotdata, *dataname;\nl_int32  i, nplots;\nFILE    *fp;\n\n    PROCNAME(\"gplotGenDataFiles\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    nplots = sarrayGetCount(gplot->datanames);\n    for (i = 0; i < nplots; i++) {\n        plotdata = sarrayGetString(gplot->plotdata, i, L_NOCOPY);\n        dataname = sarrayGetString(gplot->datanames, i, L_NOCOPY);\n        if ((fp = fopen(dataname, \"w\")) == NULL)\n            return ERROR_INT(\"datafile stream not opened\", procName, 1);\n        fwrite(plotdata, 1, strlen(plotdata), fp);\n        fclose(fp);\n    }\n\n    return 0;\n}\n\n\n/*-----------------------------------------------------------------*\n *                       Quick and Dirty Plots                     *\n *-----------------------------------------------------------------*/\n/*!\n * \\brief   gplotSimple1()\n *\n * \\param[in]    na numa; plot Y_VS_I\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional], can be NULL\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a line plot of a numa, where the array value\n *          is plotted vs the array index.  The plot is generated\n *          in the specified output format; the title  is optional.\n *      (2) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimple1(NUMA        *na,\n             l_int32      outformat,\n             const char  *outroot,\n             const char  *title)\n{\n    return gplotSimpleXY1(NULL, na, GPLOT_LINES, outformat, outroot, title);\n}\n\n\n/*!\n * \\brief   gplotSimple2()\n *\n * \\param[in]    na1 numa; plotted with Y_VS_I\n * \\param[in]    na2 ditto\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a line plot of two numa, where the array values\n *          are each plotted vs the array index.  The plot is generated\n *          in the specified output format; the title  is optional.\n *      (2) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimple2(NUMA        *na1,\n             NUMA        *na2,\n             l_int32      outformat,\n             const char  *outroot,\n             const char  *title)\n{\n    return gplotSimpleXY2(NULL, na1, na2, GPLOT_LINES,\n                          outformat, outroot, title);\n}\n\n\n/*!\n * \\brief   gplotSimpleN()\n *\n * \\param[in]    naa numaa; we plotted with Y_VS_I for each numa\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a line plot of all numas in a numaa (array of numa),\n *          where the array values are each plotted vs the array index.\n *          The plot is generated in the specified output format;\n *          the title  is optional.\n *      (2) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleN(NUMAA       *naa,\n             l_int32      outformat,\n             const char  *outroot,\n             const char  *title)\n{\n    return gplotSimpleXYN(NULL, naa, GPLOT_LINES, outformat, outroot, title);\n}\n\n\n/*!\n * \\brief   gplotSimpleXY1()\n *\n * \\param[in]    nax [optional]\n * \\param[in]    nay\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional], can be NULL\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a plot of a %nay vs %nax, generated in\n *          the specified output format.  The title is optional.\n *      (2) Use 0 for default plotstyle (lines).\n *      (3) %nax is optional.  If NULL, %nay is plotted against\n *          the array index.\n *      (4) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleXY1(NUMA        *nax,\n               NUMA        *nay,\n               l_int32      plotstyle,\n               l_int32      outformat,\n               const char  *outroot,\n               const char  *title)\n{\nGPLOT  *gplot;\n\n    PROCNAME(\"gplotSimpleXY1\");\n\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return ERROR_INT(\"invalid outformat\", procName, 1);\n    if (!outroot)\n        return ERROR_INT(\"outroot not specified\", procName, 1);\n\n    if ((gplot = gplotCreate(outroot, outformat, title, NULL, NULL)) == 0)\n        return ERROR_INT(\"gplot not made\", procName, 1);\n    gplotAddPlot(gplot, nax, nay, plotstyle, NULL);\n    gplotMakeOutput(gplot);\n    gplotDestroy(&gplot);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotSimpleXY2()\n *\n * \\param[in]    nax <optional; can be NULL\n * \\param[in]    nay1\n * \\param[in]    nay2\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title  [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives plots of %nay1 and %nay2 against nax, generated\n *          in the specified output format.  The title is optional.\n *      (2) Use 0 for default plotstyle (lines).\n *      (3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted\n *          against the array index.\n *      (4) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleXY2(NUMA        *nax,\n               NUMA        *nay1,\n               NUMA        *nay2,\n               l_int32      plotstyle,\n               l_int32      outformat,\n               const char  *outroot,\n               const char  *title)\n{\nGPLOT  *gplot;\n\n    PROCNAME(\"gplotSimpleXY2\");\n\n    if (!nay1 || !nay2)\n        return ERROR_INT(\"nay1 and nay2 not both defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return ERROR_INT(\"invalid outformat\", procName, 1);\n    if (!outroot)\n        return ERROR_INT(\"outroot not specified\", procName, 1);\n\n    if ((gplot = gplotCreate(outroot, outformat, title, NULL, NULL)) == 0)\n        return ERROR_INT(\"gplot not made\", procName, 1);\n    gplotAddPlot(gplot, nax, nay1, plotstyle, NULL);\n    gplotAddPlot(gplot, nax, nay2, plotstyle, NULL);\n    gplotMakeOutput(gplot);\n    gplotDestroy(&gplot);\n    return 0;\n}\n\n\n/*!\n * \\brief   gplotSimpleXYN()\n *\n * \\param[in]    nax [optional]; can be NULL\n * \\param[in]    naay numaa of arrays to plot against %nax\n * \\param[in]    plotstyle GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,\n *                         GPLOT_LINESPOINTS, GPLOT_DOTS\n * \\param[in]    outformat GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX\n * \\param[in]    outroot root of output files\n * \\param[in]    title [optional]\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This gives plots of each Numa in %naa against nax,\n *          generated in the specified output format.  The title is optional.\n *      (2) Use 0 for default plotstyle (lines).\n *      (3) %nax is optional.  If NULL, each Numa array is plotted against\n *          the array index.\n *      (4) When calling these simple plot functions more than once, use\n *          different %outroot to avoid overwriting the output files.\n * </pre>\n */\nl_int32\ngplotSimpleXYN(NUMA        *nax,\n               NUMAA       *naay,\n               l_int32      plotstyle,\n               l_int32      outformat,\n               const char  *outroot,\n               const char  *title)\n{\nl_int32  i, n;\nGPLOT   *gplot;\nNUMA    *nay;\n\n    PROCNAME(\"gplotSimpleXYN\");\n\n    if (!naay)\n        return ERROR_INT(\"naay not defined\", procName, 1);\n    if ((n = numaaGetCount(naay)) == 0)\n        return ERROR_INT(\"no numa in array\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return ERROR_INT(\"invalid outformat\", procName, 1);\n    if (!outroot)\n        return ERROR_INT(\"outroot not specified\", procName, 1);\n\n    if ((gplot = gplotCreate(outroot, outformat, title, NULL, NULL)) == 0)\n        return ERROR_INT(\"gplot not made\", procName, 1);\n    for (i = 0; i < n; i++) {\n        nay = numaaGetNuma(naay, i, L_CLONE);\n        gplotAddPlot(gplot, nax, nay, plotstyle, NULL);\n        numaDestroy(&nay);\n    }\n    gplotMakeOutput(gplot);\n    gplotDestroy(&gplot);\n    return 0;\n}\n\n\n/*-----------------------------------------------------------------*\n *                           Serialize for I/O                     *\n *-----------------------------------------------------------------*/\n/*!\n * \\brief   gplotRead()\n *\n * \\param[in]    filename\n * \\return  gplot, or NULL on error\n */\nGPLOT *\ngplotRead(const char  *filename)\n{\nchar     buf[L_BUFSIZE];\nchar    *rootname, *title, *xlabel, *ylabel, *ignores;\nl_int32  outformat, ret, version, ignore;\nFILE    *fp;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotRead\");\n\n    if (!filename)\n        return (GPLOT *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (GPLOT *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ret = fscanf(fp, \"Gplot Version %d\\n\", &version);\n    if (ret != 1) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"not a gplot file\", procName, NULL);\n    }\n    if (version != GPLOT_VERSION_NUMBER) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"invalid gplot version\", procName, NULL);\n    }\n\n    ignore = fscanf(fp, \"Rootname: %511s\\n\", buf);  /* L_BUFSIZE - 1 */\n    rootname = stringNew(buf);\n    ignore = fscanf(fp, \"Output format: %d\\n\", &outformat);\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* Title: ... */\n    title = stringNew(buf + 7);\n    title[strlen(title) - 1] = '\\0';\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* X axis label: ... */\n    xlabel = stringNew(buf + 14);\n    xlabel[strlen(xlabel) - 1] = '\\0';\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* Y axis label: ... */\n    ylabel = stringNew(buf + 14);\n    ylabel[strlen(ylabel) - 1] = '\\0';\n\n    gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);\n    LEPT_FREE(rootname);\n    LEPT_FREE(title);\n    LEPT_FREE(xlabel);\n    LEPT_FREE(ylabel);\n    if (!gplot) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    }\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n    sarrayDestroy(&gplot->plottitles);\n    numaDestroy(&gplot->plotstyles);\n\n    ignore = fscanf(fp, \"Commandfile name: %511s\\n\", buf);  /* L_BUFSIZE - 1 */\n    stringReplace(&gplot->cmdname, buf);\n    ignore = fscanf(fp, \"\\nCommandfile data:\");\n    gplot->cmddata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nDatafile names:\");\n    gplot->datanames = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot data:\");\n    gplot->plotdata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot titles:\");\n    gplot->plottitles = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot styles:\");\n    gplot->plotstyles = numaReadStream(fp);\n\n    ignore = fscanf(fp, \"Number of plots: %d\\n\", &gplot->nplots);\n    ignore = fscanf(fp, \"Output file name: %511s\\n\", buf);\n    stringReplace(&gplot->outname, buf);\n    ignore = fscanf(fp, \"Axis scaling: %d\\n\", &gplot->scaling);\n\n    fclose(fp);\n    return gplot;\n}\n\n\n/*!\n * \\brief   gplotWrite()\n *\n * \\param[in]    filename\n * \\param[in]    gplot\n * \\return  0 if OK; 1 on error\n */\nl_int32\ngplotWrite(const char  *filename,\n           GPLOT       *gplot)\n{\nFILE  *fp;\n\n    PROCNAME(\"gplotWrite\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(filename, \"wb\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n\n    fprintf(fp, \"Gplot Version %d\\n\", GPLOT_VERSION_NUMBER);\n    fprintf(fp, \"Rootname: %s\\n\", gplot->rootname);\n    fprintf(fp, \"Output format: %d\\n\", gplot->outformat);\n    fprintf(fp, \"Title: %s\\n\", gplot->title);\n    fprintf(fp, \"X axis label: %s\\n\", gplot->xlabel);\n    fprintf(fp, \"Y axis label: %s\\n\", gplot->ylabel);\n\n    fprintf(fp, \"Commandfile name: %s\\n\", gplot->cmdname);\n    fprintf(fp, \"\\nCommandfile data:\");\n    sarrayWriteStream(fp, gplot->cmddata);\n    fprintf(fp, \"\\nDatafile names:\");\n    sarrayWriteStream(fp, gplot->datanames);\n    fprintf(fp, \"\\nPlot data:\");\n    sarrayWriteStream(fp, gplot->plotdata);\n    fprintf(fp, \"\\nPlot titles:\");\n    sarrayWriteStream(fp, gplot->plottitles);\n    fprintf(fp, \"\\nPlot styles:\");\n    numaWriteStream(fp, gplot->plotstyles);\n\n    fprintf(fp, \"Number of plots: %d\\n\", gplot->nplots);\n    fprintf(fp, \"Output file name: %s\\n\", gplot->outname);\n    fprintf(fp, \"Axis scaling: %d\\n\", gplot->scaling);\n\n    fclose(fp);\n    return 0;\n}\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n\n/*!\n * \\file  ptabasic.c\n * <pre>\n *\n *      Pta creation, destruction, copy, clone, empty\n *           PTA            *ptaCreate()\n *           PTA            *ptaCreateFromNuma()\n *           void            ptaDestroy()\n *           PTA            *ptaCopy()\n *           PTA            *ptaCopyRange()\n *           PTA            *ptaClone()\n *           l_int32         ptaEmpty()\n *\n *      Pta array extension\n *           l_int32         ptaAddPt()\n *           static l_int32  ptaExtendArrays()\n *\n *      Pta insertion and removal\n *           l_int32         ptaInsertPt()\n *           l_int32         ptaRemovePt()\n *\n *      Pta accessors\n *           l_int32         ptaGetRefcount()\n *           l_int32         ptaChangeRefcount()\n *           l_int32         ptaGetCount()\n *           l_int32         ptaGetPt()\n *           l_int32         ptaGetIPt()\n *           l_int32         ptaSetPt()\n *           l_int32         ptaGetArrays()\n *\n *      Pta serialized for I/O\n *           PTA            *ptaRead()\n *           PTA            *ptaReadStream()\n *           PTA            *ptaReadMem()\n *           l_int32         ptaWrite()\n *           l_int32         ptaWriteStream()\n *           l_int32         ptaWriteMem()\n *\n *      Ptaa creation, destruction\n *           PTAA           *ptaaCreate()\n *           void            ptaaDestroy()\n *\n *      Ptaa array extension\n *           l_int32         ptaaAddPta()\n *           static l_int32  ptaaExtendArray()\n *\n *      Ptaa accessors\n *           l_int32         ptaaGetCount()\n *           l_int32         ptaaGetPta()\n *           l_int32         ptaaGetPt()\n *\n *      Ptaa array modifiers\n *           l_int32         ptaaInitFull()\n *           l_int32         ptaaReplacePta()\n *           l_int32         ptaaAddPt()\n *           l_int32         ptaaTruncate()\n *\n *      Ptaa serialized for I/O\n *           PTAA           *ptaaRead()\n *           PTAA           *ptaaReadStream()\n *           PTAA           *ptaaReadMem()\n *           l_int32         ptaaWrite()\n *           l_int32         ptaaWriteStream()\n *           l_int32         ptaaWriteMem()\n * </pre>\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  INITIAL_PTR_ARRAYSIZE = 20;   /* n'import quoi */\n\n    /* Static functions */\nstatic l_int32 ptaExtendArrays(PTA *pta);\nstatic l_int32 ptaaExtendArray(PTAA *ptaa);\n\n\n/*---------------------------------------------------------------------*\n *                Pta creation, destruction, copy, clone               *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaCreate()\n *\n * \\param[in]    n  initial array sizes\n * \\return  pta, or NULL on error.\n */\nPTA *\nptaCreate(l_int32  n)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaCreate\");\n\n    if (n <= 0)\n        n = INITIAL_PTR_ARRAYSIZE;\n\n    pta = (PTA *)LEPT_CALLOC(1, sizeof(PTA));\n    pta->n = 0;\n    pta->nalloc = n;\n    ptaChangeRefcount(pta, 1);  /* sets to 1 */\n\n    pta->x = (l_float32 *)LEPT_CALLOC(n, sizeof(l_float32));\n    pta->y = (l_float32 *)LEPT_CALLOC(n, sizeof(l_float32));\n    if (!pta->x || !pta->y) {\n        ptaDestroy(&pta);\n        return (PTA *)ERROR_PTR(\"x and y arrays not both made\", procName, NULL);\n    }\n\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaCreateFromNuma()\n *\n * \\param[in]    nax [optional] can be null\n * \\param[in]    nay\n * \\return  pta, or NULL on error.\n */\nPTA *\nptaCreateFromNuma(NUMA  *nax,\n                  NUMA  *nay)\n{\nl_int32    i, n;\nl_float32  startx, delx, xval, yval;\nPTA       *pta;\n\n    PROCNAME(\"ptaCreateFromNuma\");\n\n    if (!nay)\n        return (PTA *)ERROR_PTR(\"nay not defined\", procName, NULL);\n    n = numaGetCount(nay);\n    if (nax && numaGetCount(nax) != n)\n        return (PTA *)ERROR_PTR(\"nax and nay sizes differ\", procName, NULL);\n\n    pta = ptaCreate(n);\n    numaGetParameters(nay, &startx, &delx);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &xval);\n        else  /* use implicit x values from nay */\n            xval = startx + i * delx;\n        numaGetFValue(nay, i, &yval);\n        ptaAddPt(pta, xval, yval);\n    }\n\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaDestroy()\n *\n * \\param[in,out]   ppta to be nulled\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) Decrements the ref count and, if 0, destroys the pta.\n *      (2) Always nulls the input ptr.\n * </pre>\n */\nvoid\nptaDestroy(PTA  **ppta)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaDestroy\");\n\n    if (ppta == NULL) {\n        L_WARNING(\"ptr address is NULL!\\n\", procName);\n        return;\n    }\n\n    if ((pta = *ppta) == NULL)\n        return;\n\n    ptaChangeRefcount(pta, -1);\n    if (ptaGetRefcount(pta) <= 0) {\n        LEPT_FREE(pta->x);\n        LEPT_FREE(pta->y);\n        LEPT_FREE(pta);\n    }\n\n    *ppta = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   ptaCopy()\n *\n * \\param[in]    pta\n * \\return  copy of pta, or NULL on error\n */\nPTA *\nptaCopy(PTA  *pta)\n{\nl_int32    i;\nl_float32  x, y;\nPTA       *npta;\n\n    PROCNAME(\"ptaCopy\");\n\n    if (!pta)\n        return (PTA *)ERROR_PTR(\"pta not defined\", procName, NULL);\n\n    if ((npta = ptaCreate(pta->nalloc)) == NULL)\n        return (PTA *)ERROR_PTR(\"npta not made\", procName, NULL);\n\n    for (i = 0; i < pta->n; i++) {\n        ptaGetPt(pta, i, &x, &y);\n        ptaAddPt(npta, x, y);\n    }\n\n    return npta;\n}\n\n\n/*!\n * \\brief   ptaCopyRange()\n *\n * \\param[in]    ptas\n * \\param[in]    istart  starting index in ptas\n * \\param[in]    iend  ending index in ptas; use 0 to copy to end\n * \\return  0 if OK, 1 on error\n */\nPTA *\nptaCopyRange(PTA     *ptas,\n             l_int32  istart,\n             l_int32  iend)\n{\nl_int32  n, i, x, y;\nPTA     *ptad;\n\n    PROCNAME(\"ptaCopyRange\");\n\n    if (!ptas)\n        return (PTA *)ERROR_PTR(\"ptas not defined\", procName, NULL);\n    n = ptaGetCount(ptas);\n    if (istart < 0)\n        istart = 0;\n    if (istart >= n)\n        return (PTA *)ERROR_PTR(\"istart out of bounds\", procName, NULL);\n    if (iend <= 0 || iend >= n)\n        iend = n - 1;\n    if (istart > iend)\n        return (PTA *)ERROR_PTR(\"istart > iend; no pts\", procName, NULL);\n\n    if ((ptad = ptaCreate(iend - istart + 1)) == NULL)\n        return (PTA *)ERROR_PTR(\"ptad not made\", procName, NULL);\n    for (i = istart; i <= iend; i++) {\n        ptaGetIPt(ptas, i, &x, &y);\n        ptaAddPt(ptad, x, y);\n    }\n\n    return ptad;\n}\n\n\n/*!\n * \\brief   ptaClone()\n *\n * \\param[in]    pta\n * \\return  ptr to same pta, or NULL on error\n */\nPTA *\nptaClone(PTA  *pta)\n{\n    PROCNAME(\"ptaClone\");\n\n    if (!pta)\n        return (PTA *)ERROR_PTR(\"pta not defined\", procName, NULL);\n\n    ptaChangeRefcount(pta, 1);\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaEmpty()\n *\n * \\param[in]    pta\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      This only resets the Pta::n field, for reuse\n * </pre>\n */\nl_int32\nptaEmpty(PTA  *pta)\n{\n    PROCNAME(\"ptaEmpty\");\n\n    if (!pta)\n        return ERROR_INT(\"ptad not defined\", procName, 1);\n    pta->n = 0;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                         Pta array extension                         *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaAddPt()\n *\n * \\param[in]    pta\n * \\param[in]    x, y\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaAddPt(PTA       *pta,\n         l_float32  x,\n         l_float32  y)\n{\nl_int32  n;\n\n    PROCNAME(\"ptaAddPt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    n = pta->n;\n    if (n >= pta->nalloc)\n        ptaExtendArrays(pta);\n    pta->x[n] = x;\n    pta->y[n] = y;\n    pta->n++;\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaExtendArrays()\n *\n * \\param[in]    pta\n * \\return  0 if OK; 1 on error\n */\nstatic l_int32\nptaExtendArrays(PTA  *pta)\n{\n    PROCNAME(\"ptaExtendArrays\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    if ((pta->x = (l_float32 *)reallocNew((void **)&pta->x,\n                               sizeof(l_float32) * pta->nalloc,\n                               2 * sizeof(l_float32) * pta->nalloc)) == NULL)\n        return ERROR_INT(\"new x array not returned\", procName, 1);\n    if ((pta->y = (l_float32 *)reallocNew((void **)&pta->y,\n                               sizeof(l_float32) * pta->nalloc,\n                               2 * sizeof(l_float32) * pta->nalloc)) == NULL)\n        return ERROR_INT(\"new y array not returned\", procName, 1);\n\n    pta->nalloc = 2 * pta->nalloc;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                     Pta insertion and removal                       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaInsertPt()\n *\n * \\param[in]    pta\n * \\param[in]    index at which pt is to be inserted\n * \\param[in]    x, y point values\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaInsertPt(PTA     *pta,\n            l_int32  index,\n            l_int32  x,\n            l_int32  y)\n{\nl_int32  i, n;\n\n    PROCNAME(\"ptaInsertPt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaGetCount(pta);\n    if (index < 0 || index > n)\n        return ERROR_INT(\"index not in {0...n}\", procName, 1);\n\n    if (n > pta->nalloc)\n        ptaExtendArrays(pta);\n    pta->n++;\n    for (i = n; i > index; i--) {\n        pta->x[i] = pta->x[i - 1];\n        pta->y[i] = pta->y[i - 1];\n    }\n    pta->x[index] = x;\n    pta->y[index] = y;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaRemovePt()\n *\n * \\param[in]    pta\n * \\param[in]    index of point to be removed\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This shifts pta[i] --> pta[i - 1] for all i > index.\n *      (2) It should not be used repeatedly on large arrays,\n *          because the function is O(n).\n * </pre>\n */\nl_int32\nptaRemovePt(PTA     *pta,\n            l_int32  index)\n{\nl_int32  i, n;\n\n    PROCNAME(\"ptaRemovePt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaGetCount(pta);\n    if (index < 0 || index >= n)\n        return ERROR_INT(\"index not in {0...n - 1}\", procName, 1);\n\n        /* Remove the point */\n    for (i = index + 1; i < n; i++) {\n        pta->x[i - 1] = pta->x[i];\n        pta->y[i - 1] = pta->y[i];\n    }\n    pta->n--;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                           Pta accessors                             *\n *---------------------------------------------------------------------*/\nl_int32\nptaGetRefcount(PTA  *pta)\n{\n    PROCNAME(\"ptaGetRefcount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    return pta->refcount;\n}\n\n\nl_int32\nptaChangeRefcount(PTA     *pta,\n                  l_int32  delta)\n{\n    PROCNAME(\"ptaChangeRefcount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    pta->refcount += delta;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaGetCount()\n *\n * \\param[in]    pta\n * \\return  count, or 0 if no pta\n */\nl_int32\nptaGetCount(PTA  *pta)\n{\n    PROCNAME(\"ptaGetCount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 0);\n\n    return pta->n;\n}\n\n\n/*!\n * \\brief   ptaGetPt()\n *\n * \\param[in]    pta\n * \\param[in]    index  into arrays\n * \\param[out]   px [optional] float x value\n * \\param[out]   py [optional] float y value\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaGetPt(PTA        *pta,\n         l_int32     index,\n         l_float32  *px,\n         l_float32  *py)\n{\n    PROCNAME(\"ptaGetPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    if (px) *px = pta->x[index];\n    if (py) *py = pta->y[index];\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaGetIPt()\n *\n * \\param[in]    pta\n * \\param[in]    index  into arrays\n * \\param[out]   px [optional] integer x value\n * \\param[out]   py [optional] integer y value\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaGetIPt(PTA      *pta,\n          l_int32   index,\n          l_int32  *px,\n          l_int32  *py)\n{\n    PROCNAME(\"ptaGetIPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    if (px) *px = (l_int32)(pta->x[index] + 0.5);\n    if (py) *py = (l_int32)(pta->y[index] + 0.5);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaSetPt()\n *\n * \\param[in]    pta\n * \\param[in]    index  into arrays\n * \\param[in]    x, y\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaSetPt(PTA       *pta,\n         l_int32    index,\n         l_float32  x,\n         l_float32  y)\n{\n    PROCNAME(\"ptaSetPt\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    pta->x[index] = x;\n    pta->y[index] = y;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaGetArrays()\n *\n * \\param[in]    pta\n * \\param[out]   pnax [optional] numa of x array\n * \\param[out]   pnay [optional] numa of y array\n * \\return  0 if OK; 1 on error or if pta is empty\n *\n * <pre>\n * Notes:\n *      (1) This copies the internal arrays into new Numas.\n * </pre>\n */\nl_int32\nptaGetArrays(PTA    *pta,\n             NUMA  **pnax,\n             NUMA  **pnay)\n{\nl_int32  i, n;\nNUMA    *nax, *nay;\n\n    PROCNAME(\"ptaGetArrays\");\n\n    if (!pnax && !pnay)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (pnax) *pnax = NULL;\n    if (pnay) *pnay = NULL;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if ((n = ptaGetCount(pta)) == 0)\n        return ERROR_INT(\"pta is empty\", procName, 1);\n\n    if (pnax) {\n        if ((nax = numaCreate(n)) == NULL)\n            return ERROR_INT(\"nax not made\", procName, 1);\n        *pnax = nax;\n        for (i = 0; i < n; i++)\n            nax->array[i] = pta->x[i];\n        nax->n = n;\n    }\n    if (pnay) {\n        if ((nay = numaCreate(n)) == NULL)\n            return ERROR_INT(\"nay not made\", procName, 1);\n        *pnay = nay;\n        for (i = 0; i < n; i++)\n            nay->array[i] = pta->y[i];\n        nay->n = n;\n    }\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                       Pta serialized for I/O                        *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaRead()\n *\n * \\param[in]    filename\n * \\return  pta, or NULL on error\n */\nPTA *\nptaRead(const char  *filename)\n{\nFILE  *fp;\nPTA   *pta;\n\n    PROCNAME(\"ptaRead\");\n\n    if (!filename)\n        return (PTA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PTA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    pta = ptaReadStream(fp);\n    fclose(fp);\n    if (!pta)\n        return (PTA *)ERROR_PTR(\"pta not read\", procName, NULL);\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  pta, or NULL on error\n */\nPTA *\nptaReadStream(FILE  *fp)\n{\nchar       typestr[128];  /* hardcoded below in fscanf */\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n\n    PROCNAME(\"ptaReadStream\");\n\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %127s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  /* typestr is \"integer\" */\n        type = 1;\n\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  /* data is float */\n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   /* data is integer */\n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaReadMem()\n *\n * \\param[in]    data  serialization in ascii\n * \\param[in]    size  of data in bytes; can use strlen to get it\n * \\return  pta, or NULL on error\n */\nPTA *\nptaReadMem(const l_uint8  *data,\n           size_t          size)\n{\nFILE  *fp;\nPTA   *pta;\n\n    PROCNAME(\"ptaReadMem\");\n\n    if (!data)\n        return (PTA *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if ((fp = fopenReadFromMemory(data, size)) == NULL)\n        return (PTA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    pta = ptaReadStream(fp);\n    fclose(fp);\n    if (!pta) L_ERROR(\"pta not read\\n\", procName);\n    return pta;\n}\n\n\n/*!\n * \\brief   ptaWrite()\n *\n * \\param[in]    filename\n * \\param[in]    pta\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaWrite(const char  *filename,\n         PTA         *pta,\n         l_int32      type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaWrite\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(filename, \"w\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaWriteStream(fp, pta, type);\n    fclose(fp);\n    if (ret)\n        return ERROR_INT(\"pta not written to stream\", procName, 1);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    pta\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaWriteStream(FILE    *fp,\n               PTA     *pta,\n               l_int32  type)\n{\nl_int32    i, n, ix, iy;\nl_float32  x, y;\n\n    PROCNAME(\"ptaWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    n = ptaGetCount(pta);\n    fprintf(fp, \"\\n Pta Version %d\\n\", PTA_VERSION_NUMBER);\n    if (type == 0)\n        fprintf(fp, \" Number of pts = %d; format = float\\n\", n);\n    else  /* type == 1 */\n        fprintf(fp, \" Number of pts = %d; format = integer\\n\", n);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  /* data is float */\n            ptaGetPt(pta, i, &x, &y);\n            fprintf(fp, \"   (%f, %f)\\n\", x, y);\n        } else {   /* data is integer */\n            ptaGetIPt(pta, i, &ix, &iy);\n            fprintf(fp, \"   (%d, %d)\\n\", ix, iy);\n        }\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaWriteMem()\n *\n * \\param[out]   pdata data of serialized pta; ascii\n * \\param[out]   psize size of returned data\n * \\param[in]    pta\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Serializes a pta in memory and puts the result in a buffer.\n * </pre>\n */\nl_int32\nptaWriteMem(l_uint8  **pdata,\n            size_t    *psize,\n            PTA       *pta,\n            l_int32    type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaWriteMem\");\n\n    if (pdata) *pdata = NULL;\n    if (psize) *psize = 0;\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n#if HAVE_FMEMOPEN\n    if ((fp = open_memstream((char **)pdata, psize)) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaWriteStream(fp, pta, type);\n#else\n    L_INFO(\"work-around: writing to a temp file\\n\", procName);\n  #ifdef _WIN32\n    if ((fp = fopenWriteWinTempfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #else\n    if ((fp = tmpfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #endif  /* _WIN32 */\n    ret = ptaWriteStream(fp, pta, type);\n    rewind(fp);\n    *pdata = l_binaryReadStream(fp, psize);\n#endif  /* HAVE_FMEMOPEN */\n    fclose(fp);\n    return ret;\n}\n\n\n/*---------------------------------------------------------------------*\n *                     PTAA creation, destruction                      *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaCreate()\n *\n * \\param[in]    n  initial number of ptrs\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaCreate(l_int32  n)\n{\nPTAA  *ptaa;\n\n    PROCNAME(\"ptaaCreate\");\n\n    if (n <= 0)\n        n = INITIAL_PTR_ARRAYSIZE;\n\n    if ((ptaa = (PTAA *)LEPT_CALLOC(1, sizeof(PTAA))) == NULL)\n        return (PTAA *)ERROR_PTR(\"ptaa not made\", procName, NULL);\n    ptaa->n = 0;\n    ptaa->nalloc = n;\n    if ((ptaa->pta = (PTA **)LEPT_CALLOC(n, sizeof(PTA *))) == NULL) {\n        ptaaDestroy(&ptaa);\n        return (PTAA *)ERROR_PTR(\"pta ptrs not made\", procName, NULL);\n    }\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaDestroy()\n *\n * \\param[in,out]   pptaa to be nulled\n * \\return  void\n */\nvoid\nptaaDestroy(PTAA  **pptaa)\n{\nl_int32  i;\nPTAA    *ptaa;\n\n    PROCNAME(\"ptaaDestroy\");\n\n    if (pptaa == NULL) {\n        L_WARNING(\"ptr address is NULL!\\n\", procName);\n        return;\n    }\n\n    if ((ptaa = *pptaa) == NULL)\n        return;\n\n    for (i = 0; i < ptaa->n; i++)\n        ptaDestroy(&ptaa->pta[i]);\n    LEPT_FREE(ptaa->pta);\n\n    LEPT_FREE(ptaa);\n    *pptaa = NULL;\n    return;\n}\n\n\n/*---------------------------------------------------------------------*\n *                          PTAA array extension                       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaAddPta()\n *\n * \\param[in]    ptaa\n * \\param[in]    pta  to be added\n * \\param[in]    copyflag  L_INSERT, L_COPY, L_CLONE\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaaAddPta(PTAA    *ptaa,\n           PTA     *pta,\n           l_int32  copyflag)\n{\nl_int32  n;\nPTA     *ptac;\n\n    PROCNAME(\"ptaaAddPta\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    if (copyflag == L_INSERT) {\n        ptac = pta;\n    } else if (copyflag == L_COPY) {\n        if ((ptac = ptaCopy(pta)) == NULL)\n            return ERROR_INT(\"ptac not made\", procName, 1);\n    } else if (copyflag == L_CLONE) {\n        if ((ptac = ptaClone(pta)) == NULL)\n            return ERROR_INT(\"pta clone not made\", procName, 1);\n    } else {\n        return ERROR_INT(\"invalid copyflag\", procName, 1);\n    }\n\n    n = ptaaGetCount(ptaa);\n    if (n >= ptaa->nalloc)\n        ptaaExtendArray(ptaa);\n    ptaa->pta[n] = ptac;\n    ptaa->n++;\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaExtendArray()\n *\n * \\param[in]    ptaa\n * \\return  0 if OK, 1 on error\n */\nstatic l_int32\nptaaExtendArray(PTAA  *ptaa)\n{\n    PROCNAME(\"ptaaExtendArray\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    if ((ptaa->pta = (PTA **)reallocNew((void **)&ptaa->pta,\n                             sizeof(PTA *) * ptaa->nalloc,\n                             2 * sizeof(PTA *) * ptaa->nalloc)) == NULL)\n        return ERROR_INT(\"new ptr array not returned\", procName, 1);\n\n    ptaa->nalloc = 2 * ptaa->nalloc;\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                          Ptaa accessors                             *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaGetCount()\n *\n * \\param[in]    ptaa\n * \\return  count, or 0 if no ptaa\n */\nl_int32\nptaaGetCount(PTAA  *ptaa)\n{\n    PROCNAME(\"ptaaGetCount\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 0);\n\n    return ptaa->n;\n}\n\n\n/*!\n * \\brief   ptaaGetPta()\n *\n * \\param[in]    ptaa\n * \\param[in]    index  to the i-th pta\n * \\param[in]    accessflag  L_COPY or L_CLONE\n * \\return  pta, or NULL on error\n */\nPTA *\nptaaGetPta(PTAA    *ptaa,\n           l_int32  index,\n           l_int32  accessflag)\n{\n    PROCNAME(\"ptaaGetPta\");\n\n    if (!ptaa)\n        return (PTA *)ERROR_PTR(\"ptaa not defined\", procName, NULL);\n    if (index < 0 || index >= ptaa->n)\n        return (PTA *)ERROR_PTR(\"index not valid\", procName, NULL);\n\n    if (accessflag == L_COPY)\n        return ptaCopy(ptaa->pta[index]);\n    else if (accessflag == L_CLONE)\n        return ptaClone(ptaa->pta[index]);\n    else\n        return (PTA *)ERROR_PTR(\"invalid accessflag\", procName, NULL);\n}\n\n\n/*!\n * \\brief   ptaaGetPt()\n *\n * \\param[in]    ptaa\n * \\param[in]    ipta  to the i-th pta\n * \\param[in]    jpt index to the j-th pt in the pta\n * \\param[out]   px [optional] float x value\n * \\param[out]   py [optional] float y value\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaGetPt(PTAA       *ptaa,\n           l_int32     ipta,\n           l_int32     jpt,\n           l_float32  *px,\n           l_float32  *py)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaaGetPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (ipta < 0 || ipta >= ptaa->n)\n        return ERROR_INT(\"index ipta not valid\", procName, 1);\n\n    pta = ptaaGetPta(ptaa, ipta, L_CLONE);\n    if (jpt < 0 || jpt >= pta->n) {\n        ptaDestroy(&pta);\n        return ERROR_INT(\"index jpt not valid\", procName, 1);\n    }\n\n    ptaGetPt(pta, jpt, px, py);\n    ptaDestroy(&pta);\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                        Ptaa array modifiers                         *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaInitFull()\n *\n * \\param[in]    ptaa can have non-null ptrs in the ptr array\n * \\param[in]    pta to be replicated into the entire ptr array\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaInitFull(PTAA  *ptaa,\n             PTA   *pta)\n{\nl_int32  n, i;\nPTA     *ptat;\n\n    PROCNAME(\"ptaaInitFull\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n\n    n = ptaa->nalloc;\n    ptaa->n = n;\n    for (i = 0; i < n; i++) {\n        ptat = ptaCopy(pta);\n        ptaaReplacePta(ptaa, i, ptat);\n    }\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaReplacePta()\n *\n * \\param[in]    ptaa\n * \\param[in]    index  to the index-th pta\n * \\param[in]    pta insert and replace any existing one\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Any existing pta is destroyed, and the input one\n *          is inserted in its place.\n *      (2) If the index is invalid, return 1 (error)\n * </pre>\n */\nl_int32\nptaaReplacePta(PTAA    *ptaa,\n               l_int32  index,\n               PTA     *pta)\n{\nl_int32  n;\n\n    PROCNAME(\"ptaaReplacePta\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaaGetCount(ptaa);\n    if (index < 0 || index >= n)\n        return ERROR_INT(\"index not valid\", procName, 1);\n\n    ptaDestroy(&ptaa->pta[index]);\n    ptaa->pta[index] = pta;\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaAddPt()\n *\n * \\param[in]    ptaa\n * \\param[in]    ipta  to the i-th pta\n * \\param[in]    x,y point coordinates\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaAddPt(PTAA      *ptaa,\n          l_int32    ipta,\n          l_float32  x,\n          l_float32  y)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaaAddPt\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (ipta < 0 || ipta >= ptaa->n)\n        return ERROR_INT(\"index ipta not valid\", procName, 1);\n\n    pta = ptaaGetPta(ptaa, ipta, L_CLONE);\n    ptaAddPt(pta, x, y);\n    ptaDestroy(&pta);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaTruncate()\n *\n * \\param[in]    ptaa\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This identifies the largest index containing a pta that\n *          has any points within it, destroys all pta above that index,\n *          and resets the count.\n * </pre>\n */\nl_int32\nptaaTruncate(PTAA  *ptaa)\n{\nl_int32  i, n, np;\nPTA     *pta;\n\n    PROCNAME(\"ptaaTruncate\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    n = ptaaGetCount(ptaa);\n    for (i = n - 1; i >= 0; i--) {\n        pta = ptaaGetPta(ptaa, i, L_CLONE);\n        if (!pta) {\n            ptaa->n--;\n            continue;\n        }\n        np = ptaGetCount(pta);\n        ptaDestroy(&pta);\n        if (np == 0) {\n            ptaDestroy(&ptaa->pta[i]);\n            ptaa->n--;\n        } else {\n            break;\n        }\n    }\n    return 0;\n}\n\n\n/*---------------------------------------------------------------------*\n *                       Ptaa serialized for I/O                       *\n *---------------------------------------------------------------------*/\n/*!\n * \\brief   ptaaRead()\n *\n * \\param[in]    filename\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaRead(const char  *filename)\n{\nFILE  *fp;\nPTAA  *ptaa;\n\n    PROCNAME(\"ptaaRead\");\n\n    if (!filename)\n        return (PTAA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PTAA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    ptaa = ptaaReadStream(fp);\n    fclose(fp);\n    if (!ptaa)\n        return (PTAA *)ERROR_PTR(\"ptaa not read\", procName, NULL);\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaReadStream(FILE  *fp)\n{\nl_int32  i, n, version;\nPTA     *pta;\nPTAA    *ptaa;\n\n    PROCNAME(\"ptaaReadStream\");\n\n    if (!fp)\n        return (PTAA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\nPtaa Version %d\\n\", &version) != 1)\n        return (PTAA *)ERROR_PTR(\"not a ptaa file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTAA *)ERROR_PTR(\"invalid ptaa version\", procName, NULL);\n    if (fscanf(fp, \"Number of Pta = %d\\n\", &n) != 1)\n        return (PTAA *)ERROR_PTR(\"not a ptaa file\", procName, NULL);\n\n    if ((ptaa = ptaaCreate(n)) == NULL)\n        return (PTAA *)ERROR_PTR(\"ptaa not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if ((pta = ptaReadStream(fp)) == NULL) {\n            ptaaDestroy(&ptaa);\n            return (PTAA *)ERROR_PTR(\"error reading pta\", procName, NULL);\n        }\n        ptaaAddPta(ptaa, pta, L_INSERT);\n    }\n\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaReadMem()\n *\n * \\param[in]    data  serialization in ascii\n * \\param[in]    size  of data in bytes; can use strlen to get it\n * \\return  ptaa, or NULL on error\n */\nPTAA *\nptaaReadMem(const l_uint8  *data,\n            size_t          size)\n{\nFILE  *fp;\nPTAA  *ptaa;\n\n    PROCNAME(\"ptaaReadMem\");\n\n    if (!data)\n        return (PTAA *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if ((fp = fopenReadFromMemory(data, size)) == NULL)\n        return (PTAA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ptaa = ptaaReadStream(fp);\n    fclose(fp);\n    if (!ptaa) L_ERROR(\"ptaa not read\\n\", procName);\n    return ptaa;\n}\n\n\n/*!\n * \\brief   ptaaWrite()\n *\n * \\param[in]    filename\n * \\param[in]    ptaa\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n */\nl_int32\nptaaWrite(const char  *filename,\n          PTAA        *ptaa,\n          l_int32      type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaaWrite\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(filename, \"w\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaaWriteStream(fp, ptaa, type);\n    fclose(fp);\n    if (ret)\n        return ERROR_INT(\"ptaa not written to stream\", procName, 1);\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    ptaa\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK; 1 on error\n */\nl_int32\nptaaWriteStream(FILE    *fp,\n                PTAA    *ptaa,\n                l_int32  type)\n{\nl_int32  i, n;\nPTA     *pta;\n\n    PROCNAME(\"ptaaWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n    n = ptaaGetCount(ptaa);\n    fprintf(fp, \"\\nPtaa Version %d\\n\", PTA_VERSION_NUMBER);\n    fprintf(fp, \"Number of Pta = %d\\n\", n);\n    for (i = 0; i < n; i++) {\n        pta = ptaaGetPta(ptaa, i, L_CLONE);\n        ptaWriteStream(fp, pta, type);\n        ptaDestroy(&pta);\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   ptaaWriteMem()\n *\n * \\param[out]   pdata data of serialized ptaa; ascii\n * \\param[out]   psize size of returned data\n * \\param[in]    ptaa\n * \\param[in]    type  0 for float values; 1 for integer values\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Serializes a ptaa in memory and puts the result in a buffer.\n * </pre>\n */\nl_int32\nptaaWriteMem(l_uint8  **pdata,\n             size_t    *psize,\n             PTAA      *ptaa,\n             l_int32    type)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"ptaaWriteMem\");\n\n    if (pdata) *pdata = NULL;\n    if (psize) *psize = 0;\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n\n#if HAVE_FMEMOPEN\n    if ((fp = open_memstream((char **)pdata, psize)) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    ret = ptaaWriteStream(fp, ptaa, type);\n#else\n    L_INFO(\"work-around: writing to a temp file\\n\", procName);\n  #ifdef _WIN32\n    if ((fp = fopenWriteWinTempfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #else\n    if ((fp = tmpfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n  #endif  /* _WIN32 */\n    ret = ptaaWriteStream(fp, ptaa, type);\n    rewind(fp);\n    *pdata = l_binaryReadStream(fp, psize);\n#endif  /* HAVE_FMEMOPEN */\n    fclose(fp);\n    return ret;\n}\n\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n\n/*!\n * \\file sel1.c\n * <pre>\n *\n *      Basic ops on Sels and Selas\n *\n *         Create/destroy/copy:\n *            SELA      *selaCreate()\n *            void       selaDestroy()\n *            SEL       *selCreate()\n *            void       selDestroy()\n *            SEL       *selCopy()\n *            SEL       *selCreateBrick()\n *            SEL       *selCreateComb()\n *\n *         Helper proc:\n *            l_int32  **create2dIntArray()\n *\n *         Extension of sela:\n *            SELA      *selaAddSel()\n *            static l_int32  selaExtendArray()\n *\n *         Accessors:\n *            l_int32    selaGetCount()\n *            SEL       *selaGetSel()\n *            char      *selGetName()\n *            l_int32    selSetName()\n *            l_int32    selaFindSelByName()\n *            l_int32    selGetElement()\n *            l_int32    selSetElement()\n *            l_int32    selGetParameters()\n *            l_int32    selSetOrigin()\n *            l_int32    selGetTypeAtOrigin()\n *            char      *selaGetBrickName()\n *            char      *selaGetCombName()\n *     static char      *selaComputeCompositeParameters()\n *            l_int32    getCompositeParameters()\n *            SARRAY    *selaGetSelnames()\n *\n *         Max translations for erosion and hmt\n *            l_int32    selFindMaxTranslations()\n *\n *         Rotation by multiples of 90 degrees\n *            SEL       *selRotateOrth()\n *\n *         Sela and Sel serialized I/O\n *            SELA      *selaRead()\n *            SELA      *selaReadStream()\n *            SEL       *selRead()\n *            SEL       *selReadStream()\n *            l_int32    selaWrite()\n *            l_int32    selaWriteStream()\n *            l_int32    selWrite()\n *            l_int32    selWriteStream()\n *\n *         Building custom hit-miss sels from compiled strings\n *            SEL       *selCreateFromString()\n *            char      *selPrintToString()     [for debugging]\n *\n *         Building custom hit-miss sels from a simple file format\n *            SELA      *selaCreateFromFile()\n *            static SEL *selCreateFromSArray()\n *\n *         Making hit-only sels from Pta and Pix\n *            SEL       *selCreateFromPta()\n *            SEL       *selCreateFromPix()\n *\n *         Making hit-miss sels from Pix and image files\n *            SEL       *selReadFromColorImage()\n *            SEL       *selCreateFromColorPix()\n *\n *         Printable display of sel\n *            PIX       *selDisplayInPix()\n *            PIX       *selaDisplayInPix()\n *\n *     Usage notes:\n *        In this file we have seven functions that make sels:\n *          (1)  selCreate(), with input (h, w, [name])\n *               The generic function.  Roll your own, using selSetElement().\n *          (2)  selCreateBrick(), with input (h, w, cy, cx, val)\n *               The most popular function.  Makes a rectangular sel of\n *               all hits, misses or don't-cares.  We have many morphology\n *               operations that create a sel of all hits, use it, and\n *               destroy it.\n *          (3)  selCreateFromString() with input (text, h, w, [name])\n *               Adam Langley's clever function, allows you to make a hit-miss\n *               sel from a string in code that is geometrically laid out\n *               just like the actual sel.\n *          (4)  selaCreateFromFile() with input (filename)\n *               This parses a simple file format to create an array of\n *               hit-miss sels.  The sel data uses the same encoding\n *               as in (3), with geometrical layout enforced.\n *          (5)  selCreateFromPta() with input (pta, cy, cx, [name])\n *               Another way to make a sel with only hits.\n *          (6)  selCreateFromPix() with input (pix, cy, cx, [name])\n *               Yet another way to make a sel from hits.\n *          (7)  selCreateFromColorPix() with input (pix, name).\n *               Another way to make a general hit-miss sel, starting with\n *               an image editor.\n *        In addition, there are three functions in selgen.c that\n *        automatically generate a hit-miss sel from a pix and\n *        a number of parameters.  This is useful for problems like\n *        \"find all patterns that look like this one.\"\n *\n *        Consistency, being the hobgoblin of small minds,\n *        is adhered to here in the dimensioning and accessing of sels.\n *        Everything is done in standard matrix (row, column) order.\n *        When we set specific elements in a sel, we likewise use\n *        (row, col) ordering:\n *             selSetElement(), with input (row, col, type)\n * </pre>\n */\n\n#include <string.h>\n#include \"allheaders.h\"\n\nstatic const l_int32  L_BUFSIZE = 256;  /* hardcoded below in sscanf */\nstatic const l_int32  INITIAL_PTR_ARRAYSIZE = 50;  /* n'import quoi */\nstatic const l_int32  MANY_SELS = 1000;\n\n    /* Static functions */\nstatic l_int32 selaExtendArray(SELA *sela);\nstatic SEL *selCreateFromSArray(SARRAY *sa, l_int32 first, l_int32 last);\n\nstruct CompParameterMap\n{\n    l_int32  size;\n    l_int32  size1;\n    l_int32  size2;\n    char     selnameh1[20];\n    char     selnameh2[20];\n    char     selnamev1[20];\n    char     selnamev2[20];\n};\n\nstatic const struct CompParameterMap  comp_parameter_map[] =\n    { { 2, 2, 1, \"sel_2h\", \"\", \"sel_2v\", \"\" },\n      { 3, 3, 1, \"sel_3h\", \"\", \"sel_3v\", \"\" },\n      { 4, 2, 2, \"sel_2h\", \"sel_comb_4h\", \"sel_2v\", \"sel_comb_4v\" },\n      { 5, 5, 1, \"sel_5h\", \"\", \"sel_5v\", \"\" },\n      { 6, 3, 2, \"sel_3h\", \"sel_comb_6h\", \"sel_3v\", \"sel_comb_6v\" },\n      { 7, 7, 1, \"sel_7h\", \"\", \"sel_7v\", \"\" },\n      { 8, 4, 2, \"sel_4h\", \"sel_comb_8h\", \"sel_4v\", \"sel_comb_8v\" },\n      { 9, 3, 3, \"sel_3h\", \"sel_comb_9h\", \"sel_3v\", \"sel_comb_9v\" },\n      { 10, 5, 2, \"sel_5h\", \"sel_comb_10h\", \"sel_5v\", \"sel_comb_10v\" },\n      { 11, 4, 3, \"sel_4h\", \"sel_comb_12h\", \"sel_4v\", \"sel_comb_12v\" },\n      { 12, 4, 3, \"sel_4h\", \"sel_comb_12h\", \"sel_4v\", \"sel_comb_12v\" },\n      { 13, 4, 3, \"sel_4h\", \"sel_comb_12h\", \"sel_4v\", \"sel_comb_12v\" },\n      { 14, 7, 2, \"sel_7h\", \"sel_comb_14h\", \"sel_7v\", \"sel_comb_14v\" },\n      { 15, 5, 3, \"sel_5h\", \"sel_comb_15h\", \"sel_5v\", \"sel_comb_15v\" },\n      { 16, 4, 4, \"sel_4h\", \"sel_comb_16h\", \"sel_4v\", \"sel_comb_16v\" },\n      { 17, 4, 4, \"sel_4h\", \"sel_comb_16h\", \"sel_4v\", \"sel_comb_16v\" },\n      { 18, 6, 3, \"sel_6h\", \"sel_comb_18h\", \"sel_6v\", \"sel_comb_18v\" },\n      { 19, 5, 4, \"sel_5h\", \"sel_comb_20h\", \"sel_5v\", \"sel_comb_20v\" },\n      { 20, 5, 4, \"sel_5h\", \"sel_comb_20h\", \"sel_5v\", \"sel_comb_20v\" },\n      { 21, 7, 3, \"sel_7h\", \"sel_comb_21h\", \"sel_7v\", \"sel_comb_21v\" },\n      { 22, 11, 2, \"sel_11h\", \"sel_comb_22h\", \"sel_11v\", \"sel_comb_22v\" },\n      { 23, 6, 4, \"sel_6h\", \"sel_comb_24h\", \"sel_6v\", \"sel_comb_24v\" },\n      { 24, 6, 4, \"sel_6h\", \"sel_comb_24h\", \"sel_6v\", \"sel_comb_24v\" },\n      { 25, 5, 5, \"sel_5h\", \"sel_comb_25h\", \"sel_5v\", \"sel_comb_25v\" },\n      { 26, 5, 5, \"sel_5h\", \"sel_comb_25h\", \"sel_5v\", \"sel_comb_25v\" },\n      { 27, 9, 3, \"sel_9h\", \"sel_comb_27h\", \"sel_9v\", \"sel_comb_27v\" },\n      { 28, 7, 4, \"sel_7h\", \"sel_comb_28h\", \"sel_7v\", \"sel_comb_28v\" },\n      { 29, 6, 5, \"sel_6h\", \"sel_comb_30h\", \"sel_6v\", \"sel_comb_30v\" },\n      { 30, 6, 5, \"sel_6h\", \"sel_comb_30h\", \"sel_6v\", \"sel_comb_30v\" },\n      { 31, 6, 5, \"sel_6h\", \"sel_comb_30h\", \"sel_6v\", \"sel_comb_30v\" },\n      { 32, 8, 4, \"sel_8h\", \"sel_comb_32h\", \"sel_8v\", \"sel_comb_32v\" },\n      { 33, 11, 3, \"sel_11h\", \"sel_comb_33h\", \"sel_11v\", \"sel_comb_33v\" },\n      { 34, 7, 5, \"sel_7h\", \"sel_comb_35h\", \"sel_7v\", \"sel_comb_35v\" },\n      { 35, 7, 5, \"sel_7h\", \"sel_comb_35h\", \"sel_7v\", \"sel_comb_35v\" },\n      { 36, 6, 6, \"sel_6h\", \"sel_comb_36h\", \"sel_6v\", \"sel_comb_36v\" },\n      { 37, 6, 6, \"sel_6h\", \"sel_comb_36h\", \"sel_6v\", \"sel_comb_36v\" },\n      { 38, 6, 6, \"sel_6h\", \"sel_comb_36h\", \"sel_6v\", \"sel_comb_36v\" },\n      { 39, 13, 3, \"sel_13h\", \"sel_comb_39h\", \"sel_13v\", \"sel_comb_39v\" },\n      { 40, 8, 5, \"sel_8h\", \"sel_comb_40h\", \"sel_8v\", \"sel_comb_40v\" },\n      { 41, 7, 6, \"sel_7h\", \"sel_comb_42h\", \"sel_7v\", \"sel_comb_42v\" },\n      { 42, 7, 6, \"sel_7h\", \"sel_comb_42h\", \"sel_7v\", \"sel_comb_42v\" },\n      { 43, 7, 6, \"sel_7h\", \"sel_comb_42h\", \"sel_7v\", \"sel_comb_42v\" },\n      { 44, 11, 4, \"sel_11h\", \"sel_comb_44h\", \"sel_11v\", \"sel_comb_44v\" },\n      { 45, 9, 5, \"sel_9h\", \"sel_comb_45h\", \"sel_9v\", \"sel_comb_45v\" },\n      { 46, 9, 5, \"sel_9h\", \"sel_comb_45h\", \"sel_9v\", \"sel_comb_45v\" },\n      { 47, 8, 6, \"sel_8h\", \"sel_comb_48h\", \"sel_8v\", \"sel_comb_48v\" },\n      { 48, 8, 6, \"sel_8h\", \"sel_comb_48h\", \"sel_8v\", \"sel_comb_48v\" },\n      { 49, 7, 7, \"sel_7h\", \"sel_comb_49h\", \"sel_7v\", \"sel_comb_49v\" },\n      { 50, 10, 5, \"sel_10h\", \"sel_comb_50h\", \"sel_10v\", \"sel_comb_50v\" },\n      { 51, 10, 5, \"sel_10h\", \"sel_comb_50h\", \"sel_10v\", \"sel_comb_50v\" },\n      { 52, 13, 4, \"sel_13h\", \"sel_comb_52h\", \"sel_13v\", \"sel_comb_52v\" },\n      { 53, 9, 6, \"sel_9h\", \"sel_comb_54h\", \"sel_9v\", \"sel_comb_54v\" },\n      { 54, 9, 6, \"sel_9h\", \"sel_comb_54h\", \"sel_9v\", \"sel_comb_54v\" },\n      { 55, 11, 5, \"sel_11h\", \"sel_comb_55h\", \"sel_11v\", \"sel_comb_55v\" },\n      { 56, 8, 7, \"sel_8h\", \"sel_comb_56h\", \"sel_8v\", \"sel_comb_56v\" },\n      { 57, 8, 7, \"sel_8h\", \"sel_comb_56h\", \"sel_8v\", \"sel_comb_56v\" },\n      { 58, 8, 7, \"sel_8h\", \"sel_comb_56h\", \"sel_8v\", \"sel_comb_56v\" },\n      { 59, 10, 6, \"sel_10h\", \"sel_comb_60h\", \"sel_10v\", \"sel_comb_60v\" },\n      { 60, 10, 6, \"sel_10h\", \"sel_comb_60h\", \"sel_10v\", \"sel_comb_60v\" },\n      { 61, 10, 6, \"sel_10h\", \"sel_comb_60h\", \"sel_10v\", \"sel_comb_60v\" },\n      { 62, 9, 7, \"sel_9h\", \"sel_comb_63h\", \"sel_9v\", \"sel_comb_63v\" },\n      { 63, 9, 7, \"sel_9h\", \"sel_comb_63h\", \"sel_9v\", \"sel_comb_63v\" } };\n\n\n\n/*------------------------------------------------------------------------*\n *                      Create / Destroy / Copy                           *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   selaCreate()\n *\n * \\param[in]    n initial number of sel ptrs; use 0 for default\n * \\return  sela, or NULL on error\n */\nSELA *\nselaCreate(l_int32  n)\n{\nSELA  *sela;\n\n    PROCNAME(\"selaCreate\");\n\n    if (n <= 0)\n        n = INITIAL_PTR_ARRAYSIZE;\n    if (n > MANY_SELS)\n        L_WARNING(\"%d sels\\n\", procName, n);\n\n    if ((sela = (SELA *)LEPT_CALLOC(1, sizeof(SELA))) == NULL)\n        return (SELA *)ERROR_PTR(\"sela not made\", procName, NULL);\n\n    sela->nalloc = n;\n    sela->n = 0;\n\n        /* make array of se ptrs */\n    if ((sela->sel = (SEL **)LEPT_CALLOC(n, sizeof(SEL *))) == NULL) {\n        LEPT_FREE(sela);\n        return (SELA *)ERROR_PTR(\"sel ptrs not made\", procName, NULL);\n    }\n    return sela;\n}\n\n\n/*!\n * \\brief   selaDestroy()\n *\n * \\param[in,out]   psela to be nulled\n * \\return  void\n */\nvoid\nselaDestroy(SELA  **psela)\n{\nSELA    *sela;\nl_int32  i;\n\n    if (!psela) return;\n    if ((sela = *psela) == NULL)\n        return;\n\n    for (i = 0; i < sela->n; i++)\n        selDestroy(&sela->sel[i]);\n    LEPT_FREE(sela->sel);\n    LEPT_FREE(sela);\n    *psela = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   selCreate()\n *\n * \\param[in]    height, width\n * \\param[in]    name [optional] sel name; can be null\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) selCreate() initializes all values to 0.\n *      (2) After this call, (cy,cx) and nonzero data values must be\n *          assigned.  If a text name is not assigned here, it will\n *          be needed later when the sel is put into a sela.\n * </pre>\n */\nSEL *\nselCreate(l_int32      height,\n          l_int32      width,\n          const char  *name)\n{\nSEL  *sel;\n\n    PROCNAME(\"selCreate\");\n\n    if ((sel = (SEL *)LEPT_CALLOC(1, sizeof(SEL))) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    if (name)\n        sel->name = stringNew(name);\n    sel->sy = height;\n    sel->sx = width;\n    if ((sel->data = create2dIntArray(height, width)) == NULL) {\n        LEPT_FREE(sel->name);\n        LEPT_FREE(sel);\n        return (SEL *)ERROR_PTR(\"data not allocated\", procName, NULL);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selDestroy()\n *\n * \\param[in,out]   psel to be nulled\n * \\return  void\n */\nvoid\nselDestroy(SEL  **psel)\n{\nl_int32  i;\nSEL     *sel;\n\n    PROCNAME(\"selDestroy\");\n\n    if (psel == NULL)  {\n        L_WARNING(\"ptr address is NULL!\\n\", procName);\n        return;\n    }\n    if ((sel = *psel) == NULL)\n        return;\n\n    for (i = 0; i < sel->sy; i++)\n        LEPT_FREE(sel->data[i]);\n    LEPT_FREE(sel->data);\n    if (sel->name)\n        LEPT_FREE(sel->name);\n    LEPT_FREE(sel);\n\n    *psel = NULL;\n    return;\n}\n\n\n/*!\n * \\brief   selCopy()\n *\n * \\param[in]    sel\n * \\return  a copy of the sel, or NULL on error\n */\nSEL *\nselCopy(SEL  *sel)\n{\nl_int32  sx, sy, cx, cy, i, j;\nSEL     *csel;\n\n    PROCNAME(\"selCopy\");\n\n    if (!sel)\n        return (SEL *)ERROR_PTR(\"sel not defined\", procName, NULL);\n\n    if ((csel = (SEL *)LEPT_CALLOC(1, sizeof(SEL))) == NULL)\n        return (SEL *)ERROR_PTR(\"csel not made\", procName, NULL);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    csel->sy = sy;\n    csel->sx = sx;\n    csel->cy = cy;\n    csel->cx = cx;\n\n    if ((csel->data = create2dIntArray(sy, sx)) == NULL) {\n        LEPT_FREE(csel);\n        return (SEL *)ERROR_PTR(\"sel data not made\", procName, NULL);\n    }\n\n    for (i = 0; i < sy; i++)\n        for (j = 0; j < sx; j++)\n            csel->data[i][j] = sel->data[i][j];\n\n    if (sel->name)\n        csel->name = stringNew(sel->name);\n\n    return csel;\n}\n\n\n/*!\n * \\brief   selCreateBrick()\n *\n * \\param[in]    h, w    height, width\n * \\param[in]    cy, cx  origin, relative to UL corner at 0,0\n * \\param[in]    type    SEL_HIT, SEL_MISS, or SEL_DONT_CARE\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is a rectangular sel of all hits, misses or don't cares.\n * </pre>\n */\nSEL *\nselCreateBrick(l_int32  h,\n               l_int32  w,\n               l_int32  cy,\n               l_int32  cx,\n               l_int32  type)\n{\nl_int32  i, j;\nSEL     *sel;\n\n    PROCNAME(\"selCreateBrick\");\n\n    if (h <= 0 || w <= 0)\n        return (SEL *)ERROR_PTR(\"h and w must both be > 0\", procName, NULL);\n    if (type != SEL_HIT && type != SEL_MISS && type != SEL_DONT_CARE)\n        return (SEL *)ERROR_PTR(\"invalid sel element type\", procName, NULL);\n\n    if ((sel = selCreate(h, w, NULL)) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < h; i++)\n        for (j = 0; j < w; j++)\n            sel->data[i][j] = type;\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selCreateComb()\n *\n * \\param[in]    factor1 contiguous space between comb tines\n * \\param[in]    factor2 number of comb tines\n * \\param[in]    direction L_HORIZ, L_VERT\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This generates a comb Sel of hits with the origin as\n *          near the center as possible.\n *      (2) In use, this is complemented by a brick sel of size %factor1,\n *          Both brick and comb sels are made by selectComposableSels().\n * </pre>\n */\nSEL *\nselCreateComb(l_int32  factor1,\n              l_int32  factor2,\n              l_int32  direction)\n{\nl_int32  i, size, z;\nSEL     *sel;\n\n    PROCNAME(\"selCreateComb\");\n\n    if (factor1 < 1 || factor2 < 1)\n        return (SEL *)ERROR_PTR(\"factors must be >= 1\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (SEL *)ERROR_PTR(\"invalid direction\", procName, NULL);\n\n    size = factor1 * factor2;\n    if (direction == L_HORIZ) {\n        sel = selCreate(1, size, NULL);\n        selSetOrigin(sel, 0, size / 2);\n    } else {\n        sel = selCreate(size, 1, NULL);\n        selSetOrigin(sel, size / 2, 0);\n    }\n\n        /* Lay down the elements of the comb */\n    for (i = 0; i < factor2; i++) {\n        z = factor1 / 2 + i * factor1;\n/*        fprintf(stderr, \"i = %d, factor1 = %d, factor2 = %d, z = %d\\n\",\n                        i, factor1, factor2, z); */\n        if (direction == L_HORIZ)\n            selSetElement(sel, 0, z, SEL_HIT);\n        else\n            selSetElement(sel, z, 0, SEL_HIT);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   create2dIntArray()\n *\n * \\param[in]    sy rows == height\n * \\param[in]    sx columns == width\n * \\return  doubly indexed array i.e., an array of sy row pointers,\n *              each of which points to an array of sx ints\n *\n * <pre>\n * Notes:\n *      (1) The array[sy][sx] is indexed in standard \"matrix notation\",\n *          with the row index first.\n * </pre>\n */\nl_int32 **\ncreate2dIntArray(l_int32  sy,\n                 l_int32  sx)\n{\nl_int32    i, j, success;\nl_int32  **array;\n\n    PROCNAME(\"create2dIntArray\");\n\n    if ((array = (l_int32 **)LEPT_CALLOC(sy, sizeof(l_int32 *))) == NULL)\n        return (l_int32 **)ERROR_PTR(\"ptr array not made\", procName, NULL);\n\n    success = TRUE;\n    for (i = 0; i < sy; i++) {\n        if ((array[i] = (l_int32 *)LEPT_CALLOC(sx, sizeof(l_int32))) == NULL) {\n            success = FALSE;\n            break;\n        }\n    }\n    if (success) return array;\n\n        /* Cleanup after error */\n    for (j = 0; j < i; j++)\n        LEPT_FREE(array[j]);\n    LEPT_FREE(array);\n    return (l_int32 **)ERROR_PTR(\"array not made\", procName, NULL);\n}\n\n\n\n/*------------------------------------------------------------------------*\n *                           Extension of sela                            *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   selaAddSel()\n *\n * \\param[in]    sela\n * \\param[in]    sel to be added\n * \\param[in]    selname ignored if already defined in sel;\n *                       req'd in sel when added to a sela\n * \\param[in]    copyflag  L_INSERT or L_COPY\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This adds a sel, either inserting or making a copy.\n *      (2) Because every sel in a sela must have a name, it copies\n *          the input name if necessary.  You can input NULL for\n *          selname if the sel already has a name.\n * </pre>\n */\nl_int32\nselaAddSel(SELA        *sela,\n           SEL         *sel,\n           const char  *selname,\n           l_int32      copyflag)\n{\nl_int32  n;\nSEL     *csel;\n\n    PROCNAME(\"selaAddSel\");\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (!sel->name && !selname)\n        return ERROR_INT(\"added sel must have name\", procName, 1);\n    if (copyflag != L_INSERT && copyflag != L_COPY)\n        return ERROR_INT(\"invalid copyflag\", procName, 1);\n\n    if (copyflag == L_COPY) {\n        if ((csel = selCopy(sel)) == NULL)\n            return ERROR_INT(\"csel not made\", procName, 1);\n    } else {  /* copyflag == L_INSERT */\n        csel = sel;\n    }\n    if (!csel->name)\n        csel->name = stringNew(selname);\n\n    n = selaGetCount(sela);\n    if (n >= sela->nalloc)\n        selaExtendArray(sela);\n    sela->sel[n] = csel;\n    sela->n++;\n\n    return 0;\n}\n\n\n/*!\n * \\brief   selaExtendArray()\n *\n * \\param[in]    sela\n * \\return  0 if OK; 1 on error\n */\nstatic l_int32\nselaExtendArray(SELA  *sela)\n{\n    PROCNAME(\"selaExtendArray\");\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    if ((sela->sel = (SEL **)reallocNew((void **)&sela->sel,\n                              sizeof(SEL *) * sela->nalloc,\n                              2 * sizeof(SEL *) * sela->nalloc)) == NULL)\n            return ERROR_INT(\"new ptr array not returned\", procName, 1);\n\n    sela->nalloc = 2 * sela->nalloc;\n    return 0;\n}\n\n\n\n/*----------------------------------------------------------------------*\n *                               Accessors                              *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selaGetCount()\n *\n * \\param[in]    sela\n * \\return  count, or 0 on error\n */\nl_int32\nselaGetCount(SELA  *sela)\n{\n    PROCNAME(\"selaGetCount\");\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 0);\n\n    return sela->n;\n}\n\n\n/*!\n * \\brief   selaGetSel()\n *\n * \\param[in]    sela\n * \\param[in]    i index of sel to be retrieved not copied\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This returns a ptr to the sel, not a copy, so the caller\n *          must not destroy it!\n * </pre>\n */\nSEL *\nselaGetSel(SELA    *sela,\n           l_int32  i)\n{\n    PROCNAME(\"selaGetSel\");\n\n    if (!sela)\n        return (SEL *)ERROR_PTR(\"sela not defined\", procName, NULL);\n\n    if (i < 0 || i >= sela->n)\n        return (SEL *)ERROR_PTR(\"invalid index\", procName, NULL);\n    return sela->sel[i];\n}\n\n\n/*!\n * \\brief   selGetName()\n *\n * \\param[in]    sel\n * \\return  sel name not copied, or NULL if no name or on error\n */\nchar *\nselGetName(SEL  *sel)\n{\n    PROCNAME(\"selGetName\");\n\n    if (!sel)\n        return (char *)ERROR_PTR(\"sel not defined\", procName, NULL);\n\n    return sel->name;\n}\n\n\n/*!\n * \\brief   selSetName()\n *\n * \\param[in]    sel\n * \\param[in]    name [optional]; can be null\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Always frees the existing sel name, if defined.\n *      (2) If name is not defined, just clears any existing sel name.\n * </pre>\n */\nl_int32\nselSetName(SEL         *sel,\n           const char  *name)\n{\n    PROCNAME(\"selSetName\");\n\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n\n    return stringReplace(&sel->name, name);\n}\n\n\n/*!\n * \\brief   selaFindSelByName()\n *\n * \\param[in]    sela\n * \\param[in]    name sel name\n * \\param[out]   pindex [optional]\n * \\param[in]    psel   [optional] sel (not a copy)\n * \\return  0 if OK; 1 on error\n */\nl_int32\nselaFindSelByName(SELA        *sela,\n                  const char  *name,\n                  l_int32     *pindex,\n                  SEL        **psel)\n{\nl_int32  i, n;\nchar    *sname;\nSEL     *sel;\n\n    PROCNAME(\"selaFindSelByName\");\n\n    if (pindex) *pindex = -1;\n    if (psel) *psel = NULL;\n\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    n = selaGetCount(sela);\n    for (i = 0; i < n; i++)\n    {\n        if ((sel = selaGetSel(sela, i)) == NULL) {\n            L_WARNING(\"missing sel\\n\", procName);\n            continue;\n        }\n\n        sname = selGetName(sel);\n        if (sname && (!strcmp(name, sname))) {\n            if (pindex)\n                *pindex = i;\n            if (psel)\n                *psel = sel;\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n\n/*!\n * \\brief   selGetElement()\n *\n * \\param[in]    sel\n * \\param[in]    row\n * \\param[in]    col\n * \\param[out]   ptype  SEL_HIT, SEL_MISS, SEL_DONT_CARE\n * \\return  0 if OK; 1 on error\n */\nl_int32\nselGetElement(SEL      *sel,\n              l_int32   row,\n              l_int32   col,\n              l_int32  *ptype)\n{\n    PROCNAME(\"selGetElement\");\n\n    if (!ptype)\n        return ERROR_INT(\"&type not defined\", procName, 1);\n    *ptype = SEL_DONT_CARE;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (row < 0 || row >= sel->sy)\n        return ERROR_INT(\"sel row out of bounds\", procName, 1);\n    if (col < 0 || col >= sel->sx)\n        return ERROR_INT(\"sel col out of bounds\", procName, 1);\n\n    *ptype = sel->data[row][col];\n    return 0;\n}\n\n\n/*!\n * \\brief   selSetElement()\n *\n * \\param[in]    sel\n * \\param[in]    row\n * \\param[in]    col\n * \\param[in]    type  SEL_HIT, SEL_MISS, SEL_DONT_CARE\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Because we use row and column to index into an array,\n *          they are always non-negative.  The location of the origin\n *          (and the type of operation) determine the actual\n *          direction of the rasterop.\n * </pre>\n */\nl_int32\nselSetElement(SEL     *sel,\n              l_int32  row,\n              l_int32  col,\n              l_int32  type)\n{\n    PROCNAME(\"selSetElement\");\n\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (type != SEL_HIT && type != SEL_MISS && type != SEL_DONT_CARE)\n        return ERROR_INT(\"invalid sel element type\", procName, 1);\n    if (row < 0 || row >= sel->sy)\n        return ERROR_INT(\"sel row out of bounds\", procName, 1);\n    if (col < 0 || col >= sel->sx)\n        return ERROR_INT(\"sel col out of bounds\", procName, 1);\n\n    sel->data[row][col] = type;\n    return 0;\n}\n\n\n/*!\n * \\brief   selGetParameters()\n *\n * \\param[in]    sel\n * \\param[out]   psy, psx, pcy, pcx [optional]  each can be null\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselGetParameters(SEL      *sel,\n                 l_int32  *psy,\n                 l_int32  *psx,\n                 l_int32  *pcy,\n                 l_int32  *pcx)\n{\n    PROCNAME(\"selGetParameters\");\n\n    if (psy) *psy = 0;\n    if (psx) *psx = 0;\n    if (pcy) *pcy = 0;\n    if (pcx) *pcx = 0;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    if (psy) *psy = sel->sy;\n    if (psx) *psx = sel->sx;\n    if (pcy) *pcy = sel->cy;\n    if (pcx) *pcx = sel->cx;\n    return 0;\n}\n\n\n/*!\n * \\brief   selSetOrigin()\n *\n * \\param[in]    sel\n * \\param[in]    cy, cx\n * \\return  0 if OK; 1 on error\n */\nl_int32\nselSetOrigin(SEL     *sel,\n             l_int32  cy,\n             l_int32  cx)\n{\n    PROCNAME(\"selSetOrigin\");\n\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    sel->cy = cy;\n    sel->cx = cx;\n    return 0;\n}\n\n\n/*!\n * \\brief   selGetTypeAtOrigin()\n *\n * \\param[in]    sel\n * \\param[out]   ptype  SEL_HIT, SEL_MISS, SEL_DONT_CARE\n * \\return  0 if OK; 1 on error or if origin is not found\n */\nl_int32\nselGetTypeAtOrigin(SEL      *sel,\n                   l_int32  *ptype)\n{\nl_int32  sx, sy, cx, cy, i, j;\n\n    PROCNAME(\"selGetTypeAtOrigin\");\n\n    if (!ptype)\n        return ERROR_INT(\"&type not defined\", procName, 1);\n    *ptype = SEL_DONT_CARE;  /* init */\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            if (i == cy && j == cx) {\n                selGetElement(sel, i, j, ptype);\n                return 0;\n            }\n        }\n    }\n\n    return ERROR_INT(\"sel origin not found\", procName, 1);\n}\n\n\n/*!\n * \\brief   selaGetBrickName()\n *\n * \\param[in]    sela\n * \\param[in]    hsize, vsize of brick sel\n * \\return  sel name new string, or NULL if no name or on error\n */\nchar *\nselaGetBrickName(SELA    *sela,\n                 l_int32  hsize,\n                 l_int32  vsize)\n{\nl_int32  i, nsels, sx, sy;\nSEL     *sel;\n\n    PROCNAME(\"selaGetBrickName\");\n\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (hsize == sx && vsize == sy)\n            return stringNew(selGetName(sel));\n    }\n\n    return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}\n\n\n/*!\n * \\brief   selaGetCombName()\n *\n * \\param[in]    sela\n * \\param[in]    size the product of sizes of the brick and comb parts\n * \\param[in]    direction L_HORIZ, L_VERT\n * \\return  sel name new string, or NULL if name not found or on error\n *\n * <pre>\n * Notes:\n *      (1) Combs are by definition 1-dimensional, either horiz or vert.\n *      (2) Use this with comb Sels; e.g., from selaAddDwaCombs().\n * </pre>\n */\nchar *\nselaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUFSIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n\n    PROCNAME(\"selaGetCombName\");\n\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n\n        /* Derive the comb name we're looking for */\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUFSIZE, \"sel_comb_%dh\", size);\n    else  /* direction == L_VERT */\n        snprintf(combname, L_BUFSIZE, \"sel_comb_%dv\", size);\n\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  /* 2-D; not a comb */\n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}\n\n\n/* --------- Function used to generate code in this file  ---------- */\n#if 0\nstatic void selaComputeCompositeParameters(const char *fileout);\n\n/*!\n * \\brief   selaComputeCompParameters()\n *\n * \\param[in]    output filename\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) This static function was used to construct the comp_parameter_map[]\n *          array at the top of this file.  It is static because it does\n *          not need to be called again.  It remains here to show how\n *          the composite parameter map was computed.\n *      (2) The output file was pasted directly into comp_parameter_map[].\n *          The composite parameter map is used to quickly determine\n *          the linear decomposition parameters and sel names.\n * </pre>\n */\nstatic void\nselaComputeCompositeParameters(const char  *fileout)\n{\nchar    *str, *nameh1, *nameh2, *namev1, *namev2;\nchar     buf[L_BUFSIZE];\nl_int32  size, size1, size2, len;\nSARRAY  *sa;\nSELA    *selabasic, *selacomb;\n\n    selabasic = selaAddBasic(NULL);\n    selacomb = selaAddDwaCombs(NULL);\n    sa = sarrayCreate(64);\n    for (size = 2; size < 64; size++) {\n        selectComposableSizes(size, &size1, &size2);\n        nameh1 = selaGetBrickName(selabasic, size1, 1);\n        namev1 = selaGetBrickName(selabasic, 1, size1);\n        if (size2 > 1) {\n            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);\n            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);\n        } else {\n            nameh2 = stringNew(\"\");\n            namev2 = stringNew(\"\");\n        }\n        snprintf(buf, L_BUFSIZE,\n                 \"      { %d, %d, %d, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\",\n                 size, size1, size2, nameh1, nameh2, namev1, namev2);\n        sarrayAddString(sa, buf, L_COPY);\n        LEPT_FREE(nameh1);\n        LEPT_FREE(nameh2);\n        LEPT_FREE(namev1);\n        LEPT_FREE(namev2);\n    }\n    str = sarrayToString(sa, 1);\n    len = strlen(str);\n    l_binaryWrite(fileout, \"w\", str, len + 1);\n    LEPT_FREE(str);\n    sarrayDestroy(&sa);\n    selaDestroy(&selabasic);\n    selaDestroy(&selacomb);\n    return;\n}\n#endif\n/* -------------------------------------------------------------------- */\n\n\n/*!\n * \\brief   getCompositeParameters()\n *\n * \\param[in]    size\n * \\param[out]   psize1 [optional] brick factor size\n * \\param[out]   psize2 [optional] comb factor size\n * \\param[out]   pnameh1 [optional] name of horiz brick\n * \\param[out]   pnameh2 [optional] name of horiz comb\n * \\param[out]   pnamev1 [optional] name of vert brick\n * \\param[out]   pnamev2 [optional] name of vert comb\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This uses the big lookup table at the top of this file.\n *      (2) All returned strings are copies that must be freed.\n * </pre>\n */\nl_int32\ngetCompositeParameters(l_int32   size,\n                       l_int32  *psize1,\n                       l_int32  *psize2,\n                       char    **pnameh1,\n                       char    **pnameh2,\n                       char    **pnamev1,\n                       char    **pnamev2)\n{\nl_int32  index;\n\n    PROCNAME(\"selaGetSelnames\");\n\n    if (psize1) *psize1 = 0;\n    if (psize2) *psize2 = 0;\n    if (pnameh1) *pnameh1 = NULL;\n    if (pnameh2) *pnameh2 = NULL;\n    if (pnamev1) *pnamev1 = NULL;\n    if (pnamev2) *pnamev2 = NULL;\n    if (size < 2 || size > 63)\n        return ERROR_INT(\"valid size range is {2 ... 63}\", procName, 1);\n    index = size - 2;\n    if (psize1)\n        *psize1 = comp_parameter_map[index].size1;\n    if (psize2)\n        *psize2 = comp_parameter_map[index].size2;\n    if (pnameh1)\n        *pnameh1 = stringNew(comp_parameter_map[index].selnameh1);\n    if (pnameh2)\n        *pnameh2 = stringNew(comp_parameter_map[index].selnameh2);\n    if (pnamev1)\n        *pnamev1 = stringNew(comp_parameter_map[index].selnamev1);\n    if (pnamev2)\n        *pnamev2 = stringNew(comp_parameter_map[index].selnamev2);\n    return 0;\n}\n\n\n/*!\n * \\brief   selaGetSelnames()\n *\n * \\param[in]    sela\n * \\return  sa of all sel names, or NULL on error\n */\nSARRAY *\nselaGetSelnames(SELA  *sela)\n{\nchar    *selname;\nl_int32  i, n;\nSEL     *sel;\nSARRAY  *sa;\n\n    PROCNAME(\"selaGetSelnames\");\n\n    if (!sela)\n        return (SARRAY *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if ((n = selaGetCount(sela)) == 0)\n        return (SARRAY *)ERROR_PTR(\"no sels in sela\", procName, NULL);\n\n    if ((sa = sarrayCreate(n)) == NULL)\n        return (SARRAY *)ERROR_PTR(\"sa not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        sel = selaGetSel(sela, i);\n        selname = selGetName(sel);\n        sarrayAddString(sa, selname, L_COPY);\n    }\n\n    return sa;\n}\n\n\n\n/*----------------------------------------------------------------------*\n *                Max translations for erosion and hmt                  *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selFindMaxTranslations()\n *\n * \\param[in]    sel\n * \\param[out]   pxp, pyp, pxn, pyn  max shifts\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n          These are the maximum shifts for the erosion operation.\n *        For example, when j < cx, the shift of the image\n *        is +x to the cx.  This is a positive xp shift.\n * </pre>\n */\nl_int32\nselFindMaxTranslations(SEL      *sel,\n                       l_int32  *pxp,\n                       l_int32  *pyp,\n                       l_int32  *pxn,\n                       l_int32  *pyn)\n{\nl_int32  sx, sy, cx, cy, i, j;\nl_int32  maxxp, maxyp, maxxn, maxyn;\n\n    PROCNAME(\"selaFindMaxTranslations\");\n\n    if (!pxp || !pyp || !pxn || !pyn)\n        return ERROR_INT(\"&xp (etc) defined\", procName, 1);\n    *pxp = *pyp = *pxn = *pyn = 0;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n\n    maxxp = maxyp = maxxn = maxyn = 0;\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            if (sel->data[i][j] == 1) {\n                maxxp = L_MAX(maxxp, cx - j);\n                maxyp = L_MAX(maxyp, cy - i);\n                maxxn = L_MAX(maxxn, j - cx);\n                maxyn = L_MAX(maxyn, i - cy);\n            }\n        }\n    }\n\n    *pxp = maxxp;\n    *pyp = maxyp;\n    *pxn = maxxn;\n    *pyn = maxyn;\n\n    return 0;\n}\n\n\n/*----------------------------------------------------------------------*\n *                   Rotation by multiples of 90 degrees                *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selRotateOrth()\n *\n * \\param[in]    sel\n * \\param[in]    quads 0 - 4; number of 90 degree cw rotations\n * \\return  seld, or NULL on error\n */\nSEL  *\nselRotateOrth(SEL     *sel,\n              l_int32  quads)\n{\nl_int32  i, j, ni, nj, sx, sy, cx, cy, nsx, nsy, ncx, ncy, type;\nSEL     *seld;\n\n    PROCNAME(\"selRotateOrth\");\n\n    if (!sel)\n        return (SEL *)ERROR_PTR(\"sel not defined\", procName, NULL);\n    if (quads < 0 || quads > 4)\n        return (SEL *)ERROR_PTR(\"quads not in {0,1,2,3,4}\", procName, NULL);\n    if (quads == 0 || quads == 4)\n        return selCopy(sel);\n\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    if (quads == 1) {  /* 90 degrees cw */\n        nsx = sy;\n        nsy = sx;\n        ncx = sy - cy - 1;\n        ncy = cx;\n    } else if (quads == 2) {  /* 180 degrees cw */\n        nsx = sx;\n        nsy = sy;\n        ncx = sx - cx - 1;\n        ncy = sy - cy - 1;\n    } else {  /* 270 degrees cw */\n        nsx = sy;\n        nsy = sx;\n        ncx = cy;\n        ncy = sx - cx - 1;\n    }\n    seld = selCreateBrick(nsy, nsx, ncy, ncx, SEL_DONT_CARE);\n    if (sel->name)\n        seld->name = stringNew(sel->name);\n\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            selGetElement(sel, i, j, &type);\n            if (quads == 1) {\n               ni = j;\n               nj = sy - i - 1;\n            } else if (quads == 2) {\n               ni = sy - i - 1;\n               nj = sx - j - 1;\n            } else {  /* quads == 3 */\n               ni = sx - j - 1;\n               nj = i;\n            }\n            selSetElement(seld, ni, nj, type);\n        }\n    }\n\n    return seld;\n}\n\n\n/*----------------------------------------------------------------------*\n *                       Sela and Sel serialized I/O                    *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selaRead()\n *\n * \\param[in]    fname filename\n * \\return  sela, or NULL on error\n */\nSELA  *\nselaRead(const char  *fname)\n{\nFILE  *fp;\nSELA  *sela;\n\n    PROCNAME(\"selaRead\");\n\n    if (!fname)\n        return (SELA *)ERROR_PTR(\"fname not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(fname)) == NULL)\n        return (SELA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if ((sela = selaReadStream(fp)) == NULL) {\n        fclose(fp);\n        return (SELA *)ERROR_PTR(\"sela not returned\", procName, NULL);\n    }\n    fclose(fp);\n\n    return sela;\n}\n\n\n/*!\n * \\brief   selaReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  sela, or NULL on error\n */\nSELA  *\nselaReadStream(FILE  *fp)\n{\nl_int32  i, n, version;\nSEL     *sel;\nSELA    *sela;\n\n    PROCNAME(\"selaReadStream\");\n\n    if (!fp)\n        return (SELA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\nSela Version %d\\n\", &version) != 1)\n        return (SELA *)ERROR_PTR(\"not a sela file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SELA *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n    if (fscanf(fp, \"Number of Sels = %d\\n\\n\", &n) != 1)\n        return (SELA *)ERROR_PTR(\"not a sela file\", procName, NULL);\n\n    if ((sela = selaCreate(n)) == NULL)\n        return (SELA *)ERROR_PTR(\"sela not made\", procName, NULL);\n    sela->nalloc = n;\n\n    for (i = 0; i < n; i++) {\n        if ((sel = selReadStream(fp)) == NULL) {\n            selaDestroy(&sela);\n            return (SELA *)ERROR_PTR(\"sel not read\", procName, NULL);\n        }\n        selaAddSel(sela, sel, NULL, 0);\n    }\n\n    return sela;\n}\n\n\n/*!\n * \\brief   selRead()\n *\n * \\param[in]    fname filename\n * \\return  sel, or NULL on error\n */\nSEL  *\nselRead(const char  *fname)\n{\nFILE  *fp;\nSEL   *sel;\n\n    PROCNAME(\"selRead\");\n\n    if (!fname)\n        return (SEL *)ERROR_PTR(\"fname not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(fname)) == NULL)\n        return (SEL *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if ((sel = selReadStream(fp)) == NULL) {\n        fclose(fp);\n        return (SEL *)ERROR_PTR(\"sela not returned\", procName, NULL);\n    }\n    fclose(fp);\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selReadStream()\n *\n * \\param[in]    fp file stream\n * \\return  sel, or NULL on error\n */\nSEL  *\nselReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[L_BUFSIZE];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n\n    PROCNAME(\"selReadStream\");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n\n    if (fgets(linebuf, L_BUFSIZE, fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %200s  ------\", selname);\n\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n\n    LEPT_FREE(selname);\n    return sel;\n}\n\n\n/*!\n * \\brief   selaWrite()\n *\n * \\param[in]    fname filename\n * \\param[in]    sela\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselaWrite(const char  *fname,\n          SELA        *sela)\n{\nFILE  *fp;\n\n    PROCNAME(\"selaWrite\");\n\n    if (!fname)\n        return ERROR_INT(\"fname not defined\", procName, 1);\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(fname, \"wb\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    selaWriteStream(fp, sela);\n    fclose(fp);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   selaWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    sela\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselaWriteStream(FILE  *fp,\n                SELA  *sela)\n{\nl_int32  i, n;\nSEL     *sel;\n\n    PROCNAME(\"selaWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!sela)\n        return ERROR_INT(\"sela not defined\", procName, 1);\n\n    n = selaGetCount(sela);\n    fprintf(fp, \"\\nSela Version %d\\n\", SEL_VERSION_NUMBER);\n    fprintf(fp, \"Number of Sels = %d\\n\\n\", n);\n    for (i = 0; i < n; i++) {\n        if ((sel = selaGetSel(sela, i)) == NULL)\n            continue;\n        selWriteStream(fp, sel);\n    }\n    return 0;\n}\n\n\n/*!\n * \\brief   selWrite()\n *\n * \\param[in]    fname filename\n * \\param[in]    sel\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselWrite(const char  *fname,\n         SEL         *sel)\n{\nFILE  *fp;\n\n    PROCNAME(\"selWrite\");\n\n    if (!fname)\n        return ERROR_INT(\"fname not defined\", procName, 1);\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n\n    if ((fp = fopenWriteStream(fname, \"wb\")) == NULL)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n    selWriteStream(fp, sel);\n    fclose(fp);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   selWriteStream()\n *\n * \\param[in]    fp file stream\n * \\param[in]    sel\n * \\return  0 if OK, 1 on error\n */\nl_int32\nselWriteStream(FILE  *fp,\n               SEL   *sel)\n{\nl_int32  sx, sy, cx, cy, i, j;\n\n    PROCNAME(\"selWriteStream\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n\n    fprintf(fp, \"  Sel Version %d\\n\", SEL_VERSION_NUMBER);\n    fprintf(fp, \"  ------  %s  ------\\n\", selGetName(sel));\n    fprintf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\", sy, sx, cy, cx);\n    for (i = 0; i < sy; i++) {\n        fprintf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            fprintf(fp, \"%d\", sel->data[i][j]);\n        fprintf(fp, \"\\n\");\n    }\n    fprintf(fp, \"\\n\");\n\n    return 0;\n}\n\n\n/*----------------------------------------------------------------------*\n *           Building custom hit-miss sels from compiled strings        *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selCreateFromString()\n *\n * \\param[in]    text\n * \\param[in]    h, w  height, width\n * \\param[in]    name  [optional] sel name; can be null\n * \\return  sel of the given size, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The text is an array of chars (in row-major order) where\n *          each char can be one of the following:\n *             'x': hit\n *             'o': miss\n *             ' ': don't-care\n *      (2) When the origin falls on a hit or miss, use an upper case\n *          char (e.g., 'X' or 'O') to indicate it.  When the origin\n *          falls on a don't-care, indicate this with a 'C'.\n *          The string must have exactly one origin specified.\n *      (3) The advantage of this method is that the text can be input\n *          in a format that shows the 2D layout of the Sel; e.g.,\n * \\code\n *              static const char *seltext = \"x    \"\n *                                           \"x Oo \"\n *                                           \"x    \"\n *                                           \"xxxxx\";\n * \\endcode\n * </pre>\n */\nSEL *\nselCreateFromString(const char  *text,\n                    l_int32      h,\n                    l_int32      w,\n                    const char  *name)\n{\nSEL     *sel;\nl_int32  y, x, norig;\nchar     ch;\n\n    PROCNAME(\"selCreateFromString\");\n\n    if (h < 1)\n        return (SEL *)ERROR_PTR(\"height must be > 0\", procName, NULL);\n    if (w < 1)\n        return (SEL *)ERROR_PTR(\"width must be > 0\", procName, NULL);\n\n    sel = selCreate(h, w, name);\n\n    norig = 0;\n    for (y = 0; y < h; ++y) {\n        for (x = 0; x < w; ++x) {\n            ch = *(text++);\n            switch (ch)\n            {\n                case 'X':\n                    norig++;\n                    selSetOrigin(sel, y, x);\n                case 'x':\n                    selSetElement(sel, y, x, SEL_HIT);\n                    break;\n\n                case 'O':\n                    norig++;\n                    selSetOrigin(sel, y, x);\n                case 'o':\n                    selSetElement(sel, y, x, SEL_MISS);\n                    break;\n\n                case 'C':\n                    norig++;\n                    selSetOrigin(sel, y, x);\n                case ' ':\n                    selSetElement(sel, y, x, SEL_DONT_CARE);\n                    break;\n\n                case '\\n':\n                    /* ignored */\n                    continue;\n\n                default:\n                    selDestroy(&sel);\n                    return (SEL *)ERROR_PTR(\"unknown char\", procName, NULL);\n            }\n        }\n    }\n    if (norig != 1) {\n        L_ERROR(\"Exactly one origin must be specified; this string has %d\\n\",\n                procName, norig);\n        selDestroy(&sel);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selPrintToString()\n *\n * \\param[in]    sel\n * \\return  str string; caller must free\n *\n * <pre>\n * Notes:\n *      (1) This is an inverse function of selCreateFromString.\n *          It prints a textual representation of the SEL to a malloc'd\n *          string.  The format is the same as selCreateFromString\n *          except that newlines are inserted into the output\n *          between rows.\n *      (2) This is useful for debugging.  However, if you want to\n *          save some Sels in a file, put them in a Sela and write\n *          them out with selaWrite().  They can then be read in\n *          with selaRead().\n * </pre>\n */\nchar *\nselPrintToString(SEL  *sel)\n{\nchar     is_center;\nchar    *str, *strptr;\nl_int32  type;\nl_int32  sx, sy, cx, cy, x, y;\n\n    PROCNAME(\"selPrintToString\");\n\n    if (!sel)\n        return (char *)ERROR_PTR(\"sel not defined\", procName, NULL);\n\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    if ((str = (char *)LEPT_CALLOC(1, sy * (sx + 1) + 1)) == NULL)\n        return (char *)ERROR_PTR(\"calloc fail for str\", procName, NULL);\n    strptr = str;\n\n    for (y = 0; y < sy; ++y) {\n        for (x = 0; x < sx; ++x) {\n            selGetElement(sel, y, x, &type);\n            is_center = (x == cx && y == cy);\n            switch (type) {\n                case SEL_HIT:\n                    *(strptr++) = is_center ? 'X' : 'x';\n                    break;\n                case SEL_MISS:\n                    *(strptr++) = is_center ? 'O' : 'o';\n                    break;\n                case SEL_DONT_CARE:\n                    *(strptr++) = is_center ? 'C' : ' ';\n                    break;\n            }\n        }\n        *(strptr++) = '\\n';\n    }\n\n    return str;\n}\n\n\n/*----------------------------------------------------------------------*\n *         Building custom hit-miss sels from a simple file format      *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selaCreateFromFile()\n *\n * \\param[in]    filename\n * \\return  sela, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The file contains a sequence of Sel descriptions.\n *      (2) Each Sel is formatted as follows:\n *           ~ Any number of comment lines starting with '#' are ignored\n *           ~ The next line contains the selname\n *           ~ The next lines contain the Sel data.  They must be\n *             formatted similarly to the string format in\n *             selCreateFromString(), with each line beginning and\n *             ending with a double-quote, and showing the 2D layout.\n *           ~ Each Sel ends when a blank line, a comment line, or\n *             the end of file is reached.\n *      (3) See selCreateFromString() for a description of the string\n *          format for the Sel data.  As an example, here are the lines\n *          of is a valid file for a single Sel.  In the file, all lines\n *          are left-justified:\n *                    # diagonal sel\n *                    sel_5diag\n *                    \"x    \"\n *                    \" x   \"\n *                    \"  X  \"\n *                    \"   x \"\n *                    \"    x\"\n * </pre>\n */\nSELA *\nselaCreateFromFile(const char  *filename)\n{\nchar    *filestr, *line;\nl_int32  i, n, first, last, nsel, insel;\nsize_t   nbytes;\nNUMA    *nafirst, *nalast;\nSARRAY  *sa;\nSEL     *sel;\nSELA    *sela;\n\n    PROCNAME(\"selaCreateFromFile\");\n\n    if (!filename)\n        return (SELA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    filestr = (char *)l_binaryRead(filename, &nbytes);\n    sa = sarrayCreateLinesFromString(filestr, 1);\n    LEPT_FREE(filestr);\n    n = sarrayGetCount(sa);\n    sela = selaCreate(0);\n\n        /* Find the start and end lines for each Sel.\n         * We allow the \"blank\" lines to be null strings or\n         * to have standard whitespace (' ','\\t',\\'n') or be '#'. */\n    nafirst = numaCreate(0);\n    nalast = numaCreate(0);\n    insel = FALSE;\n    for (i = 0; i < n; i++) {\n        line = sarrayGetString(sa, i, L_NOCOPY);\n        if (!insel &&\n            (line[0] != '\\0' && line[0] != ' ' &&\n             line[0] != '\\t' && line[0] != '\\n' && line[0] != '#')) {\n            numaAddNumber(nafirst, i);\n            insel = TRUE;\n            continue;\n        }\n        if (insel &&\n            (line[0] == '\\0' || line[0] == ' ' ||\n             line[0] == '\\t' || line[0] == '\\n' || line[0] == '#')) {\n            numaAddNumber(nalast, i - 1);\n            insel = FALSE;\n            continue;\n        }\n    }\n    if (insel)  /* fell off the end of the file */\n        numaAddNumber(nalast, n - 1);\n\n        /* Extract sels */\n    nsel = numaGetCount(nafirst);\n    for (i = 0; i < nsel; i++) {\n        numaGetIValue(nafirst, i, &first);\n        numaGetIValue(nalast, i, &last);\n        if ((sel = selCreateFromSArray(sa, first, last)) == NULL) {\n            fprintf(stderr, \"Error reading sel from %d to %d\\n\", first, last);\n            selaDestroy(&sela);\n            sarrayDestroy(&sa);\n            numaDestroy(&nafirst);\n            numaDestroy(&nalast);\n            return (SELA *)ERROR_PTR(\"bad sela file\", procName, NULL);\n        }\n        selaAddSel(sela, sel, NULL, 0);\n    }\n\n    numaDestroy(&nafirst);\n    numaDestroy(&nalast);\n    sarrayDestroy(&sa);\n    return sela;\n}\n\n\n/*!\n * \\brief   selCreateFromSArray()\n *\n * \\param[in]    sa\n * \\param[in]    first line of sarray where Sel begins\n * \\param[in]    last line of sarray where Sel ends\n * \\return  sela, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The Sel contains the following lines:\n *          ~ The first line is the selname\n *          ~ The remaining lines contain the Sel data.  They must\n *            be formatted similarly to the string format in\n *            selCreateFromString(), with each line beginning and\n *            ending with a double-quote, and showing the 2D layout.\n *          ~ 'last' gives the last line in the Sel data.\n *      (2) See selCreateFromString() for a description of the string\n *          format for the Sel data.  As an example, here are the lines\n *          of is a valid file for a single Sel.  In the file, all lines\n *          are left-justified:\n *                    # diagonal sel\n *                    sel_5diag\n *                    \"x    \"\n *                    \" x   \"\n *                    \"  X  \"\n *                    \"   x \"\n *                    \"    x\"\n * </pre>\n */\nstatic SEL *\nselCreateFromSArray(SARRAY  *sa,\n                    l_int32  first,\n                    l_int32  last)\n{\nchar     ch;\nchar    *name, *line;\nl_int32  n, len, i, w, h, y, x;\nSEL     *sel;\n\n    PROCNAME(\"selCreateFromSArray\");\n\n    if (!sa)\n        return (SEL *)ERROR_PTR(\"sa not defined\", procName, NULL);\n    n = sarrayGetCount(sa);\n    if (first < 0 || first >= n || last <= first || last >= n)\n        return (SEL *)ERROR_PTR(\"invalid range\", procName, NULL);\n\n    name = sarrayGetString(sa, first, L_NOCOPY);\n    h = last - first;\n    line = sarrayGetString(sa, first + 1, L_NOCOPY);\n    len = strlen(line);\n    if (line[0] != '\"' || line[len - 1] != '\"')\n        return (SEL *)ERROR_PTR(\"invalid format\", procName, NULL);\n    w = len - 2;\n    if ((sel = selCreate(h, w, name)) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    for (i = first + 1; i <= last; i++) {\n        line = sarrayGetString(sa, i, L_NOCOPY);\n        y = i - first - 1;\n        for (x = 0; x < w; ++x) {\n            ch = line[x + 1];  /* skip the leading double-quote */\n            switch (ch)\n            {\n                case 'X':\n                    selSetOrigin(sel, y, x);  /* set origin and hit */\n                case 'x':\n                    selSetElement(sel, y, x, SEL_HIT);\n                    break;\n\n                case 'O':\n                    selSetOrigin(sel, y, x);  /* set origin and miss */\n                case 'o':\n                    selSetElement(sel, y, x, SEL_MISS);\n                    break;\n\n                case 'C':\n                    selSetOrigin(sel, y, x);  /* set origin and don't-care */\n                case ' ':\n                    selSetElement(sel, y, x, SEL_DONT_CARE);\n                    break;\n\n                default:\n                    selDestroy(&sel);\n                    return (SEL *)ERROR_PTR(\"unknown char\", procName, NULL);\n            }\n        }\n    }\n\n    return sel;\n}\n\n\n/*----------------------------------------------------------------------*\n *               Making hit-only SELs from Pta and Pix                  *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selCreateFromPta()\n *\n * \\param[in]    pta\n * \\param[in]    cy, cx origin of sel\n * \\param[in]    name [optional] sel name; can be null\n * \\return  sel of minimum required size, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The origin and all points in the pta must be positive.\n * </pre>\n */\nSEL *\nselCreateFromPta(PTA         *pta,\n                 l_int32      cy,\n                 l_int32      cx,\n                 const char  *name)\n{\nl_int32  i, n, x, y, w, h;\nBOX     *box;\nSEL     *sel;\n\n    PROCNAME(\"selCreateFromPta\");\n\n    if (!pta)\n        return (SEL *)ERROR_PTR(\"pta not defined\", procName, NULL);\n    if (cy < 0 || cx < 0)\n        return (SEL *)ERROR_PTR(\"(cy, cx) not both >= 0\", procName, NULL);\n    n = ptaGetCount(pta);\n    if (n == 0)\n        return (SEL *)ERROR_PTR(\"no pts in pta\", procName, NULL);\n\n    box = ptaGetBoundingRegion(pta);\n    boxGetGeometry(box, &x, &y, &w, &h);\n    boxDestroy(&box);\n    if (x < 0 || y < 0)\n        return (SEL *)ERROR_PTR(\"not all x and y >= 0\", procName, NULL);\n\n    sel = selCreate(y + h, x + w, name);\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < n; i++) {\n        ptaGetIPt(pta, i, &x, &y);\n        selSetElement(sel, y, x, SEL_HIT);\n    }\n\n    return sel;\n}\n\n\n/*!\n * \\brief   selCreateFromPix()\n *\n * \\param[in]    pix\n * \\param[in]    cy, cx origin of sel\n * \\param[in]    name [optional] sel name; can be null\n * \\return  sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The origin must be positive.\n * </pre>\n */\nSEL *\nselCreateFromPix(PIX         *pix,\n                 l_int32      cy,\n                 l_int32      cx,\n                 const char  *name)\n{\nSEL      *sel;\nl_int32   i, j, w, h, d;\nl_uint32  val;\n\n    PROCNAME(\"selCreateFromPix\");\n\n    if (!pix)\n        return (SEL *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (cy < 0 || cx < 0)\n        return (SEL *)ERROR_PTR(\"(cy, cx) not both >= 0\", procName, NULL);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (d != 1)\n        return (SEL *)ERROR_PTR(\"pix not 1 bpp\", procName, NULL);\n\n    sel = selCreate(h, w, name);\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            pixGetPixel(pix, j, i, &val);\n            if (val)\n                selSetElement(sel, i, j, SEL_HIT);\n        }\n    }\n\n    return sel;\n}\n\n\n/*----------------------------------------------------------------------*\n *            Making hit-miss sels from color Pix and image files             *\n *----------------------------------------------------------------------*/\n/*!\n *\n *  selReadFromColorImage()\n *\n * \\param[in]    pathname\n * \\return  sel if OK; NULL on error\n *\n * <pre>\n * Notes:\n *      (1) Loads an image from a file and creates a (hit-miss) sel.\n *      (2) The sel name is taken from the pathname without the directory\n *          and extension.\n * </pre>\n */\nSEL *\nselReadFromColorImage(const char  *pathname)\n{\nPIX   *pix;\nSEL   *sel;\nchar  *basename, *selname;\n\n    PROCNAME(\"selReadFromColorImage\");\n\n    splitPathAtExtension (pathname, &basename, NULL);\n    splitPathAtDirectory (basename, NULL, &selname);\n    LEPT_FREE(basename);\n\n    if ((pix = pixRead(pathname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"pix not returned\", procName, NULL);\n    }\n    if ((sel = selCreateFromColorPix(pix, selname)) == NULL)\n        L_ERROR(\"sel not made\\n\", procName);\n\n    LEPT_FREE(selname);\n    pixDestroy(&pix);\n    return sel;\n}\n\n\n/*!\n *\n *  selCreateFromColorPix()\n *\n * \\param[in]    pixs cmapped or rgb\n * \\param[in]    selname [optional] sel name; can be null\n * \\return  sel if OK, NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The sel size is given by the size of pixs.\n *      (2) In pixs, hits are represented by green pixels, misses by red\n *          pixels, and don't-cares by white pixels.\n *      (3) In pixs, there may be no misses, but there must be at least 1 hit.\n *      (4) At most there can be only one origin pixel, which is optionally\n *          specified by using a lower-intensity pixel:\n *            if a hit:  dark green\n *            if a miss: dark red\n *            if a don't care: gray\n *          If there is no such pixel, the origin defaults to the approximate\n *          center of the sel.\n * </pre>\n */\nSEL *\nselCreateFromColorPix(PIX   *pixs,\n                      char  *selname)\n{\nPIXCMAP  *cmap;\nSEL      *sel;\nl_int32   hascolor, hasorigin, nohits;\nl_int32   w, h, d, i, j, red, green, blue;\nl_uint32  pixval;\n\n    PROCNAME(\"selCreateFromColorPix\");\n\n    if (!pixs)\n        return (SEL *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n\n    hascolor = FALSE;\n    cmap = pixGetColormap(pixs);\n    if (cmap)\n        pixcmapHasColor(cmap, &hascolor);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (hascolor == FALSE && d != 32)\n        return (SEL *)ERROR_PTR(\"pixs has no color\", procName, NULL);\n\n    if ((sel = selCreate (h, w, NULL)) == NULL)\n        return (SEL *)ERROR_PTR (\"sel not made\", procName, NULL);\n    selSetOrigin (sel, h / 2, w / 2);\n    selSetName(sel, selname);\n\n    hasorigin = FALSE;\n    nohits = TRUE;\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            pixGetPixel (pixs, j, i, &pixval);\n\n            if (cmap) {\n                pixcmapGetColor (cmap, pixval, &red, &green, &blue);\n            } else {\n                red = GET_DATA_BYTE (&pixval, COLOR_RED);\n                green = GET_DATA_BYTE (&pixval, COLOR_GREEN);\n                blue = GET_DATA_BYTE (&pixval, COLOR_BLUE);\n            }\n\n            if (red < 255 && green < 255 && blue < 255) {\n                if (hasorigin)\n                    L_WARNING(\"multiple origins in sel image\\n\", procName);\n                selSetOrigin (sel, i, j);\n                hasorigin = TRUE;\n            }\n            if (!red && green && !blue) {\n                nohits = FALSE;\n                selSetElement (sel, i, j, SEL_HIT);\n            } else if (red && !green && !blue) {\n                selSetElement (sel, i, j, SEL_MISS);\n            } else if (red && green && blue) {\n                selSetElement (sel, i, j, SEL_DONT_CARE);\n            } else {\n                selDestroy(&sel);\n                return (SEL *)ERROR_PTR(\"invalid color\", procName, NULL);\n            }\n        }\n    }\n\n    if (nohits) {\n        selDestroy(&sel);\n        return (SEL *)ERROR_PTR(\"no hits in sel\", procName, NULL);\n    }\n    return sel;\n}\n\n\n/*----------------------------------------------------------------------*\n *                     Printable display of sel                         *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   selDisplayInPix()\n *\n * \\param[in]    sel\n * \\param[in]    size of grid interiors; odd; minimum size of 13 is enforced\n * \\param[in]    gthick grid thickness; minimum size of 2 is enforced\n * \\return  pix display of sel, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a visual representation of a general (hit-miss) sel.\n *      (2) The empty sel is represented by a grid of intersecting lines.\n *      (3) Three different patterns are generated for the sel elements:\n *          ~ hit (solid black circle)\n *          ~ miss (black ring; inner radius is radius2)\n *          ~ origin (cross, XORed with whatever is there)\n * </pre>\n */\nPIX *\nselDisplayInPix(SEL     *sel,\n                l_int32  size,\n                l_int32  gthick)\n{\nl_int32  i, j, w, h, sx, sy, cx, cy, type, width;\nl_int32  radius1, radius2, shift1, shift2, x0, y0;\nPIX     *pixd, *pix2, *pixh, *pixm, *pixorig;\nPTA     *pta1, *pta2, *pta1t, *pta2t;\n\n    PROCNAME(\"selDisplayInPix\");\n\n    if (!sel)\n        return (PIX *)ERROR_PTR(\"sel not defined\", procName, NULL);\n    if (size < 13) {\n        L_WARNING(\"size < 13; setting to 13\\n\", procName);\n        size = 13;\n    }\n    if (size % 2 == 0)\n        size++;\n    if (gthick < 2) {\n        L_WARNING(\"grid thickness < 2; setting to 2\\n\", procName);\n        gthick = 2;\n    }\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n    w = size * sx + gthick * (sx + 1);\n    h = size * sy + gthick * (sy + 1);\n    pixd = pixCreate(w, h, 1);\n\n        /* Generate grid lines */\n    for (i = 0; i <= sy; i++)\n        pixRenderLine(pixd, 0, gthick / 2 + i * (size + gthick),\n                      w - 1, gthick / 2 + i * (size + gthick),\n                      gthick, L_SET_PIXELS);\n    for (j = 0; j <= sx; j++)\n        pixRenderLine(pixd, gthick / 2 + j * (size + gthick), 0,\n                      gthick / 2 + j * (size + gthick), h - 1,\n                      gthick, L_SET_PIXELS);\n\n        /* Generate hit and miss patterns */\n    radius1 = (l_int32)(0.85 * ((size - 1) / 2.0) + 0.5);  /* of hit */\n    radius2 = (l_int32)(0.65 * ((size - 1) / 2.0) + 0.5);  /* of inner miss */\n    pta1 = generatePtaFilledCircle(radius1);\n    pta2 = generatePtaFilledCircle(radius2);\n    shift1 = (size - 1) / 2 - radius1;  /* center circle in square */\n    shift2 = (size - 1) / 2 - radius2;\n    pta1t = ptaTransform(pta1, shift1, shift1, 1.0, 1.0);\n    pta2t = ptaTransform(pta2, shift2, shift2, 1.0, 1.0);\n    pixh = pixGenerateFromPta(pta1t, size, size);  /* hits */\n    pix2 = pixGenerateFromPta(pta2t, size, size);\n    pixm = pixSubtract(NULL, pixh, pix2);\n\n        /* Generate crossed lines for origin pattern */\n    pixorig = pixCreate(size, size, 1);\n    width = size / 8;\n    pixRenderLine(pixorig, size / 2, (l_int32)(0.12 * size),\n                           size / 2, (l_int32)(0.88 * size),\n                           width, L_SET_PIXELS);\n    pixRenderLine(pixorig, (l_int32)(0.15 * size), size / 2,\n                           (l_int32)(0.85 * size), size / 2,\n                           width, L_FLIP_PIXELS);\n    pixRasterop(pixorig, size / 2 - width, size / 2 - width,\n                2 * width, 2 * width, PIX_NOT(PIX_DST), NULL, 0, 0);\n\n        /* Specialize origin pattern for this sel */\n    selGetTypeAtOrigin(sel, &type);\n    if (type == SEL_HIT)\n        pixXor(pixorig, pixorig, pixh);\n    else if (type == SEL_MISS)\n        pixXor(pixorig, pixorig, pixm);\n\n        /* Paste the patterns in */\n    y0 = gthick;\n    for (i = 0; i < sy; i++) {\n        x0 = gthick;\n        for (j = 0; j < sx; j++) {\n            selGetElement(sel, i, j, &type);\n            if (i == cy && j == cx)  /* origin */\n                pixRasterop(pixd, x0, y0, size, size, PIX_SRC, pixorig, 0, 0);\n            else if (type == SEL_HIT)\n                pixRasterop(pixd, x0, y0, size, size, PIX_SRC, pixh, 0, 0);\n            else if (type == SEL_MISS)\n                pixRasterop(pixd, x0, y0, size, size, PIX_SRC, pixm, 0, 0);\n            x0 += size + gthick;\n        }\n        y0 += size + gthick;\n    }\n\n    pixDestroy(&pix2);\n    pixDestroy(&pixh);\n    pixDestroy(&pixm);\n    pixDestroy(&pixorig);\n    ptaDestroy(&pta1);\n    ptaDestroy(&pta1t);\n    ptaDestroy(&pta2);\n    ptaDestroy(&pta2t);\n    return pixd;\n}\n\n\n/*!\n * \\brief   selaDisplayInPix()\n *\n * \\param[in]    sela\n * \\param[in]    size of grid interiors; odd; minimum size of 13 is enforced\n * \\param[in]    gthick grid thickness; minimum size of 2 is enforced\n * \\param[in]    spacing between sels, both horizontally and vertically\n * \\param[in]    ncols number of sels per \"line\"\n * \\return  pix display of all sels in sela, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This gives a visual representation of all the sels in a sela.\n *      (2) See notes in selDisplayInPix() for display params of each sel.\n *      (3) This gives the nicest results when all sels in the sela\n *          are the same size.\n * </pre>\n */\nPIX *\nselaDisplayInPix(SELA    *sela,\n                 l_int32  size,\n                 l_int32  gthick,\n                 l_int32  spacing,\n                 l_int32  ncols)\n{\nl_int32  nsels, i, w, width;\nPIX     *pixt, *pixd;\nPIXA    *pixa;\nSEL     *sel;\n\n    PROCNAME(\"selaDisplayInPix\");\n\n    if (!sela)\n        return (PIX *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (size < 13) {\n        L_WARNING(\"size < 13; setting to 13\\n\", procName);\n        size = 13;\n    }\n    if (size % 2 == 0)\n        size++;\n    if (gthick < 2) {\n        L_WARNING(\"grid thickness < 2; setting to 2\\n\", procName);\n        gthick = 2;\n    }\n    if (spacing < 5) {\n        L_WARNING(\"spacing < 5; setting to 5\\n\", procName);\n        spacing = 5;\n    }\n\n        /* Accumulate the pix of each sel */\n    nsels = selaGetCount(sela);\n    pixa = pixaCreate(nsels);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        pixt = selDisplayInPix(sel, size, gthick);\n        pixaAddPix(pixa, pixt, L_INSERT);\n    }\n\n        /* Find the tiled output width, using just the first\n         * ncols pix in the pixa.   If all pix have the same width,\n         * they will align properly in columns. */\n    width = 0;\n    ncols = L_MIN(nsels, ncols);\n    for (i = 0; i < ncols; i++) {\n        pixt = pixaGetPix(pixa, i, L_CLONE);\n        pixGetDimensions(pixt, &w, NULL, NULL);\n        width += w;\n        pixDestroy(&pixt);\n    }\n    width += (ncols + 1) * spacing;  /* add spacing all around as well */\n\n    pixd = pixaDisplayTiledInRows(pixa, 1, width, 1.0, 0, spacing, 0);\n    pixaDestroy(&pixa);\n    return pixd;\n}\n"], "filenames": ["README.md", "prog/xtractprotos.c", "src/gplot.c", "src/ptabasic.c", "src/sel1.c"], "buggy_code_start_loc": [65, 90, 53, 692, 144], "buggy_code_end_loc": [69, 194, 890, 707, 1430], "fixing_code_start_loc": [66, 90, 53, 692, 144], "fixing_code_end_loc": [69, 194, 890, 707, 1430], "type": "CWE-787", "message": "Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.", "other": {"cve": {"id": "CVE-2018-7186", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-16T16:29:00.160", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions."}, {"lang": "es", "value": "Leptonica, en versiones anteriores a la 1.75.3, no limita el n\u00famero de caracteres en un argumento de formato %s en fscanf o sscanf, lo que permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en pila) o que puedan causar otro tipo de impacto sin especificar mediante una cadena larga. Esto se demuestra mediante las funciones gplotRead y ptaReadStream."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:leptonica:leptonica:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.75.3", "matchCriteriaId": "92955A0B-68B2-4832-BE97-A6FAE66F1753"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "https://bugs.debian.org/890548", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/03/msg00005.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts/2018/02/msg00054.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a"}}