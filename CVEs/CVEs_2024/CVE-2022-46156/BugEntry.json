{"buggy_code": ["package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/adhoc\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/checks\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/feature\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/http\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/pusher\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/version\"\n\t\"github.com/grafana/synthetic-monitoring-agent/pkg/pb/synthetic_monitoring\"\n\t\"github.com/jpillora/backoff\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/rs/zerolog\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"google.golang.org/grpc/grpclog\"\n)\n\nconst exitFail = 1\n\nfunc run(args []string, stdout io.Writer) error {\n\tflags := flag.NewFlagSet(filepath.Base(args[0]), flag.ExitOnError)\n\n\tvar (\n\t\tfeatures          = feature.NewCollection()\n\t\tdebug             = flags.Bool(\"debug\", false, \"debug output (enables verbose)\")\n\t\tverbose           = flags.Bool(\"verbose\", false, \"verbose logging\")\n\t\treportVersion     = flags.Bool(\"version\", false, \"report version and exit\")\n\t\tgrpcApiServerAddr = flags.String(\"api-server-address\", \"localhost:4031\", \"GRPC API server address\")\n\t\tgrpcInsecure      = flags.Bool(\"api-insecure\", false, \"Don't use TLS with connections to GRPC API\")\n\t\thttpListenAddr    = flags.String(\"listen-address\", \":4050\", \"listen address\")\n\t\tapiToken          = flags.String(\"api-token\", \"\", \"synthetic monitoring probe authentication token\")\n\t\tenableDisconnect  = flags.Bool(\"enable-disconnect\", false, \"enable HTTP /disconnect endpoint\")\n\t\tenablePProf       = flags.Bool(\"enable-pprof\", false, \"exposes profiling data via HTTP /debug/pprof/ endpoint\")\n\t)\n\n\tflags.Var(&features, \"features\", \"optional feature flags\")\n\n\tif err := flags.Parse(args[1:]); err != nil {\n\t\treturn err\n\t}\n\n\tif *reportVersion {\n\t\tfmt.Printf(\n\t\t\t\"%s version=\\\"%s\\\" buildstamp=\\\"%s\\\" commit=\\\"%s\\\"\\n\",\n\t\t\tflags.Name(),\n\t\t\tversion.Short(),\n\t\t\tversion.Buildstamp(),\n\t\t\tversion.Commit(),\n\t\t)\n\t\treturn nil\n\t}\n\n\tif *apiToken == \"\" {\n\t\treturn fmt.Errorf(\"invalid API token\")\n\t}\n\n\tbaseCtx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tg, ctx := errgroup.WithContext(baseCtx)\n\n\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnixMs\n\n\tzl := zerolog.New(stdout).With().Timestamp().Str(\"program\", filepath.Base(args[0])).Logger()\n\n\tswitch {\n\tcase *debug:\n\t\tzerolog.SetGlobalLevel(zerolog.DebugLevel)\n\t\tzlGrpc := zl.With().Str(\"component\", \"grpc-go\").Logger()\n\t\tzl = zl.With().Caller().Logger()\n\t\t*verbose = true\n\t\tgrpclog.SetLoggerV2(grpclog.NewLoggerV2WithVerbosity(zlGrpc, zlGrpc, zlGrpc, 99))\n\n\tcase *verbose:\n\t\tzerolog.SetGlobalLevel(zerolog.InfoLevel)\n\n\tdefault:\n\t\tzerolog.SetGlobalLevel(zerolog.ErrorLevel)\n\t}\n\n\tg.Go(func() error {\n\t\treturn signalHandler(ctx, zl.With().Str(\"subsystem\", \"signal handler\").Logger())\n\t})\n\n\tzl.Info().\n\t\tStr(\"version\", version.Short()).\n\t\tStr(\"commit\", version.Commit()).\n\t\tStr(\"buildstamp\", version.Buildstamp()).\n\t\tStr(\"features\", features.String()).\n\t\tMsg(\"starting\")\n\n\tpromRegisterer := prometheus.NewRegistry()\n\n\tif err := registerMetrics(promRegisterer); err != nil {\n\t\treturn err\n\t}\n\n\t// to know if probe is connected to API\n\treadynessHandler := NewReadynessHandler()\n\n\trouter := NewMux(MuxOpts{\n\t\tLogger:            zl.With().Str(\"subsystem\", \"mux\").Logger(),\n\t\tPromRegisterer:    promRegisterer,\n\t\tisReady:           readynessHandler,\n\t\tdisconnectEnabled: *enableDisconnect,\n\t\tpprofEnabled:      *enablePProf,\n\t})\n\n\thttpConfig := http.Config{\n\t\tListenAddr:   *httpListenAddr,\n\t\tLogger:       zl.With().Str(\"subsystem\", \"http\").Logger(),\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 60 * time.Second,\n\t\tIdleTimeout:  15 * time.Second,\n\t}\n\n\thttpServer := http.NewServer(ctx, router, httpConfig)\n\n\thttpListener, err := (&net.ListenConfig{}).Listen(ctx, \"tcp\", httpServer.ListenAddr())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg.Go(func() error {\n\t\t<-ctx.Done()\n\t\ttimeoutCtx, timeoutCancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer timeoutCancel()\n\n\t\t// we probably cannot do anything meaningful with this\n\t\t// error but return it anyways.\n\t\treturn httpServer.Shutdown(timeoutCtx)\n\t})\n\n\tg.Go(func() error {\n\t\treturn httpServer.Run(httpListener)\n\t})\n\n\tpublishCh := make(chan pusher.Payload)\n\ttenantCh := make(chan synthetic_monitoring.Tenant)\n\n\tconn, err := dialAPIServer(ctx, *grpcApiServerAddr, *grpcInsecure, *apiToken)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing GRPC server %s: %w\", *grpcApiServerAddr, err)\n\t}\n\tdefer conn.Close()\n\n\tchecksUpdater, err := checks.NewUpdater(checks.UpdaterOptions{\n\t\tConn:           conn,\n\t\tLogger:         zl.With().Str(\"subsystem\", \"updater\").Logger(),\n\t\tBackoff:        newConnectionBackoff(),\n\t\tPublishCh:      publishCh,\n\t\tTenantCh:       tenantCh,\n\t\tIsConnected:    readynessHandler.Set,\n\t\tPromRegisterer: promRegisterer,\n\t\tFeatures:       features,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Cannot create checks updater: %w\", err)\n\t}\n\n\tg.Go(func() error {\n\t\treturn checksUpdater.Run(ctx)\n\t})\n\n\tif features.IsSet(feature.AdHoc) {\n\t\tadhocHandler, err := adhoc.NewHandler(adhoc.HandlerOpts{\n\t\t\tConn:           conn,\n\t\t\tLogger:         zl.With().Str(\"subsystem\", \"adhoc\").Logger(),\n\t\t\tBackoff:        newConnectionBackoff(),\n\t\t\tPublishCh:      publishCh,\n\t\t\tTenantCh:       tenantCh,\n\t\t\tPromRegisterer: promRegisterer,\n\t\t\tFeatures:       features,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Cannot create ad-hoc checks handler: %w\", err)\n\t\t}\n\n\t\tg.Go(func() error {\n\t\t\treturn adhocHandler.Run(ctx)\n\t\t})\n\t}\n\n\ttm := pusher.NewTenantManager(ctx, synthetic_monitoring.NewTenantsClient(conn), tenantCh, 15*time.Minute)\n\n\tpublisher := pusher.NewPublisher(tm, publishCh, zl.With().Str(\"subsystem\", \"publisher\").Logger(), promRegisterer)\n\n\tg.Go(func() error {\n\t\treturn publisher.Run(ctx)\n\t})\n\n\treturn g.Wait()\n}\n\nfunc main() {\n\tif err := run(os.Args, os.Stdout); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"E: %s\\n\", err)\n\t\tos.Exit(exitFail)\n\t}\n}\n\nfunc signalHandler(ctx context.Context, logger zerolog.Logger) error {\n\tsigCh := make(chan os.Signal, 1)\n\n\tsignal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)\n\n\tselect {\n\tcase sig := <-sigCh:\n\t\tlogger.Info().Str(\"signal\", sig.String()).Msg(\"shutting down\")\n\t\treturn fmt.Errorf(\"Got signal %s\", sig)\n\n\tcase <-ctx.Done():\n\t\tlogger.Info().Msg(\"shutting down\")\n\t\treturn nil\n\t}\n}\n\nfunc newConnectionBackoff() *backoff.Backoff {\n\treturn &backoff.Backoff{\n\t\tMin:    2 * time.Second,\n\t\tMax:    30 * time.Second,\n\t\tFactor: math.Pow(30./2., 1./8.), // reach the target in ~ 8 steps\n\t\tJitter: true,\n\t}\n}\n", "# Enter API token retrieved from grafana.com here\nAPI_TOKEN='YOUR TOKEN HERE'\n\n# Backend API server to connect to\nAPI_SERVER='synthetic-monitoring-grpc.grafana.net:443' \n\n# Don't use TLS with connections to GRPC API\nAPI_INSECURE=\"false\"\n\n# listen address for /metrics and /debug/pprof\nLISTEN_ADDRESS=\":4031\"\n\n# verbose logging\nVERBOSE=\"false\"\n\n# debug output (enables verbose)\nDEBUG=\"false\"\n\n# feature flags\nFEATURES=\"\"", "[Unit]\nDescription=Grafana synthetic monitoring agent\n\n[Service]\nType=simple\nUser=root\nGroup=root\nEnvironmentFile=/etc/synthetic-monitoring/synthetic-monitoring-agent.conf\nExecStart=/usr/bin/synthetic-monitoring-agent --api-token=${API_TOKEN} --api-server-address=${API_SERVER} --api-insecure=${API_INSECURE} --listen-address=${LISTEN_ADDRESS} --verbose=${VERBOSE} --debug=${DEBUG} --features=${FEATURES}\nRestart=always\n\n[Install]\nWantedBy=network-online.target\n"], "fixing_code": ["package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/adhoc\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/checks\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/feature\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/http\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/pusher\"\n\t\"github.com/grafana/synthetic-monitoring-agent/internal/version\"\n\t\"github.com/grafana/synthetic-monitoring-agent/pkg/pb/synthetic_monitoring\"\n\t\"github.com/jpillora/backoff\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/rs/zerolog\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"google.golang.org/grpc/grpclog\"\n)\n\nconst exitFail = 1\n\nfunc run(args []string, stdout io.Writer) error {\n\tflags := flag.NewFlagSet(filepath.Base(args[0]), flag.ExitOnError)\n\n\tvar (\n\t\tfeatures          = feature.NewCollection()\n\t\tdebug             = flags.Bool(\"debug\", false, \"debug output (enables verbose)\")\n\t\tverbose           = flags.Bool(\"verbose\", false, \"verbose logging\")\n\t\treportVersion     = flags.Bool(\"version\", false, \"report version and exit\")\n\t\tgrpcApiServerAddr = flags.String(\"api-server-address\", \"localhost:4031\", \"GRPC API server address\")\n\t\tgrpcInsecure      = flags.Bool(\"api-insecure\", false, \"Don't use TLS with connections to GRPC API\")\n\t\thttpListenAddr    = flags.String(\"listen-address\", \":4050\", \"listen address\")\n\t\tapiToken          = flags.String(\"api-token\", \"\", \"synthetic monitoring probe authentication token\")\n\t\tenableDisconnect  = flags.Bool(\"enable-disconnect\", false, \"enable HTTP /disconnect endpoint\")\n\t\tenablePProf       = flags.Bool(\"enable-pprof\", false, \"exposes profiling data via HTTP /debug/pprof/ endpoint\")\n\t)\n\n\tflags.Var(&features, \"features\", \"optional feature flags\")\n\n\tif err := flags.Parse(args[1:]); err != nil {\n\t\treturn err\n\t}\n\n\tif *reportVersion {\n\t\tfmt.Printf(\n\t\t\t\"%s version=\\\"%s\\\" buildstamp=\\\"%s\\\" commit=\\\"%s\\\"\\n\",\n\t\t\tflags.Name(),\n\t\t\tversion.Short(),\n\t\t\tversion.Buildstamp(),\n\t\t\tversion.Commit(),\n\t\t)\n\t\treturn nil\n\t}\n\n\t// If the token is provided on the command line, prefer that. Otherwise\n\t// pull it from the environment variable SM_AGENT_API_TOKEN. If that's\n\t// not available, fallback to API_TOKEN, which was the environment\n\t// variable name previously used in the systemd unit files.\n\t//\n\t// Using API_TOKEN should be deprecated after March 1st, 2023.\n\t*apiToken = stringFromEnv(\"API_TOKEN\", stringFromEnv(\"SM_AGENT_API_TOKEN\", *apiToken))\n\n\tif *apiToken == \"\" {\n\t\treturn fmt.Errorf(\"invalid API token\")\n\t}\n\n\tbaseCtx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tg, ctx := errgroup.WithContext(baseCtx)\n\n\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnixMs\n\n\tzl := zerolog.New(stdout).With().Timestamp().Str(\"program\", filepath.Base(args[0])).Logger()\n\n\tswitch {\n\tcase *debug:\n\t\tzerolog.SetGlobalLevel(zerolog.DebugLevel)\n\t\tzlGrpc := zl.With().Str(\"component\", \"grpc-go\").Logger()\n\t\tzl = zl.With().Caller().Logger()\n\t\t*verbose = true\n\t\tgrpclog.SetLoggerV2(grpclog.NewLoggerV2WithVerbosity(zlGrpc, zlGrpc, zlGrpc, 99))\n\n\tcase *verbose:\n\t\tzerolog.SetGlobalLevel(zerolog.InfoLevel)\n\n\tdefault:\n\t\tzerolog.SetGlobalLevel(zerolog.ErrorLevel)\n\t}\n\n\tg.Go(func() error {\n\t\treturn signalHandler(ctx, zl.With().Str(\"subsystem\", \"signal handler\").Logger())\n\t})\n\n\tzl.Info().\n\t\tStr(\"version\", version.Short()).\n\t\tStr(\"commit\", version.Commit()).\n\t\tStr(\"buildstamp\", version.Buildstamp()).\n\t\tStr(\"features\", features.String()).\n\t\tMsg(\"starting\")\n\n\tpromRegisterer := prometheus.NewRegistry()\n\n\tif err := registerMetrics(promRegisterer); err != nil {\n\t\treturn err\n\t}\n\n\t// to know if probe is connected to API\n\treadynessHandler := NewReadynessHandler()\n\n\trouter := NewMux(MuxOpts{\n\t\tLogger:            zl.With().Str(\"subsystem\", \"mux\").Logger(),\n\t\tPromRegisterer:    promRegisterer,\n\t\tisReady:           readynessHandler,\n\t\tdisconnectEnabled: *enableDisconnect,\n\t\tpprofEnabled:      *enablePProf,\n\t})\n\n\thttpConfig := http.Config{\n\t\tListenAddr:   *httpListenAddr,\n\t\tLogger:       zl.With().Str(\"subsystem\", \"http\").Logger(),\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 60 * time.Second,\n\t\tIdleTimeout:  15 * time.Second,\n\t}\n\n\thttpServer := http.NewServer(ctx, router, httpConfig)\n\n\thttpListener, err := (&net.ListenConfig{}).Listen(ctx, \"tcp\", httpServer.ListenAddr())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg.Go(func() error {\n\t\t<-ctx.Done()\n\t\ttimeoutCtx, timeoutCancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer timeoutCancel()\n\n\t\t// we probably cannot do anything meaningful with this\n\t\t// error but return it anyways.\n\t\treturn httpServer.Shutdown(timeoutCtx)\n\t})\n\n\tg.Go(func() error {\n\t\treturn httpServer.Run(httpListener)\n\t})\n\n\tpublishCh := make(chan pusher.Payload)\n\ttenantCh := make(chan synthetic_monitoring.Tenant)\n\n\tconn, err := dialAPIServer(ctx, *grpcApiServerAddr, *grpcInsecure, *apiToken)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing GRPC server %s: %w\", *grpcApiServerAddr, err)\n\t}\n\tdefer conn.Close()\n\n\tchecksUpdater, err := checks.NewUpdater(checks.UpdaterOptions{\n\t\tConn:           conn,\n\t\tLogger:         zl.With().Str(\"subsystem\", \"updater\").Logger(),\n\t\tBackoff:        newConnectionBackoff(),\n\t\tPublishCh:      publishCh,\n\t\tTenantCh:       tenantCh,\n\t\tIsConnected:    readynessHandler.Set,\n\t\tPromRegisterer: promRegisterer,\n\t\tFeatures:       features,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Cannot create checks updater: %w\", err)\n\t}\n\n\tg.Go(func() error {\n\t\treturn checksUpdater.Run(ctx)\n\t})\n\n\tif features.IsSet(feature.AdHoc) {\n\t\tadhocHandler, err := adhoc.NewHandler(adhoc.HandlerOpts{\n\t\t\tConn:           conn,\n\t\t\tLogger:         zl.With().Str(\"subsystem\", \"adhoc\").Logger(),\n\t\t\tBackoff:        newConnectionBackoff(),\n\t\t\tPublishCh:      publishCh,\n\t\t\tTenantCh:       tenantCh,\n\t\t\tPromRegisterer: promRegisterer,\n\t\t\tFeatures:       features,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Cannot create ad-hoc checks handler: %w\", err)\n\t\t}\n\n\t\tg.Go(func() error {\n\t\t\treturn adhocHandler.Run(ctx)\n\t\t})\n\t}\n\n\ttm := pusher.NewTenantManager(ctx, synthetic_monitoring.NewTenantsClient(conn), tenantCh, 15*time.Minute)\n\n\tpublisher := pusher.NewPublisher(tm, publishCh, zl.With().Str(\"subsystem\", \"publisher\").Logger(), promRegisterer)\n\n\tg.Go(func() error {\n\t\treturn publisher.Run(ctx)\n\t})\n\n\treturn g.Wait()\n}\n\nfunc main() {\n\tif err := run(os.Args, os.Stdout); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"E: %s\\n\", err)\n\t\tos.Exit(exitFail)\n\t}\n}\n\nfunc signalHandler(ctx context.Context, logger zerolog.Logger) error {\n\tsigCh := make(chan os.Signal, 1)\n\n\tsignal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)\n\n\tselect {\n\tcase sig := <-sigCh:\n\t\tlogger.Info().Str(\"signal\", sig.String()).Msg(\"shutting down\")\n\t\treturn fmt.Errorf(\"Got signal %s\", sig)\n\n\tcase <-ctx.Done():\n\t\tlogger.Info().Msg(\"shutting down\")\n\t\treturn nil\n\t}\n}\n\nfunc newConnectionBackoff() *backoff.Backoff {\n\treturn &backoff.Backoff{\n\t\tMin:    2 * time.Second,\n\t\tMax:    30 * time.Second,\n\t\tFactor: math.Pow(30./2., 1./8.), // reach the target in ~ 8 steps\n\t\tJitter: true,\n\t}\n}\n\nfunc stringFromEnv(name string, override string) string {\n\tif override != \"\" {\n\t\treturn override\n\t}\n\n\treturn os.Getenv(name)\n}\n", "# Enter API token retrieved from grafana.com here\nSM_AGENT_API_TOKEN='YOUR TOKEN HERE'\n\n# Backend API server to connect to\nAPI_SERVER='synthetic-monitoring-grpc.grafana.net:443' \n\n# Don't use TLS with connections to GRPC API\nAPI_INSECURE=\"false\"\n\n# listen address for /metrics and /debug/pprof\nLISTEN_ADDRESS=\":4031\"\n\n# verbose logging\nVERBOSE=\"false\"\n\n# debug output (enables verbose)\nDEBUG=\"false\"\n\n# feature flags\nFEATURES=\"\"", "[Unit]\nDescription=Grafana synthetic monitoring agent\n\n[Service]\nType=simple\nUser=root\nGroup=root\nEnvironmentFile=/etc/synthetic-monitoring/synthetic-monitoring-agent.conf\nExecStart=/usr/bin/synthetic-monitoring-agent --api-server-address=${API_SERVER} --api-insecure=${API_INSECURE} --listen-address=${LISTEN_ADDRESS} --verbose=${VERBOSE} --debug=${DEBUG} --features=${FEATURES}\nRestart=always\n\n[Install]\nWantedBy=network-online.target\n"], "filenames": ["cmd/synthetic-monitoring-agent/main.go", "scripts/package/config/systemd/synthetic-monitoring-agent.conf", "scripts/package/config/systemd/synthetic-monitoring-agent.service"], "buggy_code_start_loc": [64, 2, 9], "buggy_code_end_loc": [237, 3, 10], "fixing_code_start_loc": [65, 2, 9], "fixing_code_end_loc": [254, 3, 10], "type": "NVD-CWE-Other", "message": "The Synthetic Monitoring Agent for Grafana's Synthetic Monitoring application provides probe functionality and executes network checks for monitoring remote targets. Users running the Synthetic Monitoring agent prior to version 0.12.0 in their local network are impacted. The authentication token used to communicate with the Synthetic Monitoring API is exposed through a debugging endpoint. This token can be used to retrieve the Synthetic Monitoring checks created by the user and assigned to the agent identified with that token. The Synthetic Monitoring API will reject connections from already-connected agents, so access to the token does not guarantee access to the checks. Version 0.12.0 contains a fix. Users are advised to rotate the agent tokens. After upgrading to version v0.12.0 or later, it's recommended that users of distribution packages review the configuration stored in `/etc/synthetic-monitoring/synthetic-monitoring-agent.conf`, specifically the `API_TOKEN` variable which has been renamed to `SM_AGENT_API_TOKEN`. As a workaround for previous versions, it's recommended that users review the agent settings and set the HTTP listening address in a manner that limits the exposure, for example, localhost or a non-routed network, by using the command line parameter `-listen-address`, e.g. `-listen-address localhost:4050`.", "other": {"cve": {"id": "CVE-2022-46156", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-30T22:15:10.640", "lastModified": "2022-12-05T14:58:13.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Synthetic Monitoring Agent for Grafana's Synthetic Monitoring application provides probe functionality and executes network checks for monitoring remote targets. Users running the Synthetic Monitoring agent prior to version 0.12.0 in their local network are impacted. The authentication token used to communicate with the Synthetic Monitoring API is exposed through a debugging endpoint. This token can be used to retrieve the Synthetic Monitoring checks created by the user and assigned to the agent identified with that token. The Synthetic Monitoring API will reject connections from already-connected agents, so access to the token does not guarantee access to the checks. Version 0.12.0 contains a fix. Users are advised to rotate the agent tokens. After upgrading to version v0.12.0 or later, it's recommended that users of distribution packages review the configuration stored in `/etc/synthetic-monitoring/synthetic-monitoring-agent.conf`, specifically the `API_TOKEN` variable which has been renamed to `SM_AGENT_API_TOKEN`. As a workaround for previous versions, it's recommended that users review the agent settings and set the HTTP listening address in a manner that limits the exposure, for example, localhost or a non-routed network, by using the command line parameter `-listen-address`, e.g. `-listen-address localhost:4050`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-489"}, {"lang": "en", "value": "CWE-749"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:synthetic_monitoring_agent:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.0", "matchCriteriaId": "B0243C5D-EDC8-4238-94FF-0A7F6FDAF3C5"}]}]}], "references": [{"url": "https://github.com/grafana/synthetic-monitoring-agent/commit/d8dc7f9c1c641881cbcf0a09e178b90ebf0f0228", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/synthetic-monitoring-agent/pull/373", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/synthetic-monitoring-agent/pull/374", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/synthetic-monitoring-agent/pull/375", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/grafana/synthetic-monitoring-agent/releases/tag/v0.12.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/grafana/synthetic-monitoring-agent/security/advisories/GHSA-9j4f-f249-q5w8", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/synthetic-monitoring-agent/commit/d8dc7f9c1c641881cbcf0a09e178b90ebf0f0228"}}