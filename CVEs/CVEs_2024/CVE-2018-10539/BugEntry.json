{"buggy_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// dsdiff.c\n\n// This module is a helper to the WavPack command-line programs to support DFF files.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#ifdef _WIN32\n#define strdup(x) _strdup(x)\n#endif\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\n#pragma pack(push,2)\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n} DFFChunkHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char formType [4];\n} DFFFileHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t version;\n} DFFVersionChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t sampleRate;\n} DFFSampleRateChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint16_t numChannels;\n} DFFChannelsHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char compressionType [4];\n} DFFCompressionHeader;\n\n#pragma pack(pop)\n\n#define DFFChunkHeaderFormat \"4D\"\n#define DFFFileHeaderFormat \"4D4\"\n#define DFFVersionChunkFormat \"4DL\"\n#define DFFSampleRateChunkFormat \"4DL\"\n#define DFFChannelsHeaderFormat \"4DS\"\n#define DFFCompressionHeaderFormat \"4D4\"\n\nint ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteDsdiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    uint32_t chan_mask = WavpackGetChannelMask (wpc);\n    int num_channels = WavpackGetNumChannels (wpc);\n    DFFFileHeader file_header, prop_header;\n    DFFChunkHeader data_header;\n    DFFVersionChunk ver_chunk;\n    DFFSampleRateChunk fs_chunk;\n    DFFChannelsHeader chan_header;\n    DFFCompressionHeader cmpr_header;\n    char *cmpr_name = \"\\016not compressed\", *chan_ids;\n    int64_t file_size, prop_chunk_size, data_size;\n    int cmpr_name_size, chan_ids_size;\n    uint32_t bcount;\n\n    if (debug_logging_mode)\n        error_line (\"WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\\n\",\n            (long long) total_samples, qmode);\n\n    cmpr_name_size = (strlen (cmpr_name) + 1) & ~1;\n    chan_ids_size = num_channels * 4;\n    chan_ids = malloc (chan_ids_size);\n\n    if (chan_ids) {\n        uint32_t scan_mask = 0x1;\n        char *cptr = chan_ids;\n        int ci, uci = 0;\n\n        for (ci = 0; ci < num_channels; ++ci) {\n            while (scan_mask && !(scan_mask & chan_mask))\n                scan_mask <<= 1;\n\n            if (scan_mask & 0x1)\n                memcpy (cptr, num_channels <= 2 ? \"SLFT\" : \"MLFT\", 4);\n            else if (scan_mask & 0x2)\n                memcpy (cptr, num_channels <= 2 ? \"SRGT\" : \"MRGT\", 4);\n            else if (scan_mask & 0x4)\n                memcpy (cptr, \"C   \", 4);\n            else if (scan_mask & 0x8)\n                memcpy (cptr, \"LFE \", 4);\n            else if (scan_mask & 0x10)\n                memcpy (cptr, \"LS  \", 4);\n            else if (scan_mask & 0x20)\n                memcpy (cptr, \"RS  \", 4);\n            else {\n                cptr [0] = 'C';\n                cptr [1] = (uci / 100) + '0';\n                cptr [2] = ((uci % 100) / 10) + '0';\n                cptr [3] = (uci % 10) + '0';\n                uci++;\n            }\n\n            scan_mask <<= 1;\n            cptr += 4;\n        }\n    }\n    else {\n        error_line (\"can't allocate memory!\");\n        return FALSE;\n    }\n\n    data_size = total_samples * num_channels;\n    prop_chunk_size = sizeof (prop_header) + sizeof (fs_chunk) + sizeof (chan_header) + chan_ids_size + sizeof (cmpr_header) + cmpr_name_size;\n    file_size = sizeof (file_header) + sizeof (ver_chunk) + prop_chunk_size + sizeof (data_header) + ((data_size + 1) & ~(int64_t)1);\n\n    memcpy (file_header.ckID, \"FRM8\", 4);\n    file_header.ckDataSize = file_size - 12;\n    memcpy (file_header.formType, \"DSD \", 4);\n\n    memcpy (prop_header.ckID, \"PROP\", 4);\n    prop_header.ckDataSize = prop_chunk_size - 12;\n    memcpy (prop_header.formType, \"SND \", 4);\n\n    memcpy (ver_chunk.ckID, \"FVER\", 4);\n    ver_chunk.ckDataSize = sizeof (ver_chunk) - 12;\n    ver_chunk.version = 0x01050000;\n\n    memcpy (fs_chunk.ckID, \"FS  \", 4);\n    fs_chunk.ckDataSize = sizeof (fs_chunk) - 12;\n    fs_chunk.sampleRate = WavpackGetSampleRate (wpc) * 8;\n\n    memcpy (chan_header.ckID, \"CHNL\", 4);\n    chan_header.ckDataSize = sizeof (chan_header) + chan_ids_size - 12;\n    chan_header.numChannels = num_channels;\n\n    memcpy (cmpr_header.ckID, \"CMPR\", 4);\n    cmpr_header.ckDataSize = sizeof (cmpr_header) + cmpr_name_size - 12;\n    memcpy (cmpr_header.compressionType, \"DSD \", 4);\n\n    memcpy (data_header.ckID, \"DSD \", 4);\n    data_header.ckDataSize = data_size;\n\n    WavpackNativeToBigEndian (&file_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&ver_chunk, DFFVersionChunkFormat);\n    WavpackNativeToBigEndian (&prop_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&fs_chunk, DFFSampleRateChunkFormat);\n    WavpackNativeToBigEndian (&chan_header, DFFChannelsHeaderFormat);\n    WavpackNativeToBigEndian (&cmpr_header, DFFCompressionHeaderFormat);\n    WavpackNativeToBigEndian (&data_header, DFFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &file_header, sizeof (file_header), &bcount) || bcount != sizeof (file_header) ||\n        !DoWriteFile (outfile, &ver_chunk, sizeof (ver_chunk), &bcount) || bcount != sizeof (ver_chunk) ||\n        !DoWriteFile (outfile, &prop_header, sizeof (prop_header), &bcount) || bcount != sizeof (prop_header) ||\n        !DoWriteFile (outfile, &fs_chunk, sizeof (fs_chunk), &bcount) || bcount != sizeof (fs_chunk) ||\n        !DoWriteFile (outfile, &chan_header, sizeof (chan_header), &bcount) || bcount != sizeof (chan_header) ||\n        !DoWriteFile (outfile, chan_ids, chan_ids_size, &bcount) || bcount != chan_ids_size ||\n        !DoWriteFile (outfile, &cmpr_header, sizeof (cmpr_header), &bcount) || bcount != sizeof (cmpr_header) ||\n        !DoWriteFile (outfile, cmpr_name, cmpr_name_size, &bcount) || bcount != cmpr_name_size ||\n        !DoWriteFile (outfile, &data_header, sizeof (data_header), &bcount) || bcount != sizeof (data_header)) {\n            error_line (\"can't write .DSF data, disk probably full!\");\n            free (chan_ids);\n            return FALSE;\n    }\n\n    free (chan_ids);\n    return TRUE;\n}\n\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// riff.c\n\n// This module is a helper to the WavPack command-line programs to support WAV files\n// (both MS standard and rf64 varients).\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define CS64ChunkFormat \"4D\"\n#define DS64ChunkFormat \"DDDL\"\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\n    int64_t total_samples = 0, infilesize;\n    RiffChunkHeader riff_chunk_header;\n    ChunkHeader chunk_header;\n    WaveHeader WaveHeader;\n    DS64Chunk ds64_chunk;\n    uint32_t bcount;\n\n    CLEAR (WaveHeader);\n    CLEAR (ds64_chunk);\n    infilesize = DoGetFileSize (infile);\n\n    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\n        error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    memcpy (&riff_chunk_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\n        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\n            error_line (\"%s is not a valid .WAV file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\n            bcount != sizeof (ChunkHeader)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\n\n        if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n            if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n                bcount != sizeof (DS64Chunk)) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            got_ds64 = 1;\n            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\n\n            if (debug_logging_mode)\n                error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\n\n            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            while (ds64_chunk.tableLength--) {\n                CS64Chunk cs64_chunk;\n                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\n                    bcount != sizeof (CS64Chunk) ||\n                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\n                        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                        return WAVPACK_SOFT_ERROR;\n                }\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and\n            int supported = TRUE, format;                        // make sure it's a .wav file we can handle\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .WAV format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this WAV file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else if (config->float_norm_exp)\n                    error_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\n                        config->float_norm_exp - 126, 150 - config->float_norm_exp);\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop\n\n            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\n                ds64_chunk.dataSize64 : chunk_header.ckSize;\n\n\n            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\n                error_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (config->qmode & QMODE_IGNORE_LENGTH) {\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                total_samples = data_chunk_size / WaveHeader.BlockAlign;\n\n                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (!total_samples) {\n                    error_line (\"this .WAV file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid RIFF wav header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes > 0xff000000) {\n        if (debug_logging_mode)\n            error_line (\"total_data_bytes = %lld, so rf64\", total_data_bytes);\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n    else if (debug_logging_mode)\n        error_line (\"total_data_bytes = %lld, so riff\", total_data_bytes);\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    // again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// wave64.c\n\n// This module is a helper to the WavPack command-line programs to support Sony's\n// Wave64 WAV file varient. Note that unlike the WAV/RF64 version, this does not\n// fall back to conventional WAV in the < 4GB case.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n    char formType [16];\n} Wave64FileHeader;\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n} Wave64ChunkHeader;\n\n#define Wave64ChunkHeaderFormat \"88D\"\n\nstatic const unsigned char riff_guid [16] = { 'r','i','f','f', 0x2e,0x91,0xcf,0x11,0xa5,0xd6,0x28,0xdb,0x04,0xc1,0x00,0x00 };\nstatic const unsigned char wave_guid [16] = { 'w','a','v','e', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char  fmt_guid [16] = { 'f','m','t',' ', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char data_guid [16] = { 'd','a','t','a', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&filehdr, fourcc, 4);\n\n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n    // loop through all elements of the wave64 header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .wav file we can handle\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteWave64Header (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    Wave64ChunkHeader datahdr, fmthdr;\n    Wave64FileHeader filehdr;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_file_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid Wave64 header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    total_file_bytes = sizeof (filehdr) + sizeof (fmthdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 7) & ~(int64_t)7);\n\n    memcpy (filehdr.ckID, riff_guid, sizeof (riff_guid));\n    memcpy (filehdr.formType, wave_guid, sizeof (wave_guid));\n    filehdr.ckSize = total_file_bytes;\n\n    memcpy (fmthdr.ckID, fmt_guid, sizeof (fmt_guid));\n    fmthdr.ckSize = sizeof (fmthdr) + wavhdrsize;\n\n    memcpy (datahdr.ckID, data_guid, sizeof (data_guid));\n    datahdr.ckSize = total_data_bytes + sizeof (datahdr);\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&filehdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, Wave64ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &filehdr, sizeof (filehdr), &bcount) || bcount != sizeof (filehdr) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .W64 data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n"], "fixing_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// dsdiff.c\n\n// This module is a helper to the WavPack command-line programs to support DFF files.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#ifdef _WIN32\n#define strdup(x) _strdup(x)\n#endif\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\n#pragma pack(push,2)\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n} DFFChunkHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char formType [4];\n} DFFFileHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t version;\n} DFFVersionChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t sampleRate;\n} DFFSampleRateChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint16_t numChannels;\n} DFFChannelsHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char compressionType [4];\n} DFFCompressionHeader;\n\n#pragma pack(pop)\n\n#define DFFChunkHeaderFormat \"4D\"\n#define DFFFileHeaderFormat \"4D4\"\n#define DFFVersionChunkFormat \"4DL\"\n#define DFFSampleRateChunkFormat \"4DL\"\n#define DFFChannelsHeaderFormat \"4DS\"\n#define DFFCompressionHeaderFormat \"4D4\"\n\nint ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteDsdiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    uint32_t chan_mask = WavpackGetChannelMask (wpc);\n    int num_channels = WavpackGetNumChannels (wpc);\n    DFFFileHeader file_header, prop_header;\n    DFFChunkHeader data_header;\n    DFFVersionChunk ver_chunk;\n    DFFSampleRateChunk fs_chunk;\n    DFFChannelsHeader chan_header;\n    DFFCompressionHeader cmpr_header;\n    char *cmpr_name = \"\\016not compressed\", *chan_ids;\n    int64_t file_size, prop_chunk_size, data_size;\n    int cmpr_name_size, chan_ids_size;\n    uint32_t bcount;\n\n    if (debug_logging_mode)\n        error_line (\"WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\\n\",\n            (long long) total_samples, qmode);\n\n    cmpr_name_size = (strlen (cmpr_name) + 1) & ~1;\n    chan_ids_size = num_channels * 4;\n    chan_ids = malloc (chan_ids_size);\n\n    if (chan_ids) {\n        uint32_t scan_mask = 0x1;\n        char *cptr = chan_ids;\n        int ci, uci = 0;\n\n        for (ci = 0; ci < num_channels; ++ci) {\n            while (scan_mask && !(scan_mask & chan_mask))\n                scan_mask <<= 1;\n\n            if (scan_mask & 0x1)\n                memcpy (cptr, num_channels <= 2 ? \"SLFT\" : \"MLFT\", 4);\n            else if (scan_mask & 0x2)\n                memcpy (cptr, num_channels <= 2 ? \"SRGT\" : \"MRGT\", 4);\n            else if (scan_mask & 0x4)\n                memcpy (cptr, \"C   \", 4);\n            else if (scan_mask & 0x8)\n                memcpy (cptr, \"LFE \", 4);\n            else if (scan_mask & 0x10)\n                memcpy (cptr, \"LS  \", 4);\n            else if (scan_mask & 0x20)\n                memcpy (cptr, \"RS  \", 4);\n            else {\n                cptr [0] = 'C';\n                cptr [1] = (uci / 100) + '0';\n                cptr [2] = ((uci % 100) / 10) + '0';\n                cptr [3] = (uci % 10) + '0';\n                uci++;\n            }\n\n            scan_mask <<= 1;\n            cptr += 4;\n        }\n    }\n    else {\n        error_line (\"can't allocate memory!\");\n        return FALSE;\n    }\n\n    data_size = total_samples * num_channels;\n    prop_chunk_size = sizeof (prop_header) + sizeof (fs_chunk) + sizeof (chan_header) + chan_ids_size + sizeof (cmpr_header) + cmpr_name_size;\n    file_size = sizeof (file_header) + sizeof (ver_chunk) + prop_chunk_size + sizeof (data_header) + ((data_size + 1) & ~(int64_t)1);\n\n    memcpy (file_header.ckID, \"FRM8\", 4);\n    file_header.ckDataSize = file_size - 12;\n    memcpy (file_header.formType, \"DSD \", 4);\n\n    memcpy (prop_header.ckID, \"PROP\", 4);\n    prop_header.ckDataSize = prop_chunk_size - 12;\n    memcpy (prop_header.formType, \"SND \", 4);\n\n    memcpy (ver_chunk.ckID, \"FVER\", 4);\n    ver_chunk.ckDataSize = sizeof (ver_chunk) - 12;\n    ver_chunk.version = 0x01050000;\n\n    memcpy (fs_chunk.ckID, \"FS  \", 4);\n    fs_chunk.ckDataSize = sizeof (fs_chunk) - 12;\n    fs_chunk.sampleRate = WavpackGetSampleRate (wpc) * 8;\n\n    memcpy (chan_header.ckID, \"CHNL\", 4);\n    chan_header.ckDataSize = sizeof (chan_header) + chan_ids_size - 12;\n    chan_header.numChannels = num_channels;\n\n    memcpy (cmpr_header.ckID, \"CMPR\", 4);\n    cmpr_header.ckDataSize = sizeof (cmpr_header) + cmpr_name_size - 12;\n    memcpy (cmpr_header.compressionType, \"DSD \", 4);\n\n    memcpy (data_header.ckID, \"DSD \", 4);\n    data_header.ckDataSize = data_size;\n\n    WavpackNativeToBigEndian (&file_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&ver_chunk, DFFVersionChunkFormat);\n    WavpackNativeToBigEndian (&prop_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&fs_chunk, DFFSampleRateChunkFormat);\n    WavpackNativeToBigEndian (&chan_header, DFFChannelsHeaderFormat);\n    WavpackNativeToBigEndian (&cmpr_header, DFFCompressionHeaderFormat);\n    WavpackNativeToBigEndian (&data_header, DFFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &file_header, sizeof (file_header), &bcount) || bcount != sizeof (file_header) ||\n        !DoWriteFile (outfile, &ver_chunk, sizeof (ver_chunk), &bcount) || bcount != sizeof (ver_chunk) ||\n        !DoWriteFile (outfile, &prop_header, sizeof (prop_header), &bcount) || bcount != sizeof (prop_header) ||\n        !DoWriteFile (outfile, &fs_chunk, sizeof (fs_chunk), &bcount) || bcount != sizeof (fs_chunk) ||\n        !DoWriteFile (outfile, &chan_header, sizeof (chan_header), &bcount) || bcount != sizeof (chan_header) ||\n        !DoWriteFile (outfile, chan_ids, chan_ids_size, &bcount) || bcount != chan_ids_size ||\n        !DoWriteFile (outfile, &cmpr_header, sizeof (cmpr_header), &bcount) || bcount != sizeof (cmpr_header) ||\n        !DoWriteFile (outfile, cmpr_name, cmpr_name_size, &bcount) || bcount != cmpr_name_size ||\n        !DoWriteFile (outfile, &data_header, sizeof (data_header), &bcount) || bcount != sizeof (data_header)) {\n            error_line (\"can't write .DSF data, disk probably full!\");\n            free (chan_ids);\n            return FALSE;\n    }\n\n    free (chan_ids);\n    return TRUE;\n}\n\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// riff.c\n\n// This module is a helper to the WavPack command-line programs to support WAV files\n// (both MS standard and rf64 varients).\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#pragma pack(push,4)\n\ntypedef struct {\n    char ckID [4];\n    uint64_t chunkSize64;\n} CS64Chunk;\n\ntypedef struct {\n    uint64_t riffSize64, dataSize64, sampleCount64;\n    uint32_t tableLength;\n} DS64Chunk;\n\ntypedef struct {\n    char ckID [4];\n    uint32_t ckSize;\n    char junk [28];\n} JunkChunk;\n\n#pragma pack(pop)\n\n#define CS64ChunkFormat \"4D\"\n#define DS64ChunkFormat \"DDDL\"\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\n    int64_t total_samples = 0, infilesize;\n    RiffChunkHeader riff_chunk_header;\n    ChunkHeader chunk_header;\n    WaveHeader WaveHeader;\n    DS64Chunk ds64_chunk;\n    uint32_t bcount;\n\n    CLEAR (WaveHeader);\n    CLEAR (ds64_chunk);\n    infilesize = DoGetFileSize (infile);\n\n    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\n        error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    memcpy (&riff_chunk_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\n        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\n            error_line (\"%s is not a valid .WAV file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\n            bcount != sizeof (ChunkHeader)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\n\n        if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n            if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n                bcount != sizeof (DS64Chunk)) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            got_ds64 = 1;\n            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\n\n            if (debug_logging_mode)\n                error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\n\n            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            while (ds64_chunk.tableLength--) {\n                CS64Chunk cs64_chunk;\n                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\n                    bcount != sizeof (CS64Chunk) ||\n                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\n                        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                        return WAVPACK_SOFT_ERROR;\n                }\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and\n            int supported = TRUE, format;                        // make sure it's a .wav file we can handle\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .WAV format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this WAV file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else if (config->float_norm_exp)\n                    error_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\n                        config->float_norm_exp - 126, 150 - config->float_norm_exp);\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop\n\n            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\n                ds64_chunk.dataSize64 : chunk_header.ckSize;\n\n\n            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\n                error_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (config->qmode & QMODE_IGNORE_LENGTH) {\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                total_samples = data_chunk_size / WaveHeader.BlockAlign;\n\n                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (!total_samples) {\n                    error_line (\"this .WAV file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid RIFF wav header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n\n    if (total_data_bytes > 0xff000000) {\n        if (debug_logging_mode)\n            error_line (\"total_data_bytes = %lld, so rf64\", total_data_bytes);\n        write_junk = 0;\n        do_rf64 = 1;\n    }\n    else if (debug_logging_mode)\n        error_line (\"total_data_bytes = %lld, so riff\", total_data_bytes);\n\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    // again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// wave64.c\n\n// This module is a helper to the WavPack command-line programs to support Sony's\n// Wave64 WAV file varient. Note that unlike the WAV/RF64 version, this does not\n// fall back to conventional WAV in the < 4GB case.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n    char formType [16];\n} Wave64FileHeader;\n\ntypedef struct {\n    char ckID [16];\n    int64_t ckSize;\n} Wave64ChunkHeader;\n\n#define Wave64ChunkHeaderFormat \"88D\"\n\nstatic const unsigned char riff_guid [16] = { 'r','i','f','f', 0x2e,0x91,0xcf,0x11,0xa5,0xd6,0x28,0xdb,0x04,0xc1,0x00,0x00 };\nstatic const unsigned char wave_guid [16] = { 'w','a','v','e', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char  fmt_guid [16] = { 'f','m','t',' ', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\nstatic const unsigned char data_guid [16] = { 'd','a','t','a', 0xf3,0xac,0xd3,0x11,0x8c,0xd1,0x00,0xc0,0x4f,0x8e,0xdb,0x8a };\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\nint ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&filehdr, fourcc, 4);\n\n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n    // loop through all elements of the wave64 header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .wav file we can handle\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteWave64Header (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    Wave64ChunkHeader datahdr, fmthdr;\n    Wave64FileHeader filehdr;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_file_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n    int format = WavpackGetFloatNormExp (wpc) ? 3 : 1;\n    int wavhdrsize = 16;\n\n    if (format == 3 && WavpackGetFloatNormExp (wpc) != 127) {\n        error_line (\"can't create valid Wave64 header for non-normalized floating data!\");\n        return FALSE;\n    }\n\n    if (total_samples == -1)\n        total_samples = 0x7ffff000 / (bytes_per_sample * num_channels);\n\n    total_data_bytes = total_samples * bytes_per_sample * num_channels;\n    CLEAR (wavhdr);\n\n    wavhdr.FormatTag = format;\n    wavhdr.NumChannels = num_channels;\n    wavhdr.SampleRate = sample_rate;\n    wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;\n    wavhdr.BlockAlign = bytes_per_sample * num_channels;\n    wavhdr.BitsPerSample = bits_per_sample;\n\n    if (num_channels > 2 || channel_mask != 0x5 - num_channels) {\n        wavhdrsize = sizeof (wavhdr);\n        wavhdr.cbSize = 22;\n        wavhdr.ValidBitsPerSample = bits_per_sample;\n        wavhdr.SubFormat = format;\n        wavhdr.ChannelMask = channel_mask;\n        wavhdr.FormatTag = 0xfffe;\n        wavhdr.BitsPerSample = bytes_per_sample * 8;\n        wavhdr.GUID [4] = 0x10;\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    total_file_bytes = sizeof (filehdr) + sizeof (fmthdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 7) & ~(int64_t)7);\n\n    memcpy (filehdr.ckID, riff_guid, sizeof (riff_guid));\n    memcpy (filehdr.formType, wave_guid, sizeof (wave_guid));\n    filehdr.ckSize = total_file_bytes;\n\n    memcpy (fmthdr.ckID, fmt_guid, sizeof (fmt_guid));\n    fmthdr.ckSize = sizeof (fmthdr) + wavhdrsize;\n\n    memcpy (datahdr.ckID, data_guid, sizeof (data_guid));\n    datahdr.ckSize = total_data_bytes + sizeof (datahdr);\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&filehdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, Wave64ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, Wave64ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &filehdr, sizeof (filehdr), &bcount) || bcount != sizeof (filehdr) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .W64 data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}\n\n"], "filenames": ["cli/dsdiff.c", "cli/riff.c", "cli/wave64.c"], "buggy_code_start_loc": [282, 289, 244], "buggy_code_end_loc": [283, 290, 245], "fixing_code_start_loc": [282, 289, 244], "fixing_code_end_loc": [290, 297, 252], "type": "CWE-787", "message": "An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.", "other": {"cve": {"id": "CVE-2018-10539", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-29T15:29:00.570", "lastModified": "2019-12-20T10:15:12.373", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation."}, {"lang": "es", "value": "Se ha descubierto un problema en WavPack 5.1.0 y anteriores para las entradas DSDiff. Pueden ocurrir escrituras fuera de l\u00edmites debido a que ParseDsdiffHeaderConfig en dsdiff.c no valida los tama\u00f1os de los fragmentos desconocidos antes de intentar asignar memoria. Esto se relaciona con la falta de protecci\u00f3n ante desbordamientos de enteros en un c\u00e1lculo bytes_to_copy y una subsecuente llamada malloc, lo que conduce a una asignaci\u00f3n de memoria insuficiente."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wavpack:wavpack:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.1.0", "matchCriteriaId": "A5AF1FF6-17E5-429C-8280-8215E7010571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/155743/Slackware-Security-Advisory-wavpack-Updates.html", "source": "cve@mitre.org"}, {"url": "https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/33", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6CFFFWIWALGQPKINRDW3PRGRD5LOLGZA/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BRWQNE3TH5UF64IKHKKHVCHJHUOVKJUH/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Dec/37", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3637-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4197", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d"}}