{"buggy_code": ["                                                         -*- coding: utf-8 -*-\nChanges with Apache 2.5.0\n\n  *) mod_lua: Fix default value of LuaInherit directive. It should be \n     'parent-first' instead of 'none', as per documentation.  PR 60419\n     [Christophe Jaillet]\n\n  *) mod_ratelimit: Allow for initial \"burst\" amount at full speed before\n     throttling: PR 60145 [Andy Valencia <ajv-etradanalhos vsta.org>,\n     Jim Jagielski]\n\n  *) event: Allow to use the whole allocated scoreboard (up to ServerLimit\n     slots) to avoid scoreboard full errors when some processes are finishing\n     gracefully. Also, make gracefully finishing processes close all\n     keep-alive connections. PR 53555. [Stefan Fritsch]\n\n  *) http: Allow unknown response status' lines returned in the form of\n     \"HTTP/x.x xxx Status xxx\".  [Yann Ylavic]\n\n  *) core: Add <IfFile> configuration section to allow any file on disk to be\n     used as a conditional.  [Edward Lu, Eric Covener]\n\n  *) event: Avoid listener periodic wake ups by using the pollset wake-ability\n     when available.  PR 57399.  [Yann Ylavic, Luca Toscano]\n\n  *) mod_brotli: Add a new module for dynamic Brotli (RFC 7932) compression.\n     [Evgeny Kotkov]\n\n  *) core: Permit unencoded ';' characters to appear in proxy requests and\n     Location: response headers. Corresponds to modern browser behavior.\n     [William Rowe]\n\n  *) mod_cache: Use the actual URI path and query-string for identifying the\n     cached entity (key), such that rewrites are taken into account when\n     running afterwards (CacheQuickHandler off).  PR 21935.  [Yann Ylavic]\n\n  *) mod_ssl: Fix quick renegotiation (OptRenegotiaton) with no intermediate\n     in the client certificate chain.  PR 55786.  [Yann Ylavic]\n\n  *) mod_reqtimeout: Fix body timeout disabling for CONNECT requests to avoid\n     triggering mod_proxy_connect's AH01018 once the tunnel is established.\n     [Yann Ylavic]\n\n  *) mod_crypto: Add the all purpose crypto filters with support for HLS.\n     [Graham Leggett]\n\n  *) core: Drop an invalid Last-Modified header value coming\n     from a FCGI/CGI script instead of replacing it with Unix epoch.\n     Warn the users about Last-Modified header value replacements\n     and violations of the RFC.\n     [Yann Ylavic, Luca Toscano, William Rowe, Jacob Champion]\n\n  *) mod_dav: Allow other modules to become providers and add ACLs\n     to the DAV response.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_dav: Add dav_begin_multistatus, dav_send_one_response,\n     dav_finish_multistatus, dav_send_multistatus, dav_handle_err,\n     dav_failed_proppatch, dav_success_proppatch to mod_dav.h.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_proxy, mod_ssl: Handle SSLProxy* directives in <Proxy> sections,\n     allowing per backend TLS configuration.  [Yann Ylavic]\n\n  *) core: explicitly exclude 'h2' from protocols announced via an Upgrade: \n     header as commanded by http-wg. [Stefan Eissing]\n\n  *) mod_proxy_ajp: Add \"secret\" parameter to proxy workers to implement legacy\n     AJP13 authentication.  PR 53098.  [Dmitry A. Bakshaev <dab1818 gmail com>]\n\n  *) mpm_event: Don't take over scoreboard slots from gracefully finishing\n     threads. [Stefan Fritsch]\n\n  *) mod_status: Display the process slot number in the async connection\n     overview. [Stefan Fritsch]\n\n  *) mpm: Generalise the ap_mpm_register_socket functions to accept pipes\n     or sockets. [Graham Leggett]\n\n  *) core: Extend support for setting aside data from the network input filter\n     to any connection or request input filter. [Graham Leggett]\n\n  *) core: Split ap_create_request() from ap_read_request(). [Graham Leggett]\n\n  *) mod_auth_digest: Fix compatibility with expression-based Authname. PR59039.\n     [Eric Covener]\n\n  *) mpm: Add a complete_connection hook that confirms whether an MPM is allowed\n     to leave the WRITE_COMPLETION phase. Move filter code out of the MPMs.\n     [Graham Leggett]\n\n  *) core: Added support for HTTP code 451. PR58985.\n     [Yehuda Katz <yehuda ymkatz.net>, Jim Jagielski]\n\n  *) mod_ssl: Add support for OpenSSL 1.1.0. [Rainer Jung]\n\n  *) mod_filter: Fix AddOutputFilterByType with non-content-level filters.\n     PR58856 [Micha Lenk <micha lenk.info>]\n\n  *) mod_cache: Consider Cache-Control: s-maxage in expiration\n     calculations.  [Eric Covener]\n\n  *) mod_cache: Allow caching of responses with an Expires header\n     in the past that also has Cache-Control: max-age or s-maxage.\n     PR55156. [Eric Covener]\n\n  *) Added many log numbers to log statements that had none.\n\n  *) mod_session: Introduce SessionExpiryUpdateInterval which allows to\n     configure the session/cookie expiry's update interval. PR 57300.\n     [Paul Spangler <paul.spangler ni.com>]\n\n  *) core: Extend support for asynchronous write completion from the\n     network filter to any connection or request filter. [Graham Leggett]\n\n  *) mpm_event: Free memory earlier when shutting down processes.\n     [Stefan Fritsch]\n\n  *) mod_auth_digest: remove AuthDigestEnableQueryStringHack which is no\n     more documented since dec 2012 (r1415960). [Christophe Jaillet]\n\n  *) mod_charset_lite: On EBCDIC platforms, make sure mod_charset_lite runs\n     after other resource-level filters. [Eric Covener]\n\n  *) mod_dir: Responses that go through \"FallbackResource\" might appear to\n     hang due to unterminated chunked encoding. PR58292. [Eric Covener]\n\n  *) http: Don't remove the Content-Length of zero from a HEAD response if\n     it comes from an origin server, module or script.  [Yann Ylavic]\n\n  *) http: Add support for RFC2324/RFC7168. [Graham Leggett]\n\n  *) mod_rewrite: Add support for starting External Rewriting Programs\n     as non-root user on UNIX systems by specifying username and group name\n     as third argument of RewriteMap directive. [Jan Kaluza]\n\n  *) mod_authn_core: Add expression support to AuthName and AuthType.\n     [Graham Leggett]\n\n  *) suexec: Filter out the HTTP_PROXY environment variable because it is\n     treated as alias for http_proxy by some programs. [Stefan Fritsch]\n\n  *) mod_proxy_http: Don't establish or reuse a backend connection before pre-\n     fetching the request body, so to minimize the delay between it is supposed\n     to be alive and the first bytes sent: this is a best effort to prevent the\n     backend from closing because of idle or keepalive timeout in the meantime.\n     Also, handle a new \"proxy-flushall\" environment variable which allows to\n     flush any forwarded body data immediately. PR 56541+37920. [Yann Ylavic]\n\n  *) core: Define and UnDefine are no longer permitted in\n     directory context. Previously they would always be evaulated\n     as the configuration was read without regard for the directory\n     context. [Eric Covener]\n\n  *) config: For directives that do not expect any arguments, enforce\n     that none are specified in the configuration file. \n     [Joachim Zobel <jzobel heute-morgen.de>, Eric Covener]\n\n  *) mod_rewrite: Improve 'bad flag delimeters' startup error by showing\n     how the input was tokenized.  PR 56528. [Edward Lu <Chaosed0 gmail.com>]\n\n  *) mod_proxy: Don't put non balancer-member workers in error state by\n     default for connection or 500/503 errors, and honor status=+I for\n     any error.  PR 48388.  [Yann Ylavic]\n\n  *) mod_socache_memcache: Pass expiration time through to memcached. PR 55445.\n     [Faidon Liambotis <paravoid debian.org>, Joe Orton]\n\n  *) ap_expr: Add filemod function for checking file modification dates\n     [Daniel Gruno]\n\n  *) mod_authnz_ldap: Resolve crashes with LDAP authz and non-LDAP authn since \n     r1608202. [Eric Covener]\n\n  *) apreq: Content-Length header should be always interpreted as a decimal.\n     Leading 0 could be erroneously considered as an octal value. PR 56598.\n     [Chris Card <ctcard hotmail com>]\n\n  *) mod_proxy: Now allow for 191 character worker names, with non-fatal\n     errors if name is truncated. PR53218. [Jim Jagielski]\n\n  *) mod_ssl: Add optional function \"ssl_get_tls_cb\" to allow support\n     for channel bindings.  [Simo Sorce <simo redhat.com>]\n\n  *) mod_proxy_wstunnel: Concurrent websockets messages could be \n     lost or delayed with ProxyWebsocketAsync enabled.  \n     [Edward Lu <Chaosed0 gmail.com>]\n\n  *) core, mod_info: Add compiled and loaded PCRE versions to version\n     number display.  [Rainer Jung]\n\n  *) mod_authnz_ldap: Return LDAP connections to the pool before the handler\n     is run, instead of waiting until the end of the request. [Eric Covener]\n\n  *) mod_proxy_html: support automatic detection of doctype and processing\n     of FPIs.  PR56285 [Micha Lenk <micha lenk info>, Nick Kew]\n\n  *) mod_proxy_html: skip documents shorter than 4 bytes\n     PR 56286 [Micha Lenk <micha lenk info>]\n\n  *) mod_proxy_fdpass: Fix computation of the size of 'struct sockaddr_un'\n     when passed to 'connect()'.\n     [Graham Dumpleton <grahamd apache org>]\n\n  *) core: Add ap_mpm_resume_suspended() API to allow a suspended connection\n     to resume. PR56333 \n     [Artem <artemciy gmail.com>, Edward Lu <Chaosed0 gmail.com>]\n\n  *) core: Add ap_mpm_register_socket_callback_timeout() API. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Honor ProxyWebsocketIdleTimeout in asynchronous\n     processing mode. [Eric Covener]\n\n  *) mod_authnz_ldap: Fail explicitly when the filter is too long. Remove\n     unnecessary apr_pstrdup() and strlen(). [Graham Leggett]\n\n  *) Add the ldap-search option to mod_authnz_ldap, allowing authorization\n     to be based on arbitrary expressions that do not include the username.\n     [Graham Leggett]\n\n  *) Add the ldap function to the expression API, allowing LDAP filters and\n     distinguished names based on expressions to be escaped correctly to\n     guard against LDAP injection. [Graham Leggett]\n\n  *) Add module mod_ssl_ct, which provides an implementation of Certificate\n     Transparency (RFC 6962) for httpd.  [Jeff Trawick]\n\n  *) mod_proxy_wstunnel: Avoid sending error responses down an upgraded\n     websockets connection as it is being close down. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Allow the administrator to cap the amount\n     of time a synchronous websockets connection stays idle with \n     ProxyWebsocketIdleTimeout. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Change to opt-in for asynchronous support, adding \n     directives ProxyWebsocketAsync and ProxyWebsocketAsyncDelay. \n     [Eric Covener]\n\n  *) mod_proxy_wstunnel: Stop leaking websockets backend connections under\n     event MPM (trunk-only). [Eric Covener]\n\n  *) mod_proxy_http: Add detach_backend hook (potentially usable\n     in other proxy scheme handlers).  [Jeff Trawick]\n\n  *) mod_deflate: Add DeflateAlterETag to control how the ETag\n     is modified. The 'NoChange' parameter mimics 2.2.x behavior.\n     PR 45023, PR 39727. [Eric Covener]\n\n  *) mod_rewrite: Add 'BNF' (backreferences-no-plus) flag to RewriteRule to \n     allow spaces in backreferences to be encoded as %20 instead of '+'.\n     [Eric Covener]\n\n  *) mod_rewrite: Support an optional list of characters to escape in the \n     argument for the 'B' (escape backreferences) flag. [Eric Covener]\n\n  *) mod_dir: Default to 2.2-like behavior and skip execution when method is\n     neither GET nor POST, such as for DAV requests. PR 54914. [Chris Darroch]\n\n  *) mod_rewrite: Rename the handler that does per-directory internal \n     redirects to \"rewrite-redirect-handler\" from \"redirect-handler\" so\n     it is less ambiguous and less likely to be reused. [Eric Covener]\n\n  *) mod_rewrite: Protect against looping with the [N] flag by enforcing a \n     default limit of 10000 iterations, and allowing each rule to change its\n     limit. [Eric Covener]\n\n  *) mod_ssl: Fix config merging of SSLOCSPEnable and SSLOCSPOverrideResponder.\n     [Jeff Trawick]\n\n  *) Add HttpContentLengthHeadZero and HttpExpectStrict directives.\n     [Yehuda Sadeh <yehuda inktank com>, Justin Erenkrantz]\n\n  *) mod_ssl: Add -t -DDUMP_CA_CERTS option which dumps the filenames of all\n     configured SSL CA certificates to stdout the same way as DUMP_CERTS does.\n     [Jan Kaluza]\n\n  *) mod_ssl: Don't flush when an EOS is received. Prepares mod_ssl\n     to support write completion. [Graham Leggett]\n\n  *) core: Add parse_errorlog_arg callback to ap_errorlog_provider\n     to allow providers to check the ErrorLog argument. [Jan Kaluza]\n\n  *) mod_cgid: Use the servers Timeout for each read from a CGI script,\n     allow override with new CGIDRequestTimeout directive. PR43494\n     [Eric Covener, Toshikuni Fukaya <toshikuni-fukaya cybozu co jp>]\n\n  *) core: ensure any abnormal exit is reported to stderr if it's a tty.\n     PR 55670 [Nick Kew]\n\n  *) mod_lua: Let the Inter-VM get/set functions work with a global \n     shared memory pool instead of a per-process pool. [Daniel Gruno]\n\n  *) ldap: Support ldaps when using the Microsoft LDAP SDK.\n     PR 54626. [Jean-Frederic Clere]\n\n  *) mod_authnz_ldap: Change default value of AuthLDAPMaxSubGroupDepth to 0\n     to avoid performance problems when subgroups aren't in use. [Eric Covener]\n\n  *) mod_syslog: New module implementing syslog ap_error_log provider.\n     Previously, this code was part of core, now it's in separate module.\n     [Jan Kaluza]\n\n  *) core: Add ap_errorlog_provider to make ErrorLog logging modular. Move\n     syslog support from core to new mod_syslog. [Jan Kaluza]\n\n  *) mod_status, mod_echo: Fix the display of client addresses.\n     They were truncated to 31 characters which is not enough for IPv6 addresses.\n     PR 54848 [Bernhard Schmidt <berni birkenwald de>]\n\n  *) mod_unique_id: Use output of the PRNG rather than IP address and\n     pid, avoiding sleep() call and possible DNS issues at startup,\n     plus improving randomness for IPv6-only hosts.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) mod_file_cache: mod_file_cache should be able to serve files that\n     haven't had a Content-Type set via e.g. mod_mime. [Eric Covener]\n\n  *) core: merge AllowEncodedSlashes from the base configuration into\n     virtual hosts. [Eric Covener]\n\n  *) AIX: Install DSO's with \"cp\" instead of \"install\" in instdso.sh\n     [Eric Covener]\n\n  *) mod_ldap: Don't keep retrying if a new LDAP connection times out.\n     [Eric Covener]\n\n  *) mod_deflate: permit compilation of mod_deflate against a zlib that has\n     been configured with -D Z_PREFIX, which redefines the token \"deflate\".\n     [Eric Covener]\n\n  *) mod_auth_digest: Use the secret when generating nonces in all cases and\n     not only when AuthName is used in .htaccess files (this change may cause\n     problems if used with round robin load balancers). Don't regenerate the\n     secret on graceful restarts. PR 54637  [Stefan Fritsch]\n\n  *) core: Remove apr_brigade_flatten(), buffering and duplicated code\n     from the HTTP_IN filter, parse chunks in a single pass with zero copy.\n     Reduce memory usage by 48 bytes per request. [Graham Leggett]\n\n  *) core: Stop the HTTP_IN filter from attempting to write error buckets\n     to the output filters, which is bogus in the proxy case. Create a\n     clean mapping from APR codes to HTTP status codes, and use it where\n     needed. [Graham Leggett]\n\n  *) mod_proxy: Ensure network errors detected by the proxy are returned as\n     504 Gateway Timout as opposed to 502 Bad Gateway, in order to be\n     compliant with RFC2616 14.9.4 Cache Revalidation and Reload Controls.\n\n  *) mod_dav: mod_dav overrides dav_fs response on PUT failure. PR 35981\n     [Basant Kumar Kukreja <basant.kukreja sun.com>, Alejandro Alvarez\n     <alejandro.alvarez.ayllon cern.ch>]\n\n  *) mod_ldap: LDAP connections used for authentication were not respecting\n     LDAPConnectionPoolTimeout.  PR 54587\n\n  *) core: ap_rgetline_core now pulls from r->proto_input_filters.\n\n  *) mod_proxy_html: process parsed comments immediately. \n     Fixes bug where parsed comments may be lost. [Nick Kew]\n\n  *) mod_proxy_html: introduce doctype for HTML 5 [Nick Kew]\n\n  *) mod_proxy_html: fix typo-bug processing \"strict\" vs \"transitional\"\n     HTML/XHTML [Nick Kew]\n\n  *) core: Add option to add valgrind support. Use it to reduce false positive\n     warnings in mod_ssl. [Stefan Fritsch]\n\n  *) mod_authn_file, mod_authn_dbd, mod_authn_dbm, mod_authn_socache:\n     Cache the result of the most recent password hash verification for every\n     keep-alive connection. This saves some expensive calculations.\n     [Stefan Fritsch]\n\n  *) http: Remove support for Request-Range header sent by Navigator 2-3 and\n     MSIE 3. [Stefan Fritsch]\n\n  *) core, http: Extend HttpProtocol with an option to enforce stricter HTTP\n     conformance or to only log the found problems. [Stefan Fritsch]\n\n  *) core: Correctly parse an IPv6 literal host specification in an absolute\n     URL in the request line. [Stefan Fritsch]\n\n  *) EventOpt MPM\n\n  *) core: Add LogLevelOverride directive that allows to override the\n     loglevel for clients from certain IPs. This also works for things\n     like the SSL handshake where <If> LogLevel ... </If> is evaluated\n     too late. [Stefan Fritsch]\n\n  *) core: Add new directive Warning to issue warnings from a configuration\n     file. Both Warning and Error now generate a timestamped log message.\n     [Fabien Coelho] \n\n  *) ap_expr: Add SERVER_PROTOCOL_VERSION, ..._MAJOR, and ..._MINOR\n     variables. [Stefan Fritsch]\n\n  *) core: New directive RegisterHttpMethod for registering non-standard\n     HTTP methods. [Stefan Fritsch]\n\n  *) core: New directive HttpProtocol which allows to disable HTTP/0.9\n     support. [Stefan Fritsch]\n\n  *) mod_allowhandlers: New module to forbid specific handlers for specific\n     directories. [Stefan Fritsch]\n\n  *) mod_systemd: New module, for integration with systemd on Linux.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) WinNT MPM: Store pid and generation for each thread in scoreboard\n     to allow tracking of threads from exiting children via mod_status\n     or other such mechanisms.  [Jeff Trawick]\n\n  *) The following now respect DefaultRuntimeDir/DEFAULT_REL_RUNTIMEDIR:\n     - APIs: ap_log_pid(), ap_remove_pid, ap_read_pid()\n     - mod_cache: thundering herd lock directory\n     - mod_lbmethod_heartbeat, mod_heartmonitor: heartbeat storage file\n     - mod_ldap: shared memory cache\n     - mod_socache_shmcb, mod_socache_dbm: shared memory or dbm for cache\n     [Jeff Trawick]\n\n  *) suexec: Add --enable-suexec-capabilites support on Linux, to use\n     setuid/setgid capability bits rather than a setuid root binary.\n     [Joe Orton]\n\n  *) suexec: Add support for logging to syslog as an alternative to logging\n     to a file; configure --without-suexec-logfile --with-suexec-syslog.  \n     [Joe Orton]\n\n  *) mod_ssl: Add support for TLS Next Protocol Negotiation.  PR 52210.\n     [Matthew Steele <mdsteele google.com>]\n\n  *) cross-compile: allow to provide CC_FOR_BUILD so that gen_test_char will\n     be compiled by the build compiler instead of the host compiler.\n     Also set CC_FOR_BUILD to 'cc' when cross-compilation is detected.\n     PR 51257. [Guenter Knauf]\n\n  *) core: In maintainer mode, replace apr_palloc with a version that\n     initializes the allocated memory with non-zero values, except if\n     AP_DEBUG_NO_ALLOC_POISON is defined. [Stefan Fritsch]\n\n  *) mod_policy: Add a new testing module to help server administrators\n     enforce a configurable level of protocol compliance on their\n     servers and application servers behind theirs. [Graham Leggett]\n\n  *) mod_firehose: Add a new debugging module able to record traffic\n     passing through the server in such a way that connections and/or\n     requests be reconstructed and replayed. [Graham Leggett]\n\n  *) mod_noloris\n\n  *) APREQ\n\n  *) Simple MPM\n\n  *) mod_serf\n\n  [Apache 2.5.0-dev includes those bug fixes and changes with the\n   Apache 2.4.xx tree as documented below, except as noted.]\n\nChanges with Apache 2.4.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.4.x/CHANGES?view=markup\n\nChanges with Apache 2.2.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.2.x/CHANGES?view=markup\n\nChanges with Apache 2.0.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.0.x/CHANGES?view=markup\n\n", "/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <assert.h>\n#include <stddef.h>\n#include <apr_thread_cond.h>\n#include <apr_base64.h>\n#include <apr_strings.h>\n\n#include <ap_mpm.h>\n\n#include <httpd.h>\n#include <http_core.h>\n#include <http_config.h>\n#include <http_log.h>\n#include <scoreboard.h>\n\n#include \"h2_private.h\"\n#include \"h2.h\"\n#include \"h2_bucket_eoc.h\"\n#include \"h2_bucket_eos.h\"\n#include \"h2_config.h\"\n#include \"h2_ctx.h\"\n#include \"h2_filter.h\"\n#include \"h2_h2.h\"\n#include \"h2_mplx.h\"\n#include \"h2_push.h\"\n#include \"h2_request.h\"\n#include \"h2_headers.h\"\n#include \"h2_stream.h\"\n#include \"h2_task.h\"\n#include \"h2_session.h\"\n#include \"h2_util.h\"\n#include \"h2_version.h\"\n#include \"h2_workers.h\"\n\n\nstatic int h2_session_status_from_apr_status(apr_status_t rv)\n{\n    if (rv == APR_SUCCESS) {\n        return NGHTTP2_NO_ERROR;\n    }\n    else if (APR_STATUS_IS_EAGAIN(rv)) {\n        return NGHTTP2_ERR_WOULDBLOCK;\n    }\n    else if (APR_STATUS_IS_EOF(rv)) {\n        return NGHTTP2_ERR_EOF;\n    }\n    return NGHTTP2_ERR_PROTO;\n}\n\nstatic void update_window(void *ctx, int stream_id, apr_off_t bytes_read)\n{\n    h2_session *session = (h2_session*)ctx;\n    nghttp2_session_consume(session->ngh2, stream_id, bytes_read);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                  \"h2_session(%ld-%d): consumed %ld bytes\",\n                  session->id, stream_id, (long)bytes_read);\n}\n\nstatic apr_status_t h2_session_receive(void *ctx, \n                                       const char *data, apr_size_t len,\n                                       apr_size_t *readlen);\n\nstatic void dispatch_event(h2_session *session, h2_session_event_t ev, \n                             int err, const char *msg);\n\napr_status_t h2_session_stream_done(h2_session *session, h2_stream *stream)\n{\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                  \"h2_stream(%ld-%d): EOS bucket cleanup -> done\", \n                  session->id, stream->id);\n    h2_mplx_stream_done(session->mplx, stream);\n    \n    dispatch_event(session, H2_SESSION_EV_STREAM_DONE, 0, NULL);\n    return APR_SUCCESS;\n}\n\ntypedef struct stream_sel_ctx {\n    h2_session *session;\n    h2_stream *candidate;\n} stream_sel_ctx;\n\nstatic int find_cleanup_stream(h2_stream *stream, void *ictx)\n{\n    stream_sel_ctx *ctx = ictx;\n    if (H2_STREAM_CLIENT_INITIATED(stream->id)) {\n        if (!ctx->session->local.accepting\n            && stream->id > ctx->session->local.accepted_max) {\n            ctx->candidate = stream;\n            return 0;\n        }\n    }\n    else {\n        if (!ctx->session->remote.accepting\n            && stream->id > ctx->session->remote.accepted_max) {\n            ctx->candidate = stream;\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic void cleanup_streams(h2_session *session)\n{\n    stream_sel_ctx ctx;\n    ctx.session = session;\n    ctx.candidate = NULL;\n    while (1) {\n        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);\n        if (ctx.candidate) {\n            h2_session_stream_done(session, ctx.candidate);\n            ctx.candidate = NULL;\n        }\n        else {\n            break;\n        }\n    }\n}\n\nh2_stream *h2_session_open_stream(h2_session *session, int stream_id,\n                                  int initiated_on, const h2_request *req)\n{\n    h2_stream * stream;\n    apr_pool_t *stream_pool;\n    \n    apr_pool_create(&stream_pool, session->pool);\n    apr_pool_tag(stream_pool, \"h2_stream\");\n    \n    stream = h2_stream_open(stream_id, stream_pool, session, \n                            initiated_on);\n    nghttp2_session_set_stream_user_data(session->ngh2, stream_id, stream);\n    \n    if (req) {\n        h2_stream_set_request(stream, req);\n    }\n    \n    if (H2_STREAM_CLIENT_INITIATED(stream_id)) {\n        if (stream_id > session->remote.emitted_max) {\n            ++session->remote.emitted_count;\n            session->remote.emitted_max = stream->id;\n            session->local.accepted_max = stream->id;\n        }\n    }\n    else {\n        if (stream_id > session->local.emitted_max) {\n            ++session->local.emitted_count;\n            session->remote.emitted_max = stream->id;\n        }\n    }\n    dispatch_event(session, H2_SESSION_EV_STREAM_OPEN, 0, NULL);\n    \n    return stream;\n}\n\n/**\n * Determine the importance of streams when scheduling tasks.\n * - if both stream depend on the same one, compare weights\n * - if one stream is closer to the root, prioritize that one\n * - if both are on the same level, use the weight of their root\n *   level ancestors\n */\nstatic int spri_cmp(int sid1, nghttp2_stream *s1, \n                    int sid2, nghttp2_stream *s2, h2_session *session)\n{\n    nghttp2_stream *p1, *p2;\n    \n    p1 = nghttp2_stream_get_parent(s1);\n    p2 = nghttp2_stream_get_parent(s2);\n    \n    if (p1 == p2) {\n        int32_t w1, w2;\n        \n        w1 = nghttp2_stream_get_weight(s1);\n        w2 = nghttp2_stream_get_weight(s2);\n        return w2 - w1;\n    }\n    else if (!p1) {\n        /* stream 1 closer to root */\n        return -1;\n    }\n    else if (!p2) {\n        /* stream 2 closer to root */\n        return 1;\n    }\n    return spri_cmp(sid1, p1, sid2, p2, session);\n}\n\nstatic int stream_pri_cmp(int sid1, int sid2, void *ctx)\n{\n    h2_session *session = ctx;\n    nghttp2_stream *s1, *s2;\n    \n    s1 = nghttp2_session_find_stream(session->ngh2, sid1);\n    s2 = nghttp2_session_find_stream(session->ngh2, sid2);\n\n    if (s1 == s2) {\n        return 0;\n    }\n    else if (!s1) {\n        return 1;\n    }\n    else if (!s2) {\n        return -1;\n    }\n    return spri_cmp(sid1, s1, sid2, s2, session);\n}\n\nstatic apr_status_t stream_schedule(h2_session *session,\n                                    h2_stream *stream, int eos)\n{\n    (void)session;\n    return h2_stream_schedule(stream, eos, h2_session_push_enabled(session), \n                              stream_pri_cmp, session);\n}\n\n/*\n * Callback when nghttp2 wants to send bytes back to the client.\n */\nstatic ssize_t send_cb(nghttp2_session *ngh2,\n                       const uint8_t *data, size_t length,\n                       int flags, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    apr_status_t status;\n    \n    (void)ngh2;\n    (void)flags;\n    status = h2_conn_io_write(&session->io, (const char *)data, length);\n    if (status == APR_SUCCESS) {\n        return length;\n    }\n    if (APR_STATUS_IS_EAGAIN(status)) {\n        return NGHTTP2_ERR_WOULDBLOCK;\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c, APLOGNO(03062)\n                  \"h2_session: send error\");\n    return h2_session_status_from_apr_status(status);\n}\n\nstatic int on_invalid_frame_recv_cb(nghttp2_session *ngh2,\n                                    const nghttp2_frame *frame,\n                                    int error, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    (void)ngh2;\n    \n    if (APLOGcdebug(session->c)) {\n        char buffer[256];\n        \n        h2_util_frame_print(frame, buffer, sizeof(buffer)/sizeof(buffer[0]));\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03063)\n                      \"h2_session(%ld): recv invalid FRAME[%s], frames=%ld/%ld (r/s)\",\n                      session->id, buffer, (long)session->frames_received,\n                     (long)session->frames_sent);\n    }\n    return 0;\n}\n\nstatic h2_stream *get_stream(h2_session *session, int stream_id)\n{\n    return nghttp2_session_get_stream_user_data(session->ngh2, stream_id);\n}\n\nstatic int on_data_chunk_recv_cb(nghttp2_session *ngh2, uint8_t flags,\n                                 int32_t stream_id,\n                                 const uint8_t *data, size_t len, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    apr_status_t status = APR_SUCCESS;\n    h2_stream * stream;\n    int rv;\n    \n    (void)flags;\n    stream = get_stream(session, stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03064)\n                      \"h2_stream(%ld-%d): on_data_chunk for unknown stream\",\n                      session->id, (int)stream_id);\n        rv = nghttp2_submit_rst_stream(ngh2, NGHTTP2_FLAG_NONE, stream_id,\n                                       NGHTTP2_INTERNAL_ERROR);\n        if (nghttp2_is_fatal(rv)) {\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n        }\n        return 0;\n    }\n\n    /* FIXME: enabling setting EOS this way seems to break input handling\n     * in mod_proxy_http2. why? */\n    status = h2_stream_write_data(stream, (const char *)data, len,\n                                  0 /*flags & NGHTTP2_FLAG_END_STREAM*/);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                  \"h2_stream(%ld-%d): data_chunk_recv, written %ld bytes\",\n                  session->id, stream_id, (long)len);\n    if (status != APR_SUCCESS) {\n        update_window(session, stream_id, len);\n        rv = nghttp2_submit_rst_stream(ngh2, NGHTTP2_FLAG_NONE, stream_id,\n                                       H2_STREAM_RST(stream, H2_ERR_INTERNAL_ERROR));\n        if (nghttp2_is_fatal(rv)) {\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n        }\n    }\n    return 0;\n}\n\nstatic apr_status_t stream_release(h2_session *session, \n                                   h2_stream *stream,\n                                   uint32_t error_code) \n{\n    conn_rec *c = session->c;\n    apr_bucket *b;\n    apr_status_t status;\n    \n    if (!error_code) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                      \"h2_stream(%ld-%d): handled, closing\", \n                      session->id, (int)stream->id);\n        if (H2_STREAM_CLIENT_INITIATED(stream->id)) {\n            if (stream->id > session->local.completed_max) {\n                session->local.completed_max = stream->id;\n            }\n        }\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03065)\n                      \"h2_stream(%ld-%d): closing with err=%d %s\", \n                      session->id, (int)stream->id, (int)error_code,\n                      h2_h2_err_description(error_code));\n        h2_stream_rst(stream, error_code);\n    }\n    \n    b = h2_bucket_eos_create(c->bucket_alloc, stream);\n    APR_BRIGADE_INSERT_TAIL(session->bbtmp, b);\n    status = h2_conn_io_pass(&session->io, session->bbtmp);\n    apr_brigade_cleanup(session->bbtmp);\n    return status;\n}\n\nstatic int on_stream_close_cb(nghttp2_session *ngh2, int32_t stream_id,\n                              uint32_t error_code, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    h2_stream *stream;\n    \n    (void)ngh2;\n    stream = get_stream(session, stream_id);\n    if (stream) {\n        stream_release(session, stream, error_code);\n    }\n    return 0;\n}\n\nstatic int on_begin_headers_cb(nghttp2_session *ngh2,\n                               const nghttp2_frame *frame, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    h2_stream *s;\n    \n    /* We may see HEADERs at the start of a stream or after all DATA\n     * streams to carry trailers. */\n    (void)ngh2;\n    s = get_stream(session, frame->hd.stream_id);\n    if (s) {\n        /* nop */\n    }\n    else {\n        s = h2_session_open_stream(userp, frame->hd.stream_id, 0, NULL);\n    }\n    return s? 0 : NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n}\n\nstatic int on_header_cb(nghttp2_session *ngh2, const nghttp2_frame *frame,\n                        const uint8_t *name, size_t namelen,\n                        const uint8_t *value, size_t valuelen,\n                        uint8_t flags,\n                        void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    h2_stream * stream;\n    apr_status_t status;\n    \n    (void)flags;\n    stream = get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, session->c,\n                      APLOGNO(02920) \n                      \"h2_session:  stream(%ld-%d): on_header unknown stream\",\n                      session->id, (int)frame->hd.stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n    \n    status = h2_stream_add_header(stream, (const char *)name, namelen,\n                                  (const char *)value, valuelen);\n    if (status != APR_SUCCESS && !h2_stream_is_ready(stream)) {\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n    return 0;\n}\n\n/**\n * nghttp2 session has received a complete frame. Most, it uses\n * for processing of internal state. HEADER and DATA frames however\n * we need to handle ourself.\n */\nstatic int on_frame_recv_cb(nghttp2_session *ng2s,\n                            const nghttp2_frame *frame,\n                            void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    apr_status_t status = APR_SUCCESS;\n    h2_stream *stream;\n    \n    if (APLOGcdebug(session->c)) {\n        char buffer[256];\n        \n        h2_util_frame_print(frame, buffer, sizeof(buffer)/sizeof(buffer[0]));\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03066)\n                      \"h2_session(%ld): recv FRAME[%s], frames=%ld/%ld (r/s)\",\n                      session->id, buffer, (long)session->frames_received,\n                     (long)session->frames_sent);\n    }\n\n    ++session->frames_received;\n    switch (frame->hd.type) {\n        case NGHTTP2_HEADERS:\n            /* This can be HEADERS for a new stream, defining the request,\n             * or HEADER may come after DATA at the end of a stream as in\n             * trailers */\n            stream = get_stream(session, frame->hd.stream_id);\n            if (stream) {\n                int eos = (frame->hd.flags & NGHTTP2_FLAG_END_STREAM);\n                \n                if (h2_stream_is_scheduled(stream)) {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                                  \"h2_stream(%ld-%d): TRAILER, eos=%d\", \n                                  session->id, frame->hd.stream_id, eos);\n                    if (eos) {\n                        status = h2_stream_close_input(stream);\n                    }\n                }\n                else {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                                  \"h2_stream(%ld-%d): HEADER, eos=%d\", \n                                  session->id, frame->hd.stream_id, eos);\n                    status = stream_schedule(session, stream, eos);\n                }\n            }\n            else {\n                status = APR_EINVAL;\n            }\n            break;\n        case NGHTTP2_DATA:\n            stream = get_stream(session, frame->hd.stream_id);\n            if (stream) {\n                int eos = (frame->hd.flags & NGHTTP2_FLAG_END_STREAM);\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                              \"h2_stream(%ld-%d): DATA, len=%ld, eos=%d\", \n                              session->id, frame->hd.stream_id, \n                              (long)frame->hd.length, eos);\n                if (eos) {\n                    status = h2_stream_close_input(stream);\n                }\n            }\n            else {\n                status = APR_EINVAL;\n            }\n            break;\n        case NGHTTP2_PRIORITY:\n            session->reprioritize = 1;\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session:  stream(%ld-%d): PRIORITY frame \"\n                          \" weight=%d, dependsOn=%d, exclusive=%d\", \n                          session->id, (int)frame->hd.stream_id,\n                          frame->priority.pri_spec.weight,\n                          frame->priority.pri_spec.stream_id,\n                          frame->priority.pri_spec.exclusive);\n            break;\n        case NGHTTP2_WINDOW_UPDATE:\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session:  stream(%ld-%d): WINDOW_UPDATE \"\n                          \"incr=%d\", \n                          session->id, (int)frame->hd.stream_id,\n                          frame->window_update.window_size_increment);\n            break;\n        case NGHTTP2_RST_STREAM:\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03067)\n                          \"h2_session(%ld-%d): RST_STREAM by client, errror=%d\",\n                          session->id, (int)frame->hd.stream_id,\n                          (int)frame->rst_stream.error_code);\n            stream = get_stream(session, frame->hd.stream_id);\n            if (stream && stream->initiated_on) {\n                ++session->pushes_reset;\n            }\n            else {\n                ++session->streams_reset;\n            }\n            break;\n        case NGHTTP2_GOAWAY:\n            if (frame->goaway.error_code == 0 \n                && frame->goaway.last_stream_id == ((1u << 31) - 1)) {\n                /* shutdown notice. Should not come from a client... */\n                session->remote.accepting = 0;\n            }\n            else {\n                session->remote.accepted_max = frame->goaway.last_stream_id;\n                dispatch_event(session, H2_SESSION_EV_REMOTE_GOAWAY, \n                               frame->goaway.error_code, NULL);\n            }\n            break;\n        default:\n            if (APLOGctrace2(session->c)) {\n                char buffer[256];\n                \n                h2_util_frame_print(frame, buffer,\n                                    sizeof(buffer)/sizeof(buffer[0]));\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                              \"h2_session: on_frame_rcv %s\", buffer);\n            }\n            break;\n    }\n\n    if (status != APR_SUCCESS) {\n        int rv;\n        \n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c,\n                      APLOGNO(02923) \n                      \"h2_session: stream(%ld-%d): error handling frame\",\n                      session->id, (int)frame->hd.stream_id);\n        rv = nghttp2_submit_rst_stream(ng2s, NGHTTP2_FLAG_NONE,\n                                       frame->hd.stream_id,\n                                       NGHTTP2_INTERNAL_ERROR);\n        if (nghttp2_is_fatal(rv)) {\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n        }\n    }\n    \n    return 0;\n}\n\nstatic char immortal_zeros[H2_MAX_PADLEN];\n\nstatic int on_send_data_cb(nghttp2_session *ngh2, \n                           nghttp2_frame *frame, \n                           const uint8_t *framehd, \n                           size_t length, \n                           nghttp2_data_source *source, \n                           void *userp)\n{\n    apr_status_t status = APR_SUCCESS;\n    h2_session *session = (h2_session *)userp;\n    int stream_id = (int)frame->hd.stream_id;\n    unsigned char padlen;\n    int eos;\n    h2_stream *stream;\n    apr_bucket *b;\n    apr_off_t len = length;\n    \n    (void)ngh2;\n    (void)source;\n    if (frame->data.padlen > H2_MAX_PADLEN) {\n        return NGHTTP2_ERR_PROTO;\n    }\n    padlen = (unsigned char)frame->data.padlen;\n    \n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                  \"h2_stream(%ld-%d): send_data_cb for %ld bytes\",\n                  session->id, (int)stream_id, (long)length);\n                  \n    stream = get_stream(session, stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_NOTFOUND, session->c,\n                      APLOGNO(02924) \n                      \"h2_stream(%ld-%d): send_data, lookup stream\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    status = h2_conn_io_write(&session->io, (const char *)framehd, 9);\n    if (padlen && status == APR_SUCCESS) {\n        status = h2_conn_io_write(&session->io, (const char *)&padlen, 1);\n    }\n    \n    if (status != APR_SUCCESS) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2_stream(%ld-%d): writing frame header\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    status = h2_stream_read_to(stream, session->bbtmp, &len, &eos);\n    if (status != APR_SUCCESS) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2_stream(%ld-%d): send_data_cb, reading stream\",\n                      session->id, (int)stream_id);\n        apr_brigade_cleanup(session->bbtmp);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    else if (len != length) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2_stream(%ld-%d): send_data_cb, wanted %ld bytes, \"\n                      \"got %ld from stream\",\n                      session->id, (int)stream_id, (long)length, (long)len);\n        apr_brigade_cleanup(session->bbtmp);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    if (padlen) {\n        b = apr_bucket_immortal_create(immortal_zeros, padlen, \n                                       session->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(session->bbtmp, b);\n    }\n    \n    status = h2_conn_io_pass(&session->io, session->bbtmp);\n    apr_brigade_cleanup(session->bbtmp);\n    \n    if (status == APR_SUCCESS) {\n        stream->out_data_frames++;\n        stream->out_data_octets += length;\n        return 0;\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c,\n                      APLOGNO(02925) \n                      \"h2_stream(%ld-%d): failed send_data_cb\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n}\n\nstatic int on_frame_send_cb(nghttp2_session *ngh2, \n                            const nghttp2_frame *frame,\n                            void *user_data)\n{\n    h2_session *session = user_data;\n    if (APLOGcdebug(session->c)) {\n        char buffer[256];\n        \n        h2_util_frame_print(frame, buffer, sizeof(buffer)/sizeof(buffer[0]));\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03068)\n                      \"h2_session(%ld): sent FRAME[%s], frames=%ld/%ld (r/s)\",\n                      session->id, buffer, (long)session->frames_received,\n                     (long)session->frames_sent);\n    }\n    ++session->frames_sent;\n    return 0;\n}\n\n#ifdef H2_NG2_INVALID_HEADER_CB\nstatic int on_invalid_header_cb(nghttp2_session *ngh2, \n                                const nghttp2_frame *frame, \n                                const uint8_t *name, size_t namelen, \n                                const uint8_t *value, size_t valuelen, \n                                uint8_t flags, void *user_data)\n{\n    h2_session *session = user_data;\n    if (APLOGcdebug(session->c)) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03456)\n                      \"h2_session(%ld-%d): denying stream with invalid header \"\n                      \"'%s: %s'\", session->id, (int)frame->hd.stream_id,\n                      apr_pstrndup(session->pool, (const char *)name, namelen),\n                      apr_pstrndup(session->pool, (const char *)value, valuelen));\n    }\n    return nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE,\n                                     frame->hd.stream_id, \n                                     NGHTTP2_PROTOCOL_ERROR);\n}\n#endif\n\n#define NGH2_SET_CALLBACK(callbacks, name, fn)\\\nnghttp2_session_callbacks_set_##name##_callback(callbacks, fn)\n\nstatic apr_status_t init_callbacks(conn_rec *c, nghttp2_session_callbacks **pcb)\n{\n    int rv = nghttp2_session_callbacks_new(pcb);\n    if (rv != 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,\n                      APLOGNO(02926) \"nghttp2_session_callbacks_new: %s\",\n                      nghttp2_strerror(rv));\n        return APR_EGENERAL;\n    }\n    \n    NGH2_SET_CALLBACK(*pcb, send, send_cb);\n    NGH2_SET_CALLBACK(*pcb, on_frame_recv, on_frame_recv_cb);\n    NGH2_SET_CALLBACK(*pcb, on_invalid_frame_recv, on_invalid_frame_recv_cb);\n    NGH2_SET_CALLBACK(*pcb, on_data_chunk_recv, on_data_chunk_recv_cb);\n    NGH2_SET_CALLBACK(*pcb, on_stream_close, on_stream_close_cb);\n    NGH2_SET_CALLBACK(*pcb, on_begin_headers, on_begin_headers_cb);\n    NGH2_SET_CALLBACK(*pcb, on_header, on_header_cb);\n    NGH2_SET_CALLBACK(*pcb, send_data, on_send_data_cb);\n    NGH2_SET_CALLBACK(*pcb, on_frame_send, on_frame_send_cb);\n#ifdef H2_NG2_INVALID_HEADER_CB\n    NGH2_SET_CALLBACK(*pcb, on_invalid_header, on_invalid_header_cb);\n#endif\n    return APR_SUCCESS;\n}\n\nstatic void h2_session_destroy(h2_session *session)\n{\n    ap_assert(session);    \n\n    if (session->mplx) {\n        h2_mplx_set_consumed_cb(session->mplx, NULL, NULL);\n        h2_mplx_release_and_join(session->mplx, session->iowait);\n        session->mplx = NULL;\n    }\n\n    ap_remove_input_filter_byhandle((session->r? session->r->input_filters :\n                                     session->c->input_filters), \"H2_IN\");\n    if (session->ngh2) {\n        nghttp2_session_del(session->ngh2);\n        session->ngh2 = NULL;\n    }\n    if (session->c) {\n        h2_ctx_clear(session->c);\n    }\n\n    if (APLOGctrace1(session->c)) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                      \"h2_session(%ld): destroy\", session->id);\n    }\n    if (session->pool) {\n        apr_pool_destroy(session->pool);\n    }\n}\n\nstatic apr_status_t h2_session_shutdown_notice(h2_session *session)\n{\n    apr_status_t status;\n    \n    ap_assert(session);\n    if (!session->local.accepting) {\n        return APR_SUCCESS;\n    }\n    \n    nghttp2_submit_shutdown_notice(session->ngh2);\n    session->local.accepting = 0;\n    status = nghttp2_session_send(session->ngh2);\n    if (status == APR_SUCCESS) {\n        status = h2_conn_io_flush(&session->io);\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03457)\n                  \"session(%ld): sent shutdown notice\", session->id);\n    return status;\n}\n\nstatic apr_status_t h2_session_shutdown(h2_session *session, int error, \n                                        const char *msg, int force_close)\n{\n    apr_status_t status = APR_SUCCESS;\n    \n    ap_assert(session);\n    if (session->local.shutdown) {\n        return APR_SUCCESS;\n    }\n    if (!msg && error) {\n        msg = nghttp2_strerror(error);\n    }\n    \n    if (error || force_close) {\n        /* not a graceful shutdown, we want to leave... \n         * Do not start further streams that are waiting to be scheduled. \n         * Find out the max stream id that we habe been processed or\n         * are still actively working on.\n         * Remove all streams greater than this number without submitting\n         * a RST_STREAM frame, since that should be clear from the GOAWAY\n         * we send. */\n        session->local.accepted_max = h2_mplx_shutdown(session->mplx);\n        session->local.error = error;\n    }\n    else {\n        /* graceful shutdown. we will continue processing all streams\n         * we have, but no longer accept new ones. Report the max stream\n         * we have received and discard all new ones. */\n    }\n    nghttp2_submit_goaway(session->ngh2, NGHTTP2_FLAG_NONE, \n                          session->local.accepted_max, \n                          error, (uint8_t*)msg, msg? strlen(msg):0);\n    session->local.accepting = 0;\n    session->local.shutdown = 1;\n    status = nghttp2_session_send(session->ngh2);\n    if (status == APR_SUCCESS) {\n        status = h2_conn_io_flush(&session->io);\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03069)\n                  \"session(%ld): sent GOAWAY, err=%d, msg=%s\", \n                  session->id, error, msg? msg : \"\");\n    dispatch_event(session, H2_SESSION_EV_LOCAL_GOAWAY, error, msg);\n    \n    if (force_close) {\n        apr_brigade_cleanup(session->bbtmp);\n        h2_mplx_abort(session->mplx);\n    }\n    \n    return status;\n}\n\nstatic apr_status_t session_pool_cleanup(void *data)\n{\n    h2_session *session = data;\n    /* On a controlled connection shutdown, this gets never\n     * called as we deregister and destroy our pool manually.\n     * However when we have an async mpm, and handed it our idle\n     * connection, it will just cleanup once the connection is closed\n     * from the other side (and sometimes even from out side) and\n     * here we arrive then.\n     */\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                  \"session(%ld): pool_cleanup\", session->id);\n    \n    if (session->state != H2_SESSION_ST_DONE) {\n        /* Not good. The connection is being torn down and we have\n         * not sent a goaway. This is considered a protocol error and\n         * the client has to assume that any streams \"in flight\" may have\n         * been processed and are not safe to retry.\n         * As clients with idle connection may only learn about a closed\n         * connection when sending the next request, this has the effect\n         * that at least this one request will fail.\n         */\n        ap_log_cerror(APLOG_MARK, APLOG_WARNING, 0, session->c, APLOGNO(03199)\n                      \"session(%ld): connection disappeared without proper \"\n                      \"goodbye, clients will be confused, should not happen\", \n                      session->id);\n    }\n    /* keep us from destroying the pool, since that is already ongoing. */\n    session->pool = NULL;\n    h2_session_destroy(session);\n    return APR_SUCCESS;\n}\n\nstatic void *session_malloc(size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): malloc(%ld)\",\n                  session->id, (long)size);\n    return malloc(size);\n}\n\nstatic void session_free(void *p, void *ctx)\n{\n    h2_session *session = ctx;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): free()\",\n                  session->id);\n    free(p);\n}\n\nstatic void *session_calloc(size_t n, size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): calloc(%ld, %ld)\",\n                  session->id, (long)n, (long)size);\n    return calloc(n, size);\n}\n\nstatic void *session_realloc(void *p, size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): realloc(%ld)\",\n                  session->id, (long)size);\n    return realloc(p, size);\n}\n\nstatic h2_session *h2_session_create_int(conn_rec *c,\n                                         request_rec *r,\n                                         h2_ctx *ctx, \n                                         h2_workers *workers)\n{\n    nghttp2_session_callbacks *callbacks = NULL;\n    nghttp2_option *options = NULL;\n    uint32_t n;\n\n    apr_pool_t *pool = NULL;\n    apr_status_t status = apr_pool_create(&pool, c->pool);\n    h2_session *session;\n    if (status != APR_SUCCESS) {\n        return NULL;\n    }\n    apr_pool_tag(pool, \"h2_session\");\n\n    session = apr_pcalloc(pool, sizeof(h2_session));\n    if (session) {\n        int rv;\n        nghttp2_mem *mem;\n        \n        session->id = c->id;\n        session->c = c;\n        session->r = r;\n        session->s = h2_ctx_server_get(ctx);\n        session->pool = pool;\n        session->config = h2_config_sget(session->s);\n        session->workers = workers;\n        \n        session->state = H2_SESSION_ST_INIT;\n        session->local.accepting = 1;\n        session->remote.accepting = 1;\n        \n        apr_pool_pre_cleanup_register(pool, session, session_pool_cleanup);\n        \n        session->max_stream_count = h2_config_geti(session->config, \n                                                   H2_CONF_MAX_STREAMS);\n        session->max_stream_mem = h2_config_geti(session->config, \n                                                 H2_CONF_STREAM_MAX_MEM);\n\n        status = apr_thread_cond_create(&session->iowait, session->pool);\n        if (status != APR_SUCCESS) {\n            return NULL;\n        }\n        \n        session->mplx = h2_mplx_create(c, session->pool, session->config, \n                                       session->s->timeout, workers);\n        \n        h2_mplx_set_consumed_cb(session->mplx, update_window, session);\n        \n        /* Install the connection input filter that feeds the session */\n        session->cin = h2_filter_cin_create(session->pool, \n                                            h2_session_receive, session);\n        ap_add_input_filter(\"H2_IN\", session->cin, r, c);\n\n        h2_conn_io_init(&session->io, c, session->config);\n        session->bbtmp = apr_brigade_create(session->pool, c->bucket_alloc);\n        \n        status = init_callbacks(c, &callbacks);\n        if (status != APR_SUCCESS) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, c, APLOGNO(02927) \n                          \"nghttp2: error in init_callbacks\");\n            h2_session_destroy(session);\n            return NULL;\n        }\n        \n        rv = nghttp2_option_new(&options);\n        if (rv != 0) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, c,\n                          APLOGNO(02928) \"nghttp2_option_new: %s\", \n                          nghttp2_strerror(rv));\n            h2_session_destroy(session);\n            return NULL;\n        }\n        nghttp2_option_set_peer_max_concurrent_streams(\n            options, (uint32_t)session->max_stream_count);\n        /* We need to handle window updates ourself, otherwise we\n         * get flooded by nghttp2. */\n        nghttp2_option_set_no_auto_window_update(options, 1);\n        \n        if (APLOGctrace6(c)) {\n            mem = apr_pcalloc(session->pool, sizeof(nghttp2_mem));\n            mem->mem_user_data = session;\n            mem->malloc    = session_malloc;\n            mem->free      = session_free;\n            mem->calloc    = session_calloc;\n            mem->realloc   = session_realloc;\n            \n            rv = nghttp2_session_server_new3(&session->ngh2, callbacks,\n                                             session, options, mem);\n        }\n        else {\n            rv = nghttp2_session_server_new2(&session->ngh2, callbacks,\n                                             session, options);\n        }\n        nghttp2_session_callbacks_del(callbacks);\n        nghttp2_option_del(options);\n        \n        if (rv != 0) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, c,\n                          APLOGNO(02929) \"nghttp2_session_server_new: %s\",\n                          nghttp2_strerror(rv));\n            h2_session_destroy(session);\n            return NULL;\n        }\n         \n        n = h2_config_geti(session->config, H2_CONF_PUSH_DIARY_SIZE);\n        session->push_diary = h2_push_diary_create(session->pool, n);\n        \n        if (APLOGcdebug(c)) {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03200)\n                          \"h2_session(%ld) created, max_streams=%d, \"\n                          \"stream_mem=%d, workers_limit=%d, workers_max=%d, \"\n                          \"push_diary(type=%d,N=%d)\",\n                          session->id, (int)session->max_stream_count, \n                          (int)session->max_stream_mem,\n                          session->mplx->workers_limit, \n                          session->mplx->workers_max, \n                          session->push_diary->dtype, \n                          (int)session->push_diary->N);\n        }\n    }\n    return session;\n}\n\nh2_session *h2_session_create(conn_rec *c, h2_ctx *ctx, h2_workers *workers)\n{\n    return h2_session_create_int(c, NULL, ctx, workers);\n}\n\nh2_session *h2_session_rcreate(request_rec *r, h2_ctx *ctx, h2_workers *workers)\n{\n    return h2_session_create_int(r->connection, r, ctx, workers);\n}\n\nvoid h2_session_eoc_callback(h2_session *session)\n{\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                  \"session(%ld): cleanup and destroy\", session->id);\n    apr_pool_cleanup_kill(session->pool, session, session_pool_cleanup);\n    h2_session_destroy(session);\n}\n\nstatic apr_status_t h2_session_start(h2_session *session, int *rv)\n{\n    apr_status_t status = APR_SUCCESS;\n    nghttp2_settings_entry settings[3];\n    size_t slen;\n    int win_size;\n    \n    ap_assert(session);\n    /* Start the conversation by submitting our SETTINGS frame */\n    *rv = 0;\n    if (session->r) {\n        const char *s, *cs;\n        apr_size_t dlen; \n        h2_stream * stream;\n\n        /* 'h2c' mode: we should have a 'HTTP2-Settings' header with\n         * base64 encoded client settings. */\n        s = apr_table_get(session->r->headers_in, \"HTTP2-Settings\");\n        if (!s) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, session->r,\n                          APLOGNO(02931) \n                          \"HTTP2-Settings header missing in request\");\n            return APR_EINVAL;\n        }\n        cs = NULL;\n        dlen = h2_util_base64url_decode(&cs, s, session->pool);\n        \n        if (APLOGrdebug(session->r)) {\n            char buffer[128];\n            h2_util_hex_dump(buffer, 128, (char*)cs, dlen);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, session->r, APLOGNO(03070)\n                          \"upgrading h2c session with HTTP2-Settings: %s -> %s (%d)\",\n                          s, buffer, (int)dlen);\n        }\n        \n        *rv = nghttp2_session_upgrade(session->ngh2, (uint8_t*)cs, dlen, NULL);\n        if (*rv != 0) {\n            status = APR_EINVAL;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, session->r,\n                          APLOGNO(02932) \"nghttp2_session_upgrade: %s\", \n                          nghttp2_strerror(*rv));\n            return status;\n        }\n        \n        /* Now we need to auto-open stream 1 for the request we got. */\n        stream = h2_session_open_stream(session, 1, 0, NULL);\n        if (!stream) {\n            status = APR_EGENERAL;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, session->r,\n                          APLOGNO(02933) \"open stream 1: %s\", \n                          nghttp2_strerror(*rv));\n            return status;\n        }\n        \n        status = h2_stream_set_request_rec(stream, session->r);\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n        status = stream_schedule(session, stream, 1);\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n    }\n\n    slen = 0;\n    settings[slen].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n    settings[slen].value = (uint32_t)session->max_stream_count;\n    ++slen;\n    win_size = h2_config_geti(session->config, H2_CONF_WIN_SIZE);\n    if (win_size != H2_INITIAL_WINDOW_SIZE) {\n        settings[slen].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n        settings[slen].value = win_size;\n        ++slen;\n    }\n    \n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c, APLOGNO(03201)\n                  \"h2_session(%ld): start, INITIAL_WINDOW_SIZE=%ld, \"\n                  \"MAX_CONCURRENT_STREAMS=%d\", \n                  session->id, (long)win_size, (int)session->max_stream_count);\n    *rv = nghttp2_submit_settings(session->ngh2, NGHTTP2_FLAG_NONE,\n                                  settings, slen);\n    if (*rv != 0) {\n        status = APR_EGENERAL;\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                      APLOGNO(02935) \"nghttp2_submit_settings: %s\", \n                      nghttp2_strerror(*rv));\n    }\n    else {\n        /* use maximum possible value for connection window size. We are only\n         * interested in per stream flow control. which have the initial window\n         * size configured above.\n         * Therefore, for our use, the connection window can only get in the\n         * way. Example: if we allow 100 streams with a 32KB window each, we\n         * buffer up to 3.2 MB of data. Unless we do separate connection window\n         * interim updates, any smaller connection window will lead to blocking\n         * in DATA flow.\n         */\n        *rv = nghttp2_submit_window_update(session->ngh2, NGHTTP2_FLAG_NONE,\n                                           0, NGHTTP2_MAX_WINDOW_SIZE - win_size);\n        if (*rv != 0) {\n            status = APR_EGENERAL;\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                          APLOGNO(02970) \"nghttp2_submit_window_update: %s\", \n                          nghttp2_strerror(*rv));        \n        }\n    }\n    \n    return status;\n}\n\nstatic apr_status_t on_stream_headers(h2_session *session, h2_stream *stream,  \n                                      h2_headers *headers, apr_off_t len,\n                                      int eos);\n\nstatic ssize_t stream_data_cb(nghttp2_session *ng2s,\n                              int32_t stream_id,\n                              uint8_t *buf,\n                              size_t length,\n                              uint32_t *data_flags,\n                              nghttp2_data_source *source,\n                              void *puser)\n{\n    h2_session *session = (h2_session *)puser;\n    apr_off_t nread = length;\n    int eos = 0;\n    apr_status_t status;\n    h2_stream *stream;\n    ap_assert(session);\n    \n    /* The session wants to send more DATA for the stream. We need\n     * to find out how much of the requested length we can send without\n     * blocking.\n     * Indicate EOS when we encounter it or DEFERRED if the stream\n     * should be suspended. Beware of trailers.\n     */\n \n    (void)ng2s;\n    (void)buf;\n    (void)source;\n    stream = get_stream(session, stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, session->c,\n                      APLOGNO(02937) \n                      \"h2_stream(%ld-%d): data requested but stream not found\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n\n    status = h2_stream_out_prepare(stream, &nread, &eos, NULL);\n    if (nread) {\n        *data_flags |=  NGHTTP2_DATA_FLAG_NO_COPY;\n    }\n    \n    switch (status) {\n        case APR_SUCCESS:\n            break;\n            \n        case APR_ECONNRESET:\n            return nghttp2_submit_rst_stream(ng2s, NGHTTP2_FLAG_NONE,\n                stream->id, stream->rst_error);\n            \n        case APR_EAGAIN:\n            /* If there is no data available, our session will automatically\n             * suspend this stream and not ask for more data until we resume\n             * it. Remember at our h2_stream that we need to do this.\n             */\n            nread = 0;\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03071)\n                          \"h2_stream(%ld-%d): suspending\",\n                          session->id, (int)stream_id);\n            return NGHTTP2_ERR_DEFERRED;\n            \n        default:\n            nread = 0;\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                          APLOGNO(02938) \"h2_stream(%ld-%d): reading data\",\n                          session->id, (int)stream_id);\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    if (eos) {\n        *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n    }\n    return (ssize_t)nread;\n}\n\nstruct h2_stream *h2_session_push(h2_session *session, h2_stream *is,\n                                  h2_push *push)\n{\n    apr_status_t status;\n    h2_stream *stream;\n    h2_ngheader *ngh;\n    int nid;\n    \n    ngh = h2_util_ngheader_make_req(is->pool, push->req);\n    nid = nghttp2_submit_push_promise(session->ngh2, 0, is->id, \n                                      ngh->nv, ngh->nvlen, NULL);\n    if (nid <= 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03075)\n                      \"h2_stream(%ld-%d): submitting push promise fail: %s\",\n                      session->id, is->id, nghttp2_strerror(nid));\n        return NULL;\n    }\n    ++session->pushes_promised;\n    \n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03076)\n                  \"h2_stream(%ld-%d): SERVER_PUSH %d for %s %s on %d\",\n                  session->id, is->id, nid,\n                  push->req->method, push->req->path, is->id);\n                  \n    stream = h2_session_open_stream(session, nid, is->id, push->req);\n    if (stream) {\n        h2_session_set_prio(session, stream, push->priority);\n        status = stream_schedule(session, stream, 1);\n        if (status != APR_SUCCESS) {\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                          \"h2_stream(%ld-%d): scheduling push stream\",\n                          session->id, stream->id);\n            stream = NULL;\n        }\n        ++session->unsent_promises;\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03077)\n                      \"h2_stream(%ld-%d): failed to create stream obj %d\",\n                      session->id, is->id, nid);\n    }\n\n    if (!stream) {\n        /* try to tell the client that it should not wait. */\n        nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE, nid,\n                                  NGHTTP2_INTERNAL_ERROR);\n    }\n    \n    return stream;\n}\n\nstatic int valid_weight(float f) \n{\n    int w = (int)f;\n    return (w < NGHTTP2_MIN_WEIGHT? NGHTTP2_MIN_WEIGHT : \n            (w > NGHTTP2_MAX_WEIGHT)? NGHTTP2_MAX_WEIGHT : w);\n}\n\napr_status_t h2_session_set_prio(h2_session *session, h2_stream *stream, \n                                 const h2_priority *prio)\n{\n    apr_status_t status = APR_SUCCESS;\n#ifdef H2_NG2_CHANGE_PRIO\n    nghttp2_stream *s_grandpa, *s_parent, *s;\n    \n    if (prio == NULL) {\n        /* we treat this as a NOP */\n        return APR_SUCCESS;\n    }\n    s = nghttp2_session_find_stream(session->ngh2, stream->id);\n    if (!s) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                      \"h2_stream(%ld-%d): lookup of nghttp2_stream failed\",\n                      session->id, stream->id);\n        return APR_EINVAL;\n    }\n    \n    s_parent = nghttp2_stream_get_parent(s);\n    if (s_parent) {\n        nghttp2_priority_spec ps;\n        int id_parent, id_grandpa, w_parent, w;\n        int rv = 0;\n        const char *ptype = \"AFTER\";\n        h2_dependency dep = prio->dependency;\n        \n        id_parent = nghttp2_stream_get_stream_id(s_parent);\n        s_grandpa = nghttp2_stream_get_parent(s_parent);\n        if (s_grandpa) {\n            id_grandpa = nghttp2_stream_get_stream_id(s_grandpa);\n        }\n        else {\n            /* parent of parent does not exist, \n             * only possible if parent == root */\n            dep = H2_DEPENDANT_AFTER;\n        }\n        \n        switch (dep) {\n            case H2_DEPENDANT_INTERLEAVED:\n                /* PUSHed stream is to be interleaved with initiating stream.\n                 * It is made a sibling of the initiating stream and gets a\n                 * proportional weight [1, MAX_WEIGHT] of the initiaing\n                 * stream weight.\n                 */\n                ptype = \"INTERLEAVED\";\n                w_parent = nghttp2_stream_get_weight(s_parent);\n                w = valid_weight(w_parent * ((float)prio->weight / NGHTTP2_MAX_WEIGHT));\n                nghttp2_priority_spec_init(&ps, id_grandpa, w, 0);\n                break;\n                \n            case H2_DEPENDANT_BEFORE:\n                /* PUSHed stream os to be sent BEFORE the initiating stream.\n                 * It gets the same weight as the initiating stream, replaces\n                 * that stream in the dependency tree and has the initiating\n                 * stream as child.\n                 */\n                ptype = \"BEFORE\";\n                w = w_parent = nghttp2_stream_get_weight(s_parent);\n                nghttp2_priority_spec_init(&ps, stream->id, w_parent, 0);\n                id_grandpa = nghttp2_stream_get_stream_id(s_grandpa);\n                rv = nghttp2_session_change_stream_priority(session->ngh2, id_parent, &ps);\n                if (rv < 0) {\n                    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03202)\n                                  \"h2_stream(%ld-%d): PUSH BEFORE, weight=%d, \"\n                                  \"depends=%d, returned=%d\",\n                                  session->id, id_parent, ps.weight, ps.stream_id, rv);\n                    return APR_EGENERAL;\n                }\n                nghttp2_priority_spec_init(&ps, id_grandpa, w, 0);\n                break;\n                \n            case H2_DEPENDANT_AFTER:\n                /* The PUSHed stream is to be sent after the initiating stream.\n                 * Give if the specified weight and let it depend on the intiating\n                 * stream.\n                 */\n                /* fall through, it's the default */\n            default:\n                nghttp2_priority_spec_init(&ps, id_parent, valid_weight(prio->weight), 0);\n                break;\n        }\n\n\n        rv = nghttp2_session_change_stream_priority(session->ngh2, stream->id, &ps);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03203)\n                      \"h2_stream(%ld-%d): PUSH %s, weight=%d, \"\n                      \"depends=%d, returned=%d\",\n                      session->id, stream->id, ptype, \n                      ps.weight, ps.stream_id, rv);\n        status = (rv < 0)? APR_EGENERAL : APR_SUCCESS;\n    }\n#else\n    (void)session;\n    (void)stream;\n    (void)prio;\n    (void)valid_weight;\n#endif\n    return status;\n}\n\nint h2_session_push_enabled(h2_session *session)\n{\n    /* iff we can and they can and want */\n    return (session->remote.accepting /* remote GOAWAY received */\n            && h2_config_geti(session->config, H2_CONF_PUSH)\n            && nghttp2_session_get_remote_settings(session->ngh2, \n                   NGHTTP2_SETTINGS_ENABLE_PUSH));\n}\n\nstatic apr_status_t h2_session_send(h2_session *session)\n{\n    apr_interval_time_t saved_timeout;\n    int rv;\n    apr_socket_t *socket;\n    \n    socket = ap_get_conn_socket(session->c);\n    if (socket) {\n        apr_socket_timeout_get(socket, &saved_timeout);\n        apr_socket_timeout_set(socket, session->s->timeout);\n    }\n    \n    rv = nghttp2_session_send(session->ngh2);\n    \n    if (socket) {\n        apr_socket_timeout_set(socket, saved_timeout);\n    }\n    session->have_written = 1;\n    if (rv != 0) {\n        if (nghttp2_is_fatal(rv)) {\n            dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, rv, nghttp2_strerror(rv));\n            return APR_EGENERAL;\n        }\n    }\n    \n    session->unsent_promises = 0;\n    session->unsent_submits = 0;\n    \n    return APR_SUCCESS;\n}\n\n/**\n * headers for the stream are ready.\n */\nstatic apr_status_t on_stream_headers(h2_session *session, h2_stream *stream,  \n                                      h2_headers *headers, apr_off_t len,\n                                      int eos)\n{\n    apr_status_t status = APR_SUCCESS;\n    int rv = 0;\n\n    ap_assert(session);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c, \n                  \"h2_stream(%ld-%d): on_headers\", session->id, stream->id);\n    if (headers->status < 100) {\n        int err = H2_STREAM_RST(stream, headers->status);\n        rv = nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE,\n                                       stream->id, err);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, \n                  \"h2_stream(%ld-%d): unpexected header status %d, stream rst\", \n                  session->id, stream->id, headers->status);\n        goto leave;\n    }\n    else if (stream->has_response) {\n        h2_ngheader *nh;\n        \n        nh = h2_util_ngheader_make(stream->pool, headers->headers);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03072)\n                      \"h2_stream(%ld-%d): submit %d trailers\",\n                      session->id, (int)stream->id,(int) nh->nvlen);\n        rv = nghttp2_submit_trailer(session->ngh2, stream->id, nh->nv, nh->nvlen);\n        goto leave;\n    }\n    else {\n        nghttp2_data_provider provider, *pprovider = NULL;\n        h2_ngheader *ngh;\n        apr_table_t *hout;\n        const char *note;\n        \n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03073)\n                      \"h2_stream(%ld-%d): submit response %d, REMOTE_WINDOW_SIZE=%u\",\n                      session->id, stream->id, headers->status,\n                      (unsigned int)nghttp2_session_get_stream_remote_window_size(session->ngh2, stream->id));\n        \n        if (!eos || len > 0) {\n            memset(&provider, 0, sizeof(provider));\n            provider.source.fd = stream->id;\n            provider.read_callback = stream_data_cb;\n            pprovider = &provider;\n        }\n        \n        /* If this stream is not a pushed one itself,\n         * and HTTP/2 server push is enabled here,\n         * and the response HTTP status is not sth >= 400,\n         * and the remote side has pushing enabled,\n         * -> find and perform any pushes on this stream\n         *    *before* we submit the stream response itself.\n         *    This helps clients avoid opening new streams on Link\n         *    headers that get pushed right afterwards.\n         * \n         * *) the response code is relevant, as we do not want to \n         *    make pushes on 401 or 403 codes and friends. \n         *    And if we see a 304, we do not push either\n         *    as the client, having this resource in its cache, might\n         *    also have the pushed ones as well.\n         */\n        if (!stream->initiated_on\n            && !stream->has_response\n            && stream->request && stream->request->method\n            && !strcmp(\"GET\", stream->request->method)\n            && (headers->status < 400)\n            && (headers->status != 304)\n            && h2_session_push_enabled(session)) {\n            \n            h2_stream_submit_pushes(stream, headers);\n        }\n        \n        if (!stream->pref_priority) {\n            stream->pref_priority = h2_stream_get_priority(stream, headers);\n        }\n        h2_session_set_prio(session, stream, stream->pref_priority);\n        \n        hout = headers->headers;\n        note = apr_table_get(headers->notes, H2_FILTER_DEBUG_NOTE);\n        if (note && !strcmp(\"on\", note)) {\n            int32_t connFlowIn, connFlowOut;\n\n            connFlowIn = nghttp2_session_get_effective_local_window_size(session->ngh2); \n            connFlowOut = nghttp2_session_get_remote_window_size(session->ngh2);\n            hout = apr_table_clone(stream->pool, hout);\n            apr_table_setn(hout, \"conn-flow-in\", \n                           apr_itoa(stream->pool, connFlowIn));\n            apr_table_setn(hout, \"conn-flow-out\", \n                           apr_itoa(stream->pool, connFlowOut));\n        }\n        \n        if (headers->status == 103 \n            && !h2_config_geti(session->config, H2_CONF_EARLY_HINTS)) {\n            /* suppress sending this to the client, it might have triggered \n             * pushes and served its purpose nevertheless */\n            rv = 0;\n            goto leave;\n        }\n        \n        ngh = h2_util_ngheader_make_res(stream->pool, headers->status, hout);\n        rv = nghttp2_submit_response(session->ngh2, stream->id,\n                                     ngh->nv, ngh->nvlen, pprovider);\n        stream->has_response = h2_headers_are_response(headers);\n        session->have_written = 1;\n        \n        if (stream->initiated_on) {\n            ++session->pushes_submitted;\n        }\n        else {\n            ++session->responses_submitted;\n        }\n    }\n    \nleave:\n    if (nghttp2_is_fatal(rv)) {\n        status = APR_EGENERAL;\n        dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, rv, nghttp2_strerror(rv));\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                      APLOGNO(02940) \"submit_response: %s\", \n                      nghttp2_strerror(rv));\n    }\n    \n    ++session->unsent_submits;\n    \n    /* Unsent push promises are written immediately, as nghttp2\n     * 1.5.0 realizes internal stream data structures only on \n     * send and we might need them for other submits. \n     * Also, to conserve memory, we send at least every 10 submits\n     * so that nghttp2 does not buffer all outbound items too \n     * long.\n     */\n    if (status == APR_SUCCESS \n        && (session->unsent_promises || session->unsent_submits > 10)) {\n        status = h2_session_send(session);\n    }\n    return status;\n}\n\n/**\n * A stream was resumed as new response/output data arrived.\n */\nstatic apr_status_t on_stream_resume(void *ctx, h2_stream *stream)\n{\n    h2_session *session = ctx;\n    apr_status_t status = APR_EAGAIN;\n    int rv;\n    apr_off_t len = 0;\n    int eos = 0;\n    h2_headers *headers;\n    \n    ap_assert(stream);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c, \n                  \"h2_stream(%ld-%d): on_resume\", session->id, stream->id);\n        \nsend_headers:\n    headers = NULL;\n    status = h2_stream_out_prepare(stream, &len, &eos, &headers);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, session->c, \n                  \"h2_stream(%ld-%d): prepared len=%ld, eos=%d\", \n                  session->id, stream->id, (long)len, eos);\n    if (headers) {\n        status = on_stream_headers(session, stream, headers, len, eos);\n        if (status != APR_SUCCESS || stream->rst_error) {\n            return status;\n        }\n        goto send_headers;\n    }\n    else if (status != APR_EAGAIN) {\n        if (!stream->has_response) {\n            int err = H2_STREAM_RST(stream, H2_ERR_PROTOCOL_ERROR);\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03466)\n                          \"h2_stream(%ld-%d): no response, RST_STREAM, err=%d\",\n                          session->id, stream->id, err);\n            nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE,\n                                      stream->id, err);\n            return APR_SUCCESS;\n        } \n        rv = nghttp2_session_resume_data(session->ngh2, stream->id);\n        session->have_written = 1;\n        ap_log_cerror(APLOG_MARK, nghttp2_is_fatal(rv)?\n                      APLOG_ERR : APLOG_DEBUG, 0, session->c,\n                      APLOGNO(02936) \n                      \"h2_stream(%ld-%d): resuming %s\",\n                      session->id, stream->id, rv? nghttp2_strerror(rv) : \"\");\n    }\n    return status;\n}\n\nstatic apr_status_t h2_session_receive(void *ctx, const char *data, \n                                       apr_size_t len, apr_size_t *readlen)\n{\n    h2_session *session = ctx;\n    ssize_t n;\n    \n    if (len > 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                      \"h2_session(%ld): feeding %ld bytes to nghttp2\",\n                      session->id, (long)len);\n        n = nghttp2_session_mem_recv(session->ngh2, (const uint8_t *)data, len);\n        if (n < 0) {\n            if (nghttp2_is_fatal((int)n)) {\n                dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, (int)n, nghttp2_strerror((int)n));\n                return APR_EGENERAL;\n            }\n        }\n        else {\n            *readlen = n;\n            session->io.bytes_read += n;\n        }\n    }\n    return APR_SUCCESS;\n}\n\nstatic apr_status_t h2_session_read(h2_session *session, int block)\n{\n    apr_status_t status, rstatus = APR_EAGAIN;\n    conn_rec *c = session->c;\n    apr_off_t read_start = session->io.bytes_read;\n    \n    while (1) {\n        /* H2_IN filter handles all incoming data against the session.\n         * We just pull at the filter chain to make it happen */\n        status = ap_get_brigade(c->input_filters,\n                                session->bbtmp, AP_MODE_READBYTES,\n                                block? APR_BLOCK_READ : APR_NONBLOCK_READ,\n                                APR_BUCKET_BUFF_SIZE);\n        /* get rid of any possible data we do not expect to get */\n        apr_brigade_cleanup(session->bbtmp); \n\n        switch (status) {\n            case APR_SUCCESS:\n                /* successful read, reset our idle timers */\n                rstatus = APR_SUCCESS;\n                if (block) {\n                    /* successful blocked read, try unblocked to\n                     * get more. */\n                    block = 0;\n                }\n                break;\n            case APR_EAGAIN:\n                return rstatus;\n            case APR_TIMEUP:\n                return status;\n            default:\n                if (session->io.bytes_read == read_start) {\n                    /* first attempt failed */\n                    if (APR_STATUS_IS_ETIMEDOUT(status)\n                        || APR_STATUS_IS_ECONNABORTED(status)\n                        || APR_STATUS_IS_ECONNRESET(status)\n                        || APR_STATUS_IS_EOF(status)\n                        || APR_STATUS_IS_EBADF(status)) {\n                        /* common status for a client that has left */\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE1, status, c,\n                                      \"h2_session(%ld): input gone\", session->id);\n                    }\n                    else {\n                        /* uncommon status, log on INFO so that we see this */\n                        ap_log_cerror( APLOG_MARK, APLOG_DEBUG, status, c,\n                                      APLOGNO(02950) \n                                      \"h2_session(%ld): error reading, terminating\",\n                                      session->id);\n                    }\n                    return status;\n                }\n                /* subsequent failure after success(es), return initial\n                 * status. */\n                return rstatus;\n        }\n        if ((session->io.bytes_read - read_start) > (64*1024)) {\n            /* read enough in one go, give write a chance */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, c,\n                          \"h2_session(%ld): read 64k, returning\", session->id);\n            break;\n        }\n    }\n    return rstatus;\n}\n\nstatic const char *StateNames[] = {\n    \"INIT\",      /* H2_SESSION_ST_INIT */\n    \"DONE\",      /* H2_SESSION_ST_DONE */\n    \"IDLE\",      /* H2_SESSION_ST_IDLE */\n    \"BUSY\",      /* H2_SESSION_ST_BUSY */\n    \"WAIT\",      /* H2_SESSION_ST_WAIT */\n};\n\nstatic const char *state_name(h2_session_state state)\n{\n    if (state >= (sizeof(StateNames)/sizeof(StateNames[0]))) {\n        return \"unknown\";\n    }\n    return StateNames[state];\n}\n\nstatic void update_child_status(h2_session *session, int status, const char *msg)\n{\n    /* Assume that we also change code/msg when something really happened and\n     * avoid updating the scoreboard in between */\n    if (session->last_status_code != status \n        || session->last_status_msg != msg) {\n        apr_snprintf(session->status, sizeof(session->status),\n                     \"%s, streams: %d/%d/%d/%d/%d (open/recv/resp/push/rst)\", \n                     msg? msg : \"-\",\n                     (int)session->open_streams, \n                     (int)session->remote.emitted_count,\n                     (int)session->responses_submitted,\n                     (int)session->pushes_submitted,\n                     (int)session->pushes_reset + session->streams_reset);\n        ap_update_child_status_descr(session->c->sbh, status, session->status);\n    }\n}\n\nstatic void transit(h2_session *session, const char *action, h2_session_state nstate)\n{\n    if (session->state != nstate) {\n        int loglvl = APLOG_DEBUG;\n        if ((session->state == H2_SESSION_ST_BUSY && nstate == H2_SESSION_ST_WAIT)\n            || (session->state == H2_SESSION_ST_WAIT && nstate == H2_SESSION_ST_BUSY)){\n            loglvl = APLOG_TRACE1;\n        }\n        ap_log_cerror(APLOG_MARK, loglvl, 0, session->c, APLOGNO(03078)\n                      \"h2_session(%ld): transit [%s] -- %s --> [%s]\", session->id,\n                      state_name(session->state), action, state_name(nstate));\n        session->state = nstate;\n        switch (session->state) {\n            case H2_SESSION_ST_IDLE:\n                update_child_status(session, (session->open_streams == 0? \n                                              SERVER_BUSY_KEEPALIVE\n                                              : SERVER_BUSY_READ), \"idle\");\n                break;\n            case H2_SESSION_ST_DONE:\n                update_child_status(session, SERVER_CLOSING, \"done\");\n                break;\n            default:\n                /* nop */\n                break;\n        }\n    }\n}\n\nstatic void h2_session_ev_init(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_INIT:\n            transit(session, \"init\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_local_goaway(h2_session *session, int arg, const char *msg)\n{\n    cleanup_streams(session);\n    if (!session->remote.shutdown) {\n        update_child_status(session, SERVER_CLOSING, \"local goaway\");\n    }\n    transit(session, \"local goaway\", H2_SESSION_ST_DONE);\n}\n\nstatic void h2_session_ev_remote_goaway(h2_session *session, int arg, const char *msg)\n{\n    if (!session->remote.shutdown) {\n        session->remote.error = arg;\n        session->remote.accepting = 0;\n        session->remote.shutdown = 1;\n        cleanup_streams(session);\n        update_child_status(session, SERVER_CLOSING, \"remote goaway\");\n        transit(session, \"remote goaway\", H2_SESSION_ST_DONE);\n    }\n}\n\nstatic void h2_session_ev_conn_error(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_INIT:\n        case H2_SESSION_ST_DONE:\n            /* just leave */\n            transit(session, \"conn error\", H2_SESSION_ST_DONE);\n            break;\n        \n        default:\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03401)\n                          \"h2_session(%ld): conn error -> shutdown\", session->id);\n            h2_session_shutdown(session, arg, msg, 0);\n            break;\n    }\n}\n\nstatic void h2_session_ev_proto_error(h2_session *session, int arg, const char *msg)\n{\n    if (!session->local.shutdown) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03402)\n                      \"h2_session(%ld): proto error -> shutdown\", session->id);\n        h2_session_shutdown(session, arg, msg, 0);\n    }\n}\n\nstatic void h2_session_ev_conn_timeout(h2_session *session, int arg, const char *msg)\n{\n    transit(session, msg, H2_SESSION_ST_DONE);\n    if (!session->local.shutdown) {\n        h2_session_shutdown(session, arg, msg, 1);\n    }\n}\n\nstatic void h2_session_ev_no_io(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_BUSY:\n            /* Nothing to READ, nothing to WRITE on the master connection.\n             * Possible causes:\n             * - we wait for the client to send us sth\n             * - we wait for started tasks to produce output\n             * - we have finished all streams and the client has sent GO_AWAY\n             */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session(%ld): NO_IO event, %d streams open\", \n                          session->id, session->open_streams);\n            h2_conn_io_flush(&session->io);\n            if (session->open_streams > 0) {\n                if (h2_mplx_awaits_data(session->mplx)) {\n                    /* waiting for at least one stream to produce data */\n                    transit(session, \"no io\", H2_SESSION_ST_WAIT);\n                }\n                else {\n                    /* we have streams open, and all are submitted and none\n                     * is suspended. The only thing keeping us from WRITEing\n                     * more must be the flow control.\n                     * This means we only wait for WINDOW_UPDATE from the \n                     * client and can block on READ. */\n                    transit(session, \"no io (flow wait)\", H2_SESSION_ST_IDLE);\n                    session->idle_until = apr_time_now() + session->s->timeout;\n                    session->keep_sync_until = session->idle_until;\n                    /* Make sure we have flushed all previously written output\n                     * so that the client will react. */\n                    if (h2_conn_io_flush(&session->io) != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                        return;\n                    }\n                }\n            }\n            else if (session->local.accepting) {\n                /* When we have no streams, but accept new, switch to idle */\n                apr_time_t now = apr_time_now();\n                transit(session, \"no io (keepalive)\", H2_SESSION_ST_IDLE);\n                session->idle_until = (session->remote.emitted_count? \n                                       session->s->keep_alive_timeout : \n                                       session->s->timeout) + now;\n                session->keep_sync_until = now + apr_time_from_sec(1);\n            }\n            else {\n                /* We are no longer accepting new streams and there are\n                 * none left. Time to leave. */\n                h2_session_shutdown(session, arg, msg, 0);\n                transit(session, \"no io\", H2_SESSION_ST_DONE);\n            }\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_stream_ready(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_WAIT:\n            transit(session, \"stream ready\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_data_read(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n        case H2_SESSION_ST_WAIT:\n            transit(session, \"data read\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_ngh2_done(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_DONE:\n            /* nop */\n            break;\n        default:\n            transit(session, \"nghttp2 done\", H2_SESSION_ST_DONE);\n            break;\n    }\n}\n\nstatic void h2_session_ev_mpm_stopping(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_DONE:\n            /* nop */\n            break;\n        default:\n            h2_session_shutdown_notice(session);\n            break;\n    }\n}\n\nstatic void h2_session_ev_pre_close(h2_session *session, int arg, const char *msg)\n{\n    h2_session_shutdown(session, arg, msg, 1);\n}\n\nstatic void h2_session_ev_stream_open(h2_session *session, int arg, const char *msg)\n{\n    ++session->open_streams;\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n            if (session->open_streams == 1) {\n                /* enter tiomeout, since we have a stream again */\n                session->idle_until = (session->s->timeout + apr_time_now());\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nstatic void h2_session_ev_stream_done(h2_session *session, int arg, const char *msg)\n{\n    --session->open_streams;\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n            if (session->open_streams == 0) {\n                /* enter keepalive timeout, since we no longer have streams */\n                session->idle_until = (session->s->keep_alive_timeout\n                                       + apr_time_now());\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nstatic void dispatch_event(h2_session *session, h2_session_event_t ev, \n                      int arg, const char *msg)\n{\n    switch (ev) {\n        case H2_SESSION_EV_INIT:\n            h2_session_ev_init(session, arg, msg);\n            break;            \n        case H2_SESSION_EV_LOCAL_GOAWAY:\n            h2_session_ev_local_goaway(session, arg, msg);\n            break;\n        case H2_SESSION_EV_REMOTE_GOAWAY:\n            h2_session_ev_remote_goaway(session, arg, msg);\n            break;\n        case H2_SESSION_EV_CONN_ERROR:\n            h2_session_ev_conn_error(session, arg, msg);\n            break;\n        case H2_SESSION_EV_PROTO_ERROR:\n            h2_session_ev_proto_error(session, arg, msg);\n            break;\n        case H2_SESSION_EV_CONN_TIMEOUT:\n            h2_session_ev_conn_timeout(session, arg, msg);\n            break;\n        case H2_SESSION_EV_NO_IO:\n            h2_session_ev_no_io(session, arg, msg);\n            break;\n        case H2_SESSION_EV_STREAM_READY:\n            h2_session_ev_stream_ready(session, arg, msg);\n            break;\n        case H2_SESSION_EV_DATA_READ:\n            h2_session_ev_data_read(session, arg, msg);\n            break;\n        case H2_SESSION_EV_NGH2_DONE:\n            h2_session_ev_ngh2_done(session, arg, msg);\n            break;\n        case H2_SESSION_EV_MPM_STOPPING:\n            h2_session_ev_mpm_stopping(session, arg, msg);\n            break;\n        case H2_SESSION_EV_PRE_CLOSE:\n            h2_session_ev_pre_close(session, arg, msg);\n            break;\n        case H2_SESSION_EV_STREAM_OPEN:\n            h2_session_ev_stream_open(session, arg, msg);\n            break;\n        case H2_SESSION_EV_STREAM_DONE:\n            h2_session_ev_stream_done(session, arg, msg);\n            break;\n        default:\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                          \"h2_session(%ld): unknown event %d\", \n                          session->id, ev);\n            break;\n    }\n    \n    if (session->state == H2_SESSION_ST_DONE) {\n        apr_brigade_cleanup(session->bbtmp);\n        h2_mplx_abort(session->mplx);\n    }\n}\n\nstatic const int MAX_WAIT_MICROS = 200 * 1000;\n\napr_status_t h2_session_process(h2_session *session, int async)\n{\n    apr_status_t status = APR_SUCCESS;\n    conn_rec *c = session->c;\n    int rv, mpm_state, trace = APLOGctrace3(c);\n\n    if (trace) {\n        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                      \"h2_session(%ld): process start, async=%d\", \n                      session->id, async);\n    }\n                  \n    if (c->cs) {\n        c->cs->state = CONN_STATE_WRITE_COMPLETION;\n    }\n    \n    while (session->state != H2_SESSION_ST_DONE) {\n        trace = APLOGctrace3(c);\n        session->have_read = session->have_written = 0;\n\n        if (session->local.accepting \n            && !ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n            if (mpm_state == AP_MPMQ_STOPPING) {\n                dispatch_event(session, H2_SESSION_EV_MPM_STOPPING, 0, NULL);\n            }\n        }\n        \n        session->status[0] = '\\0';\n        \n        switch (session->state) {\n            case H2_SESSION_ST_INIT:\n                ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n                if (!h2_is_acceptable_connection(c, 1)) {\n                    update_child_status(session, SERVER_BUSY_READ, \"inadequate security\");\n                    h2_session_shutdown(session, NGHTTP2_INADEQUATE_SECURITY, NULL, 1);\n                } \n                else {\n                    update_child_status(session, SERVER_BUSY_READ, \"init\");\n                    status = h2_session_start(session, &rv);\n                    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, c, APLOGNO(03079)\n                                  \"h2_session(%ld): started on %s:%d\", session->id,\n                                  session->s->server_hostname,\n                                  c->local_addr->port);\n                    if (status != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                    }\n                    dispatch_event(session, H2_SESSION_EV_INIT, 0, NULL);\n                }\n                break;\n                \n            case H2_SESSION_ST_IDLE:\n                /* make certain, we send everything before we idle */\n                h2_conn_io_flush(&session->io);\n                if (!session->keep_sync_until && async && !session->open_streams\n                    && !session->r && session->remote.emitted_count) {\n                    if (trace) {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): async idle, nonblock read, \"\n                                      \"%d streams open\", session->id, \n                                      session->open_streams);\n                    }\n                    /* We do not return to the async mpm immediately, since under\n                     * load, mpms show the tendency to throw keep_alive connections\n                     * away very rapidly.\n                     * So, if we are still processing streams, we wait for the\n                     * normal timeout first and, on timeout, close.\n                     * If we have no streams, we still wait a short amount of\n                     * time here for the next frame to arrive, before handing\n                     * it to keep_alive processing of the mpm.\n                     */\n                    status = h2_session_read(session, 0);\n                    \n                    if (status == APR_SUCCESS) {\n                        session->have_read = 1;\n                        dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                    }\n                    else if (APR_STATUS_IS_EAGAIN(status) || APR_STATUS_IS_TIMEUP(status)) {\n                        if (apr_time_now() > session->idle_until) {\n                            dispatch_event(session, H2_SESSION_EV_CONN_TIMEOUT, 0, NULL);\n                        }\n                        else {\n                            status = APR_EAGAIN;\n                            goto out;\n                        }\n                    }\n                    else {\n                        ap_log_cerror( APLOG_MARK, APLOG_DEBUG, status, c,\n\t\t\t\t      APLOGNO(03403)\n                                      \"h2_session(%ld): idle, no data, error\", \n                                      session->id);\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, \"timeout\");\n                    }\n                }\n                else {\n                    if (trace) {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): sync idle, stutter 1-sec, \"\n                                      \"%d streams open\", session->id,\n                                      session->open_streams);\n                    }\n                    /* We wait in smaller increments, using a 1 second timeout.\n                     * That gives us the chance to check for MPMQ_STOPPING often. \n                     */\n                    status = h2_mplx_idle(session->mplx);\n                    if (status != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, \n                                       H2_ERR_ENHANCE_YOUR_CALM, \"less is more\");\n                    }\n                    h2_filter_cin_timeout_set(session->cin, apr_time_from_sec(1));\n                    status = h2_session_read(session, 1);\n                    if (status == APR_SUCCESS) {\n                        session->have_read = 1;\n                        dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                    }\n                    else if (status == APR_EAGAIN) {\n                        /* nothing to read */\n                    }\n                    else if (APR_STATUS_IS_TIMEUP(status)) {\n                        apr_time_t now = apr_time_now();\n                        if (now > session->keep_sync_until) {\n                            /* if we are on an async mpm, now is the time that\n                             * we may dare to pass control to it. */\n                            session->keep_sync_until = 0;\n                        }\n                        if (now > session->idle_until) {\n                            if (trace) {\n                                ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                              \"h2_session(%ld): keepalive timeout\",\n                                              session->id);\n                            }\n                            dispatch_event(session, H2_SESSION_EV_CONN_TIMEOUT, 0, \"timeout\");\n                        }\n                        else if (trace) {                        \n                            ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                          \"h2_session(%ld): keepalive, %f sec left\",\n                                          session->id, (session->idle_until - now) / 1000000.0f);\n                        }\n                        /* continue reading handling */\n                    }\n                    else if (APR_STATUS_IS_ECONNABORTED(status)\n                             || APR_STATUS_IS_ECONNRESET(status)\n                             || APR_STATUS_IS_EOF(status)\n                             || APR_STATUS_IS_EBADF(status)) {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): input gone\", session->id);\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                    }\n                    else {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): idle(1 sec timeout) \"\n                                      \"read failed\", session->id);\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, \"error\");\n                    }\n                }\n                \n                break;\n                \n            case H2_SESSION_ST_BUSY:\n                if (nghttp2_session_want_read(session->ngh2)) {\n                    ap_update_child_status(session->c->sbh, SERVER_BUSY_READ, NULL);\n                    h2_filter_cin_timeout_set(session->cin, session->s->timeout);\n                    status = h2_session_read(session, 0);\n                    if (status == APR_SUCCESS) {\n                        session->have_read = 1;\n                        dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                    }\n                    else if (status == APR_EAGAIN) {\n                        /* nothing to read */\n                    }\n                    else if (APR_STATUS_IS_TIMEUP(status)) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_TIMEOUT, 0, NULL);\n                        break;\n                    }\n                    else {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                    }\n                }\n                \n                /* trigger window updates, stream resumes and submits */\n                status = h2_mplx_dispatch_master_events(session->mplx, \n                                                        on_stream_resume,\n                                                        session);\n                if (status != APR_SUCCESS) {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE3, status, c,\n                                  \"h2_session(%ld): dispatch error\", \n                                  session->id);\n                    dispatch_event(session, H2_SESSION_EV_CONN_ERROR, \n                                   H2_ERR_INTERNAL_ERROR, \n                                   \"dispatch error\");\n                    break;\n                }\n                \n                if (nghttp2_session_want_write(session->ngh2)) {\n                    ap_update_child_status(session->c->sbh, SERVER_BUSY_WRITE, NULL);\n                    status = h2_session_send(session);\n                    if (status != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, \n                                       H2_ERR_INTERNAL_ERROR, \"writing\");\n                        break;\n                    }\n                }\n                \n                if (session->have_read || session->have_written) {\n                    if (session->wait_us) {\n                        session->wait_us = 0;\n                    }\n                }\n                else if (!nghttp2_session_want_write(session->ngh2)) {\n                    dispatch_event(session, H2_SESSION_EV_NO_IO, 0, NULL);\n                }\n                break;\n                \n            case H2_SESSION_ST_WAIT:\n                if (session->wait_us <= 0) {\n                    session->wait_us = 10;\n                    if (h2_conn_io_flush(&session->io) != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                        break;\n                    }\n                }\n                else {\n                    /* repeating, increase timer for graceful backoff */\n                    session->wait_us = H2MIN(session->wait_us*2, MAX_WAIT_MICROS);\n                }\n\n                if (trace) {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE3, 0, c,\n                                  \"h2_session: wait for data, %ld micros\", \n                                  (long)session->wait_us);\n                }\n                status = h2_mplx_out_trywait(session->mplx, session->wait_us, \n                                             session->iowait);\n                if (status == APR_SUCCESS) {\n                    session->wait_us = 0;\n                    dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                }\n                else if (APR_STATUS_IS_TIMEUP(status)) {\n                    /* go back to checking all inputs again */\n                    transit(session, \"wait cycle\", session->local.accepting? \n                            H2_SESSION_ST_BUSY : H2_SESSION_ST_DONE);\n                }\n                else if (APR_STATUS_IS_ECONNRESET(status) \n                         || APR_STATUS_IS_ECONNABORTED(status)) {\n                    dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                }\n                else {\n                    ap_log_cerror(APLOG_MARK, APLOG_WARNING, status, c,\n\t\t\t\t  APLOGNO(03404)\n                                  \"h2_session(%ld): waiting on conditional\",\n                                  session->id);\n                    h2_session_shutdown(session, H2_ERR_INTERNAL_ERROR, \n                                        \"cond wait error\", 0);\n                }\n                break;\n                \n            default:\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, c,\n                              APLOGNO(03080)\n                              \"h2_session(%ld): unknown state %d\", session->id, session->state);\n                dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, 0, NULL);\n                break;\n        }\n\n        if (!nghttp2_session_want_read(session->ngh2) \n                 && !nghttp2_session_want_write(session->ngh2)) {\n            dispatch_event(session, H2_SESSION_EV_NGH2_DONE, 0, NULL); \n        }\n        if (session->reprioritize) {\n            h2_mplx_reprioritize(session->mplx, stream_pri_cmp, session);\n            session->reprioritize = 0;\n        }\n    }\n    \nout:\n    if (trace) {\n        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                      \"h2_session(%ld): [%s] process returns\", \n                      session->id, state_name(session->state));\n    }\n    \n    if ((session->state != H2_SESSION_ST_DONE)\n        && (APR_STATUS_IS_EOF(status)\n            || APR_STATUS_IS_ECONNRESET(status) \n            || APR_STATUS_IS_ECONNABORTED(status))) {\n        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n    }\n\n    status = APR_SUCCESS;\n    if (session->state == H2_SESSION_ST_DONE) {\n        status = APR_EOF;\n        if (!session->eoc_written) {\n            session->eoc_written = 1;\n            h2_conn_io_write_eoc(&session->io, session);\n        }\n    }\n    \n    return status;\n}\n\napr_status_t h2_session_pre_close(h2_session *session, int async)\n{\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c, \n                  \"h2_session(%ld): pre_close\", session->id);\n    dispatch_event(session, H2_SESSION_EV_PRE_CLOSE, 0, \n        (session->state == H2_SESSION_ST_IDLE)? \"timeout\" : NULL);\n    return APR_SUCCESS;\n}\n", "/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <assert.h>\n#include <stddef.h>\n\n#include <apr_strings.h>\n\n#include <httpd.h>\n#include <http_core.h>\n#include <http_connection.h>\n#include <http_log.h>\n\n#include <nghttp2/nghttp2.h>\n\n#include \"h2_private.h\"\n#include \"h2.h\"\n#include \"h2_bucket_beam.h\"\n#include \"h2_conn.h\"\n#include \"h2_config.h\"\n#include \"h2_h2.h\"\n#include \"h2_mplx.h\"\n#include \"h2_push.h\"\n#include \"h2_request.h\"\n#include \"h2_headers.h\"\n#include \"h2_session.h\"\n#include \"h2_stream.h\"\n#include \"h2_task.h\"\n#include \"h2_ctx.h\"\n#include \"h2_task.h\"\n#include \"h2_util.h\"\n\n\nstatic int state_transition[][7] = {\n    /*  ID OP RL RR CI CO CL */\n/*ID*/{  1, 0, 0, 0, 0, 0, 0 },\n/*OP*/{  1, 1, 0, 0, 0, 0, 0 },\n/*RL*/{  0, 0, 1, 0, 0, 0, 0 },\n/*RR*/{  0, 0, 0, 1, 0, 0, 0 },\n/*CI*/{  1, 1, 0, 0, 1, 0, 0 },\n/*CO*/{  1, 1, 0, 0, 0, 1, 0 },\n/*CL*/{  1, 1, 0, 0, 1, 1, 1 },\n};\n\nstatic void H2_STREAM_OUT_LOG(int lvl, h2_stream *s, const char *tag)\n{\n    if (APLOG_C_IS_LEVEL(s->session->c, lvl)) {\n        conn_rec *c = s->session->c;\n        char buffer[4 * 1024];\n        const char *line = \"(null)\";\n        apr_size_t len, bmax = sizeof(buffer)/sizeof(buffer[0]);\n        \n        len = h2_util_bb_print(buffer, bmax, tag, \"\", s->out_buffer);\n        ap_log_cerror(APLOG_MARK, lvl, 0, c, \"bb_dump(%s): %s\", \n                      c->log_id, len? buffer : line);\n    }\n}\n\nstatic int set_state(h2_stream *stream, h2_stream_state_t state)\n{\n    int allowed = state_transition[state][stream->state];\n    if (allowed) {\n        stream->state = state;\n        return 1;\n    }\n    \n    ap_log_cerror(APLOG_MARK, APLOG_WARNING, 0, stream->session->c, APLOGNO(03081)\n                  \"h2_stream(%ld-%d): invalid state transition from %d to %d\", \n                  stream->session->id, stream->id, stream->state, state);\n    return 0;\n}\n\nstatic int close_input(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_CLOSED_INPUT:\n        case H2_STREAM_ST_CLOSED:\n            return 0; /* ignore, idempotent */\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            /* both closed now */\n            set_state(stream, H2_STREAM_ST_CLOSED);\n            break;\n        default:\n            /* everything else we jump to here */\n            set_state(stream, H2_STREAM_ST_CLOSED_INPUT);\n            break;\n    }\n    return 1;\n}\n\nstatic int input_closed(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_OPEN:\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            return 0;\n        default:\n            return 1;\n    }\n}\n\nstatic int close_output(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n        case H2_STREAM_ST_CLOSED:\n            return 0; /* ignore, idempotent */\n        case H2_STREAM_ST_CLOSED_INPUT:\n            /* both closed now */\n            set_state(stream, H2_STREAM_ST_CLOSED);\n            break;\n        default:\n            /* everything else we jump to here */\n            set_state(stream, H2_STREAM_ST_CLOSED_OUTPUT);\n            break;\n    }\n    return 1;\n}\n\nstatic int input_open(const h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_OPEN:\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            return 1;\n        default:\n            return 0;\n    }\n}\n\nstatic int output_open(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_OPEN:\n        case H2_STREAM_ST_CLOSED_INPUT:\n            return 1;\n        default:\n            return 0;\n    }\n}\n\nstatic void prep_output(h2_stream *stream) {\n    conn_rec *c = stream->session->c;\n    if (!stream->out_buffer) {\n        stream->out_buffer = apr_brigade_create(stream->pool, c->bucket_alloc);\n    }\n}\n\nstatic void prepend_response(h2_stream *stream, h2_headers *response)\n{\n    conn_rec *c = stream->session->c;\n    apr_bucket *b;\n    \n    prep_output(stream);\n    b = h2_bucket_headers_create(c->bucket_alloc, response);\n    APR_BRIGADE_INSERT_HEAD(stream->out_buffer, b);\n}\n\nstatic apr_status_t stream_pool_cleanup(void *ctx)\n{\n    h2_stream *stream = ctx;\n    apr_status_t status;\n    \n    ap_assert(stream->can_be_cleaned);\n    if (stream->files) {\n        apr_file_t *file;\n        int i;\n        for (i = 0; i < stream->files->nelts; ++i) {\n            file = APR_ARRAY_IDX(stream->files, i, apr_file_t*);\n            status = apr_file_close(file);\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE3, status, stream->session->c, \n                          \"h2_stream(%ld-%d): destroy, closed file %d\", \n                          stream->session->id, stream->id, i);\n        }\n        stream->files = NULL;\n    }\n    return APR_SUCCESS;\n}\n\nh2_stream *h2_stream_open(int id, apr_pool_t *pool, h2_session *session,\n                          int initiated_on)\n{\n    h2_stream *stream = apr_pcalloc(pool, sizeof(h2_stream));\n    \n    stream->id           = id;\n    stream->initiated_on = initiated_on;\n    stream->created      = apr_time_now();\n    stream->state        = H2_STREAM_ST_IDLE;\n    stream->pool         = pool;\n    stream->session      = session;\n    stream->can_be_cleaned = 1;\n\n    h2_beam_create(&stream->input, pool, id, \"input\", H2_BEAM_OWNER_SEND, 0);\n    h2_beam_create(&stream->output, pool, id, \"output\", H2_BEAM_OWNER_RECV, 0);\n    \n    set_state(stream, H2_STREAM_ST_OPEN);\n    apr_pool_cleanup_register(pool, stream, stream_pool_cleanup, \n                              apr_pool_cleanup_null);\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03082)\n                  \"h2_stream(%ld-%d): opened\", session->id, stream->id);\n    return stream;\n}\n\nvoid h2_stream_cleanup(h2_stream *stream)\n{\n    apr_status_t status;\n    \n    ap_assert(stream);\n    if (stream->out_buffer) {\n        /* remove any left over output buckets that may still have\n         * references into request pools */\n        apr_brigade_cleanup(stream->out_buffer);\n    }\n    h2_beam_abort(stream->input);\n    status = h2_beam_wait_empty(stream->input, APR_NONBLOCK_READ);\n    if (status == APR_EAGAIN) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, stream->session->c, \n                      \"h2_stream(%ld-%d): wait on input drain\", \n                      stream->session->id, stream->id);\n        status = h2_beam_wait_empty(stream->input, APR_BLOCK_READ);\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, stream->session->c, \n                      \"h2_stream(%ld-%d): input drain returned\", \n                      stream->session->id, stream->id);\n    }\n}\n\nvoid h2_stream_destroy(h2_stream *stream)\n{\n    ap_assert(stream);\n    ap_assert(!h2_mplx_stream_get(stream->session->mplx, stream->id));\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE3, 0, stream->session->c, \n                  \"h2_stream(%ld-%d): destroy\", \n                  stream->session->id, stream->id);\n    stream->can_be_cleaned = 1;\n    if (stream->pool) {\n        apr_pool_destroy(stream->pool);\n    }\n}\n\nvoid h2_stream_eos_destroy(h2_stream *stream)\n{\n    h2_session_stream_done(stream->session, stream);\n    /* stream possibly destroyed */\n}\n\napr_pool_t *h2_stream_detach_pool(h2_stream *stream)\n{\n    apr_pool_t *pool = stream->pool;\n    stream->pool = NULL;\n    return pool;\n}\n\nvoid h2_stream_rst(h2_stream *stream, int error_code)\n{\n    stream->rst_error = error_code;\n    close_input(stream);\n    close_output(stream);\n    if (stream->out_buffer) {\n        apr_brigade_cleanup(stream->out_buffer);\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                  \"h2_stream(%ld-%d): reset, error=%d\", \n                  stream->session->id, stream->id, error_code);\n}\n\napr_status_t h2_stream_set_request_rec(h2_stream *stream, request_rec *r)\n{\n    h2_request *req;\n    apr_status_t status;\n\n    ap_assert(stream->request == NULL);\n    ap_assert(stream->rtmp == NULL);\n    if (stream->rst_error) {\n        return APR_ECONNRESET;\n    }\n    status = h2_request_rcreate(&req, stream->pool, r);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(03058)\n                  \"h2_request(%d): set_request_rec %s host=%s://%s%s\",\n                  stream->id, req->method, req->scheme, req->authority, \n                  req->path);\n    stream->rtmp = req;\n    return status;\n}\n\napr_status_t h2_stream_set_request(h2_stream *stream, const h2_request *r)\n{\n    ap_assert(stream->request == NULL);\n    ap_assert(stream->rtmp == NULL);\n    stream->rtmp = h2_request_clone(stream->pool, r);\n    return APR_SUCCESS;\n}\n\nstatic apr_status_t add_trailer(h2_stream *stream,\n                                const char *name, size_t nlen,\n                                const char *value, size_t vlen)\n{\n    conn_rec *c = stream->session->c;\n    char *hname, *hvalue;\n\n    if (nlen == 0 || name[0] == ':') {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_EINVAL, c, APLOGNO(03060)\n                      \"h2_request(%ld-%d): pseudo header in trailer\",\n                      c->id, stream->id);\n        return APR_EINVAL;\n    }\n    if (h2_req_ignore_trailer(name, nlen)) {\n        return APR_SUCCESS;\n    }\n    if (!stream->trailers) {\n        stream->trailers = apr_table_make(stream->pool, 5);\n    }\n    hname = apr_pstrndup(stream->pool, name, nlen);\n    hvalue = apr_pstrndup(stream->pool, value, vlen);\n    h2_util_camel_case_header(hname, nlen);\n    apr_table_mergen(stream->trailers, hname, hvalue);\n    \n    return APR_SUCCESS;\n}\n\napr_status_t h2_stream_add_header(h2_stream *stream,\n                                  const char *name, size_t nlen,\n                                  const char *value, size_t vlen)\n{\n    ap_assert(stream);\n    \n    if (!stream->has_response) {\n        if (name[0] == ':') {\n            if ((vlen) > stream->session->s->limit_req_line) {\n                /* pseudo header: approximation of request line size check */\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                              \"h2_stream(%ld-%d): pseudo header %s too long\", \n                              stream->session->id, stream->id, name);\n                return h2_stream_set_error(stream, \n                                           HTTP_REQUEST_URI_TOO_LARGE);\n            }\n        }\n        else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n            /* header too long */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                          \"h2_stream(%ld-%d): header %s too long\", \n                          stream->session->id, stream->id, name);\n            return h2_stream_set_error(stream, \n                                       HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n        }\n        \n        if (name[0] != ':') {\n            ++stream->request_headers_added;\n            if (stream->request_headers_added \n                > stream->session->s->limit_req_fields) {\n                /* too many header lines */\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                              \"h2_stream(%ld-%d): too many header lines\", \n                              stream->session->id, stream->id);\n                return h2_stream_set_error(stream, \n                                           HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n            }\n        }\n    }\n    \n    if (h2_stream_is_scheduled(stream)) {\n        return add_trailer(stream, name, nlen, value, vlen);\n    }\n    else {\n        if (!stream->rtmp) {\n            stream->rtmp = h2_req_create(stream->id, stream->pool, \n                                         NULL, NULL, NULL, NULL, NULL, 0);\n        }\n        if (stream->state != H2_STREAM_ST_OPEN) {\n            return APR_ECONNRESET;\n        }\n        return h2_request_add_header(stream->rtmp, stream->pool,\n                                     name, nlen, value, vlen);\n    }\n}\n\napr_status_t h2_stream_schedule(h2_stream *stream, int eos, int push_enabled, \n                                h2_stream_pri_cmp *cmp, void *ctx)\n{\n    apr_status_t status = APR_EINVAL;\n    ap_assert(stream);\n    ap_assert(stream->session);\n    ap_assert(stream->session->mplx);\n    \n    if (!stream->scheduled) {\n        if (eos) {\n            close_input(stream);\n        }\n\n        if (h2_stream_is_ready(stream)) {\n            /* already have a resonse, probably a HTTP error code */\n            return h2_mplx_process(stream->session->mplx, stream, cmp, ctx);\n        }\n        else if (!stream->request && stream->rtmp) {\n            /* This is the common case: a h2_request was being assembled, now\n             * it gets finalized and checked for completness */\n            status = h2_request_end_headers(stream->rtmp, stream->pool, eos);\n            if (status == APR_SUCCESS) {\n                stream->rtmp->serialize = h2_config_geti(stream->session->config,\n                                                         H2_CONF_SER_HEADERS); \n\n                stream->request = stream->rtmp;\n                stream->rtmp = NULL;\n                stream->scheduled = 1;\n\n                stream->push_policy = h2_push_policy_determine(stream->request->headers, \n                                                               stream->pool, push_enabled);\n            \n                \n                status = h2_mplx_process(stream->session->mplx, stream, cmp, ctx);\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                              \"h2_stream(%ld-%d): scheduled %s %s://%s%s \"\n                              \"chunked=%d\",\n                              stream->session->id, stream->id,\n                              stream->request->method, stream->request->scheme,\n                              stream->request->authority, stream->request->path,\n                              stream->request->chunked);\n                return status;\n            }\n        }\n        else {\n            status = APR_ECONNRESET;\n        }\n    }\n    \n    h2_stream_rst(stream, H2_ERR_INTERNAL_ERROR);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, stream->session->c,\n                  \"h2_stream(%ld-%d): RST=2 (internal err) %s %s://%s%s\",\n                  stream->session->id, stream->id,\n                  stream->request->method, stream->request->scheme,\n                  stream->request->authority, stream->request->path);\n    return status;\n}\n\nint h2_stream_is_scheduled(const h2_stream *stream)\n{\n    return stream->scheduled;\n}\n\napr_status_t h2_stream_close_input(h2_stream *stream)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status;\n    apr_bucket_brigade *tmp;\n    apr_bucket *b;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                  \"h2_stream(%ld-%d): closing input\",\n                  stream->session->id, stream->id);\n    if (stream->rst_error) {\n        return APR_ECONNRESET;\n    }\n    \n    tmp = apr_brigade_create(stream->pool, c->bucket_alloc);\n    if (stream->trailers && !apr_is_empty_table(stream->trailers)) {\n        h2_headers *r = h2_headers_create(HTTP_OK, stream->trailers, \n                                          NULL, stream->pool);\n        b = h2_bucket_headers_create(c->bucket_alloc, r);\n        APR_BRIGADE_INSERT_TAIL(tmp, b);\n        stream->trailers = NULL;\n    }\n    \n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmp, b);\n    status = h2_beam_send(stream->input, tmp, APR_BLOCK_READ);\n    apr_brigade_destroy(tmp);\n    return status;\n}\n\napr_status_t h2_stream_write_data(h2_stream *stream,\n                                  const char *data, size_t len, int eos)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status = APR_SUCCESS;\n    apr_bucket_brigade *tmp;\n    \n    ap_assert(stream);\n    if (!stream->input) {\n        return APR_EOF;\n    }\n    if (input_closed(stream) || !stream->request) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                      \"h2_stream(%ld-%d): writing denied, closed=%d, eoh=%d\", \n                      stream->session->id, stream->id, input_closed(stream),\n                      stream->request != NULL);\n        return APR_EINVAL;\n    }\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                  \"h2_stream(%ld-%d): add %ld input bytes\", \n                  stream->session->id, stream->id, (long)len);\n    \n    tmp = apr_brigade_create(stream->pool, c->bucket_alloc);\n    apr_brigade_write(tmp, NULL, NULL, data, len);\n    status = h2_beam_send(stream->input, tmp, APR_BLOCK_READ);\n    apr_brigade_destroy(tmp);\n    \n    stream->in_data_frames++;\n    stream->in_data_octets += len;\n    \n    if (eos) {\n        return h2_stream_close_input(stream);\n    }\n    \n    return status;\n}\n\nstatic apr_status_t fill_buffer(h2_stream *stream, apr_size_t amount)\n{\n    conn_rec *c = stream->session->c;\n    apr_bucket *b;\n    apr_status_t status;\n    \n    if (!stream->output) {\n        return APR_EOF;\n    }\n    status = h2_beam_receive(stream->output, stream->out_buffer, \n                             APR_NONBLOCK_READ, amount);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, stream->session->c,\n                  \"h2_stream(%ld-%d): beam_received\",\n                  stream->session->id, stream->id);\n    /* The buckets we reveive are using the stream->out_buffer pool as\n     * lifetime which is exactly what we want since this is stream->pool.\n     *\n     * However: when we send these buckets down the core output filters, the\n     * filter might decide to setaside them into a pool of its own. And it\n     * might decide, after having sent the buckets, to clear its pool.\n     *\n     * This is problematic for file buckets because it then closed the contained\n     * file. Any split off buckets we sent afterwards will result in a \n     * APR_EBADF.\n     */\n    for (b = APR_BRIGADE_FIRST(stream->out_buffer);\n         b != APR_BRIGADE_SENTINEL(stream->out_buffer);\n         b = APR_BUCKET_NEXT(b)) {\n        if (APR_BUCKET_IS_FILE(b)) {\n            apr_bucket_file *f = (apr_bucket_file *)b->data;\n            apr_pool_t *fpool = apr_file_pool_get(f->fd);\n            if (fpool != c->pool) {\n                apr_bucket_setaside(b, c->pool);\n                if (!stream->files) {\n                    stream->files = apr_array_make(stream->pool, \n                                                   5, sizeof(apr_file_t*));\n                }\n                APR_ARRAY_PUSH(stream->files, apr_file_t*) = f->fd;\n            }\n        }\n    }\n    return status;\n}\n\napr_status_t h2_stream_set_error(h2_stream *stream, int http_status)\n{\n    h2_headers *response;\n    \n    if (h2_stream_is_ready(stream)) {\n        return APR_EINVAL;\n    }\n    if (stream->rtmp) {\n        stream->request = stream->rtmp;\n        stream->rtmp = NULL;\n    }\n    response = h2_headers_die(http_status, stream->request, stream->pool);\n    prepend_response(stream, response);\n    h2_beam_close(stream->output);\n    return APR_SUCCESS;\n}\n\nstatic apr_bucket *get_first_headers_bucket(apr_bucket_brigade *bb)\n{\n    if (bb) {\n        apr_bucket *b = APR_BRIGADE_FIRST(bb);\n        while (b != APR_BRIGADE_SENTINEL(bb)) {\n            if (H2_BUCKET_IS_HEADERS(b)) {\n                return b;\n            }\n            b = APR_BUCKET_NEXT(b);\n        }\n    }\n    return NULL;\n}\n\napr_status_t h2_stream_out_prepare(h2_stream *stream, apr_off_t *plen, \n                                   int *peos, h2_headers **presponse)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status = APR_SUCCESS;\n    apr_off_t requested;\n    apr_bucket *b, *e;\n\n    if (presponse) {\n        *presponse = NULL;\n    }\n    \n    if (stream->rst_error) {\n        *plen = 0;\n        *peos = 1;\n        return APR_ECONNRESET;\n    }\n    \n    if (!output_open(stream)) {\n        return APR_ECONNRESET;\n    }\n    prep_output(stream);\n\n    if (*plen > 0) {\n        requested = H2MIN(*plen, H2_DATA_CHUNK_SIZE);\n    }\n    else {\n        requested = H2_DATA_CHUNK_SIZE;\n    }\n    *plen = requested;\n    \n    H2_STREAM_OUT_LOG(APLOG_TRACE2, stream, \"h2_stream_out_prepare_pre\");\n    h2_util_bb_avail(stream->out_buffer, plen, peos);\n    if (!*peos && *plen < requested) {\n        /* try to get more data */\n        status = fill_buffer(stream, (requested - *plen) + H2_DATA_CHUNK_SIZE);\n        if (APR_STATUS_IS_EOF(status)) {\n            apr_bucket *eos = apr_bucket_eos_create(c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(stream->out_buffer, eos);\n            status = APR_SUCCESS;\n        }\n        else if (status == APR_EAGAIN) {\n            /* did not receive more, it's ok */\n            status = APR_SUCCESS;\n        }\n        *plen = requested;\n        h2_util_bb_avail(stream->out_buffer, plen, peos);\n    }\n    H2_STREAM_OUT_LOG(APLOG_TRACE2, stream, \"h2_stream_out_prepare_post\");\n    \n    b = APR_BRIGADE_FIRST(stream->out_buffer);\n    while (b != APR_BRIGADE_SENTINEL(stream->out_buffer)) {\n        e = APR_BUCKET_NEXT(b);\n        if (APR_BUCKET_IS_FLUSH(b)\n            || (!APR_BUCKET_IS_METADATA(b) && b->length == 0)) {\n            APR_BUCKET_REMOVE(b);\n            apr_bucket_destroy(b);\n        }\n        else {\n            break;\n        }\n        b = e;\n    }\n    \n    b = get_first_headers_bucket(stream->out_buffer);\n    if (b) {\n        /* there are HEADERS to submit */\n        *peos = 0;\n        *plen = 0;\n        if (b == APR_BRIGADE_FIRST(stream->out_buffer)) {\n            if (presponse) {\n                *presponse = h2_bucket_headers_get(b);\n                APR_BUCKET_REMOVE(b);\n                apr_bucket_destroy(b);\n                status = APR_SUCCESS;\n            }\n            else {\n                /* someone needs to retrieve the response first */\n                h2_mplx_keep_active(stream->session->mplx, stream->id);\n                status = APR_EAGAIN;\n            }\n        }\n        else {\n            apr_bucket *e = APR_BRIGADE_FIRST(stream->out_buffer);\n            while (e != APR_BRIGADE_SENTINEL(stream->out_buffer)) {\n                if (e == b) {\n                    break;\n                }\n                else if (e->length != (apr_size_t)-1) {\n                    *plen += e->length;\n                }\n                e = APR_BUCKET_NEXT(e);\n            }\n        }\n    }\n    \n    if (!*peos && !*plen && status == APR_SUCCESS \n        && (!presponse || !*presponse)) {\n        status = APR_EAGAIN;\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, c,\n                  \"h2_stream(%ld-%d): prepare, len=%ld eos=%d\",\n                  c->id, stream->id, (long)*plen, *peos);\n    return status;\n}\n\nstatic int is_not_headers(apr_bucket *b)\n{\n    return !H2_BUCKET_IS_HEADERS(b);\n}\n\napr_status_t h2_stream_read_to(h2_stream *stream, apr_bucket_brigade *bb, \n                               apr_off_t *plen, int *peos)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status = APR_SUCCESS;\n\n    if (stream->rst_error) {\n        return APR_ECONNRESET;\n    }\n    status = h2_append_brigade(bb, stream->out_buffer, plen, peos, is_not_headers);\n    if (status == APR_SUCCESS && !*peos && !*plen) {\n        status = APR_EAGAIN;\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, c,\n                  \"h2_stream(%ld-%d): read_to, len=%ld eos=%d\",\n                  c->id, stream->id, (long)*plen, *peos);\n    return status;\n}\n\n\nint h2_stream_input_is_open(const h2_stream *stream) \n{\n    return input_open(stream);\n}\n\napr_status_t h2_stream_submit_pushes(h2_stream *stream, h2_headers *response)\n{\n    apr_status_t status = APR_SUCCESS;\n    apr_array_header_t *pushes;\n    int i;\n    \n    pushes = h2_push_collect_update(stream, stream->request, response);\n    if (pushes && !apr_is_empty_array(pushes)) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): found %d push candidates\",\n                      stream->session->id, stream->id, pushes->nelts);\n        for (i = 0; i < pushes->nelts; ++i) {\n            h2_push *push = APR_ARRAY_IDX(pushes, i, h2_push*);\n            h2_stream *s = h2_session_push(stream->session, stream, push);\n            if (!s) {\n                status = APR_ECONNRESET;\n                break;\n            }\n        }\n    }\n    return status;\n}\n\napr_table_t *h2_stream_get_trailers(h2_stream *stream)\n{\n    return NULL;\n}\n\nconst h2_priority *h2_stream_get_priority(h2_stream *stream, \n                                          h2_headers *response)\n{\n    if (response && stream->initiated_on) {\n        const char *ctype = apr_table_get(response->headers, \"content-type\");\n        if (ctype) {\n            /* FIXME: Not good enough, config needs to come from request->server */\n            return h2_config_get_priority(stream->session->config, ctype);\n        }\n    }\n    return NULL;\n}\n\nconst char *h2_stream_state_str(h2_stream *stream)\n{\n    switch (stream->state) {\n        case H2_STREAM_ST_IDLE:\n            return \"IDLE\";\n        case H2_STREAM_ST_OPEN:\n            return \"OPEN\";\n        case H2_STREAM_ST_RESV_LOCAL:\n            return \"RESERVED_LOCAL\";\n        case H2_STREAM_ST_RESV_REMOTE:\n            return \"RESERVED_REMOTE\";\n        case H2_STREAM_ST_CLOSED_INPUT:\n            return \"HALF_CLOSED_REMOTE\";\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            return \"HALF_CLOSED_LOCAL\";\n        case H2_STREAM_ST_CLOSED:\n            return \"CLOSED\";\n        default:\n            return \"UNKNOWN\";\n            \n    }\n}\n\nint h2_stream_is_ready(h2_stream *stream)\n{\n    if (stream->has_response) {\n        return 1;\n    }\n    else if (stream->out_buffer && get_first_headers_bucket(stream->out_buffer)) {\n        return 1;\n    }\n    return 0;\n}\n\n\n"], "fixing_code": ["                                                         -*- coding: utf-8 -*-\nChanges with Apache 2.5.0\n\n  *) mod_http2: CVE-2016-8740: Mitigate DoS memory exhaustion via endless\n     CONTINUATION frames.\n     [Naveen Tiwari <naveen.tiwari@asu.edu> and CDF/SEFCOM at Arizona State University, Stefan Eissing]\n\n  *) mod_lua: Fix default value of LuaInherit directive. It should be \n     'parent-first' instead of 'none', as per documentation.  PR 60419\n     [Christophe Jaillet]\n\n  *) mod_ratelimit: Allow for initial \"burst\" amount at full speed before\n     throttling: PR 60145 [Andy Valencia <ajv-etradanalhos vsta.org>,\n     Jim Jagielski]\n\n  *) event: Allow to use the whole allocated scoreboard (up to ServerLimit\n     slots) to avoid scoreboard full errors when some processes are finishing\n     gracefully. Also, make gracefully finishing processes close all\n     keep-alive connections. PR 53555. [Stefan Fritsch]\n\n  *) http: Allow unknown response status' lines returned in the form of\n     \"HTTP/x.x xxx Status xxx\".  [Yann Ylavic]\n\n  *) core: Add <IfFile> configuration section to allow any file on disk to be\n     used as a conditional.  [Edward Lu, Eric Covener]\n\n  *) event: Avoid listener periodic wake ups by using the pollset wake-ability\n     when available.  PR 57399.  [Yann Ylavic, Luca Toscano]\n\n  *) mod_brotli: Add a new module for dynamic Brotli (RFC 7932) compression.\n     [Evgeny Kotkov]\n\n  *) core: Permit unencoded ';' characters to appear in proxy requests and\n     Location: response headers. Corresponds to modern browser behavior.\n     [William Rowe]\n\n  *) mod_cache: Use the actual URI path and query-string for identifying the\n     cached entity (key), such that rewrites are taken into account when\n     running afterwards (CacheQuickHandler off).  PR 21935.  [Yann Ylavic]\n\n  *) mod_ssl: Fix quick renegotiation (OptRenegotiaton) with no intermediate\n     in the client certificate chain.  PR 55786.  [Yann Ylavic]\n\n  *) mod_reqtimeout: Fix body timeout disabling for CONNECT requests to avoid\n     triggering mod_proxy_connect's AH01018 once the tunnel is established.\n     [Yann Ylavic]\n\n  *) mod_crypto: Add the all purpose crypto filters with support for HLS.\n     [Graham Leggett]\n\n  *) core: Drop an invalid Last-Modified header value coming\n     from a FCGI/CGI script instead of replacing it with Unix epoch.\n     Warn the users about Last-Modified header value replacements\n     and violations of the RFC.\n     [Yann Ylavic, Luca Toscano, William Rowe, Jacob Champion]\n\n  *) mod_dav: Allow other modules to become providers and add ACLs\n     to the DAV response.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_dav: Add dav_begin_multistatus, dav_send_one_response,\n     dav_finish_multistatus, dav_send_multistatus, dav_handle_err,\n     dav_failed_proppatch, dav_success_proppatch to mod_dav.h.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_proxy, mod_ssl: Handle SSLProxy* directives in <Proxy> sections,\n     allowing per backend TLS configuration.  [Yann Ylavic]\n\n  *) core: explicitly exclude 'h2' from protocols announced via an Upgrade: \n     header as commanded by http-wg. [Stefan Eissing]\n\n  *) mod_proxy_ajp: Add \"secret\" parameter to proxy workers to implement legacy\n     AJP13 authentication.  PR 53098.  [Dmitry A. Bakshaev <dab1818 gmail com>]\n\n  *) mpm_event: Don't take over scoreboard slots from gracefully finishing\n     threads. [Stefan Fritsch]\n\n  *) mod_status: Display the process slot number in the async connection\n     overview. [Stefan Fritsch]\n\n  *) mpm: Generalise the ap_mpm_register_socket functions to accept pipes\n     or sockets. [Graham Leggett]\n\n  *) core: Extend support for setting aside data from the network input filter\n     to any connection or request input filter. [Graham Leggett]\n\n  *) core: Split ap_create_request() from ap_read_request(). [Graham Leggett]\n\n  *) mod_auth_digest: Fix compatibility with expression-based Authname. PR59039.\n     [Eric Covener]\n\n  *) mpm: Add a complete_connection hook that confirms whether an MPM is allowed\n     to leave the WRITE_COMPLETION phase. Move filter code out of the MPMs.\n     [Graham Leggett]\n\n  *) core: Added support for HTTP code 451. PR58985.\n     [Yehuda Katz <yehuda ymkatz.net>, Jim Jagielski]\n\n  *) mod_ssl: Add support for OpenSSL 1.1.0. [Rainer Jung]\n\n  *) mod_filter: Fix AddOutputFilterByType with non-content-level filters.\n     PR58856 [Micha Lenk <micha lenk.info>]\n\n  *) mod_cache: Consider Cache-Control: s-maxage in expiration\n     calculations.  [Eric Covener]\n\n  *) mod_cache: Allow caching of responses with an Expires header\n     in the past that also has Cache-Control: max-age or s-maxage.\n     PR55156. [Eric Covener]\n\n  *) Added many log numbers to log statements that had none.\n\n  *) mod_session: Introduce SessionExpiryUpdateInterval which allows to\n     configure the session/cookie expiry's update interval. PR 57300.\n     [Paul Spangler <paul.spangler ni.com>]\n\n  *) core: Extend support for asynchronous write completion from the\n     network filter to any connection or request filter. [Graham Leggett]\n\n  *) mpm_event: Free memory earlier when shutting down processes.\n     [Stefan Fritsch]\n\n  *) mod_auth_digest: remove AuthDigestEnableQueryStringHack which is no\n     more documented since dec 2012 (r1415960). [Christophe Jaillet]\n\n  *) mod_charset_lite: On EBCDIC platforms, make sure mod_charset_lite runs\n     after other resource-level filters. [Eric Covener]\n\n  *) mod_dir: Responses that go through \"FallbackResource\" might appear to\n     hang due to unterminated chunked encoding. PR58292. [Eric Covener]\n\n  *) http: Don't remove the Content-Length of zero from a HEAD response if\n     it comes from an origin server, module or script.  [Yann Ylavic]\n\n  *) http: Add support for RFC2324/RFC7168. [Graham Leggett]\n\n  *) mod_rewrite: Add support for starting External Rewriting Programs\n     as non-root user on UNIX systems by specifying username and group name\n     as third argument of RewriteMap directive. [Jan Kaluza]\n\n  *) mod_authn_core: Add expression support to AuthName and AuthType.\n     [Graham Leggett]\n\n  *) suexec: Filter out the HTTP_PROXY environment variable because it is\n     treated as alias for http_proxy by some programs. [Stefan Fritsch]\n\n  *) mod_proxy_http: Don't establish or reuse a backend connection before pre-\n     fetching the request body, so to minimize the delay between it is supposed\n     to be alive and the first bytes sent: this is a best effort to prevent the\n     backend from closing because of idle or keepalive timeout in the meantime.\n     Also, handle a new \"proxy-flushall\" environment variable which allows to\n     flush any forwarded body data immediately. PR 56541+37920. [Yann Ylavic]\n\n  *) core: Define and UnDefine are no longer permitted in\n     directory context. Previously they would always be evaulated\n     as the configuration was read without regard for the directory\n     context. [Eric Covener]\n\n  *) config: For directives that do not expect any arguments, enforce\n     that none are specified in the configuration file. \n     [Joachim Zobel <jzobel heute-morgen.de>, Eric Covener]\n\n  *) mod_rewrite: Improve 'bad flag delimeters' startup error by showing\n     how the input was tokenized.  PR 56528. [Edward Lu <Chaosed0 gmail.com>]\n\n  *) mod_proxy: Don't put non balancer-member workers in error state by\n     default for connection or 500/503 errors, and honor status=+I for\n     any error.  PR 48388.  [Yann Ylavic]\n\n  *) mod_socache_memcache: Pass expiration time through to memcached. PR 55445.\n     [Faidon Liambotis <paravoid debian.org>, Joe Orton]\n\n  *) ap_expr: Add filemod function for checking file modification dates\n     [Daniel Gruno]\n\n  *) mod_authnz_ldap: Resolve crashes with LDAP authz and non-LDAP authn since \n     r1608202. [Eric Covener]\n\n  *) apreq: Content-Length header should be always interpreted as a decimal.\n     Leading 0 could be erroneously considered as an octal value. PR 56598.\n     [Chris Card <ctcard hotmail com>]\n\n  *) mod_proxy: Now allow for 191 character worker names, with non-fatal\n     errors if name is truncated. PR53218. [Jim Jagielski]\n\n  *) mod_ssl: Add optional function \"ssl_get_tls_cb\" to allow support\n     for channel bindings.  [Simo Sorce <simo redhat.com>]\n\n  *) mod_proxy_wstunnel: Concurrent websockets messages could be \n     lost or delayed with ProxyWebsocketAsync enabled.  \n     [Edward Lu <Chaosed0 gmail.com>]\n\n  *) core, mod_info: Add compiled and loaded PCRE versions to version\n     number display.  [Rainer Jung]\n\n  *) mod_authnz_ldap: Return LDAP connections to the pool before the handler\n     is run, instead of waiting until the end of the request. [Eric Covener]\n\n  *) mod_proxy_html: support automatic detection of doctype and processing\n     of FPIs.  PR56285 [Micha Lenk <micha lenk info>, Nick Kew]\n\n  *) mod_proxy_html: skip documents shorter than 4 bytes\n     PR 56286 [Micha Lenk <micha lenk info>]\n\n  *) mod_proxy_fdpass: Fix computation of the size of 'struct sockaddr_un'\n     when passed to 'connect()'.\n     [Graham Dumpleton <grahamd apache org>]\n\n  *) core: Add ap_mpm_resume_suspended() API to allow a suspended connection\n     to resume. PR56333 \n     [Artem <artemciy gmail.com>, Edward Lu <Chaosed0 gmail.com>]\n\n  *) core: Add ap_mpm_register_socket_callback_timeout() API. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Honor ProxyWebsocketIdleTimeout in asynchronous\n     processing mode. [Eric Covener]\n\n  *) mod_authnz_ldap: Fail explicitly when the filter is too long. Remove\n     unnecessary apr_pstrdup() and strlen(). [Graham Leggett]\n\n  *) Add the ldap-search option to mod_authnz_ldap, allowing authorization\n     to be based on arbitrary expressions that do not include the username.\n     [Graham Leggett]\n\n  *) Add the ldap function to the expression API, allowing LDAP filters and\n     distinguished names based on expressions to be escaped correctly to\n     guard against LDAP injection. [Graham Leggett]\n\n  *) Add module mod_ssl_ct, which provides an implementation of Certificate\n     Transparency (RFC 6962) for httpd.  [Jeff Trawick]\n\n  *) mod_proxy_wstunnel: Avoid sending error responses down an upgraded\n     websockets connection as it is being close down. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Allow the administrator to cap the amount\n     of time a synchronous websockets connection stays idle with \n     ProxyWebsocketIdleTimeout. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Change to opt-in for asynchronous support, adding \n     directives ProxyWebsocketAsync and ProxyWebsocketAsyncDelay. \n     [Eric Covener]\n\n  *) mod_proxy_wstunnel: Stop leaking websockets backend connections under\n     event MPM (trunk-only). [Eric Covener]\n\n  *) mod_proxy_http: Add detach_backend hook (potentially usable\n     in other proxy scheme handlers).  [Jeff Trawick]\n\n  *) mod_deflate: Add DeflateAlterETag to control how the ETag\n     is modified. The 'NoChange' parameter mimics 2.2.x behavior.\n     PR 45023, PR 39727. [Eric Covener]\n\n  *) mod_rewrite: Add 'BNF' (backreferences-no-plus) flag to RewriteRule to \n     allow spaces in backreferences to be encoded as %20 instead of '+'.\n     [Eric Covener]\n\n  *) mod_rewrite: Support an optional list of characters to escape in the \n     argument for the 'B' (escape backreferences) flag. [Eric Covener]\n\n  *) mod_dir: Default to 2.2-like behavior and skip execution when method is\n     neither GET nor POST, such as for DAV requests. PR 54914. [Chris Darroch]\n\n  *) mod_rewrite: Rename the handler that does per-directory internal \n     redirects to \"rewrite-redirect-handler\" from \"redirect-handler\" so\n     it is less ambiguous and less likely to be reused. [Eric Covener]\n\n  *) mod_rewrite: Protect against looping with the [N] flag by enforcing a \n     default limit of 10000 iterations, and allowing each rule to change its\n     limit. [Eric Covener]\n\n  *) mod_ssl: Fix config merging of SSLOCSPEnable and SSLOCSPOverrideResponder.\n     [Jeff Trawick]\n\n  *) Add HttpContentLengthHeadZero and HttpExpectStrict directives.\n     [Yehuda Sadeh <yehuda inktank com>, Justin Erenkrantz]\n\n  *) mod_ssl: Add -t -DDUMP_CA_CERTS option which dumps the filenames of all\n     configured SSL CA certificates to stdout the same way as DUMP_CERTS does.\n     [Jan Kaluza]\n\n  *) mod_ssl: Don't flush when an EOS is received. Prepares mod_ssl\n     to support write completion. [Graham Leggett]\n\n  *) core: Add parse_errorlog_arg callback to ap_errorlog_provider\n     to allow providers to check the ErrorLog argument. [Jan Kaluza]\n\n  *) mod_cgid: Use the servers Timeout for each read from a CGI script,\n     allow override with new CGIDRequestTimeout directive. PR43494\n     [Eric Covener, Toshikuni Fukaya <toshikuni-fukaya cybozu co jp>]\n\n  *) core: ensure any abnormal exit is reported to stderr if it's a tty.\n     PR 55670 [Nick Kew]\n\n  *) mod_lua: Let the Inter-VM get/set functions work with a global \n     shared memory pool instead of a per-process pool. [Daniel Gruno]\n\n  *) ldap: Support ldaps when using the Microsoft LDAP SDK.\n     PR 54626. [Jean-Frederic Clere]\n\n  *) mod_authnz_ldap: Change default value of AuthLDAPMaxSubGroupDepth to 0\n     to avoid performance problems when subgroups aren't in use. [Eric Covener]\n\n  *) mod_syslog: New module implementing syslog ap_error_log provider.\n     Previously, this code was part of core, now it's in separate module.\n     [Jan Kaluza]\n\n  *) core: Add ap_errorlog_provider to make ErrorLog logging modular. Move\n     syslog support from core to new mod_syslog. [Jan Kaluza]\n\n  *) mod_status, mod_echo: Fix the display of client addresses.\n     They were truncated to 31 characters which is not enough for IPv6 addresses.\n     PR 54848 [Bernhard Schmidt <berni birkenwald de>]\n\n  *) mod_unique_id: Use output of the PRNG rather than IP address and\n     pid, avoiding sleep() call and possible DNS issues at startup,\n     plus improving randomness for IPv6-only hosts.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) mod_file_cache: mod_file_cache should be able to serve files that\n     haven't had a Content-Type set via e.g. mod_mime. [Eric Covener]\n\n  *) core: merge AllowEncodedSlashes from the base configuration into\n     virtual hosts. [Eric Covener]\n\n  *) AIX: Install DSO's with \"cp\" instead of \"install\" in instdso.sh\n     [Eric Covener]\n\n  *) mod_ldap: Don't keep retrying if a new LDAP connection times out.\n     [Eric Covener]\n\n  *) mod_deflate: permit compilation of mod_deflate against a zlib that has\n     been configured with -D Z_PREFIX, which redefines the token \"deflate\".\n     [Eric Covener]\n\n  *) mod_auth_digest: Use the secret when generating nonces in all cases and\n     not only when AuthName is used in .htaccess files (this change may cause\n     problems if used with round robin load balancers). Don't regenerate the\n     secret on graceful restarts. PR 54637  [Stefan Fritsch]\n\n  *) core: Remove apr_brigade_flatten(), buffering and duplicated code\n     from the HTTP_IN filter, parse chunks in a single pass with zero copy.\n     Reduce memory usage by 48 bytes per request. [Graham Leggett]\n\n  *) core: Stop the HTTP_IN filter from attempting to write error buckets\n     to the output filters, which is bogus in the proxy case. Create a\n     clean mapping from APR codes to HTTP status codes, and use it where\n     needed. [Graham Leggett]\n\n  *) mod_proxy: Ensure network errors detected by the proxy are returned as\n     504 Gateway Timout as opposed to 502 Bad Gateway, in order to be\n     compliant with RFC2616 14.9.4 Cache Revalidation and Reload Controls.\n\n  *) mod_dav: mod_dav overrides dav_fs response on PUT failure. PR 35981\n     [Basant Kumar Kukreja <basant.kukreja sun.com>, Alejandro Alvarez\n     <alejandro.alvarez.ayllon cern.ch>]\n\n  *) mod_ldap: LDAP connections used for authentication were not respecting\n     LDAPConnectionPoolTimeout.  PR 54587\n\n  *) core: ap_rgetline_core now pulls from r->proto_input_filters.\n\n  *) mod_proxy_html: process parsed comments immediately. \n     Fixes bug where parsed comments may be lost. [Nick Kew]\n\n  *) mod_proxy_html: introduce doctype for HTML 5 [Nick Kew]\n\n  *) mod_proxy_html: fix typo-bug processing \"strict\" vs \"transitional\"\n     HTML/XHTML [Nick Kew]\n\n  *) core: Add option to add valgrind support. Use it to reduce false positive\n     warnings in mod_ssl. [Stefan Fritsch]\n\n  *) mod_authn_file, mod_authn_dbd, mod_authn_dbm, mod_authn_socache:\n     Cache the result of the most recent password hash verification for every\n     keep-alive connection. This saves some expensive calculations.\n     [Stefan Fritsch]\n\n  *) http: Remove support for Request-Range header sent by Navigator 2-3 and\n     MSIE 3. [Stefan Fritsch]\n\n  *) core, http: Extend HttpProtocol with an option to enforce stricter HTTP\n     conformance or to only log the found problems. [Stefan Fritsch]\n\n  *) core: Correctly parse an IPv6 literal host specification in an absolute\n     URL in the request line. [Stefan Fritsch]\n\n  *) EventOpt MPM\n\n  *) core: Add LogLevelOverride directive that allows to override the\n     loglevel for clients from certain IPs. This also works for things\n     like the SSL handshake where <If> LogLevel ... </If> is evaluated\n     too late. [Stefan Fritsch]\n\n  *) core: Add new directive Warning to issue warnings from a configuration\n     file. Both Warning and Error now generate a timestamped log message.\n     [Fabien Coelho] \n\n  *) ap_expr: Add SERVER_PROTOCOL_VERSION, ..._MAJOR, and ..._MINOR\n     variables. [Stefan Fritsch]\n\n  *) core: New directive RegisterHttpMethod for registering non-standard\n     HTTP methods. [Stefan Fritsch]\n\n  *) core: New directive HttpProtocol which allows to disable HTTP/0.9\n     support. [Stefan Fritsch]\n\n  *) mod_allowhandlers: New module to forbid specific handlers for specific\n     directories. [Stefan Fritsch]\n\n  *) mod_systemd: New module, for integration with systemd on Linux.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) WinNT MPM: Store pid and generation for each thread in scoreboard\n     to allow tracking of threads from exiting children via mod_status\n     or other such mechanisms.  [Jeff Trawick]\n\n  *) The following now respect DefaultRuntimeDir/DEFAULT_REL_RUNTIMEDIR:\n     - APIs: ap_log_pid(), ap_remove_pid, ap_read_pid()\n     - mod_cache: thundering herd lock directory\n     - mod_lbmethod_heartbeat, mod_heartmonitor: heartbeat storage file\n     - mod_ldap: shared memory cache\n     - mod_socache_shmcb, mod_socache_dbm: shared memory or dbm for cache\n     [Jeff Trawick]\n\n  *) suexec: Add --enable-suexec-capabilites support on Linux, to use\n     setuid/setgid capability bits rather than a setuid root binary.\n     [Joe Orton]\n\n  *) suexec: Add support for logging to syslog as an alternative to logging\n     to a file; configure --without-suexec-logfile --with-suexec-syslog.  \n     [Joe Orton]\n\n  *) mod_ssl: Add support for TLS Next Protocol Negotiation.  PR 52210.\n     [Matthew Steele <mdsteele google.com>]\n\n  *) cross-compile: allow to provide CC_FOR_BUILD so that gen_test_char will\n     be compiled by the build compiler instead of the host compiler.\n     Also set CC_FOR_BUILD to 'cc' when cross-compilation is detected.\n     PR 51257. [Guenter Knauf]\n\n  *) core: In maintainer mode, replace apr_palloc with a version that\n     initializes the allocated memory with non-zero values, except if\n     AP_DEBUG_NO_ALLOC_POISON is defined. [Stefan Fritsch]\n\n  *) mod_policy: Add a new testing module to help server administrators\n     enforce a configurable level of protocol compliance on their\n     servers and application servers behind theirs. [Graham Leggett]\n\n  *) mod_firehose: Add a new debugging module able to record traffic\n     passing through the server in such a way that connections and/or\n     requests be reconstructed and replayed. [Graham Leggett]\n\n  *) mod_noloris\n\n  *) APREQ\n\n  *) Simple MPM\n\n  *) mod_serf\n\n  [Apache 2.5.0-dev includes those bug fixes and changes with the\n   Apache 2.4.xx tree as documented below, except as noted.]\n\nChanges with Apache 2.4.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.4.x/CHANGES?view=markup\n\nChanges with Apache 2.2.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.2.x/CHANGES?view=markup\n\nChanges with Apache 2.0.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.0.x/CHANGES?view=markup\n\n", "/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <assert.h>\n#include <stddef.h>\n#include <apr_thread_cond.h>\n#include <apr_base64.h>\n#include <apr_strings.h>\n\n#include <ap_mpm.h>\n\n#include <httpd.h>\n#include <http_core.h>\n#include <http_config.h>\n#include <http_log.h>\n#include <scoreboard.h>\n\n#include \"h2_private.h\"\n#include \"h2.h\"\n#include \"h2_bucket_eoc.h\"\n#include \"h2_bucket_eos.h\"\n#include \"h2_config.h\"\n#include \"h2_ctx.h\"\n#include \"h2_filter.h\"\n#include \"h2_h2.h\"\n#include \"h2_mplx.h\"\n#include \"h2_push.h\"\n#include \"h2_request.h\"\n#include \"h2_headers.h\"\n#include \"h2_stream.h\"\n#include \"h2_task.h\"\n#include \"h2_session.h\"\n#include \"h2_util.h\"\n#include \"h2_version.h\"\n#include \"h2_workers.h\"\n\n\nstatic int h2_session_status_from_apr_status(apr_status_t rv)\n{\n    if (rv == APR_SUCCESS) {\n        return NGHTTP2_NO_ERROR;\n    }\n    else if (APR_STATUS_IS_EAGAIN(rv)) {\n        return NGHTTP2_ERR_WOULDBLOCK;\n    }\n    else if (APR_STATUS_IS_EOF(rv)) {\n        return NGHTTP2_ERR_EOF;\n    }\n    return NGHTTP2_ERR_PROTO;\n}\n\nstatic void update_window(void *ctx, int stream_id, apr_off_t bytes_read)\n{\n    h2_session *session = (h2_session*)ctx;\n    nghttp2_session_consume(session->ngh2, stream_id, bytes_read);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                  \"h2_session(%ld-%d): consumed %ld bytes\",\n                  session->id, stream_id, (long)bytes_read);\n}\n\nstatic apr_status_t h2_session_receive(void *ctx, \n                                       const char *data, apr_size_t len,\n                                       apr_size_t *readlen);\n\nstatic void dispatch_event(h2_session *session, h2_session_event_t ev, \n                             int err, const char *msg);\n\napr_status_t h2_session_stream_done(h2_session *session, h2_stream *stream)\n{\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                  \"h2_stream(%ld-%d): EOS bucket cleanup -> done\", \n                  session->id, stream->id);\n    h2_mplx_stream_done(session->mplx, stream);\n    \n    dispatch_event(session, H2_SESSION_EV_STREAM_DONE, 0, NULL);\n    return APR_SUCCESS;\n}\n\ntypedef struct stream_sel_ctx {\n    h2_session *session;\n    h2_stream *candidate;\n} stream_sel_ctx;\n\nstatic int find_cleanup_stream(h2_stream *stream, void *ictx)\n{\n    stream_sel_ctx *ctx = ictx;\n    if (H2_STREAM_CLIENT_INITIATED(stream->id)) {\n        if (!ctx->session->local.accepting\n            && stream->id > ctx->session->local.accepted_max) {\n            ctx->candidate = stream;\n            return 0;\n        }\n    }\n    else {\n        if (!ctx->session->remote.accepting\n            && stream->id > ctx->session->remote.accepted_max) {\n            ctx->candidate = stream;\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic void cleanup_streams(h2_session *session)\n{\n    stream_sel_ctx ctx;\n    ctx.session = session;\n    ctx.candidate = NULL;\n    while (1) {\n        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);\n        if (ctx.candidate) {\n            h2_session_stream_done(session, ctx.candidate);\n            ctx.candidate = NULL;\n        }\n        else {\n            break;\n        }\n    }\n}\n\nh2_stream *h2_session_open_stream(h2_session *session, int stream_id,\n                                  int initiated_on, const h2_request *req)\n{\n    h2_stream * stream;\n    apr_pool_t *stream_pool;\n    \n    apr_pool_create(&stream_pool, session->pool);\n    apr_pool_tag(stream_pool, \"h2_stream\");\n    \n    stream = h2_stream_open(stream_id, stream_pool, session, \n                            initiated_on);\n    nghttp2_session_set_stream_user_data(session->ngh2, stream_id, stream);\n    \n    if (req) {\n        h2_stream_set_request(stream, req);\n    }\n    \n    if (H2_STREAM_CLIENT_INITIATED(stream_id)) {\n        if (stream_id > session->remote.emitted_max) {\n            ++session->remote.emitted_count;\n            session->remote.emitted_max = stream->id;\n            session->local.accepted_max = stream->id;\n        }\n    }\n    else {\n        if (stream_id > session->local.emitted_max) {\n            ++session->local.emitted_count;\n            session->remote.emitted_max = stream->id;\n        }\n    }\n    dispatch_event(session, H2_SESSION_EV_STREAM_OPEN, 0, NULL);\n    \n    return stream;\n}\n\n/**\n * Determine the importance of streams when scheduling tasks.\n * - if both stream depend on the same one, compare weights\n * - if one stream is closer to the root, prioritize that one\n * - if both are on the same level, use the weight of their root\n *   level ancestors\n */\nstatic int spri_cmp(int sid1, nghttp2_stream *s1, \n                    int sid2, nghttp2_stream *s2, h2_session *session)\n{\n    nghttp2_stream *p1, *p2;\n    \n    p1 = nghttp2_stream_get_parent(s1);\n    p2 = nghttp2_stream_get_parent(s2);\n    \n    if (p1 == p2) {\n        int32_t w1, w2;\n        \n        w1 = nghttp2_stream_get_weight(s1);\n        w2 = nghttp2_stream_get_weight(s2);\n        return w2 - w1;\n    }\n    else if (!p1) {\n        /* stream 1 closer to root */\n        return -1;\n    }\n    else if (!p2) {\n        /* stream 2 closer to root */\n        return 1;\n    }\n    return spri_cmp(sid1, p1, sid2, p2, session);\n}\n\nstatic int stream_pri_cmp(int sid1, int sid2, void *ctx)\n{\n    h2_session *session = ctx;\n    nghttp2_stream *s1, *s2;\n    \n    s1 = nghttp2_session_find_stream(session->ngh2, sid1);\n    s2 = nghttp2_session_find_stream(session->ngh2, sid2);\n\n    if (s1 == s2) {\n        return 0;\n    }\n    else if (!s1) {\n        return 1;\n    }\n    else if (!s2) {\n        return -1;\n    }\n    return spri_cmp(sid1, s1, sid2, s2, session);\n}\n\nstatic apr_status_t stream_schedule(h2_session *session,\n                                    h2_stream *stream, int eos)\n{\n    (void)session;\n    return h2_stream_schedule(stream, eos, h2_session_push_enabled(session), \n                              stream_pri_cmp, session);\n}\n\n/*\n * Callback when nghttp2 wants to send bytes back to the client.\n */\nstatic ssize_t send_cb(nghttp2_session *ngh2,\n                       const uint8_t *data, size_t length,\n                       int flags, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    apr_status_t status;\n    \n    (void)ngh2;\n    (void)flags;\n    status = h2_conn_io_write(&session->io, (const char *)data, length);\n    if (status == APR_SUCCESS) {\n        return length;\n    }\n    if (APR_STATUS_IS_EAGAIN(status)) {\n        return NGHTTP2_ERR_WOULDBLOCK;\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c, APLOGNO(03062)\n                  \"h2_session: send error\");\n    return h2_session_status_from_apr_status(status);\n}\n\nstatic int on_invalid_frame_recv_cb(nghttp2_session *ngh2,\n                                    const nghttp2_frame *frame,\n                                    int error, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    (void)ngh2;\n    \n    if (APLOGcdebug(session->c)) {\n        char buffer[256];\n        \n        h2_util_frame_print(frame, buffer, sizeof(buffer)/sizeof(buffer[0]));\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03063)\n                      \"h2_session(%ld): recv invalid FRAME[%s], frames=%ld/%ld (r/s)\",\n                      session->id, buffer, (long)session->frames_received,\n                     (long)session->frames_sent);\n    }\n    return 0;\n}\n\nstatic h2_stream *get_stream(h2_session *session, int stream_id)\n{\n    return nghttp2_session_get_stream_user_data(session->ngh2, stream_id);\n}\n\nstatic int on_data_chunk_recv_cb(nghttp2_session *ngh2, uint8_t flags,\n                                 int32_t stream_id,\n                                 const uint8_t *data, size_t len, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    apr_status_t status = APR_SUCCESS;\n    h2_stream * stream;\n    int rv;\n    \n    (void)flags;\n    stream = get_stream(session, stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03064)\n                      \"h2_stream(%ld-%d): on_data_chunk for unknown stream\",\n                      session->id, (int)stream_id);\n        rv = nghttp2_submit_rst_stream(ngh2, NGHTTP2_FLAG_NONE, stream_id,\n                                       NGHTTP2_INTERNAL_ERROR);\n        if (nghttp2_is_fatal(rv)) {\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n        }\n        return 0;\n    }\n\n    /* FIXME: enabling setting EOS this way seems to break input handling\n     * in mod_proxy_http2. why? */\n    status = h2_stream_write_data(stream, (const char *)data, len,\n                                  0 /*flags & NGHTTP2_FLAG_END_STREAM*/);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                  \"h2_stream(%ld-%d): data_chunk_recv, written %ld bytes\",\n                  session->id, stream_id, (long)len);\n    if (status != APR_SUCCESS) {\n        update_window(session, stream_id, len);\n        rv = nghttp2_submit_rst_stream(ngh2, NGHTTP2_FLAG_NONE, stream_id,\n                                       H2_STREAM_RST(stream, H2_ERR_INTERNAL_ERROR));\n        if (nghttp2_is_fatal(rv)) {\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n        }\n    }\n    return 0;\n}\n\nstatic apr_status_t stream_release(h2_session *session, \n                                   h2_stream *stream,\n                                   uint32_t error_code) \n{\n    conn_rec *c = session->c;\n    apr_bucket *b;\n    apr_status_t status;\n    \n    if (!error_code) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                      \"h2_stream(%ld-%d): handled, closing\", \n                      session->id, (int)stream->id);\n        if (H2_STREAM_CLIENT_INITIATED(stream->id)) {\n            if (stream->id > session->local.completed_max) {\n                session->local.completed_max = stream->id;\n            }\n        }\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03065)\n                      \"h2_stream(%ld-%d): closing with err=%d %s\", \n                      session->id, (int)stream->id, (int)error_code,\n                      h2_h2_err_description(error_code));\n        h2_stream_rst(stream, error_code);\n    }\n    \n    b = h2_bucket_eos_create(c->bucket_alloc, stream);\n    APR_BRIGADE_INSERT_TAIL(session->bbtmp, b);\n    status = h2_conn_io_pass(&session->io, session->bbtmp);\n    apr_brigade_cleanup(session->bbtmp);\n    return status;\n}\n\nstatic int on_stream_close_cb(nghttp2_session *ngh2, int32_t stream_id,\n                              uint32_t error_code, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    h2_stream *stream;\n    \n    (void)ngh2;\n    stream = get_stream(session, stream_id);\n    if (stream) {\n        stream_release(session, stream, error_code);\n    }\n    return 0;\n}\n\nstatic int on_begin_headers_cb(nghttp2_session *ngh2,\n                               const nghttp2_frame *frame, void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    h2_stream *s;\n    \n    /* We may see HEADERs at the start of a stream or after all DATA\n     * streams to carry trailers. */\n    (void)ngh2;\n    s = get_stream(session, frame->hd.stream_id);\n    if (s) {\n        /* nop */\n    }\n    else {\n        s = h2_session_open_stream(userp, frame->hd.stream_id, 0, NULL);\n    }\n    return s? 0 : NGHTTP2_ERR_START_STREAM_NOT_ALLOWED;\n}\n\nstatic int on_header_cb(nghttp2_session *ngh2, const nghttp2_frame *frame,\n                        const uint8_t *name, size_t namelen,\n                        const uint8_t *value, size_t valuelen,\n                        uint8_t flags,\n                        void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    h2_stream * stream;\n    apr_status_t status;\n    \n    (void)flags;\n    stream = get_stream(session, frame->hd.stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c,\n                      APLOGNO(02920) \n                      \"h2_session:  stream(%ld-%d): on_header unknown stream\",\n                      session->id, (int)frame->hd.stream_id);\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n    \n    status = h2_stream_add_header(stream, (const char *)name, namelen,\n                                  (const char *)value, valuelen);\n    if (status == APR_ECONNRESET) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2-stream(%ld-%d): on_header, reset stream\",\n                      session->id, stream->id);\n        nghttp2_submit_rst_stream(ngh2, NGHTTP2_FLAG_NONE, stream->id,\n                                  NGHTTP2_INTERNAL_ERROR);\n    }\n    else if (status != APR_SUCCESS && !h2_stream_is_ready(stream)) {\n        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n    }\n    return 0;\n}\n\n/**\n * nghttp2 session has received a complete frame. Most, it uses\n * for processing of internal state. HEADER and DATA frames however\n * we need to handle ourself.\n */\nstatic int on_frame_recv_cb(nghttp2_session *ng2s,\n                            const nghttp2_frame *frame,\n                            void *userp)\n{\n    h2_session *session = (h2_session *)userp;\n    apr_status_t status = APR_SUCCESS;\n    h2_stream *stream;\n    \n    if (APLOGcdebug(session->c)) {\n        char buffer[256];\n        \n        h2_util_frame_print(frame, buffer, sizeof(buffer)/sizeof(buffer[0]));\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03066)\n                      \"h2_session(%ld): recv FRAME[%s], frames=%ld/%ld (r/s)\",\n                      session->id, buffer, (long)session->frames_received,\n                     (long)session->frames_sent);\n    }\n\n    ++session->frames_received;\n    switch (frame->hd.type) {\n        case NGHTTP2_HEADERS:\n            /* This can be HEADERS for a new stream, defining the request,\n             * or HEADER may come after DATA at the end of a stream as in\n             * trailers */\n            stream = get_stream(session, frame->hd.stream_id);\n            if (stream) {\n                int eos = (frame->hd.flags & NGHTTP2_FLAG_END_STREAM);\n                \n                if (h2_stream_is_scheduled(stream)) {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                                  \"h2_stream(%ld-%d): TRAILER, eos=%d\", \n                                  session->id, frame->hd.stream_id, eos);\n                    if (eos) {\n                        status = h2_stream_close_input(stream);\n                    }\n                }\n                else {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                                  \"h2_stream(%ld-%d): HEADER, eos=%d\", \n                                  session->id, frame->hd.stream_id, eos);\n                    status = stream_schedule(session, stream, eos);\n                }\n            }\n            else {\n                status = APR_EINVAL;\n            }\n            break;\n        case NGHTTP2_DATA:\n            stream = get_stream(session, frame->hd.stream_id);\n            if (stream) {\n                int eos = (frame->hd.flags & NGHTTP2_FLAG_END_STREAM);\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                              \"h2_stream(%ld-%d): DATA, len=%ld, eos=%d\", \n                              session->id, frame->hd.stream_id, \n                              (long)frame->hd.length, eos);\n                if (eos) {\n                    status = h2_stream_close_input(stream);\n                }\n            }\n            else {\n                status = APR_EINVAL;\n            }\n            break;\n        case NGHTTP2_PRIORITY:\n            session->reprioritize = 1;\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session:  stream(%ld-%d): PRIORITY frame \"\n                          \" weight=%d, dependsOn=%d, exclusive=%d\", \n                          session->id, (int)frame->hd.stream_id,\n                          frame->priority.pri_spec.weight,\n                          frame->priority.pri_spec.stream_id,\n                          frame->priority.pri_spec.exclusive);\n            break;\n        case NGHTTP2_WINDOW_UPDATE:\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session:  stream(%ld-%d): WINDOW_UPDATE \"\n                          \"incr=%d\", \n                          session->id, (int)frame->hd.stream_id,\n                          frame->window_update.window_size_increment);\n            break;\n        case NGHTTP2_RST_STREAM:\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03067)\n                          \"h2_session(%ld-%d): RST_STREAM by client, errror=%d\",\n                          session->id, (int)frame->hd.stream_id,\n                          (int)frame->rst_stream.error_code);\n            stream = get_stream(session, frame->hd.stream_id);\n            if (stream && stream->initiated_on) {\n                ++session->pushes_reset;\n            }\n            else {\n                ++session->streams_reset;\n            }\n            break;\n        case NGHTTP2_GOAWAY:\n            if (frame->goaway.error_code == 0 \n                && frame->goaway.last_stream_id == ((1u << 31) - 1)) {\n                /* shutdown notice. Should not come from a client... */\n                session->remote.accepting = 0;\n            }\n            else {\n                session->remote.accepted_max = frame->goaway.last_stream_id;\n                dispatch_event(session, H2_SESSION_EV_REMOTE_GOAWAY, \n                               frame->goaway.error_code, NULL);\n            }\n            break;\n        default:\n            if (APLOGctrace2(session->c)) {\n                char buffer[256];\n                \n                h2_util_frame_print(frame, buffer,\n                                    sizeof(buffer)/sizeof(buffer[0]));\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                              \"h2_session: on_frame_rcv %s\", buffer);\n            }\n            break;\n    }\n\n    if (status != APR_SUCCESS) {\n        int rv;\n        \n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c,\n                      APLOGNO(02923) \n                      \"h2_session: stream(%ld-%d): error handling frame\",\n                      session->id, (int)frame->hd.stream_id);\n        rv = nghttp2_submit_rst_stream(ng2s, NGHTTP2_FLAG_NONE,\n                                       frame->hd.stream_id,\n                                       NGHTTP2_INTERNAL_ERROR);\n        if (nghttp2_is_fatal(rv)) {\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n        }\n    }\n    \n    return 0;\n}\n\nstatic char immortal_zeros[H2_MAX_PADLEN];\n\nstatic int on_send_data_cb(nghttp2_session *ngh2, \n                           nghttp2_frame *frame, \n                           const uint8_t *framehd, \n                           size_t length, \n                           nghttp2_data_source *source, \n                           void *userp)\n{\n    apr_status_t status = APR_SUCCESS;\n    h2_session *session = (h2_session *)userp;\n    int stream_id = (int)frame->hd.stream_id;\n    unsigned char padlen;\n    int eos;\n    h2_stream *stream;\n    apr_bucket *b;\n    apr_off_t len = length;\n    \n    (void)ngh2;\n    (void)source;\n    if (frame->data.padlen > H2_MAX_PADLEN) {\n        return NGHTTP2_ERR_PROTO;\n    }\n    padlen = (unsigned char)frame->data.padlen;\n    \n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                  \"h2_stream(%ld-%d): send_data_cb for %ld bytes\",\n                  session->id, (int)stream_id, (long)length);\n                  \n    stream = get_stream(session, stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_NOTFOUND, session->c,\n                      APLOGNO(02924) \n                      \"h2_stream(%ld-%d): send_data, lookup stream\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    status = h2_conn_io_write(&session->io, (const char *)framehd, 9);\n    if (padlen && status == APR_SUCCESS) {\n        status = h2_conn_io_write(&session->io, (const char *)&padlen, 1);\n    }\n    \n    if (status != APR_SUCCESS) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2_stream(%ld-%d): writing frame header\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    status = h2_stream_read_to(stream, session->bbtmp, &len, &eos);\n    if (status != APR_SUCCESS) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2_stream(%ld-%d): send_data_cb, reading stream\",\n                      session->id, (int)stream_id);\n        apr_brigade_cleanup(session->bbtmp);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    else if (len != length) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                      \"h2_stream(%ld-%d): send_data_cb, wanted %ld bytes, \"\n                      \"got %ld from stream\",\n                      session->id, (int)stream_id, (long)length, (long)len);\n        apr_brigade_cleanup(session->bbtmp);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    if (padlen) {\n        b = apr_bucket_immortal_create(immortal_zeros, padlen, \n                                       session->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(session->bbtmp, b);\n    }\n    \n    status = h2_conn_io_pass(&session->io, session->bbtmp);\n    apr_brigade_cleanup(session->bbtmp);\n    \n    if (status == APR_SUCCESS) {\n        stream->out_data_frames++;\n        stream->out_data_octets += length;\n        return 0;\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c,\n                      APLOGNO(02925) \n                      \"h2_stream(%ld-%d): failed send_data_cb\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n}\n\nstatic int on_frame_send_cb(nghttp2_session *ngh2, \n                            const nghttp2_frame *frame,\n                            void *user_data)\n{\n    h2_session *session = user_data;\n    if (APLOGcdebug(session->c)) {\n        char buffer[256];\n        \n        h2_util_frame_print(frame, buffer, sizeof(buffer)/sizeof(buffer[0]));\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03068)\n                      \"h2_session(%ld): sent FRAME[%s], frames=%ld/%ld (r/s)\",\n                      session->id, buffer, (long)session->frames_received,\n                     (long)session->frames_sent);\n    }\n    ++session->frames_sent;\n    return 0;\n}\n\n#ifdef H2_NG2_INVALID_HEADER_CB\nstatic int on_invalid_header_cb(nghttp2_session *ngh2, \n                                const nghttp2_frame *frame, \n                                const uint8_t *name, size_t namelen, \n                                const uint8_t *value, size_t valuelen, \n                                uint8_t flags, void *user_data)\n{\n    h2_session *session = user_data;\n    if (APLOGcdebug(session->c)) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03456)\n                      \"h2_session(%ld-%d): denying stream with invalid header \"\n                      \"'%s: %s'\", session->id, (int)frame->hd.stream_id,\n                      apr_pstrndup(session->pool, (const char *)name, namelen),\n                      apr_pstrndup(session->pool, (const char *)value, valuelen));\n    }\n    return nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE,\n                                     frame->hd.stream_id, \n                                     NGHTTP2_PROTOCOL_ERROR);\n}\n#endif\n\n#define NGH2_SET_CALLBACK(callbacks, name, fn)\\\nnghttp2_session_callbacks_set_##name##_callback(callbacks, fn)\n\nstatic apr_status_t init_callbacks(conn_rec *c, nghttp2_session_callbacks **pcb)\n{\n    int rv = nghttp2_session_callbacks_new(pcb);\n    if (rv != 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c,\n                      APLOGNO(02926) \"nghttp2_session_callbacks_new: %s\",\n                      nghttp2_strerror(rv));\n        return APR_EGENERAL;\n    }\n    \n    NGH2_SET_CALLBACK(*pcb, send, send_cb);\n    NGH2_SET_CALLBACK(*pcb, on_frame_recv, on_frame_recv_cb);\n    NGH2_SET_CALLBACK(*pcb, on_invalid_frame_recv, on_invalid_frame_recv_cb);\n    NGH2_SET_CALLBACK(*pcb, on_data_chunk_recv, on_data_chunk_recv_cb);\n    NGH2_SET_CALLBACK(*pcb, on_stream_close, on_stream_close_cb);\n    NGH2_SET_CALLBACK(*pcb, on_begin_headers, on_begin_headers_cb);\n    NGH2_SET_CALLBACK(*pcb, on_header, on_header_cb);\n    NGH2_SET_CALLBACK(*pcb, send_data, on_send_data_cb);\n    NGH2_SET_CALLBACK(*pcb, on_frame_send, on_frame_send_cb);\n#ifdef H2_NG2_INVALID_HEADER_CB\n    NGH2_SET_CALLBACK(*pcb, on_invalid_header, on_invalid_header_cb);\n#endif\n    return APR_SUCCESS;\n}\n\nstatic void h2_session_destroy(h2_session *session)\n{\n    ap_assert(session);    \n\n    if (session->mplx) {\n        h2_mplx_set_consumed_cb(session->mplx, NULL, NULL);\n        h2_mplx_release_and_join(session->mplx, session->iowait);\n        session->mplx = NULL;\n    }\n\n    ap_remove_input_filter_byhandle((session->r? session->r->input_filters :\n                                     session->c->input_filters), \"H2_IN\");\n    if (session->ngh2) {\n        nghttp2_session_del(session->ngh2);\n        session->ngh2 = NULL;\n    }\n    if (session->c) {\n        h2_ctx_clear(session->c);\n    }\n\n    if (APLOGctrace1(session->c)) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                      \"h2_session(%ld): destroy\", session->id);\n    }\n    if (session->pool) {\n        apr_pool_destroy(session->pool);\n    }\n}\n\nstatic apr_status_t h2_session_shutdown_notice(h2_session *session)\n{\n    apr_status_t status;\n    \n    ap_assert(session);\n    if (!session->local.accepting) {\n        return APR_SUCCESS;\n    }\n    \n    nghttp2_submit_shutdown_notice(session->ngh2);\n    session->local.accepting = 0;\n    status = nghttp2_session_send(session->ngh2);\n    if (status == APR_SUCCESS) {\n        status = h2_conn_io_flush(&session->io);\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03457)\n                  \"session(%ld): sent shutdown notice\", session->id);\n    return status;\n}\n\nstatic apr_status_t h2_session_shutdown(h2_session *session, int error, \n                                        const char *msg, int force_close)\n{\n    apr_status_t status = APR_SUCCESS;\n    \n    ap_assert(session);\n    if (session->local.shutdown) {\n        return APR_SUCCESS;\n    }\n    if (!msg && error) {\n        msg = nghttp2_strerror(error);\n    }\n    \n    if (error || force_close) {\n        /* not a graceful shutdown, we want to leave... \n         * Do not start further streams that are waiting to be scheduled. \n         * Find out the max stream id that we habe been processed or\n         * are still actively working on.\n         * Remove all streams greater than this number without submitting\n         * a RST_STREAM frame, since that should be clear from the GOAWAY\n         * we send. */\n        session->local.accepted_max = h2_mplx_shutdown(session->mplx);\n        session->local.error = error;\n    }\n    else {\n        /* graceful shutdown. we will continue processing all streams\n         * we have, but no longer accept new ones. Report the max stream\n         * we have received and discard all new ones. */\n    }\n    nghttp2_submit_goaway(session->ngh2, NGHTTP2_FLAG_NONE, \n                          session->local.accepted_max, \n                          error, (uint8_t*)msg, msg? strlen(msg):0);\n    session->local.accepting = 0;\n    session->local.shutdown = 1;\n    status = nghttp2_session_send(session->ngh2);\n    if (status == APR_SUCCESS) {\n        status = h2_conn_io_flush(&session->io);\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03069)\n                  \"session(%ld): sent GOAWAY, err=%d, msg=%s\", \n                  session->id, error, msg? msg : \"\");\n    dispatch_event(session, H2_SESSION_EV_LOCAL_GOAWAY, error, msg);\n    \n    if (force_close) {\n        apr_brigade_cleanup(session->bbtmp);\n        h2_mplx_abort(session->mplx);\n    }\n    \n    return status;\n}\n\nstatic apr_status_t session_pool_cleanup(void *data)\n{\n    h2_session *session = data;\n    /* On a controlled connection shutdown, this gets never\n     * called as we deregister and destroy our pool manually.\n     * However when we have an async mpm, and handed it our idle\n     * connection, it will just cleanup once the connection is closed\n     * from the other side (and sometimes even from out side) and\n     * here we arrive then.\n     */\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                  \"session(%ld): pool_cleanup\", session->id);\n    \n    if (session->state != H2_SESSION_ST_DONE) {\n        /* Not good. The connection is being torn down and we have\n         * not sent a goaway. This is considered a protocol error and\n         * the client has to assume that any streams \"in flight\" may have\n         * been processed and are not safe to retry.\n         * As clients with idle connection may only learn about a closed\n         * connection when sending the next request, this has the effect\n         * that at least this one request will fail.\n         */\n        ap_log_cerror(APLOG_MARK, APLOG_WARNING, 0, session->c, APLOGNO(03199)\n                      \"session(%ld): connection disappeared without proper \"\n                      \"goodbye, clients will be confused, should not happen\", \n                      session->id);\n    }\n    /* keep us from destroying the pool, since that is already ongoing. */\n    session->pool = NULL;\n    h2_session_destroy(session);\n    return APR_SUCCESS;\n}\n\nstatic void *session_malloc(size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): malloc(%ld)\",\n                  session->id, (long)size);\n    return malloc(size);\n}\n\nstatic void session_free(void *p, void *ctx)\n{\n    h2_session *session = ctx;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): free()\",\n                  session->id);\n    free(p);\n}\n\nstatic void *session_calloc(size_t n, size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): calloc(%ld, %ld)\",\n                  session->id, (long)n, (long)size);\n    return calloc(n, size);\n}\n\nstatic void *session_realloc(void *p, size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): realloc(%ld)\",\n                  session->id, (long)size);\n    return realloc(p, size);\n}\n\nstatic h2_session *h2_session_create_int(conn_rec *c,\n                                         request_rec *r,\n                                         h2_ctx *ctx, \n                                         h2_workers *workers)\n{\n    nghttp2_session_callbacks *callbacks = NULL;\n    nghttp2_option *options = NULL;\n    uint32_t n;\n\n    apr_pool_t *pool = NULL;\n    apr_status_t status = apr_pool_create(&pool, c->pool);\n    h2_session *session;\n    if (status != APR_SUCCESS) {\n        return NULL;\n    }\n    apr_pool_tag(pool, \"h2_session\");\n\n    session = apr_pcalloc(pool, sizeof(h2_session));\n    if (session) {\n        int rv;\n        nghttp2_mem *mem;\n        \n        session->id = c->id;\n        session->c = c;\n        session->r = r;\n        session->s = h2_ctx_server_get(ctx);\n        session->pool = pool;\n        session->config = h2_config_sget(session->s);\n        session->workers = workers;\n        \n        session->state = H2_SESSION_ST_INIT;\n        session->local.accepting = 1;\n        session->remote.accepting = 1;\n        \n        apr_pool_pre_cleanup_register(pool, session, session_pool_cleanup);\n        \n        session->max_stream_count = h2_config_geti(session->config, \n                                                   H2_CONF_MAX_STREAMS);\n        session->max_stream_mem = h2_config_geti(session->config, \n                                                 H2_CONF_STREAM_MAX_MEM);\n\n        status = apr_thread_cond_create(&session->iowait, session->pool);\n        if (status != APR_SUCCESS) {\n            return NULL;\n        }\n        \n        session->mplx = h2_mplx_create(c, session->pool, session->config, \n                                       session->s->timeout, workers);\n        \n        h2_mplx_set_consumed_cb(session->mplx, update_window, session);\n        \n        /* Install the connection input filter that feeds the session */\n        session->cin = h2_filter_cin_create(session->pool, \n                                            h2_session_receive, session);\n        ap_add_input_filter(\"H2_IN\", session->cin, r, c);\n\n        h2_conn_io_init(&session->io, c, session->config);\n        session->bbtmp = apr_brigade_create(session->pool, c->bucket_alloc);\n        \n        status = init_callbacks(c, &callbacks);\n        if (status != APR_SUCCESS) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, c, APLOGNO(02927) \n                          \"nghttp2: error in init_callbacks\");\n            h2_session_destroy(session);\n            return NULL;\n        }\n        \n        rv = nghttp2_option_new(&options);\n        if (rv != 0) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, c,\n                          APLOGNO(02928) \"nghttp2_option_new: %s\", \n                          nghttp2_strerror(rv));\n            h2_session_destroy(session);\n            return NULL;\n        }\n        nghttp2_option_set_peer_max_concurrent_streams(\n            options, (uint32_t)session->max_stream_count);\n        /* We need to handle window updates ourself, otherwise we\n         * get flooded by nghttp2. */\n        nghttp2_option_set_no_auto_window_update(options, 1);\n        \n        if (APLOGctrace6(c)) {\n            mem = apr_pcalloc(session->pool, sizeof(nghttp2_mem));\n            mem->mem_user_data = session;\n            mem->malloc    = session_malloc;\n            mem->free      = session_free;\n            mem->calloc    = session_calloc;\n            mem->realloc   = session_realloc;\n            \n            rv = nghttp2_session_server_new3(&session->ngh2, callbacks,\n                                             session, options, mem);\n        }\n        else {\n            rv = nghttp2_session_server_new2(&session->ngh2, callbacks,\n                                             session, options);\n        }\n        nghttp2_session_callbacks_del(callbacks);\n        nghttp2_option_del(options);\n        \n        if (rv != 0) {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, c,\n                          APLOGNO(02929) \"nghttp2_session_server_new: %s\",\n                          nghttp2_strerror(rv));\n            h2_session_destroy(session);\n            return NULL;\n        }\n         \n        n = h2_config_geti(session->config, H2_CONF_PUSH_DIARY_SIZE);\n        session->push_diary = h2_push_diary_create(session->pool, n);\n        \n        if (APLOGcdebug(c)) {\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03200)\n                          \"h2_session(%ld) created, max_streams=%d, \"\n                          \"stream_mem=%d, workers_limit=%d, workers_max=%d, \"\n                          \"push_diary(type=%d,N=%d)\",\n                          session->id, (int)session->max_stream_count, \n                          (int)session->max_stream_mem,\n                          session->mplx->workers_limit, \n                          session->mplx->workers_max, \n                          session->push_diary->dtype, \n                          (int)session->push_diary->N);\n        }\n    }\n    return session;\n}\n\nh2_session *h2_session_create(conn_rec *c, h2_ctx *ctx, h2_workers *workers)\n{\n    return h2_session_create_int(c, NULL, ctx, workers);\n}\n\nh2_session *h2_session_rcreate(request_rec *r, h2_ctx *ctx, h2_workers *workers)\n{\n    return h2_session_create_int(r->connection, r, ctx, workers);\n}\n\nvoid h2_session_eoc_callback(h2_session *session)\n{\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                  \"session(%ld): cleanup and destroy\", session->id);\n    apr_pool_cleanup_kill(session->pool, session, session_pool_cleanup);\n    h2_session_destroy(session);\n}\n\nstatic apr_status_t h2_session_start(h2_session *session, int *rv)\n{\n    apr_status_t status = APR_SUCCESS;\n    nghttp2_settings_entry settings[3];\n    size_t slen;\n    int win_size;\n    \n    ap_assert(session);\n    /* Start the conversation by submitting our SETTINGS frame */\n    *rv = 0;\n    if (session->r) {\n        const char *s, *cs;\n        apr_size_t dlen; \n        h2_stream * stream;\n\n        /* 'h2c' mode: we should have a 'HTTP2-Settings' header with\n         * base64 encoded client settings. */\n        s = apr_table_get(session->r->headers_in, \"HTTP2-Settings\");\n        if (!s) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, session->r,\n                          APLOGNO(02931) \n                          \"HTTP2-Settings header missing in request\");\n            return APR_EINVAL;\n        }\n        cs = NULL;\n        dlen = h2_util_base64url_decode(&cs, s, session->pool);\n        \n        if (APLOGrdebug(session->r)) {\n            char buffer[128];\n            h2_util_hex_dump(buffer, 128, (char*)cs, dlen);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, session->r, APLOGNO(03070)\n                          \"upgrading h2c session with HTTP2-Settings: %s -> %s (%d)\",\n                          s, buffer, (int)dlen);\n        }\n        \n        *rv = nghttp2_session_upgrade(session->ngh2, (uint8_t*)cs, dlen, NULL);\n        if (*rv != 0) {\n            status = APR_EINVAL;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, session->r,\n                          APLOGNO(02932) \"nghttp2_session_upgrade: %s\", \n                          nghttp2_strerror(*rv));\n            return status;\n        }\n        \n        /* Now we need to auto-open stream 1 for the request we got. */\n        stream = h2_session_open_stream(session, 1, 0, NULL);\n        if (!stream) {\n            status = APR_EGENERAL;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, session->r,\n                          APLOGNO(02933) \"open stream 1: %s\", \n                          nghttp2_strerror(*rv));\n            return status;\n        }\n        \n        status = h2_stream_set_request_rec(stream, session->r);\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n        status = stream_schedule(session, stream, 1);\n        if (status != APR_SUCCESS) {\n            return status;\n        }\n    }\n\n    slen = 0;\n    settings[slen].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\n    settings[slen].value = (uint32_t)session->max_stream_count;\n    ++slen;\n    win_size = h2_config_geti(session->config, H2_CONF_WIN_SIZE);\n    if (win_size != H2_INITIAL_WINDOW_SIZE) {\n        settings[slen].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n        settings[slen].value = win_size;\n        ++slen;\n    }\n    \n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c, APLOGNO(03201)\n                  \"h2_session(%ld): start, INITIAL_WINDOW_SIZE=%ld, \"\n                  \"MAX_CONCURRENT_STREAMS=%d\", \n                  session->id, (long)win_size, (int)session->max_stream_count);\n    *rv = nghttp2_submit_settings(session->ngh2, NGHTTP2_FLAG_NONE,\n                                  settings, slen);\n    if (*rv != 0) {\n        status = APR_EGENERAL;\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                      APLOGNO(02935) \"nghttp2_submit_settings: %s\", \n                      nghttp2_strerror(*rv));\n    }\n    else {\n        /* use maximum possible value for connection window size. We are only\n         * interested in per stream flow control. which have the initial window\n         * size configured above.\n         * Therefore, for our use, the connection window can only get in the\n         * way. Example: if we allow 100 streams with a 32KB window each, we\n         * buffer up to 3.2 MB of data. Unless we do separate connection window\n         * interim updates, any smaller connection window will lead to blocking\n         * in DATA flow.\n         */\n        *rv = nghttp2_submit_window_update(session->ngh2, NGHTTP2_FLAG_NONE,\n                                           0, NGHTTP2_MAX_WINDOW_SIZE - win_size);\n        if (*rv != 0) {\n            status = APR_EGENERAL;\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                          APLOGNO(02970) \"nghttp2_submit_window_update: %s\", \n                          nghttp2_strerror(*rv));        \n        }\n    }\n    \n    return status;\n}\n\nstatic apr_status_t on_stream_headers(h2_session *session, h2_stream *stream,  \n                                      h2_headers *headers, apr_off_t len,\n                                      int eos);\n\nstatic ssize_t stream_data_cb(nghttp2_session *ng2s,\n                              int32_t stream_id,\n                              uint8_t *buf,\n                              size_t length,\n                              uint32_t *data_flags,\n                              nghttp2_data_source *source,\n                              void *puser)\n{\n    h2_session *session = (h2_session *)puser;\n    apr_off_t nread = length;\n    int eos = 0;\n    apr_status_t status;\n    h2_stream *stream;\n    ap_assert(session);\n    \n    /* The session wants to send more DATA for the stream. We need\n     * to find out how much of the requested length we can send without\n     * blocking.\n     * Indicate EOS when we encounter it or DEFERRED if the stream\n     * should be suspended. Beware of trailers.\n     */\n \n    (void)ng2s;\n    (void)buf;\n    (void)source;\n    stream = get_stream(session, stream_id);\n    if (!stream) {\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, session->c,\n                      APLOGNO(02937) \n                      \"h2_stream(%ld-%d): data requested but stream not found\",\n                      session->id, (int)stream_id);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n\n    status = h2_stream_out_prepare(stream, &nread, &eos, NULL);\n    if (nread) {\n        *data_flags |=  NGHTTP2_DATA_FLAG_NO_COPY;\n    }\n    \n    switch (status) {\n        case APR_SUCCESS:\n            break;\n            \n        case APR_ECONNRESET:\n            return nghttp2_submit_rst_stream(ng2s, NGHTTP2_FLAG_NONE,\n                stream->id, stream->rst_error);\n            \n        case APR_EAGAIN:\n            /* If there is no data available, our session will automatically\n             * suspend this stream and not ask for more data until we resume\n             * it. Remember at our h2_stream that we need to do this.\n             */\n            nread = 0;\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03071)\n                          \"h2_stream(%ld-%d): suspending\",\n                          session->id, (int)stream_id);\n            return NGHTTP2_ERR_DEFERRED;\n            \n        default:\n            nread = 0;\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                          APLOGNO(02938) \"h2_stream(%ld-%d): reading data\",\n                          session->id, (int)stream_id);\n            return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    \n    if (eos) {\n        *data_flags |= NGHTTP2_DATA_FLAG_EOF;\n    }\n    return (ssize_t)nread;\n}\n\nstruct h2_stream *h2_session_push(h2_session *session, h2_stream *is,\n                                  h2_push *push)\n{\n    apr_status_t status;\n    h2_stream *stream;\n    h2_ngheader *ngh;\n    int nid;\n    \n    ngh = h2_util_ngheader_make_req(is->pool, push->req);\n    nid = nghttp2_submit_push_promise(session->ngh2, 0, is->id, \n                                      ngh->nv, ngh->nvlen, NULL);\n    if (nid <= 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03075)\n                      \"h2_stream(%ld-%d): submitting push promise fail: %s\",\n                      session->id, is->id, nghttp2_strerror(nid));\n        return NULL;\n    }\n    ++session->pushes_promised;\n    \n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03076)\n                  \"h2_stream(%ld-%d): SERVER_PUSH %d for %s %s on %d\",\n                  session->id, is->id, nid,\n                  push->req->method, push->req->path, is->id);\n                  \n    stream = h2_session_open_stream(session, nid, is->id, push->req);\n    if (stream) {\n        h2_session_set_prio(session, stream, push->priority);\n        status = stream_schedule(session, stream, 1);\n        if (status != APR_SUCCESS) {\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n                          \"h2_stream(%ld-%d): scheduling push stream\",\n                          session->id, stream->id);\n            stream = NULL;\n        }\n        ++session->unsent_promises;\n    }\n    else {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03077)\n                      \"h2_stream(%ld-%d): failed to create stream obj %d\",\n                      session->id, is->id, nid);\n    }\n\n    if (!stream) {\n        /* try to tell the client that it should not wait. */\n        nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE, nid,\n                                  NGHTTP2_INTERNAL_ERROR);\n    }\n    \n    return stream;\n}\n\nstatic int valid_weight(float f) \n{\n    int w = (int)f;\n    return (w < NGHTTP2_MIN_WEIGHT? NGHTTP2_MIN_WEIGHT : \n            (w > NGHTTP2_MAX_WEIGHT)? NGHTTP2_MAX_WEIGHT : w);\n}\n\napr_status_t h2_session_set_prio(h2_session *session, h2_stream *stream, \n                                 const h2_priority *prio)\n{\n    apr_status_t status = APR_SUCCESS;\n#ifdef H2_NG2_CHANGE_PRIO\n    nghttp2_stream *s_grandpa, *s_parent, *s;\n    \n    if (prio == NULL) {\n        /* we treat this as a NOP */\n        return APR_SUCCESS;\n    }\n    s = nghttp2_session_find_stream(session->ngh2, stream->id);\n    if (!s) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                      \"h2_stream(%ld-%d): lookup of nghttp2_stream failed\",\n                      session->id, stream->id);\n        return APR_EINVAL;\n    }\n    \n    s_parent = nghttp2_stream_get_parent(s);\n    if (s_parent) {\n        nghttp2_priority_spec ps;\n        int id_parent, id_grandpa, w_parent, w;\n        int rv = 0;\n        const char *ptype = \"AFTER\";\n        h2_dependency dep = prio->dependency;\n        \n        id_parent = nghttp2_stream_get_stream_id(s_parent);\n        s_grandpa = nghttp2_stream_get_parent(s_parent);\n        if (s_grandpa) {\n            id_grandpa = nghttp2_stream_get_stream_id(s_grandpa);\n        }\n        else {\n            /* parent of parent does not exist, \n             * only possible if parent == root */\n            dep = H2_DEPENDANT_AFTER;\n        }\n        \n        switch (dep) {\n            case H2_DEPENDANT_INTERLEAVED:\n                /* PUSHed stream is to be interleaved with initiating stream.\n                 * It is made a sibling of the initiating stream and gets a\n                 * proportional weight [1, MAX_WEIGHT] of the initiaing\n                 * stream weight.\n                 */\n                ptype = \"INTERLEAVED\";\n                w_parent = nghttp2_stream_get_weight(s_parent);\n                w = valid_weight(w_parent * ((float)prio->weight / NGHTTP2_MAX_WEIGHT));\n                nghttp2_priority_spec_init(&ps, id_grandpa, w, 0);\n                break;\n                \n            case H2_DEPENDANT_BEFORE:\n                /* PUSHed stream os to be sent BEFORE the initiating stream.\n                 * It gets the same weight as the initiating stream, replaces\n                 * that stream in the dependency tree and has the initiating\n                 * stream as child.\n                 */\n                ptype = \"BEFORE\";\n                w = w_parent = nghttp2_stream_get_weight(s_parent);\n                nghttp2_priority_spec_init(&ps, stream->id, w_parent, 0);\n                id_grandpa = nghttp2_stream_get_stream_id(s_grandpa);\n                rv = nghttp2_session_change_stream_priority(session->ngh2, id_parent, &ps);\n                if (rv < 0) {\n                    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03202)\n                                  \"h2_stream(%ld-%d): PUSH BEFORE, weight=%d, \"\n                                  \"depends=%d, returned=%d\",\n                                  session->id, id_parent, ps.weight, ps.stream_id, rv);\n                    return APR_EGENERAL;\n                }\n                nghttp2_priority_spec_init(&ps, id_grandpa, w, 0);\n                break;\n                \n            case H2_DEPENDANT_AFTER:\n                /* The PUSHed stream is to be sent after the initiating stream.\n                 * Give if the specified weight and let it depend on the intiating\n                 * stream.\n                 */\n                /* fall through, it's the default */\n            default:\n                nghttp2_priority_spec_init(&ps, id_parent, valid_weight(prio->weight), 0);\n                break;\n        }\n\n\n        rv = nghttp2_session_change_stream_priority(session->ngh2, stream->id, &ps);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03203)\n                      \"h2_stream(%ld-%d): PUSH %s, weight=%d, \"\n                      \"depends=%d, returned=%d\",\n                      session->id, stream->id, ptype, \n                      ps.weight, ps.stream_id, rv);\n        status = (rv < 0)? APR_EGENERAL : APR_SUCCESS;\n    }\n#else\n    (void)session;\n    (void)stream;\n    (void)prio;\n    (void)valid_weight;\n#endif\n    return status;\n}\n\nint h2_session_push_enabled(h2_session *session)\n{\n    /* iff we can and they can and want */\n    return (session->remote.accepting /* remote GOAWAY received */\n            && h2_config_geti(session->config, H2_CONF_PUSH)\n            && nghttp2_session_get_remote_settings(session->ngh2, \n                   NGHTTP2_SETTINGS_ENABLE_PUSH));\n}\n\nstatic apr_status_t h2_session_send(h2_session *session)\n{\n    apr_interval_time_t saved_timeout;\n    int rv;\n    apr_socket_t *socket;\n    \n    socket = ap_get_conn_socket(session->c);\n    if (socket) {\n        apr_socket_timeout_get(socket, &saved_timeout);\n        apr_socket_timeout_set(socket, session->s->timeout);\n    }\n    \n    rv = nghttp2_session_send(session->ngh2);\n    \n    if (socket) {\n        apr_socket_timeout_set(socket, saved_timeout);\n    }\n    session->have_written = 1;\n    if (rv != 0) {\n        if (nghttp2_is_fatal(rv)) {\n            dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, rv, nghttp2_strerror(rv));\n            return APR_EGENERAL;\n        }\n    }\n    \n    session->unsent_promises = 0;\n    session->unsent_submits = 0;\n    \n    return APR_SUCCESS;\n}\n\n/**\n * headers for the stream are ready.\n */\nstatic apr_status_t on_stream_headers(h2_session *session, h2_stream *stream,  \n                                      h2_headers *headers, apr_off_t len,\n                                      int eos)\n{\n    apr_status_t status = APR_SUCCESS;\n    int rv = 0;\n\n    ap_assert(session);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c, \n                  \"h2_stream(%ld-%d): on_headers\", session->id, stream->id);\n    if (headers->status < 100) {\n        int err = H2_STREAM_RST(stream, headers->status);\n        rv = nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE,\n                                       stream->id, err);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, \n                  \"h2_stream(%ld-%d): unpexected header status %d, stream rst\", \n                  session->id, stream->id, headers->status);\n        goto leave;\n    }\n    else if (stream->has_response) {\n        h2_ngheader *nh;\n        \n        nh = h2_util_ngheader_make(stream->pool, headers->headers);\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03072)\n                      \"h2_stream(%ld-%d): submit %d trailers\",\n                      session->id, (int)stream->id,(int) nh->nvlen);\n        rv = nghttp2_submit_trailer(session->ngh2, stream->id, nh->nv, nh->nvlen);\n        goto leave;\n    }\n    else {\n        nghttp2_data_provider provider, *pprovider = NULL;\n        h2_ngheader *ngh;\n        apr_table_t *hout;\n        const char *note;\n        \n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03073)\n                      \"h2_stream(%ld-%d): submit response %d, REMOTE_WINDOW_SIZE=%u\",\n                      session->id, stream->id, headers->status,\n                      (unsigned int)nghttp2_session_get_stream_remote_window_size(session->ngh2, stream->id));\n        \n        if (!eos || len > 0) {\n            memset(&provider, 0, sizeof(provider));\n            provider.source.fd = stream->id;\n            provider.read_callback = stream_data_cb;\n            pprovider = &provider;\n        }\n        \n        /* If this stream is not a pushed one itself,\n         * and HTTP/2 server push is enabled here,\n         * and the response HTTP status is not sth >= 400,\n         * and the remote side has pushing enabled,\n         * -> find and perform any pushes on this stream\n         *    *before* we submit the stream response itself.\n         *    This helps clients avoid opening new streams on Link\n         *    headers that get pushed right afterwards.\n         * \n         * *) the response code is relevant, as we do not want to \n         *    make pushes on 401 or 403 codes and friends. \n         *    And if we see a 304, we do not push either\n         *    as the client, having this resource in its cache, might\n         *    also have the pushed ones as well.\n         */\n        if (!stream->initiated_on\n            && !stream->has_response\n            && stream->request && stream->request->method\n            && !strcmp(\"GET\", stream->request->method)\n            && (headers->status < 400)\n            && (headers->status != 304)\n            && h2_session_push_enabled(session)) {\n            \n            h2_stream_submit_pushes(stream, headers);\n        }\n        \n        if (!stream->pref_priority) {\n            stream->pref_priority = h2_stream_get_priority(stream, headers);\n        }\n        h2_session_set_prio(session, stream, stream->pref_priority);\n        \n        hout = headers->headers;\n        note = apr_table_get(headers->notes, H2_FILTER_DEBUG_NOTE);\n        if (note && !strcmp(\"on\", note)) {\n            int32_t connFlowIn, connFlowOut;\n\n            connFlowIn = nghttp2_session_get_effective_local_window_size(session->ngh2); \n            connFlowOut = nghttp2_session_get_remote_window_size(session->ngh2);\n            hout = apr_table_clone(stream->pool, hout);\n            apr_table_setn(hout, \"conn-flow-in\", \n                           apr_itoa(stream->pool, connFlowIn));\n            apr_table_setn(hout, \"conn-flow-out\", \n                           apr_itoa(stream->pool, connFlowOut));\n        }\n        \n        if (headers->status == 103 \n            && !h2_config_geti(session->config, H2_CONF_EARLY_HINTS)) {\n            /* suppress sending this to the client, it might have triggered \n             * pushes and served its purpose nevertheless */\n            rv = 0;\n            goto leave;\n        }\n        \n        ngh = h2_util_ngheader_make_res(stream->pool, headers->status, hout);\n        rv = nghttp2_submit_response(session->ngh2, stream->id,\n                                     ngh->nv, ngh->nvlen, pprovider);\n        stream->has_response = h2_headers_are_response(headers);\n        session->have_written = 1;\n        \n        if (stream->initiated_on) {\n            ++session->pushes_submitted;\n        }\n        else {\n            ++session->responses_submitted;\n        }\n    }\n    \nleave:\n    if (nghttp2_is_fatal(rv)) {\n        status = APR_EGENERAL;\n        dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, rv, nghttp2_strerror(rv));\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, status, session->c,\n                      APLOGNO(02940) \"submit_response: %s\", \n                      nghttp2_strerror(rv));\n    }\n    \n    ++session->unsent_submits;\n    \n    /* Unsent push promises are written immediately, as nghttp2\n     * 1.5.0 realizes internal stream data structures only on \n     * send and we might need them for other submits. \n     * Also, to conserve memory, we send at least every 10 submits\n     * so that nghttp2 does not buffer all outbound items too \n     * long.\n     */\n    if (status == APR_SUCCESS \n        && (session->unsent_promises || session->unsent_submits > 10)) {\n        status = h2_session_send(session);\n    }\n    return status;\n}\n\n/**\n * A stream was resumed as new response/output data arrived.\n */\nstatic apr_status_t on_stream_resume(void *ctx, h2_stream *stream)\n{\n    h2_session *session = ctx;\n    apr_status_t status = APR_EAGAIN;\n    int rv;\n    apr_off_t len = 0;\n    int eos = 0;\n    h2_headers *headers;\n    \n    ap_assert(stream);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c, \n                  \"h2_stream(%ld-%d): on_resume\", session->id, stream->id);\n        \nsend_headers:\n    headers = NULL;\n    status = h2_stream_out_prepare(stream, &len, &eos, &headers);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, session->c, \n                  \"h2_stream(%ld-%d): prepared len=%ld, eos=%d\", \n                  session->id, stream->id, (long)len, eos);\n    if (headers) {\n        status = on_stream_headers(session, stream, headers, len, eos);\n        if (status != APR_SUCCESS || stream->rst_error) {\n            return status;\n        }\n        goto send_headers;\n    }\n    else if (status != APR_EAGAIN) {\n        if (!stream->has_response) {\n            int err = H2_STREAM_RST(stream, H2_ERR_PROTOCOL_ERROR);\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03466)\n                          \"h2_stream(%ld-%d): no response, RST_STREAM, err=%d\",\n                          session->id, stream->id, err);\n            nghttp2_submit_rst_stream(session->ngh2, NGHTTP2_FLAG_NONE,\n                                      stream->id, err);\n            return APR_SUCCESS;\n        } \n        rv = nghttp2_session_resume_data(session->ngh2, stream->id);\n        session->have_written = 1;\n        ap_log_cerror(APLOG_MARK, nghttp2_is_fatal(rv)?\n                      APLOG_ERR : APLOG_DEBUG, 0, session->c,\n                      APLOGNO(02936) \n                      \"h2_stream(%ld-%d): resuming %s\",\n                      session->id, stream->id, rv? nghttp2_strerror(rv) : \"\");\n    }\n    return status;\n}\n\nstatic apr_status_t h2_session_receive(void *ctx, const char *data, \n                                       apr_size_t len, apr_size_t *readlen)\n{\n    h2_session *session = ctx;\n    ssize_t n;\n    \n    if (len > 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                      \"h2_session(%ld): feeding %ld bytes to nghttp2\",\n                      session->id, (long)len);\n        n = nghttp2_session_mem_recv(session->ngh2, (const uint8_t *)data, len);\n        if (n < 0) {\n            if (nghttp2_is_fatal((int)n)) {\n                dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, (int)n, nghttp2_strerror((int)n));\n                return APR_EGENERAL;\n            }\n        }\n        else {\n            *readlen = n;\n            session->io.bytes_read += n;\n        }\n    }\n    return APR_SUCCESS;\n}\n\nstatic apr_status_t h2_session_read(h2_session *session, int block)\n{\n    apr_status_t status, rstatus = APR_EAGAIN;\n    conn_rec *c = session->c;\n    apr_off_t read_start = session->io.bytes_read;\n    \n    while (1) {\n        /* H2_IN filter handles all incoming data against the session.\n         * We just pull at the filter chain to make it happen */\n        status = ap_get_brigade(c->input_filters,\n                                session->bbtmp, AP_MODE_READBYTES,\n                                block? APR_BLOCK_READ : APR_NONBLOCK_READ,\n                                APR_BUCKET_BUFF_SIZE);\n        /* get rid of any possible data we do not expect to get */\n        apr_brigade_cleanup(session->bbtmp); \n\n        switch (status) {\n            case APR_SUCCESS:\n                /* successful read, reset our idle timers */\n                rstatus = APR_SUCCESS;\n                if (block) {\n                    /* successful blocked read, try unblocked to\n                     * get more. */\n                    block = 0;\n                }\n                break;\n            case APR_EAGAIN:\n                return rstatus;\n            case APR_TIMEUP:\n                return status;\n            default:\n                if (session->io.bytes_read == read_start) {\n                    /* first attempt failed */\n                    if (APR_STATUS_IS_ETIMEDOUT(status)\n                        || APR_STATUS_IS_ECONNABORTED(status)\n                        || APR_STATUS_IS_ECONNRESET(status)\n                        || APR_STATUS_IS_EOF(status)\n                        || APR_STATUS_IS_EBADF(status)) {\n                        /* common status for a client that has left */\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE1, status, c,\n                                      \"h2_session(%ld): input gone\", session->id);\n                    }\n                    else {\n                        /* uncommon status, log on INFO so that we see this */\n                        ap_log_cerror( APLOG_MARK, APLOG_DEBUG, status, c,\n                                      APLOGNO(02950) \n                                      \"h2_session(%ld): error reading, terminating\",\n                                      session->id);\n                    }\n                    return status;\n                }\n                /* subsequent failure after success(es), return initial\n                 * status. */\n                return rstatus;\n        }\n        if ((session->io.bytes_read - read_start) > (64*1024)) {\n            /* read enough in one go, give write a chance */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, c,\n                          \"h2_session(%ld): read 64k, returning\", session->id);\n            break;\n        }\n    }\n    return rstatus;\n}\n\nstatic const char *StateNames[] = {\n    \"INIT\",      /* H2_SESSION_ST_INIT */\n    \"DONE\",      /* H2_SESSION_ST_DONE */\n    \"IDLE\",      /* H2_SESSION_ST_IDLE */\n    \"BUSY\",      /* H2_SESSION_ST_BUSY */\n    \"WAIT\",      /* H2_SESSION_ST_WAIT */\n};\n\nstatic const char *state_name(h2_session_state state)\n{\n    if (state >= (sizeof(StateNames)/sizeof(StateNames[0]))) {\n        return \"unknown\";\n    }\n    return StateNames[state];\n}\n\nstatic void update_child_status(h2_session *session, int status, const char *msg)\n{\n    /* Assume that we also change code/msg when something really happened and\n     * avoid updating the scoreboard in between */\n    if (session->last_status_code != status \n        || session->last_status_msg != msg) {\n        apr_snprintf(session->status, sizeof(session->status),\n                     \"%s, streams: %d/%d/%d/%d/%d (open/recv/resp/push/rst)\", \n                     msg? msg : \"-\",\n                     (int)session->open_streams, \n                     (int)session->remote.emitted_count,\n                     (int)session->responses_submitted,\n                     (int)session->pushes_submitted,\n                     (int)session->pushes_reset + session->streams_reset);\n        ap_update_child_status_descr(session->c->sbh, status, session->status);\n    }\n}\n\nstatic void transit(h2_session *session, const char *action, h2_session_state nstate)\n{\n    if (session->state != nstate) {\n        int loglvl = APLOG_DEBUG;\n        if ((session->state == H2_SESSION_ST_BUSY && nstate == H2_SESSION_ST_WAIT)\n            || (session->state == H2_SESSION_ST_WAIT && nstate == H2_SESSION_ST_BUSY)){\n            loglvl = APLOG_TRACE1;\n        }\n        ap_log_cerror(APLOG_MARK, loglvl, 0, session->c, APLOGNO(03078)\n                      \"h2_session(%ld): transit [%s] -- %s --> [%s]\", session->id,\n                      state_name(session->state), action, state_name(nstate));\n        session->state = nstate;\n        switch (session->state) {\n            case H2_SESSION_ST_IDLE:\n                update_child_status(session, (session->open_streams == 0? \n                                              SERVER_BUSY_KEEPALIVE\n                                              : SERVER_BUSY_READ), \"idle\");\n                break;\n            case H2_SESSION_ST_DONE:\n                update_child_status(session, SERVER_CLOSING, \"done\");\n                break;\n            default:\n                /* nop */\n                break;\n        }\n    }\n}\n\nstatic void h2_session_ev_init(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_INIT:\n            transit(session, \"init\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_local_goaway(h2_session *session, int arg, const char *msg)\n{\n    cleanup_streams(session);\n    if (!session->remote.shutdown) {\n        update_child_status(session, SERVER_CLOSING, \"local goaway\");\n    }\n    transit(session, \"local goaway\", H2_SESSION_ST_DONE);\n}\n\nstatic void h2_session_ev_remote_goaway(h2_session *session, int arg, const char *msg)\n{\n    if (!session->remote.shutdown) {\n        session->remote.error = arg;\n        session->remote.accepting = 0;\n        session->remote.shutdown = 1;\n        cleanup_streams(session);\n        update_child_status(session, SERVER_CLOSING, \"remote goaway\");\n        transit(session, \"remote goaway\", H2_SESSION_ST_DONE);\n    }\n}\n\nstatic void h2_session_ev_conn_error(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_INIT:\n        case H2_SESSION_ST_DONE:\n            /* just leave */\n            transit(session, \"conn error\", H2_SESSION_ST_DONE);\n            break;\n        \n        default:\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03401)\n                          \"h2_session(%ld): conn error -> shutdown\", session->id);\n            h2_session_shutdown(session, arg, msg, 0);\n            break;\n    }\n}\n\nstatic void h2_session_ev_proto_error(h2_session *session, int arg, const char *msg)\n{\n    if (!session->local.shutdown) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03402)\n                      \"h2_session(%ld): proto error -> shutdown\", session->id);\n        h2_session_shutdown(session, arg, msg, 0);\n    }\n}\n\nstatic void h2_session_ev_conn_timeout(h2_session *session, int arg, const char *msg)\n{\n    transit(session, msg, H2_SESSION_ST_DONE);\n    if (!session->local.shutdown) {\n        h2_session_shutdown(session, arg, msg, 1);\n    }\n}\n\nstatic void h2_session_ev_no_io(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_BUSY:\n            /* Nothing to READ, nothing to WRITE on the master connection.\n             * Possible causes:\n             * - we wait for the client to send us sth\n             * - we wait for started tasks to produce output\n             * - we have finished all streams and the client has sent GO_AWAY\n             */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session(%ld): NO_IO event, %d streams open\", \n                          session->id, session->open_streams);\n            h2_conn_io_flush(&session->io);\n            if (session->open_streams > 0) {\n                if (h2_mplx_awaits_data(session->mplx)) {\n                    /* waiting for at least one stream to produce data */\n                    transit(session, \"no io\", H2_SESSION_ST_WAIT);\n                }\n                else {\n                    /* we have streams open, and all are submitted and none\n                     * is suspended. The only thing keeping us from WRITEing\n                     * more must be the flow control.\n                     * This means we only wait for WINDOW_UPDATE from the \n                     * client and can block on READ. */\n                    transit(session, \"no io (flow wait)\", H2_SESSION_ST_IDLE);\n                    session->idle_until = apr_time_now() + session->s->timeout;\n                    session->keep_sync_until = session->idle_until;\n                    /* Make sure we have flushed all previously written output\n                     * so that the client will react. */\n                    if (h2_conn_io_flush(&session->io) != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                        return;\n                    }\n                }\n            }\n            else if (session->local.accepting) {\n                /* When we have no streams, but accept new, switch to idle */\n                apr_time_t now = apr_time_now();\n                transit(session, \"no io (keepalive)\", H2_SESSION_ST_IDLE);\n                session->idle_until = (session->remote.emitted_count? \n                                       session->s->keep_alive_timeout : \n                                       session->s->timeout) + now;\n                session->keep_sync_until = now + apr_time_from_sec(1);\n            }\n            else {\n                /* We are no longer accepting new streams and there are\n                 * none left. Time to leave. */\n                h2_session_shutdown(session, arg, msg, 0);\n                transit(session, \"no io\", H2_SESSION_ST_DONE);\n            }\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_stream_ready(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_WAIT:\n            transit(session, \"stream ready\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_data_read(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n        case H2_SESSION_ST_WAIT:\n            transit(session, \"data read\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n\nstatic void h2_session_ev_ngh2_done(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_DONE:\n            /* nop */\n            break;\n        default:\n            transit(session, \"nghttp2 done\", H2_SESSION_ST_DONE);\n            break;\n    }\n}\n\nstatic void h2_session_ev_mpm_stopping(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_DONE:\n            /* nop */\n            break;\n        default:\n            h2_session_shutdown_notice(session);\n            break;\n    }\n}\n\nstatic void h2_session_ev_pre_close(h2_session *session, int arg, const char *msg)\n{\n    h2_session_shutdown(session, arg, msg, 1);\n}\n\nstatic void h2_session_ev_stream_open(h2_session *session, int arg, const char *msg)\n{\n    ++session->open_streams;\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n            if (session->open_streams == 1) {\n                /* enter tiomeout, since we have a stream again */\n                session->idle_until = (session->s->timeout + apr_time_now());\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nstatic void h2_session_ev_stream_done(h2_session *session, int arg, const char *msg)\n{\n    --session->open_streams;\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n            if (session->open_streams == 0) {\n                /* enter keepalive timeout, since we no longer have streams */\n                session->idle_until = (session->s->keep_alive_timeout\n                                       + apr_time_now());\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nstatic void dispatch_event(h2_session *session, h2_session_event_t ev, \n                      int arg, const char *msg)\n{\n    switch (ev) {\n        case H2_SESSION_EV_INIT:\n            h2_session_ev_init(session, arg, msg);\n            break;            \n        case H2_SESSION_EV_LOCAL_GOAWAY:\n            h2_session_ev_local_goaway(session, arg, msg);\n            break;\n        case H2_SESSION_EV_REMOTE_GOAWAY:\n            h2_session_ev_remote_goaway(session, arg, msg);\n            break;\n        case H2_SESSION_EV_CONN_ERROR:\n            h2_session_ev_conn_error(session, arg, msg);\n            break;\n        case H2_SESSION_EV_PROTO_ERROR:\n            h2_session_ev_proto_error(session, arg, msg);\n            break;\n        case H2_SESSION_EV_CONN_TIMEOUT:\n            h2_session_ev_conn_timeout(session, arg, msg);\n            break;\n        case H2_SESSION_EV_NO_IO:\n            h2_session_ev_no_io(session, arg, msg);\n            break;\n        case H2_SESSION_EV_STREAM_READY:\n            h2_session_ev_stream_ready(session, arg, msg);\n            break;\n        case H2_SESSION_EV_DATA_READ:\n            h2_session_ev_data_read(session, arg, msg);\n            break;\n        case H2_SESSION_EV_NGH2_DONE:\n            h2_session_ev_ngh2_done(session, arg, msg);\n            break;\n        case H2_SESSION_EV_MPM_STOPPING:\n            h2_session_ev_mpm_stopping(session, arg, msg);\n            break;\n        case H2_SESSION_EV_PRE_CLOSE:\n            h2_session_ev_pre_close(session, arg, msg);\n            break;\n        case H2_SESSION_EV_STREAM_OPEN:\n            h2_session_ev_stream_open(session, arg, msg);\n            break;\n        case H2_SESSION_EV_STREAM_DONE:\n            h2_session_ev_stream_done(session, arg, msg);\n            break;\n        default:\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c,\n                          \"h2_session(%ld): unknown event %d\", \n                          session->id, ev);\n            break;\n    }\n    \n    if (session->state == H2_SESSION_ST_DONE) {\n        apr_brigade_cleanup(session->bbtmp);\n        h2_mplx_abort(session->mplx);\n    }\n}\n\nstatic const int MAX_WAIT_MICROS = 200 * 1000;\n\napr_status_t h2_session_process(h2_session *session, int async)\n{\n    apr_status_t status = APR_SUCCESS;\n    conn_rec *c = session->c;\n    int rv, mpm_state, trace = APLOGctrace3(c);\n\n    if (trace) {\n        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                      \"h2_session(%ld): process start, async=%d\", \n                      session->id, async);\n    }\n                  \n    if (c->cs) {\n        c->cs->state = CONN_STATE_WRITE_COMPLETION;\n    }\n    \n    while (session->state != H2_SESSION_ST_DONE) {\n        trace = APLOGctrace3(c);\n        session->have_read = session->have_written = 0;\n\n        if (session->local.accepting \n            && !ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n            if (mpm_state == AP_MPMQ_STOPPING) {\n                dispatch_event(session, H2_SESSION_EV_MPM_STOPPING, 0, NULL);\n            }\n        }\n        \n        session->status[0] = '\\0';\n        \n        switch (session->state) {\n            case H2_SESSION_ST_INIT:\n                ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n                if (!h2_is_acceptable_connection(c, 1)) {\n                    update_child_status(session, SERVER_BUSY_READ, \"inadequate security\");\n                    h2_session_shutdown(session, NGHTTP2_INADEQUATE_SECURITY, NULL, 1);\n                } \n                else {\n                    update_child_status(session, SERVER_BUSY_READ, \"init\");\n                    status = h2_session_start(session, &rv);\n                    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, c, APLOGNO(03079)\n                                  \"h2_session(%ld): started on %s:%d\", session->id,\n                                  session->s->server_hostname,\n                                  c->local_addr->port);\n                    if (status != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                    }\n                    dispatch_event(session, H2_SESSION_EV_INIT, 0, NULL);\n                }\n                break;\n                \n            case H2_SESSION_ST_IDLE:\n                /* make certain, we send everything before we idle */\n                h2_conn_io_flush(&session->io);\n                if (!session->keep_sync_until && async && !session->open_streams\n                    && !session->r && session->remote.emitted_count) {\n                    if (trace) {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): async idle, nonblock read, \"\n                                      \"%d streams open\", session->id, \n                                      session->open_streams);\n                    }\n                    /* We do not return to the async mpm immediately, since under\n                     * load, mpms show the tendency to throw keep_alive connections\n                     * away very rapidly.\n                     * So, if we are still processing streams, we wait for the\n                     * normal timeout first and, on timeout, close.\n                     * If we have no streams, we still wait a short amount of\n                     * time here for the next frame to arrive, before handing\n                     * it to keep_alive processing of the mpm.\n                     */\n                    status = h2_session_read(session, 0);\n                    \n                    if (status == APR_SUCCESS) {\n                        session->have_read = 1;\n                        dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                    }\n                    else if (APR_STATUS_IS_EAGAIN(status) || APR_STATUS_IS_TIMEUP(status)) {\n                        if (apr_time_now() > session->idle_until) {\n                            dispatch_event(session, H2_SESSION_EV_CONN_TIMEOUT, 0, NULL);\n                        }\n                        else {\n                            status = APR_EAGAIN;\n                            goto out;\n                        }\n                    }\n                    else {\n                        ap_log_cerror( APLOG_MARK, APLOG_DEBUG, status, c,\n\t\t\t\t      APLOGNO(03403)\n                                      \"h2_session(%ld): idle, no data, error\", \n                                      session->id);\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, \"timeout\");\n                    }\n                }\n                else {\n                    if (trace) {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): sync idle, stutter 1-sec, \"\n                                      \"%d streams open\", session->id,\n                                      session->open_streams);\n                    }\n                    /* We wait in smaller increments, using a 1 second timeout.\n                     * That gives us the chance to check for MPMQ_STOPPING often. \n                     */\n                    status = h2_mplx_idle(session->mplx);\n                    if (status != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, \n                                       H2_ERR_ENHANCE_YOUR_CALM, \"less is more\");\n                    }\n                    h2_filter_cin_timeout_set(session->cin, apr_time_from_sec(1));\n                    status = h2_session_read(session, 1);\n                    if (status == APR_SUCCESS) {\n                        session->have_read = 1;\n                        dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                    }\n                    else if (status == APR_EAGAIN) {\n                        /* nothing to read */\n                    }\n                    else if (APR_STATUS_IS_TIMEUP(status)) {\n                        apr_time_t now = apr_time_now();\n                        if (now > session->keep_sync_until) {\n                            /* if we are on an async mpm, now is the time that\n                             * we may dare to pass control to it. */\n                            session->keep_sync_until = 0;\n                        }\n                        if (now > session->idle_until) {\n                            if (trace) {\n                                ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                              \"h2_session(%ld): keepalive timeout\",\n                                              session->id);\n                            }\n                            dispatch_event(session, H2_SESSION_EV_CONN_TIMEOUT, 0, \"timeout\");\n                        }\n                        else if (trace) {                        \n                            ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                          \"h2_session(%ld): keepalive, %f sec left\",\n                                          session->id, (session->idle_until - now) / 1000000.0f);\n                        }\n                        /* continue reading handling */\n                    }\n                    else if (APR_STATUS_IS_ECONNABORTED(status)\n                             || APR_STATUS_IS_ECONNRESET(status)\n                             || APR_STATUS_IS_EOF(status)\n                             || APR_STATUS_IS_EBADF(status)) {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): input gone\", session->id);\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                    }\n                    else {\n                        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                                      \"h2_session(%ld): idle(1 sec timeout) \"\n                                      \"read failed\", session->id);\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, \"error\");\n                    }\n                }\n                \n                break;\n                \n            case H2_SESSION_ST_BUSY:\n                if (nghttp2_session_want_read(session->ngh2)) {\n                    ap_update_child_status(session->c->sbh, SERVER_BUSY_READ, NULL);\n                    h2_filter_cin_timeout_set(session->cin, session->s->timeout);\n                    status = h2_session_read(session, 0);\n                    if (status == APR_SUCCESS) {\n                        session->have_read = 1;\n                        dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                    }\n                    else if (status == APR_EAGAIN) {\n                        /* nothing to read */\n                    }\n                    else if (APR_STATUS_IS_TIMEUP(status)) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_TIMEOUT, 0, NULL);\n                        break;\n                    }\n                    else {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                    }\n                }\n                \n                /* trigger window updates, stream resumes and submits */\n                status = h2_mplx_dispatch_master_events(session->mplx, \n                                                        on_stream_resume,\n                                                        session);\n                if (status != APR_SUCCESS) {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE3, status, c,\n                                  \"h2_session(%ld): dispatch error\", \n                                  session->id);\n                    dispatch_event(session, H2_SESSION_EV_CONN_ERROR, \n                                   H2_ERR_INTERNAL_ERROR, \n                                   \"dispatch error\");\n                    break;\n                }\n                \n                if (nghttp2_session_want_write(session->ngh2)) {\n                    ap_update_child_status(session->c->sbh, SERVER_BUSY_WRITE, NULL);\n                    status = h2_session_send(session);\n                    if (status != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, \n                                       H2_ERR_INTERNAL_ERROR, \"writing\");\n                        break;\n                    }\n                }\n                \n                if (session->have_read || session->have_written) {\n                    if (session->wait_us) {\n                        session->wait_us = 0;\n                    }\n                }\n                else if (!nghttp2_session_want_write(session->ngh2)) {\n                    dispatch_event(session, H2_SESSION_EV_NO_IO, 0, NULL);\n                }\n                break;\n                \n            case H2_SESSION_ST_WAIT:\n                if (session->wait_us <= 0) {\n                    session->wait_us = 10;\n                    if (h2_conn_io_flush(&session->io) != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                        break;\n                    }\n                }\n                else {\n                    /* repeating, increase timer for graceful backoff */\n                    session->wait_us = H2MIN(session->wait_us*2, MAX_WAIT_MICROS);\n                }\n\n                if (trace) {\n                    ap_log_cerror(APLOG_MARK, APLOG_TRACE3, 0, c,\n                                  \"h2_session: wait for data, %ld micros\", \n                                  (long)session->wait_us);\n                }\n                status = h2_mplx_out_trywait(session->mplx, session->wait_us, \n                                             session->iowait);\n                if (status == APR_SUCCESS) {\n                    session->wait_us = 0;\n                    dispatch_event(session, H2_SESSION_EV_DATA_READ, 0, NULL);\n                }\n                else if (APR_STATUS_IS_TIMEUP(status)) {\n                    /* go back to checking all inputs again */\n                    transit(session, \"wait cycle\", session->local.accepting? \n                            H2_SESSION_ST_BUSY : H2_SESSION_ST_DONE);\n                }\n                else if (APR_STATUS_IS_ECONNRESET(status) \n                         || APR_STATUS_IS_ECONNABORTED(status)) {\n                    dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                }\n                else {\n                    ap_log_cerror(APLOG_MARK, APLOG_WARNING, status, c,\n\t\t\t\t  APLOGNO(03404)\n                                  \"h2_session(%ld): waiting on conditional\",\n                                  session->id);\n                    h2_session_shutdown(session, H2_ERR_INTERNAL_ERROR, \n                                        \"cond wait error\", 0);\n                }\n                break;\n                \n            default:\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, c,\n                              APLOGNO(03080)\n                              \"h2_session(%ld): unknown state %d\", session->id, session->state);\n                dispatch_event(session, H2_SESSION_EV_PROTO_ERROR, 0, NULL);\n                break;\n        }\n\n        if (!nghttp2_session_want_read(session->ngh2) \n                 && !nghttp2_session_want_write(session->ngh2)) {\n            dispatch_event(session, H2_SESSION_EV_NGH2_DONE, 0, NULL); \n        }\n        if (session->reprioritize) {\n            h2_mplx_reprioritize(session->mplx, stream_pri_cmp, session);\n            session->reprioritize = 0;\n        }\n    }\n    \nout:\n    if (trace) {\n        ap_log_cerror( APLOG_MARK, APLOG_TRACE3, status, c,\n                      \"h2_session(%ld): [%s] process returns\", \n                      session->id, state_name(session->state));\n    }\n    \n    if ((session->state != H2_SESSION_ST_DONE)\n        && (APR_STATUS_IS_EOF(status)\n            || APR_STATUS_IS_ECONNRESET(status) \n            || APR_STATUS_IS_ECONNABORTED(status))) {\n        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n    }\n\n    status = APR_SUCCESS;\n    if (session->state == H2_SESSION_ST_DONE) {\n        status = APR_EOF;\n        if (!session->eoc_written) {\n            session->eoc_written = 1;\n            h2_conn_io_write_eoc(&session->io, session);\n        }\n    }\n    \n    return status;\n}\n\napr_status_t h2_session_pre_close(h2_session *session, int async)\n{\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, session->c, \n                  \"h2_session(%ld): pre_close\", session->id);\n    dispatch_event(session, H2_SESSION_EV_PRE_CLOSE, 0, \n        (session->state == H2_SESSION_ST_IDLE)? \"timeout\" : NULL);\n    return APR_SUCCESS;\n}\n", "/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <assert.h>\n#include <stddef.h>\n\n#include <apr_strings.h>\n\n#include <httpd.h>\n#include <http_core.h>\n#include <http_connection.h>\n#include <http_log.h>\n\n#include <nghttp2/nghttp2.h>\n\n#include \"h2_private.h\"\n#include \"h2.h\"\n#include \"h2_bucket_beam.h\"\n#include \"h2_conn.h\"\n#include \"h2_config.h\"\n#include \"h2_h2.h\"\n#include \"h2_mplx.h\"\n#include \"h2_push.h\"\n#include \"h2_request.h\"\n#include \"h2_headers.h\"\n#include \"h2_session.h\"\n#include \"h2_stream.h\"\n#include \"h2_task.h\"\n#include \"h2_ctx.h\"\n#include \"h2_task.h\"\n#include \"h2_util.h\"\n\n\nstatic int state_transition[][7] = {\n    /*  ID OP RL RR CI CO CL */\n/*ID*/{  1, 0, 0, 0, 0, 0, 0 },\n/*OP*/{  1, 1, 0, 0, 0, 0, 0 },\n/*RL*/{  0, 0, 1, 0, 0, 0, 0 },\n/*RR*/{  0, 0, 0, 1, 0, 0, 0 },\n/*CI*/{  1, 1, 0, 0, 1, 0, 0 },\n/*CO*/{  1, 1, 0, 0, 0, 1, 0 },\n/*CL*/{  1, 1, 0, 0, 1, 1, 1 },\n};\n\nstatic void H2_STREAM_OUT_LOG(int lvl, h2_stream *s, const char *tag)\n{\n    if (APLOG_C_IS_LEVEL(s->session->c, lvl)) {\n        conn_rec *c = s->session->c;\n        char buffer[4 * 1024];\n        const char *line = \"(null)\";\n        apr_size_t len, bmax = sizeof(buffer)/sizeof(buffer[0]);\n        \n        len = h2_util_bb_print(buffer, bmax, tag, \"\", s->out_buffer);\n        ap_log_cerror(APLOG_MARK, lvl, 0, c, \"bb_dump(%s): %s\", \n                      c->log_id, len? buffer : line);\n    }\n}\n\nstatic int set_state(h2_stream *stream, h2_stream_state_t state)\n{\n    int allowed = state_transition[state][stream->state];\n    if (allowed) {\n        stream->state = state;\n        return 1;\n    }\n    \n    ap_log_cerror(APLOG_MARK, APLOG_WARNING, 0, stream->session->c, APLOGNO(03081)\n                  \"h2_stream(%ld-%d): invalid state transition from %d to %d\", \n                  stream->session->id, stream->id, stream->state, state);\n    return 0;\n}\n\nstatic int close_input(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_CLOSED_INPUT:\n        case H2_STREAM_ST_CLOSED:\n            return 0; /* ignore, idempotent */\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            /* both closed now */\n            set_state(stream, H2_STREAM_ST_CLOSED);\n            break;\n        default:\n            /* everything else we jump to here */\n            set_state(stream, H2_STREAM_ST_CLOSED_INPUT);\n            break;\n    }\n    return 1;\n}\n\nstatic int input_closed(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_OPEN:\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            return 0;\n        default:\n            return 1;\n    }\n}\n\nstatic int close_output(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n        case H2_STREAM_ST_CLOSED:\n            return 0; /* ignore, idempotent */\n        case H2_STREAM_ST_CLOSED_INPUT:\n            /* both closed now */\n            set_state(stream, H2_STREAM_ST_CLOSED);\n            break;\n        default:\n            /* everything else we jump to here */\n            set_state(stream, H2_STREAM_ST_CLOSED_OUTPUT);\n            break;\n    }\n    return 1;\n}\n\nstatic int input_open(const h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_OPEN:\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            return 1;\n        default:\n            return 0;\n    }\n}\n\nstatic int output_open(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_OPEN:\n        case H2_STREAM_ST_CLOSED_INPUT:\n            return 1;\n        default:\n            return 0;\n    }\n}\n\nstatic void prep_output(h2_stream *stream) {\n    conn_rec *c = stream->session->c;\n    if (!stream->out_buffer) {\n        stream->out_buffer = apr_brigade_create(stream->pool, c->bucket_alloc);\n    }\n}\n\nstatic void prepend_response(h2_stream *stream, h2_headers *response)\n{\n    conn_rec *c = stream->session->c;\n    apr_bucket *b;\n    \n    prep_output(stream);\n    b = h2_bucket_headers_create(c->bucket_alloc, response);\n    APR_BRIGADE_INSERT_HEAD(stream->out_buffer, b);\n}\n\nstatic apr_status_t stream_pool_cleanup(void *ctx)\n{\n    h2_stream *stream = ctx;\n    apr_status_t status;\n    \n    ap_assert(stream->can_be_cleaned);\n    if (stream->files) {\n        apr_file_t *file;\n        int i;\n        for (i = 0; i < stream->files->nelts; ++i) {\n            file = APR_ARRAY_IDX(stream->files, i, apr_file_t*);\n            status = apr_file_close(file);\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE3, status, stream->session->c, \n                          \"h2_stream(%ld-%d): destroy, closed file %d\", \n                          stream->session->id, stream->id, i);\n        }\n        stream->files = NULL;\n    }\n    return APR_SUCCESS;\n}\n\nh2_stream *h2_stream_open(int id, apr_pool_t *pool, h2_session *session,\n                          int initiated_on)\n{\n    h2_stream *stream = apr_pcalloc(pool, sizeof(h2_stream));\n    \n    stream->id           = id;\n    stream->initiated_on = initiated_on;\n    stream->created      = apr_time_now();\n    stream->state        = H2_STREAM_ST_IDLE;\n    stream->pool         = pool;\n    stream->session      = session;\n    stream->can_be_cleaned = 1;\n\n    h2_beam_create(&stream->input, pool, id, \"input\", H2_BEAM_OWNER_SEND, 0);\n    h2_beam_create(&stream->output, pool, id, \"output\", H2_BEAM_OWNER_RECV, 0);\n    \n    set_state(stream, H2_STREAM_ST_OPEN);\n    apr_pool_cleanup_register(pool, stream, stream_pool_cleanup, \n                              apr_pool_cleanup_null);\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03082)\n                  \"h2_stream(%ld-%d): opened\", session->id, stream->id);\n    return stream;\n}\n\nvoid h2_stream_cleanup(h2_stream *stream)\n{\n    apr_status_t status;\n    \n    ap_assert(stream);\n    if (stream->out_buffer) {\n        /* remove any left over output buckets that may still have\n         * references into request pools */\n        apr_brigade_cleanup(stream->out_buffer);\n    }\n    h2_beam_abort(stream->input);\n    status = h2_beam_wait_empty(stream->input, APR_NONBLOCK_READ);\n    if (status == APR_EAGAIN) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, stream->session->c, \n                      \"h2_stream(%ld-%d): wait on input drain\", \n                      stream->session->id, stream->id);\n        status = h2_beam_wait_empty(stream->input, APR_BLOCK_READ);\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, stream->session->c, \n                      \"h2_stream(%ld-%d): input drain returned\", \n                      stream->session->id, stream->id);\n    }\n}\n\nvoid h2_stream_destroy(h2_stream *stream)\n{\n    ap_assert(stream);\n    ap_assert(!h2_mplx_stream_get(stream->session->mplx, stream->id));\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE3, 0, stream->session->c, \n                  \"h2_stream(%ld-%d): destroy\", \n                  stream->session->id, stream->id);\n    stream->can_be_cleaned = 1;\n    if (stream->pool) {\n        apr_pool_destroy(stream->pool);\n    }\n}\n\nvoid h2_stream_eos_destroy(h2_stream *stream)\n{\n    h2_session_stream_done(stream->session, stream);\n    /* stream possibly destroyed */\n}\n\napr_pool_t *h2_stream_detach_pool(h2_stream *stream)\n{\n    apr_pool_t *pool = stream->pool;\n    stream->pool = NULL;\n    return pool;\n}\n\nvoid h2_stream_rst(h2_stream *stream, int error_code)\n{\n    stream->rst_error = error_code;\n    close_input(stream);\n    close_output(stream);\n    if (stream->out_buffer) {\n        apr_brigade_cleanup(stream->out_buffer);\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                  \"h2_stream(%ld-%d): reset, error=%d\", \n                  stream->session->id, stream->id, error_code);\n}\n\napr_status_t h2_stream_set_request_rec(h2_stream *stream, request_rec *r)\n{\n    h2_request *req;\n    apr_status_t status;\n\n    ap_assert(stream->request == NULL);\n    ap_assert(stream->rtmp == NULL);\n    if (stream->rst_error) {\n        return APR_ECONNRESET;\n    }\n    status = h2_request_rcreate(&req, stream->pool, r);\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(03058)\n                  \"h2_request(%d): set_request_rec %s host=%s://%s%s\",\n                  stream->id, req->method, req->scheme, req->authority, \n                  req->path);\n    stream->rtmp = req;\n    return status;\n}\n\napr_status_t h2_stream_set_request(h2_stream *stream, const h2_request *r)\n{\n    ap_assert(stream->request == NULL);\n    ap_assert(stream->rtmp == NULL);\n    stream->rtmp = h2_request_clone(stream->pool, r);\n    return APR_SUCCESS;\n}\n\nstatic apr_status_t add_trailer(h2_stream *stream,\n                                const char *name, size_t nlen,\n                                const char *value, size_t vlen)\n{\n    conn_rec *c = stream->session->c;\n    char *hname, *hvalue;\n\n    if (nlen == 0 || name[0] == ':') {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, APR_EINVAL, c, APLOGNO(03060)\n                      \"h2_request(%ld-%d): pseudo header in trailer\",\n                      c->id, stream->id);\n        return APR_EINVAL;\n    }\n    if (h2_req_ignore_trailer(name, nlen)) {\n        return APR_SUCCESS;\n    }\n    if (!stream->trailers) {\n        stream->trailers = apr_table_make(stream->pool, 5);\n    }\n    hname = apr_pstrndup(stream->pool, name, nlen);\n    hvalue = apr_pstrndup(stream->pool, value, vlen);\n    h2_util_camel_case_header(hname, nlen);\n    apr_table_mergen(stream->trailers, hname, hvalue);\n    \n    return APR_SUCCESS;\n}\n\napr_status_t h2_stream_add_header(h2_stream *stream,\n                                  const char *name, size_t nlen,\n                                  const char *value, size_t vlen)\n{\n    int error = 0;\n    ap_assert(stream);\n    \n    if (stream->has_response) {\n        return APR_EINVAL;    \n    }\n    ++stream->request_headers_added;\n    if (name[0] == ':') {\n        if ((vlen) > stream->session->s->limit_req_line) {\n            /* pseudo header: approximation of request line size check */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                          \"h2_stream(%ld-%d): pseudo header %s too long\", \n                          stream->session->id, stream->id, name);\n            error = HTTP_REQUEST_URI_TOO_LARGE;\n        }\n    }\n    else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n        /* header too long */\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): header %s too long\", \n                      stream->session->id, stream->id, name);\n        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    \n    if (stream->request_headers_added \n        > stream->session->s->limit_req_fields + 4) {\n        /* too many header lines, include 4 pseudo headers */\n        if (stream->request_headers_added \n            > stream->session->s->limit_req_fields + 4 + 100) {\n            /* yeah, right */\n            return APR_ECONNRESET;\n        }\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): too many header lines\", \n                      stream->session->id, stream->id);\n        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    \n    if (h2_stream_is_scheduled(stream)) {\n        return add_trailer(stream, name, nlen, value, vlen);\n    }\n    else if (error) {\n        return h2_stream_set_error(stream, error); \n    }\n    else {\n        if (!stream->rtmp) {\n            stream->rtmp = h2_req_create(stream->id, stream->pool, \n                                         NULL, NULL, NULL, NULL, NULL, 0);\n        }\n        if (stream->state != H2_STREAM_ST_OPEN) {\n            return APR_ECONNRESET;\n        }\n        return h2_request_add_header(stream->rtmp, stream->pool,\n                                     name, nlen, value, vlen);\n    }\n}\n\napr_status_t h2_stream_schedule(h2_stream *stream, int eos, int push_enabled, \n                                h2_stream_pri_cmp *cmp, void *ctx)\n{\n    apr_status_t status = APR_EINVAL;\n    ap_assert(stream);\n    ap_assert(stream->session);\n    ap_assert(stream->session->mplx);\n    \n    if (!stream->scheduled) {\n        if (eos) {\n            close_input(stream);\n        }\n\n        if (h2_stream_is_ready(stream)) {\n            /* already have a resonse, probably a HTTP error code */\n            return h2_mplx_process(stream->session->mplx, stream, cmp, ctx);\n        }\n        else if (!stream->request && stream->rtmp) {\n            /* This is the common case: a h2_request was being assembled, now\n             * it gets finalized and checked for completness */\n            status = h2_request_end_headers(stream->rtmp, stream->pool, eos);\n            if (status == APR_SUCCESS) {\n                stream->rtmp->serialize = h2_config_geti(stream->session->config,\n                                                         H2_CONF_SER_HEADERS); \n\n                stream->request = stream->rtmp;\n                stream->rtmp = NULL;\n                stream->scheduled = 1;\n\n                stream->push_policy = h2_push_policy_determine(stream->request->headers, \n                                                               stream->pool, push_enabled);\n            \n                \n                status = h2_mplx_process(stream->session->mplx, stream, cmp, ctx);\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                              \"h2_stream(%ld-%d): scheduled %s %s://%s%s \"\n                              \"chunked=%d\",\n                              stream->session->id, stream->id,\n                              stream->request->method, stream->request->scheme,\n                              stream->request->authority, stream->request->path,\n                              stream->request->chunked);\n                return status;\n            }\n        }\n        else {\n            status = APR_ECONNRESET;\n        }\n    }\n    \n    h2_stream_rst(stream, H2_ERR_INTERNAL_ERROR);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, stream->session->c,\n                  \"h2_stream(%ld-%d): RST=2 (internal err) %s %s://%s%s\",\n                  stream->session->id, stream->id,\n                  stream->request->method, stream->request->scheme,\n                  stream->request->authority, stream->request->path);\n    return status;\n}\n\nint h2_stream_is_scheduled(const h2_stream *stream)\n{\n    return stream->scheduled;\n}\n\napr_status_t h2_stream_close_input(h2_stream *stream)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status;\n    apr_bucket_brigade *tmp;\n    apr_bucket *b;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                  \"h2_stream(%ld-%d): closing input\",\n                  stream->session->id, stream->id);\n    if (stream->rst_error) {\n        return APR_ECONNRESET;\n    }\n    \n    tmp = apr_brigade_create(stream->pool, c->bucket_alloc);\n    if (stream->trailers && !apr_is_empty_table(stream->trailers)) {\n        h2_headers *r = h2_headers_create(HTTP_OK, stream->trailers, \n                                          NULL, stream->pool);\n        b = h2_bucket_headers_create(c->bucket_alloc, r);\n        APR_BRIGADE_INSERT_TAIL(tmp, b);\n        stream->trailers = NULL;\n    }\n    \n    b = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmp, b);\n    status = h2_beam_send(stream->input, tmp, APR_BLOCK_READ);\n    apr_brigade_destroy(tmp);\n    return status;\n}\n\napr_status_t h2_stream_write_data(h2_stream *stream,\n                                  const char *data, size_t len, int eos)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status = APR_SUCCESS;\n    apr_bucket_brigade *tmp;\n    \n    ap_assert(stream);\n    if (!stream->input) {\n        return APR_EOF;\n    }\n    if (input_closed(stream) || !stream->request) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                      \"h2_stream(%ld-%d): writing denied, closed=%d, eoh=%d\", \n                      stream->session->id, stream->id, input_closed(stream),\n                      stream->request != NULL);\n        return APR_EINVAL;\n    }\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                  \"h2_stream(%ld-%d): add %ld input bytes\", \n                  stream->session->id, stream->id, (long)len);\n    \n    tmp = apr_brigade_create(stream->pool, c->bucket_alloc);\n    apr_brigade_write(tmp, NULL, NULL, data, len);\n    status = h2_beam_send(stream->input, tmp, APR_BLOCK_READ);\n    apr_brigade_destroy(tmp);\n    \n    stream->in_data_frames++;\n    stream->in_data_octets += len;\n    \n    if (eos) {\n        return h2_stream_close_input(stream);\n    }\n    \n    return status;\n}\n\nstatic apr_status_t fill_buffer(h2_stream *stream, apr_size_t amount)\n{\n    conn_rec *c = stream->session->c;\n    apr_bucket *b;\n    apr_status_t status;\n    \n    if (!stream->output) {\n        return APR_EOF;\n    }\n    status = h2_beam_receive(stream->output, stream->out_buffer, \n                             APR_NONBLOCK_READ, amount);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, stream->session->c,\n                  \"h2_stream(%ld-%d): beam_received\",\n                  stream->session->id, stream->id);\n    /* The buckets we reveive are using the stream->out_buffer pool as\n     * lifetime which is exactly what we want since this is stream->pool.\n     *\n     * However: when we send these buckets down the core output filters, the\n     * filter might decide to setaside them into a pool of its own. And it\n     * might decide, after having sent the buckets, to clear its pool.\n     *\n     * This is problematic for file buckets because it then closed the contained\n     * file. Any split off buckets we sent afterwards will result in a \n     * APR_EBADF.\n     */\n    for (b = APR_BRIGADE_FIRST(stream->out_buffer);\n         b != APR_BRIGADE_SENTINEL(stream->out_buffer);\n         b = APR_BUCKET_NEXT(b)) {\n        if (APR_BUCKET_IS_FILE(b)) {\n            apr_bucket_file *f = (apr_bucket_file *)b->data;\n            apr_pool_t *fpool = apr_file_pool_get(f->fd);\n            if (fpool != c->pool) {\n                apr_bucket_setaside(b, c->pool);\n                if (!stream->files) {\n                    stream->files = apr_array_make(stream->pool, \n                                                   5, sizeof(apr_file_t*));\n                }\n                APR_ARRAY_PUSH(stream->files, apr_file_t*) = f->fd;\n            }\n        }\n    }\n    return status;\n}\n\napr_status_t h2_stream_set_error(h2_stream *stream, int http_status)\n{\n    h2_headers *response;\n    \n    if (h2_stream_is_ready(stream)) {\n        return APR_EINVAL;\n    }\n    if (stream->rtmp) {\n        stream->request = stream->rtmp;\n        stream->rtmp = NULL;\n    }\n    response = h2_headers_die(http_status, stream->request, stream->pool);\n    prepend_response(stream, response);\n    h2_beam_close(stream->output);\n    return APR_SUCCESS;\n}\n\nstatic apr_bucket *get_first_headers_bucket(apr_bucket_brigade *bb)\n{\n    if (bb) {\n        apr_bucket *b = APR_BRIGADE_FIRST(bb);\n        while (b != APR_BRIGADE_SENTINEL(bb)) {\n            if (H2_BUCKET_IS_HEADERS(b)) {\n                return b;\n            }\n            b = APR_BUCKET_NEXT(b);\n        }\n    }\n    return NULL;\n}\n\napr_status_t h2_stream_out_prepare(h2_stream *stream, apr_off_t *plen, \n                                   int *peos, h2_headers **presponse)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status = APR_SUCCESS;\n    apr_off_t requested;\n    apr_bucket *b, *e;\n\n    if (presponse) {\n        *presponse = NULL;\n    }\n    \n    if (stream->rst_error) {\n        *plen = 0;\n        *peos = 1;\n        return APR_ECONNRESET;\n    }\n    \n    if (!output_open(stream)) {\n        return APR_ECONNRESET;\n    }\n    prep_output(stream);\n\n    if (*plen > 0) {\n        requested = H2MIN(*plen, H2_DATA_CHUNK_SIZE);\n    }\n    else {\n        requested = H2_DATA_CHUNK_SIZE;\n    }\n    *plen = requested;\n    \n    H2_STREAM_OUT_LOG(APLOG_TRACE2, stream, \"h2_stream_out_prepare_pre\");\n    h2_util_bb_avail(stream->out_buffer, plen, peos);\n    if (!*peos && *plen < requested) {\n        /* try to get more data */\n        status = fill_buffer(stream, (requested - *plen) + H2_DATA_CHUNK_SIZE);\n        if (APR_STATUS_IS_EOF(status)) {\n            apr_bucket *eos = apr_bucket_eos_create(c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(stream->out_buffer, eos);\n            status = APR_SUCCESS;\n        }\n        else if (status == APR_EAGAIN) {\n            /* did not receive more, it's ok */\n            status = APR_SUCCESS;\n        }\n        *plen = requested;\n        h2_util_bb_avail(stream->out_buffer, plen, peos);\n    }\n    H2_STREAM_OUT_LOG(APLOG_TRACE2, stream, \"h2_stream_out_prepare_post\");\n    \n    b = APR_BRIGADE_FIRST(stream->out_buffer);\n    while (b != APR_BRIGADE_SENTINEL(stream->out_buffer)) {\n        e = APR_BUCKET_NEXT(b);\n        if (APR_BUCKET_IS_FLUSH(b)\n            || (!APR_BUCKET_IS_METADATA(b) && b->length == 0)) {\n            APR_BUCKET_REMOVE(b);\n            apr_bucket_destroy(b);\n        }\n        else {\n            break;\n        }\n        b = e;\n    }\n    \n    b = get_first_headers_bucket(stream->out_buffer);\n    if (b) {\n        /* there are HEADERS to submit */\n        *peos = 0;\n        *plen = 0;\n        if (b == APR_BRIGADE_FIRST(stream->out_buffer)) {\n            if (presponse) {\n                *presponse = h2_bucket_headers_get(b);\n                APR_BUCKET_REMOVE(b);\n                apr_bucket_destroy(b);\n                status = APR_SUCCESS;\n            }\n            else {\n                /* someone needs to retrieve the response first */\n                h2_mplx_keep_active(stream->session->mplx, stream->id);\n                status = APR_EAGAIN;\n            }\n        }\n        else {\n            apr_bucket *e = APR_BRIGADE_FIRST(stream->out_buffer);\n            while (e != APR_BRIGADE_SENTINEL(stream->out_buffer)) {\n                if (e == b) {\n                    break;\n                }\n                else if (e->length != (apr_size_t)-1) {\n                    *plen += e->length;\n                }\n                e = APR_BUCKET_NEXT(e);\n            }\n        }\n    }\n    \n    if (!*peos && !*plen && status == APR_SUCCESS \n        && (!presponse || !*presponse)) {\n        status = APR_EAGAIN;\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, c,\n                  \"h2_stream(%ld-%d): prepare, len=%ld eos=%d\",\n                  c->id, stream->id, (long)*plen, *peos);\n    return status;\n}\n\nstatic int is_not_headers(apr_bucket *b)\n{\n    return !H2_BUCKET_IS_HEADERS(b);\n}\n\napr_status_t h2_stream_read_to(h2_stream *stream, apr_bucket_brigade *bb, \n                               apr_off_t *plen, int *peos)\n{\n    conn_rec *c = stream->session->c;\n    apr_status_t status = APR_SUCCESS;\n\n    if (stream->rst_error) {\n        return APR_ECONNRESET;\n    }\n    status = h2_append_brigade(bb, stream->out_buffer, plen, peos, is_not_headers);\n    if (status == APR_SUCCESS && !*peos && !*plen) {\n        status = APR_EAGAIN;\n    }\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, status, c,\n                  \"h2_stream(%ld-%d): read_to, len=%ld eos=%d\",\n                  c->id, stream->id, (long)*plen, *peos);\n    return status;\n}\n\n\nint h2_stream_input_is_open(const h2_stream *stream) \n{\n    return input_open(stream);\n}\n\napr_status_t h2_stream_submit_pushes(h2_stream *stream, h2_headers *response)\n{\n    apr_status_t status = APR_SUCCESS;\n    apr_array_header_t *pushes;\n    int i;\n    \n    pushes = h2_push_collect_update(stream, stream->request, response);\n    if (pushes && !apr_is_empty_array(pushes)) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): found %d push candidates\",\n                      stream->session->id, stream->id, pushes->nelts);\n        for (i = 0; i < pushes->nelts; ++i) {\n            h2_push *push = APR_ARRAY_IDX(pushes, i, h2_push*);\n            h2_stream *s = h2_session_push(stream->session, stream, push);\n            if (!s) {\n                status = APR_ECONNRESET;\n                break;\n            }\n        }\n    }\n    return status;\n}\n\napr_table_t *h2_stream_get_trailers(h2_stream *stream)\n{\n    return NULL;\n}\n\nconst h2_priority *h2_stream_get_priority(h2_stream *stream, \n                                          h2_headers *response)\n{\n    if (response && stream->initiated_on) {\n        const char *ctype = apr_table_get(response->headers, \"content-type\");\n        if (ctype) {\n            /* FIXME: Not good enough, config needs to come from request->server */\n            return h2_config_get_priority(stream->session->config, ctype);\n        }\n    }\n    return NULL;\n}\n\nconst char *h2_stream_state_str(h2_stream *stream)\n{\n    switch (stream->state) {\n        case H2_STREAM_ST_IDLE:\n            return \"IDLE\";\n        case H2_STREAM_ST_OPEN:\n            return \"OPEN\";\n        case H2_STREAM_ST_RESV_LOCAL:\n            return \"RESERVED_LOCAL\";\n        case H2_STREAM_ST_RESV_REMOTE:\n            return \"RESERVED_REMOTE\";\n        case H2_STREAM_ST_CLOSED_INPUT:\n            return \"HALF_CLOSED_REMOTE\";\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            return \"HALF_CLOSED_LOCAL\";\n        case H2_STREAM_ST_CLOSED:\n            return \"CLOSED\";\n        default:\n            return \"UNKNOWN\";\n            \n    }\n}\n\nint h2_stream_is_ready(h2_stream *stream)\n{\n    if (stream->has_response) {\n        return 1;\n    }\n    else if (stream->out_buffer && get_first_headers_bucket(stream->out_buffer)) {\n        return 1;\n    }\n    return 0;\n}\n\n\n"], "filenames": ["CHANGES", "modules/http2/h2_session.c", "modules/http2/h2_stream.c"], "buggy_code_start_loc": [2, 397, 335], "buggy_code_end_loc": [2, 407, 373], "fixing_code_start_loc": [3, 397, 336], "fixing_code_end_loc": [7, 414, 379], "type": "CWE-20", "message": "The mod_http2 module in the Apache HTTP Server 2.4.17 through 2.4.23, when the Protocols configuration includes h2 or h2c, does not restrict request-header length, which allows remote attackers to cause a denial of service (memory consumption) via crafted CONTINUATION frames in an HTTP/2 request.", "other": {"cve": {"id": "CVE-2016-8740", "sourceIdentifier": "security@apache.org", "published": "2016-12-05T19:59:00.250", "lastModified": "2021-06-06T11:15:19.650", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mod_http2 module in the Apache HTTP Server 2.4.17 through 2.4.23, when the Protocols configuration includes h2 or h2c, does not restrict request-header length, which allows remote attackers to cause a denial of service (memory consumption) via crafted CONTINUATION frames in an HTTP/2 request."}, {"lang": "es", "value": "El m\u00f3dulo mod_http2 en el Apache HTTP Server 2.4.17 hasta la versi\u00f3n 2.4.23, cuando la configuraci\u00f3n Protocols incluye h2 o h2c, no restringe la longitud de la cabecera de petici\u00f3n, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria) a trav\u00e9s de marcos CONTINUATION manipulados en una petici\u00f3n HTTP/2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "E1F45B27-504B-4202-87B8-BD3B094003F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "F2FB2B98-DFD2-420A-8A7F-9B288651242F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "2AE538EE-7152-4DB5-AE45-614494CB7B95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "B803D25B-0A19-4569-BA05-09D58F33917C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "BE253E49-9A56-49C8-B1D8-E23BB3D5D1D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "DE5A73E5-1A04-420B-92B2-B90FD970005C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "8510442C-212F-4013-85FA-E0AB59F6F2C6"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/140023/Apache-HTTPD-Web-Server-2.4.23-Memory-Exhaustion.html", "source": "security@apache.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-1415.html", "source": "security@apache.org"}, {"url": "http://www.securityfocus.com/bid/94650", "source": "security@apache.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037388", "source": "security@apache.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1161", "source": "security@apache.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1413", "source": "security@apache.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1414", "source": "security@apache.org"}, {"url": "https://github.com/apache/httpd/commit/29c63b786ae028d82405421585e91283c8fa0da3", "source": "security@apache.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://h20566.www2.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbux03725en_us", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/56c2e7cc9deb1c12a843d0dc251ea7fd3e7e80293cde02fcd65286ba@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/84a3714f0878781f6ed84473d1a503d2cc382277e100450209231830@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r04e89e873d54116a0635ef2f7061c15acc5ed27ef7500997beb65d6f@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r476d175be0aaf4a17680ef98c5153b4d336eaef76fb2224cc94c463a@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r76142b8c5119df2178be7c2dba88fde552eedeec37ea993dfce68d1d@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r9f93cf6dde308d42a9c807784e8102600d0397f5f834890708bf6920@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rb14daf9cc4e28d18cdc15d6a6ca74e565672fabf7ad89541071d008b@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rc998b18880df98bafaade071346690c2bc1444adaa1a1ea464b93f0a@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rcc44594d4d6579b90deccd4536b5d31f099ef563df39b094be286b9e@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rd18c3c43602e66f9cdcf09f1de233804975b9572b0456cc582390b6f@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rd336919f655b7ff309385e34a143e41c503e133da80414485b3abcc9@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/re1e3a24664d35bcd0a0e793e0b5fc6ca6c107f99a1b2c545c5d4b467@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/re3d27b6250aa8548b8845d314bb8a350b3df326cacbbfdfe4d455234@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rf6449464fd8b7437704c55f88361b66f12d5b5f90bcce66af4be4ba9@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://security.gentoo.org/glsa/201701-36", "source": "security@apache.org"}, {"url": "https://security.netapp.com/advisory/ntap-20180423-0001/", "source": "security@apache.org"}, {"url": "https://support.apple.com/HT208221", "source": "security@apache.org"}, {"url": "https://www.exploit-db.com/exploits/40909/", "source": "security@apache.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.tenable.com/security/tns-2017-04", "source": "security@apache.org"}]}, "github_commit_url": "https://github.com/apache/httpd/commit/29c63b786ae028d82405421585e91283c8fa0da3"}}