{"buggy_code": ["package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/openfga/openfga/internal/build\"\n\t\"github.com/openfga/openfga/internal/condition\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\tserverconfig \"github.com/openfga/openfga/internal/server/config\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nconst streamedBufferSize = 100\n\nvar (\n\tfurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tNamespace: build.ProjectName,\n\t\tName:      \"list_objects_further_eval_required_count\",\n\t\tHelp:      \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n\n\tnoFurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tNamespace: build.ProjectName,\n\t\tName:      \"list_objects_no_further_eval_required_count\",\n\t\tHelp:      \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n)\n\ntype ListObjectsQuery struct {\n\tdatastore               storage.RelationshipTupleReader\n\tlogger                  logger.Logger\n\tlistObjectsDeadline     time.Duration\n\tlistObjectsMaxResults   uint32\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\tmaxConcurrentReads      uint32\n\n\tcheckOptions []graph.LocalCheckerOption\n}\n\ntype ListObjectsResponse struct {\n\tObjects            []string\n\tResolutionMetadata reverseexpand.ResolutionMetadata\n}\n\ntype ListObjectsQueryOption func(d *ListObjectsQuery)\n\nfunc WithListObjectsDeadline(deadline time.Duration) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsDeadline = deadline\n\t}\n}\n\nfunc WithListObjectsMaxResults(max uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsMaxResults = max\n\t}\n}\n\n// WithResolveNodeLimit see server.WithResolveNodeLimit\nfunc WithResolveNodeLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\n// WithResolveNodeBreadthLimit see server.WithResolveNodeBreadthLimit\nfunc WithResolveNodeBreadthLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc WithLogger(l logger.Logger) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.logger = l\n\t}\n}\n\nfunc WithCheckOptions(checkOptions []graph.LocalCheckerOption) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.checkOptions = checkOptions\n\t}\n}\n\n// WithMaxConcurrentReads see server.WithMaxConcurrentReadsForListObjects\nfunc WithMaxConcurrentReads(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.maxConcurrentReads = limit\n\t}\n}\n\nfunc NewListObjectsQuery(ds storage.RelationshipTupleReader, opts ...ListObjectsQueryOption) *ListObjectsQuery {\n\tquery := &ListObjectsQuery{\n\t\tdatastore:               ds,\n\t\tlogger:                  logger.NewNoopLogger(),\n\t\tlistObjectsDeadline:     serverconfig.DefaultListObjectsDeadline,\n\t\tlistObjectsMaxResults:   serverconfig.DefaultListObjectsMaxResults,\n\t\tresolveNodeLimit:        serverconfig.DefaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: serverconfig.DefaultResolveNodeBreadthLimit,\n\t\tmaxConcurrentReads:      serverconfig.DefaultMaxConcurrentReadsForListObjects,\n\t\tcheckOptions:            []graph.LocalCheckerOption{},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\tquery.datastore = storagewrappers.NewBoundedConcurrencyTupleReader(query.datastore, query.maxConcurrentReads)\n\n\treturn query\n}\n\ntype ListObjectsResult struct {\n\tObjectID string\n\tErr      error\n}\n\n// listObjectsRequest captures the RPC request definition interface for the ListObjects API.\n// The unary and streaming RPC definitions implement this interface, and so it can be used\n// interchangeably for a canonical representation between the two.\ntype listObjectsRequest interface {\n\tGetStoreId() string\n\tGetAuthorizationModelId() string\n\tGetType() string\n\tGetRelation() string\n\tGetUser() string\n\tGetContextualTuples() *openfgav1.ContextualTupleKeys\n\tGetContext() *structpb.Struct\n}\n\nfunc (q *ListObjectsQuery) evaluate(\n\tctx context.Context,\n\treq listObjectsRequest,\n\tresultsChan chan<- ListObjectsResult,\n\tmaxResults uint32,\n\tresolutionMetadata *reverseexpand.ResolutionMetadata,\n) error {\n\ttargetObjectType := req.GetType()\n\ttargetRelation := req.GetRelation()\n\n\ttypesys, ok := typesystem.TypesystemFromContext(ctx)\n\tif !ok {\n\t\tpanic(\"typesystem missing in context\")\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(typesys.GetSchemaVersion()) {\n\t\treturn serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\t_, err := typesys.GetRelation(targetObjectType, targetRelation)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn serverErrors.TypeNotFound(targetObjectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn serverErrors.RelationNotFound(targetRelation, targetObjectType, nil)\n\t\t}\n\n\t\treturn serverErrors.NewInternalError(\"\", err)\n\t}\n\n\tif err := validation.ValidateUser(typesys, req.GetUser()); err != nil {\n\t\treturn serverErrors.ValidationError(fmt.Errorf(\"invalid 'user' value: %s\", err))\n\t}\n\n\thandler := func() {\n\t\tuserObj, userRel := tuple.SplitObjectRelation(req.GetUser())\n\t\tuserObjType, userObjID := tuple.SplitObject(userObj)\n\n\t\tvar sourceUserRef reverseexpand.IsUserRef\n\t\tsourceUserRef = &reverseexpand.UserRefObject{\n\t\t\tObject: &openfgav1.Object{\n\t\t\t\tType: userObjType,\n\t\t\t\tId:   userObjID,\n\t\t\t},\n\t\t}\n\n\t\tif tuple.IsTypedWildcard(userObj) {\n\t\t\tsourceUserRef = &reverseexpand.UserRefTypedWildcard{Type: tuple.GetType(userObj)}\n\t\t}\n\n\t\tif userRel != \"\" {\n\t\t\tsourceUserRef = &reverseexpand.UserRefObjectRelation{\n\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\tObject:   userObj,\n\t\t\t\t\tRelation: userRel,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\treverseExpandResultsChan := make(chan *reverseexpand.ReverseExpandResult, 1)\n\t\tobjectsFound := atomic.Uint32{}\n\n\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(q.datastore, typesys,\n\t\t\treverseexpand.WithResolveNodeLimit(q.resolveNodeLimit),\n\t\t\treverseexpand.WithResolveNodeBreadthLimit(q.resolveNodeBreadthLimit),\n\t\t\treverseexpand.WithLogger(q.logger),\n\t\t)\n\n\t\tcancelCtx, cancel := context.WithCancel(ctx)\n\n\t\twg := sync.WaitGroup{}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\treverseExpandQuery.Execute(cancelCtx, &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:          req.GetStoreId(),\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetRelation,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.GetContextualTuples().GetTupleKeys(),\n\t\t\t\tContext:          req.GetContext(),\n\t\t\t}, reverseExpandResultsChan, resolutionMetadata)\n\t\t}()\n\n\t\tcheckResolver := graph.NewLocalChecker(\n\t\t\tstoragewrappers.NewCombinedTupleReader(q.datastore, req.GetContextualTuples().GetTupleKeys()),\n\t\t\tq.checkOptions...,\n\t\t)\n\t\tdefer checkResolver.Close()\n\n\t\tconcurrencyLimiterCh := make(chan struct{}, q.resolveNodeBreadthLimit)\n\n\t\tfor res := range reverseExpandResultsChan {\n\t\t\tif res.Err != nil {\n\t\t\t\terr := res.Err\n\n\t\t\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\t\t\terr = serverErrors.AuthorizationModelResolutionTooComplex\n\t\t\t\t}\n\n\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif !(maxResults == 0) && objectsFound.Load() >= maxResults {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif res.ResultStatus == reverseexpand.NoFurtherEvalStatus {\n\t\t\t\tnoFurtherEvalRequiredCounter.Inc()\n\t\t\t\ttrySendObject(res.Object, &objectsFound, maxResults, resultsChan)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfurtherEvalRequiredCounter.Inc()\n\n\t\t\twg.Add(1)\n\t\t\tgo func(res *reverseexpand.ReverseExpandResult) {\n\t\t\t\tdefer func() {\n\t\t\t\t\t<-concurrencyLimiterCh\n\t\t\t\t\twg.Done()\n\t\t\t\t}()\n\n\t\t\t\tconcurrencyLimiterCh <- struct{}{}\n\n\t\t\t\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\t\t\t\tStoreID:              req.GetStoreId(),\n\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelId(),\n\t\t\t\t\tTupleKey:             tuple.NewTupleKey(res.Object, req.GetRelation(), req.GetUser()),\n\t\t\t\t\tContextualTuples:     req.GetContextualTuples().GetTupleKeys(),\n\t\t\t\t\tContext:              req.GetContext(),\n\t\t\t\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\t\t\t\tDepth: q.resolveNodeLimit,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\t\t\t\tresultsChan <- ListObjectsResult{Err: serverErrors.AuthorizationModelResolutionTooComplex}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tatomic.AddUint32(resolutionMetadata.QueryCount, resp.GetResolutionMetadata().DatastoreQueryCount)\n\n\t\t\t\tif resp.Allowed {\n\t\t\t\t\ttrySendObject(res.Object, &objectsFound, maxResults, resultsChan)\n\t\t\t\t}\n\t\t\t}(res)\n\t\t}\n\n\t\tcancel()\n\t\twg.Wait()\n\t\tclose(resultsChan)\n\t}\n\n\tgo handler()\n\n\treturn nil\n}\n\nfunc trySendObject(object string, objectsFound *atomic.Uint32, maxResults uint32, resultsChan chan<- ListObjectsResult) {\n\tif !(maxResults == 0) {\n\t\tif objectsFound.Add(1) > maxResults {\n\t\t\treturn\n\t\t}\n\t}\n\tresultsChan <- ListObjectsResult{ObjectID: object}\n}\n\n// Execute the ListObjectsQuery, returning a list of object IDs up to a maximum of q.listObjectsMaxResults\n// or until q.listObjectsDeadline is hit, whichever happens first.\nfunc (q *ListObjectsQuery) Execute(\n\tctx context.Context,\n\treq *openfgav1.ListObjectsRequest,\n) (*ListObjectsResponse, error) {\n\tresultsChan := make(chan ListObjectsResult, 1)\n\tmaxResults := q.listObjectsMaxResults\n\tif maxResults > 0 {\n\t\tresultsChan = make(chan ListObjectsResult, maxResults)\n\t}\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobjects := make([]string, 0)\n\n\tvar errs *multierror.Error\n\tfor {\n\t\tselect {\n\t\tcase <-timeoutCtx.Done():\n\t\t\tq.logger.WarnWithContext(\n\t\t\t\tctx, fmt.Sprintf(\"list objects timeout after %s\", q.listObjectsDeadline.String()),\n\t\t\t)\n\t\t\treturn &ListObjectsResponse{\n\t\t\t\tObjects:            objects,\n\t\t\t\tResolutionMetadata: *resolutionMetadata,\n\t\t\t}, nil\n\n\t\tcase result, channelOpen := <-resultsChan:\n\t\t\tif result.Err != nil {\n\t\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\t\treturn nil, result.Err\n\t\t\t\t}\n\n\t\t\t\tif errors.Is(result.Err, condition.ErrEvaluationFailed) {\n\t\t\t\t\terrs = multierror.Append(errs, result.Err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif errors.Is(result.Err, context.Canceled) || errors.Is(result.Err, context.DeadlineExceeded) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t\t}\n\n\t\t\tif !channelOpen {\n\t\t\t\tif len(objects) < int(maxResults) && errs.ErrorOrNil() != nil {\n\t\t\t\t\treturn nil, errs\n\t\t\t\t}\n\n\t\t\t\treturn &ListObjectsResponse{\n\t\t\t\t\tObjects:            objects,\n\t\t\t\t\tResolutionMetadata: *resolutionMetadata,\n\t\t\t\t}, nil\n\t\t\t}\n\t\t\tobjects = append(objects, result.ObjectID)\n\t\t}\n\t}\n}\n\n// ExecuteStreamed executes the ListObjectsQuery, returning a stream of object IDs.\n// It ignores the value of q.listObjectsMaxResults and returns all available results\n// until q.listObjectsDeadline is hit\nfunc (q *ListObjectsQuery) ExecuteStreamed(ctx context.Context, req *openfgav1.StreamedListObjectsRequest, srv openfgav1.OpenFGAService_StreamedListObjectsServer) (*reverseexpand.ResolutionMetadata, error) {\n\tmaxResults := uint32(math.MaxUint32)\n\t// make a buffered channel so that writer goroutines aren't blocked when attempting to send a result\n\tresultsChan := make(chan ListObjectsResult, streamedBufferSize)\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-timeoutCtx.Done():\n\t\t\tq.logger.WarnWithContext(\n\t\t\t\tctx, fmt.Sprintf(\"list objects timeout after %s\", q.listObjectsDeadline.String()),\n\t\t\t)\n\t\t\treturn resolutionMetadata, nil\n\n\t\tcase result, channelOpen := <-resultsChan:\n\t\t\tif !channelOpen {\n\t\t\t\t// Channel closed! No more results.\n\t\t\t\treturn resolutionMetadata, nil\n\t\t\t}\n\n\t\t\tif result.Err != nil {\n\t\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\t\treturn nil, result.Err\n\t\t\t\t}\n\n\t\t\t\tif errors.Is(result.Err, condition.ErrEvaluationFailed) {\n\t\t\t\t\treturn nil, serverErrors.ValidationError(result.Err)\n\t\t\t\t}\n\n\t\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t\t}\n\n\t\t\tif err := srv.Send(&openfgav1.StreamedListObjectsResponse{\n\t\t\t\tObject: result.ObjectID,\n\t\t\t}); err != nil {\n\t\t\t\treturn nil, serverErrors.NewInternalError(\"\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Package reverseexpand contains the code that handles the ReverseExpand API\npackage reverseexpand\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/sourcegraph/conc/pool\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/openfga/openfga/pkg/logger\"\n\n\t\"github.com/openfga/openfga/internal/condition\"\n\t\"github.com/openfga/openfga/internal/condition/eval\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\tserverconfig \"github.com/openfga/openfga/internal/server/config\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server/commands/reverse_expand\")\n\ntype ReverseExpandRequest struct {\n\tStoreID          string\n\tObjectType       string\n\tRelation         string\n\tUser             IsUserRef\n\tContextualTuples []*openfgav1.TupleKey\n\tContext          *structpb.Struct\n\n\tedge *graph.RelationshipEdge\n}\n\ntype IsUserRef interface {\n\tisUserRef()\n\tGetObjectType() string\n\tString() string\n}\n\ntype UserRefObject struct {\n\tObject *openfgav1.Object\n}\n\nvar _ IsUserRef = (*UserRefObject)(nil)\n\nfunc (u *UserRefObject) isUserRef() {}\n\nfunc (u *UserRefObject) GetObjectType() string {\n\treturn u.Object.Type\n}\n\nfunc (u *UserRefObject) String() string {\n\treturn tuple.BuildObject(u.Object.GetType(), u.Object.GetId())\n}\n\ntype UserRefTypedWildcard struct {\n\tType string\n}\n\nvar _ IsUserRef = (*UserRefTypedWildcard)(nil)\n\nfunc (*UserRefTypedWildcard) isUserRef() {}\n\nfunc (u *UserRefTypedWildcard) GetObjectType() string {\n\treturn u.Type\n}\n\nfunc (u *UserRefTypedWildcard) String() string {\n\treturn fmt.Sprintf(\"%s:*\", u.Type)\n}\n\ntype UserRefObjectRelation struct {\n\tObjectRelation *openfgav1.ObjectRelation\n\tCondition      *openfgav1.RelationshipCondition\n}\n\nfunc (*UserRefObjectRelation) isUserRef() {}\n\nfunc (u *UserRefObjectRelation) GetObjectType() string {\n\treturn tuple.GetType(u.ObjectRelation.Object)\n}\n\nfunc (u *UserRefObjectRelation) String() string {\n\treturn tuple.ToObjectRelationString(\n\t\tu.ObjectRelation.GetObject(),\n\t\tu.ObjectRelation.GetRelation(),\n\t)\n}\n\ntype UserRef struct {\n\n\t// Types that are assignable to Ref\n\t//  *UserRef_Object\n\t//  *UserRef_TypedWildcard\n\t//  *UserRef_ObjectRelation\n\tRef IsUserRef\n}\n\ntype ReverseExpandQuery struct {\n\tlogger                  logger.Logger\n\tdatastore               storage.RelationshipTupleReader\n\ttypesystem              *typesystem.TypeSystem\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\n\t// visitedUsersetsMap map prevents visiting the same userset through the same edge twice\n\tvisitedUsersetsMap *sync.Map\n\t// candidateObjectsMap map prevents returning the same object twice\n\tcandidateObjectsMap *sync.Map\n}\n\ntype ReverseExpandQueryOption func(d *ReverseExpandQuery)\n\nfunc WithResolveNodeLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\nfunc WithResolveNodeBreadthLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc NewReverseExpandQuery(ds storage.RelationshipTupleReader, ts *typesystem.TypeSystem, opts ...ReverseExpandQueryOption) *ReverseExpandQuery {\n\tquery := &ReverseExpandQuery{\n\t\tlogger:                  logger.NewNoopLogger(),\n\t\tdatastore:               ds,\n\t\ttypesystem:              ts,\n\t\tresolveNodeLimit:        serverconfig.DefaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: serverconfig.DefaultResolveNodeBreadthLimit,\n\t\tcandidateObjectsMap:     new(sync.Map),\n\t\tvisitedUsersetsMap:      new(sync.Map),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\treturn query\n}\n\ntype ConditionalResultStatus int\n\nconst (\n\tRequiresFurtherEvalStatus ConditionalResultStatus = iota\n\tNoFurtherEvalStatus\n)\n\ntype ReverseExpandResult struct {\n\tErr          error\n\tObject       string\n\tResultStatus ConditionalResultStatus\n}\n\ntype ResolutionMetadata struct {\n\tQueryCount *uint32\n}\n\nfunc NewResolutionMetadata() *ResolutionMetadata {\n\treturn &ResolutionMetadata{\n\t\tQueryCount: new(uint32),\n\t}\n}\n\nfunc WithLogger(logger logger.Logger) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.logger = logger\n\t}\n}\n\n// Execute yields all the objects of the provided objectType that the given user has, possibly, a specific relation with\n// and sends those objects to resultChan. It MUST guarantee no duplicate objects sent.\n//\n// If an error is encountered before resolving all objects: the provided channel will NOT be closed and\n// - if the error is context cancellation or deadline: Execute may send the error through the channel\n// - otherwise: Execute will send the error through the channel\n// If no errors, Execute will yield all of the objects on the provided channel and then close the channel\n// to signal that it is done.\nfunc (c *ReverseExpandQuery) Execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) {\n\terr := c.execute(ctx, req, resultChan, false, resolutionMetadata)\n\tif err != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase resultChan <- &ReverseExpandResult{Err: err}:\n\t\t\treturn\n\t\t}\n\t}\n\n\tclose(resultChan)\n}\n\nfunc (c *ReverseExpandQuery) execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tctx, span := tracer.Start(ctx, \"reverseExpand.Execute\", trace.WithAttributes(\n\t\tattribute.String(\"target_type\", req.ObjectType),\n\t\tattribute.String(\"target_relation\", req.Relation),\n\t\tattribute.String(\"source\", req.User.String()),\n\t))\n\tdefer span.End()\n\n\tif req.edge != nil {\n\t\tspan.SetAttributes(attribute.String(\"edge\", req.edge.String()))\n\t}\n\n\tdepth, ok := graph.ResolutionDepthFromContext(ctx)\n\tif !ok {\n\t\tctx = graph.ContextWithResolutionDepth(ctx, 0)\n\t} else {\n\t\tif depth >= c.resolveNodeLimit {\n\t\t\treturn graph.ErrResolutionDepthExceeded\n\t\t}\n\n\t\tctx = graph.ContextWithResolutionDepth(ctx, depth+1)\n\t}\n\n\tvar sourceUserRef *openfgav1.RelationReference\n\tvar sourceUserType, sourceUserObj string\n\n\t// e.g. 'user:bob'\n\tif val, ok := req.User.(*UserRefObject); ok {\n\t\tsourceUserType = val.Object.GetType()\n\t\tsourceUserObj = tuple.BuildObject(sourceUserType, val.Object.GetId())\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, \"\")\n\t}\n\n\t// e.g. 'user:*'\n\tif val, ok := req.User.(*UserRefTypedWildcard); ok {\n\t\tsourceUserType = val.Type\n\t\tsourceUserRef = typesystem.WildcardRelationReference(sourceUserType)\n\t}\n\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\tsourceUserType = tuple.GetType(val.ObjectRelation.GetObject())\n\t\tsourceUserObj = val.ObjectRelation.Object\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, val.ObjectRelation.GetRelation())\n\n\t\tif req.edge != nil {\n\t\t\tkey := fmt.Sprintf(\"%s#%s\", sourceUserObj, req.edge.String())\n\t\t\tif _, loaded := c.visitedUsersetsMap.LoadOrStore(key, struct{}{}); loaded {\n\t\t\t\t// we've already visited this userset through this edge, exit to avoid an infinite cycle\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tsourceUserRel := val.ObjectRelation.GetRelation()\n\n\t\t\tif sourceUserType == req.ObjectType && sourceUserRel == req.Relation {\n\t\t\t\tif err := c.trySendCandidate(ctx, intersectionOrExclusionInPreviousEdges, sourceUserObj, resultChan); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttargetObjRef := typesystem.DirectRelationReference(req.ObjectType, req.Relation)\n\n\tg := graph.New(c.typesystem)\n\n\tedges, err := g.GetPrunedRelationshipEdges(targetObjRef, sourceUserRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpool := pool.New().WithContext(ctx)\n\tpool.WithCancelOnError()\n\tpool.WithFirstError()\n\tpool.WithMaxGoroutines(int(c.resolveNodeBreadthLimit))\n\tvar errs *multierror.Error\n\nLoopOnEdges:\n\tfor _, edge := range edges {\n\t\tinnerLoopEdge := edge\n\t\tintersectionOrExclusionInPreviousEdges := intersectionOrExclusionInPreviousEdges || innerLoopEdge.TargetReferenceInvolvesIntersectionOrExclusion\n\t\tr := &ReverseExpandRequest{\n\t\t\tStoreID:          req.StoreID,\n\t\t\tObjectType:       req.ObjectType,\n\t\t\tRelation:         req.Relation,\n\t\t\tUser:             req.User,\n\t\t\tContextualTuples: req.ContextualTuples,\n\t\t\tContext:          req.Context,\n\t\t\tedge:             innerLoopEdge,\n\t\t}\n\t\tswitch innerLoopEdge.Type {\n\t\tcase graph.DirectEdge:\n\t\t\tpool.Go(func(ctx context.Context) error {\n\t\t\t\treturn c.reverseExpandDirect(ctx, r, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t\t})\n\t\tcase graph.ComputedUsersetEdge:\n\t\t\t// follow the computed_userset edge, no new goroutine needed since it's not I/O intensive\n\t\t\tr.User = &UserRefObjectRelation{\n\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\tObject:   sourceUserObj,\n\t\t\t\t\tRelation: innerLoopEdge.TargetReference.GetRelation(),\n\t\t\t\t},\n\t\t\t}\n\t\t\terr = c.execute(ctx, r, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t\tif err != nil {\n\t\t\t\terrs = multierror.Append(errs, err)\n\t\t\t\tbreak LoopOnEdges\n\t\t\t}\n\t\tcase graph.TupleToUsersetEdge:\n\t\t\tpool.Go(func(ctx context.Context) error {\n\t\t\t\treturn c.reverseExpandTupleToUserset(ctx, r, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t\t})\n\t\tdefault:\n\t\t\tpanic(\"unsupported edge type\")\n\t\t}\n\t}\n\n\terr = pool.Wait()\n\tif err != nil {\n\t\terrs = multierror.Append(errs, err)\n\t}\n\tif errs.ErrorOrNil() != nil {\n\t\ttelemetry.TraceError(span, errs.ErrorOrNil())\n\t\treturn errs.ErrorOrNil()\n\t}\n\n\treturn nil\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandTupleToUserset(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandTupleToUserset\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.User.String()),\n\t))\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\ttelemetry.TraceError(span, err)\n\t\t}\n\t\tspan.End()\n\t}()\n\n\terr = c.readTuplesAndExecute(ctx, req, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\treturn err\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandDirect(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandDirect\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.User.String()),\n\t))\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\ttelemetry.TraceError(span, err)\n\t\t}\n\t\tspan.End()\n\t}()\n\n\terr = c.readTuplesAndExecute(ctx, req, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\treturn err\n}\n\nfunc (c *ReverseExpandQuery) readTuplesAndExecute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tctx, span := tracer.Start(ctx, \"readTuplesAndExecute\")\n\tdefer span.End()\n\n\tvar userFilter []*openfgav1.ObjectRelation\n\tvar relationFilter string\n\n\tswitch req.edge.Type {\n\tcase graph.DirectEdge:\n\t\trelationFilter = req.edge.TargetReference.GetRelation()\n\t\ttargetUserObjectType := req.User.GetObjectType()\n\n\t\tpubliclyAssignable, err := c.typesystem.IsPubliclyAssignable(req.edge.TargetReference, targetUserObjectType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif publiclyAssignable {\n\t\t\t// e.g. 'user:*'\n\t\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\t\tObject: fmt.Sprintf(\"%s:*\", targetUserObjectType),\n\t\t\t})\n\t\t}\n\n\t\t// e.g. 'user:bob'\n\t\tif val, ok := req.User.(*UserRefObject); ok {\n\t\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\t\tObject: tuple.BuildObject(val.Object.Type, val.Object.Id),\n\t\t\t})\n\t\t}\n\n\t\t// e.g. 'group:eng#member'\n\t\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\t\tuserFilter = append(userFilter, val.ObjectRelation)\n\t\t}\n\tcase graph.TupleToUsersetEdge:\n\t\trelationFilter = req.edge.TuplesetRelation\n\t\t// a TTU edge can only have a userset as a source node\n\t\t// e.g. 'group:eng#member'\n\t\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\t\tObject: val.ObjectRelation.Object,\n\t\t\t})\n\t\t} else {\n\t\t\tpanic(\"unexpected source for reverse expansion of tuple to userset\")\n\t\t}\n\tdefault:\n\t\tpanic(\"unsupported edge type\")\n\t}\n\n\tcombinedTupleReader := storagewrappers.NewCombinedTupleReader(c.datastore, req.ContextualTuples)\n\n\t// find all tuples of the form req.edge.TargetReference.Type:...#relationFilter@userFilter\n\titer, err := combinedTupleReader.ReadStartingWithUser(ctx, req.StoreID, storage.ReadStartingWithUserFilter{\n\t\tObjectType: req.edge.TargetReference.GetType(),\n\t\tRelation:   relationFilter,\n\t\tUserFilter: userFilter,\n\t})\n\tatomic.AddUint32(resolutionMetadata.QueryCount, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// filter out invalid tuples yielded by the database iterator\n\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\tstorage.NewTupleKeyIteratorFromTupleIterator(iter),\n\t\tfunc(tupleKey *openfgav1.TupleKey) bool {\n\t\t\treturn validation.ValidateCondition(c.typesystem, tupleKey) == nil\n\t\t},\n\t)\n\tdefer filteredIter.Stop()\n\n\tpool := pool.New().WithContext(ctx)\n\tpool.WithCancelOnError()\n\tpool.WithFirstError()\n\tpool.WithMaxGoroutines(int(c.resolveNodeBreadthLimit))\n\n\tvar errs *multierror.Error\n\nLoopOnIterator:\n\tfor {\n\t\ttk, err := filteredIter.Next(ctx)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terrs = multierror.Append(errs, err)\n\t\t\tbreak LoopOnIterator\n\t\t}\n\n\t\tcondEvalResult, err := eval.EvaluateTupleCondition(ctx, tk, c.typesystem, req.Context)\n\t\tif err != nil {\n\t\t\terrs = multierror.Append(errs, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !condEvalResult.ConditionMet {\n\t\t\tif len(condEvalResult.MissingParameters) > 0 {\n\t\t\t\terrs = multierror.Append(errs, condition.NewEvaluationError(\n\t\t\t\t\ttk.GetCondition().GetName(),\n\t\t\t\t\tfmt.Errorf(\"tuple '%s' is missing context parameters '%v'\",\n\t\t\t\t\t\ttuple.TupleKeyToString(tk),\n\t\t\t\t\t\tcondEvalResult.MissingParameters),\n\t\t\t\t))\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tfoundObject := tk.GetObject()\n\t\tvar newRelation string\n\n\t\tswitch req.edge.Type {\n\t\tcase graph.DirectEdge:\n\t\t\tnewRelation = tk.GetRelation()\n\t\tcase graph.TupleToUsersetEdge:\n\t\t\tnewRelation = req.edge.TargetReference.GetRelation()\n\t\tdefault:\n\t\t\tpanic(\"unsupported edge type\")\n\t\t}\n\n\t\tpool.Go(func(ctx context.Context) error {\n\t\t\treturn c.execute(ctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:    req.StoreID,\n\t\t\t\tObjectType: req.ObjectType,\n\t\t\t\tRelation:   req.Relation,\n\t\t\t\tUser: &UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   foundObject,\n\t\t\t\t\t\tRelation: newRelation,\n\t\t\t\t\t},\n\t\t\t\t\tCondition: tk.GetCondition(),\n\t\t\t\t},\n\t\t\t\tContextualTuples: req.ContextualTuples,\n\t\t\t\tContext:          req.Context,\n\t\t\t\tedge:             req.edge,\n\t\t\t}, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t})\n\t}\n\n\terrs = multierror.Append(errs, pool.Wait())\n\tif errs.ErrorOrNil() != nil {\n\t\ttelemetry.TraceError(span, errs.ErrorOrNil())\n\t\treturn errs\n\t}\n\n\treturn nil\n}\n\nfunc (c *ReverseExpandQuery) trySendCandidate(ctx context.Context, intersectionOrExclusionInPreviousEdges bool, candidateObject string, candidateChan chan<- *ReverseExpandResult) error {\n\t_, span := tracer.Start(ctx, \"trySendCandidate\", trace.WithAttributes(\n\t\tattribute.String(\"object\", candidateObject),\n\t\tattribute.Bool(\"sent\", false),\n\t))\n\tdefer span.End()\n\n\tif _, ok := c.candidateObjectsMap.LoadOrStore(candidateObject, struct{}{}); !ok {\n\t\tresultStatus := NoFurtherEvalStatus\n\t\tif intersectionOrExclusionInPreviousEdges {\n\t\t\tspan.SetAttributes(attribute.Bool(\"requires_further_eval\", true))\n\t\t\tresultStatus = RequiresFurtherEvalStatus\n\t\t}\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase candidateChan <- &ReverseExpandResult{\n\t\t\tObject:       candidateObject,\n\t\t\tResultStatus: resultStatus,\n\t\t}:\n\t\t\tspan.SetAttributes(attribute.Bool(\"sent\", true))\n\t\t}\n\t}\n\n\treturn nil\n}\n", "package reverseexpand\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n\tgomock \"go.uber.org/mock/gomock\"\n\n\t\"go.uber.org/goleak\"\n\n\t\"github.com/openfga/openfga/internal/mocks\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nfunc TestReverseExpandRespectsContextCancellation(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user]`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tvar tuples []*openfgav1.Tuple\n\tfor i := 0; i < 100; i++ {\n\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(i))\n\t\ttuples = append(tuples, &openfgav1.Tuple{Key: tuple.NewTupleKey(obj, \"viewer\", \"user:maria\")})\n\t}\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tTimes(1).\n\t\tDoAndReturn(func(_ context.Context, _ string, _ storage.ReadStartingWithUserFilter) (storage.TupleIterator, error) {\n\t\t\t// simulate many goroutines trying to write to the results channel\n\t\t\titerator := storage.NewStaticTupleIterator(tuples)\n\t\t\tt.Logf(\"returning tuple iterator\")\n\t\t\treturn iterator, nil\n\t\t})\n\tctx, cancelFunc := context.WithCancel(context.Background())\n\n\tresultChan := make(chan *ReverseExpandResult)\n\n\tdone := make(chan struct{})\n\n\t// process query in one goroutine, but it will be cancelled almost right away\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\tt.Logf(\"before execute reverse expand\")\n\t\treverseExpandQuery.Execute(ctx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\t\tt.Logf(\"after execute reverse expand\")\n\t\tdone <- struct{}{}\n\t}()\n\tgo func() {\n\t\t// simulate max_results=1\n\t\tt.Logf(\"before receive one result\")\n\t\tres := <-resultChan\n\t\tt.Logf(\"after receive one result\")\n\t\tcancelFunc()\n\t\tt.Logf(\"after send cancellation\")\n\t\trequire.NotNil(t, res.Object)\n\t\trequire.NoError(t, res.Err)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tt.Log(\"OK!\")\n\t\treturn\n\tcase <-time.After(30 * time.Millisecond):\n\t\trequire.FailNow(t, \"timed out\")\n\t}\n}\n\nfunc TestReverseExpandRespectsContextTimeout(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine allowed: [user]\n\tdefine viewer: [user] and allowed`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tMaxTimes(2) // we expect it to be 0 most of the time\n\n\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), time.Nanosecond)\n\tdefer cancel()\n\tresultChan := make(chan *ReverseExpandResult)\n\tdone := make(chan struct{})\n\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\treverseExpandQuery.Execute(timeoutCtx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\t\tdone <- struct{}{}\n\t}()\n\tselect {\n\tcase res, open := <-resultChan:\n\t\tif open {\n\t\t\trequire.Error(t, res.Err)\n\t\t} else {\n\t\t\trequire.Nil(t, res)\n\t\t}\n\t\t<-done\n\tcase <-done:\n\t\t// OK!\n\t}\n}\n\nfunc TestReverseExpandErrorInTuples(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user]`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tvar tuples []*openfgav1.Tuple\n\tfor i := 0; i < 100; i++ {\n\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(i))\n\t\ttuples = append(tuples, &openfgav1.Tuple{Key: tuple.NewTupleKey(obj, \"viewer\", \"user:maria\")})\n\t}\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tDoAndReturn(func(_ context.Context, _ string, _ storage.ReadStartingWithUserFilter) (storage.TupleIterator, error) {\n\t\t\titerator := mocks.NewErrorTupleIterator(tuples)\n\t\t\treturn iterator, nil\n\t\t})\n\tctx, cancelFunc := context.WithCancel(context.Background())\n\n\tresultChan := make(chan *ReverseExpandResult)\n\n\tdone := make(chan struct{})\n\n\t// process query in one goroutine, but it will be cancelled almost right away\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\treverseExpandQuery.Execute(ctx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\t\tdone <- struct{}{}\n\t}()\n\n\tgo func() {\n\t\t<-resultChan\n\t\t// We want to read resultChan twice because Next() will fail after first read\n\t\t<-resultChan\n\t\tcancelFunc()\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn\n\tcase <-time.After(30 * time.Millisecond):\n\t\trequire.FailNow(t, \"timed out\")\n\t}\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\tparser \"github.com/openfga/language/pkg/go/transformer\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/openfga/openfga/cmd/migrate\"\n\t\"github.com/openfga/openfga/cmd/util\"\n\t\"github.com/openfga/openfga/internal/build\"\n\tmockstorage \"github.com/openfga/openfga/internal/mocks\"\n\tserverconfig \"github.com/openfga/openfga/internal/server/config\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/server/test\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\tstoragefixtures \"github.com/openfga/openfga/pkg/testfixtures/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nfunc init() {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"..\", \"..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestServerPanicIfNoDatastore(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: a datastore option must be provided\", func() {\n\t\t_ = MustNewServerWithOpts()\n\t})\n}\n\nfunc TestServerNotReadyDueToDatastoreRevision(t *testing.T) {\n\tengines := []string{\"postgres\", \"mysql\"}\n\n\tfor _, engine := range engines {\n\t\tt.Run(engine, func(t *testing.T) {\n\t\t\t_, ds, stopFunc, uri, err := util.MustBootstrapDatastore(t, engine)\n\t\t\tdefer stopFunc()\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttargetVersion := build.MinimumSupportedDatastoreSchemaRevision - 1\n\n\t\t\tmigrateCommand := migrate.NewMigrateCommand()\n\n\t\t\tmigrateCommand.SetArgs([]string{\"--datastore-engine\", engine, \"--datastore-uri\", uri, \"--version\", strconv.Itoa(int(targetVersion))})\n\n\t\t\terr = migrateCommand.Execute()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tstatus, _ := ds.IsReady(context.Background())\n\t\t\trequire.Contains(t, status.Message, fmt.Sprintf(\"datastore requires migrations: at revision '%d', but requires '%d'.\", targetVersion, build.MinimumSupportedDatastoreSchemaRevision))\n\t\t\trequire.False(t, status.IsReady)\n\t\t})\n\t}\n}\n\nfunc TestServerPanicIfEmptyRequestDurationDatastoreCountBuckets(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: request duration datastore count buckets must not be empty\", func() {\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\t_ = MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t\tWithRequestDurationByQueryHistogramBuckets([]uint{}),\n\t\t)\n\t})\n}\n\nfunc TestServerWithPostgresDatastore(t *testing.T) {\n\tds, stopFunc := MustBootstrapDatastore(t, \"postgres\")\n\tdefer func() {\n\t\tstopFunc()\n\t\t//goleak.VerifyNone(t)\n\t}()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithPostgresDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\tdefer func() {\n\t\tstopFunc()\n\t\t//goleak.VerifyNone(t)\n\t}()\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := postgres.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMemoryDatastore(t *testing.T) {\n\tds, stopFunc := MustBootstrapDatastore(t, \"memory\")\n\tdefer func() {\n\t\tstopFunc()\n\t\t//goleak.VerifyNone(t)\n\t}()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastore(t *testing.T) {\n\tds, stopFunc := MustBootstrapDatastore(t, \"mysql\")\n\tdefer func() {\n\t\tstopFunc()\n\t\t//goleak.VerifyNone(t)\n\t}()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, \"mysql\")\n\tdefer func() {\n\t\tstopFunc()\n\t\t//goleak.VerifyNone(t)\n\t}()\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := mysql.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc BenchmarkOpenFGAServer(b *testing.B) {\n\tb.Run(\"BenchmarkPostgresDatastore\", func(b *testing.B) {\n\t\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(b, \"postgres\")\n\t\tdefer stopFunc()\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := postgres.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMemoryDatastore\", func(b *testing.B) {\n\t\tds := memory.New()\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMySQLDatastore\", func(b *testing.B) {\n\t\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(b, \"mysql\")\n\t\tdefer stopFunc()\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := mysql.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n}\n\nfunc TestCheckDoesNotThrowBecauseDirectTupleWasFound(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user]\n`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"reader\", \"user:anne\")\n\treturnedTuple := &openfgav1.Tuple{Key: tuple.ConvertCheckRequestTupleKeyToTupleKey(tk)}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(returnedTuple, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn nil, errors.New(\"some error\")\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestListObjectsReleasesConnections(t *testing.T) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\tdefer stopFunc()\n\n\turi := testDatastore.GetConnectionURI(true)\n\tds, err := postgres.New(uri, sqlcommon.NewConfig(\n\t\tsqlcommon.WithMaxOpenConns(1),\n\t\tsqlcommon.WithMaxTuplesPerWrite(2000),\n\t))\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(storagewrappers.NewContextWrapper(ds)),\n\t\tWithMaxConcurrentReadsForListObjects(1),\n\t)\n\n\tstoreID := ulid.Make().String()\n\n\twriteAuthzModelResp, err := s.WriteAuthorizationModel(context.Background(), &openfgav1.WriteAuthorizationModelRequest{\n\t\tStoreId: storeID,\n\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine editor: [user]`).TypeDefinitions,\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t})\n\trequire.NoError(t, err)\n\n\tmodelID := writeAuthzModelResp.GetAuthorizationModelId()\n\n\tnumTuples := 2000\n\ttuples := make([]*openfgav1.TupleKey, 0, numTuples)\n\tfor i := 0; i < numTuples; i++ {\n\t\ttk := tuple.NewTupleKey(fmt.Sprintf(\"document:%d\", i), \"editor\", \"user:jon\")\n\n\t\ttuples = append(tuples, tk)\n\t}\n\n\t_, err = s.Write(context.Background(), &openfgav1.WriteRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tWrites: &openfgav1.WriteRequestWrites{\n\t\t\tTupleKeys: tuples,\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\n\t_, err = s.ListObjects(context.Background(), &openfgav1.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"document\",\n\t\tRelation:             \"editor\",\n\t\tUser:                 \"user:jon\",\n\t})\n\trequire.NoError(t, err)\n\n\ttimeoutCtx, timeoutCancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer timeoutCancel()\n\n\t// If ListObjects is still hogging the database connection pool even after responding, then this fails.\n\t// If ListObjects is closing up its connections effectively then this will not fail.\n\tstatus, err := ds.IsReady(timeoutCtx)\n\trequire.NoError(t, err)\n\trequire.True(t, status.IsReady)\n}\n\nfunc TestOperationsWithInvalidModel(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\t// The model is invalid\n\ttypedefs := parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine admin: [user]\n\tdefine r1: [user] and r2 and r3\n\tdefine r2: [user] and r1 and r3\n\tdefine r3: [user] and r1 and r2`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"r1\", \"user:anne\")\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tId:              modelID,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// the model is error and err should return\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.Error(t, err)\n\te, ok := status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t}, NewMockStreamServer())\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.Expand(ctx, &openfgav1.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tuple.NewExpandRequestTupleKey(tk.Object, tk.Relation),\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n}\n\nfunc TestShortestPathToSolutionWins(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user:*]`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"reader\", \"user:*\")\n\treturnedTuple := &openfgav1.Tuple{Key: tuple.ConvertCheckRequestTupleKeyToTupleKey(tk)}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(ctx context.Context, _ string, _ *openfgav1.TupleKey) (storage.TupleIterator, error) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\t\t\treturn nil, storage.ErrNotFound\n\t\t\t\t}\n\t\t\t})\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\treturn storage.NewStaticTupleIterator([]*openfgav1.Tuple{returnedTuple}), nil\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tstart := time.Now()\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\tend := time.Since(start)\n\n\t// we expect the Check call to be short-circuited after ReadUsersetTuples runs\n\trequire.Lessf(t, end, 200*time.Millisecond, fmt.Sprintf(\"end was %s\", end))\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestCheckWithCachedResolution(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user]`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"reader\", \"user:mike\")\n\treturnedTuple := &openfgav1.Tuple{Key: tuple.ConvertCheckRequestTupleKeyToTupleKey(tk)}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tTimes(1).\n\t\tReturn(returnedTuple, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t\tWithCheckQueryCacheEnabled(true),\n\t\tWithCheckQueryCacheLimit(10),\n\t\tWithCheckQueryCacheTTL(1*time.Minute),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n\n\t// If we check for the same request, data should come from cache and number of ReadUserTuple should still be 1\n\tcheckResponse, err = s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestWriteAssertionModelDSError(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user]`).TypeDefinitions\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDSOldSchema := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDSOldSchema.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\tmockDSBadReadAuthModel := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDSBadReadAuthModel.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(nil, fmt.Errorf(\"unable to read\"))\n\n\tmockDSBadWriteAssertions := mockstorage.NewMockOpenFGADatastore(mockController)\n\tmockDSBadWriteAssertions.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\tmockDSBadWriteAssertions.EXPECT().\n\t\tWriteAssertions(gomock.Any(), storeID, modelID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(fmt.Errorf(\"unable to write\"))\n\n\ttests := []struct {\n\t\tname          string\n\t\tassertions    []*openfgav1.Assertion\n\t\tmockDatastore *mockstorage.MockOpenFGADatastore\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"unsupported_schema\",\n\t\t\tassertions:    []*openfgav1.Assertion{},\n\t\t\tmockDatastore: mockDSOldSchema,\n\t\t\texpectedError: serverErrors.ValidationError(\n\t\t\t\tfmt.Errorf(\"invalid schema version\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"failed_to_read\",\n\t\t\tassertions:    []*openfgav1.Assertion{},\n\t\t\tmockDatastore: mockDSBadReadAuthModel,\n\t\t\texpectedError: serverErrors.NewInternalError(\n\t\t\t\t\"\", fmt.Errorf(\"unable to read\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"failed_to_write\",\n\t\t\tassertions:    []*openfgav1.Assertion{},\n\t\t\tmockDatastore: mockDSBadWriteAssertions,\n\t\t\texpectedError: serverErrors.NewInternalError(\n\t\t\t\t\"\", fmt.Errorf(\"unable to write\"),\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, curTest := range tests {\n\t\tt.Run(curTest.name, func(t *testing.T) {\n\t\t\trequest := &openfgav1.WriteAssertionsRequest{\n\t\t\t\tStoreId:              storeID,\n\t\t\t\tAssertions:           curTest.assertions,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t}\n\n\t\t\twriteAssertionCmd := commands.NewWriteAssertionsCommand(curTest.mockDatastore)\n\t\t\t_, err := writeAssertionCmd.Execute(ctx, request)\n\t\t\trequire.ErrorIs(t, curTest.expectedError, err)\n\t\t})\n\t}\n}\n\nfunc TestReadAssertionModelDSError(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDSBadReadAssertions := mockstorage.NewMockOpenFGADatastore(mockController)\n\tmockDSBadReadAssertions.EXPECT().\n\t\tReadAssertions(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(nil, fmt.Errorf(\"unable to read\"))\n\n\treadAssertionQuery := commands.NewReadAssertionsQuery(mockDSBadReadAssertions)\n\t_, err := readAssertionQuery.Execute(ctx, storeID, modelID)\n\texpectedError := serverErrors.NewInternalError(\n\t\t\"\", fmt.Errorf(\"unable to read\"),\n\t)\n\trequire.ErrorIs(t, expectedError, err)\n}\n\nfunc TestResolveAuthorizationModel(t *testing.T) {\n\tctx := context.Background()\n\n\tt.Run(\"no_latest_authorization_model_id_found\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(\"\", storage.ErrNotFound)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\texpectedError := serverErrors.LatestAuthorizationModelNotFound(store)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.ErrorIs(t, err, expectedError)\n\t})\n\n\tt.Run(\"read_existing_authorization_model\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(modelID, nil)\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).Return(\n\t\t\t&openfgav1.AuthorizationModel{\n\t\t\t\tId:            modelID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\ttypesys, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, modelID, typesys.GetAuthorizationModelID())\n\t})\n\n\tt.Run(\"non-valid_modelID_returns_error\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := \"foo\"\n\t\twant := serverErrors.AuthorizationModelNotFound(modelID)\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, modelID)\n\t\trequire.Equal(t, want, err)\n\t})\n}\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n}\n\nfunc NewMockStreamServer() *mockStreamServer {\n\treturn &mockStreamServer{}\n}\n\nfunc (m *mockStreamServer) Context() context.Context {\n\treturn context.Background()\n}\n\nfunc (m *mockStreamServer) Send(*openfgav1.StreamedListObjectsResponse) error {\n\treturn nil\n}\n\n// This runs ListObjects and StreamedListObjects many times over to ensure no race conditions (see https://github.com/openfga/openfga/pull/762)\nfunc BenchmarkListObjectsNoRaceCondition(b *testing.B) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(b)\n\tdefer mockController.Finish()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine allowed: [user]\n\tdefine viewer: [user] and allowed`).TypeDefinitions\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\n\t\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t}\n}\n\nfunc TestListObjects_ErrorCases(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tt.Run(\"database_errors\", func(t *testing.T) {\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype document\n  relations\n\tdefine viewer: [user, user:*]`).TypeDefinitions,\n\t\t}, nil)\n\n\t\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUserFilter: []*openfgav1.ObjectRelation{\n\t\t\t\t{Object: \"user:*\"},\n\t\t\t\t{Object: \"user:bob\"},\n\t\t\t}}).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\t\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:bob\",\n\t\t\t})\n\n\t\t\trequire.Nil(t, res)\n\t\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t\t})\n\n\t\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:bob\",\n\t\t\t}, NewMockStreamServer())\n\n\t\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t\t})\n\t})\n\n\tt.Run(\"graph_resolution_errors\", func(t *testing.T) {\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(memory.New()),\n\t\t\tWithResolveNodeLimit(2),\n\t\t)\n\n\t\twriteModelResp, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:       store,\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user, group#member]\n\ntype document\n  relations\n\tdefine viewer: [group#member]`).TypeDefinitions,\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId: store,\n\t\t\tWrites: &openfgav1.WriteRequestWrites{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:1#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:2#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:3#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:3\", \"member\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\tt.Run(\"resolution_depth_exceeded_error_unary\", func(t *testing.T) {\n\t\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: writeModelResp.GetAuthorizationModelId(),\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:jon\",\n\t\t\t})\n\n\t\t\trequire.Nil(t, res)\n\t\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t\t})\n\n\t\tt.Run(\"resolution_depth_exceeded_error_streaming\", func(t *testing.T) {\n\t\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: writeModelResp.GetAuthorizationModelId(),\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:jon\",\n\t\t\t}, NewMockStreamServer())\n\n\t\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t\t})\n\t})\n}\n\nfunc TestAuthorizationModelInvalidSchemaVersion(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\"member\": typesystem.This(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"invalid_schema_error_in_check\", func(t *testing.T) {\n\t\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewCheckRequestTupleKey(\n\t\t\t\t\"team:abc\",\n\t\t\t\t\"member\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_list_objects\", func(t *testing.T) {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_streamed_list_objects\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t}, NewMockStreamServer())\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write\", func(t *testing.T) {\n\t\t_, err := s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tWrites: &openfgav1.WriteRequestWrites{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tObject:   \"repo:openfga/openfga\",\n\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_model\", func(t *testing.T) {\n\t\tmockDatastore.EXPECT().MaxTypesPerAuthorizationModel().Return(100)\n\n\t\t_, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:       store,\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype repo\n`).TypeDefinitions,\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_invalid_authorization_model), e.Code(), err)\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_assertion\", func(t *testing.T) {\n\t\t_, err := s.WriteAssertions(ctx, &openfgav1.WriteAssertionsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tAssertions: []*openfgav1.Assertion{{\n\t\t\t\tTupleKey:    tuple.NewAssertionTupleKey(\"repo:test\", \"reader\", \"user:elbuo\"),\n\t\t\t\tExpectation: false,\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n}\n\nfunc TestDefaultMaxConcurrentReadSettings(t *testing.T) {\n\tcfg := serverconfig.DefaultConfig()\n\trequire.EqualValues(t, math.MaxUint32, cfg.MaxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, cfg.MaxConcurrentReadsForListObjects)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(memory.New()),\n\t)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForListObjects)\n}\n\nfunc MustBootstrapDatastore(t testing.TB, engine string) (storage.OpenFGADatastore, func()) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, engine)\n\n\turi := testDatastore.GetConnectionURI(true)\n\n\tvar ds storage.OpenFGADatastore\n\tvar err error\n\n\tswitch engine {\n\tcase \"memory\":\n\t\tds = memory.New()\n\tcase \"postgres\":\n\t\tds, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"mysql\":\n\t\tds, err = mysql.New(uri, sqlcommon.NewConfig())\n\tdefault:\n\t\tt.Fatalf(\"'%s' is not a supported datastore engine\", engine)\n\t}\n\trequire.NoError(t, err)\n\n\treturn ds, func() {\n\t\tds.Close()\n\t\tstopFunc()\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/karlseguin/ccache/v3\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\tparser \"github.com/openfga/language/pkg/go/transformer\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/mocks\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n\tchannel chan string\n}\n\nfunc (x *mockStreamServer) Send(m *openfgav1.StreamedListObjectsResponse) error {\n\tx.channel <- m.Object\n\treturn nil\n}\n\ntype listObjectsTestCase struct {\n\tname                   string\n\ttuples                 []*openfgav1.TupleKey\n\tmodel                  string\n\tobjectType             string\n\tuser                   string\n\trelation               string\n\tcontextualTuples       *openfgav1.ContextualTupleKeys\n\tcontext                *structpb.Struct\n\tallResults             []string // all the results. the server may return less\n\tmaxResults             uint32\n\tminimumResultsExpected uint32\n\tlistObjectsDeadline    time.Duration // 10 seconds if not set\n\treadTuplesDelay        time.Duration // if set, purposely use a slow storage to slow down read and simulate timeout\n\tuseCheckCache          bool\n}\n\nfunc TestListObjects(t *testing.T, ds storage.OpenFGADatastore) {\n\ttestCases := []listObjectsTestCase{\n\t\t{\n\t\t\tname: \"max_results_equal_0_with_simple_model\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             0,\n\t\t\tminimumResultsExpected: 3,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"max_results_equal_2_with_simple_model\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"max_results_with_model_that_uses_exclusion\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype org\n  relations\n\tdefine blocked: [user]\n\tdefine admin: [user] but not blocked`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"org:1\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"admin\", \"user:charlie\"),\n\t\t\t},\n\t\t\tuser:       \"user:charlie\",\n\t\t\tobjectType: \"org\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"org:3\", \"admin\", \"user:charlie\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"org:1\", \"org:2\", \"org:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"max_results_with_model_that_uses_exclusion_and_one_object_is_a_false_candidate\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype org\n  relations\n\tdefine blocked: [user]\n\tdefine admin: [user] but not blocked`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"blocked\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:1\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:3\", \"admin\", \"user:charlie\"),\n\t\t\t},\n\t\t\tuser:                   \"user:charlie\",\n\t\t\tobjectType:             \"org\",\n\t\t\trelation:               \"admin\",\n\t\t\tcontextualTuples:       &openfgav1.ContextualTupleKeys{},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"org:1\", \"org:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"respects_when_schema_1_1_and_maxresults_is_higher_than_actual_result_length\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype team\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:1\", \"admin\", \"user:bob\"),\n\t\t\t},\n\t\t\tuser:                   \"user:bob\",\n\t\t\tobjectType:             \"team\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"team:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"respects_max_results_when_deadline_timeout_and_returns_no_error_and_no_results\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:                   \"user:alice\",\n\t\t\tobjectType:             \"repo\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 0,\n\t\t\t// We expect empty array to be returned as list object will timeout due to readTuplesDelay > listObjectsDeadline\n\t\t\tallResults:          []string{},\n\t\t\tlistObjectsDeadline: 1 * time.Second,\n\t\t\treadTuplesDelay:     2 * time.Second, // We are mocking the ds to slow down the read call and simulate timeout\n\t\t\tuseCheckCache:       false,\n\t\t},\n\t\t{\n\t\t\tname: \"list_object_use_check_cache\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t\t// when we use cache, the regular_endpoint should pick up the cached value from the streaming_endpoint run\n\t\t\tuseCheckCache: true,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_tuples\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string) {\n  param1 == 'ok'\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tuser:                   \"user:anne\",\n\t\t\tobjectType:             \"document\",\n\t\t\trelation:               \"viewer\",\n\t\t\tcontextualTuples:       nil,\n\t\t\tmaxResults:             1,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"document:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_contextual_tuples\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string) {\n  param1 == 'ok'\n}`,\n\t\t\ttuples:     nil,\n\t\t\tuser:       \"user:anne\",\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmaxResults:             1,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"document:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_tuples_and_contextual_tuples\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string) {\n  param1 == 'ok'\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tuser:       \"user:anne\",\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"document:1\", \"document:2\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_tuples_and_contextual_tuples_and_context\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string, param2: string) {\n  param1 == 'ok' && param2 == 'ok'\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tuser:       \"user:anne\",\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\tcontext:    testutils.MustNewStruct(t, map[string]interface{}{\"param2\": \"ok\"}),\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:3\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:4\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmaxResults:             4,\n\t\t\tminimumResultsExpected: 4,\n\t\t\tallResults:             []string{\"document:1\", \"document:2\", \"document:3\", \"document:4\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_in_ttu_relationships\",\n\t\t\tmodel: `model\n  schema 1.1\n\ntype user\n\ntype folder\n  relations\n    define viewer: [user]\n\ntype document\n  relations\n    define parent: [folder with condition1]\n\tdefine viewer: viewer from parent\n\ncondition condition1(x: int) {\n  x < 100\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKeyWithCondition(\"document:1\", \"parent\", \"folder:x\", \"condition1\", nil),\n\t\t\t\ttuple.NewTupleKey(\"folder:x\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\tuser:                   \"user:jon\",\n\t\t\tobjectType:             \"document\",\n\t\t\trelation:               \"viewer\",\n\t\t\tcontext:                testutils.MustNewStruct(t, map[string]interface{}{\"x\": 50}),\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"document:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx := context.Background()\n\t\t\tstoreID := ulid.Make().String()\n\n\t\t\t// arrange: write model\n\t\t\tmodel := testutils.MustTransformDSLToProtoWithID(test.model)\n\n\t\t\terr := ds.WriteAuthorizationModel(ctx, storeID, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// arrange: write tuples\n\t\t\terr = ds.Write(context.Background(), storeID, nil, test.tuples)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// act: run ListObjects\n\n\t\t\tdatastore := ds\n\t\t\tif test.readTuplesDelay > 0 {\n\t\t\t\tdatastore = mocks.NewMockSlowDataStorage(ds, test.readTuplesDelay)\n\t\t\t}\n\n\t\t\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\t\t\topts := []commands.ListObjectsQueryOption{\n\t\t\t\tcommands.WithListObjectsMaxResults(test.maxResults),\n\t\t\t\tcommands.WithListObjectsDeadline(10 * time.Second),\n\t\t\t}\n\n\t\t\tif test.listObjectsDeadline != 0 {\n\t\t\t\topts = append(opts, commands.WithListObjectsDeadline(test.listObjectsDeadline))\n\t\t\t}\n\n\t\t\tcheckOptions := []graph.LocalCheckerOption{\n\t\t\t\tgraph.WithResolveNodeBreadthLimit(100),\n\t\t\t\tgraph.WithMaxConcurrentReads(30),\n\t\t\t}\n\n\t\t\tif test.useCheckCache {\n\t\t\t\tcheckCache := ccache.New(\n\t\t\t\t\tccache.Configure[*graph.CachedResolveCheckResponse]().MaxSize(100),\n\t\t\t\t)\n\t\t\t\tdefer checkCache.Stop()\n\n\t\t\t\tcheckOptions = append(checkOptions, graph.WithCachedResolver(\n\t\t\t\t\tgraph.WithExistingCache(checkCache),\n\t\t\t\t\tgraph.WithCacheTTL(10*time.Second),\n\t\t\t\t))\n\t\t\t}\n\n\t\t\topts = append(opts, commands.WithCheckOptions(checkOptions))\n\t\t\tlistObjectsQuery := commands.NewListObjectsQuery(datastore, opts...)\n\n\t\t\t// assertions\n\t\t\tt.Run(\"streaming_endpoint\", func(t *testing.T) {\n\t\t\t\tserver := &mockStreamServer{\n\t\t\t\t\tchannel: make(chan string, len(test.allResults)),\n\t\t\t\t}\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tvar streamedObjectIds []string\n\t\t\t\tgo func() {\n\t\t\t\t\tfor x := range server.channel {\n\t\t\t\t\t\tstreamedObjectIds = append(streamedObjectIds, x)\n\t\t\t\t\t}\n\n\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t}()\n\n\t\t\t\t_, err := listObjectsQuery.ExecuteStreamed(ctx, &openfgav1.StreamedListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t\tContext:          test.context,\n\t\t\t\t}, server)\n\t\t\t\tclose(server.channel)\n\t\t\t\t<-done\n\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\t// there is no upper bound of the number of results for the streamed version\n\t\t\t\trequire.GreaterOrEqual(t, len(streamedObjectIds), int(test.minimumResultsExpected))\n\t\t\t\trequire.ElementsMatch(t, test.allResults, streamedObjectIds)\n\t\t\t})\n\n\t\t\tt.Run(\"regular_endpoint\", func(t *testing.T) {\n\t\t\t\tres, err := listObjectsQuery.Execute(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t\tContext:          test.context,\n\t\t\t\t})\n\n\t\t\t\trequire.NotNil(t, res)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tif test.maxResults != 0 { // don't get all results\n\t\t\t\t\trequire.LessOrEqual(t, len(res.Objects), int(test.maxResults))\n\t\t\t\t}\n\t\t\t\trequire.GreaterOrEqual(t, len(res.Objects), int(test.minimumResultsExpected))\n\t\t\t\trequire.Subset(t, test.allResults, res.Objects)\n\t\t\t})\n\t\t})\n\t}\n}\n\n// Used to avoid compiler optimizations (see https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)\nvar listObjectsResponse *commands.ListObjectsResponse //nolint\n\n// setupListObjectsBenchmark writes the model and lots of tuples\nfunc setupListObjectsBenchmark(b *testing.B, ds storage.OpenFGADatastore, storeID string) (*openfgav1.AuthorizationModel, string, int) {\n\tb.Helper()\n\tmodelID := ulid.Make().String()\n\tmodel := &openfgav1.AuthorizationModel{\n\t\tId:            modelID,\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t// this model exercises all possible execution paths: \"direct\" edge and \"computed userset\" edge and \"TTU\" edge\n\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\ntype folder\n  relations\n    define viewer: [user]\ntype document\n  relations\n\tdefine viewer: [user]\n\tdefine parent: [folder]\n\tdefine can_view: viewer or viewer from parent`).TypeDefinitions,\n\t}\n\terr := ds.WriteAuthorizationModel(context.Background(), storeID, model)\n\trequire.NoError(b, err)\n\n\tnumberObjectsAccesible := 0\n\tfor i := 0; i < 100; i++ {\n\t\tvar tuples []*openfgav1.TupleKey\n\n\t\tfor j := 0; j < ds.MaxTuplesPerWrite(); j++ {\n\t\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(numberObjectsAccesible))\n\n\t\t\ttuples = append(tuples, tuple.NewTupleKey(obj, \"viewer\", \"user:maria\"))\n\n\t\t\tnumberObjectsAccesible += 1\n\t\t}\n\n\t\terr := ds.Write(context.Background(), storeID, nil, tuples)\n\t\trequire.NoError(b, err)\n\t}\n\n\treturn model, modelID, numberObjectsAccesible\n}\n\nfunc BenchmarkListObjects(b *testing.B, ds storage.OpenFGADatastore) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmodel, modelID, numberObjectsAccessible := setupListObjectsBenchmark(b, ds, store)\n\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\treq := &openfgav1.ListObjectsRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"document\",\n\t\tRelation:             \"can_view\",\n\t\tUser:                 \"user:maria\",\n\t}\n\n\tvar r *commands.ListObjectsResponse\n\n\tvar oneResultIterations, allResultsIterations int\n\n\tb.Run(\"oneResult\", func(b *testing.B) {\n\t\tlistObjectsQuery := commands.NewListObjectsQuery(ds,\n\t\t\tcommands.WithListObjectsMaxResults(1),\n\t\t)\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tr, _ := listObjectsQuery.Execute(ctx, req)\n\t\t\trequire.Len(b, r.Objects, 1)\n\t\t}\n\n\t\tlistObjectsResponse = r\n\t\toneResultIterations = b.N\n\t})\n\tb.Run(\"allResults\", func(b *testing.B) {\n\t\tlistObjectsQuery := commands.NewListObjectsQuery(ds,\n\t\t\tcommands.WithListObjectsMaxResults(0),\n\t\t)\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tr, _ := listObjectsQuery.Execute(ctx, req)\n\t\t\trequire.Len(b, r.Objects, numberObjectsAccessible)\n\t\t}\n\n\t\tlistObjectsResponse = r\n\t\tallResultsIterations = b.N\n\t})\n\n\trequire.Greater(b, oneResultIterations, allResultsIterations)\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nfunc TestReverseExpand(t *testing.T, ds storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname                 string\n\t\tmodel                string\n\t\ttuples               []*openfgav1.TupleKey\n\t\trequest              *reverseexpand.ReverseExpandRequest\n\t\tresolveNodeLimit     uint32\n\t\texpectedResult       []*reverseexpand.ReverseExpandResult\n\t\texpectedError        error\n\t\texpectedDSQueryCount uint32\n\t}{\n\t\t{\n\t\t\tname: \"basic_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine allowed: [user]\n\tdefine viewer: [user] and allowed`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"allowed\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine writer: [user]\n\tdefine editor: [user]\n\tdefine viewer: writer and editor\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:X\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"writer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"editor\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\n\t\t{\n\t\t\tname: \"resolve_direct_relationships_with_tuples_and_contextual_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine viewer: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_involving_relationships_with_users_and_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype document\n  relations\n\tdefine viewer: [user, group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_direct_relationships_and_computed_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype document\n  relations\n\tdefine owner: [user, group#member]\n\tdefine viewer: owner`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"owner\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"owner\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"owner\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_many_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder5\", \"parent\", \"folder:folder4\"),\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder6\", \"viewer\", \"user:bob\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user, group#member]\n\ntype folder\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: [user, group#member] or viewer from parent\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder4\", \"viewer\", \"group:eng#member\"),\n\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder3\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"parent\", \"folder:folder5\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"parent\", \"folder:folder6\"),\n\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_objects_involved_in_recursive_hierarchy\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: [user] or viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"resolution_depth_exceeded_failure\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tresolveNodeLimit: 2,\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: [user] or viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedError:        graph.ErrResolutionDepthExceeded,\n\t\t\texpectedDSQueryCount: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user, group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:opensource\", \"member\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:iam#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:opensource\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:eng\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset_self_referencing\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype group\n  relations\n\tdefine member: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"group:iam#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:iam\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine owner: [user]\n\tdefine editor: owner\n\tdefine viewer: [document#editor]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#editor\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"owner\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine manager: [user]\n\tdefine member: manager\n\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"manager\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"trial\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"fede\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype team\n  relations\n\tdefine admin: [user]\n\tdefine member: admin\n\ntype trial\n  relations\n\tdefine editor: [team#member]\n\tdefine viewer: editor`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"trial:1\", \"editor\", \"team:devs#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:devs\", \"admin\", \"user:fede\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"trial:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_indirectly_through_a_ttu\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"view\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"organization\",\n\t\t\t\t\t\tId:   \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype organization\n  relations\n\tdefine viewer: [organization]\n\tdefine can_view: viewer\n\ntype document\n  relations\n\tdefine parent: [organization]\n\tdefine view: can_view from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"organization:1\"),\n\t\t\t\ttuple.NewTupleKey(\"organization:1\", \"viewer\", \"organization:2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"directly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine viewer: [user, user:*]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirectly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype team\n  relations\n\tdefine member: [user]\ntype group\n  relations\n\tdefine member: [team#member]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"typed_wildcard_relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [team#member]\ntype team\n  relations\n\tdefine member: [user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_direct_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user, user:*]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_indirect_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user, user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:other\", \"member\", \"employee:*\"), // assume this comes from a prior model\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"group:other#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"bev\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user]\ntype resource\n  relations\n\tdefine reader: [user, user:*, group#member] or writer\n\tdefine writer: [user, user:*, group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:x\", \"writer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:x\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user, user:*]`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"employee:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype employee\ntype document\n  relations\n\tdefine viewer: [user:*]`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:eng\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine viewer: [user, user:*]\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_without_wildcard_connectivity\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype employee\n\ntype folder\n  relations\n\tdefine viewer: [user, employee:*]\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user:*]\ntype folder\n  relations\n\tdefine viewer: [group#member]\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"writer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype org\n  relations\n\tdefine dept: [group]\n\tdefine dept_member: member from dept\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype resource\n  relations\n\tdefine writer: [org#dept_member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype org\n  relations\n\tdefine dept: [group]\n\tdefine dept_member: member from dept\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype resource\n  relations\n\tdefine writer: [org#dept_member]\n\tdefine reader: [org#dept_member] or writer`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_tupleset_relation_terminates\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"node\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"wonder\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype node\n  relations\n\tdefine parent: [node]\n\tdefine editor: [user] or editor from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"node:abc\", \"editor\", \"user:wonder\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"node:abc\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"does_not_send_duplicate_even_though_there_are_two_paths_to_same_solution\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\tdefine maintainer: [user]\n\ntype document\n  relations\n\tdefine viewer: [group#member,group#maintainer]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:example1#maintainer\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"maintainer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire := require.New(t)\n\n\t\t\tctx := context.Background()\n\t\t\tstore := ulid.Make().String()\n\t\t\ttest.request.StoreID = store\n\n\t\t\tmodel := testutils.MustTransformDSLToProtoWithID(test.model)\n\t\t\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(err)\n\n\t\t\terr = ds.Write(ctx, store, nil, test.tuples)\n\t\t\trequire.NoError(err)\n\n\t\t\tvar opts []reverseexpand.ReverseExpandQueryOption\n\n\t\t\tif test.resolveNodeLimit != 0 {\n\t\t\t\topts = append(opts, reverseexpand.WithResolveNodeLimit(test.resolveNodeLimit))\n\t\t\t}\n\n\t\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(ds, typesystem.New(model), opts...)\n\n\t\t\tresultChan := make(chan *reverseexpand.ReverseExpandResult, 100)\n\n\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\t\t\tgo func() {\n\t\t\t\treverseExpandQuery.Execute(timeoutCtx, test.request, resultChan, resolutionMetadata)\n\t\t\t}()\n\n\t\t\tvar results []*reverseexpand.ReverseExpandResult\n\t\t\treverseExpandErrCh := make(chan error)\n\t\t\tgo func() {\n\t\t\t\tfor result := range resultChan {\n\t\t\t\t\tif result.Err != nil {\n\t\t\t\t\t\treverseExpandErrCh <- result.Err\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tresults = append(results, result)\n\t\t\t\t}\n\n\t\t\t\treverseExpandErrCh <- nil\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-timeoutCtx.Done():\n\t\t\t\trequire.FailNow(\"timed out waiting for response\")\n\t\t\tcase err := <-reverseExpandErrCh:\n\t\t\t\trequire.ErrorIs(err, test.expectedError)\n\t\t\t}\n\n\t\t\tif test.expectedError == nil {\n\t\t\t\trequire.ElementsMatch(test.expectedResult, results)\n\t\t\t\trequire.Equal(test.expectedDSQueryCount, *resolutionMetadata.QueryCount)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package storage\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/go-connections/nat\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/openfga/openfga/assets\"\n)\n\nconst (\n\tmySQLImage = \"mysql:8\"\n)\n\ntype mySQLTestContainer struct {\n\taddr     string\n\tversion  int64\n\tusername string\n\tpassword string\n}\n\n// NewMySQLTestContainer returns an implementation of the DatastoreTestContainer interface\n// for MySQL.\nfunc NewMySQLTestContainer() *mySQLTestContainer {\n\treturn &mySQLTestContainer{}\n}\n\nfunc (m *mySQLTestContainer) GetDatabaseSchemaVersion() int64 {\n\treturn m.version\n}\n\n// RunMySQLTestContainer runs a MySQL container, connects to it, and returns a\n// bootstrapped implementation of the DatastoreTestContainer interface wired up for the\n// MySQL datastore engine.\nfunc (m *mySQLTestContainer) RunMySQLTestContainer(t testing.TB) (DatastoreTestContainer, func()) {\n\tdockerClient, err := client.NewClientWithOpts(\n\t\tclient.FromEnv,\n\t\tclient.WithAPIVersionNegotiation(),\n\t)\n\trequire.NoError(t, err)\n\n\tallImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{\n\t\tAll: true,\n\t})\n\trequire.NoError(t, err)\n\n\tfoundMysqlImage := false\n\tfor _, image := range allImages {\n\t\tfor _, tag := range image.RepoTags {\n\t\t\tif strings.Contains(tag, mySQLImage) {\n\t\t\t\tfoundMysqlImage = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !foundMysqlImage {\n\t\tt.Logf(\"Pulling image %s\", mySQLImage)\n\t\treader, err := dockerClient.ImagePull(context.Background(), mySQLImage, types.ImagePullOptions{})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done\n\t\trequire.NoError(t, err)\n\t}\n\n\tcontainerCfg := container.Config{\n\t\tEnv: []string{\n\t\t\t\"MYSQL_DATABASE=defaultdb\",\n\t\t\t\"MYSQL_ROOT_PASSWORD=secret\",\n\t\t},\n\t\tExposedPorts: nat.PortSet{\n\t\t\tnat.Port(\"3306/tcp\"): {},\n\t\t},\n\t\tImage: mySQLImage,\n\t}\n\n\thostCfg := container.HostConfig{\n\t\tAutoRemove:      true,\n\t\tPublishAllPorts: true,\n\t\tTmpfs:           map[string]string{\"/var/lib/mysql\": \"\"},\n\t}\n\n\tname := fmt.Sprintf(\"mysql-%s\", ulid.Make().String())\n\n\tcont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)\n\trequire.NoError(t, err, \"failed to create mysql docker container\")\n\n\tstopContainer := func() {\n\t\tt.Logf(\"stopping container %s\", name)\n\t\ttimeoutSec := 5\n\n\t\terr := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})\n\t\tif err != nil && !client.IsErrNotFound(err) {\n\t\t\tt.Logf(\"failed to stop mysql container: %v\", err)\n\t\t}\n\n\t\tdockerClient.Close()\n\t\tt.Logf(\"stopped container %s\", name)\n\t}\n\n\terr = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to start mysql container: %v\", err)\n\t}\n\n\tcontainerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)\n\trequire.NoError(t, err)\n\n\tp, ok := containerJSON.NetworkSettings.Ports[\"3306/tcp\"]\n\tif !ok || len(p) == 0 {\n\t\tt.Fatalf(\"failed to get host port mapping from mysql container\")\n\t}\n\n\tmySQLTestContainer := &mySQLTestContainer{\n\t\taddr:     fmt.Sprintf(\"localhost:%s\", p[0].HostPort),\n\t\tusername: \"root\",\n\t\tpassword: \"secret\",\n\t}\n\n\turi := fmt.Sprintf(\"%s:%s@tcp(%s)/defaultdb?parseTime=true\", mySQLTestContainer.username, mySQLTestContainer.password, mySQLTestContainer.addr)\n\n\terr = mysql.SetLogger(log.New(io.Discard, \"\", 0))\n\trequire.NoError(t, err)\n\n\tgoose.SetLogger(goose.NopLogger())\n\n\tvar db *sql.DB\n\n\tbackoffPolicy := backoff.NewExponentialBackOff()\n\tbackoffPolicy.MaxElapsedTime = 2 * time.Minute\n\terr = backoff.Retry(\n\t\tfunc() error {\n\t\t\tdb, err = goose.OpenDBWithDriver(\"mysql\", uri)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn db.Ping()\n\t\t},\n\t\tbackoffPolicy,\n\t)\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to connect to mysql container: %v\", err)\n\t}\n\n\tgoose.SetBaseFS(assets.EmbedMigrations)\n\n\terr = goose.Up(db, assets.MySQLMigrationDir)\n\trequire.NoError(t, err)\n\tversion, err := goose.GetDBVersion(db)\n\trequire.NoError(t, err)\n\tmySQLTestContainer.version = version\n\n\terr = db.Close()\n\trequire.NoError(t, err)\n\n\treturn mySQLTestContainer, stopContainer\n}\n\n// GetConnectionURI returns the mysql connection uri for the running mysql test container.\nfunc (m *mySQLTestContainer) GetConnectionURI(includeCredentials bool) string {\n\tcreds := \"\"\n\tif includeCredentials {\n\t\tcreds = fmt.Sprintf(\"%s:%s@\", m.username, m.password)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t\"%stcp(%s)/%s?parseTime=true\",\n\t\tcreds,\n\t\tm.addr,\n\t\t\"defaultdb\",\n\t)\n}\n\nfunc (m *mySQLTestContainer) GetUsername() string {\n\treturn m.username\n}\n\nfunc (m *mySQLTestContainer) GetPassword() string {\n\treturn m.password\n}\n", "package storage\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/go-connections/nat\"\n\t_ \"github.com/jackc/pgx/v5/stdlib\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/openfga/openfga/assets\"\n)\n\nconst (\n\tpostgresImage = \"postgres:14\"\n)\n\ntype postgresTestContainer struct {\n\taddr     string\n\tversion  int64\n\tusername string\n\tpassword string\n}\n\n// NewPostgresTestContainer returns an implementation of the DatastoreTestContainer interface\n// for Postgres.\nfunc NewPostgresTestContainer() *postgresTestContainer {\n\treturn &postgresTestContainer{}\n}\n\nfunc (p *postgresTestContainer) GetDatabaseSchemaVersion() int64 {\n\treturn p.version\n}\n\n// RunPostgresTestContainer runs a Postgres container, connects to it, and returns a\n// bootstrapped implementation of the DatastoreTestContainer interface wired up for the\n// Postgres datastore engine.\nfunc (p *postgresTestContainer) RunPostgresTestContainer(t testing.TB) (DatastoreTestContainer, func()) {\n\tdockerClient, err := client.NewClientWithOpts(\n\t\tclient.FromEnv,\n\t\tclient.WithAPIVersionNegotiation(),\n\t)\n\trequire.NoError(t, err)\n\n\tallImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{\n\t\tAll: true,\n\t})\n\trequire.NoError(t, err)\n\n\tfoundPostgresImage := false\n\tfor _, image := range allImages {\n\t\tfor _, tag := range image.RepoTags {\n\t\t\tif strings.Contains(tag, postgresImage) {\n\t\t\t\tfoundPostgresImage = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !foundPostgresImage {\n\t\tt.Logf(\"Pulling image %s\", postgresImage)\n\t\treader, err := dockerClient.ImagePull(context.Background(), postgresImage, types.ImagePullOptions{})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done\n\t\trequire.NoError(t, err)\n\t}\n\n\tcontainerCfg := container.Config{\n\t\tEnv: []string{\n\t\t\t\"POSTGRES_DB=defaultdb\",\n\t\t\t\"POSTGRES_PASSWORD=secret\",\n\t\t},\n\t\tExposedPorts: nat.PortSet{\n\t\t\tnat.Port(\"5432/tcp\"): {},\n\t\t},\n\t\tImage: postgresImage,\n\t}\n\n\thostCfg := container.HostConfig{\n\t\tAutoRemove:      true,\n\t\tPublishAllPorts: true,\n\t\tTmpfs:           map[string]string{\"/var/lib/postgresql/data\": \"\"},\n\t}\n\n\tname := fmt.Sprintf(\"postgres-%s\", ulid.Make().String())\n\n\tcont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)\n\trequire.NoError(t, err, \"failed to create postgres docker container\")\n\n\tstopContainer := func() {\n\t\tt.Logf(\"stopping container %s\", name)\n\t\ttimeoutSec := 5\n\n\t\terr := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})\n\t\tif err != nil && !client.IsErrNotFound(err) {\n\t\t\tt.Logf(\"failed to stop postgres container: %v\", err)\n\t\t}\n\n\t\tdockerClient.Close()\n\t\tt.Logf(\"stopped container %s\", name)\n\t}\n\n\terr = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to start postgres container: %v\", err)\n\t}\n\n\tcontainerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)\n\trequire.NoError(t, err)\n\n\tm, ok := containerJSON.NetworkSettings.Ports[\"5432/tcp\"]\n\tif !ok || len(m) == 0 {\n\t\tt.Fatalf(\"failed to get host port mapping from postgres container\")\n\t}\n\n\tpgTestContainer := &postgresTestContainer{\n\t\taddr:     fmt.Sprintf(\"localhost:%s\", m[0].HostPort),\n\t\tusername: \"postgres\",\n\t\tpassword: \"secret\",\n\t}\n\n\turi := fmt.Sprintf(\"postgres://%s:%s@%s/defaultdb?sslmode=disable\", pgTestContainer.username, pgTestContainer.password, pgTestContainer.addr)\n\n\tgoose.SetLogger(goose.NopLogger())\n\n\tdb, err := goose.OpenDBWithDriver(\"pgx\", uri)\n\trequire.NoError(t, err)\n\n\tbackoffPolicy := backoff.NewExponentialBackOff()\n\tbackoffPolicy.MaxElapsedTime = 30 * time.Second\n\terr = backoff.Retry(\n\t\tfunc() error {\n\t\t\treturn db.Ping()\n\t\t},\n\t\tbackoffPolicy,\n\t)\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to connect to postgres container: %v\", err)\n\t}\n\n\tgoose.SetBaseFS(assets.EmbedMigrations)\n\n\terr = goose.Up(db, assets.PostgresMigrationDir)\n\trequire.NoError(t, err)\n\n\tversion, err := goose.GetDBVersion(db)\n\trequire.NoError(t, err)\n\tpgTestContainer.version = version\n\n\terr = db.Close()\n\trequire.NoError(t, err)\n\n\treturn pgTestContainer, stopContainer\n}\n\n// GetConnectionURI returns the postgres connection uri for the running postgres test container.\nfunc (p *postgresTestContainer) GetConnectionURI(includeCredentials bool) string {\n\tcreds := \"\"\n\tif includeCredentials {\n\t\tcreds = fmt.Sprintf(\"%s:%s@\", p.username, p.password)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t\"postgres://%s%s/%s?sslmode=disable\",\n\t\tcreds,\n\t\tp.addr,\n\t\t\"defaultdb\",\n\t)\n}\n\nfunc (p *postgresTestContainer) GetUsername() string {\n\treturn p.username\n}\n\nfunc (p *postgresTestContainer) GetPassword() string {\n\treturn p.password\n}\n", "package listobjects\n\nimport (\n\t\"testing\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/openfga/openfga/cmd/run\"\n\t\"github.com/openfga/openfga/tests\"\n)\n\nfunc TestListObjectsMemory(t *testing.T) {\n\ttestRunAll(t, \"memory\")\n}\n\nfunc TestListObjectsPostgres(t *testing.T) {\n\ttestRunAll(t, \"postgres\")\n}\n\nfunc TestListObjectsMySQL(t *testing.T) {\n\ttestRunAll(t, \"mysql\")\n}\n\nfunc testRunAll(t *testing.T, engine string) {\n\t// uncomment in https://github.com/openfga/openfga/pull/1315\n\t// defer goleak.VerifyNone(t)\n\tcfg := run.MustDefaultConfigWithRandomPorts()\n\tcfg.Log.Level = \"error\"\n\tcfg.Datastore.Engine = engine\n\n\tcancel := tests.StartServer(t, cfg)\n\tdefer cancel()\n\n\tconn, err := grpc.Dial(cfg.GRPC.Addr,\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\tRunAllTests(t, openfgav1.NewOpenFGAServiceClient(conn))\n}\n"], "fixing_code": ["package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/openfga/openfga/internal/build\"\n\t\"github.com/openfga/openfga/internal/condition\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\tserverconfig \"github.com/openfga/openfga/internal/server/config\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nconst streamedBufferSize = 100\n\nvar (\n\tfurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tNamespace: build.ProjectName,\n\t\tName:      \"list_objects_further_eval_required_count\",\n\t\tHelp:      \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n\n\tnoFurtherEvalRequiredCounter = promauto.NewCounter(prometheus.CounterOpts{\n\t\tNamespace: build.ProjectName,\n\t\tName:      \"list_objects_no_further_eval_required_count\",\n\t\tHelp:      \"Number of objects in a ListObjects call that needed to issue a Check call to determine a final result\",\n\t})\n)\n\ntype ListObjectsQuery struct {\n\tdatastore               storage.RelationshipTupleReader\n\tlogger                  logger.Logger\n\tlistObjectsDeadline     time.Duration\n\tlistObjectsMaxResults   uint32\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\tmaxConcurrentReads      uint32\n\n\tcheckOptions []graph.LocalCheckerOption\n}\n\ntype ListObjectsResponse struct {\n\tObjects            []string\n\tResolutionMetadata reverseexpand.ResolutionMetadata\n}\n\ntype ListObjectsQueryOption func(d *ListObjectsQuery)\n\nfunc WithListObjectsDeadline(deadline time.Duration) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsDeadline = deadline\n\t}\n}\n\nfunc WithListObjectsMaxResults(max uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.listObjectsMaxResults = max\n\t}\n}\n\n// WithResolveNodeLimit see server.WithResolveNodeLimit\nfunc WithResolveNodeLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\n// WithResolveNodeBreadthLimit see server.WithResolveNodeBreadthLimit\nfunc WithResolveNodeBreadthLimit(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc WithLogger(l logger.Logger) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.logger = l\n\t}\n}\n\nfunc WithCheckOptions(checkOptions []graph.LocalCheckerOption) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.checkOptions = checkOptions\n\t}\n}\n\n// WithMaxConcurrentReads see server.WithMaxConcurrentReadsForListObjects\nfunc WithMaxConcurrentReads(limit uint32) ListObjectsQueryOption {\n\treturn func(d *ListObjectsQuery) {\n\t\td.maxConcurrentReads = limit\n\t}\n}\n\nfunc NewListObjectsQuery(ds storage.RelationshipTupleReader, opts ...ListObjectsQueryOption) *ListObjectsQuery {\n\tquery := &ListObjectsQuery{\n\t\tdatastore:               ds,\n\t\tlogger:                  logger.NewNoopLogger(),\n\t\tlistObjectsDeadline:     serverconfig.DefaultListObjectsDeadline,\n\t\tlistObjectsMaxResults:   serverconfig.DefaultListObjectsMaxResults,\n\t\tresolveNodeLimit:        serverconfig.DefaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: serverconfig.DefaultResolveNodeBreadthLimit,\n\t\tmaxConcurrentReads:      serverconfig.DefaultMaxConcurrentReadsForListObjects,\n\t\tcheckOptions:            []graph.LocalCheckerOption{},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\tquery.datastore = storagewrappers.NewBoundedConcurrencyTupleReader(query.datastore, query.maxConcurrentReads)\n\n\treturn query\n}\n\ntype ListObjectsResult struct {\n\tObjectID string\n\tErr      error\n}\n\n// listObjectsRequest captures the RPC request definition interface for the ListObjects API.\n// The unary and streaming RPC definitions implement this interface, and so it can be used\n// interchangeably for a canonical representation between the two.\ntype listObjectsRequest interface {\n\tGetStoreId() string\n\tGetAuthorizationModelId() string\n\tGetType() string\n\tGetRelation() string\n\tGetUser() string\n\tGetContextualTuples() *openfgav1.ContextualTupleKeys\n\tGetContext() *structpb.Struct\n}\n\n// evaluate fires of evaluation of the ListObjects query by delegating to\n// [[reverseexpand.ReverseExpand#Execute]] and resolving the results yielded\n// from it. If any results yielded by reverse expansion require further eval,\n// then these results get dispatched to Check to resolve the residual outcome.\n//\n// The resultsChan is **always** closed by evaluate when it is done with its work,\n// which is either when all results have been yielded, the deadline has been met,\n// or some other terminal error case has occurred.\nfunc (q *ListObjectsQuery) evaluate(\n\tctx context.Context,\n\treq listObjectsRequest,\n\tresultsChan chan<- ListObjectsResult,\n\tmaxResults uint32,\n\tresolutionMetadata *reverseexpand.ResolutionMetadata,\n) error {\n\ttargetObjectType := req.GetType()\n\ttargetRelation := req.GetRelation()\n\n\ttypesys, ok := typesystem.TypesystemFromContext(ctx)\n\tif !ok {\n\t\tpanic(\"typesystem missing in context\")\n\t}\n\n\tif !typesystem.IsSchemaVersionSupported(typesys.GetSchemaVersion()) {\n\t\treturn serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)\n\t}\n\n\tfor _, ctxTuple := range req.GetContextualTuples().GetTupleKeys() {\n\t\tif err := validation.ValidateTuple(typesys, ctxTuple); err != nil {\n\t\t\treturn serverErrors.HandleTupleValidateError(err)\n\t\t}\n\t}\n\n\t_, err := typesys.GetRelation(targetObjectType, targetRelation)\n\tif err != nil {\n\t\tif errors.Is(err, typesystem.ErrObjectTypeUndefined) {\n\t\t\treturn serverErrors.TypeNotFound(targetObjectType)\n\t\t}\n\n\t\tif errors.Is(err, typesystem.ErrRelationUndefined) {\n\t\t\treturn serverErrors.RelationNotFound(targetRelation, targetObjectType, nil)\n\t\t}\n\n\t\treturn serverErrors.NewInternalError(\"\", err)\n\t}\n\n\tif err := validation.ValidateUser(typesys, req.GetUser()); err != nil {\n\t\treturn serverErrors.ValidationError(fmt.Errorf(\"invalid 'user' value: %s\", err))\n\t}\n\n\thandler := func() {\n\t\tuserObj, userRel := tuple.SplitObjectRelation(req.GetUser())\n\t\tuserObjType, userObjID := tuple.SplitObject(userObj)\n\n\t\tvar sourceUserRef reverseexpand.IsUserRef\n\t\tsourceUserRef = &reverseexpand.UserRefObject{\n\t\t\tObject: &openfgav1.Object{\n\t\t\t\tType: userObjType,\n\t\t\t\tId:   userObjID,\n\t\t\t},\n\t\t}\n\n\t\tif tuple.IsTypedWildcard(userObj) {\n\t\t\tsourceUserRef = &reverseexpand.UserRefTypedWildcard{Type: tuple.GetType(userObj)}\n\t\t}\n\n\t\tif userRel != \"\" {\n\t\t\tsourceUserRef = &reverseexpand.UserRefObjectRelation{\n\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\tObject:   userObj,\n\t\t\t\t\tRelation: userRel,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\treverseExpandResultsChan := make(chan *reverseexpand.ReverseExpandResult, 1)\n\t\tobjectsFound := atomic.Uint32{}\n\n\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(\n\t\t\tq.datastore,\n\t\t\ttypesys,\n\t\t\treverseexpand.WithResolveNodeLimit(q.resolveNodeLimit),\n\t\t\treverseexpand.WithResolveNodeBreadthLimit(q.resolveNodeBreadthLimit),\n\t\t\treverseexpand.WithLogger(q.logger),\n\t\t)\n\n\t\tcancelCtx, cancel := context.WithCancel(ctx)\n\n\t\twg := sync.WaitGroup{}\n\n\t\terrChan := make(chan error, 1)\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\terr := reverseExpandQuery.Execute(cancelCtx, &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:          req.GetStoreId(),\n\t\t\t\tObjectType:       targetObjectType,\n\t\t\t\tRelation:         targetRelation,\n\t\t\t\tUser:             sourceUserRef,\n\t\t\t\tContextualTuples: req.GetContextualTuples().GetTupleKeys(),\n\t\t\t\tContext:          req.GetContext(),\n\t\t\t}, reverseExpandResultsChan, resolutionMetadata)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t}\n\t\t}()\n\n\t\tcheckResolver := graph.NewLocalChecker(\n\t\t\tstoragewrappers.NewCombinedTupleReader(q.datastore, req.GetContextualTuples().GetTupleKeys()),\n\t\t\tq.checkOptions...,\n\t\t)\n\t\tdefer checkResolver.Close()\n\n\t\tconcurrencyLimiterCh := make(chan struct{}, q.resolveNodeBreadthLimit)\n\n\tConsumerReadLoop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak ConsumerReadLoop\n\t\t\tcase res, channelOpen := <-reverseExpandResultsChan:\n\t\t\t\tif !channelOpen {\n\t\t\t\t\tbreak ConsumerReadLoop\n\t\t\t\t}\n\n\t\t\t\tif !(maxResults == 0) && objectsFound.Load() >= maxResults {\n\t\t\t\t\tbreak ConsumerReadLoop\n\t\t\t\t}\n\n\t\t\t\tif res.ResultStatus == reverseexpand.NoFurtherEvalStatus {\n\t\t\t\t\tnoFurtherEvalRequiredCounter.Inc()\n\t\t\t\t\ttrySendObject(res.Object, &objectsFound, maxResults, resultsChan)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfurtherEvalRequiredCounter.Inc()\n\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func(res *reverseexpand.ReverseExpandResult) {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t<-concurrencyLimiterCh\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}()\n\n\t\t\t\t\tconcurrencyLimiterCh <- struct{}{}\n\n\t\t\t\t\tresp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{\n\t\t\t\t\t\tStoreID:              req.GetStoreId(),\n\t\t\t\t\t\tAuthorizationModelID: req.GetAuthorizationModelId(),\n\t\t\t\t\t\tTupleKey:             tuple.NewTupleKey(res.Object, req.GetRelation(), req.GetUser()),\n\t\t\t\t\t\tContextualTuples:     req.GetContextualTuples().GetTupleKeys(),\n\t\t\t\t\t\tContext:              req.GetContext(),\n\t\t\t\t\t\tResolutionMetadata: &graph.ResolutionMetadata{\n\t\t\t\t\t\t\tDepth: q.resolveNodeLimit,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\t\t\t\t\tresultsChan <- ListObjectsResult{Err: serverErrors.AuthorizationModelResolutionTooComplex}\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tatomic.AddUint32(resolutionMetadata.QueryCount, resp.GetResolutionMetadata().DatastoreQueryCount)\n\n\t\t\t\t\tif resp.Allowed {\n\t\t\t\t\t\ttrySendObject(res.Object, &objectsFound, maxResults, resultsChan)\n\t\t\t\t\t}\n\t\t\t\t}(res)\n\n\t\t\tcase err := <-errChan:\n\t\t\t\tif errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {\n\t\t\t\t\terr = serverErrors.AuthorizationModelResolutionTooComplex\n\t\t\t\t}\n\n\t\t\t\tresultsChan <- ListObjectsResult{Err: err}\n\t\t\t\tbreak ConsumerReadLoop\n\t\t\t}\n\t\t}\n\n\t\tcancel()\n\t\twg.Wait()\n\t\tclose(resultsChan)\n\t}\n\n\tgo handler()\n\n\treturn nil\n}\n\nfunc trySendObject(object string, objectsFound *atomic.Uint32, maxResults uint32, resultsChan chan<- ListObjectsResult) {\n\tif !(maxResults == 0) {\n\t\tif objectsFound.Add(1) > maxResults {\n\t\t\treturn\n\t\t}\n\t}\n\tresultsChan <- ListObjectsResult{ObjectID: object}\n}\n\n// Execute the ListObjectsQuery, returning a list of object IDs up to a maximum of q.listObjectsMaxResults\n// or until q.listObjectsDeadline is hit, whichever happens first.\nfunc (q *ListObjectsQuery) Execute(\n\tctx context.Context,\n\treq *openfgav1.ListObjectsRequest,\n) (*ListObjectsResponse, error) {\n\tresultsChan := make(chan ListObjectsResult, 1)\n\tmaxResults := q.listObjectsMaxResults\n\tif maxResults > 0 {\n\t\tresultsChan = make(chan ListObjectsResult, maxResults)\n\t}\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tobjects := make([]string, 0)\n\n\tvar errs *multierror.Error\n\n\tfor result := range resultsChan {\n\t\tif result.Err != nil {\n\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\treturn nil, result.Err\n\t\t\t}\n\n\t\t\tif errors.Is(result.Err, condition.ErrEvaluationFailed) {\n\t\t\t\terrs = multierror.Append(errs, result.Err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif errors.Is(result.Err, context.Canceled) || errors.Is(result.Err, context.DeadlineExceeded) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t}\n\n\t\tobjects = append(objects, result.ObjectID)\n\t}\n\n\tif len(objects) < int(maxResults) && errs.ErrorOrNil() != nil {\n\t\treturn nil, errs\n\t}\n\n\treturn &ListObjectsResponse{\n\t\tObjects:            objects,\n\t\tResolutionMetadata: *resolutionMetadata,\n\t}, nil\n}\n\n// ExecuteStreamed executes the ListObjectsQuery, returning a stream of object IDs.\n// It ignores the value of q.listObjectsMaxResults and returns all available results\n// until q.listObjectsDeadline is hit\nfunc (q *ListObjectsQuery) ExecuteStreamed(ctx context.Context, req *openfgav1.StreamedListObjectsRequest, srv openfgav1.OpenFGAService_StreamedListObjectsServer) (*reverseexpand.ResolutionMetadata, error) {\n\tmaxResults := uint32(math.MaxUint32)\n\t// make a buffered channel so that writer goroutines aren't blocked when attempting to send a result\n\tresultsChan := make(chan ListObjectsResult, streamedBufferSize)\n\n\ttimeoutCtx := ctx\n\tif q.listObjectsDeadline != 0 {\n\t\tvar cancel context.CancelFunc\n\t\ttimeoutCtx, cancel = context.WithTimeout(ctx, q.listObjectsDeadline)\n\t\tdefer cancel()\n\t}\n\n\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\terr := q.evaluate(timeoutCtx, req, resultsChan, maxResults, resolutionMetadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor result := range resultsChan {\n\t\tif result.Err != nil {\n\t\t\tif errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {\n\t\t\t\treturn nil, result.Err\n\t\t\t}\n\n\t\t\tif errors.Is(result.Err, condition.ErrEvaluationFailed) {\n\t\t\t\treturn nil, serverErrors.ValidationError(result.Err)\n\t\t\t}\n\n\t\t\treturn nil, serverErrors.HandleError(\"\", result.Err)\n\t\t}\n\n\t\tif err := srv.Send(&openfgav1.StreamedListObjectsResponse{\n\t\t\tObject: result.ObjectID,\n\t\t}); err != nil {\n\t\t\treturn nil, serverErrors.NewInternalError(\"\", err)\n\t\t}\n\t}\n\n\treturn resolutionMetadata, nil\n}\n", "// Package reverseexpand contains the code that handles the ReverseExpand API\npackage reverseexpand\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/sourcegraph/conc/pool\"\n\t\"go.opentelemetry.io/otel\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/trace\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/openfga/openfga/pkg/logger\"\n\n\t\"github.com/openfga/openfga/internal/condition\"\n\t\"github.com/openfga/openfga/internal/condition/eval\"\n\t\"github.com/openfga/openfga/internal/graph\"\n\tserverconfig \"github.com/openfga/openfga/internal/server/config\"\n\t\"github.com/openfga/openfga/internal/validation\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\t\"github.com/openfga/openfga/pkg/telemetry\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nvar tracer = otel.Tracer(\"openfga/pkg/server/commands/reverse_expand\")\n\ntype ReverseExpandRequest struct {\n\tStoreID          string\n\tObjectType       string\n\tRelation         string\n\tUser             IsUserRef\n\tContextualTuples []*openfgav1.TupleKey\n\tContext          *structpb.Struct\n\n\tedge *graph.RelationshipEdge\n}\n\ntype IsUserRef interface {\n\tisUserRef()\n\tGetObjectType() string\n\tString() string\n}\n\ntype UserRefObject struct {\n\tObject *openfgav1.Object\n}\n\nvar _ IsUserRef = (*UserRefObject)(nil)\n\nfunc (u *UserRefObject) isUserRef() {}\n\nfunc (u *UserRefObject) GetObjectType() string {\n\treturn u.Object.Type\n}\n\nfunc (u *UserRefObject) String() string {\n\treturn tuple.BuildObject(u.Object.GetType(), u.Object.GetId())\n}\n\ntype UserRefTypedWildcard struct {\n\tType string\n}\n\nvar _ IsUserRef = (*UserRefTypedWildcard)(nil)\n\nfunc (*UserRefTypedWildcard) isUserRef() {}\n\nfunc (u *UserRefTypedWildcard) GetObjectType() string {\n\treturn u.Type\n}\n\nfunc (u *UserRefTypedWildcard) String() string {\n\treturn fmt.Sprintf(\"%s:*\", u.Type)\n}\n\ntype UserRefObjectRelation struct {\n\tObjectRelation *openfgav1.ObjectRelation\n\tCondition      *openfgav1.RelationshipCondition\n}\n\nfunc (*UserRefObjectRelation) isUserRef() {}\n\nfunc (u *UserRefObjectRelation) GetObjectType() string {\n\treturn tuple.GetType(u.ObjectRelation.Object)\n}\n\nfunc (u *UserRefObjectRelation) String() string {\n\treturn tuple.ToObjectRelationString(\n\t\tu.ObjectRelation.GetObject(),\n\t\tu.ObjectRelation.GetRelation(),\n\t)\n}\n\ntype UserRef struct {\n\n\t// Types that are assignable to Ref\n\t//  *UserRef_Object\n\t//  *UserRef_TypedWildcard\n\t//  *UserRef_ObjectRelation\n\tRef IsUserRef\n}\n\ntype ReverseExpandQuery struct {\n\tlogger                  logger.Logger\n\tdatastore               storage.RelationshipTupleReader\n\ttypesystem              *typesystem.TypeSystem\n\tresolveNodeLimit        uint32\n\tresolveNodeBreadthLimit uint32\n\n\t// visitedUsersetsMap map prevents visiting the same userset through the same edge twice\n\tvisitedUsersetsMap *sync.Map\n\t// candidateObjectsMap map prevents returning the same object twice\n\tcandidateObjectsMap *sync.Map\n}\n\ntype ReverseExpandQueryOption func(d *ReverseExpandQuery)\n\nfunc WithResolveNodeLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeLimit = limit\n\t}\n}\n\nfunc WithResolveNodeBreadthLimit(limit uint32) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.resolveNodeBreadthLimit = limit\n\t}\n}\n\nfunc NewReverseExpandQuery(ds storage.RelationshipTupleReader, ts *typesystem.TypeSystem, opts ...ReverseExpandQueryOption) *ReverseExpandQuery {\n\tquery := &ReverseExpandQuery{\n\t\tlogger:                  logger.NewNoopLogger(),\n\t\tdatastore:               ds,\n\t\ttypesystem:              ts,\n\t\tresolveNodeLimit:        serverconfig.DefaultResolveNodeLimit,\n\t\tresolveNodeBreadthLimit: serverconfig.DefaultResolveNodeBreadthLimit,\n\t\tcandidateObjectsMap:     new(sync.Map),\n\t\tvisitedUsersetsMap:      new(sync.Map),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(query)\n\t}\n\n\treturn query\n}\n\ntype ConditionalResultStatus int\n\nconst (\n\tRequiresFurtherEvalStatus ConditionalResultStatus = iota\n\tNoFurtherEvalStatus\n)\n\ntype ReverseExpandResult struct {\n\tObject       string\n\tResultStatus ConditionalResultStatus\n}\n\ntype ResolutionMetadata struct {\n\tQueryCount *uint32\n}\n\nfunc NewResolutionMetadata() *ResolutionMetadata {\n\treturn &ResolutionMetadata{\n\t\tQueryCount: new(uint32),\n\t}\n}\n\nfunc WithLogger(logger logger.Logger) ReverseExpandQueryOption {\n\treturn func(d *ReverseExpandQuery) {\n\t\td.logger = logger\n\t}\n}\n\n// Execute yields all the objects of the provided objectType that the\n// given user possibly has, a specific relation with and sends those\n// objects to resultChan. It MUST guarantee no duplicate objects sent.\n//\n// This function respects context timeouts and cancellations. If an\n// error is encountered (e.g. context timeout) before resolving all\n// objects, then the provided channel will NOT be closed, and it will\n// send the error through the channel.\n//\n// If no errors occur, then Execute will yield all of the objects on\n// the provided channel and then close the channel to signal that it\n// is done.\nfunc (c *ReverseExpandQuery) Execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\terr := c.execute(ctx, req, resultChan, false, resolutionMetadata)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclose(resultChan)\n\treturn nil\n}\n\nfunc (c *ReverseExpandQuery) execute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tctx, span := tracer.Start(ctx, \"reverseExpand.Execute\", trace.WithAttributes(\n\t\tattribute.String(\"target_type\", req.ObjectType),\n\t\tattribute.String(\"target_relation\", req.Relation),\n\t\tattribute.String(\"source\", req.User.String()),\n\t))\n\tdefer span.End()\n\n\tif req.edge != nil {\n\t\tspan.SetAttributes(attribute.String(\"edge\", req.edge.String()))\n\t}\n\n\tdepth, ok := graph.ResolutionDepthFromContext(ctx)\n\tif !ok {\n\t\tctx = graph.ContextWithResolutionDepth(ctx, 0)\n\t} else {\n\t\tif depth >= c.resolveNodeLimit {\n\t\t\treturn graph.ErrResolutionDepthExceeded\n\t\t}\n\n\t\tctx = graph.ContextWithResolutionDepth(ctx, depth+1)\n\t}\n\n\tvar sourceUserRef *openfgav1.RelationReference\n\tvar sourceUserType, sourceUserObj string\n\n\t// e.g. 'user:bob'\n\tif val, ok := req.User.(*UserRefObject); ok {\n\t\tsourceUserType = val.Object.GetType()\n\t\tsourceUserObj = tuple.BuildObject(sourceUserType, val.Object.GetId())\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, \"\")\n\t}\n\n\t// e.g. 'user:*'\n\tif val, ok := req.User.(*UserRefTypedWildcard); ok {\n\t\tsourceUserType = val.Type\n\t\tsourceUserRef = typesystem.WildcardRelationReference(sourceUserType)\n\t}\n\n\t// e.g. 'group:eng#member'\n\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\tsourceUserType = tuple.GetType(val.ObjectRelation.GetObject())\n\t\tsourceUserObj = val.ObjectRelation.Object\n\t\tsourceUserRef = typesystem.DirectRelationReference(sourceUserType, val.ObjectRelation.GetRelation())\n\n\t\tif req.edge != nil {\n\t\t\tkey := fmt.Sprintf(\"%s#%s\", sourceUserObj, req.edge.String())\n\t\t\tif _, loaded := c.visitedUsersetsMap.LoadOrStore(key, struct{}{}); loaded {\n\t\t\t\t// we've already visited this userset through this edge, exit to avoid an infinite cycle\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tsourceUserRel := val.ObjectRelation.GetRelation()\n\n\t\t\tif sourceUserType == req.ObjectType && sourceUserRel == req.Relation {\n\t\t\t\tif err := c.trySendCandidate(ctx, intersectionOrExclusionInPreviousEdges, sourceUserObj, resultChan); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttargetObjRef := typesystem.DirectRelationReference(req.ObjectType, req.Relation)\n\n\tg := graph.New(c.typesystem)\n\n\tedges, err := g.GetPrunedRelationshipEdges(targetObjRef, sourceUserRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpool := pool.New().WithContext(ctx)\n\tpool.WithCancelOnError()\n\tpool.WithFirstError()\n\tpool.WithMaxGoroutines(int(c.resolveNodeBreadthLimit))\n\tvar errs *multierror.Error\n\nLoopOnEdges:\n\tfor _, edge := range edges {\n\t\tinnerLoopEdge := edge\n\t\tintersectionOrExclusionInPreviousEdges := intersectionOrExclusionInPreviousEdges || innerLoopEdge.TargetReferenceInvolvesIntersectionOrExclusion\n\t\tr := &ReverseExpandRequest{\n\t\t\tStoreID:          req.StoreID,\n\t\t\tObjectType:       req.ObjectType,\n\t\t\tRelation:         req.Relation,\n\t\t\tUser:             req.User,\n\t\t\tContextualTuples: req.ContextualTuples,\n\t\t\tContext:          req.Context,\n\t\t\tedge:             innerLoopEdge,\n\t\t}\n\t\tswitch innerLoopEdge.Type {\n\t\tcase graph.DirectEdge:\n\t\t\tpool.Go(func(ctx context.Context) error {\n\t\t\t\treturn c.reverseExpandDirect(ctx, r, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t\t})\n\t\tcase graph.ComputedUsersetEdge:\n\t\t\t// follow the computed_userset edge, no new goroutine needed since it's not I/O intensive\n\t\t\tr.User = &UserRefObjectRelation{\n\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\tObject:   sourceUserObj,\n\t\t\t\t\tRelation: innerLoopEdge.TargetReference.GetRelation(),\n\t\t\t\t},\n\t\t\t}\n\t\t\terr = c.execute(ctx, r, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t\tif err != nil {\n\t\t\t\terrs = multierror.Append(errs, err)\n\t\t\t\tbreak LoopOnEdges\n\t\t\t}\n\t\tcase graph.TupleToUsersetEdge:\n\t\t\tpool.Go(func(ctx context.Context) error {\n\t\t\t\treturn c.reverseExpandTupleToUserset(ctx, r, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t\t})\n\t\tdefault:\n\t\t\tpanic(\"unsupported edge type\")\n\t\t}\n\t}\n\n\terr = pool.Wait()\n\tif err != nil {\n\t\terrs = multierror.Append(errs, err)\n\t}\n\tif errs.ErrorOrNil() != nil {\n\t\ttelemetry.TraceError(span, errs.ErrorOrNil())\n\t\treturn errs.ErrorOrNil()\n\t}\n\n\treturn nil\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandTupleToUserset(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandTupleToUserset\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.User.String()),\n\t))\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\ttelemetry.TraceError(span, err)\n\t\t}\n\t\tspan.End()\n\t}()\n\n\terr = c.readTuplesAndExecute(ctx, req, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\treturn err\n}\n\nfunc (c *ReverseExpandQuery) reverseExpandDirect(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tctx, span := tracer.Start(ctx, \"reverseExpandDirect\", trace.WithAttributes(\n\t\tattribute.String(\"edge\", req.edge.String()),\n\t\tattribute.String(\"source.user\", req.User.String()),\n\t))\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\ttelemetry.TraceError(span, err)\n\t\t}\n\t\tspan.End()\n\t}()\n\n\terr = c.readTuplesAndExecute(ctx, req, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\treturn err\n}\n\nfunc (c *ReverseExpandQuery) readTuplesAndExecute(\n\tctx context.Context,\n\treq *ReverseExpandRequest,\n\tresultChan chan<- *ReverseExpandResult,\n\tintersectionOrExclusionInPreviousEdges bool,\n\tresolutionMetadata *ResolutionMetadata,\n) error {\n\tif ctx.Err() != nil {\n\t\treturn ctx.Err()\n\t}\n\n\tctx, span := tracer.Start(ctx, \"readTuplesAndExecute\")\n\tdefer span.End()\n\n\tvar userFilter []*openfgav1.ObjectRelation\n\tvar relationFilter string\n\n\tswitch req.edge.Type {\n\tcase graph.DirectEdge:\n\t\trelationFilter = req.edge.TargetReference.GetRelation()\n\t\ttargetUserObjectType := req.User.GetObjectType()\n\n\t\tpubliclyAssignable, err := c.typesystem.IsPubliclyAssignable(req.edge.TargetReference, targetUserObjectType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif publiclyAssignable {\n\t\t\t// e.g. 'user:*'\n\t\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\t\tObject: fmt.Sprintf(\"%s:*\", targetUserObjectType),\n\t\t\t})\n\t\t}\n\n\t\t// e.g. 'user:bob'\n\t\tif val, ok := req.User.(*UserRefObject); ok {\n\t\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\t\tObject: tuple.BuildObject(val.Object.Type, val.Object.Id),\n\t\t\t})\n\t\t}\n\n\t\t// e.g. 'group:eng#member'\n\t\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\t\tuserFilter = append(userFilter, val.ObjectRelation)\n\t\t}\n\tcase graph.TupleToUsersetEdge:\n\t\trelationFilter = req.edge.TuplesetRelation\n\t\t// a TTU edge can only have a userset as a source node\n\t\t// e.g. 'group:eng#member'\n\t\tif val, ok := req.User.(*UserRefObjectRelation); ok {\n\t\t\tuserFilter = append(userFilter, &openfgav1.ObjectRelation{\n\t\t\t\tObject: val.ObjectRelation.Object,\n\t\t\t})\n\t\t} else {\n\t\t\tpanic(\"unexpected source for reverse expansion of tuple to userset\")\n\t\t}\n\tdefault:\n\t\tpanic(\"unsupported edge type\")\n\t}\n\n\tcombinedTupleReader := storagewrappers.NewCombinedTupleReader(c.datastore, req.ContextualTuples)\n\n\t// find all tuples of the form req.edge.TargetReference.Type:...#relationFilter@userFilter\n\titer, err := combinedTupleReader.ReadStartingWithUser(ctx, req.StoreID, storage.ReadStartingWithUserFilter{\n\t\tObjectType: req.edge.TargetReference.GetType(),\n\t\tRelation:   relationFilter,\n\t\tUserFilter: userFilter,\n\t})\n\tatomic.AddUint32(resolutionMetadata.QueryCount, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// filter out invalid tuples yielded by the database iterator\n\tfilteredIter := storage.NewFilteredTupleKeyIterator(\n\t\tstorage.NewTupleKeyIteratorFromTupleIterator(iter),\n\t\tfunc(tupleKey *openfgav1.TupleKey) bool {\n\t\t\treturn validation.ValidateCondition(c.typesystem, tupleKey) == nil\n\t\t},\n\t)\n\tdefer filteredIter.Stop()\n\n\tpool := pool.New().WithContext(ctx)\n\tpool.WithCancelOnError()\n\tpool.WithFirstError()\n\tpool.WithMaxGoroutines(int(c.resolveNodeBreadthLimit))\n\n\tvar errs *multierror.Error\n\nLoopOnIterator:\n\tfor {\n\t\ttk, err := filteredIter.Next(ctx)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storage.ErrIteratorDone) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terrs = multierror.Append(errs, err)\n\t\t\tbreak LoopOnIterator\n\t\t}\n\n\t\tcondEvalResult, err := eval.EvaluateTupleCondition(ctx, tk, c.typesystem, req.Context)\n\t\tif err != nil {\n\t\t\terrs = multierror.Append(errs, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !condEvalResult.ConditionMet {\n\t\t\tif len(condEvalResult.MissingParameters) > 0 {\n\t\t\t\terrs = multierror.Append(errs, condition.NewEvaluationError(\n\t\t\t\t\ttk.GetCondition().GetName(),\n\t\t\t\t\tfmt.Errorf(\"tuple '%s' is missing context parameters '%v'\",\n\t\t\t\t\t\ttuple.TupleKeyToString(tk),\n\t\t\t\t\t\tcondEvalResult.MissingParameters),\n\t\t\t\t))\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tfoundObject := tk.GetObject()\n\t\tvar newRelation string\n\n\t\tswitch req.edge.Type {\n\t\tcase graph.DirectEdge:\n\t\t\tnewRelation = tk.GetRelation()\n\t\tcase graph.TupleToUsersetEdge:\n\t\t\tnewRelation = req.edge.TargetReference.GetRelation()\n\t\tdefault:\n\t\t\tpanic(\"unsupported edge type\")\n\t\t}\n\n\t\tpool.Go(func(ctx context.Context) error {\n\t\t\treturn c.execute(ctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:    req.StoreID,\n\t\t\t\tObjectType: req.ObjectType,\n\t\t\t\tRelation:   req.Relation,\n\t\t\t\tUser: &UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   foundObject,\n\t\t\t\t\t\tRelation: newRelation,\n\t\t\t\t\t},\n\t\t\t\t\tCondition: tk.GetCondition(),\n\t\t\t\t},\n\t\t\t\tContextualTuples: req.ContextualTuples,\n\t\t\t\tContext:          req.Context,\n\t\t\t\tedge:             req.edge,\n\t\t\t}, resultChan, intersectionOrExclusionInPreviousEdges, resolutionMetadata)\n\t\t})\n\t}\n\n\terrs = multierror.Append(errs, pool.Wait())\n\tif errs.ErrorOrNil() != nil {\n\t\ttelemetry.TraceError(span, errs.ErrorOrNil())\n\t\treturn errs\n\t}\n\n\treturn nil\n}\n\nfunc (c *ReverseExpandQuery) trySendCandidate(ctx context.Context, intersectionOrExclusionInPreviousEdges bool, candidateObject string, candidateChan chan<- *ReverseExpandResult) error {\n\t_, span := tracer.Start(ctx, \"trySendCandidate\", trace.WithAttributes(\n\t\tattribute.String(\"object\", candidateObject),\n\t\tattribute.Bool(\"sent\", false),\n\t))\n\tdefer span.End()\n\n\tif _, ok := c.candidateObjectsMap.LoadOrStore(candidateObject, struct{}{}); !ok {\n\t\tresultStatus := NoFurtherEvalStatus\n\t\tif intersectionOrExclusionInPreviousEdges {\n\t\t\tspan.SetAttributes(attribute.Bool(\"requires_further_eval\", true))\n\t\t\tresultStatus = RequiresFurtherEvalStatus\n\t\t}\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase candidateChan <- &ReverseExpandResult{\n\t\t\tObject:       candidateObject,\n\t\t\tResultStatus: resultStatus,\n\t\t}:\n\t\t\tspan.SetAttributes(attribute.Bool(\"sent\", true))\n\t\t}\n\t}\n\n\treturn nil\n}\n", "package reverseexpand\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n\tgomock \"go.uber.org/mock/gomock\"\n\n\t\"go.uber.org/goleak\"\n\n\t\"github.com/openfga/openfga/internal/mocks\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nfunc TestReverseExpandResultChannelClosed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user]`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tvar tuples []*openfgav1.Tuple\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tTimes(1).\n\t\tDoAndReturn(func(_ context.Context, _ string, _ storage.ReadStartingWithUserFilter) (storage.TupleIterator, error) {\n\t\t\titerator := storage.NewStaticTupleIterator(tuples)\n\t\t\treturn iterator, nil\n\t\t})\n\n\tctx := context.Background()\n\n\tresultChan := make(chan *ReverseExpandResult)\n\terrChan := make(chan error, 1)\n\n\t// process query in one goroutine, but it will be cancelled almost right away\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\tt.Logf(\"before execute reverse expand\")\n\t\terr := reverseExpandQuery.Execute(ctx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\t\tt.Logf(\"after execute reverse expand\")\n\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\n\tselect {\n\tcase _, open := <-resultChan:\n\t\tif open {\n\t\t\trequire.FailNow(t, \"expected immediate closure of result channel\")\n\t\t}\n\tcase err := <-errChan:\n\t\trequire.FailNow(t, \"unexpected error received on error channel :%v\", err)\n\tcase <-time.After(30 * time.Millisecond):\n\t\trequire.FailNow(t, \"unexpected timeout on channel receive, expected receive on error channel\")\n\t}\n}\n\nfunc TestReverseExpandRespectsContextCancellation(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user]`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tvar tuples []*openfgav1.Tuple\n\tfor i := 0; i < 100; i++ {\n\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(i))\n\t\ttuples = append(tuples, &openfgav1.Tuple{Key: tuple.NewTupleKey(obj, \"viewer\", \"user:maria\")})\n\t}\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tTimes(1).\n\t\tDoAndReturn(func(_ context.Context, _ string, _ storage.ReadStartingWithUserFilter) (storage.TupleIterator, error) {\n\t\t\t// simulate many goroutines trying to write to the results channel\n\t\t\titerator := storage.NewStaticTupleIterator(tuples)\n\t\t\tt.Logf(\"returning tuple iterator\")\n\t\t\treturn iterator, nil\n\t\t})\n\tctx, cancelFunc := context.WithCancel(context.Background())\n\n\tresultChan := make(chan *ReverseExpandResult)\n\terrChan := make(chan error, 1)\n\n\t// process query in one goroutine, but it will be cancelled almost right away\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\tt.Logf(\"before execute reverse expand\")\n\t\terr := reverseExpandQuery.Execute(ctx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\t\tt.Logf(\"after execute reverse expand\")\n\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\tgo func() {\n\t\t// simulate max_results=1\n\t\tt.Logf(\"before receive one result\")\n\t\tres := <-resultChan\n\t\tt.Logf(\"after receive one result\")\n\t\tcancelFunc()\n\t\tt.Logf(\"after send cancellation\")\n\t\trequire.NotNil(t, res.Object)\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.Error(t, err)\n\tcase <-time.After(30 * time.Millisecond):\n\t\trequire.FailNow(t, \"unexpected timeout on channel receive, expected receive on error channel\")\n\t}\n}\n\nfunc TestReverseExpandRespectsContextTimeout(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine allowed: [user]\n\tdefine viewer: [user] and allowed`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tMaxTimes(2) // we expect it to be 0 most of the time\n\n\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), time.Nanosecond)\n\tdefer cancel()\n\tresultChan := make(chan *ReverseExpandResult)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\terr := reverseExpandQuery.Execute(timeoutCtx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\tselect {\n\tcase _, open := <-resultChan:\n\t\tif !open {\n\t\t\trequire.FailNow(t, \"unexpected closure of result channel\")\n\t\t}\n\tcase err := <-errChan:\n\t\trequire.Error(t, err)\n\tcase <-time.After(1 * time.Second):\n\t\trequire.FailNow(t, \"unexpected timeout encountered, expected other receive\")\n\t}\n}\n\nfunc TestReverseExpandErrorInTuples(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user]`)\n\n\ttypeSystem := typesystem.New(model)\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tvar tuples []*openfgav1.Tuple\n\tfor i := 0; i < 100; i++ {\n\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(i))\n\t\ttuples = append(tuples, &openfgav1.Tuple{Key: tuple.NewTupleKey(obj, \"viewer\", \"user:maria\")})\n\t}\n\n\tmockDatastore := mocks.NewMockOpenFGADatastore(mockController)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).\n\t\tDoAndReturn(func(_ context.Context, _ string, _ storage.ReadStartingWithUserFilter) (storage.TupleIterator, error) {\n\t\t\titerator := mocks.NewErrorTupleIterator(tuples)\n\t\t\treturn iterator, nil\n\t\t})\n\n\tctx, cancelFunc := context.WithCancel(context.Background())\n\tdefer cancelFunc()\n\n\tresultChan := make(chan *ReverseExpandResult)\n\terrChan := make(chan error, 1)\n\n\t// process query in one goroutine, but it will be cancelled almost right away\n\tgo func() {\n\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typeSystem)\n\t\terr := reverseExpandQuery.Execute(ctx, &ReverseExpandRequest{\n\t\t\tStoreID:    store,\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUser: &UserRefObject{\n\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"maria\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t}, resultChan, NewResolutionMetadata())\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\nConsumerLoop:\n\tfor {\n\t\tselect {\n\t\tcase _, open := <-resultChan:\n\t\t\tif !open {\n\t\t\t\trequire.FailNow(t, \"unexpected closure of result channel\")\n\t\t\t}\n\n\t\t\tcancelFunc()\n\t\tcase err := <-errChan:\n\t\t\trequire.Error(t, err)\n\t\t\tbreak ConsumerLoop\n\t\tcase <-time.After(30 * time.Millisecond):\n\t\t\trequire.FailNow(t, \"unexpected timeout waiting for channel receive, expected an error on the error channel\")\n\t\t}\n\t}\n}\n\nfunc TestReverseExpandSendsAllErrorsThroughChannel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\n\tstore := ulid.Make().String()\n\n\tmodel := testutils.MustTransformDSLToProtoWithID(`model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user]`)\n\n\tmockDatastore := mocks.NewMockSlowDataStorage(memory.New(), 1*time.Second)\n\n\tfor i := 0; i < 50; i++ {\n\t\tt.Logf(\"iteration %d\", i)\n\t\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Nanosecond))\n\t\tt.Cleanup(func() {\n\t\t\tcancel()\n\t\t})\n\n\t\tresultChan := make(chan *ReverseExpandResult)\n\t\terrChan := make(chan error, 1)\n\n\t\tgo func() {\n\t\t\treverseExpandQuery := NewReverseExpandQuery(mockDatastore, typesystem.New(model))\n\t\t\tt.Logf(\"before produce\")\n\t\t\terr := reverseExpandQuery.Execute(ctx, &ReverseExpandRequest{\n\t\t\t\tStoreID:    store,\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"maria\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t}, resultChan, NewResolutionMetadata())\n\t\t\tt.Logf(\"after produce\")\n\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t}\n\t\t}()\n\n\t\tselect {\n\t\tcase _, channelOpen := <-resultChan:\n\t\t\tif !channelOpen {\n\t\t\t\trequire.FailNow(t, \"unexpected closure of result channel\")\n\t\t\t}\n\t\tcase err := <-errChan:\n\t\t\trequire.Error(t, err)\n\t\tcase <-time.After(3 * time.Second):\n\t\t\trequire.FailNow(t, \"unexpected timeout waiting for channel receive, expected an error on the error channel\")\n\t\t}\n\t}\n}\n", "package server\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\tparser \"github.com/openfga/language/pkg/go/transformer\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/goleak\"\n\t\"go.uber.org/mock/gomock\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/openfga/openfga/cmd/migrate\"\n\t\"github.com/openfga/openfga/cmd/util\"\n\t\"github.com/openfga/openfga/internal/build\"\n\tmockstorage \"github.com/openfga/openfga/internal/mocks\"\n\tserverconfig \"github.com/openfga/openfga/internal/server/config\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/pkg/server/errors\"\n\t\"github.com/openfga/openfga/pkg/server/test\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/storage/memory\"\n\t\"github.com/openfga/openfga/pkg/storage/mysql\"\n\t\"github.com/openfga/openfga/pkg/storage/postgres\"\n\t\"github.com/openfga/openfga/pkg/storage/sqlcommon\"\n\t\"github.com/openfga/openfga/pkg/storage/storagewrappers\"\n\tstoragefixtures \"github.com/openfga/openfga/pkg/testfixtures/storage\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nfunc init() {\n\t_, filename, _, _ := runtime.Caller(0)\n\tdir := path.Join(path.Dir(filename), \"..\", \"..\")\n\terr := os.Chdir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestServerPanicIfNoDatastore(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: a datastore option must be provided\", func() {\n\t\t_ = MustNewServerWithOpts()\n\t})\n}\n\nfunc TestServerNotReadyDueToDatastoreRevision(t *testing.T) {\n\tengines := []string{\"postgres\", \"mysql\"}\n\n\tfor _, engine := range engines {\n\t\tt.Run(engine, func(t *testing.T) {\n\t\t\t_, ds, stopFunc, uri, err := util.MustBootstrapDatastore(t, engine)\n\t\t\tdefer stopFunc()\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttargetVersion := build.MinimumSupportedDatastoreSchemaRevision - 1\n\n\t\t\tmigrateCommand := migrate.NewMigrateCommand()\n\n\t\t\tmigrateCommand.SetArgs([]string{\"--datastore-engine\", engine, \"--datastore-uri\", uri, \"--version\", strconv.Itoa(int(targetVersion))})\n\n\t\t\terr = migrateCommand.Execute()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tstatus, _ := ds.IsReady(context.Background())\n\t\t\trequire.Contains(t, status.Message, fmt.Sprintf(\"datastore requires migrations: at revision '%d', but requires '%d'.\", targetVersion, build.MinimumSupportedDatastoreSchemaRevision))\n\t\t\trequire.False(t, status.IsReady)\n\t\t})\n\t}\n}\n\nfunc TestServerPanicIfEmptyRequestDurationDatastoreCountBuckets(t *testing.T) {\n\trequire.PanicsWithError(t, \"failed to construct the OpenFGA server: request duration datastore count buckets must not be empty\", func() {\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\t_ = MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t\tWithRequestDurationByQueryHistogramBuckets([]uint{}),\n\t\t)\n\t})\n}\n\nfunc TestServerWithPostgresDatastore(t *testing.T) {\n\tds, stopFunc := MustBootstrapDatastore(t, \"postgres\")\n\tdefer func() {\n\t\tstopFunc()\n\t\tgoleak.VerifyNone(t)\n\t}()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithPostgresDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\tdefer func() {\n\t\tstopFunc()\n\t\tgoleak.VerifyNone(t)\n\t}()\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := postgres.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMemoryDatastore(t *testing.T) {\n\tds, stopFunc := MustBootstrapDatastore(t, \"memory\")\n\tdefer func() {\n\t\tstopFunc()\n\t\tgoleak.VerifyNone(t)\n\t}()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastore(t *testing.T) {\n\tds, stopFunc := MustBootstrapDatastore(t, \"mysql\")\n\tdefer func() {\n\t\tstopFunc()\n\t\tgoleak.VerifyNone(t)\n\t}()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc TestServerWithMySQLDatastoreAndExplicitCredentials(t *testing.T) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, \"mysql\")\n\tdefer func() {\n\t\tstopFunc()\n\t\tgoleak.VerifyNone(t)\n\t}()\n\n\turi := testDatastore.GetConnectionURI(false)\n\tds, err := mysql.New(\n\t\turi,\n\t\tsqlcommon.NewConfig(\n\t\t\tsqlcommon.WithUsername(testDatastore.GetUsername()),\n\t\t\tsqlcommon.WithPassword(testDatastore.GetPassword()),\n\t\t),\n\t)\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ttest.RunAllTests(t, ds)\n}\n\nfunc BenchmarkOpenFGAServer(b *testing.B) {\n\tb.Run(\"BenchmarkPostgresDatastore\", func(b *testing.B) {\n\t\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(b, \"postgres\")\n\t\tdefer stopFunc()\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := postgres.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMemoryDatastore\", func(b *testing.B) {\n\t\tds := memory.New()\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n\n\tb.Run(\"BenchmarkMySQLDatastore\", func(b *testing.B) {\n\t\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(b, \"mysql\")\n\t\tdefer stopFunc()\n\n\t\turi := testDatastore.GetConnectionURI(true)\n\t\tds, err := mysql.New(uri, sqlcommon.NewConfig())\n\t\trequire.NoError(b, err)\n\t\tdefer ds.Close()\n\t\ttest.RunAllBenchmarks(b, ds)\n\t})\n}\n\nfunc TestCheckDoesNotThrowBecauseDirectTupleWasFound(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user]\n`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"reader\", \"user:anne\")\n\treturnedTuple := &openfgav1.Tuple{Key: tuple.ConvertCheckRequestTupleKeyToTupleKey(tk)}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(returnedTuple, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\treturn nil, errors.New(\"some error\")\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestListObjectsReleasesConnections(t *testing.T) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, \"postgres\")\n\tdefer stopFunc()\n\n\turi := testDatastore.GetConnectionURI(true)\n\tds, err := postgres.New(uri, sqlcommon.NewConfig(\n\t\tsqlcommon.WithMaxOpenConns(1),\n\t\tsqlcommon.WithMaxTuplesPerWrite(2000),\n\t))\n\trequire.NoError(t, err)\n\tdefer ds.Close()\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(storagewrappers.NewContextWrapper(ds)),\n\t\tWithMaxConcurrentReadsForListObjects(1),\n\t)\n\n\tstoreID := ulid.Make().String()\n\n\twriteAuthzModelResp, err := s.WriteAuthorizationModel(context.Background(), &openfgav1.WriteAuthorizationModelRequest{\n\t\tStoreId: storeID,\n\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine editor: [user]`).TypeDefinitions,\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t})\n\trequire.NoError(t, err)\n\n\tmodelID := writeAuthzModelResp.GetAuthorizationModelId()\n\n\tnumTuples := 2000\n\ttuples := make([]*openfgav1.TupleKey, 0, numTuples)\n\tfor i := 0; i < numTuples; i++ {\n\t\ttk := tuple.NewTupleKey(fmt.Sprintf(\"document:%d\", i), \"editor\", \"user:jon\")\n\n\t\ttuples = append(tuples, tk)\n\t}\n\n\t_, err = s.Write(context.Background(), &openfgav1.WriteRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tWrites: &openfgav1.WriteRequestWrites{\n\t\t\tTupleKeys: tuples,\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\n\t_, err = s.ListObjects(context.Background(), &openfgav1.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"document\",\n\t\tRelation:             \"editor\",\n\t\tUser:                 \"user:jon\",\n\t})\n\trequire.NoError(t, err)\n\n\ttimeoutCtx, timeoutCancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer timeoutCancel()\n\n\t// If ListObjects is still hogging the database connection pool even after responding, then this fails.\n\t// If ListObjects is closing up its connections effectively then this will not fail.\n\tstatus, err := ds.IsReady(timeoutCtx)\n\trequire.NoError(t, err)\n\trequire.True(t, status.IsReady)\n}\n\nfunc TestOperationsWithInvalidModel(t *testing.T) {\n\tctx := context.Background()\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\t// The model is invalid\n\ttypedefs := parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine admin: [user]\n\tdefine r1: [user] and r2 and r3\n\tdefine r2: [user] and r1 and r3\n\tdefine r3: [user] and r1 and r2`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"r1\", \"user:anne\")\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tId:              modelID,\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// the model is error and err should return\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\trequire.Error(t, err)\n\te, ok := status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"repo\",\n\t\tRelation:             \"r1\",\n\t\tUser:                 \"user:anne\",\n\t}, NewMockStreamServer())\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\n\t_, err = s.Expand(ctx, &openfgav1.ExpandRequest{\n\t\tStoreId:              storeID,\n\t\tAuthorizationModelId: modelID,\n\t\tTupleKey:             tuple.NewExpandRequestTupleKey(tk.Object, tk.Relation),\n\t})\n\trequire.Error(t, err)\n\te, ok = status.FromError(err)\n\trequire.True(t, ok)\n\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n}\n\nfunc TestShortestPathToSolutionWins(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user:*]`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"reader\", \"user:*\")\n\treturnedTuple := &openfgav1.Tuple{Key: tuple.ConvertCheckRequestTupleKeyToTupleKey(tk)}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\t// it could happen that one of the following two mocks won't be necessary because the goroutine will be short-circuited\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(ctx context.Context, _ string, _ *openfgav1.TupleKey) (storage.TupleIterator, error) {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\t\t\treturn nil, storage.ErrNotFound\n\t\t\t\t}\n\t\t\t})\n\n\tmockDatastore.EXPECT().\n\t\tReadUsersetTuples(gomock.Any(), storeID, gomock.Any()).\n\t\tAnyTimes().\n\t\tDoAndReturn(\n\t\t\tfunc(_ context.Context, _ string, _ storage.ReadUsersetTuplesFilter) (storage.TupleIterator, error) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\treturn storage.NewStaticTupleIterator([]*openfgav1.Tuple{returnedTuple}), nil\n\t\t\t})\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tstart := time.Now()\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\tend := time.Since(start)\n\n\t// we expect the Check call to be short-circuited after ReadUsersetTuples runs\n\trequire.Lessf(t, end, 200*time.Millisecond, fmt.Sprintf(\"end was %s\", end))\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestCheckWithCachedResolution(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user]`).TypeDefinitions\n\n\ttk := tuple.NewCheckRequestTupleKey(\"repo:openfga\", \"reader\", \"user:mike\")\n\treturnedTuple := &openfgav1.Tuple{Key: tuple.ConvertCheckRequestTupleKeyToTupleKey(tk)}\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\tmockDatastore.EXPECT().\n\t\tReadUserTuple(gomock.Any(), storeID, gomock.Any()).\n\t\tTimes(1).\n\t\tReturn(returnedTuple, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t\tWithCheckQueryCacheEnabled(true),\n\t\tWithCheckQueryCacheLimit(10),\n\t\tWithCheckQueryCacheTTL(1*time.Minute),\n\t)\n\n\tcheckResponse, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n\n\t// If we check for the same request, data should come from cache and number of ReadUserTuple should still be 1\n\tcheckResponse, err = s.Check(ctx, &openfgav1.CheckRequest{\n\t\tStoreId:              storeID,\n\t\tTupleKey:             tk,\n\t\tAuthorizationModelId: modelID,\n\t})\n\n\trequire.NoError(t, err)\n\trequire.True(t, checkResponse.Allowed)\n}\n\nfunc TestWriteAssertionModelDSError(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine reader: [user]`).TypeDefinitions\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDSOldSchema := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDSOldSchema.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\n\tmockDSBadReadAuthModel := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDSBadReadAuthModel.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(nil, fmt.Errorf(\"unable to read\"))\n\n\tmockDSBadWriteAssertions := mockstorage.NewMockOpenFGADatastore(mockController)\n\tmockDSBadWriteAssertions.EXPECT().\n\t\tReadAuthorizationModel(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: typedefs,\n\t\t}, nil)\n\tmockDSBadWriteAssertions.EXPECT().\n\t\tWriteAssertions(gomock.Any(), storeID, modelID, gomock.Any()).\n\t\tAnyTimes().\n\t\tReturn(fmt.Errorf(\"unable to write\"))\n\n\ttests := []struct {\n\t\tname          string\n\t\tassertions    []*openfgav1.Assertion\n\t\tmockDatastore *mockstorage.MockOpenFGADatastore\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"unsupported_schema\",\n\t\t\tassertions:    []*openfgav1.Assertion{},\n\t\t\tmockDatastore: mockDSOldSchema,\n\t\t\texpectedError: serverErrors.ValidationError(\n\t\t\t\tfmt.Errorf(\"invalid schema version\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"failed_to_read\",\n\t\t\tassertions:    []*openfgav1.Assertion{},\n\t\t\tmockDatastore: mockDSBadReadAuthModel,\n\t\t\texpectedError: serverErrors.NewInternalError(\n\t\t\t\t\"\", fmt.Errorf(\"unable to read\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname:          \"failed_to_write\",\n\t\t\tassertions:    []*openfgav1.Assertion{},\n\t\t\tmockDatastore: mockDSBadWriteAssertions,\n\t\t\texpectedError: serverErrors.NewInternalError(\n\t\t\t\t\"\", fmt.Errorf(\"unable to write\"),\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, curTest := range tests {\n\t\tt.Run(curTest.name, func(t *testing.T) {\n\t\t\trequest := &openfgav1.WriteAssertionsRequest{\n\t\t\t\tStoreId:              storeID,\n\t\t\t\tAssertions:           curTest.assertions,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t}\n\n\t\t\twriteAssertionCmd := commands.NewWriteAssertionsCommand(curTest.mockDatastore)\n\t\t\t_, err := writeAssertionCmd.Execute(ctx, request)\n\t\t\trequire.ErrorIs(t, curTest.expectedError, err)\n\t\t})\n\t}\n}\n\nfunc TestReadAssertionModelDSError(t *testing.T) {\n\tctx := context.Background()\n\n\tstoreID := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDSBadReadAssertions := mockstorage.NewMockOpenFGADatastore(mockController)\n\tmockDSBadReadAssertions.EXPECT().\n\t\tReadAssertions(gomock.Any(), storeID, modelID).\n\t\tAnyTimes().\n\t\tReturn(nil, fmt.Errorf(\"unable to read\"))\n\n\treadAssertionQuery := commands.NewReadAssertionsQuery(mockDSBadReadAssertions)\n\t_, err := readAssertionQuery.Execute(ctx, storeID, modelID)\n\texpectedError := serverErrors.NewInternalError(\n\t\t\"\", fmt.Errorf(\"unable to read\"),\n\t)\n\trequire.ErrorIs(t, expectedError, err)\n}\n\nfunc TestResolveAuthorizationModel(t *testing.T) {\n\tctx := context.Background()\n\n\tt.Run(\"no_latest_authorization_model_id_found\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(\"\", storage.ErrNotFound)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\texpectedError := serverErrors.LatestAuthorizationModelNotFound(store)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.ErrorIs(t, err, expectedError)\n\t})\n\n\tt.Run(\"read_existing_authorization_model\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\t\tmockDatastore.EXPECT().FindLatestAuthorizationModelID(gomock.Any(), store).Return(modelID, nil)\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).Return(\n\t\t\t&openfgav1.AuthorizationModel{\n\t\t\t\tId:            modelID,\n\t\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\t},\n\t\t\tnil,\n\t\t)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\ttypesys, err := s.resolveTypesystem(ctx, store, \"\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, modelID, typesys.GetAuthorizationModelID())\n\t})\n\n\tt.Run(\"non-valid_modelID_returns_error\", func(t *testing.T) {\n\t\tstore := ulid.Make().String()\n\t\tmodelID := \"foo\"\n\t\twant := serverErrors.AuthorizationModelNotFound(modelID)\n\n\t\tmockController := gomock.NewController(t)\n\t\tdefer mockController.Finish()\n\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\t_, err := s.resolveTypesystem(ctx, store, modelID)\n\t\trequire.Equal(t, want, err)\n\t})\n}\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n}\n\nfunc NewMockStreamServer() *mockStreamServer {\n\treturn &mockStreamServer{}\n}\n\nfunc (m *mockStreamServer) Context() context.Context {\n\treturn context.Background()\n}\n\nfunc (m *mockStreamServer) Send(*openfgav1.StreamedListObjectsResponse) error {\n\treturn nil\n}\n\n// This runs ListObjects and StreamedListObjects many times over to ensure no race conditions (see https://github.com/openfga/openfga/pull/762)\nfunc BenchmarkListObjectsNoRaceCondition(b *testing.B) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(b)\n\tdefer mockController.Finish()\n\n\ttypedefs := parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype repo\n  relations\n\tdefine allowed: [user]\n\tdefine viewer: [user] and allowed`).TypeDefinitions\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion:   typesystem.SchemaVersion1_1,\n\t\tTypeDefinitions: typedefs,\n\t}, nil)\n\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, gomock.Any()).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t})\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\n\t\terr = s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"repo\",\n\t\t\tRelation:             \"viewer\",\n\t\t\tUser:                 \"user:bob\",\n\t\t}, NewMockStreamServer())\n\n\t\trequire.ErrorIs(b, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t}\n}\n\nfunc TestListObjects_ErrorCases(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tt.Run(\"database_errors\", func(t *testing.T) {\n\t\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(mockDatastore),\n\t\t)\n\n\t\tmodelID := ulid.Make().String()\n\n\t\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype document\n  relations\n\tdefine viewer: [user, user:*]`).TypeDefinitions,\n\t\t}, nil)\n\n\t\tmockDatastore.EXPECT().ReadStartingWithUser(gomock.Any(), store, storage.ReadStartingWithUserFilter{\n\t\t\tObjectType: \"document\",\n\t\t\tRelation:   \"viewer\",\n\t\t\tUserFilter: []*openfgav1.ObjectRelation{\n\t\t\t\t{Object: \"user:*\"},\n\t\t\t\t{Object: \"user:bob\"},\n\t\t\t}}).AnyTimes().Return(nil, errors.New(\"error reading from storage\"))\n\n\t\tt.Run(\"error_listing_objects_from_storage_in_non-streaming_version\", func(t *testing.T) {\n\t\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:bob\",\n\t\t\t})\n\n\t\t\trequire.Nil(t, res)\n\t\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t\t})\n\n\t\tt.Run(\"error_listing_objects_from_storage_in_streaming_version\", func(t *testing.T) {\n\t\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: modelID,\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:bob\",\n\t\t\t}, NewMockStreamServer())\n\n\t\t\trequire.ErrorIs(t, err, serverErrors.NewInternalError(\"\", errors.New(\"error reading from storage\")))\n\t\t})\n\t})\n\n\tt.Run(\"graph_resolution_errors\", func(t *testing.T) {\n\t\ts := MustNewServerWithOpts(\n\t\t\tWithDatastore(memory.New()),\n\t\t\tWithResolveNodeLimit(2),\n\t\t)\n\n\t\twriteModelResp, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:       store,\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n  schema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user, group#member]\n\ntype document\n  relations\n\tdefine viewer: [group#member]`).TypeDefinitions,\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId: store,\n\t\t\tWrites: &openfgav1.WriteRequestWrites{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:1#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:1\", \"member\", \"group:2#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:2\", \"member\", \"group:3#member\"),\n\t\t\t\t\ttuple.NewTupleKey(\"group:3\", \"member\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\trequire.NoError(t, err)\n\n\t\tt.Run(\"resolution_depth_exceeded_error_unary\", func(t *testing.T) {\n\t\t\tres, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: writeModelResp.GetAuthorizationModelId(),\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:jon\",\n\t\t\t})\n\n\t\t\trequire.Nil(t, res)\n\t\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t\t})\n\n\t\tt.Run(\"resolution_depth_exceeded_error_streaming\", func(t *testing.T) {\n\t\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\t\tStoreId:              store,\n\t\t\t\tAuthorizationModelId: writeModelResp.GetAuthorizationModelId(),\n\t\t\t\tType:                 \"document\",\n\t\t\t\tRelation:             \"viewer\",\n\t\t\t\tUser:                 \"user:jon\",\n\t\t\t}, NewMockStreamServer())\n\n\t\t\trequire.ErrorIs(t, err, serverErrors.AuthorizationModelResolutionTooComplex)\n\t\t})\n\t})\n}\n\nfunc TestAuthorizationModelInvalidSchemaVersion(t *testing.T) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\tmodelID := ulid.Make().String()\n\n\tmockController := gomock.NewController(t)\n\tdefer mockController.Finish()\n\n\tmockDatastore := mockstorage.NewMockOpenFGADatastore(mockController)\n\n\tmockDatastore.EXPECT().ReadAuthorizationModel(gomock.Any(), store, modelID).AnyTimes().Return(&openfgav1.AuthorizationModel{\n\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\tTypeDefinitions: []*openfgav1.TypeDefinition{\n\t\t\t{\n\t\t\t\tType: \"user\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tType: \"team\",\n\t\t\t\tRelations: map[string]*openfgav1.Userset{\n\t\t\t\t\t\"member\": typesystem.This(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(mockDatastore),\n\t)\n\n\tt.Run(\"invalid_schema_error_in_check\", func(t *testing.T) {\n\t\t_, err := s.Check(ctx, &openfgav1.CheckRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tTupleKey: tuple.NewCheckRequestTupleKey(\n\t\t\t\t\"team:abc\",\n\t\t\t\t\"member\",\n\t\t\t\t\"user:anne\"),\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_list_objects\", func(t *testing.T) {\n\t\t_, err := s.ListObjects(ctx, &openfgav1.ListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_streamed_list_objects\", func(t *testing.T) {\n\t\terr := s.StreamedListObjects(&openfgav1.StreamedListObjectsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tType:                 \"team\",\n\t\t\tRelation:             \"member\",\n\t\t\tUser:                 \"user:anne\",\n\t\t}, NewMockStreamServer())\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write\", func(t *testing.T) {\n\t\t_, err := s.Write(ctx, &openfgav1.WriteRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tWrites: &openfgav1.WriteRequestWrites{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tObject:   \"repo:openfga/openfga\",\n\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_model\", func(t *testing.T) {\n\t\tmockDatastore.EXPECT().MaxTypesPerAuthorizationModel().Return(100)\n\n\t\t_, err := s.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{\n\t\t\tStoreId:       store,\n\t\t\tSchemaVersion: typesystem.SchemaVersion1_0,\n\t\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype repo\n`).TypeDefinitions,\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_invalid_authorization_model), e.Code(), err)\n\t})\n\n\tt.Run(\"invalid_schema_error_in_write_assertion\", func(t *testing.T) {\n\t\t_, err := s.WriteAssertions(ctx, &openfgav1.WriteAssertionsRequest{\n\t\t\tStoreId:              store,\n\t\t\tAuthorizationModelId: modelID,\n\t\t\tAssertions: []*openfgav1.Assertion{{\n\t\t\t\tTupleKey:    tuple.NewAssertionTupleKey(\"repo:test\", \"reader\", \"user:elbuo\"),\n\t\t\t\tExpectation: false,\n\t\t\t}},\n\t\t})\n\t\trequire.Error(t, err)\n\t\te, ok := status.FromError(err)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, codes.Code(openfgav1.ErrorCode_validation_error), e.Code())\n\t})\n}\n\nfunc TestDefaultMaxConcurrentReadSettings(t *testing.T) {\n\tcfg := serverconfig.DefaultConfig()\n\trequire.EqualValues(t, math.MaxUint32, cfg.MaxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, cfg.MaxConcurrentReadsForListObjects)\n\n\ts := MustNewServerWithOpts(\n\t\tWithDatastore(memory.New()),\n\t)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForCheck)\n\trequire.EqualValues(t, math.MaxUint32, s.maxConcurrentReadsForListObjects)\n}\n\nfunc MustBootstrapDatastore(t testing.TB, engine string) (storage.OpenFGADatastore, func()) {\n\ttestDatastore, stopFunc := storagefixtures.RunDatastoreTestContainer(t, engine)\n\n\turi := testDatastore.GetConnectionURI(true)\n\n\tvar ds storage.OpenFGADatastore\n\tvar err error\n\n\tswitch engine {\n\tcase \"memory\":\n\t\tds = memory.New()\n\tcase \"postgres\":\n\t\tds, err = postgres.New(uri, sqlcommon.NewConfig())\n\tcase \"mysql\":\n\t\tds, err = mysql.New(uri, sqlcommon.NewConfig())\n\tdefault:\n\t\tt.Fatalf(\"'%s' is not a supported datastore engine\", engine)\n\t}\n\trequire.NoError(t, err)\n\n\treturn ds, func() {\n\t\tds.Close()\n\t\tstopFunc()\n\t}\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/karlseguin/ccache/v3\"\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\tparser \"github.com/openfga/language/pkg/go/transformer\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/internal/mocks\"\n\t\"github.com/openfga/openfga/pkg/server/commands\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\ntype mockStreamServer struct {\n\tgrpc.ServerStream\n\tchannel chan string\n}\n\nfunc (x *mockStreamServer) Send(m *openfgav1.StreamedListObjectsResponse) error {\n\tx.channel <- m.Object\n\treturn nil\n}\n\ntype listObjectsTestCase struct {\n\tname                   string\n\ttuples                 []*openfgav1.TupleKey\n\tmodel                  string\n\tobjectType             string\n\tuser                   string\n\trelation               string\n\tcontextualTuples       *openfgav1.ContextualTupleKeys\n\tcontext                *structpb.Struct\n\tallResults             []string // all the results. the server may return less\n\tmaxResults             uint32\n\tminimumResultsExpected uint32\n\tlistObjectsDeadline    time.Duration // 10 seconds if not set\n\treadTuplesDelay        time.Duration // if set, purposely use a slow storage to slow down read and simulate timeout\n\tuseCheckCache          bool\n}\n\nfunc TestListObjects(t *testing.T, ds storage.OpenFGADatastore) {\n\ttestCases := []listObjectsTestCase{\n\t\t{\n\t\t\tname: \"max_results_equal_0_with_simple_model\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             0,\n\t\t\tminimumResultsExpected: 3,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"max_results_equal_2_with_simple_model\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"max_results_with_model_that_uses_exclusion\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype org\n  relations\n\tdefine blocked: [user]\n\tdefine admin: [user] but not blocked`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"org:1\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"admin\", \"user:charlie\"),\n\t\t\t},\n\t\t\tuser:       \"user:charlie\",\n\t\t\tobjectType: \"org\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"org:3\", \"admin\", \"user:charlie\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"org:1\", \"org:2\", \"org:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"max_results_with_model_that_uses_exclusion_and_one_object_is_a_false_candidate\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype org\n  relations\n\tdefine blocked: [user]\n\tdefine admin: [user] but not blocked`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"blocked\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:1\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:2\", \"admin\", \"user:charlie\"),\n\t\t\t\ttuple.NewTupleKey(\"org:3\", \"admin\", \"user:charlie\"),\n\t\t\t},\n\t\t\tuser:                   \"user:charlie\",\n\t\t\tobjectType:             \"org\",\n\t\t\trelation:               \"admin\",\n\t\t\tcontextualTuples:       &openfgav1.ContextualTupleKeys{},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"org:1\", \"org:3\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"respects_when_schema_1_1_and_maxresults_is_higher_than_actual_result_length\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype team\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:1\", \"admin\", \"user:bob\"),\n\t\t\t},\n\t\t\tuser:                   \"user:bob\",\n\t\t\tobjectType:             \"team\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"team:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"respects_max_results_when_deadline_timeout_and_returns_no_error_and_no_results\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:                   \"user:alice\",\n\t\t\tobjectType:             \"repo\",\n\t\t\trelation:               \"admin\",\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 0,\n\t\t\t// We expect empty array to be returned as list object will timeout due to readTuplesDelay > listObjectsDeadline\n\t\t\tallResults:          []string{},\n\t\t\tlistObjectsDeadline: 1 * time.Second,\n\t\t\treadTuplesDelay:     2 * time.Second, // We are mocking the ds to slow down the read call and simulate timeout\n\t\t\tuseCheckCache:       false,\n\t\t},\n\t\t{\n\t\t\tname: \"list_object_use_check_cache\",\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype repo\n  relations\n\tdefine admin: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"repo:1\", \"admin\", \"user:alice\"),\n\t\t\t\ttuple.NewTupleKey(\"repo:2\", \"admin\", \"user:alice\"),\n\t\t\t},\n\t\t\tuser:       \"user:alice\",\n\t\t\tobjectType: \"repo\",\n\t\t\trelation:   \"admin\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{tuple.NewTupleKey(\"repo:3\", \"admin\", \"user:alice\")},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"repo:1\", \"repo:2\", \"repo:3\"},\n\t\t\t// when we use cache, the regular_endpoint should pick up the cached value from the streaming_endpoint run\n\t\t\tuseCheckCache: true,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_tuples\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string) {\n  param1 == 'ok'\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tuser:                   \"user:anne\",\n\t\t\tobjectType:             \"document\",\n\t\t\trelation:               \"viewer\",\n\t\t\tcontextualTuples:       nil,\n\t\t\tmaxResults:             1,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"document:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_contextual_tuples\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string) {\n  param1 == 'ok'\n}`,\n\t\t\ttuples:     nil,\n\t\t\tuser:       \"user:anne\",\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmaxResults:             1,\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"document:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_tuples_and_contextual_tuples\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string) {\n  param1 == 'ok'\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"notok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tuser:       \"user:anne\",\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmaxResults:             2,\n\t\t\tminimumResultsExpected: 2,\n\t\t\tallResults:             []string{\"document:1\", \"document:2\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_with_tuples_and_contextual_tuples_and_context\",\n\t\t\tmodel: `model\n  schema 1.1\ntype user\ntype document\n  relations\n    define viewer: [user with condition1]\n\ncondition condition1(param1: string, param2: string) {\n  param1 == 'ok' && param2 == 'ok'\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:1\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\tObject:   \"document:2\",\n\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tuser:       \"user:anne\",\n\t\t\tobjectType: \"document\",\n\t\t\trelation:   \"viewer\",\n\t\t\tcontext:    testutils.MustNewStruct(t, map[string]interface{}{\"param2\": \"ok\"}),\n\t\t\tcontextualTuples: &openfgav1.ContextualTupleKeys{\n\t\t\t\tTupleKeys: []*openfgav1.TupleKey{\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:3\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tUser:     \"user:anne\",\n\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\tObject:   \"document:4\",\n\t\t\t\t\t\tCondition: &openfgav1.RelationshipCondition{\n\t\t\t\t\t\t\tName:    \"condition1\",\n\t\t\t\t\t\t\tContext: testutils.MustNewStruct(t, map[string]interface{}{\"param1\": \"ok\"}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmaxResults:             4,\n\t\t\tminimumResultsExpected: 4,\n\t\t\tallResults:             []string{\"document:1\", \"document:2\", \"document:3\", \"document:4\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t\t{\n\t\t\tname: \"condition_in_ttu_relationships\",\n\t\t\tmodel: `model\n  schema 1.1\n\ntype user\n\ntype folder\n  relations\n    define viewer: [user]\n\ntype document\n  relations\n    define parent: [folder with condition1]\n\tdefine viewer: viewer from parent\n\ncondition condition1(x: int) {\n  x < 100\n}`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKeyWithCondition(\"document:1\", \"parent\", \"folder:x\", \"condition1\", nil),\n\t\t\t\ttuple.NewTupleKey(\"folder:x\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\tuser:                   \"user:jon\",\n\t\t\tobjectType:             \"document\",\n\t\t\trelation:               \"viewer\",\n\t\t\tcontext:                testutils.MustNewStruct(t, map[string]interface{}{\"x\": 50}),\n\t\t\tminimumResultsExpected: 1,\n\t\t\tallResults:             []string{\"document:1\"},\n\t\t\tuseCheckCache:          false,\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx := context.Background()\n\t\t\tstoreID := ulid.Make().String()\n\n\t\t\t// arrange: write model\n\t\t\tmodel := testutils.MustTransformDSLToProtoWithID(test.model)\n\n\t\t\terr := ds.WriteAuthorizationModel(ctx, storeID, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// arrange: write tuples\n\t\t\terr = ds.Write(context.Background(), storeID, nil, test.tuples)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// act: run ListObjects\n\n\t\t\tdatastore := ds\n\t\t\tif test.readTuplesDelay > 0 {\n\t\t\t\tdatastore = mocks.NewMockSlowDataStorage(ds, test.readTuplesDelay)\n\t\t\t}\n\n\t\t\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\t\t\topts := []commands.ListObjectsQueryOption{\n\t\t\t\tcommands.WithListObjectsMaxResults(test.maxResults),\n\t\t\t\tcommands.WithListObjectsDeadline(10 * time.Second),\n\t\t\t}\n\n\t\t\tif test.listObjectsDeadline != 0 {\n\t\t\t\topts = append(opts, commands.WithListObjectsDeadline(test.listObjectsDeadline))\n\t\t\t}\n\n\t\t\tcheckOptions := []graph.LocalCheckerOption{\n\t\t\t\tgraph.WithResolveNodeBreadthLimit(100),\n\t\t\t\tgraph.WithMaxConcurrentReads(30),\n\t\t\t}\n\n\t\t\tif test.useCheckCache {\n\t\t\t\tcheckCache := ccache.New(\n\t\t\t\t\tccache.Configure[*graph.CachedResolveCheckResponse]().MaxSize(100),\n\t\t\t\t)\n\t\t\t\tdefer checkCache.Stop()\n\n\t\t\t\tcheckOptions = append(checkOptions, graph.WithCachedResolver(\n\t\t\t\t\tgraph.WithExistingCache(checkCache),\n\t\t\t\t\tgraph.WithCacheTTL(10*time.Second),\n\t\t\t\t))\n\t\t\t}\n\n\t\t\topts = append(opts, commands.WithCheckOptions(checkOptions))\n\t\t\tlistObjectsQuery := commands.NewListObjectsQuery(datastore, opts...)\n\n\t\t\t// assertions\n\t\t\tt.Run(\"streaming_endpoint\", func(t *testing.T) {\n\t\t\t\tserver := &mockStreamServer{\n\t\t\t\t\tchannel: make(chan string, len(test.allResults)),\n\t\t\t\t}\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tvar streamedObjectIds []string\n\t\t\t\tgo func() {\n\t\t\t\t\tfor {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase objectID, open := <-server.channel:\n\t\t\t\t\t\t\tif !open {\n\t\t\t\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstreamedObjectIds = append(streamedObjectIds, objectID)\n\n\t\t\t\t\t\t// for tests whose deadline is sooner than the latency of the storage layer\n\t\t\t\t\t\tcase <-time.After(test.readTuplesDelay + 1*time.Second):\n\t\t\t\t\t\t\tdone <- struct{}{}\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}()\n\n\t\t\t\t_, err := listObjectsQuery.ExecuteStreamed(ctx, &openfgav1.StreamedListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t\tContext:          test.context,\n\t\t\t\t}, server)\n\t\t\t\tclose(server.channel)\n\t\t\t\t<-done\n\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\t// there is no upper bound of the number of results for the streamed version\n\t\t\t\trequire.GreaterOrEqual(t, len(streamedObjectIds), int(test.minimumResultsExpected))\n\t\t\t\trequire.ElementsMatch(t, test.allResults, streamedObjectIds)\n\t\t\t})\n\n\t\t\tt.Run(\"regular_endpoint\", func(t *testing.T) {\n\t\t\t\tres, err := listObjectsQuery.Execute(ctx, &openfgav1.ListObjectsRequest{\n\t\t\t\t\tStoreId:          storeID,\n\t\t\t\t\tType:             test.objectType,\n\t\t\t\t\tRelation:         test.relation,\n\t\t\t\t\tUser:             test.user,\n\t\t\t\t\tContextualTuples: test.contextualTuples,\n\t\t\t\t\tContext:          test.context,\n\t\t\t\t})\n\n\t\t\t\trequire.NotNil(t, res)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tif test.maxResults != 0 { // don't get all results\n\t\t\t\t\trequire.LessOrEqual(t, len(res.Objects), int(test.maxResults))\n\t\t\t\t}\n\t\t\t\trequire.GreaterOrEqual(t, len(res.Objects), int(test.minimumResultsExpected))\n\t\t\t\trequire.Subset(t, test.allResults, res.Objects)\n\t\t\t})\n\t\t})\n\t}\n}\n\n// Used to avoid compiler optimizations (see https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)\nvar listObjectsResponse *commands.ListObjectsResponse //nolint\n\n// setupListObjectsBenchmark writes the model and lots of tuples\nfunc setupListObjectsBenchmark(b *testing.B, ds storage.OpenFGADatastore, storeID string) (*openfgav1.AuthorizationModel, string, int) {\n\tb.Helper()\n\tmodelID := ulid.Make().String()\n\tmodel := &openfgav1.AuthorizationModel{\n\t\tId:            modelID,\n\t\tSchemaVersion: typesystem.SchemaVersion1_1,\n\t\t// this model exercises all possible execution paths: \"direct\" edge and \"computed userset\" edge and \"TTU\" edge\n\t\tTypeDefinitions: parser.MustTransformDSLToProto(`model\n\tschema 1.1\ntype user\ntype folder\n  relations\n    define viewer: [user]\ntype document\n  relations\n\tdefine viewer: [user]\n\tdefine parent: [folder]\n\tdefine can_view: viewer or viewer from parent`).TypeDefinitions,\n\t}\n\terr := ds.WriteAuthorizationModel(context.Background(), storeID, model)\n\trequire.NoError(b, err)\n\n\tnumberObjectsAccesible := 0\n\tfor i := 0; i < 100; i++ {\n\t\tvar tuples []*openfgav1.TupleKey\n\n\t\tfor j := 0; j < ds.MaxTuplesPerWrite(); j++ {\n\t\t\tobj := fmt.Sprintf(\"document:%s\", strconv.Itoa(numberObjectsAccesible))\n\n\t\t\ttuples = append(tuples, tuple.NewTupleKey(obj, \"viewer\", \"user:maria\"))\n\n\t\t\tnumberObjectsAccesible += 1\n\t\t}\n\n\t\terr := ds.Write(context.Background(), storeID, nil, tuples)\n\t\trequire.NoError(b, err)\n\t}\n\n\treturn model, modelID, numberObjectsAccesible\n}\n\nfunc BenchmarkListObjects(b *testing.B, ds storage.OpenFGADatastore) {\n\tctx := context.Background()\n\tstore := ulid.Make().String()\n\n\tmodel, modelID, numberObjectsAccessible := setupListObjectsBenchmark(b, ds, store)\n\tctx = typesystem.ContextWithTypesystem(ctx, typesystem.New(model))\n\n\treq := &openfgav1.ListObjectsRequest{\n\t\tStoreId:              store,\n\t\tAuthorizationModelId: modelID,\n\t\tType:                 \"document\",\n\t\tRelation:             \"can_view\",\n\t\tUser:                 \"user:maria\",\n\t}\n\n\tvar r *commands.ListObjectsResponse\n\n\tvar oneResultIterations, allResultsIterations int\n\n\tb.Run(\"oneResult\", func(b *testing.B) {\n\t\tlistObjectsQuery := commands.NewListObjectsQuery(ds,\n\t\t\tcommands.WithListObjectsMaxResults(1),\n\t\t)\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tr, _ := listObjectsQuery.Execute(ctx, req)\n\t\t\trequire.Len(b, r.Objects, 1)\n\t\t}\n\n\t\tlistObjectsResponse = r\n\t\toneResultIterations = b.N\n\t})\n\tb.Run(\"allResults\", func(b *testing.B) {\n\t\tlistObjectsQuery := commands.NewListObjectsQuery(ds,\n\t\t\tcommands.WithListObjectsMaxResults(0),\n\t\t)\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tr, _ := listObjectsQuery.Execute(ctx, req)\n\t\t\trequire.Len(b, r.Objects, numberObjectsAccessible)\n\t\t}\n\n\t\tlistObjectsResponse = r\n\t\tallResultsIterations = b.N\n\t})\n\n\trequire.Greater(b, oneResultIterations, allResultsIterations)\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/openfga/openfga/internal/graph\"\n\t\"github.com/openfga/openfga/pkg/server/commands/reverseexpand\"\n\t\"github.com/openfga/openfga/pkg/storage\"\n\t\"github.com/openfga/openfga/pkg/testutils\"\n\t\"github.com/openfga/openfga/pkg/tuple\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n)\n\nfunc TestReverseExpand(t *testing.T, ds storage.OpenFGADatastore) {\n\ttests := []struct {\n\t\tname                 string\n\t\tmodel                string\n\t\ttuples               []*openfgav1.TupleKey\n\t\trequest              *reverseexpand.ReverseExpandRequest\n\t\tresolveNodeLimit     uint32\n\t\texpectedResult       []*reverseexpand.ReverseExpandResult\n\t\texpectedError        error\n\t\texpectedDSQueryCount uint32\n\t}{\n\t\t{\n\t\t\tname: \"basic_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine allowed: [user]\n\tdefine viewer: [user] and allowed`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"allowed\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirect_intersection\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine writer: [user]\n\tdefine editor: [user]\n\tdefine viewer: writer and editor\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:X\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"writer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:X\", \"editor\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.RequiresFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\n\t\t{\n\t\t\tname: \"resolve_direct_relationships_with_tuples_and_contextual_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine viewer: [user]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"direct_relations_involving_relationships_with_users_and_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype document\n  relations\n\tdefine viewer: [user, group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"viewer\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"viewer\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_direct_relationships_and_computed_usersets\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype document\n  relations\n\tdefine owner: [user, group#member]\n\tdefine viewer: owner`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"owner\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"owner\", \"user:bob\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"owner\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"success_with_many_tuples\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder5\", \"parent\", \"folder:folder4\"),\n\t\t\t\t\ttuple.NewTupleKey(\"folder:folder6\", \"viewer\", \"user:bob\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user, group#member]\n\ntype folder\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: [user, group#member] or viewer from parent\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder4\", \"viewer\", \"group:eng#member\"),\n\n\t\t\t\ttuple.NewTupleKey(\"document:doc1\", \"parent\", \"folder:folder3\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc2\", \"parent\", \"folder:folder5\"),\n\t\t\t\ttuple.NewTupleKey(\"document:doc3\", \"parent\", \"folder:folder6\"),\n\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:openfga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:openfga\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:doc2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"resolve_objects_involved_in_recursive_hierarchy\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: [user] or viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"folder:folder3\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"resolution_depth_exceeded_failure\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"folder\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tresolveNodeLimit: 2,\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: [user] or viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"folder:folder1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder2\", \"parent\", \"folder:folder1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:folder3\", \"parent\", \"folder:folder2\"),\n\t\t\t},\n\t\t\texpectedError:        graph.ErrResolutionDepthExceeded,\n\t\t\texpectedDSQueryCount: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user, group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:opensource\", \"member\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"group:iam#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:opensource\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:eng\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_to_a_userset_self_referencing\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"group\",\n\t\t\t\tRelation:   \"member\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:iam\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype group\n  relations\n\tdefine member: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:iam\", \"member\", \"group:iam#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"group:iam\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine owner: [user]\n\tdefine editor: owner\n\tdefine viewer: [document#editor]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#editor\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"owner\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine manager: [user]\n\tdefine member: manager\n\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"manager\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_through_a_computed_userset_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"trial\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"fede\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype team\n  relations\n\tdefine admin: [user]\n\tdefine member: admin\n\ntype trial\n  relations\n\tdefine editor: [team#member]\n\tdefine viewer: editor`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"trial:1\", \"editor\", \"team:devs#member\"),\n\t\t\t\ttuple.NewTupleKey(\"team:devs\", \"admin\", \"user:fede\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"trial:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"objects_connected_indirectly_through_a_ttu\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"view\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"organization\",\n\t\t\t\t\t\tId:   \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype organization\n  relations\n\tdefine viewer: [organization]\n\tdefine can_view: viewer\n\ntype document\n  relations\n\tdefine parent: [organization]\n\tdefine view: can_view from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"organization:1\"),\n\t\t\t\ttuple.NewTupleKey(\"organization:1\", \"viewer\", \"organization:2\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"directly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype document\n  relations\n\tdefine viewer: [user, user:*]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"indirectly_related_typed_wildcard\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype team\n  relations\n\tdefine member: [user]\ntype group\n  relations\n\tdefine member: [team#member]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"typed_wildcard_relationship_through_multiple_indirections\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [team#member]\ntype team\n  relations\n\tdefine member: [user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"team:tigers\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"team:tigers#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_direct_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user, user:*]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_and_indirect_relation\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"jon\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user, user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user:*]\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t\ttuple.NewTupleKey(\"group:other\", \"member\", \"employee:*\"), // assume this comes from a prior model\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"group:fga#member\"),\n\t\t\t\ttuple.NewTupleKey(\"document:3\", \"viewer\", \"group:other#member\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"with_public_user_access_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{\n\t\t\t\t\t\tType: \"user\",\n\t\t\t\t\t\tId:   \"bev\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype group\n  relations\n\tdefine member: [user]\ntype resource\n  relations\n\tdefine reader: [user, user:*, group#member] or writer\n\tdefine writer: [user, user:*, group#member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:x\", \"writer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:x\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{\n\t\t\t\t\tObject: &openfgav1.Object{Type: \"user\", Id: \"jon\"},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"user:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:jon\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype document\n  relations\n\tdefine viewer: [user, user:*]`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser:       &reverseexpand.UserRefTypedWildcard{Type: \"user\"},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"employee:*\"),\n\t\t\t\t\ttuple.NewTupleKey(\"document:2\", \"viewer\", \"user:*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype employee\ntype document\n  relations\n\tdefine viewer: [user:*]`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple_typed_wildcard_with_contextual_tuples_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObjectRelation{\n\t\t\t\t\tObjectRelation: &openfgav1.ObjectRelation{\n\t\t\t\t\t\tObject:   \"group:eng\",\n\t\t\t\t\t\tRelation: \"member\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tContextualTuples: []*openfgav1.TupleKey{\n\t\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype document\n  relations\n\tdefine viewer: [group#member]`,\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype folder\n  relations\n\tdefine viewer: [user, user:*]\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:2\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_without_wildcard_connectivity\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\ntype employee\n\ntype folder\n  relations\n\tdefine viewer: [user, employee:*]\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"document:2\", \"parent\", \"folder:2\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:2\", \"viewer\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_1\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user:*]\ntype folder\n  relations\n\tdefine viewer: [group#member]\n\ntype document\n  relations\n\tdefine parent: [folder]\n\tdefine viewer: viewer from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"parent\", \"folder:1\"),\n\t\t\t\ttuple.NewTupleKey(\"folder:1\", \"viewer\", \"group:eng#member\"),\n\t\t\t\ttuple.NewTupleKey(\"group:eng\", \"member\", \"user:*\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_2\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"writer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype org\n  relations\n\tdefine dept: [group]\n\tdefine dept_member: member from dept\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype resource\n  relations\n\tdefine writer: [org#dept_member]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-assignable_ttu_relationship_through_indirection_3\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"resource\",\n\t\t\t\tRelation:   \"reader\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"anne\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype org\n  relations\n\tdefine dept: [group]\n\tdefine dept_member: member from dept\n\ntype group\n  relations\n\tdefine member: [user]\n\ntype resource\n  relations\n\tdefine writer: [org#dept_member]\n\tdefine reader: [org#dept_member] or writer`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"resource:eng_handbook\", \"writer\", \"org:eng#dept_member\"),\n\t\t\t\ttuple.NewTupleKey(\"org:eng\", \"dept\", \"group:fga\"),\n\t\t\t\ttuple.NewTupleKey(\"group:fga\", \"member\", \"user:anne\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"resource:eng_handbook\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"cyclical_tupleset_relation_terminates\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"node\",\n\t\t\t\tRelation:   \"editor\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"wonder\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype node\n  relations\n\tdefine parent: [node]\n\tdefine editor: [user] or editor from parent`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"node:abc\", \"editor\", \"user:wonder\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"node:abc\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"does_not_send_duplicate_even_though_there_are_two_paths_to_same_solution\",\n\t\t\trequest: &reverseexpand.ReverseExpandRequest{\n\t\t\t\tStoreID:    ulid.Make().String(),\n\t\t\t\tObjectType: \"document\",\n\t\t\t\tRelation:   \"viewer\",\n\t\t\t\tUser: &reverseexpand.UserRefObject{Object: &openfgav1.Object{\n\t\t\t\t\tType: \"user\",\n\t\t\t\t\tId:   \"jon\",\n\t\t\t\t}},\n\t\t\t},\n\t\t\tmodel: `model\n\tschema 1.1\ntype user\n\ntype group\n  relations\n\tdefine member: [user]\n\tdefine maintainer: [user]\n\ntype document\n  relations\n\tdefine viewer: [group#member,group#maintainer]`,\n\t\t\ttuples: []*openfgav1.TupleKey{\n\t\t\t\ttuple.NewTupleKey(\"document:1\", \"viewer\", \"group:example1#maintainer\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"maintainer\", \"user:jon\"),\n\t\t\t\ttuple.NewTupleKey(\"group:example1\", \"member\", \"user:jon\"),\n\t\t\t},\n\t\t\texpectedResult: []*reverseexpand.ReverseExpandResult{\n\t\t\t\t{\n\t\t\t\t\tObject:       \"document:1\",\n\t\t\t\t\tResultStatus: reverseexpand.NoFurtherEvalStatus,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedDSQueryCount: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tctx := context.Background()\n\t\t\tstore := ulid.Make().String()\n\t\t\ttest.request.StoreID = store\n\n\t\t\tmodel := testutils.MustTransformDSLToProtoWithID(test.model)\n\t\t\terr := ds.WriteAuthorizationModel(ctx, store, model)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = ds.Write(ctx, store, nil, test.tuples)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tvar opts []reverseexpand.ReverseExpandQueryOption\n\n\t\t\tif test.resolveNodeLimit != 0 {\n\t\t\t\topts = append(opts, reverseexpand.WithResolveNodeLimit(test.resolveNodeLimit))\n\t\t\t}\n\n\t\t\treverseExpandQuery := reverseexpand.NewReverseExpandQuery(ds, typesystem.New(model), opts...)\n\n\t\t\tresultChan := make(chan *reverseexpand.ReverseExpandResult, 100)\n\n\t\t\ttimeoutCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\tresolutionMetadata := reverseexpand.NewResolutionMetadata()\n\n\t\t\treverseExpandErrCh := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\terr := reverseExpandQuery.Execute(timeoutCtx, test.request, resultChan, resolutionMetadata)\n\t\t\t\tif err != nil {\n\t\t\t\t\treverseExpandErrCh <- err\n\t\t\t\t\tt.Logf(\"sent err %s\", err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tvar results []*reverseexpand.ReverseExpandResult\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase err := <-reverseExpandErrCh:\n\t\t\t\t\trequire.ErrorIs(t, err, test.expectedError)\n\t\t\t\t\treturn\n\t\t\t\tcase res, channelOpen := <-resultChan:\n\t\t\t\t\tif !channelOpen {\n\t\t\t\t\t\tt.Log(\"channel closed\")\n\t\t\t\t\t\tif test.expectedError == nil {\n\t\t\t\t\t\t\trequire.ElementsMatch(t, test.expectedResult, results)\n\t\t\t\t\t\t\trequire.Equal(t, test.expectedDSQueryCount, *resolutionMetadata.QueryCount)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trequire.FailNow(t, \"expected an error, got none\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Logf(\"appending result %s\", res.Object)\n\t\t\t\t\t\tresults = append(results, res)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n", "package storage\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/go-connections/nat\"\n\t\"github.com/go-sql-driver/mysql\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/openfga/openfga/assets\"\n)\n\nconst (\n\tmySQLImage = \"mysql:8\"\n)\n\ntype mySQLTestContainer struct {\n\taddr     string\n\tversion  int64\n\tusername string\n\tpassword string\n}\n\n// NewMySQLTestContainer returns an implementation of the DatastoreTestContainer interface\n// for MySQL.\nfunc NewMySQLTestContainer() *mySQLTestContainer {\n\treturn &mySQLTestContainer{}\n}\n\nfunc (m *mySQLTestContainer) GetDatabaseSchemaVersion() int64 {\n\treturn m.version\n}\n\n// RunMySQLTestContainer runs a MySQL container, connects to it, and returns a\n// bootstrapped implementation of the DatastoreTestContainer interface wired up for the\n// MySQL datastore engine.\nfunc (m *mySQLTestContainer) RunMySQLTestContainer(t testing.TB) (DatastoreTestContainer, func()) {\n\tdockerClient, err := client.NewClientWithOpts(\n\t\tclient.FromEnv,\n\t\tclient.WithAPIVersionNegotiation(),\n\t)\n\trequire.NoError(t, err)\n\n\tallImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{\n\t\tAll: true,\n\t})\n\trequire.NoError(t, err)\n\n\tfoundMysqlImage := false\n\tfor _, image := range allImages {\n\t\tfor _, tag := range image.RepoTags {\n\t\t\tif strings.Contains(tag, mySQLImage) {\n\t\t\t\tfoundMysqlImage = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !foundMysqlImage {\n\t\tt.Logf(\"Pulling image %s\", mySQLImage)\n\t\treader, err := dockerClient.ImagePull(context.Background(), mySQLImage, types.ImagePullOptions{})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done\n\t\trequire.NoError(t, err)\n\t}\n\n\tcontainerCfg := container.Config{\n\t\tEnv: []string{\n\t\t\t\"MYSQL_DATABASE=defaultdb\",\n\t\t\t\"MYSQL_ROOT_PASSWORD=secret\",\n\t\t},\n\t\tExposedPorts: nat.PortSet{\n\t\t\tnat.Port(\"3306/tcp\"): {},\n\t\t},\n\t\tImage: mySQLImage,\n\t}\n\n\thostCfg := container.HostConfig{\n\t\tAutoRemove:      true,\n\t\tPublishAllPorts: true,\n\t\tTmpfs:           map[string]string{\"/var/lib/mysql\": \"\"},\n\t}\n\n\tname := fmt.Sprintf(\"mysql-%s\", ulid.Make().String())\n\n\tcont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)\n\trequire.NoError(t, err, \"failed to create mysql docker container\")\n\n\tstopContainer := func() {\n\t\tt.Logf(\"stopping container %s\", name)\n\t\ttimeoutSec := 5\n\n\t\terr := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})\n\t\tif err != nil && !client.IsErrNotFound(err) {\n\t\t\tt.Logf(\"failed to stop mysql container: %v\", err)\n\t\t}\n\n\t\tdockerClient.Close()\n\t\tt.Logf(\"stopped container %s\", name)\n\t}\n\n\terr = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to start mysql container: %v\", err)\n\t}\n\n\tcontainerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)\n\trequire.NoError(t, err)\n\n\tp, ok := containerJSON.NetworkSettings.Ports[\"3306/tcp\"]\n\tif !ok || len(p) == 0 {\n\t\tt.Fatalf(\"failed to get host port mapping from mysql container\")\n\t}\n\n\tmySQLTestContainer := &mySQLTestContainer{\n\t\taddr:     fmt.Sprintf(\"localhost:%s\", p[0].HostPort),\n\t\tusername: \"root\",\n\t\tpassword: \"secret\",\n\t}\n\n\turi := fmt.Sprintf(\"%s:%s@tcp(%s)/defaultdb?parseTime=true\", mySQLTestContainer.username, mySQLTestContainer.password, mySQLTestContainer.addr)\n\n\terr = mysql.SetLogger(log.New(io.Discard, \"\", 0))\n\trequire.NoError(t, err)\n\n\tgoose.SetLogger(goose.NopLogger())\n\n\tdb, err := goose.OpenDBWithDriver(\"mysql\", uri)\n\trequire.NoError(t, err)\n\tdefer db.Close()\n\n\tbackoffPolicy := backoff.NewExponentialBackOff()\n\tbackoffPolicy.MaxElapsedTime = 2 * time.Minute\n\terr = backoff.Retry(\n\t\tfunc() error {\n\t\t\treturn db.Ping()\n\t\t},\n\t\tbackoffPolicy,\n\t)\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to connect to mysql container: %v\", err)\n\t}\n\n\tgoose.SetBaseFS(assets.EmbedMigrations)\n\n\terr = goose.Up(db, assets.MySQLMigrationDir)\n\trequire.NoError(t, err)\n\tversion, err := goose.GetDBVersion(db)\n\trequire.NoError(t, err)\n\tmySQLTestContainer.version = version\n\n\treturn mySQLTestContainer, stopContainer\n}\n\n// GetConnectionURI returns the mysql connection uri for the running mysql test container.\nfunc (m *mySQLTestContainer) GetConnectionURI(includeCredentials bool) string {\n\tcreds := \"\"\n\tif includeCredentials {\n\t\tcreds = fmt.Sprintf(\"%s:%s@\", m.username, m.password)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t\"%stcp(%s)/%s?parseTime=true\",\n\t\tcreds,\n\t\tm.addr,\n\t\t\"defaultdb\",\n\t)\n}\n\nfunc (m *mySQLTestContainer) GetUsername() string {\n\treturn m.username\n}\n\nfunc (m *mySQLTestContainer) GetPassword() string {\n\treturn m.password\n}\n", "package storage\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/go-connections/nat\"\n\t_ \"github.com/jackc/pgx/v5/stdlib\"\n\t\"github.com/oklog/ulid/v2\"\n\t\"github.com/pressly/goose/v3\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/openfga/openfga/assets\"\n)\n\nconst (\n\tpostgresImage = \"postgres:14\"\n)\n\ntype postgresTestContainer struct {\n\taddr     string\n\tversion  int64\n\tusername string\n\tpassword string\n}\n\n// NewPostgresTestContainer returns an implementation of the DatastoreTestContainer interface\n// for Postgres.\nfunc NewPostgresTestContainer() *postgresTestContainer {\n\treturn &postgresTestContainer{}\n}\n\nfunc (p *postgresTestContainer) GetDatabaseSchemaVersion() int64 {\n\treturn p.version\n}\n\n// RunPostgresTestContainer runs a Postgres container, connects to it, and returns a\n// bootstrapped implementation of the DatastoreTestContainer interface wired up for the\n// Postgres datastore engine.\nfunc (p *postgresTestContainer) RunPostgresTestContainer(t testing.TB) (DatastoreTestContainer, func()) {\n\tdockerClient, err := client.NewClientWithOpts(\n\t\tclient.FromEnv,\n\t\tclient.WithAPIVersionNegotiation(),\n\t)\n\trequire.NoError(t, err)\n\n\tallImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{\n\t\tAll: true,\n\t})\n\trequire.NoError(t, err)\n\n\tfoundPostgresImage := false\n\tfor _, image := range allImages {\n\t\tfor _, tag := range image.RepoTags {\n\t\t\tif strings.Contains(tag, postgresImage) {\n\t\t\t\tfoundPostgresImage = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !foundPostgresImage {\n\t\tt.Logf(\"Pulling image %s\", postgresImage)\n\t\treader, err := dockerClient.ImagePull(context.Background(), postgresImage, types.ImagePullOptions{})\n\t\trequire.NoError(t, err)\n\n\t\t_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done\n\t\trequire.NoError(t, err)\n\t}\n\n\tcontainerCfg := container.Config{\n\t\tEnv: []string{\n\t\t\t\"POSTGRES_DB=defaultdb\",\n\t\t\t\"POSTGRES_PASSWORD=secret\",\n\t\t},\n\t\tExposedPorts: nat.PortSet{\n\t\t\tnat.Port(\"5432/tcp\"): {},\n\t\t},\n\t\tImage: postgresImage,\n\t}\n\n\thostCfg := container.HostConfig{\n\t\tAutoRemove:      true,\n\t\tPublishAllPorts: true,\n\t\tTmpfs:           map[string]string{\"/var/lib/postgresql/data\": \"\"},\n\t}\n\n\tname := fmt.Sprintf(\"postgres-%s\", ulid.Make().String())\n\n\tcont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)\n\trequire.NoError(t, err, \"failed to create postgres docker container\")\n\n\tstopContainer := func() {\n\t\tt.Logf(\"stopping container %s\", name)\n\t\ttimeoutSec := 5\n\n\t\terr := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})\n\t\tif err != nil && !client.IsErrNotFound(err) {\n\t\t\tt.Logf(\"failed to stop postgres container: %v\", err)\n\t\t}\n\n\t\tdockerClient.Close()\n\t\tt.Logf(\"stopped container %s\", name)\n\t}\n\n\terr = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to start postgres container: %v\", err)\n\t}\n\n\tcontainerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)\n\trequire.NoError(t, err)\n\n\tm, ok := containerJSON.NetworkSettings.Ports[\"5432/tcp\"]\n\tif !ok || len(m) == 0 {\n\t\tt.Fatalf(\"failed to get host port mapping from postgres container\")\n\t}\n\n\tpgTestContainer := &postgresTestContainer{\n\t\taddr:     fmt.Sprintf(\"localhost:%s\", m[0].HostPort),\n\t\tusername: \"postgres\",\n\t\tpassword: \"secret\",\n\t}\n\n\turi := fmt.Sprintf(\"postgres://%s:%s@%s/defaultdb?sslmode=disable\", pgTestContainer.username, pgTestContainer.password, pgTestContainer.addr)\n\n\tgoose.SetLogger(goose.NopLogger())\n\n\tdb, err := goose.OpenDBWithDriver(\"pgx\", uri)\n\trequire.NoError(t, err)\n\tdefer db.Close()\n\n\tbackoffPolicy := backoff.NewExponentialBackOff()\n\tbackoffPolicy.MaxElapsedTime = 30 * time.Second\n\terr = backoff.Retry(\n\t\tfunc() error {\n\t\t\treturn db.Ping()\n\t\t},\n\t\tbackoffPolicy,\n\t)\n\tif err != nil {\n\t\tstopContainer()\n\t\tt.Fatalf(\"failed to connect to postgres container: %v\", err)\n\t}\n\n\tgoose.SetBaseFS(assets.EmbedMigrations)\n\n\terr = goose.Up(db, assets.PostgresMigrationDir)\n\trequire.NoError(t, err)\n\n\tversion, err := goose.GetDBVersion(db)\n\trequire.NoError(t, err)\n\tpgTestContainer.version = version\n\n\treturn pgTestContainer, stopContainer\n}\n\n// GetConnectionURI returns the postgres connection uri for the running postgres test container.\nfunc (p *postgresTestContainer) GetConnectionURI(includeCredentials bool) string {\n\tcreds := \"\"\n\tif includeCredentials {\n\t\tcreds = fmt.Sprintf(\"%s:%s@\", p.username, p.password)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t\"postgres://%s%s/%s?sslmode=disable\",\n\t\tcreds,\n\t\tp.addr,\n\t\t\"defaultdb\",\n\t)\n}\n\nfunc (p *postgresTestContainer) GetUsername() string {\n\treturn p.username\n}\n\nfunc (p *postgresTestContainer) GetPassword() string {\n\treturn p.password\n}\n", "package listobjects\n\nimport (\n\t\"testing\"\n\n\topenfgav1 \"github.com/openfga/api/proto/openfga/v1\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/goleak\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/openfga/openfga/cmd/run\"\n\t\"github.com/openfga/openfga/tests\"\n)\n\nfunc TestListObjectsMemory(t *testing.T) {\n\ttestRunAll(t, \"memory\")\n}\n\nfunc TestListObjectsPostgres(t *testing.T) {\n\ttestRunAll(t, \"postgres\")\n}\n\nfunc TestListObjectsMySQL(t *testing.T) {\n\ttestRunAll(t, \"mysql\")\n}\n\nfunc testRunAll(t *testing.T, engine string) {\n\tdefer goleak.VerifyNone(t)\n\tcfg := run.MustDefaultConfigWithRandomPorts()\n\tcfg.Log.Level = \"error\"\n\tcfg.Datastore.Engine = engine\n\n\tcancel := tests.StartServer(t, cfg)\n\tdefer cancel()\n\n\tconn, err := grpc.Dial(cfg.GRPC.Addr,\n\t\tgrpc.WithBlock(),\n\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n\t)\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\tRunAllTests(t, openfgav1.NewOpenFGAServiceClient(conn))\n}\n"], "filenames": ["pkg/server/commands/list_objects.go", "pkg/server/commands/reverseexpand/reverse_expand.go", "pkg/server/commands/reverseexpand/reverse_expand_test.go", "pkg/server/server_test.go", "pkg/server/test/list_objects.go", "pkg/server/test/reverse_expand.go", "pkg/testfixtures/storage/mysql.go", "pkg/testfixtures/storage/postgres.go", "tests/listobjects/listobjects_test.go"], "buggy_code_start_loc": [150, 164, 18, 18, 523, 1218, 5, 139, 7], "buggy_code_end_loc": [461, 209, 221, 151, 528, 1275, 172, 165, 30], "fixing_code_start_loc": [151, 163, 19, 19, 523, 1217, 4, 140, 8], "fixing_code_end_loc": [459, 209, 355, 152, 538, 1274, 165, 162, 30], "type": "CWE-401", "message": "OpenFGA, an authorization/permission engine, is vulnerable to a denial of service attack in versions prior to 1.4.3. In some scenarios that depend on the model and tuples used, a call to `ListObjects` may not  release memory properly. So when a sufficiently high number of those calls are executed, the OpenFGA server can create an `out of memory` error and terminate. Version 1.4.3 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2024-23820", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-26T17:15:13.287", "lastModified": "2024-02-01T16:30:14.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenFGA, an authorization/permission engine, is vulnerable to a denial of service attack in versions prior to 1.4.3. In some scenarios that depend on the model and tuples used, a call to `ListObjects` may not  release memory properly. So when a sufficiently high number of those calls are executed, the OpenFGA server can create an `out of memory` error and terminate. Version 1.4.3 contains a patch for this issue."}, {"lang": "es", "value": "OpenFGA, un motor de autorizaci\u00f3n/permisos, es vulnerable a un ataque de denegaci\u00f3n de servicio en versiones anteriores a la 1.4.3. En algunos escenarios que dependen del modelo y las tuplas utilizadas, es posible que una llamada a `ListObjects` no libere memoria correctamente. Entonces, cuando se ejecuta una cantidad suficientemente alta de esas llamadas, el servidor OpenFGA puede crear un error de \"memoria insuficiente\" y finalizar. La versi\u00f3n 1.4.3 contiene un parche para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfga:openfga:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.3", "matchCriteriaId": "C2F9E0AB-95A2-438B-ABA0-67EECF03D0C7"}]}]}], "references": [{"url": "https://github.com/openfga/openfga/commit/908ac85c8b7769c8042cca31886df8db01976c39", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/openfga/openfga/releases/tag/v1.4.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/openfga/openfga/security/advisories/GHSA-rxpw-85vw-fx87", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openfga/openfga/commit/908ac85c8b7769c8042cca31886df8db01976c39"}}