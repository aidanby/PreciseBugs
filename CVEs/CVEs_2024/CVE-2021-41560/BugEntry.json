{"buggy_code": ["<?php\n/**\n * CATS\n * File Utility Library\n *\n * Copyright (C) 2005 - 2007 Cognizo Technologies, Inc.\n *\n *\n * The contents of this file are subject to the CATS Public License\n * Version 1.1a (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.catsone.com/.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the\n * License for the specific language governing rights and limitations\n * under the License.\n *\n * The Original Code is \"CATS Standard Edition\".\n *\n * The Initial Developer of the Original Code is Cognizo Technologies, Inc.\n * Portions created by the Initial Developer are Copyright (C) 2005 - 2007\n * (or from the year in which this file was created to the year 2007) by\n * Cognizo Technologies, Inc. All Rights Reserved.\n *\n *\n * @package    CATS\n * @subpackage Library\n * @copyright Copyright (C) 2005 - 2007 Cognizo Technologies, Inc.\n * @version    $Id: FileUtility.php 3752 2007-11-28 23:39:06Z andrew $\n */\n\ndefine('DOCUMENT_TYPE_UNKNOWN', 0);\ndefine('DOCUMENT_TYPE_PDF',     100);\ndefine('DOCUMENT_TYPE_DOC',     200);\ndefine('DOCUMENT_TYPE_RTF',     300);\ndefine('DOCUMENT_TYPE_DOCX',    400);\ndefine('DOCUMENT_TYPE_HTML',    500);\ndefine('DOCUMENT_TYPE_ODT',     600);\ndefine('DOCUMENT_TYPE_TEXT',    700);\n\n/**\n *\tFile Utility Library\n *\t@package    CATS\n *\t@subpackage Library\n */\nclass FileUtility\n{\n    /* Prevent this class from being instantiated. */\n    private function __construct() {}\n    private function __clone() {}\n\n\n    /**\n     * Returns a document type based on its file extension and content type.\n     *\n     * @param string Document file name with extension.\n     * @param string MIME content type.\n     * @return flag Document type flag.\n     */\n    public static function getDocumentType($filename, $contentType = false)\n    {\n        $fileExtension = self::getFileExtension($filename);\n\n        if ($contentType === 'text/plain' || $fileExtension == 'txt')\n        {\n            return DOCUMENT_TYPE_TEXT;\n        }\n\n        if ($contentType == 'application/rtf' || $contentType == 'text/rtf' ||\n            $contentType == 'text/richtext' || $fileExtension == 'rtf')\n        {\n            return DOCUMENT_TYPE_RTF;\n        }\n\n        if ($contentType == 'application/msword' || $fileExtension == 'doc')\n        {\n            return DOCUMENT_TYPE_DOC;\n        }\n\n        if ($contentType == 'application/vnd.ms-word.document.12' ||\n            $fileExtension == 'docx')\n        {\n            return DOCUMENT_TYPE_DOCX;\n        }\n\n        if ($contentType == 'application/pdf' || $fileExtension == 'pdf')\n        {\n            return DOCUMENT_TYPE_PDF;\n        }\n\n        if ($contentType === 'text/html' || $fileExtension == 'html' ||\n            $fileExtension == 'htm')\n        {\n            return DOCUMENT_TYPE_HTML;\n        }\n\n        if ($contentType === 'application/vnd.oasis.opendocument.text' ||\n            $contentType === 'application/x-vnd.oasis.opendocument.text' ||\n            $fileExtension == 'odt')\n        {\n            return DOCUMENT_TYPE_ODT;\n        }\n\n        return DOCUMENT_TYPE_UNKNOWN;\n    }\n\n    /**\n     * Recursively removes a directory tree.\n     *\n     * @param directory name\n     * @return true on success; false otherwise\n     */\n    public static function recursivelyRemoveDirectory($directoryName)\n    {\n        $exceptions = array('.', '..');\n\n        $directory = @opendir($directoryName);\n        if (!$directory)\n        {\n            return false;\n        }\n\n        while (($child = readdir($directory)) !== false)\n        {\n            if (in_array($child, $exceptions))\n            {\n                continue;\n            }\n\n            $object = str_replace('//', '/', $directoryName . '/' . $child);\n\n            if (is_dir($object))\n            {\n                recursivelyRemoveDirectory($object);\n            }\n            else if (is_file($object))\n            {\n                @unlink($object);\n            }\n        }\n\n        closedir($directory);\n\n        if (@rmdir($directoryName))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates a filename safe to store on the local filesystem. Non-ASCII\n     * characters will be stripped, directory names will be removed, and\n     * filenames with \"executable\" extensions will have \".txt\" appended.\n     *\n     * @param flag Data Item type flag.\n     * @param integer Data Item ID.\n     * @param string Name of HTTP POST file field.\n     * @param boolean Is this a profile image attachment?\n     * @param boolean Attempt to extract, store, and index the attachment's\n     *                text?\n     * @return string Safe filename.\n     */\n    public static function makeSafeFilename($filename)\n    {\n        /* Strip out *nix directories. */\n        $filenameParts = explode('/', $filename);\n        $filename = end($filenameParts);\n\n        /* Strip out Windows directories. */\n        $filenameParts = explode('\\\\', $filename);\n        $filename = end($filenameParts);\n\n        /* Strip out non-ASCII characters. */\n        for ($i = 0; $i < strlen($filename); $i++)\n        {\n            if (ord($filename[$i]) >= 128 || ord($filename[$i]) < 32)\n            {\n                $filename[$i] = '_';\n            }\n        }\n\n        /* Is the file extension safe? */\n        $fileExtension = self::getFileExtension($filename);\n        if (in_array($fileExtension, $GLOBALS['badFileExtensions']))\n        {\n            $filename .= '.txt';\n        }\n\n        return $filename;\n    }\n\n    /**\n     * Returns a unused filename in CATS_TEMP_DIR.\n     * // FIXME: Merge me with makeRandomFilename().\n     *\n     * @return string filename\n     */\n    public static function makeRandomTemporaryFilePath()\n    {\n        /* Even though the possibility of generating a filename that\n         * already exists is small, we need to handle it just in case.\n         */\n        do\n        {\n            $filePath = CATS_TEMP_DIR . '/' . FileUtility::makeRandomFilename();\n        }\n        while (file_exists($filePath));\n\n        return $filePath;\n    }\n\n    /**\n     * Gets a random unique directory name for storing an attachment. Note that\n     * this does NOT actually create the directory.\n     *\n     * @param string The parent directory in which the unique directory name\n     *               will be created.\n     * @param string Extra data to include in the MD5 hash.\n     * @return string Ranom unique 32-character directory name.\n     */\n    public static function getUniqueDirectory($basePath, $extraData = '')\n    {\n        if (!empty($basePath) && substr($basePath, -1, 1) != '/')\n        {\n            $basePath .= '/';\n        }\n\n        /* Even though the possibility of generating a directory name that\n         * already exists is small, we need to handle it just in case.\n         */\n        do\n        {\n            $md5 = md5(rand() . time() . $extraData);\n        }\n        while (file_exists($basePath . $md5));\n\n        return $md5;\n    }\n\n    /**\n     * Returns a random filename.\n     * // FIXME: Merge with makeRandomTemporaryFilePath().\n     *\n     * @return string filename\n     */\n    public static function makeRandomFilename($padding = '')\n    {\n        return md5($padding . time() . mt_rand()) . mt_rand(0, 9);\n    }\n\n    /**\n     * Returns true if directory is writable.\n     *\n     * @param string directory to test writability\n     * @return boolean directory writable\n     */\n    public static function isDirectoryWritable($directory)\n    {\n        if (substr($directory, -1, 1) != '/')\n        {\n            $directory .= '/';\n        }\n\n        /* Create temp file name. */\n        $path = $directory . self::makeRandomFilename() . '.tmp';\n\n        $file = @fopen($path, 'w+');\n        if (!$file)\n        {\n            return false;\n        }\n\n        fclose($file);\n\n        /* Try to delete the temp file. */\n        @unlink($path);\n\n        return true;\n    }\n\n    /**\n     * Returns the UNIX octal permissions string for a file (i.e., 0777).\n     *\n     * @param string path\n     * @return string octal permissions string\n     */\n    public static function getOctalPermissions($path)\n    {\n        return substr(sprintf('%o', fileperms($path)), -4);\n    }\n\n    /**\n     * Returns the proper title for a filename by removing the extension.\n     *\n     * @param string filename\n     * @return string title\n     */\n    public static function getFileWithoutExtension($filename,\n        $baseNameOnly = false)\n    {\n        if ($baseNameOnly)\n        {\n            $filename = basename($filename);\n        }\n\n        return substr($filename, 0, strrpos($filename, '.'));\n    }\n\n    /**\n     * Returns the file extension from a filename (in lowercase).\n     *\n     * @param string filename\n     * @return string extension\n     */\n    public static function getFileExtension($filename)\n    {\n        return strtolower(substr($filename, strrpos($filename, '.') + 1));\n    }\n\n    /**\n     * Returns the attachment icon filename for a given file\n     *\n     * @param string filename\n     * @return string attachment icon filename\n     */\n    public static function getAttachmentIcon($filename)\n    {\n        $fileExtension = strtolower(self::getFileExtension($filename));\n\n        //FIXME: need to handle more extension types\n        switch ($fileExtension)\n        {\n            case 'doc':\n                return 'images/file/doc.gif';\n                break;\n\n            case 'xls':\n                return 'images/file/xls.gif';\n                break;\n\n            case 'ppt':\n                return 'images/file/ppt.gif';\n                break;\n\n            case 'pdf':\n                return 'images/file/pdf.gif';\n                break;\n\n            case 'txt':\n                return 'images/file/txt.gif';\n                break;\n\n            case 'jpg':\n                return 'images/file/jpg.gif';\n                break;\n\n            case 'gif':\n                return 'images/file/gif.gif';\n                break;\n\n            case 'zip':\n                return 'images/file/zip.gif';\n                break;\n\n            default:\n                return 'images/attachment.gif';\n                break;\n        }\n    }\n\n    /**\n     * Returns an error message for a given error code.\n     *\n     * @param integer error code (check constants.php)\n     * @return string error message\n     */\n    public static function getErrorMessage($errorCode)\n    {\n        switch ($errorCode)\n        {\n            case UPLOAD_ERR_INI_SIZE:\n                return 'File size is greater than system-wide size limit.';\n                break;\n\n            case UPLOAD_ERR_FORM_SIZE:\n                return 'File size is greater than form size limit.';\n                break;\n\n            case UPLOAD_ERR_PARTIAL:\n                return 'File was only partially uploaded. Try again.';\n                break;\n\n            case UPLOAD_ERR_NO_FILE:\n                return 'No file was uploaded. Try again.';\n                break;\n\n            case UPLOAD_ERR_NO_TMP_DIR:\n                return 'No temporary directory exists. PHP is most likely '\n                    . 'configured incorrectly.';\n                break;\n\n            case UPLOAD_ERR_CANT_WRITE:\n                return 'Cannot write to directory.';\n                break;\n\n            default:\n                return 'An unknown error has occurred.';\n                break;\n        }\n    }\n\n    /**\n     * Returns a human-readable string representation of a file size, for\n     * example '2.3 MB'.\n     *\n     * @param integer file size in bytes\n     * @return string human-readable file size\n     */\n    public static function sizeToHuman($size, $round = 2, $skipUnits = 0)\n    {\n        $units = array('B', 'KB', 'MB', 'GB', 'TB', 'PB');\n        $unitIndex = 0;\n\n        /* Keep dividing the file size by 1024 as long as the number is >0.\n         * If we are skipping units, it's okay to have fractional sizes, so we\n         * keep dividing until we're supposed to stop skipping units.\n         */\n        while ((int) ($size / 1024) > 0 || $skipUnits > 0)\n        {\n            $size /= 1024;\n            ++$unitIndex;\n            --$skipUnits;\n        }\n\n        /* Do rounding if necessary. */\n        if ($round !== false)\n        {\n            $size = round($size, $round);\n        }\n\n        /* Return the unit description along with the unit we found. */\n        return $size . ' ' . $units[$unitIndex];\n    }\n\n    /**\n     * Get the path relative to the root directory to which all uploaded files\n     * should be moved (for the current user at the current site). For example,\n     * \"upload/200\". Does not return trailing forward slash. Returned directory\n     * will be created if it doesn't exist with full-write permissions set.\n     *\n     * @param integer ID of the site the data is restricted to\n     * @param string a subdirectory of their upload folder (if necessary)\n     * @return string Upload directory path (relative to root directory).\n     */\n    public static function getUploadPath($siteID, $subDirectory = '')\n    {\n        $uploadPath = sprintf('upload%s',\n            !empty($subDirectory) ? '/' . $subDirectory : ''\n        );\n\n        if (!eval(Hooks::get('FILE_UTILITY_UPLOAD_PATH'))) return;\n\n        // Create the directory (recursively) if it doesn't exist\n        if (!@file_exists($uploadPath))\n        {\n            if (@mkdir($uploadPath, 0777, true) === false)\n            {\n                return false;\n            }\n        }\n\n        // Make sure it's writeable\n        if (@is_writable($uploadPath) === false)\n        {\n            @chmod($uploadPath, 0777);\n            if (@is_writable($uploadPath) === false) return false;\n        }\n\n        return $uploadPath;\n    }\n\n    /**\n     * Checks whether a given file is safe to view, edit, delete, that it exists, and\n     * that it is contained in a path restricted by FileUtility::getUploadPath()\n     *\n     * @param integer ID of the site\n     * @param string subdirectory (if necessary)\n     * @param string name of the file to be checked\n     * @return boolean true or false\n     */\n    public static function isUploadFileSafe($siteID, $subDirectory, $fileName)\n    {\n        if (($uploadPath = FileUtility::getUploadPath($siteID, $subDirectory)) === false)\n        {\n            // site has no upload path, by definition it is not safe\n            return false;\n        }\n\n        // Prevent uprooting\n        $fileName = str_replace('..', '', $fileName);\n\n        if (strcasecmp(substr($fileName, 0, strlen($uploadPath)), $uploadPath))\n        {\n            // Base of the filename doesn't match the upload path, it is not safe\n            return false;\n        }\n\n        if (!@file_exists($fileName) || !@is_writable($fileName))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * This function will translate a file name into the relative path\n     * to access the file (if it exists and it is considered safe).\n     *\n     * @param integer ID of the site containing the file\n     * @param string Optional sub-directory, use blank string for root\n     * @param string Full filesystem path to the file or boolean false\n     */\n    public static function getUploadFilePath($siteID, $subDirectory, $uploadFileName)\n    {\n        if (($uploadPath = self::getUploadPath($siteID, $subDirectory)) === false)\n        {\n            return false;\n        }\n\n        $filePath = sprintf('%s/%s', $uploadPath, $uploadFileName);\n\n        if (!self::isUploadFileSafe($siteID, $subDirectory, $filePath))\n        {\n            return false;\n        }\n\n        return $filePath;\n    }\n\n    /**\n     * Store the contents of a file upload in the site's upload directory with an\n     * optional sub-directory and return the name of the file (not including path).\n     *\n     * @param integer ID of the site containing the file\n     * @param string Optional sub-directory to place the file\n     * @param string Index of the $_FILES array (name from the <input> tag)\n     * @return string Complete name of the file (not including path)\n     */\n    public static function getUploadFileFromPost($siteID, $subDirectory, $id)\n    {\n        if (isset($_FILES[$id]))\n        {\n            if (!@file_exists($_FILES[$id]['tmp_name']))\n            {\n                // File was removed, accessed from another window, or no longer exists\n                return false;\n            }\n\n            if (!eval(Hooks::get('FILE_UTILITY_SPACE_CHECK'))) return;\n\n            $uploadPath = FileUtility::getUploadPath($siteID, $subDirectory);\n            $newFileName = $_FILES[$id]['name'];\n\n            // Could just while(file_exists) it, but I'm paranoid of infinate loops\n            // Shouldn't have 1000 files of the same name anyway\n            for ($i = 0; @file_exists($uploadPath . '/' . $newFileName) && $i < 1000; $i++)\n            {\n                $mp = explode('.', $newFileName);\n                $fileNameBase = implode('.', array_slice($mp, 0, count($mp)-1));\n                $fileNameExt = $mp[count($mp)-1];\n\n                if (preg_match('/(.*)_Copy([0-9]{1,3})$/', $fileNameBase, $matches))\n                {\n                    // Copy already appending, increase the #\n                    $fileNameBase = sprintf('%s_Copy%d', $matches[1], intval($matches[2]) + 1);\n                }\n                else\n                {\n                    $fileNameBase .= '_Copy1';\n                }\n\n                $newFileName = $fileNameBase . '.' . $fileNameExt;\n            }\n\n            if (@move_uploaded_file($_FILES[$id]['tmp_name'], $uploadPath . '/' . $newFileName) &&\n                @chmod($uploadPath . '/' . $newFileName, 0777))\n            {\n                return $newFileName;\n            }\n        }\n\n        return false;\n    }\n}\n\n?>\n"], "fixing_code": ["<?php\n/**\n * CATS\n * File Utility Library\n *\n * Copyright (C) 2005 - 2007 Cognizo Technologies, Inc.\n *\n *\n * The contents of this file are subject to the CATS Public License\n * Version 1.1a (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.catsone.com/.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the\n * License for the specific language governing rights and limitations\n * under the License.\n *\n * The Original Code is \"CATS Standard Edition\".\n *\n * The Initial Developer of the Original Code is Cognizo Technologies, Inc.\n * Portions created by the Initial Developer are Copyright (C) 2005 - 2007\n * (or from the year in which this file was created to the year 2007) by\n * Cognizo Technologies, Inc. All Rights Reserved.\n *\n *\n * @package    CATS\n * @subpackage Library\n * @copyright Copyright (C) 2005 - 2007 Cognizo Technologies, Inc.\n * @version    $Id: FileUtility.php 3752 2007-11-28 23:39:06Z andrew $\n */\n\ndefine('DOCUMENT_TYPE_UNKNOWN', 0);\ndefine('DOCUMENT_TYPE_PDF',     100);\ndefine('DOCUMENT_TYPE_DOC',     200);\ndefine('DOCUMENT_TYPE_RTF',     300);\ndefine('DOCUMENT_TYPE_DOCX',    400);\ndefine('DOCUMENT_TYPE_HTML',    500);\ndefine('DOCUMENT_TYPE_ODT',     600);\ndefine('DOCUMENT_TYPE_TEXT',    700);\n\n/**\n *\tFile Utility Library\n *\t@package    CATS\n *\t@subpackage Library\n */\nclass FileUtility\n{\n    /* Prevent this class from being instantiated. */\n    private function __construct() {}\n    private function __clone() {}\n\n\n    /**\n     * Returns a document type based on its file extension and content type.\n     *\n     * @param string Document file name with extension.\n     * @param string MIME content type.\n     * @return flag Document type flag.\n     */\n    public static function getDocumentType($filename, $contentType = false)\n    {\n        $fileExtension = self::getFileExtension($filename);\n\n        if ($contentType === 'text/plain' || $fileExtension == 'txt')\n        {\n            return DOCUMENT_TYPE_TEXT;\n        }\n\n        if ($contentType == 'application/rtf' || $contentType == 'text/rtf' ||\n            $contentType == 'text/richtext' || $fileExtension == 'rtf')\n        {\n            return DOCUMENT_TYPE_RTF;\n        }\n\n        if ($contentType == 'application/msword' || $fileExtension == 'doc')\n        {\n            return DOCUMENT_TYPE_DOC;\n        }\n\n        if ($contentType == 'application/vnd.ms-word.document.12' ||\n            $fileExtension == 'docx')\n        {\n            return DOCUMENT_TYPE_DOCX;\n        }\n\n        if ($contentType == 'application/pdf' || $fileExtension == 'pdf')\n        {\n            return DOCUMENT_TYPE_PDF;\n        }\n\n        if ($contentType === 'text/html' || $fileExtension == 'html' ||\n            $fileExtension == 'htm')\n        {\n            return DOCUMENT_TYPE_HTML;\n        }\n\n        if ($contentType === 'application/vnd.oasis.opendocument.text' ||\n            $contentType === 'application/x-vnd.oasis.opendocument.text' ||\n            $fileExtension == 'odt')\n        {\n            return DOCUMENT_TYPE_ODT;\n        }\n\n        return DOCUMENT_TYPE_UNKNOWN;\n    }\n\n    /**\n     * Recursively removes a directory tree.\n     *\n     * @param directory name\n     * @return true on success; false otherwise\n     */\n    public static function recursivelyRemoveDirectory($directoryName)\n    {\n        $exceptions = array('.', '..');\n\n        $directory = @opendir($directoryName);\n        if (!$directory)\n        {\n            return false;\n        }\n\n        while (($child = readdir($directory)) !== false)\n        {\n            if (in_array($child, $exceptions))\n            {\n                continue;\n            }\n\n            $object = str_replace('//', '/', $directoryName . '/' . $child);\n\n            if (is_dir($object))\n            {\n                recursivelyRemoveDirectory($object);\n            }\n            else if (is_file($object))\n            {\n                @unlink($object);\n            }\n        }\n\n        closedir($directory);\n\n        if (@rmdir($directoryName))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates a filename safe to store on the local filesystem. Non-ASCII\n     * characters will be stripped, directory names will be removed, and\n     * filenames with \"executable\" extensions will have \".txt\" appended.\n     *\n     * @param flag Data Item type flag.\n     * @param integer Data Item ID.\n     * @param string Name of HTTP POST file field.\n     * @param boolean Is this a profile image attachment?\n     * @param boolean Attempt to extract, store, and index the attachment's\n     *                text?\n     * @return string Safe filename.\n     */\n    public static function makeSafeFilename($filename)\n    {\n        /* Strip out *nix directories. */\n        $filenameParts = explode('/', $filename);\n        $filename = end($filenameParts);\n\n        /* Strip out Windows directories. */\n        $filenameParts = explode('\\\\', $filename);\n        $filename = end($filenameParts);\n\n        /* Strip out non-ASCII characters. */\n        for ($i = 0; $i < strlen($filename); $i++)\n        {\n            if (ord($filename[$i]) >= 128 || ord($filename[$i]) < 32)\n            {\n                $filename[$i] = '_';\n            }\n        }\n\n        /* Is the file extension safe? */\n        $fileExtension = self::getFileExtension($filename);\n        \n        /* Use a whitelist instead of a blacklist to prevent possible bypasses */\n        if (!preg_match(\"/(?i)\\.(pdf|docx?|rtf|odt?g?|txt|wpd|jpe?g|png|csv|xlsx?|ppt|msg|heic|tiff?|html?|bmp|wps|xps)$/i\", $fileExtension))\n        {\n            $filename .= \".txt\";\n        }\n/*        if (in_array($fileExtension, $GLOBALS['badFileExtensions']))\n        {\n            $filename .= '.txt';\n        }\n*/\n        return $filename;\n    }\n\n    /**\n     * Returns a unused filename in CATS_TEMP_DIR.\n     * // FIXME: Merge me with makeRandomFilename().\n     *\n     * @return string filename\n     */\n    public static function makeRandomTemporaryFilePath()\n    {\n        /* Even though the possibility of generating a filename that\n         * already exists is small, we need to handle it just in case.\n         */\n        do\n        {\n            $filePath = CATS_TEMP_DIR . '/' . FileUtility::makeRandomFilename();\n        }\n        while (file_exists($filePath));\n\n        return $filePath;\n    }\n\n    /**\n     * Gets a random unique directory name for storing an attachment. Note that\n     * this does NOT actually create the directory.\n     *\n     * @param string The parent directory in which the unique directory name\n     *               will be created.\n     * @param string Extra data to include in the MD5 hash.\n     * @return string Ranom unique 32-character directory name.\n     */\n    public static function getUniqueDirectory($basePath, $extraData = '')\n    {\n        if (!empty($basePath) && substr($basePath, -1, 1) != '/')\n        {\n            $basePath .= '/';\n        }\n\n        /* Even though the possibility of generating a directory name that\n         * already exists is small, we need to handle it just in case.\n         */\n        do\n        {\n            $md5 = md5(rand() . time() . $extraData);\n        }\n        while (file_exists($basePath . $md5));\n\n        return $md5;\n    }\n\n    /**\n     * Returns a random filename.\n     * // FIXME: Merge with makeRandomTemporaryFilePath().\n     *\n     * @return string filename\n     */\n    public static function makeRandomFilename($padding = '')\n    {\n        return md5($padding . time() . mt_rand()) . mt_rand(0, 9);\n    }\n\n    /**\n     * Returns true if directory is writable.\n     *\n     * @param string directory to test writability\n     * @return boolean directory writable\n     */\n    public static function isDirectoryWritable($directory)\n    {\n        if (substr($directory, -1, 1) != '/')\n        {\n            $directory .= '/';\n        }\n\n        /* Create temp file name. */\n        $path = $directory . self::makeRandomFilename() . '.tmp';\n\n        $file = @fopen($path, 'w+');\n        if (!$file)\n        {\n            return false;\n        }\n\n        fclose($file);\n\n        /* Try to delete the temp file. */\n        @unlink($path);\n\n        return true;\n    }\n\n    /**\n     * Returns the UNIX octal permissions string for a file (i.e., 0777).\n     *\n     * @param string path\n     * @return string octal permissions string\n     */\n    public static function getOctalPermissions($path)\n    {\n        return substr(sprintf('%o', fileperms($path)), -4);\n    }\n\n    /**\n     * Returns the proper title for a filename by removing the extension.\n     *\n     * @param string filename\n     * @return string title\n     */\n    public static function getFileWithoutExtension($filename,\n        $baseNameOnly = false)\n    {\n        if ($baseNameOnly)\n        {\n            $filename = basename($filename);\n        }\n\n        return substr($filename, 0, strrpos($filename, '.'));\n    }\n\n    /**\n     * Returns the file extension from a filename (in lowercase).\n     *\n     * @param string filename\n     * @return string extension\n     */\n    public static function getFileExtension($filename)\n    {\n        return strtolower(substr($filename, strrpos($filename, '.') + 1));\n    }\n\n    /**\n     * Returns the attachment icon filename for a given file\n     *\n     * @param string filename\n     * @return string attachment icon filename\n     */\n    public static function getAttachmentIcon($filename)\n    {\n        $fileExtension = strtolower(self::getFileExtension($filename));\n\n        //FIXME: need to handle more extension types\n        switch ($fileExtension)\n        {\n            case 'doc':\n                return 'images/file/doc.gif';\n                break;\n\n            case 'xls':\n                return 'images/file/xls.gif';\n                break;\n\n            case 'ppt':\n                return 'images/file/ppt.gif';\n                break;\n\n            case 'pdf':\n                return 'images/file/pdf.gif';\n                break;\n\n            case 'txt':\n                return 'images/file/txt.gif';\n                break;\n\n            case 'jpg':\n                return 'images/file/jpg.gif';\n                break;\n\n            case 'gif':\n                return 'images/file/gif.gif';\n                break;\n\n            case 'zip':\n                return 'images/file/zip.gif';\n                break;\n\n            default:\n                return 'images/attachment.gif';\n                break;\n        }\n    }\n\n    /**\n     * Returns an error message for a given error code.\n     *\n     * @param integer error code (check constants.php)\n     * @return string error message\n     */\n    public static function getErrorMessage($errorCode)\n    {\n        switch ($errorCode)\n        {\n            case UPLOAD_ERR_INI_SIZE:\n                return 'File size is greater than system-wide size limit.';\n                break;\n\n            case UPLOAD_ERR_FORM_SIZE:\n                return 'File size is greater than form size limit.';\n                break;\n\n            case UPLOAD_ERR_PARTIAL:\n                return 'File was only partially uploaded. Try again.';\n                break;\n\n            case UPLOAD_ERR_NO_FILE:\n                return 'No file was uploaded. Try again.';\n                break;\n\n            case UPLOAD_ERR_NO_TMP_DIR:\n                return 'No temporary directory exists. PHP is most likely '\n                    . 'configured incorrectly.';\n                break;\n\n            case UPLOAD_ERR_CANT_WRITE:\n                return 'Cannot write to directory.';\n                break;\n\n            default:\n                return 'An unknown error has occurred.';\n                break;\n        }\n    }\n\n    /**\n     * Returns a human-readable string representation of a file size, for\n     * example '2.3 MB'.\n     *\n     * @param integer file size in bytes\n     * @return string human-readable file size\n     */\n    public static function sizeToHuman($size, $round = 2, $skipUnits = 0)\n    {\n        $units = array('B', 'KB', 'MB', 'GB', 'TB', 'PB');\n        $unitIndex = 0;\n\n        /* Keep dividing the file size by 1024 as long as the number is >0.\n         * If we are skipping units, it's okay to have fractional sizes, so we\n         * keep dividing until we're supposed to stop skipping units.\n         */\n        while ((int) ($size / 1024) > 0 || $skipUnits > 0)\n        {\n            $size /= 1024;\n            ++$unitIndex;\n            --$skipUnits;\n        }\n\n        /* Do rounding if necessary. */\n        if ($round !== false)\n        {\n            $size = round($size, $round);\n        }\n\n        /* Return the unit description along with the unit we found. */\n        return $size . ' ' . $units[$unitIndex];\n    }\n\n    /**\n     * Get the path relative to the root directory to which all uploaded files\n     * should be moved (for the current user at the current site). For example,\n     * \"upload/200\". Does not return trailing forward slash. Returned directory\n     * will be created if it doesn't exist with full-write permissions set.\n     *\n     * @param integer ID of the site the data is restricted to\n     * @param string a subdirectory of their upload folder (if necessary)\n     * @return string Upload directory path (relative to root directory).\n     */\n    public static function getUploadPath($siteID, $subDirectory = '')\n    {\n        $uploadPath = sprintf('upload%s',\n            !empty($subDirectory) ? '/' . $subDirectory : ''\n        );\n\n        if (!eval(Hooks::get('FILE_UTILITY_UPLOAD_PATH'))) return;\n\n        // Create the directory (recursively) if it doesn't exist\n        if (!@file_exists($uploadPath))\n        {\n            if (@mkdir($uploadPath, 0777, true) === false)\n            {\n                return false;\n            }\n        }\n\n        // Make sure it's writeable\n        if (@is_writable($uploadPath) === false)\n        {\n            @chmod($uploadPath, 0777);\n            if (@is_writable($uploadPath) === false) return false;\n        }\n\n        return $uploadPath;\n    }\n\n    /**\n     * Checks whether a given file is safe to view, edit, delete, that it exists, and\n     * that it is contained in a path restricted by FileUtility::getUploadPath()\n     *\n     * @param integer ID of the site\n     * @param string subdirectory (if necessary)\n     * @param string name of the file to be checked\n     * @return boolean true or false\n     */\n    public static function isUploadFileSafe($siteID, $subDirectory, $fileName)\n    {\n        if (($uploadPath = FileUtility::getUploadPath($siteID, $subDirectory)) === false)\n        {\n            // site has no upload path, by definition it is not safe\n            return false;\n        }\n\n        // Prevent uprooting\n        $fileName = str_replace('..', '', $fileName);\n\n        if (strcasecmp(substr($fileName, 0, strlen($uploadPath)), $uploadPath))\n        {\n            // Base of the filename doesn't match the upload path, it is not safe\n            return false;\n        }\n\n        if (!@file_exists($fileName) || !@is_writable($fileName))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * This function will translate a file name into the relative path\n     * to access the file (if it exists and it is considered safe).\n     *\n     * @param integer ID of the site containing the file\n     * @param string Optional sub-directory, use blank string for root\n     * @param string Full filesystem path to the file or boolean false\n     */\n    public static function getUploadFilePath($siteID, $subDirectory, $uploadFileName)\n    {\n        if (($uploadPath = self::getUploadPath($siteID, $subDirectory)) === false)\n        {\n            return false;\n        }\n\n        $filePath = sprintf('%s/%s', $uploadPath, $uploadFileName);\n\n        if (!self::isUploadFileSafe($siteID, $subDirectory, $filePath))\n        {\n            return false;\n        }\n\n        return $filePath;\n    }\n\n    /**\n     * Store the contents of a file upload in the site's upload directory with an\n     * optional sub-directory and return the name of the file (not including path).\n     *\n     * @param integer ID of the site containing the file\n     * @param string Optional sub-directory to place the file\n     * @param string Index of the $_FILES array (name from the <input> tag)\n     * @return string Complete name of the file (not including path)\n     */\n    public static function getUploadFileFromPost($siteID, $subDirectory, $id)\n    {\n        if (isset($_FILES[$id]))\n        {\n            if (!@file_exists($_FILES[$id]['tmp_name']))\n            {\n                // File was removed, accessed from another window, or no longer exists\n                return false;\n            }\n\n            if (!eval(Hooks::get('FILE_UTILITY_SPACE_CHECK'))) return;\n\n            $uploadPath = FileUtility::getUploadPath($siteID, $subDirectory);\n            $newFileName = FileUtility::makeSafeFilename($_FILES[$id]['name']);\n\n            // Could just while(file_exists) it, but I'm paranoid of infinate loops\n            // Shouldn't have 1000 files of the same name anyway\n            for ($i = 0; @file_exists($uploadPath . '/' . $newFileName) && $i < 1000; $i++)\n            {\n                $mp = explode('.', $newFileName);\n                $fileNameBase = implode('.', array_slice($mp, 0, count($mp)-1));\n                $fileNameExt = $mp[count($mp)-1];\n\n                if (preg_match('/(.*)_Copy([0-9]{1,3})$/', $fileNameBase, $matches))\n                {\n                    // Copy already appending, increase the #\n                    $fileNameBase = sprintf('%s_Copy%d', $matches[1], intval($matches[2]) + 1);\n                }\n                else\n                {\n                    $fileNameBase .= '_Copy1';\n                }\n\n                $newFileName = $fileNameBase . '.' . $fileNameExt;\n            }\n\n            if (@move_uploaded_file($_FILES[$id]['tmp_name'], $uploadPath . '/' . $newFileName) &&\n                @chmod($uploadPath . '/' . $newFileName, 0777))\n            {\n                return $newFileName;\n            }\n        }\n\n        return false;\n    }\n}\n\n?>\n"], "filenames": ["lib/FileUtility.php"], "buggy_code_start_loc": [187], "buggy_code_end_loc": [567], "fixing_code_start_loc": [187], "fixing_code_end_loc": [573], "type": "CWE-434", "message": "OpenCATS through 0.9.6 allows remote attackers to execute arbitrary code by uploading an executable file via lib/FileUtility.php.", "other": {"cve": {"id": "CVE-2021-41560", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-15T07:15:07.317", "lastModified": "2021-12-17T16:35:38.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenCATS through 0.9.6 allows remote attackers to execute arbitrary code by uploading an executable file via lib/FileUtility.php."}, {"lang": "es", "value": "OpenCATS versiones hasta 0.9.6, permite a atacantes remotos ejecutar c\u00f3digo arbitrario al subir un archivo ejecutable por medio del archivo lib/FileUtility.php"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opencats:opencats:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.6", "matchCriteriaId": "D94BB80B-674C-432A-BB40-6EAEF7D23A7F"}]}]}], "references": [{"url": "https://github.com/Nickguitar/RevCAT", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencats/OpenCATS/commit/b1af3bde1f68bec1c703ad66a3e390f15ed8ebe1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://youtu.be/isiDISag7CM", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencats/OpenCATS/commit/b1af3bde1f68bec1c703ad66a3e390f15ed8ebe1"}}