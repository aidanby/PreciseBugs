{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Codec\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <freerdp/config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/color.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_encode.h\"\n\n#include \"nsc_sse2.h\"\n\n#include <freerdp/log.h>\n#define TAG FREERDP_TAG(\"codec.nsc\")\n\n#ifndef NSC_INIT_SIMD\n#define NSC_INIT_SIMD(_nsc_context) \\\n\tdo                              \\\n\t{                               \\\n\t} while (0)\n#endif\n\nstatic BOOL nsc_decode(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE shift;\n\tBYTE* bmpdata;\n\tsize_t pos = 0;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\trw = ROUND_UP_TO(context->width, 8);\n\tshift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n\tbmpdata = context->BitmapData;\n\n\tif (!bmpdata)\n\t\treturn FALSE;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tconst BYTE* yplane;\n\t\tconst BYTE* coplane;\n\t\tconst BYTE* cgplane;\n\t\tconst BYTE* aplane = context->priv->PlaneBuffers[3] + y * context->width; /* A */\n\n\t\tif (context->ChromaSubsamplingLevel)\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * rw;                /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + (y >> 1) * (rw >> 1); /* Co, supersampled */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + (y >> 1) * (rw >> 1); /* Cg, supersampled */\n\t\t}\n\t\telse\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * context->width;  /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + y * context->width; /* Co */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + y * context->width; /* Cg */\n\t\t}\n\n\t\tfor (x = 0; x < context->width; x++)\n\t\t{\n\t\t\tINT16 y_val = (INT16)*yplane;\n\t\t\tINT16 co_val = (INT16)(INT8)(*coplane << shift);\n\t\t\tINT16 cg_val = (INT16)(INT8)(*cgplane << shift);\n\t\t\tINT16 r_val = y_val + co_val - cg_val;\n\t\t\tINT16 g_val = y_val + cg_val;\n\t\t\tINT16 b_val = y_val - co_val - cg_val;\n\n\t\t\tif (pos + 4 > context->BitmapDataLength)\n\t\t\t\treturn FALSE;\n\n\t\t\tpos += 4;\n\t\t\t*bmpdata++ = MINMAX(b_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(g_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(r_val, 0, 0xFF);\n\t\t\t*bmpdata++ = *aplane;\n\t\t\typlane++;\n\t\t\tcoplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\tcgplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\taplane++;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 left = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tconst BYTE value = *in++;\n\t\tUINT32 len = 0;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32)*in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = ((UINT32)(*in++));\n\t\t\t\tlen |= ((UINT32)(*in++)) << 8U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 16U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 24U;\n\t\t\t}\n\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}\n\nstatic BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\n\t\trle += planeSize;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\n\tStream_Read_UINT8(s, context->ColorLossLevel);         /* ColorLossLevel (1 byte) */\n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Seek(s, 2);                                     /* Reserved (2 bytes) */\n\tcontext->Planes = Stream_Pointer(s);\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}\n\nstatic BOOL nsc_context_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tif (!nsc_stream_initialize(context, s))\n\t\treturn FALSE;\n\n\tconst size_t blength = context->width * context->height * 4ull;\n\n\tif (!context->BitmapData || (blength > context->BitmapDataLength))\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->BitmapData, blength + 16, sizeof(BYTE), 32);\n\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\n\t\tcontext->BitmapData = tmp;\n\t\tcontext->BitmapDataLength = blength;\n\t}\n\n\tconst UINT32 tempWidth = ROUND_UP_TO(context->width, 8);\n\tconst UINT32 tempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tconst size_t plength = 1ull * tempWidth * tempHeight;\n\n\tif (plength > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (size_t i = 0; i < 4; i++)\n\t\t{\n\t\t\tvoid* tmp = (BYTE*)winpr_aligned_recalloc(context->priv->PlaneBuffers[i], plength,\n\t\t\t                                          sizeof(BYTE), 32);\n\n\t\t\tif (!tmp)\n\t\t\t\treturn FALSE;\n\n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = plength;\n\t}\n\n\tfor (size_t i = 0; i < 4; i++)\n\t\tcontext->OrgByteCount[i] = context->width * context->height;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = (tempWidth >> 1) * (tempHeight >> 1);\n\t\tcontext->OrgByteCount[2] = context->OrgByteCount[1];\n\t}\n\n\treturn TRUE;\n}\n\nstatic void nsc_profiler_print(NSC_CONTEXT_PRIV* priv)\n{\n\tWINPR_UNUSED(priv);\n\n\tPROFILER_PRINT_HEADER\n\tPROFILER_PRINT(priv->prof_nsc_rle_decompress_data)\n\tPROFILER_PRINT(priv->prof_nsc_decode)\n\tPROFILER_PRINT(priv->prof_nsc_rle_compress_data)\n\tPROFILER_PRINT(priv->prof_nsc_encode)\n\tPROFILER_PRINT_FOOTER\n}\n\nBOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tif ((width > UINT16_MAX) || (height > UINT16_MAX))\n\t\treturn FALSE;\n\n\tcontext->width = (UINT16)width;\n\tcontext->height = (UINT16)height;\n\treturn TRUE;\n}\n\nNSC_CONTEXT* nsc_context_new(void)\n{\n\tNSC_CONTEXT* context = (NSC_CONTEXT*)winpr_aligned_calloc(1, sizeof(NSC_CONTEXT), 32);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->priv = (NSC_CONTEXT_PRIV*)winpr_aligned_calloc(1, sizeof(NSC_CONTEXT_PRIV), 32);\n\n\tif (!context->priv)\n\t\tgoto error;\n\n\tcontext->priv->log = WLog_Get(\"com.freerdp.codec.nsc\");\n\tWLog_OpenAppender(context->priv->log);\n\tcontext->BitmapData = NULL;\n\tcontext->decode = nsc_decode;\n\tcontext->encode = nsc_encode;\n\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_decompress_data, \"nsc_rle_decompress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_decode, \"nsc_decode\")\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_compress_data, \"nsc_rle_compress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_encode, \"nsc_encode\")\n\t/* Default encoding parameters */\n\tcontext->ColorLossLevel = 3;\n\tcontext->ChromaSubsamplingLevel = 1;\n\t/* init optimized methods */\n\tNSC_INIT_SIMD(context);\n\treturn context;\nerror:\n\tnsc_context_free(context);\n\treturn NULL;\n}\n\nvoid nsc_context_free(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn;\n\n\tif (context->priv)\n\t{\n\t\tfor (size_t i = 0; i < 5; i++)\n\t\t\twinpr_aligned_free(context->priv->PlaneBuffers[i]);\n\n\t\tnsc_profiler_print(context->priv);\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_decompress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_decode)\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_compress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_encode)\n\t\twinpr_aligned_free(context->priv);\n\t}\n\n\twinpr_aligned_free(context->BitmapData);\n\twinpr_aligned_free(context);\n}\n\n#if defined(WITH_FREERDP_DEPRECATED)\nBOOL nsc_context_set_pixel_format(NSC_CONTEXT* context, UINT32 pixel_format)\n{\n\treturn nsc_context_set_parameters(context, NSC_COLOR_FORMAT, pixel_format);\n}\n#endif\n\nBOOL nsc_context_set_parameters(NSC_CONTEXT* context, NSC_PARAMETER what, UINT32 value)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tswitch (what)\n\t{\n\t\tcase NSC_COLOR_LOSS_LEVEL:\n\t\t\tcontext->ColorLossLevel = value;\n\t\t\tbreak;\n\t\tcase NSC_ALLOW_SUBSAMPLING:\n\t\t\tcontext->ChromaSubsamplingLevel = value;\n\t\t\tbreak;\n\t\tcase NSC_DYNAMIC_COLOR_FIDELITY:\n\t\t\tcontext->DynamicColorFidelity = value != 0;\n\t\t\tbreak;\n\t\tcase NSC_COLOR_FORMAT:\n\t\t\tcontext->format = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp, UINT32 width, UINT32 height,\n                         const BYTE* data, UINT32 length, BYTE* pDstData, UINT32 DstFormat,\n                         UINT32 nDstStride, UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,\n                         UINT32 nHeight, UINT32 flip)\n{\n\twStream* s;\n\twStream sbuffer = { 0 };\n\tBOOL ret;\n\tif (!context || !data || !pDstData)\n\t\treturn FALSE;\n\n\ts = Stream_StaticConstInit(&sbuffer, data, length);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (nDstStride == 0)\n\t\tnDstStride = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\n\tswitch (bpp)\n\t{\n\t\tcase 32:\n\t\t\tcontext->format = PIXEL_FORMAT_BGRA32;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR24;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR16;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tcontext->format = PIXEL_FORMAT_RGB8;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tcontext->format = PIXEL_FORMAT_A4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tret = nsc_context_initialize(context, s);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\t/* RLE decode */\n\t{\n\t\tBOOL rc;\n\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n\t\trc = nsc_rle_decompress_data(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\t/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */\n\t{\n\t\tBOOL rc;\n\t\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n\t\trc = context->decode(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst, width, height,\n\t                        context->BitmapData, PIXEL_FORMAT_BGRA32, 0, 0, 0, NULL, flip))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Library\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CODEC_NSC_TYPES_H\n#define FREERDP_LIB_CODEC_NSC_TYPES_H\n\n#include <freerdp/config.h>\n\n#include <winpr/crt.h>\n#include <winpr/wlog.h>\n#include <winpr/collections.h>\n\n#include <freerdp/utils/profiler.h>\n#include <freerdp/codec/nsc.h>\n\n#define ROUND_UP_TO(_b, _n) (_b + ((~(_b & (_n - 1)) + 0x1) & (_n - 1)))\n#define MINMAX(_v, _l, _h) ((_v) < (_l) ? (_l) : ((_v) > (_h) ? (_h) : (_v)))\n\ntypedef struct\n{\n\twLog* log;\n\n\tBYTE* PlaneBuffers[5];     /* Decompressed Plane Buffers in the respective order */\n\tUINT32 PlaneBuffersLength; /* Lengths of each plane buffer */\n\n\t/* profilers */\n\tPROFILER_DEFINE(prof_nsc_rle_decompress_data)\n\tPROFILER_DEFINE(prof_nsc_decode)\n\tPROFILER_DEFINE(prof_nsc_rle_compress_data)\n\tPROFILER_DEFINE(prof_nsc_encode)\n} NSC_CONTEXT_PRIV;\n\nstruct S_NSC_CONTEXT\n{\n\tUINT32 OrgByteCount[4];\n\tUINT32 format;\n\tUINT16 width;\n\tUINT16 height;\n\tBYTE* BitmapData;\n\tUINT32 BitmapDataLength;\n\n\tBYTE* Planes;\n\tUINT32 PlaneByteCount[4];\n\tUINT32 ColorLossLevel;\n\tUINT32 ChromaSubsamplingLevel;\n\tBOOL DynamicColorFidelity;\n\n\t/* color palette allocated by the application */\n\tconst BYTE* palette;\n\n\tBOOL (*decode)(NSC_CONTEXT* context);\n\tBOOL (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData, UINT32 rowstride);\n\n\tNSC_CONTEXT_PRIV* priv;\n};\n\n#endif /* FREERDP_LIB_CODEC_NSC_TYPES_H */\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Codec\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <freerdp/config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/color.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_encode.h\"\n\n#include \"nsc_sse2.h\"\n\n#include <freerdp/log.h>\n#define TAG FREERDP_TAG(\"codec.nsc\")\n\n#ifndef NSC_INIT_SIMD\n#define NSC_INIT_SIMD(_nsc_context) \\\n\tdo                              \\\n\t{                               \\\n\t} while (0)\n#endif\n\nstatic BOOL nsc_decode(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE shift;\n\tBYTE* bmpdata;\n\tsize_t pos = 0;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\trw = ROUND_UP_TO(context->width, 8);\n\tshift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n\tbmpdata = context->BitmapData;\n\n\tif (!bmpdata)\n\t\treturn FALSE;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tconst BYTE* yplane;\n\t\tconst BYTE* coplane;\n\t\tconst BYTE* cgplane;\n\t\tconst BYTE* aplane = context->priv->PlaneBuffers[3] + y * context->width; /* A */\n\n\t\tif (context->ChromaSubsamplingLevel)\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * rw;                /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + (y >> 1) * (rw >> 1); /* Co, supersampled */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + (y >> 1) * (rw >> 1); /* Cg, supersampled */\n\t\t}\n\t\telse\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * context->width;  /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + y * context->width; /* Co */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + y * context->width; /* Cg */\n\t\t}\n\n\t\tfor (x = 0; x < context->width; x++)\n\t\t{\n\t\t\tINT16 y_val = (INT16)*yplane;\n\t\t\tINT16 co_val = (INT16)(INT8)(*coplane << shift);\n\t\t\tINT16 cg_val = (INT16)(INT8)(*cgplane << shift);\n\t\t\tINT16 r_val = y_val + co_val - cg_val;\n\t\t\tINT16 g_val = y_val + cg_val;\n\t\t\tINT16 b_val = y_val - co_val - cg_val;\n\n\t\t\tif (pos + 4 > context->BitmapDataLength)\n\t\t\t\treturn FALSE;\n\n\t\t\tpos += 4;\n\t\t\t*bmpdata++ = MINMAX(b_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(g_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(r_val, 0, 0xFF);\n\t\t\t*bmpdata++ = *aplane;\n\t\t\typlane++;\n\t\t\tcoplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\tcgplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\taplane++;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_rle_decode(const BYTE* in, size_t inSize, BYTE* out, UINT32 outSize,\n                           UINT32 originalSize)\n{\n\tUINT32 left = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tif (inSize < 1)\n\t\t\treturn FALSE;\n\t\tinSize--;\n\n\t\tconst BYTE value = *in++;\n\t\tUINT32 len = 0;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (inSize < 1)\n\t\t\treturn FALSE;\n\t\telse if (value == *in)\n\t\t{\n\t\t\tinSize--;\n\t\t\tin++;\n\n\t\t\tif (inSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\telse if (*in < 0xFF)\n\t\t\t{\n\t\t\t\tinSize--;\n\t\t\t\tlen = (UINT32)*in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (inSize < 5)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tinSize -= 5;\n\t\t\t\tin++;\n\t\t\t\tlen = ((UINT32)(*in++));\n\t\t\t\tlen |= ((UINT32)(*in++)) << 8U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 16U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 24U;\n\t\t\t}\n\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\n\tif (inSize < 4)\n\t\treturn FALSE;\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}\n\nstatic BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tconst BYTE* rle = context->Planes;\n\tsize_t rleSize = context->PlanesSize;\n\tWINPR_ASSERT(rle);\n\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\n\t\tif (rleSize < planeSize)\n\t\t\treturn FALSE;\n\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, rleSize, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (rleSize < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\n\t\trle += planeSize;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\n\tStream_Read_UINT8(s, context->ColorLossLevel);         /* ColorLossLevel (1 byte) */\n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Seek(s, 2);                                     /* Reserved (2 bytes) */\n\tcontext->Planes = Stream_Pointer(s);\n\tcontext->PlanesSize = total;\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}\n\nstatic BOOL nsc_context_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tif (!nsc_stream_initialize(context, s))\n\t\treturn FALSE;\n\n\tconst size_t blength = context->width * context->height * 4ull;\n\n\tif (!context->BitmapData || (blength > context->BitmapDataLength))\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->BitmapData, blength + 16, sizeof(BYTE), 32);\n\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\n\t\tcontext->BitmapData = tmp;\n\t\tcontext->BitmapDataLength = blength;\n\t}\n\n\tconst UINT32 tempWidth = ROUND_UP_TO(context->width, 8);\n\tconst UINT32 tempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tconst size_t plength = 1ull * tempWidth * tempHeight;\n\n\tif (plength > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (size_t i = 0; i < 4; i++)\n\t\t{\n\t\t\tvoid* tmp = (BYTE*)winpr_aligned_recalloc(context->priv->PlaneBuffers[i], plength,\n\t\t\t                                          sizeof(BYTE), 32);\n\n\t\t\tif (!tmp)\n\t\t\t\treturn FALSE;\n\n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = plength;\n\t}\n\n\tfor (size_t i = 0; i < 4; i++)\n\t\tcontext->OrgByteCount[i] = context->width * context->height;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = (tempWidth >> 1) * (tempHeight >> 1);\n\t\tcontext->OrgByteCount[2] = context->OrgByteCount[1];\n\t}\n\n\treturn TRUE;\n}\n\nstatic void nsc_profiler_print(NSC_CONTEXT_PRIV* priv)\n{\n\tWINPR_UNUSED(priv);\n\n\tPROFILER_PRINT_HEADER\n\tPROFILER_PRINT(priv->prof_nsc_rle_decompress_data)\n\tPROFILER_PRINT(priv->prof_nsc_decode)\n\tPROFILER_PRINT(priv->prof_nsc_rle_compress_data)\n\tPROFILER_PRINT(priv->prof_nsc_encode)\n\tPROFILER_PRINT_FOOTER\n}\n\nBOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tif ((width > UINT16_MAX) || (height > UINT16_MAX))\n\t\treturn FALSE;\n\n\tcontext->width = (UINT16)width;\n\tcontext->height = (UINT16)height;\n\treturn TRUE;\n}\n\nNSC_CONTEXT* nsc_context_new(void)\n{\n\tNSC_CONTEXT* context = (NSC_CONTEXT*)winpr_aligned_calloc(1, sizeof(NSC_CONTEXT), 32);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->priv = (NSC_CONTEXT_PRIV*)winpr_aligned_calloc(1, sizeof(NSC_CONTEXT_PRIV), 32);\n\n\tif (!context->priv)\n\t\tgoto error;\n\n\tcontext->priv->log = WLog_Get(\"com.freerdp.codec.nsc\");\n\tWLog_OpenAppender(context->priv->log);\n\tcontext->BitmapData = NULL;\n\tcontext->decode = nsc_decode;\n\tcontext->encode = nsc_encode;\n\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_decompress_data, \"nsc_rle_decompress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_decode, \"nsc_decode\")\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_compress_data, \"nsc_rle_compress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_encode, \"nsc_encode\")\n\t/* Default encoding parameters */\n\tcontext->ColorLossLevel = 3;\n\tcontext->ChromaSubsamplingLevel = 1;\n\t/* init optimized methods */\n\tNSC_INIT_SIMD(context);\n\treturn context;\nerror:\n\tnsc_context_free(context);\n\treturn NULL;\n}\n\nvoid nsc_context_free(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn;\n\n\tif (context->priv)\n\t{\n\t\tfor (size_t i = 0; i < 5; i++)\n\t\t\twinpr_aligned_free(context->priv->PlaneBuffers[i]);\n\n\t\tnsc_profiler_print(context->priv);\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_decompress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_decode)\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_compress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_encode)\n\t\twinpr_aligned_free(context->priv);\n\t}\n\n\twinpr_aligned_free(context->BitmapData);\n\twinpr_aligned_free(context);\n}\n\n#if defined(WITH_FREERDP_DEPRECATED)\nBOOL nsc_context_set_pixel_format(NSC_CONTEXT* context, UINT32 pixel_format)\n{\n\treturn nsc_context_set_parameters(context, NSC_COLOR_FORMAT, pixel_format);\n}\n#endif\n\nBOOL nsc_context_set_parameters(NSC_CONTEXT* context, NSC_PARAMETER what, UINT32 value)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tswitch (what)\n\t{\n\t\tcase NSC_COLOR_LOSS_LEVEL:\n\t\t\tcontext->ColorLossLevel = value;\n\t\t\tbreak;\n\t\tcase NSC_ALLOW_SUBSAMPLING:\n\t\t\tcontext->ChromaSubsamplingLevel = value;\n\t\t\tbreak;\n\t\tcase NSC_DYNAMIC_COLOR_FIDELITY:\n\t\t\tcontext->DynamicColorFidelity = value != 0;\n\t\t\tbreak;\n\t\tcase NSC_COLOR_FORMAT:\n\t\t\tcontext->format = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp, UINT32 width, UINT32 height,\n                         const BYTE* data, UINT32 length, BYTE* pDstData, UINT32 DstFormat,\n                         UINT32 nDstStride, UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,\n                         UINT32 nHeight, UINT32 flip)\n{\n\twStream* s;\n\twStream sbuffer = { 0 };\n\tBOOL ret;\n\tif (!context || !data || !pDstData)\n\t\treturn FALSE;\n\n\ts = Stream_StaticConstInit(&sbuffer, data, length);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (nDstStride == 0)\n\t\tnDstStride = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\n\tswitch (bpp)\n\t{\n\t\tcase 32:\n\t\t\tcontext->format = PIXEL_FORMAT_BGRA32;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR24;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR16;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tcontext->format = PIXEL_FORMAT_RGB8;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tcontext->format = PIXEL_FORMAT_A4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tret = nsc_context_initialize(context, s);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\t/* RLE decode */\n\t{\n\t\tBOOL rc;\n\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n\t\trc = nsc_rle_decompress_data(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\t/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */\n\t{\n\t\tBOOL rc;\n\t\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n\t\trc = context->decode(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst, width, height,\n\t                        context->BitmapData, PIXEL_FORMAT_BGRA32, 0, 0, 0, NULL, flip))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Library\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CODEC_NSC_TYPES_H\n#define FREERDP_LIB_CODEC_NSC_TYPES_H\n\n#include <freerdp/config.h>\n\n#include <winpr/crt.h>\n#include <winpr/wlog.h>\n#include <winpr/collections.h>\n\n#include <freerdp/utils/profiler.h>\n#include <freerdp/codec/nsc.h>\n\n#define ROUND_UP_TO(_b, _n) (_b + ((~(_b & (_n - 1)) + 0x1) & (_n - 1)))\n#define MINMAX(_v, _l, _h) ((_v) < (_l) ? (_l) : ((_v) > (_h) ? (_h) : (_v)))\n\ntypedef struct\n{\n\twLog* log;\n\n\tBYTE* PlaneBuffers[5];     /* Decompressed Plane Buffers in the respective order */\n\tUINT32 PlaneBuffersLength; /* Lengths of each plane buffer */\n\n\t/* profilers */\n\tPROFILER_DEFINE(prof_nsc_rle_decompress_data)\n\tPROFILER_DEFINE(prof_nsc_decode)\n\tPROFILER_DEFINE(prof_nsc_rle_compress_data)\n\tPROFILER_DEFINE(prof_nsc_encode)\n} NSC_CONTEXT_PRIV;\n\nstruct S_NSC_CONTEXT\n{\n\tUINT32 OrgByteCount[4];\n\tUINT32 format;\n\tUINT16 width;\n\tUINT16 height;\n\tBYTE* BitmapData;\n\tUINT32 BitmapDataLength;\n\n\tBYTE* Planes;\n\tsize_t PlanesSize;\n\tUINT32 PlaneByteCount[4];\n\tUINT32 ColorLossLevel;\n\tUINT32 ChromaSubsamplingLevel;\n\tBOOL DynamicColorFidelity;\n\n\t/* color palette allocated by the application */\n\tconst BYTE* palette;\n\n\tBOOL (*decode)(NSC_CONTEXT* context);\n\tBOOL (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData, UINT32 rowstride);\n\n\tNSC_CONTEXT_PRIV* priv;\n};\n\n#endif /* FREERDP_LIB_CODEC_NSC_TYPES_H */\n"], "filenames": ["libfreerdp/codec/nsc.c", "libfreerdp/codec/nsc_types.h"], "buggy_code_start_loc": [115, 59], "buggy_code_end_loc": [234, 59], "fixing_code_start_loc": [115, 60], "fixing_code_end_loc": [259, 61], "type": "CWE-125", "message": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Affected versions are subject to an Out-Of-Bounds Read in the `nsc_rle_decompress_data` function. The Out-Of-Bounds Read occurs because it processes `context->Planes` without  checking if it contains data of sufficient length. Should an attacker be able to leverage this vulnerability they may be able to cause a crash. This issue has been addressed in versions 2.11.0 and 3.0.0-beta3. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-39354", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-31T20:15:08.367", "lastModified": "2024-01-12T13:15:10.327", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Affected versions are subject to an Out-Of-Bounds Read in the `nsc_rle_decompress_data` function. The Out-Of-Bounds Read occurs because it processes `context->Planes` without  checking if it contains data of sufficient length. Should an attacker be able to leverage this vulnerability they may be able to cause a crash. This issue has been addressed in versions 2.11.0 and 3.0.0-beta3. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.0", "matchCriteriaId": "80B02150-FC4E-43F5-A3DF-D8E585200977"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:3.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D8720D61-0B0D-40ED-B3C4-B452D83BF3C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "18A75D02-0E7A-4AAF-8E23-0CDCB1733FEA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/cd1da25a87358eb3b5512fd259310e95b19a05ec", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-c3r2-pxxp-f8r6", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00008.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A6LLDAPEXRDJOM3PREDDD267SSNT77DP/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IHMTGKCZXJPQOR5ZD2I4GPDNP2DKRXMF/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OH2ATH2BKDNKCJAU4WPPXK4SHLE3UJUV/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://security.gentoo.org/glsa/202401-16", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/cd1da25a87358eb3b5512fd259310e95b19a05ec"}}