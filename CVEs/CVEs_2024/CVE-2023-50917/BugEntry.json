{"buggy_code": ["<?php\nerror_reporting(E_ALL & ~(E_STRICT | E_NOTICE | E_DEPRECATED));\n\nchdir('../../');\ninclude_once(\"./config.php\");\ninclude_once(\"./lib/loader.php\");\n\nif (!defined('PATH_TO_FFMPEG')) {\n    if (IsWindowsOS()) {\n        define(\"PATH_TO_FFMPEG\", SERVER_ROOT . '/apps/ffmpeg/ffmpeg.exe');\n    } else {\n        define(\"PATH_TO_FFMPEG\", 'ffmpeg');\n    }\n}\n\ndefine(\"_I_CACHING\", \"0\");               //    Chaching enabled, 1 - yes, 0 - no\ndefine(\"_I_CACHE_PATH\", \"./cms/cached/\"); //    Path to cache dir\ndefine(\"_I_CACHE_EXPIRED\", \"2592000\");   //    Expired time for images in seconds, 0 - never expired\n\n\n$url = gr('url');\n$img = gr('img');\n$username = gr('username');\n$password = gr('password');\n$transport = gr('transport');\n\n$w = gr('w', 'int');\n$h = gr('h', 'int');\n$live = gr('live', 'int');\n\n$debug_mode = gr('debug', 'int');\n\nif (isset($url) && $url != '') {\n    $tmp_url = base64_decode($url);\n    if (!$img) {\n        $filename = 'thumb_' . md5($tmp_url) . basename(preg_replace('/\\W/', '', $tmp_url));\n        $img = _I_CACHE_PATH . $filename;\n    }\n    if ($tmp_url == 'usb') {\n        $url = \"\";\n        $img_tmp = $img . '_tmp';\n        $resolution = '1280x720';\n        if ($w && $h) {\n            $resolution = $w . 'x' . $h;\n        }\n        //-re -f v4l2 -video_size 1280x720 -i /dev/video0\n        $cmd = 'fswebcam -r ' . escapeshellarg($resolution) . ' ' . escapeshellarg($img_tmp);\n        if ($debug_mode) {\n            echo $cmd . '<br/>';\n        } else {\n            exec($cmd);\n        }\n        if (file_exists($img_tmp)) {\n            rename($img_tmp, $img);\n        }\n    }\n}\n\nif ($debug_mode) {\n    $live = 0;\n}\n\nif (isset($url) && $url != '') {\n\n    $resize = '';\n    if ($w && $h) {\n        $resize = ' -vf scale=' . $w . ':' . $h;\n    } elseif ($w) {\n        $resize = ' -vf scale=' . $w . ':-1';\n    } elseif ($h) {\n        $resize = ' -vf scale=-1:' . $h;\n    }\n    $url = base64_decode($url);\n\n    if ($username || $password) {\n        $url = str_replace('://', '://' . $username . ':' . $password . '@', $url);\n    }\n\n    if (preg_match('/^rtsp:/is', $url) || preg_match('/\\/dev/', $url)) {\n        //-rtsp_transport tcp // -rtsp_transport tcp\n        $stream_options = '-timelimit 15 -y -i ' . escapeshellarg($url) . ($resize) . ' -r 5 -f image2 -vframes 1'; //-ss 00:00:01.500\n        if ($debug_mode) {\n            $stream_options = '-v verbose ' . escapeshellarg($stream_options);\n        }\n        if ($transport) {\n            $stream_options = '-rtsp_transport ' . escapeshellarg($transport) . ' ' . escapeshellarg($stream_options);\n        }\n        $cmd = PATH_TO_FFMPEG . ' ' . $stream_options . ' ' . escapeshellarg($img);\n\n        if ($live) {\n            $boundary = \"my_mjpeg\";\n            header(\"Cache-Control: no-cache\");\n            header(\"Cache-Control: private\");\n            header(\"Pragma: no-cache\");\n            header(\"Content-type: multipart/x-mixed-replace; boundary=$boundary\");\n            print \"--$boundary\\n\";\n            set_time_limit(0);\n            //@apache_setenv('no-gzip', 1);\n            @ini_set('zlib.output_compression', 0);\n            @ini_set('implicit_flush', 1);\n\n            for ($i = 0; $i < ob_get_level(); $i++) ob_end_flush();\n            ob_implicit_flush(1);\n            while (true) {\n                print \"Content-type: image/jpeg\\n\\n\";\n                system($cmd);\n                print LoadFile($img);\n                print \"--$boundary\\n\";\n                sleep(1);\n            }\n        } else {\n            @unlink($img);\n            $output = array();\n            $res = exec($cmd . ' 2>&1', $output);\n\n            if ($debug_mode) {\n                echo $cmd;\n                echo \"<hr><pre>\" . implode(\"\\n\", $output) . \"</pre>\";\n                exit;\n            }\n\n        }\n        $dc = 1;\n    } else {\n\n        function mjpeg_grab_frame($url)\n        {\n            $f = fopen($url, 'r');\n            if ($f) {\n                $r = null;\n                $lines = 0;\n                while (substr_count($r, \"\\xFF\\xD8\") != 2 && $lines < 1000) {\n                    $r .= fread($f, 512);\n                    $lines++;\n                }\n                if ($lines >= 1000) {\n                    return false;\n                }\n                $start = strpos($r, \"\\xFF\\xD8\");\n                $end = strpos($r, \"\\xFF\\xD9\", $start) + 2;\n                $frame = substr($r, $start, $end - $start);\n                fclose($f);\n                return $frame;\n            }\n        }\n\n        $result = @mjpeg_grab_frame($url);\n\n        if (!$result) {\n            $url = preg_replace('/\\/\\/(.+?)@/', '//', $url);\n            $result = getURL($url, 0, $username, $password, false, array(CURLOPT_HTTPAUTH => CURLAUTH_ANY));\n        }\n\n\n        if ($result) {\n\n            if ($live) {\n                $boundary = \"my_mjpeg\";\n                header('Accept-Range: bytes');\n                header(\"Cache-Control: no-cache\");\n                header(\"Cache-Control: private\");\n                header(\"Pragma: no-cache\");\n                header(\"Content-type: multipart/x-mixed-replace; boundary=$boundary\");\n                set_time_limit(0);\n                if (function_exists('apache_setenv')) {\n                    @apache_setenv('no-gzip', 1);\n                }\n                @ini_set('zlib.output_compression', 0);\n                @ini_set('implicit_flush', 1);\n                for ($i = 0; $i < ob_get_level(); $i++) ob_end_flush();\n                ob_implicit_flush(1);\n                ob_end_flush();\n                $counter = 0;\n                print \"Content-type: image/jpeg\\n\\n\";\n                while (true) {\n                    $counter++;\n                    $result = getURL($url, 0, $username, $password);\n                    if ($result) {\n                        $newimg = imagecreatefromstring($result);\n                        imagejpeg($newimg);\n                        print \"--$boundary\\n\\n\";\n                    }\n                    flush();\n                    ob_flush();\n                    sleep(1);\n                }\n\n            } else {\n                SaveFile($img, $result);\n            }\n            $dc = 1;\n        } else {\n            $img = 'error';\n        }\n\n    }\n}\n\n\n$type = gr('t', 'int');\n\n/*\n   Allowed types:\n    0 - fit\n    2 - exact size\n*/\nif (file_exists($img)) {\n    $new_width = $w;\n    $new_height = $h;\n\n    $cached_filename = md5($img . filemtime($img) . $new_width . $new_height) . '.jpg';\n    $path_to_cache_file = _I_CACHE_PATH . substr($cached_filename, 0, 2);\n    $cache = $path_to_cache_file . '/' . $cached_filename;\n\n    //   Check the cache\n    if (_I_CACHING == \"1\" && !$dc)\n\n        if (file_exists($cache)) {\n            header(\"Content-Type:image/jpeg\");\n            header(\"Content-Length: \" . filesize($cache));\n            header(\"Cache-Control: public\"); // HTTP/1.1\n            header(\"Expires: \" . gmdate('D, d M Y H:i:s', (time() + 60 * 60 * 24 * 30)) . ' GMT'); // Date in the future (+30 days)\n            header('Last-Modified: ' . gmdate('D, d M Y H:i:s', @filemtime($cache)) . ' GMT');\n            readfile($cache);\n            exit;\n        }\n\n    $filename = $img;\n    $lst = GetImageSize($filename);\n    $image_width = $lst[0];\n    $image_height = $lst[1];\n    $image_format = $lst[2];\n\n\n    switch ($type) {\n        case 0:\n            if (($new_width != 0) && ($new_width < $image_width)) {\n                $image_height = (int)($image_height * ($new_width / $image_width));\n                $image_width = $new_width;\n            }\n            if (($new_height != 0) && ($new_height < $image_height)) {\n                $image_width = (int)($image_width * ($new_height / $image_height));\n                $image_height = $new_height;\n            }\n            break;\n        case 1:\n            $image_width = $new_width;\n            $image_height = $image_height;\n            break;\n    }\n\n\n    if ($image_format == 1) {\n        $old_image = imagecreatefromgif($filename);\n    } elseif ($image_format == 2) {\n        $old_image = imagecreatefromjpeg($filename);\n    } elseif ($image_format == 3) {\n        $old_image = imagecreatefrompng($filename);\n    } else {\n        return;\n    }\n\n    $new_image = imageCreateTrueColor($image_width, $image_height);\n    $white = ImageColorAllocate($new_image, 255, 255, 255);\n    ImageFill($new_image, 0, 0, $white);\n\n    imagecopyresampled($new_image, $old_image, 0, 0, 0, 0, $image_width, $image_height, imageSX($old_image), imageSY($old_image));\n\n    //   Save to cache\n    if (_I_CACHING == \"1\" && !$_REQUEST['dc']) {\n        if (!is_dir($path_to_cache_file)) {\n            @mkdir($path_to_cache_file);\n        }\n        imageJpeg($new_image, $cache);\n    }\n\n    Header(\"Content-type:image/jpeg\");\n    imageJpeg($new_image);\n\n\n}\n"], "fixing_code": ["<?php\nerror_reporting(E_ALL & ~(E_STRICT | E_NOTICE | E_DEPRECATED));\n\nchdir('../../');\ninclude_once(\"./config.php\");\ninclude_once(\"./lib/loader.php\");\n\nif (!defined('PATH_TO_FFMPEG')) {\n    if (IsWindowsOS()) {\n        define(\"PATH_TO_FFMPEG\", SERVER_ROOT . '/apps/ffmpeg/ffmpeg.exe');\n    } else {\n        define(\"PATH_TO_FFMPEG\", 'ffmpeg');\n    }\n}\n\ndefine(\"_I_CACHING\", \"0\");               //    Chaching enabled, 1 - yes, 0 - no\ndefine(\"_I_CACHE_PATH\", \"./cms/cached/\"); //    Path to cache dir\ndefine(\"_I_CACHE_EXPIRED\", \"2592000\");   //    Expired time for images in seconds, 0 - never expired\n\n\n$url = gr('url');\n$img = gr('img');\n$username = gr('username');\n$password = gr('password');\n$transport = gr('transport');\n\n$w = gr('w', 'int');\n$h = gr('h', 'int');\n$live = gr('live', 'int');\n\n$debug_mode = gr('debug', 'int');\n\nif (isset($url) && $url != '') {\n    $tmp_url = base64_decode($url);\n    if (!$img) {\n        $filename = 'thumb_' . md5($tmp_url) . basename(preg_replace('/\\W/', '', $tmp_url));\n        $img = _I_CACHE_PATH . $filename;\n    }\n    if ($tmp_url == 'usb') {\n        $url = \"\";\n        $img_tmp = $img . '_tmp';\n        $resolution = '1280x720';\n        if ($w && $h) {\n            $resolution = $w . 'x' . $h;\n        }\n        //-re -f v4l2 -video_size 1280x720 -i /dev/video0\n        $cmd = 'fswebcam -r ' . escapeshellarg($resolution) . ' ' . escapeshellarg($img_tmp);\n        if ($debug_mode) {\n            echo $cmd . '<br/>';\n        } else {\n            exec($cmd);\n        }\n        if (file_exists($img_tmp)) {\n            rename($img_tmp, $img);\n        }\n    }\n}\n\nif ($debug_mode) {\n    $live = 0;\n}\n\nif (isset($url) && $url != '') {\n\n    $resize = '';\n    if ($w && $h) {\n        $resize = ' -vf scale=' . $w . ':' . $h;\n    } elseif ($w) {\n        $resize = ' -vf scale=' . $w . ':-1';\n    } elseif ($h) {\n        $resize = ' -vf scale=-1:' . $h;\n    }\n    $url = base64_decode($url);\n\n    if ($username || $password) {\n        $url = str_replace('://', '://' . $username . ':' . $password . '@', $url);\n    }\n\n    if (preg_match('/^rtsp:/is', $url) || preg_match('/\\/dev/', $url)) {\n        //-rtsp_transport tcp // -rtsp_transport tcp\n        $stream_options = '-timelimit 15 -y -i ' . escapeshellarg($url) . ($resize) . ' -r 5 -f image2 -vframes 1'; //-ss 00:00:01.500\n        if ($debug_mode) {\n            $stream_options = '-v verbose ' . $stream_options;\n        }\n        if ($transport) {\n            $stream_options = '-rtsp_transport ' . escapeshellarg($transport) . ' ' . $stream_options;\n        }\n        $cmd = PATH_TO_FFMPEG . ' ' . $stream_options . ' ' . escapeshellarg($img);\n\n        if ($live) {\n            $boundary = \"my_mjpeg\";\n            header(\"Cache-Control: no-cache\");\n            header(\"Cache-Control: private\");\n            header(\"Pragma: no-cache\");\n            header(\"Content-type: multipart/x-mixed-replace; boundary=$boundary\");\n            print \"--$boundary\\n\";\n            set_time_limit(0);\n            //@apache_setenv('no-gzip', 1);\n            @ini_set('zlib.output_compression', 0);\n            @ini_set('implicit_flush', 1);\n\n            for ($i = 0; $i < ob_get_level(); $i++) ob_end_flush();\n            ob_implicit_flush(1);\n            while (true) {\n                print \"Content-type: image/jpeg\\n\\n\";\n                system($cmd);\n                print LoadFile($img);\n                print \"--$boundary\\n\";\n                sleep(1);\n            }\n        } else {\n            @unlink($img);\n            $output = array();\n            $res = exec($cmd . ' 2>&1', $output);\n\n            if ($debug_mode) {\n                echo $cmd;\n                echo \"<hr><pre>\" . implode(\"\\n\", $output) . \"</pre>\";\n                exit;\n            }\n\n        }\n        $dc = 1;\n    } else {\n\n        function mjpeg_grab_frame($url)\n        {\n            $f = fopen($url, 'r');\n            if ($f) {\n                $r = null;\n                $lines = 0;\n                while (substr_count($r, \"\\xFF\\xD8\") != 2 && $lines < 1000) {\n                    $r .= fread($f, 512);\n                    $lines++;\n                }\n                if ($lines >= 1000) {\n                    return false;\n                }\n                $start = strpos($r, \"\\xFF\\xD8\");\n                $end = strpos($r, \"\\xFF\\xD9\", $start) + 2;\n                $frame = substr($r, $start, $end - $start);\n                fclose($f);\n                return $frame;\n            }\n        }\n\n        $result = @mjpeg_grab_frame($url);\n\n        if (!$result) {\n            $url = preg_replace('/\\/\\/(.+?)@/', '//', $url);\n            $result = getURL($url, 0, $username, $password, false, array(CURLOPT_HTTPAUTH => CURLAUTH_ANY));\n        }\n\n\n        if ($result) {\n\n            if ($live) {\n                $boundary = \"my_mjpeg\";\n                header('Accept-Range: bytes');\n                header(\"Cache-Control: no-cache\");\n                header(\"Cache-Control: private\");\n                header(\"Pragma: no-cache\");\n                header(\"Content-type: multipart/x-mixed-replace; boundary=$boundary\");\n                set_time_limit(0);\n                if (function_exists('apache_setenv')) {\n                    @apache_setenv('no-gzip', 1);\n                }\n                @ini_set('zlib.output_compression', 0);\n                @ini_set('implicit_flush', 1);\n                for ($i = 0; $i < ob_get_level(); $i++) ob_end_flush();\n                ob_implicit_flush(1);\n                ob_end_flush();\n                $counter = 0;\n                print \"Content-type: image/jpeg\\n\\n\";\n                while (true) {\n                    $counter++;\n                    $result = getURL($url, 0, $username, $password);\n                    if ($result) {\n                        $newimg = imagecreatefromstring($result);\n                        imagejpeg($newimg);\n                        print \"--$boundary\\n\\n\";\n                    }\n                    flush();\n                    ob_flush();\n                    sleep(1);\n                }\n\n            } else {\n                SaveFile($img, $result);\n            }\n            $dc = 1;\n        } else {\n            $img = 'error';\n        }\n\n    }\n}\n\n\n$type = gr('t', 'int');\n\n/*\n   Allowed types:\n    0 - fit\n    2 - exact size\n*/\nif (file_exists($img)) {\n    $new_width = $w;\n    $new_height = $h;\n\n    $cached_filename = md5($img . filemtime($img) . $new_width . $new_height) . '.jpg';\n    $path_to_cache_file = _I_CACHE_PATH . substr($cached_filename, 0, 2);\n    $cache = $path_to_cache_file . '/' . $cached_filename;\n\n    //   Check the cache\n    if (_I_CACHING == \"1\" && !$dc)\n\n        if (file_exists($cache)) {\n            header(\"Content-Type:image/jpeg\");\n            header(\"Content-Length: \" . filesize($cache));\n            header(\"Cache-Control: public\"); // HTTP/1.1\n            header(\"Expires: \" . gmdate('D, d M Y H:i:s', (time() + 60 * 60 * 24 * 30)) . ' GMT'); // Date in the future (+30 days)\n            header('Last-Modified: ' . gmdate('D, d M Y H:i:s', @filemtime($cache)) . ' GMT');\n            readfile($cache);\n            exit;\n        }\n\n    $filename = $img;\n    $lst = GetImageSize($filename);\n    $image_width = $lst[0];\n    $image_height = $lst[1];\n    $image_format = $lst[2];\n\n\n    switch ($type) {\n        case 0:\n            if (($new_width != 0) && ($new_width < $image_width)) {\n                $image_height = (int)($image_height * ($new_width / $image_width));\n                $image_width = $new_width;\n            }\n            if (($new_height != 0) && ($new_height < $image_height)) {\n                $image_width = (int)($image_width * ($new_height / $image_height));\n                $image_height = $new_height;\n            }\n            break;\n        case 1:\n            $image_width = $new_width;\n            $image_height = $image_height;\n            break;\n    }\n\n\n    if ($image_format == 1) {\n        $old_image = imagecreatefromgif($filename);\n    } elseif ($image_format == 2) {\n        $old_image = imagecreatefromjpeg($filename);\n    } elseif ($image_format == 3) {\n        $old_image = imagecreatefrompng($filename);\n    } else {\n        return;\n    }\n\n    $new_image = imageCreateTrueColor($image_width, $image_height);\n    $white = ImageColorAllocate($new_image, 255, 255, 255);\n    ImageFill($new_image, 0, 0, $white);\n\n    imagecopyresampled($new_image, $old_image, 0, 0, 0, 0, $image_width, $image_height, imageSX($old_image), imageSY($old_image));\n\n    //   Save to cache\n    if (_I_CACHING == \"1\" && !$_REQUEST['dc']) {\n        if (!is_dir($path_to_cache_file)) {\n            @mkdir($path_to_cache_file);\n        }\n        imageJpeg($new_image, $cache);\n    }\n\n    Header(\"Content-type:image/jpeg\");\n    imageJpeg($new_image);\n\n\n}\n"], "filenames": ["modules/thumb/thumb.php"], "buggy_code_start_loc": [83], "buggy_code_end_loc": [87], "fixing_code_start_loc": [83], "fixing_code_end_loc": [87], "type": "CWE-77", "message": "MajorDoMo (aka Major Domestic Module) before 0662e5e allows command execution via thumb.php shell metacharacters. NOTE: this is unrelated to the Majordomo mailing-list manager.", "other": {"cve": {"id": "CVE-2023-50917", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-15T17:15:12.840", "lastModified": "2024-01-22T17:15:09.207", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "MajorDoMo (aka Major Domestic Module) before 0662e5e allows command execution via thumb.php shell metacharacters. NOTE: this is unrelated to the Majordomo mailing-list manager."}, {"lang": "es", "value": "MajorDoMo (tambi\u00e9n conocido como Major Domestic Module) anterior a 0662e5e permite la ejecuci\u00f3n de comandos a trav\u00e9s de metacaracteres del shell thumb.php. NOTA: esto no est\u00e1 relacionado con el administrador de listas de correo de Majordomo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mjdm:majordomo:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-11-15", "matchCriteriaId": "B47943C3-4EC3-479D-B949-C2702BD92B39"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/176273/MajorDoMo-Remote-Code-Execution.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/176669/MajorDoMo-Command-Injection.html", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2023/Dec/19", "source": "cve@mitre.org"}, {"url": "https://github.com/sergejey/majordomo/commit/0662e5ebfb133445ff6154b69c61019357092178", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/sergejey/majordomo/commit/3ec3ffb863ea3c2661ab27d398776c551f4daaac", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/sergejey/majordomo/commit/0662e5ebfb133445ff6154b69c61019357092178"}}