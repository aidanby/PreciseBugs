{"buggy_code": ["/* libhttpd.c - HTTP protocol library\n**\n** Copyright \ufffd 1995,1998,1999,2000,2001 by Jef Poskanzer <jef@mail.acme.com>.\n** All rights reserved.\n**\n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions\n** are met:\n** 1. Redistributions of source code must retain the above copyright\n**    notice, this list of conditions and the following disclaimer.\n** 2. Redistributions in binary form must reproduce the above copyright\n**    notice, this list of conditions and the following disclaimer in the\n**    documentation and/or other materials provided with the distribution.\n**\n** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n** SUCH DAMAGE.\n*/\n\n\n#include <config.h>\n\n//system headers\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif /* HAVE_MEMORY_H */\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#ifdef HAVE_OSRELDATE_H\n#include <osreldate.h>\n#endif /* HAVE_OSRELDATE_H */\n\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# ifdef HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# ifdef HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# ifdef HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n\nextern char* crypt( const char* key, const char* setting );\n\n//local headers\n#include <libhttpd.h>\n#include <match.h>\n#include <mmc.h>\n#include <tdate_parse.h>\n#include <thttpd.h>\n#include <timers.h>\n#include <version.h>\n\n#ifdef SHOW_SERVER_VERSION\n#define EXPOSED_SERVER_SOFTWARE SERVER_SOFTWARE\n#else /* SHOW_SERVER_VERSION */\n#define EXPOSED_SERVER_SOFTWARE \"sthttpd\"\n#endif /* SHOW_SERVER_VERSION */\n\n#ifndef STDIN_FILENO\n#define STDIN_FILENO 0\n#endif\n#ifndef STDOUT_FILENO\n#define STDOUT_FILENO 1\n#endif\n#ifndef STDERR_FILENO\n#define STDERR_FILENO 2\n#endif\n\n#ifndef SHUT_WR\n#define SHUT_WR 1\n#endif\n\n#ifdef __CYGWIN__\n#define timezone  _timezone\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n\n/* Forwards. */\nstatic void check_options( void );\nstatic void free_httpd_server( httpd_server* hs );\nstatic int initialize_listen_socket( httpd_sockaddr* saP );\nstatic void add_response( httpd_conn* hc, char* str );\nstatic void send_mime( httpd_conn* hc, int status, char* title, char* encodings, char* extraheads, char* type, off_t length, time_t mod );\nstatic void send_response( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg );\nstatic void send_response_tail( httpd_conn* hc );\nstatic void defang( char* str, char* dfstr, int dfsize );\n#ifdef ERR_DIR\nstatic int send_err_file( httpd_conn* hc, int status, char* title, char* extraheads, char* filename );\n#endif /* ERR_DIR */\n#ifdef AUTH_FILE\nstatic void send_authenticate( httpd_conn* hc, char* realm );\nstatic int b64_decode( const char* str, unsigned char* space, int size );\nstatic int auth_check( httpd_conn* hc, char* dirname  );\nstatic int auth_check2( httpd_conn* hc, char* dirname  );\n#endif /* AUTH_FILE */\nstatic void send_dirredirect( httpd_conn* hc );\nstatic int hexit( char c );\nstatic void strdecode( char* to, char* from );\n#ifdef GENERATE_INDEXES\nstatic void strencode( char* to, int tosize, char* from );\n#endif /* GENERATE_INDEXES */\n#ifdef TILDE_MAP_1\nstatic int tilde_map_1( httpd_conn* hc );\n#endif /* TILDE_MAP_1 */\n#ifdef TILDE_MAP_2\nstatic int tilde_map_2( httpd_conn* hc );\n#endif /* TILDE_MAP_2 */\nstatic int vhost_map( httpd_conn* hc );\nstatic char* expand_symlinks( char* path, char** restP, int no_symlink_check, int tildemapped );\nstatic char* bufgets( httpd_conn* hc );\nstatic void de_dotdot( char* file );\nstatic void init_mime( void );\nstatic void figure_mime( httpd_conn* hc );\n#ifdef CGI_TIMELIMIT\nstatic void cgi_kill2( ClientData client_data, struct timeval* nowP );\nstatic void cgi_kill( ClientData client_data, struct timeval* nowP );\n#endif /* CGI_TIMELIMIT */\n#ifdef GENERATE_INDEXES\nstatic int ls( httpd_conn* hc );\n#endif /* GENERATE_INDEXES */\nstatic char* build_env( char* fmt, char* arg );\n#ifdef SERVER_NAME_LIST\nstatic char* hostname_map( char* hostname );\n#endif /* SERVER_NAME_LIST */\nstatic char** make_envp( httpd_conn* hc );\nstatic char** make_argp( httpd_conn* hc );\nstatic void cgi_interpose_input( httpd_conn* hc, int wfd );\nstatic void post_post_garbage_hack( httpd_conn* hc );\nstatic void cgi_interpose_output( httpd_conn* hc, int rfd );\nstatic void cgi_child( httpd_conn* hc );\nstatic int cgi( httpd_conn* hc );\nstatic int really_start_request( httpd_conn* hc, struct timeval* nowP );\nstatic void make_log_entry( httpd_conn* hc, struct timeval* nowP );\nstatic int check_referer( httpd_conn* hc );\nstatic int really_check_referer( httpd_conn* hc );\nstatic int sockaddr_check( httpd_sockaddr* saP );\nstatic size_t sockaddr_len( httpd_sockaddr* saP );\nstatic int my_snprintf( char* str, size_t size, const char* format, ... );\n#ifndef HAVE_ATOLL\nstatic long long atoll( const char* str );\n#endif /* HAVE_ATOLL */\n\n\n/* This global keeps track of whether we are in the main process or a\n** sub-process.  The reason is that httpd_write_response() can get called\n** in either context; when it is called from the main process it must use\n** non-blocking I/O to avoid stalling the server, but when it is called\n** from a sub-process it wants to use blocking I/O so that the whole\n** response definitely gets written.  So, it checks this variable.  A bit\n** of a hack but it seems to do the right thing.\n*/\nstatic int sub_process = 0;\n\n\nstatic void\ncheck_options( void )\n    {\n#if defined(TILDE_MAP_1) && defined(TILDE_MAP_2)\n    syslog( LOG_CRIT, \"both TILDE_MAP_1 and TILDE_MAP_2 are defined\" );\n    exit( 1 );\n#endif /* both */\n    }\n\n\nstatic void\nfree_httpd_server( httpd_server* hs )\n{\n    free(hs->binding_hostname);\n    free(hs->cwd);\n    free(hs->cgi_pattern);\n    free(hs->charset);\n    free(hs->p3p);\n    free(hs->url_pattern);\n    free(hs->local_pattern);\n    free(hs);\n}\n\n\nhttpd_server*\nhttpd_initialize(\n    char* hostname, httpd_sockaddr* sa4P, httpd_sockaddr* sa6P,\n    unsigned short port, char* cgi_pattern, int cgi_limit, char* charset,\n    char* p3p, int max_age, char* cwd, int no_log, FILE* logfp,\n    int no_symlink_check, int vhost, int global_passwd, char* url_pattern,\n    char* local_pattern, int no_empty_referers )\n    {\n    httpd_server* hs;\n    static char ghnbuf[256];\n    char* cp;\n\n    check_options();\n\n    hs = NEW( httpd_server, 1 );\n    if ( hs == (httpd_server*) 0 )\n\t{\n\tsyslog( LOG_CRIT, \"out of memory allocating an httpd_server\" );\n\treturn (httpd_server*) 0;\n\t}\n\n    if ( hostname != (char*) 0 )\n\t{\n\ths->binding_hostname = strdup( hostname );\n\tif ( hs->binding_hostname == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying hostname\" );\n\t    return (httpd_server*) 0;\n\t    }\n\ths->server_hostname = hs->binding_hostname;\n\t}\n    else\n\t{\n\ths->binding_hostname = (char*) 0;\n\ths->server_hostname = (char*) 0;\n\tif ( gethostname( ghnbuf, sizeof(ghnbuf) ) < 0 )\n\t    ghnbuf[0] = '\\0';\n#ifdef SERVER_NAME_LIST\n\tif ( ghnbuf[0] != '\\0' )\n\t    hs->server_hostname = hostname_map( ghnbuf );\n#endif /* SERVER_NAME_LIST */\n\tif ( hs->server_hostname == (char*) 0 )\n\t    {\n#ifdef SERVER_NAME\n\t    hs->server_hostname = SERVER_NAME;\n#else /* SERVER_NAME */\n\t    if ( ghnbuf[0] != '\\0' )\n\t\ths->server_hostname = ghnbuf;\n#endif /* SERVER_NAME */\n\t    }\n\t}\n\n    hs->port = port;\n    if ( cgi_pattern == (char*) 0 )\n\ths->cgi_pattern = (char*) 0;\n    else\n\t{\n\t/* Nuke any leading slashes. */\n\tif ( cgi_pattern[0] == '/' )\n\t    ++cgi_pattern;\n\ths->cgi_pattern = strdup( cgi_pattern );\n\tif ( hs->cgi_pattern == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying cgi_pattern\" );\n\t    return (httpd_server*) 0;\n\t    }\n\t/* Nuke any leading slashes in the cgi pattern. */\n\twhile ( ( cp = strstr( hs->cgi_pattern, \"|/\" ) ) != (char*) 0 )\n\t    /* -2 for the offset, +1 for the '\\0' */\n\t    (void) memmove( cp + 1, cp + 2, strlen( cp ) - 1 );\n\t}\n    hs->cgi_limit = cgi_limit;\n    hs->cgi_count = 0;\n    hs->charset = strdup( charset );\n    hs->p3p = strdup( p3p );\n    hs->max_age = max_age;\n    hs->cwd = strdup( cwd );\n    if ( hs->cwd == (char*) 0 )\n\t{\n\tsyslog( LOG_CRIT, \"out of memory copying cwd\" );\n\treturn (httpd_server*) 0;\n\t}\n    if ( url_pattern == (char*) 0 )\n\ths->url_pattern = (char*) 0;\n    else\n\t{\n\ths->url_pattern = strdup( url_pattern );\n\tif ( hs->url_pattern == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying url_pattern\" );\n\t    return (httpd_server*) 0;\n\t    }\n\t}\n    if ( local_pattern == (char*) 0 )\n\ths->local_pattern = (char*) 0;\n    else\n\t{\n\ths->local_pattern = strdup( local_pattern );\n\tif ( hs->local_pattern == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying local_pattern\" );\n\t    return (httpd_server*) 0;\n\t    }\n\t}\n    hs->no_log = no_log;\n    hs->logfp = (FILE*) 0;\n    httpd_set_logfp( hs, logfp );\n    hs->no_symlink_check = no_symlink_check;\n    hs->vhost = vhost;\n    hs->global_passwd = global_passwd;\n    hs->no_empty_referers = no_empty_referers;\n\n    /* Initialize listen sockets.  Try v6 first because of a Linux peculiarity;\n    ** like some other systems, it has magical v6 sockets that also listen for\n    ** v4, but in Linux if you bind a v4 socket first then the v6 bind fails.\n    */\n    if ( sa6P == (httpd_sockaddr*) 0 )\n\ths->listen6_fd = -1;\n    else\n\ths->listen6_fd = initialize_listen_socket( sa6P );\n    if ( sa4P == (httpd_sockaddr*) 0 )\n\ths->listen4_fd = -1;\n    else\n\ths->listen4_fd = initialize_listen_socket( sa4P );\n    /* If we didn't get any valid sockets, fail. */\n    if ( hs->listen4_fd == -1 && hs->listen6_fd == -1 )\n\t{\n\tfree_httpd_server( hs );\n\treturn (httpd_server*) 0;\n\t}\n\n    init_mime();\n\n    /* Done initializing. */\n    if ( hs->binding_hostname == (char*) 0 )\n\tsyslog(\n\t    LOG_NOTICE, \"%.80s starting on port %d\", SERVER_SOFTWARE,\n\t    (int) hs->port );\n    else\n\tsyslog(\n\t    LOG_NOTICE, \"%.80s starting on %.80s, port %d\", SERVER_SOFTWARE,\n\t    httpd_ntoa( hs->listen4_fd != -1 ? sa4P : sa6P ),\n\t    (int) hs->port );\n    return hs;\n    }\n\n\nstatic int\ninitialize_listen_socket( httpd_sockaddr* saP )\n    {\n    int listen_fd;\n    int on, flags;\n\n    /* Check sockaddr. */\n    if ( ! sockaddr_check( saP ) )\n\t{\n\tsyslog( LOG_CRIT, \"unknown sockaddr family on listen socket\" );\n\treturn -1;\n\t}\n\n    /* Create socket. */\n    listen_fd = socket( saP->sa.sa_family, SOCK_STREAM, 0 );\n    if ( listen_fd < 0 )\n\t{\n\tsyslog( LOG_CRIT, \"socket %.80s - %m\", httpd_ntoa( saP ) );\n\treturn -1;\n\t}\n    (void) fcntl( listen_fd, F_SETFD, 1 );\n\n    /* Allow reuse of local addresses. */\n    on = 1;\n    if ( setsockopt(\n\t     listen_fd, SOL_SOCKET, SO_REUSEADDR, (char*) &on,\n\t     sizeof(on) ) < 0 )\n\tsyslog( LOG_CRIT, \"setsockopt SO_REUSEADDR - %m\" );\n\n    /* Bind to it. */\n    if ( bind( listen_fd, &saP->sa, sockaddr_len( saP ) ) < 0 )\n\t{\n\tsyslog(\n\t    LOG_CRIT, \"bind %.80s - %m\", httpd_ntoa( saP ) );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n\n    /* Set the listen file descriptor to no-delay / non-blocking mode. */\n    flags = fcntl( listen_fd, F_GETFL, 0 );\n    if ( flags == -1 )\n\t{\n\tsyslog( LOG_CRIT, \"fcntl F_GETFL - %m\" );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n    if ( fcntl( listen_fd, F_SETFL, flags | O_NDELAY ) < 0 )\n\t{\n\tsyslog( LOG_CRIT, \"fcntl O_NDELAY - %m\" );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n\n    /* Start a listen going. */\n    if ( listen( listen_fd, LISTEN_BACKLOG ) < 0 )\n\t{\n\tsyslog( LOG_CRIT, \"listen - %m\" );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n\n    /* Use accept filtering, if available. */\n#ifdef SO_ACCEPTFILTER\n    {\n#if ( __FreeBSD_version >= 411000 )\n#define ACCEPT_FILTER_NAME \"httpready\"\n#else\n#define ACCEPT_FILTER_NAME \"dataready\"\n#endif\n    struct accept_filter_arg af;\n    (void) bzero( &af, sizeof(af) );\n    (void) strcpy( af.af_name, ACCEPT_FILTER_NAME );\n    (void) setsockopt(\n\tlisten_fd, SOL_SOCKET, SO_ACCEPTFILTER, (char*) &af, sizeof(af) );\n    }\n#endif /* SO_ACCEPTFILTER */\n\n    return listen_fd;\n    }\n\n\nvoid\nhttpd_set_logfp( httpd_server* hs, FILE* logfp )\n    {\n    if ( hs->logfp != (FILE*) 0 )\n\t(void) fclose( hs->logfp );\n    hs->logfp = logfp;\n    }\n\n\nvoid\nhttpd_terminate( httpd_server* hs )\n    {\n    httpd_unlisten( hs );\n    if ( hs->logfp != (FILE*) 0 )\n\t(void) fclose( hs->logfp );\n    free_httpd_server( hs );\n    }\n\n\nvoid\nhttpd_unlisten( httpd_server* hs )\n    {\n    if ( hs->listen4_fd != -1 )\n\t{\n\t(void) close( hs->listen4_fd );\n\ths->listen4_fd = -1;\n\t}\n    if ( hs->listen6_fd != -1 )\n\t{\n\t(void) close( hs->listen6_fd );\n\ths->listen6_fd = -1;\n\t}\n    }\n\n\n/* Conditional macro to allow two alternate forms for use in the built-in\n** error pages.  If EXPLICIT_ERROR_PAGES is defined, the second and more\n** explicit error form is used; otherwise, the first and more generic\n** form is used.\n*/\n#ifdef EXPLICIT_ERROR_PAGES\n#define ERROR_FORM(a,b) b\n#else /* EXPLICIT_ERROR_PAGES */\n#define ERROR_FORM(a,b) a\n#endif /* EXPLICIT_ERROR_PAGES */\n\n\nstatic char* ok200title = \"OK\";\nstatic char* ok206title = \"Partial Content\";\n\nstatic char* err302title = \"Found\";\nstatic char* err302form = \"The actual URL is '%.80s'.\\n\";\n\nstatic char* err304title = \"Not Modified\";\n\nchar* httpd_err400title = \"Bad Request\";\nchar* httpd_err400form =\n    \"Your request has bad syntax or is inherently impossible to satisfy.\\n\";\n\n#ifdef AUTH_FILE\nstatic char* err401title = \"Unauthorized\";\nstatic char* err401form =\n    \"Authorization required for the URL '%.80s'.\\n\";\n#endif /* AUTH_FILE */\n\nstatic char* err403title = \"Forbidden\";\n#ifndef EXPLICIT_ERROR_PAGES\nstatic char* err403form =\n    \"You do not have permission to get URL '%.80s' from this server.\\n\";\n#endif /* !EXPLICIT_ERROR_PAGES */\n\nstatic char* err404title = \"Not Found\";\nstatic char* err404form =\n    \"The requested URL '%.80s' was not found on this server.\\n\";\n\nchar* httpd_err408title = \"Request Timeout\";\nchar* httpd_err408form =\n    \"No request appeared within a reasonable time period.\\n\";\n\nstatic char* err500title = \"Internal Error\";\nstatic char* err500form =\n    \"There was an unusual problem serving the requested URL '%.80s'.\\n\";\n\nstatic char* err501title = \"Not Implemented\";\nstatic char* err501form =\n    \"The requested method '%.80s' is not implemented by this server.\\n\";\n\nchar* httpd_err503title = \"Service Temporarily Overloaded\";\nchar* httpd_err503form =\n    \"The requested URL '%.80s' is temporarily overloaded.  Please try again later.\\n\";\n\n\n/* Append a string to the buffer waiting to be sent as response. */\nstatic void\nadd_response( httpd_conn* hc, char* str )\n    {\n    size_t len;\n\n    len = strlen( str );\n    httpd_realloc_str( &hc->response, &hc->maxresponse, hc->responselen + len );\n    (void) memmove( &(hc->response[hc->responselen]), str, len );\n    hc->responselen += len;\n    }\n\n/* Send the buffered response. */\nvoid\nhttpd_write_response( httpd_conn* hc )\n    {\n    /* If we are in a sub-process, turn off no-delay mode. */\n    if ( sub_process )\n\thttpd_clear_ndelay( hc->conn_fd );\n    /* Send the response, if necessary. */\n    if ( hc->responselen > 0 )\n\t{\n\t(void) httpd_write_fully( hc->conn_fd, hc->response, hc->responselen );\n\thc->responselen = 0;\n\t}\n    }\n\n\n/* Set no-delay / non-blocking mode on a socket. */\nvoid\nhttpd_set_ndelay( int fd )\n    {\n    int flags, newflags;\n\n    flags = fcntl( fd, F_GETFL, 0 );\n    if ( flags != -1 )\n\t{\n\tnewflags = flags | (int) O_NDELAY;\n\tif ( newflags != flags )\n\t    (void) fcntl( fd, F_SETFL, newflags );\n\t}\n    }\n\n\n/* Clear no-delay / non-blocking mode on a socket. */\nvoid\nhttpd_clear_ndelay( int fd )\n    {\n    int flags, newflags;\n\n    flags = fcntl( fd, F_GETFL, 0 );\n    if ( flags != -1 )\n\t{\n\tnewflags = flags & ~ (int) O_NDELAY;\n\tif ( newflags != flags )\n\t    (void) fcntl( fd, F_SETFL, newflags );\n\t}\n    }\n\n\nstatic void\nsend_mime( httpd_conn* hc, int status, char* title, char* encodings, char* extraheads, char* type, off_t length, time_t mod )\n    {\n    time_t now, expires;\n    const char* rfc1123fmt = \"%a, %d %b %Y %H:%M:%S GMT\";\n    char nowbuf[100];\n    char modbuf[100];\n    char expbuf[100];\n    char fixed_type[500];\n    char buf[1000];\n    int partial_content;\n    int s100;\n\n    hc->status = status;\n    hc->bytes_to_send = length;\n    if ( hc->mime_flag )\n\t{\n\tif ( status == 200 && hc->got_range &&\n\t     ( hc->last_byte_index >= hc->first_byte_index ) &&\n\t     ( ( hc->last_byte_index != length - 1 ) ||\n\t       ( hc->first_byte_index != 0 ) ) &&\n\t     ( hc->range_if == (time_t) -1 ||\n\t       hc->range_if == hc->sb.st_mtime ) )\n\t    {\n\t    partial_content = 1;\n\t    hc->status = status = 206;\n\t    title = ok206title;\n\t    }\n\telse\n\t    {\n\t    partial_content = 0;\n\t    hc->got_range = 0;\n\t    }\n\n\tnow = time( (time_t*) 0 );\n\tif ( mod == (time_t) 0 )\n\t    mod = now;\n\t(void) strftime( nowbuf, sizeof(nowbuf), rfc1123fmt, gmtime( &now ) );\n\t(void) strftime( modbuf, sizeof(modbuf), rfc1123fmt, gmtime( &mod ) );\n\t(void) my_snprintf(\n\t    fixed_type, sizeof(fixed_type), type, hc->hs->charset );\n\t(void) my_snprintf( buf, sizeof(buf),\n\t    \"%.20s %d %s\\015\\012Server: %s\\015\\012Content-Type: %s\\015\\012Date: %s\\015\\012Last-Modified: %s\\015\\012Accept-Ranges: bytes\\015\\012Connection: close\\015\\012\",\n\t    hc->protocol, status, title, EXPOSED_SERVER_SOFTWARE, fixed_type,\n\t    nowbuf, modbuf );\n\tadd_response( hc, buf );\n\ts100 = status / 100;\n\tif ( s100 != 2 && s100 != 3 )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Cache-Control: no-cache,no-store\\015\\012\" );\n\t    add_response( hc, buf );\n\t    }\n\tif ( encodings[0] != '\\0' )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Content-Encoding: %s\\015\\012\", encodings );\n\t    add_response( hc, buf );\n\t    }\n\tif ( partial_content )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Content-Range: bytes %lld-%lld/%lld\\015\\012Content-Length: %lld\\015\\012\",\n\t\t(int64_t) hc->first_byte_index, (int64_t) hc->last_byte_index,\n\t\t(int64_t) length,\n\t\t(int64_t) ( hc->last_byte_index - hc->first_byte_index + 1 ) );\n\t    add_response( hc, buf );\n\t    }\n\telse if ( length >= 0 )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Content-Length: %lld\\015\\012\", (int64_t) length );\n\t    add_response( hc, buf );\n\t    }\n\tif ( hc->hs->p3p[0] != '\\0' )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf), \"P3P: %s\\015\\012\", hc->hs->p3p );\n\t    add_response( hc, buf );\n\t    }\n\tif ( hc->hs->max_age >= 0 )\n\t    {\n\t    expires = now + hc->hs->max_age;\n\t    (void) strftime(\n\t\texpbuf, sizeof(expbuf), rfc1123fmt, gmtime( &expires ) );\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Cache-Control: max-age=%d\\015\\012Expires: %s\\015\\012\",\n\t\thc->hs->max_age, expbuf );\n\t    add_response( hc, buf );\n\t    }\n\tif ( extraheads[0] != '\\0' )\n\t    add_response( hc, extraheads );\n\tadd_response( hc, \"\\015\\012\" );\n\t}\n    }\n\n\nstatic int str_alloc_count = 0;\nstatic size_t str_alloc_size = 0;\n\nvoid\nhttpd_realloc_str( char** strP, size_t* maxsizeP, size_t size )\n    {\n    if ( *maxsizeP == 0 )\n\t{\n\t*maxsizeP = MAX( 200, size + 100 );\n\t*strP = NEW( char, *maxsizeP + 1 );\n\t++str_alloc_count;\n\tstr_alloc_size += *maxsizeP;\n\t}\n    else if ( size > *maxsizeP )\n\t{\n\tstr_alloc_size -= *maxsizeP;\n\t*maxsizeP = MAX( *maxsizeP * 2, size * 5 / 4 );\n\t*strP = RENEW( *strP, char, *maxsizeP + 1 );\n\tstr_alloc_size += *maxsizeP;\n\t}\n    else\n\treturn;\n    if ( *strP == (char*) 0 )\n\t{\n\tsyslog(\n\t    LOG_ERR, \"out of memory reallocating a string to %zu bytes\",\n\t    *maxsizeP );\n\texit( 1 );\n\t}\n    }\n\n\nstatic void\nsend_response( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg )\n    {\n    char defanged_arg[1000], buf[2000];\n\n    send_mime(\n\thc, status, title, \"\", extraheads, \"text/html; charset=%s\", (off_t) -1,\n\t(time_t) 0 );\n    (void) my_snprintf( buf, sizeof(buf), \"\\\n<HTML>\\n\\\n<HEAD><TITLE>%d %s</TITLE></HEAD>\\n\\\n<BODY BGCOLOR=\\\"#cc9999\\\" TEXT=\\\"#000000\\\" LINK=\\\"#2020ff\\\" VLINK=\\\"#4040cc\\\">\\n\\\n<H2>%d %s</H2>\\n\",\n\tstatus, title, status, title );\n    add_response( hc, buf );\n    defang( arg, defanged_arg, sizeof(defanged_arg) );\n    (void) my_snprintf( buf, sizeof(buf), form, defanged_arg );\n    add_response( hc, buf );\n    if ( match( \"**MSIE**\", hc->useragent ) )\n\t{\n\tint n;\n\tadd_response( hc, \"<!--\\n\" );\n\tfor ( n = 0; n < 6; ++n )\n\t    add_response( hc, \"Padding so that MSIE deigns to show this error instead of its own canned one.\\n\");\n\tadd_response( hc, \"-->\\n\" );\n\t}\n    send_response_tail( hc );\n    }\n\n\nstatic void\nsend_response_tail( httpd_conn* hc )\n    {\n    char buf[1000];\n\n    (void) my_snprintf( buf, sizeof(buf), \"\\\n<HR>\\n\\\n<ADDRESS><A HREF=\\\"%s\\\">%s</A></ADDRESS>\\n\\\n</BODY>\\n\\\n</HTML>\\n\",\n\tSERVER_ADDRESS, EXPOSED_SERVER_SOFTWARE );\n    add_response( hc, buf );\n    }\n\n\nstatic void\ndefang( char* str, char* dfstr, int dfsize )\n    {\n    char* cp1;\n    char* cp2;\n\n    for ( cp1 = str, cp2 = dfstr;\n\t  *cp1 != '\\0' && cp2 - dfstr < dfsize - 5;\n\t  ++cp1, ++cp2 )\n\t{\n\tswitch ( *cp1 )\n\t    {\n\t    case '<':\n\t    *cp2++ = '&';\n\t    *cp2++ = 'l';\n\t    *cp2++ = 't';\n\t    *cp2 = ';';\n\t    break;\n\t    case '>':\n\t    *cp2++ = '&';\n\t    *cp2++ = 'g';\n\t    *cp2++ = 't';\n\t    *cp2 = ';';\n\t    break;\n\t    default:\n\t    *cp2 = *cp1;\n\t    break;\n\t    }\n\t}\n    *cp2 = '\\0';\n    }\n\n\nvoid\nhttpd_send_err( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg )\n    {\n#ifdef ERR_DIR\n\n    char filename[1000];\n\n    /* Try virtual host error page. */\n    if ( hc->hs->vhost && hc->hostdir[0] != '\\0' )\n\t{\n\t(void) my_snprintf( filename, sizeof(filename),\n\t    \"%s/%s/err%d.html\", hc->hostdir, ERR_DIR, status );\n\tif ( send_err_file( hc, status, title, extraheads, filename ) )\n\t    return;\n\t}\n\n    /* Try server-wide error page. */\n    (void) my_snprintf( filename, sizeof(filename),\n\t\"%s/err%d.html\", ERR_DIR, status );\n    if ( send_err_file( hc, status, title, extraheads, filename ) )\n\treturn;\n\n    /* Fall back on built-in error page. */\n    send_response( hc, status, title, extraheads, form, arg );\n\n#else /* ERR_DIR */\n\n    send_response( hc, status, title, extraheads, form, arg );\n\n#endif /* ERR_DIR */\n    }\n\n\n#ifdef ERR_DIR\nstatic int\nsend_err_file( httpd_conn* hc, int status, char* title, char* extraheads, char* filename )\n    {\n    FILE* fp;\n    char buf[1000];\n    size_t r;\n\n    fp = fopen( filename, \"r\" );\n    if ( fp == (FILE*) 0 )\n\treturn 0;\n    send_mime(\n\thc, status, title, \"\", extraheads, \"text/html; charset=%s\", (off_t) -1,\n\t(time_t) 0 );\n    for (;;)\n\t{\n\tr = fread( buf, 1, sizeof(buf) - 1, fp );\n\tif ( r == 0 )\n\t    break;\n\tbuf[r] = '\\0';\n\tadd_response( hc, buf );\n\t}\n    (void) fclose( fp );\n\n#ifdef ERR_APPEND_SERVER_INFO\n    send_response_tail( hc );\n#endif /* ERR_APPEND_SERVER_INFO */\n\n    return 1;\n    }\n#endif /* ERR_DIR */\n\n\n#ifdef AUTH_FILE\n\nstatic void\nsend_authenticate( httpd_conn* hc, char* realm )\n    {\n    static char* header;\n    static size_t maxheader = 0;\n    static char headstr[] = \"WWW-Authenticate: Basic realm=\\\"\";\n\n    httpd_realloc_str(\n\t&header, &maxheader, sizeof(headstr) + strlen( realm ) + 3 );\n    (void) my_snprintf( header, maxheader, \"%s%s\\\"\\015\\012\", headstr, realm );\n    httpd_send_err( hc, 401, err401title, header, err401form, hc->encodedurl );\n    /* If the request was a POST then there might still be data to be read,\n    ** so we need to do a lingering close.\n    */\n    if ( hc->method == METHOD_POST )\n\thc->should_linger = 1;\n    }\n\n\n/* Base-64 decoding.  This represents binary data as printable ASCII\n** characters.  Three 8-bit binary bytes are turned into four 6-bit\n** values, like so:\n**\n**   [11111111]  [22222222]  [33333333]\n**\n**   [111111] [112222] [222233] [333333]\n**\n** Then the 6-bit values are represented using the characters \"A-Za-z0-9+/\".\n*/\n\nstatic int b64_decode_table[256] = {\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */\n    52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */\n    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */\n    15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */\n    -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */\n    41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* C0-CF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* D0-DF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* E0-EF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1   /* F0-FF */\n    };\n\n/* Do base-64 decoding on a string.  Ignore any non-base64 bytes.\n** Return the actual number of bytes generated.  The decoded size will\n** be at most 3/4 the size of the encoded, and may be smaller if there\n** are padding characters (blanks, newlines).\n*/\nstatic int\nb64_decode( const char* str, unsigned char* space, int size )\n    {\n    const char* cp;\n    int space_idx, phase;\n    int d, prev_d = 0;\n    unsigned char c;\n\n    space_idx = 0;\n    phase = 0;\n    for ( cp = str; *cp != '\\0'; ++cp )\n\t{\n\td = b64_decode_table[(int) *cp];\n\tif ( d != -1 )\n\t    {\n\t    switch ( phase )\n\t\t{\n\t\tcase 0:\n\t\t++phase;\n\t\tbreak;\n\t\tcase 1:\n\t\tc = ( ( prev_d << 2 ) | ( ( d & 0x30 ) >> 4 ) );\n\t\tif ( space_idx < size )\n\t\t    space[space_idx++] = c;\n\t\t++phase;\n\t\tbreak;\n\t\tcase 2:\n\t\tc = ( ( ( prev_d & 0xf ) << 4 ) | ( ( d & 0x3c ) >> 2 ) );\n\t\tif ( space_idx < size )\n\t\t    space[space_idx++] = c;\n\t\t++phase;\n\t\tbreak;\n\t\tcase 3:\n\t\tc = ( ( ( prev_d & 0x03 ) << 6 ) | d );\n\t\tif ( space_idx < size )\n\t\t    space[space_idx++] = c;\n\t\tphase = 0;\n\t\tbreak;\n\t\t}\n\t    prev_d = d;\n\t    }\n\t}\n    return space_idx;\n    }\n\n\n/* Returns -1 == unauthorized, 0 == no auth file, 1 = authorized. */\nstatic int\nauth_check( httpd_conn* hc, char* dirname  )\n    {\n    if ( hc->hs->global_passwd )\n\t{\n\tchar* topdir;\n\tif ( hc->hs->vhost && hc->hostdir[0] != '\\0' )\n\t    topdir = hc->hostdir;\n\telse\n\t    topdir = \".\";\n\tswitch ( auth_check2( hc, topdir ) )\n\t    {\n\t    case -1:\n\t    return -1;\n\t    case 1:\n\t    return 1;\n\t    }\n\t}\n    return auth_check2( hc, dirname );\n    }\n\n\n/* Returns -1 == unauthorized, 0 == no auth file, 1 = authorized. */\nstatic int\nauth_check2( httpd_conn* hc, char* dirname  )\n    {\n    static char* authpath;\n    static size_t maxauthpath = 0;\n    struct stat sb;\n    char authinfo[500];\n    char* authpass;\n    char* colon;\n    int l;\n    FILE* fp;\n    char line[500];\n    char* cryp;\n    static char* prevauthpath;\n    static size_t maxprevauthpath = 0;\n    static time_t prevmtime;\n    static char* prevuser;\n    static size_t maxprevuser = 0;\n    static char* prevcryp;\n    static size_t maxprevcryp = 0;\n    char *crypt_result;\n\n    /* Construct auth filename. */\n    httpd_realloc_str(\n\t&authpath, &maxauthpath, strlen( dirname ) + 1 + sizeof(AUTH_FILE) );\n    (void) my_snprintf( authpath, maxauthpath, \"%s/%s\", dirname, AUTH_FILE );\n\n    /* Does this directory have an auth file? */\n    if ( stat( authpath, &sb ) < 0 )\n\t/* Nope, let the request go through. */\n\treturn 0;\n\n    /* Does this request contain basic authorization info? */\n    if ( hc->authorization[0] == '\\0' ||\n\t strncmp( hc->authorization, \"Basic \", 6 ) != 0 )\n\t{\n\t/* Nope, return a 401 Unauthorized. */\n\tsend_authenticate( hc, dirname );\n\treturn -1;\n\t}\n\n    /* Decode it. */\n    l = b64_decode(\n\t&(hc->authorization[6]), (unsigned char*) authinfo,\n\tsizeof(authinfo) - 1 );\n    authinfo[l] = '\\0';\n    /* Split into user and password. */\n    authpass = strchr( authinfo, ':' );\n    if ( authpass == (char*) 0 )\n\t{\n\t/* No colon?  Bogus auth info. */\n\tsend_authenticate( hc, dirname );\n\treturn -1;\n\t}\n    *authpass++ = '\\0';\n    /* If there are more fields, cut them off. */\n    colon = strchr( authpass, ':' );\n    if ( colon != (char*) 0 )\n\t*colon = '\\0';\n\n    /* See if we have a cached entry and can use it. */\n    if ( maxprevauthpath != 0 &&\n\t strcmp( authpath, prevauthpath ) == 0 &&\n\t sb.st_mtime == prevmtime &&\n\t strcmp( authinfo, prevuser ) == 0 )\n\t{\n\t/* Yes.  Check against the cached encrypted password. */\n\tcrypt_result = crypt( authpass, prevcryp );\n\tif ( ! crypt_result )\n\t    return -1;\n\tif ( strcmp( crypt_result, prevcryp ) == 0 )\n\t    {\n\t    /* Ok! */\n\t    httpd_realloc_str(\n\t\t&hc->remoteuser, &hc->maxremoteuser, strlen( authinfo ) );\n\t    (void) strcpy( hc->remoteuser, authinfo );\n\t    return 1;\n\t    }\n\telse\n\t    {\n\t    /* No. */\n\t    send_authenticate( hc, dirname );\n\t    return -1;\n\t    }\n\t}\n\n    /* Open the password file. */\n    fp = fopen( authpath, \"r\" );\n    if ( fp == (FILE*) 0 )\n\t{\n\t/* The file exists but we can't open it?  Disallow access. */\n\tsyslog(\n\t    LOG_ERR, \"%.80s auth file %.80s could not be opened - %m\",\n\t    httpd_ntoa( &hc->client_addr ), authpath );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' is protected by an authentication file, but the authentication file cannot be opened.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Read it. */\n    while ( fgets( line, sizeof(line), fp ) != (char*) 0 )\n\t{\n\t/* Nuke newline. */\n\tl = strlen( line );\n\tif ( line[l - 1] == '\\n' )\n\t    line[l - 1] = '\\0';\n\t/* Split into user and encrypted password. */\n\tcryp = strchr( line, ':' );\n\tif ( cryp == (char*) 0 )\n\t    continue;\n\t*cryp++ = '\\0';\n\t/* Is this the right user? */\n\tif ( strcmp( line, authinfo ) == 0 )\n\t    {\n\t    /* Yes. */\n\t    (void) fclose( fp );\n\t    /* So is the password right? */\n\t    crypt_result = crypt( authpass, cryp );\n\t    if ( ! crypt_result )\n\t\treturn -1;\n\t    if ( strcmp( crypt_result, cryp ) == 0 )\n\t\t{\n\t\t/* Ok! */\n\t\thttpd_realloc_str(\n\t\t    &hc->remoteuser, &hc->maxremoteuser, strlen( line ) );\n\t\t(void) strcpy( hc->remoteuser, line );\n\t\t/* And cache this user's info for next time. */\n\t\thttpd_realloc_str(\n\t\t    &prevauthpath, &maxprevauthpath, strlen( authpath ) );\n\t\t(void) strcpy( prevauthpath, authpath );\n\t\tprevmtime = sb.st_mtime;\n\t\thttpd_realloc_str(\n\t\t    &prevuser, &maxprevuser, strlen( authinfo ) );\n\t\t(void) strcpy( prevuser, authinfo );\n\t\thttpd_realloc_str( &prevcryp, &maxprevcryp, strlen( cryp ) );\n\t\t(void) strcpy( prevcryp, cryp );\n\t\treturn 1;\n\t\t}\n\t    else\n\t\t{\n\t\t/* No. */\n\t\tsend_authenticate( hc, dirname );\n\t\treturn -1;\n\t\t}\n\t    }\n\t}\n\n    /* Didn't find that user.  Access denied. */\n    (void) fclose( fp );\n    send_authenticate( hc, dirname );\n    return -1;\n    }\n\n#endif /* AUTH_FILE */\n\n\nstatic void\nsend_dirredirect( httpd_conn* hc )\n    {\n    static char* location;\n    static char* header;\n    static size_t maxlocation = 0, maxheader = 0;\n    static char headstr[] = \"Location: \";\n\n    if ( hc->query[0] != '\\0')\n\t{\n\tchar* cp = strchr( hc->encodedurl, '?' );\n\tif ( cp != (char*) 0 )\t/* should always find it */\n\t    *cp = '\\0';\n\thttpd_realloc_str(\n\t    &location, &maxlocation,\n\t    strlen( hc->encodedurl ) + 2 + strlen( hc->query ) );\n\t(void) my_snprintf( location, maxlocation,\n\t    \"%s/?%s\", hc->encodedurl, hc->query );\n\t}\n    else\n\t{\n\thttpd_realloc_str(\n\t    &location, &maxlocation, strlen( hc->encodedurl ) + 1 );\n\t(void) my_snprintf( location, maxlocation,\n\t    \"%s/\", hc->encodedurl );\n\t}\n    httpd_realloc_str(\n\t&header, &maxheader, sizeof(headstr) + strlen( location ) );\n    (void) my_snprintf( header, maxheader,\n\t\"%s%s\\015\\012\", headstr, location );\n    send_response( hc, 302, err302title, header, err302form, location );\n    }\n\n\nchar*\nhttpd_method_str( int method )\n    {\n    switch ( method )\n\t{\n\tcase METHOD_GET: return \"GET\";\n\tcase METHOD_HEAD: return \"HEAD\";\n\tcase METHOD_POST: return \"POST\";\n\tdefault: return \"UNKNOWN\";\n\t}\n    }\n\n\nstatic int\nhexit( char c )\n    {\n    if ( c >= '0' && c <= '9' )\n\treturn c - '0';\n    if ( c >= 'a' && c <= 'f' )\n\treturn c - 'a' + 10;\n    if ( c >= 'A' && c <= 'F' )\n\treturn c - 'A' + 10;\n    return 0;           /* shouldn't happen, we're guarded by isxdigit() */\n    }\n\n\n/* Copies and decodes a string.  It's ok for from and to to be the\n** same string.\n*/\nstatic void\nstrdecode( char* to, char* from )\n    {\n    for ( ; *from != '\\0'; ++to, ++from )\n\t{\n\tif ( from[0] == '%' && isxdigit( from[1] ) && isxdigit( from[2] ) )\n\t    {\n\t    *to = hexit( from[1] ) * 16 + hexit( from[2] );\n\t    from += 2;\n\t    }\n\telse\n\t    *to = *from;\n\t}\n    *to = '\\0';\n    }\n\n\n#ifdef GENERATE_INDEXES\n/* Copies and encodes a string. */\nstatic void\nstrencode( char* to, int tosize, char* from )\n    {\n    int tolen;\n\n    for ( tolen = 0; *from != '\\0' && tolen + 4 < tosize; ++from )\n\t{\n\tif ( isalnum(*from) || strchr( \"/_.-~\", *from ) != (char*) 0 )\n\t    {\n\t    *to = *from;\n\t    ++to;\n\t    ++tolen;\n\t    }\n\telse\n\t    {\n\t    (void) sprintf( to, \"%%%02x\", (int) *from & 0xff );\n\t    to += 3;\n\t    tolen += 3;\n\t    }\n\t}\n    *to = '\\0';\n    }\n#endif /* GENERATE_INDEXES */\n\n\n#ifdef TILDE_MAP_1\n/* Map a ~username/whatever URL into <prefix>/username. */\nstatic int\ntilde_map_1( httpd_conn* hc )\n    {\n    static char* temp;\n    static size_t maxtemp = 0;\n    int len;\n    static char* prefix = TILDE_MAP_1;\n\n    len = strlen( hc->expnfilename ) - 1;\n    httpd_realloc_str( &temp, &maxtemp, len );\n    (void) strcpy( temp, &hc->expnfilename[1] );\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename, strlen( prefix ) + 1 + len );\n    (void) strcpy( hc->expnfilename, prefix );\n    if ( prefix[0] != '\\0' )\n\t(void) strcat( hc->expnfilename, \"/\" );\n    (void) strcat( hc->expnfilename, temp );\n    return 1;\n    }\n#endif /* TILDE_MAP_1 */\n\n#ifdef TILDE_MAP_2\n/* Map a ~username/whatever URL into <user's homedir>/<postfix>. */\nstatic int\ntilde_map_2( httpd_conn* hc )\n    {\n    static char* temp;\n    static size_t maxtemp = 0;\n    static char* postfix = TILDE_MAP_2;\n    char* cp;\n    struct passwd* pw;\n    char* alt;\n    char* rest;\n\n    /* Get the username. */\n    httpd_realloc_str( &temp, &maxtemp, strlen( hc->expnfilename ) - 1 );\n    (void) strcpy( temp, &hc->expnfilename[1] );\n    cp = strchr( temp, '/' );\n    if ( cp != (char*) 0 )\n\t*cp++ = '\\0';\n    else\n\tcp = \"\";\n\n    /* Get the passwd entry. */\n    pw = getpwnam( temp );\n    if ( pw == (struct passwd*) 0 )\n\treturn 0;\n\n    /* Set up altdir. */\n    httpd_realloc_str(\n\t&hc->altdir, &hc->maxaltdir,\n\tstrlen( pw->pw_dir ) + 1 + strlen( postfix ) );\n    (void) strcpy( hc->altdir, pw->pw_dir );\n    if ( postfix[0] != '\\0' )\n\t{\n\t(void) strcat( hc->altdir, \"/\" );\n\t(void) strcat( hc->altdir, postfix );\n\t}\n    alt = expand_symlinks( hc->altdir, &rest, 0, 1 );\n    if ( rest[0] != '\\0' )\n\treturn 0;\n    httpd_realloc_str( &hc->altdir, &hc->maxaltdir, strlen( alt ) );\n    (void) strcpy( hc->altdir, alt );\n\n    /* And the filename becomes altdir plus the post-~ part of the original. */\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename,\n\tstrlen( hc->altdir ) + 1 + strlen( cp ) );\n    (void) my_snprintf( hc->expnfilename, hc->maxexpnfilename,\n\t\"%s/%s\", hc->altdir, cp );\n\n    /* For this type of tilde mapping, we want to defeat vhost mapping. */\n    hc->tildemapped = 1;\n\n    return 1;\n    }\n#endif /* TILDE_MAP_2 */\n\n\n/* Virtual host mapping. */\nstatic int\nvhost_map( httpd_conn* hc )\n    {\n    httpd_sockaddr sa;\n    socklen_t sz;\n    static char* tempfilename;\n    static size_t maxtempfilename = 0;\n    char* cp1;\n    int len;\n#ifdef VHOST_DIRLEVELS\n    int i;\n    char* cp2;\n#endif /* VHOST_DIRLEVELS */\n\n    /* Figure out the virtual hostname. */\n    if ( hc->reqhost[0] != '\\0' )\n\thc->hostname = hc->reqhost;\n    else if ( hc->hdrhost[0] != '\\0' )\n\thc->hostname = hc->hdrhost;\n    else\n\t{\n\tsz = sizeof(sa);\n\tif ( getsockname( hc->conn_fd, &sa.sa, &sz ) < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"getsockname - %m\" );\n\t    return 0;\n\t    }\n\thc->hostname = httpd_ntoa( &sa );\n\t}\n    /* Pound it to lower case. */\n    for ( cp1 = hc->hostname; *cp1 != '\\0'; ++cp1 )\n\tif ( isupper( *cp1 ) )\n\t    *cp1 = tolower( *cp1 );\n\n    if ( hc->tildemapped )\n\treturn 1;\n\n    /* Figure out the host directory. */\n#ifdef VHOST_DIRLEVELS\n    httpd_realloc_str(\n\t&hc->hostdir, &hc->maxhostdir,\n\tstrlen( hc->hostname ) + 2 * VHOST_DIRLEVELS );\n    if ( strncmp( hc->hostname, \"www.\", 4 ) == 0 )\n\tcp1 = &hc->hostname[4];\n    else\n\tcp1 = hc->hostname;\n    for ( cp2 = hc->hostdir, i = 0; i < VHOST_DIRLEVELS; ++i )\n\t{\n\t/* Skip dots in the hostname.  If we don't, then we get vhost\n\t** directories in higher level of filestructure if dot gets\n\t** involved into path construction.  It's `while' used here instead\n\t** of `if' for it's possible to have a hostname formed with two\n\t** dots at the end of it.\n\t*/\n\twhile ( *cp1 == '.' )\n\t    ++cp1;\n\t/* Copy a character from the hostname, or '_' if we ran out. */\n\tif ( *cp1 != '\\0' )\n\t    *cp2++ = *cp1++;\n\telse\n\t    *cp2++ = '_';\n\t/* Copy a slash. */\n\t*cp2++ = '/';\n\t}\n    (void) strcpy( cp2, hc->hostname );\n#else /* VHOST_DIRLEVELS */\n    httpd_realloc_str( &hc->hostdir, &hc->maxhostdir, strlen( hc->hostname ) );\n    (void) strcpy( hc->hostdir, hc->hostname );\n#endif /* VHOST_DIRLEVELS */\n\n    /* Prepend hostdir to the filename. */\n    len = strlen( hc->expnfilename );\n    httpd_realloc_str( &tempfilename, &maxtempfilename, len );\n    (void) strcpy( tempfilename, hc->expnfilename );\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename,\n\tstrlen( hc->hostdir ) + 1 + len );\n    (void) strcpy( hc->expnfilename, hc->hostdir );\n    (void) strcat( hc->expnfilename, \"/\" );\n    (void) strcat( hc->expnfilename, tempfilename );\n    return 1;\n    }\n\n\n/* Expands all symlinks in the given filename, eliding ..'s and leading /'s.\n** Returns the expanded path (pointer to static string), or (char*) 0 on\n** errors.  Also returns, in the string pointed to by restP, any trailing\n** parts of the path that don't exist.\n**\n** This is a fairly nice little routine.  It handles any size filenames\n** without excessive mallocs.\n*/\nstatic char*\nexpand_symlinks( char* path, char** restP, int no_symlink_check, int tildemapped )\n    {\n    static char* checked;\n    static char* rest;\n    char link[5000];\n    static size_t maxchecked = 0, maxrest = 0;\n    size_t checkedlen, restlen, linklen, prevcheckedlen, prevrestlen;\n    int nlinks, i;\n    char* r;\n    char* cp1;\n    char* cp2;\n\n    if ( no_symlink_check )\n\t{\n\t/* If we are chrooted, we can actually skip the symlink-expansion,\n\t** since it's impossible to get out of the tree.  However, we still\n\t** need to do the pathinfo check, and the existing symlink expansion\n\t** code is a pretty reasonable way to do this.  So, what we do is\n\t** a single stat() of the whole filename - if it exists, then we\n\t** return it as is with nothing in restP.  If it doesn't exist, we\n\t** fall through to the existing code.\n\t**\n\t** One side-effect of this is that users can't symlink to central\n\t** approved CGIs any more.  The workaround is to use the central\n\t** URL for the CGI instead of a local symlinked one.\n\t*/\n\tstruct stat sb;\n\tif ( stat( path, &sb ) != -1 )\n\t    {\n\t    checkedlen = strlen( path );\n\t    httpd_realloc_str( &checked, &maxchecked, checkedlen );\n\t    (void) strcpy( checked, path );\n\t    /* Trim trailing slashes. */\n\t    while ( checkedlen && checked[checkedlen - 1] == '/' )\n\t\t{\n\t\tchecked[checkedlen - 1] = '\\0';\n\t\t--checkedlen;\n\t\t}\n\t    httpd_realloc_str( &rest, &maxrest, 0 );\n\t    rest[0] = '\\0';\n\t    *restP = rest;\n\t    return checked;\n\t    }\n\t}\n\n    /* Start out with nothing in checked and the whole filename in rest. */\n    httpd_realloc_str( &checked, &maxchecked, 1 );\n    checked[0] = '\\0';\n    checkedlen = 0;\n    restlen = strlen( path );\n    httpd_realloc_str( &rest, &maxrest, restlen );\n    (void) strcpy( rest, path );\n    if ( restlen && rest[restlen - 1] == '/' )\n\trest[--restlen] = '\\0';         /* trim trailing slash */\n    if ( ! tildemapped )\n\t/* Remove any leading slashes. */\n\twhile ( rest[0] == '/' )\n\t    {\n\t    /*One more for '\\0', one less for the eaten first*/\n\t    (void) memmove( rest, &(rest[1]), strlen(rest) );\n\t    --restlen;\n\t    }\n    r = rest;\n    nlinks = 0;\n\n    /* While there are still components to check... */\n    while ( restlen > 0 )\n\t{\n\t/* Save current checkedlen in case we get a symlink.  Save current\n\t** restlen in case we get a non-existant component.\n\t*/\n\tprevcheckedlen = checkedlen;\n\tprevrestlen = restlen;\n\n\t/* Grab one component from r and transfer it to checked. */\n\tcp1 = strchr( r, '/' );\n\tif ( cp1 != (char*) 0 )\n\t    {\n\t    i = cp1 - r;\n\t    if ( i == 0 )\n\t\t{\n\t\t/* Special case for absolute paths. */\n\t\thttpd_realloc_str( &checked, &maxchecked, checkedlen + 1 );\n\t\t(void) strncpy( &checked[checkedlen], r, 1 );\n\t\tcheckedlen += 1;\n\t\t}\n\t    else if ( strncmp( r, \"..\", MAX( i, 2 ) ) == 0 )\n\t\t{\n\t\t/* Ignore ..'s that go above the start of the path. */\n\t\tif ( checkedlen != 0 )\n\t\t    {\n\t\t    cp2 = strrchr( checked, '/' );\n\t\t    if ( cp2 == (char*) 0 )\n\t\t\tcheckedlen = 0;\n\t\t    else if ( cp2 == checked )\n\t\t\tcheckedlen = 1;\n\t\t    else\n\t\t\tcheckedlen = cp2 - checked;\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\thttpd_realloc_str( &checked, &maxchecked, checkedlen + 1 + i );\n\t\tif ( checkedlen > 0 && checked[checkedlen-1] != '/' )\n\t\t    checked[checkedlen++] = '/';\n\t\t(void) strncpy( &checked[checkedlen], r, i );\n\t\tcheckedlen += i;\n\t\t}\n\t    checked[checkedlen] = '\\0';\n\t    r += i + 1;\n\t    restlen -= i + 1;\n\t    }\n\telse\n\t    {\n\t    /* No slashes remaining, r is all one component. */\n\t    if ( strcmp( r, \"..\" ) == 0 )\n\t\t{\n\t\t/* Ignore ..'s that go above the start of the path. */\n\t\tif ( checkedlen != 0 )\n\t\t    {\n\t\t    cp2 = strrchr( checked, '/' );\n\t\t    if ( cp2 == (char*) 0 )\n\t\t\tcheckedlen = 0;\n\t\t    else if ( cp2 == checked )\n\t\t\tcheckedlen = 1;\n\t\t    else\n\t\t\tcheckedlen = cp2 - checked;\n\t\t    checked[checkedlen] = '\\0';\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\thttpd_realloc_str(\n\t\t    &checked, &maxchecked, checkedlen + 1 + restlen );\n\t\tif ( checkedlen > 0 && checked[checkedlen-1] != '/' )\n\t\t    checked[checkedlen++] = '/';\n\t\t(void) strcpy( &checked[checkedlen], r );\n\t\tcheckedlen += restlen;\n\t\t}\n\t    r += restlen;\n\t    restlen = 0;\n\t    }\n\n\t/* Try reading the current filename as a symlink */\n\tif ( checked[0] == '\\0' )\n\t    continue;\n\tlinklen = readlink( checked, link, sizeof(link) - 1 );\n\tif ( linklen == -1 )\n\t    {\n\t    if ( errno == EINVAL )\n\t\tcontinue;               /* not a symlink */\n\t    if ( errno == EACCES || errno == ENOENT || errno == ENOTDIR )\n\t\t{\n\t\t/* That last component was bogus.  Restore and return. */\n\t\t*restP = r - ( prevrestlen - restlen );\n\t\tif ( prevcheckedlen == 0 )\n\t\t    (void) strcpy( checked, \".\" );\n\t\telse\n\t\t    checked[prevcheckedlen] = '\\0';\n\t\treturn checked;\n\t\t}\n\t    syslog( LOG_ERR, \"readlink %.80s - %m\", checked );\n\t    return (char*) 0;\n\t    }\n\t++nlinks;\n\tif ( nlinks > MAX_LINKS )\n\t    {\n\t    syslog( LOG_ERR, \"too many symlinks in %.80s\", path );\n\t    return (char*) 0;\n\t    }\n\tlink[linklen] = '\\0';\n\tif ( link[linklen - 1] == '/' )\n\t    link[--linklen] = '\\0';     /* trim trailing slash */\n\n\t/* Insert the link contents in front of the rest of the filename. */\n\tif ( restlen != 0 )\n\t    {\n\t    (void) strcpy( rest, r );\n\t    httpd_realloc_str( &rest, &maxrest, restlen + linklen + 1 );\n\t    for ( i = restlen; i >= 0; --i )\n\t\trest[i + linklen + 1] = rest[i];\n\t    (void) strcpy( rest, link );\n\t    rest[linklen] = '/';\n\t    restlen += linklen + 1;\n\t    r = rest;\n\t    }\n\telse\n\t    {\n\t    /* There's nothing left in the filename, so the link contents\n\t    ** becomes the rest.\n\t    */\n\t    httpd_realloc_str( &rest, &maxrest, linklen );\n\t    (void) strcpy( rest, link );\n\t    restlen = linklen;\n\t    r = rest;\n\t    }\n\n\tif ( rest[0] == '/' )\n\t    {\n\t    /* There must have been an absolute symlink - zero out checked. */\n\t    checked[0] = '\\0';\n\t    checkedlen = 0;\n\t    }\n\telse\n\t    {\n\t    /* Re-check this component. */\n\t    checkedlen = prevcheckedlen;\n\t    checked[checkedlen] = '\\0';\n\t    }\n\t}\n\n    /* Ok. */\n    *restP = r;\n    if ( checked[0] == '\\0' )\n\t(void) strcpy( checked, \".\" );\n    return checked;\n    }\n\n\nint\nhttpd_get_conn( httpd_server* hs, int listen_fd, httpd_conn* hc )\n    {\n    httpd_sockaddr sa;\n    socklen_t sz;\n\n    if ( ! hc->initialized )\n\t{\n\thc->read_size = 0;\n\thttpd_realloc_str( &hc->read_buf, &hc->read_size, 500 );\n\thc->maxdecodedurl =\n\t    hc->maxorigfilename = hc->maxexpnfilename = hc->maxencodings =\n\t    hc->maxpathinfo = hc->maxquery = hc->maxaccept =\n\t    hc->maxaccepte = hc->maxreqhost = hc->maxhostdir =\n\t    hc->maxremoteuser = hc->maxresponse = 0;\n#ifdef TILDE_MAP_2\n\thc->maxaltdir = 0;\n#endif /* TILDE_MAP_2 */\n\thttpd_realloc_str( &hc->decodedurl, &hc->maxdecodedurl, 1 );\n\thttpd_realloc_str( &hc->origfilename, &hc->maxorigfilename, 1 );\n\thttpd_realloc_str( &hc->expnfilename, &hc->maxexpnfilename, 0 );\n\thttpd_realloc_str( &hc->encodings, &hc->maxencodings, 0 );\n\thttpd_realloc_str( &hc->pathinfo, &hc->maxpathinfo, 0 );\n\thttpd_realloc_str( &hc->query, &hc->maxquery, 0 );\n\thttpd_realloc_str( &hc->accept, &hc->maxaccept, 0 );\n\thttpd_realloc_str( &hc->accepte, &hc->maxaccepte, 0 );\n\thttpd_realloc_str( &hc->reqhost, &hc->maxreqhost, 0 );\n\thttpd_realloc_str( &hc->hostdir, &hc->maxhostdir, 0 );\n\thttpd_realloc_str( &hc->remoteuser, &hc->maxremoteuser, 0 );\n\thttpd_realloc_str( &hc->response, &hc->maxresponse, 0 );\n#ifdef TILDE_MAP_2\n\thttpd_realloc_str( &hc->altdir, &hc->maxaltdir, 0 );\n#endif /* TILDE_MAP_2 */\n\thc->initialized = 1;\n\t}\n\n    /* Accept the new connection. */\n    sz = sizeof(sa);\n    hc->conn_fd = accept( listen_fd, &sa.sa, &sz );\n    if ( hc->conn_fd < 0 )\n\t{\n\tif ( errno == EWOULDBLOCK )\n\t    return GC_NO_MORE;\n\tsyslog( LOG_ERR, \"accept - %m\" );\n\treturn GC_FAIL;\n\t}\n    if ( ! sockaddr_check( &sa ) )\n\t{\n\tsyslog( LOG_ERR, \"unknown sockaddr family\" );\n\tclose( hc->conn_fd );\n\thc->conn_fd = -1;\n\treturn GC_FAIL;\n\t}\n    (void) fcntl( hc->conn_fd, F_SETFD, 1 );\n    hc->hs = hs;\n    (void) memset( &hc->client_addr, 0, sizeof(hc->client_addr) );\n    (void) memmove( &hc->client_addr, &sa, sockaddr_len( &sa ) );\n    hc->read_idx = 0;\n    hc->checked_idx = 0;\n    hc->checked_state = CHST_FIRSTWORD;\n    hc->method = METHOD_UNKNOWN;\n    hc->status = 0;\n    hc->bytes_to_send = 0;\n    hc->bytes_sent = 0;\n    hc->encodedurl = \"\";\n    hc->decodedurl[0] = '\\0';\n    hc->protocol = \"UNKNOWN\";\n    hc->origfilename[0] = '\\0';\n    hc->expnfilename[0] = '\\0';\n    hc->encodings[0] = '\\0';\n    hc->pathinfo[0] = '\\0';\n    hc->query[0] = '\\0';\n    hc->referer = \"\";\n    hc->useragent = \"\";\n    hc->accept[0] = '\\0';\n    hc->accepte[0] = '\\0';\n    hc->acceptl = \"\";\n    hc->cookie = \"\";\n    hc->contenttype = \"\";\n    hc->reqhost[0] = '\\0';\n    hc->hdrhost = \"\";\n    hc->hostdir[0] = '\\0';\n    hc->authorization = \"\";\n    hc->remoteuser[0] = '\\0';\n    hc->response[0] = '\\0';\n#ifdef TILDE_MAP_2\n    hc->altdir[0] = '\\0';\n#endif /* TILDE_MAP_2 */\n    hc->responselen = 0;\n    hc->if_modified_since = (time_t) -1;\n    hc->range_if = (time_t) -1;\n    hc->contentlength = -1;\n    hc->type = \"\";\n    hc->hostname = (char*) 0;\n    hc->mime_flag = 1;\n    hc->one_one = 0;\n    hc->got_range = 0;\n    hc->tildemapped = 0;\n    hc->first_byte_index = 0;\n    hc->last_byte_index = -1;\n    hc->keep_alive = 0;\n    hc->should_linger = 0;\n    hc->file_address = (char*) 0;\n    return GC_OK;\n    }\n\n\n/* Checks hc->read_buf to see whether a complete request has been read so far;\n** either the first line has two words (an HTTP/0.9 request), or the first\n** line has three words and there's a blank line present.\n**\n** hc->read_idx is how much has been read in; hc->checked_idx is how much we\n** have checked so far; and hc->checked_state is the current state of the\n** finite state machine.\n*/\nint\nhttpd_got_request( httpd_conn* hc )\n    {\n    char c;\n\n    for ( ; hc->checked_idx < hc->read_idx; ++hc->checked_idx )\n\t{\n\tc = hc->read_buf[hc->checked_idx];\n\tswitch ( hc->checked_state )\n\t    {\n\t    case CHST_FIRSTWORD:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\thc->checked_state = CHST_FIRSTWS;\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\t}\n\t    break;\n\t    case CHST_FIRSTWS:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_SECONDWORD;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_SECONDWORD:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\thc->checked_state = CHST_SECONDWS;\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\t/* The first line has only two words - an HTTP/0.9 request. */\n\t\treturn GR_GOT_REQUEST;\n\t\t}\n\t    break;\n\t    case CHST_SECONDWS:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_THIRDWORD;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_THIRDWORD:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\thc->checked_state = CHST_THIRDWS;\n\t\tbreak;\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_LF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_THIRDWS:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\tbreak;\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_LF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\tdefault:\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\t}\n\t    break;\n\t    case CHST_LINE:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_LF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_LF:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\t/* Two newlines in a row - a blank line - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_CR:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_CRLF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\t/* Two returns in a row - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_CRLF:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\t/* Two newlines in a row - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CRLFCR;\n\t\tbreak;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_CRLFCR:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012': case '\\015':\n\t\t/* Two CRLFs or two CRs in a row - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_BOGUS:\n\t    return GR_BAD_REQUEST;\n\t    }\n\t}\n    return GR_NO_REQUEST;\n    }\n\n\nint\nhttpd_parse_request( httpd_conn* hc )\n    {\n    char* buf;\n    char* method_str;\n    char* url;\n    char* protocol;\n    char* reqhost;\n    char* eol;\n    char* cp;\n    char* pi;\n\n    hc->checked_idx = 0;\t/* reset */\n    method_str = bufgets( hc );\n    url = strpbrk( method_str, \" \\t\\012\\015\" );\n    if ( url == (char*) 0 )\n\t{\n\thttpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\treturn -1;\n\t}\n    *url++ = '\\0';\n    url += strspn( url, \" \\t\\012\\015\" );\n    protocol = strpbrk( url, \" \\t\\012\\015\" );\n    if ( protocol == (char*) 0 )\n\t{\n\tprotocol = \"HTTP/0.9\";\n\thc->mime_flag = 0;\n\t}\n    else\n\t{\n\t*protocol++ = '\\0';\n\tprotocol += strspn( protocol, \" \\t\\012\\015\" );\n\tif ( *protocol != '\\0' )\n\t    {\n\t    eol = strpbrk( protocol, \" \\t\\012\\015\" );\n\t    if ( eol != (char*) 0 )\n\t\t*eol = '\\0';\n\t    if ( strcasecmp( protocol, \"HTTP/1.0\" ) != 0 )\n\t\thc->one_one = 1;\n\t    }\n\t}\n    hc->protocol = protocol;\n\n    /* Check for HTTP/1.1 absolute URL. */\n    if ( strncasecmp( url, \"http://\", 7 ) == 0 )\n\t{\n\tif ( ! hc->one_one )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\treqhost = url + 7;\n\turl = strchr( reqhost, '/' );\n\tif ( url == (char*) 0 )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\t*url = '\\0';\n\tif ( strchr( reqhost, '/' ) != (char*) 0 || reqhost[0] == '.' )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\thttpd_realloc_str( &hc->reqhost, &hc->maxreqhost, strlen( reqhost ) );\n\t(void) strcpy( hc->reqhost, reqhost );\n\t*url = '/';\n\t}\n\n    if ( *url != '/' )\n\t{\n\thttpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\treturn -1;\n\t}\n\n    if ( strcasecmp( method_str, httpd_method_str( METHOD_GET ) ) == 0 )\n\thc->method = METHOD_GET;\n    else if ( strcasecmp( method_str, httpd_method_str( METHOD_HEAD ) ) == 0 )\n\thc->method = METHOD_HEAD;\n    else if ( strcasecmp( method_str, httpd_method_str( METHOD_POST ) ) == 0 )\n\thc->method = METHOD_POST;\n    else\n\t{\n\thttpd_send_err( hc, 501, err501title, \"\", err501form, method_str );\n\treturn -1;\n\t}\n\n    hc->encodedurl = url;\n    httpd_realloc_str(\n\t&hc->decodedurl, &hc->maxdecodedurl, strlen( hc->encodedurl ) );\n    strdecode( hc->decodedurl, hc->encodedurl );\n\n    httpd_realloc_str(\n\t&hc->origfilename, &hc->maxorigfilename, strlen( hc->decodedurl ) );\n    (void) strcpy( hc->origfilename, &hc->decodedurl[1] );\n    /* Special case for top-level URL. */\n    if ( hc->origfilename[0] == '\\0' )\n\t(void) strcpy( hc->origfilename, \".\" );\n\n    /* Extract query string from encoded URL. */\n    cp = strchr( hc->encodedurl, '?' );\n    if ( cp != (char*) 0 )\n\t{\n\t++cp;\n\thttpd_realloc_str( &hc->query, &hc->maxquery, strlen( cp ) );\n\t(void) strcpy( hc->query, cp );\n\t/* Remove query from (decoded) origfilename. */\n\tcp = strchr( hc->origfilename, '?' );\n\tif ( cp != (char*) 0 )\n\t    *cp = '\\0';\n\t}\n\n    de_dotdot( hc->origfilename );\n    if ( hc->origfilename[0] == '/' ||\n\t ( hc->origfilename[0] == '.' && hc->origfilename[1] == '.' &&\n\t   ( hc->origfilename[2] == '\\0' || hc->origfilename[2] == '/' ) ) )\n\t{\n\thttpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\treturn -1;\n\t}\n\n    if ( hc->mime_flag )\n\t{\n\t/* Read the MIME headers. */\n\twhile ( ( buf = bufgets( hc ) ) != (char*) 0 )\n\t    {\n\t    if ( buf[0] == '\\0' )\n\t\tbreak;\n\t    if ( strncasecmp( buf, \"Referer:\", 8 ) == 0 )\n\t\t{\n\t\tcp = &buf[8];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->referer = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"User-Agent:\", 11 ) == 0 )\n\t\t{\n\t\tcp = &buf[11];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->useragent = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Host:\", 5 ) == 0 )\n\t\t{\n\t\tcp = &buf[5];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->hdrhost = cp;\n\t\tcp = strchr( hc->hdrhost, ':' );\n\t\tif ( cp != (char*) 0 )\n\t\t    *cp = '\\0';\n\t\tif ( strchr( hc->hdrhost, '/' ) != (char*) 0 || hc->hdrhost[0] == '.' )\n\t\t    {\n\t\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t\t    return -1;\n\t\t    }\n\t\t}\n\t    else if ( strncasecmp( buf, \"Accept:\", 7 ) == 0 )\n\t\t{\n\t\tcp = &buf[7];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tif ( hc->accept[0] != '\\0' )\n\t\t    {\n\t\t    if ( strlen( hc->accept ) > 5000 )\n\t\t\t{\n\t\t\tsyslog(\n\t\t\t    LOG_ERR, \"%.80s way too much Accept: data\",\n\t\t\t    httpd_ntoa( &hc->client_addr ) );\n\t\t\tcontinue;\n\t\t\t}\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accept, &hc->maxaccept,\n\t\t\tstrlen( hc->accept ) + 2 + strlen( cp ) );\n\t\t    (void) strcat( hc->accept, \", \" );\n\t\t    }\n\t\telse\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accept, &hc->maxaccept, strlen( cp ) );\n\t\t(void) strcat( hc->accept, cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Accept-Encoding:\", 16 ) == 0 )\n\t\t{\n\t\tcp = &buf[16];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tif ( hc->accepte[0] != '\\0' )\n\t\t    {\n\t\t    if ( strlen( hc->accepte ) > 5000 )\n\t\t\t{\n\t\t\tsyslog(\n\t\t\t    LOG_ERR, \"%.80s way too much Accept-Encoding: data\",\n\t\t\t    httpd_ntoa( &hc->client_addr ) );\n\t\t\tcontinue;\n\t\t\t}\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accepte, &hc->maxaccepte,\n\t\t\tstrlen( hc->accepte ) + 2 + strlen( cp ) );\n\t\t    (void) strcat( hc->accepte, \", \" );\n\t\t    }\n\t\telse\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accepte, &hc->maxaccepte, strlen( cp ) );\n\t\t(void) strcpy( hc->accepte, cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Accept-Language:\", 16 ) == 0 )\n\t\t{\n\t\tcp = &buf[16];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->acceptl = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"If-Modified-Since:\", 18 ) == 0 )\n\t\t{\n\t\tcp = &buf[18];\n\t\thc->if_modified_since = tdate_parse( cp );\n\t\tif ( hc->if_modified_since == (time_t) -1 )\n\t\t    syslog( LOG_DEBUG, \"unparsable time: %.80s\", cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Cookie:\", 7 ) == 0 )\n\t\t{\n\t\tcp = &buf[7];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->cookie = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Range:\", 6 ) == 0 )\n\t\t{\n\t\t/* Only support %d- and %d-%d, not %d-%d,%d-%d or -%d. */\n\t\tif ( strchr( buf, ',' ) == (char*) 0 )\n\t\t    {\n\t\t    char* cp_dash;\n\t\t    cp = strpbrk( buf, \"=\" );\n\t\t    if ( cp != (char*) 0 )\n\t\t\t{\n\t\t\tcp_dash = strchr( cp + 1, '-' );\n\t\t\tif ( cp_dash != (char*) 0 && cp_dash != cp + 1 )\n\t\t\t    {\n\t\t\t    *cp_dash = '\\0';\n\t\t\t    hc->got_range = 1;\n\t\t\t    hc->first_byte_index = atoll( cp + 1 );\n\t\t\t    if ( hc->first_byte_index < 0 )\n\t\t\t\thc->first_byte_index = 0;\n\t\t\t    if ( isdigit( (int) cp_dash[1] ) )\n\t\t\t\t{\n\t\t\t\thc->last_byte_index = atoll( cp_dash + 1 );\n\t\t\t\tif ( hc->last_byte_index < 0 )\n\t\t\t\t    hc->last_byte_index = -1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    else if ( strncasecmp( buf, \"Range-If:\", 9 ) == 0 ||\n\t\t      strncasecmp( buf, \"If-Range:\", 9 ) == 0 )\n\t\t{\n\t\tcp = &buf[9];\n\t\thc->range_if = tdate_parse( cp );\n\t\tif ( hc->range_if == (time_t) -1 )\n\t\t    syslog( LOG_DEBUG, \"unparsable time: %.80s\", cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Content-Type:\", 13 ) == 0 )\n\t\t{\n\t\tcp = &buf[13];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->contenttype = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Content-Length:\", 15 ) == 0 )\n\t\t{\n\t\tcp = &buf[15];\n\t\thc->contentlength = atol( cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Authorization:\", 14 ) == 0 )\n\t\t{\n\t\tcp = &buf[14];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->authorization = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Connection:\", 11 ) == 0 )\n\t\t{\n\t\tcp = &buf[11];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tif ( strcasecmp( cp, \"keep-alive\" ) == 0 )\n\t\t    hc->keep_alive = 1;\n\t\t}\n\t    else if ( strncasecmp( buf, \"X-Forwarded-For:\", 16 ) == 0 )\n\t\t{ // Use real IP if available \n\t\tcp = &buf[16];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tinet_aton( cp, &(hc->client_addr.sa_in.sin_addr) );\n\t\t}\n#ifdef LOG_UNKNOWN_HEADERS\n\t    else if ( strncasecmp( buf, \"Accept-Charset:\", 15 ) == 0 ||\n\t\t      strncasecmp( buf, \"Accept-Language:\", 16 ) == 0 ||\n\t\t      strncasecmp( buf, \"Agent:\", 6 ) == 0 ||\n\t\t      strncasecmp( buf, \"Cache-Control:\", 14 ) == 0 ||\n\t\t      strncasecmp( buf, \"Cache-Info:\", 11 ) == 0 ||\n\t\t      strncasecmp( buf, \"Charge-To:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Client-IP:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Date:\", 5 ) == 0 ||\n\t\t      strncasecmp( buf, \"Extension:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Forwarded:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"From:\", 5 ) == 0 ||\n\t\t      strncasecmp( buf, \"HTTP-Version:\", 13 ) == 0 ||\n\t\t      strncasecmp( buf, \"Max-Forwards:\", 13 ) == 0 ||\n\t\t      strncasecmp( buf, \"Message-Id:\", 11 ) == 0 ||\n\t\t      strncasecmp( buf, \"MIME-Version:\", 13 ) == 0 ||\n\t\t      strncasecmp( buf, \"Negotiate:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Pragma:\", 7 ) == 0 ||\n\t\t      strncasecmp( buf, \"Proxy-Agent:\", 12 ) == 0 ||\n\t\t      strncasecmp( buf, \"Proxy-Connection:\", 17 ) == 0 ||\n\t\t      strncasecmp( buf, \"Security-Scheme:\", 16 ) == 0 ||\n\t\t      strncasecmp( buf, \"Session-Id:\", 11 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-Color:\", 9 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-CPU:\", 7 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-Disp:\", 8 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-OS:\", 6 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-Pixels:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"User:\", 5 ) == 0 ||\n\t\t      strncasecmp( buf, \"Via:\", 4 ) == 0 ||\n\t\t      strncasecmp( buf, \"X-\", 2 ) == 0 )\n\t\t; /* ignore */\n\t    else\n\t\tsyslog( LOG_DEBUG, \"unknown request header: %.80s\", buf );\n#endif /* LOG_UNKNOWN_HEADERS */\n\t    }\n\t}\n\n    if ( hc->one_one )\n\t{\n\t/* Check that HTTP/1.1 requests specify a host, as required. */\n\tif ( hc->reqhost[0] == '\\0' && hc->hdrhost[0] == '\\0' )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\n\t/* If the client wants to do keep-alives, it might also be doing\n\t** pipelining.  There's no way for us to tell.  Since we don't\n\t** implement keep-alives yet, if we close such a connection there\n\t** might be unread pipelined requests waiting.  So, we have to\n\t** do a lingering close.\n\t*/\n\tif ( hc->keep_alive )\n\t    hc->should_linger = 1;\n\t}\n\n    /* Ok, the request has been parsed.  Now we resolve stuff that\n    ** may require the entire request.\n    */\n\n    /* Copy original filename to expanded filename. */\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename, strlen( hc->origfilename ) );\n    (void) strcpy( hc->expnfilename, hc->origfilename );\n\n    /* Tilde mapping. */\n    if ( hc->expnfilename[0] == '~' )\n\t{\n#ifdef TILDE_MAP_1\n\tif ( ! tilde_map_1( hc ) )\n\t    {\n\t    httpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\t    return -1;\n\t    }\n#endif /* TILDE_MAP_1 */\n#ifdef TILDE_MAP_2\n\tif ( ! tilde_map_2( hc ) )\n\t    {\n\t    httpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\t    return -1;\n\t    }\n#endif /* TILDE_MAP_2 */\n\t}\n\n    /* Virtual host mapping. */\n    if ( hc->hs->vhost )\n\tif ( ! vhost_map( hc ) )\n\t    {\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\n    /* Expand all symbolic links in the filename.  This also gives us\n    ** any trailing non-existing components, for pathinfo.\n    */\n    cp = expand_symlinks( hc->expnfilename, &pi, hc->hs->no_symlink_check, hc->tildemapped );\n    if ( cp == (char*) 0 )\n\t{\n\thttpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\treturn -1;\n\t}\n    httpd_realloc_str( &hc->expnfilename, &hc->maxexpnfilename, strlen( cp ) );\n    (void) strcpy( hc->expnfilename, cp );\n    httpd_realloc_str( &hc->pathinfo, &hc->maxpathinfo, strlen( pi ) );\n    (void) strcpy( hc->pathinfo, pi );\n\n    /* Remove pathinfo stuff from the original filename too. */\n    if ( hc->pathinfo[0] != '\\0' )\n\t{\n\tint i;\n\ti = strlen( hc->origfilename ) - strlen( hc->pathinfo );\n\tif ( strcmp( &hc->origfilename[i], hc->pathinfo ) == 0 )\n\t    {\n\t    if ( i == 0 ) hc->origfilename[0] = '\\0';\n\t    else hc->origfilename[i - 1] = '\\0';\n\t    }\n\t}\n\n    /* If the expanded filename is an absolute path, check that it's still\n    ** within the current directory or the alternate directory.\n    */\n    if ( hc->expnfilename[0] == '/' )\n\t{\n\tif ( strncmp(\n\t\t hc->expnfilename, hc->hs->cwd, strlen( hc->hs->cwd ) ) == 0 )\n\t    {\n\t    /* Elide the current directory. */\n\t    (void) memmove(\n\t\thc->expnfilename, &hc->expnfilename[strlen( hc->hs->cwd )], strlen(hc->expnfilename) - strlen( hc->hs->cwd ) + 1 );\n\t    }\n#ifdef TILDE_MAP_2\n\telse if ( hc->altdir[0] != '\\0' &&\n\t\t  ( strncmp(\n\t\t       hc->expnfilename, hc->altdir,\n\t\t       strlen( hc->altdir ) ) == 0 &&\n\t\t    ( hc->expnfilename[strlen( hc->altdir )] == '\\0' ||\n\t\t      hc->expnfilename[strlen( hc->altdir )] == '/' ) ) )\n\t    {}\n#endif /* TILDE_MAP_2 */\n\telse\n\t    {\n\t    syslog(\n\t\tLOG_NOTICE, \"%.80s URL \\\"%.80s\\\" goes outside the web tree\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file outside the permitted web server directory tree.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t}\n\n    return 0;\n    }\n\n\nstatic char*\nbufgets( httpd_conn* hc )\n    {\n    int i;\n    char c;\n\n    for ( i = hc->checked_idx; hc->checked_idx < hc->read_idx; ++hc->checked_idx )\n\t{\n\tc = hc->read_buf[hc->checked_idx];\n\tif ( c == '\\012' || c == '\\015' )\n\t    {\n\t    hc->read_buf[hc->checked_idx] = '\\0';\n\t    ++hc->checked_idx;\n\t    if ( c == '\\015' && hc->checked_idx < hc->read_idx &&\n\t\t hc->read_buf[hc->checked_idx] == '\\012' )\n\t\t{\n\t\thc->read_buf[hc->checked_idx] = '\\0';\n\t\t++hc->checked_idx;\n\t\t}\n\t    return &(hc->read_buf[i]);\n\t    }\n\t}\n    return (char*) 0;\n    }\n\n\nstatic void\nde_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n\n    /* Collapse any multiple / sequences. */\n    while ( ( cp = strstr( file, \"//\") ) != (char*) 0 )\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n\n    /* Remove leading ./ and any /./ sequences. */\n    while ( strncmp( file, \"./\", 2 ) == 0 )\n\t(void) memmove( file, file + 2, strlen( file ) - 1 );\n    while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n\n    /* Alternate between removing leading ../ and removing xxx/../ */\n    for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n\n    /* Also elide any xxx/.. at the end. */\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }\n\n\nvoid\nhttpd_close_conn( httpd_conn* hc, struct timeval* nowP )\n    {\n    make_log_entry( hc, nowP );\n\n    if ( hc->file_address != (char*) 0 )\n\t{\n\tmmc_unmap( hc->file_address, &(hc->sb), nowP );\n\thc->file_address = (char*) 0;\n\t}\n    if ( hc->conn_fd >= 0 )\n\t{\n\t(void) close( hc->conn_fd );\n\thc->conn_fd = -1;\n\t}\n    }\n\nvoid\nhttpd_destroy_conn( httpd_conn* hc )\n{\n    if (hc->initialized) {\n\tfree(hc->read_buf);\n\tfree(hc->decodedurl);\n\tfree(hc->origfilename);\n\tfree(hc->expnfilename);\n\tfree(hc->encodings);\n\tfree(hc->pathinfo);\n\tfree(hc->query);\n\tfree(hc->accept);\n\tfree(hc->accepte);\n\tfree(hc->reqhost);\n\tfree(hc->hostdir);\n\tfree(hc->remoteuser);\n\tfree(hc->response);\n#ifdef TILDE_MAP_2\n\tfree(hc->altdir);\n#endif /* TILDE_MAP_2 */\n\thc->initialized = 0;\n    }\n}\n\n\nstruct mime_entry {\n    char* ext;\n    size_t ext_len;\n    char* val;\n    size_t val_len;\n    };\nstatic struct mime_entry enc_tab[] = {\n#include \"mime_encodings.h\"\n    };\nstatic const int n_enc_tab = sizeof(enc_tab) / sizeof(*enc_tab);\nstatic struct mime_entry typ_tab[] = {\n#include \"mime_types.h\"\n    };\nstatic const int n_typ_tab = sizeof(typ_tab) / sizeof(*typ_tab);\n\n\n/* qsort comparison routine - declared old-style on purpose, for portability. */\nstatic int\next_compare( a, b )\n    struct mime_entry* a;\n    struct mime_entry* b;\n    {\n    return strcmp( a->ext, b->ext );\n    }\n\n\nstatic void\ninit_mime( void )\n    {\n    int i;\n\n    /* Sort the tables so we can do binary search. */\n    qsort( enc_tab, n_enc_tab, sizeof(*enc_tab), ext_compare );\n    qsort( typ_tab, n_typ_tab, sizeof(*typ_tab), ext_compare );\n\n    /* Fill in the lengths. */\n    for ( i = 0; i < n_enc_tab; ++i )\n\t{\n\tenc_tab[i].ext_len = strlen( enc_tab[i].ext );\n\tenc_tab[i].val_len = strlen( enc_tab[i].val );\n\t}\n    for ( i = 0; i < n_typ_tab; ++i )\n\t{\n\ttyp_tab[i].ext_len = strlen( typ_tab[i].ext );\n\ttyp_tab[i].val_len = strlen( typ_tab[i].val );\n\t}\n\n    }\n\n\n/* Figure out MIME encodings and type based on the filename.  Multiple\n** encodings are separated by commas, and are listed in the order in\n** which they were applied to the file.\n*/\nstatic void\nfigure_mime( httpd_conn* hc )\n    {\n    char* prev_dot;\n    char* dot;\n    char* ext;\n    int me_indexes[100], n_me_indexes;\n    size_t ext_len, encodings_len;\n    int i, top, bot, mid;\n    int r;\n    char* default_type = \"application/octet-stream\";\n\n    /* Peel off encoding extensions until there aren't any more. */\n    n_me_indexes = 0;\n    hc->type = default_type;\n    for ( prev_dot = &hc->expnfilename[strlen(hc->expnfilename)]; ; prev_dot = dot )\n\t{\n\tfor ( dot = prev_dot - 1; dot >= hc->expnfilename && *dot != '.'; --dot )\n\t    ;\n\tif ( dot < hc->expnfilename )\n\t    {\n\t    /* No dot found.  No more extensions.  */\n\t    goto done;\n\t    }\n\text = dot + 1;\n\text_len = prev_dot - ext;\n\t/* Search the encodings table.  Linear search is fine here, there\n\t** are only a few entries.\n\t*/\n\tfor ( i = 0; i < n_enc_tab; ++i )\n\t    {\n\t    if ( ext_len == enc_tab[i].ext_len && strncasecmp( ext, enc_tab[i].ext, ext_len ) == 0 )\n\t\t{\n\t\tif ( n_me_indexes < sizeof(me_indexes)/sizeof(*me_indexes) )\n\t\t    {\n\t\t    me_indexes[n_me_indexes] = i;\n\t\t    ++n_me_indexes;\n\t\t    }\n\t\tbreak;\n\t\t}\n\t    }\n\t/* Binary search for a matching type extension. */\n\ttop = n_typ_tab - 1;\n\tbot = 0;\n\twhile ( top >= bot )\n\t    {\n\t    mid = ( top + bot ) / 2;\n\t    r = strncasecmp( ext, typ_tab[mid].ext, ext_len );\n\t    if ( r < 0 )\n\t\ttop = mid - 1;\n\t    else if ( r > 0 )\n\t\tbot = mid + 1;\n\t    else\n\t\tif ( ext_len < typ_tab[mid].ext_len )\n\t\t    top = mid - 1;\n\t\telse if ( ext_len > typ_tab[mid].ext_len )\n\t\t    bot = mid + 1;\n\t\telse\n\t\t    {\n\t\t    hc->type = typ_tab[mid].val;\n\t\t    goto done;\n\t\t    }\n\t    }\n\t}\n\n    done:\n\n    /* The last thing we do is actually generate the mime-encoding header. */\n    hc->encodings[0] = '\\0';\n    encodings_len = 0;\n    for ( i = n_me_indexes - 1; i >= 0; --i )\n\t{\n\thttpd_realloc_str(\n\t    &hc->encodings, &hc->maxencodings,\n\t    encodings_len + enc_tab[me_indexes[i]].val_len + 1 );\n\tif ( hc->encodings[0] != '\\0' )\n\t    {\n\t    (void) strcpy( &hc->encodings[encodings_len], \",\" );\n\t    ++encodings_len;\n\t    }\n\t(void) strcpy( &hc->encodings[encodings_len], enc_tab[me_indexes[i]].val );\n\tencodings_len += enc_tab[me_indexes[i]].val_len;\n\t}\n\n    }\n\n\n#ifdef CGI_TIMELIMIT\nstatic void\ncgi_kill2( ClientData client_data, struct timeval* nowP )\n    {\n    pid_t pid;\n\n    pid = (pid_t) client_data.i;\n    if ( kill( pid, SIGKILL ) == 0 )\n\tsyslog( LOG_ERR, \"hard-killed CGI process %d\", pid );\n    }\n\nstatic void\ncgi_kill( ClientData client_data, struct timeval* nowP )\n    {\n    pid_t pid;\n\n    pid = (pid_t) client_data.i;\n    if ( kill( pid, SIGINT ) == 0 )\n\t{\n\tsyslog( LOG_ERR, \"killed CGI process %d\", pid );\n\t/* In case this isn't enough, schedule an uncatchable kill. */\n\tif ( tmr_create( nowP, cgi_kill2, client_data, 5 * 1000L, 0 ) == (Timer*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"tmr_create(cgi_kill2) failed\" );\n\t    exit( 1 );\n\t    }\n\t}\n    }\n#endif /* CGI_TIMELIMIT */\n\n\n#ifdef GENERATE_INDEXES\n\n/* qsort comparison routine - declared old-style on purpose, for portability. */\nstatic int\nname_compare( a, b )\n    char** a;\n    char** b;\n    {\n    return strcmp( *a, *b );\n    }\n\n\nstatic int\nls( httpd_conn* hc )\n    {\n    DIR* dirp;\n    struct dirent* de;\n    int namlen;\n    static int maxnames = 0;\n    int nnames;\n    static char* names;\n    static char** nameptrs;\n    static char* name;\n    static size_t maxname = 0;\n    static char* rname;\n    static size_t maxrname = 0;\n    static char* encrname;\n    static size_t maxencrname = 0;\n    FILE* fp;\n    int i, r;\n    struct stat sb;\n    struct stat lsb;\n    char modestr[20];\n    char* linkprefix;\n    char link[MAXPATHLEN+1];\n    int linklen;\n    char* fileclass;\n    time_t now;\n    char* timestr;\n    ClientData client_data;\n\n    dirp = opendir( hc->expnfilename );\n    if ( dirp == (DIR*) 0 )\n\t{\n\tsyslog( LOG_ERR, \"opendir %.80s - %m\", hc->expnfilename );\n\thttpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\treturn -1;\n\t}\n\n    if ( hc->method == METHOD_HEAD )\n\t{\n\tclosedir( dirp );\n\tsend_mime(\n\t    hc, 200, ok200title, \"\", \"\", \"text/html; charset=%s\", (off_t) -1,\n\t    hc->sb.st_mtime );\n\t}\n    else if ( hc->method == METHOD_GET )\n\t{\n\tif ( hc->hs->cgi_limit != 0 && hc->hs->cgi_count >= hc->hs->cgi_limit )\n\t    {\n\t    closedir( dirp );\n\t    httpd_send_err(\n\t\thc, 503, httpd_err503title, \"\", httpd_err503form,\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t++hc->hs->cgi_count;\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    closedir( dirp );\n\t    httpd_send_err(\n\t\thc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Child process. */\n\t    sub_process = 1;\n\t    httpd_unlisten( hc->hs );\n\t    send_mime(\n\t\thc, 200, ok200title, \"\", \"\", \"text/html; charset=%s\",\n\t\t(off_t) -1, hc->sb.st_mtime );\n\t    httpd_write_response( hc );\n\n#ifdef CGI_NICE\n\t    /* Set priority. */\n\t    (void) nice( CGI_NICE );\n#endif /* CGI_NICE */\n\n\t    /* Open a stdio stream so that we can use fprintf, which is more\n\t    ** efficient than a bunch of separate write()s.  We don't have\n\t    ** to worry about double closes or file descriptor leaks cause\n\t    ** we're in a subprocess.\n\t    */\n\t    fp = fdopen( hc->conn_fd, \"w\" );\n\t    if ( fp == (FILE*) 0 )\n\t\t{\n\t\tsyslog( LOG_ERR, \"fdopen - %m\" );\n\t\thttpd_send_err(\n\t\t    hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t\thttpd_write_response( hc );\n\t\tclosedir( dirp );\n\t\texit( 1 );\n\t\t}\n\n\t    (void) fprintf( fp, \"\\\n<HTML>\\n\\\n<HEAD><TITLE>Index of %.80s</TITLE></HEAD>\\n\\\n<BODY BGCOLOR=\\\"#99cc99\\\" TEXT=\\\"#000000\\\" LINK=\\\"#2020ff\\\" VLINK=\\\"#4040cc\\\">\\n\\\n<H2>Index of %.80s</H2>\\n\\\n<PRE>\\n\\\nmode  links  bytes  last-changed  name\\n\\\n<HR>\",\n\t\thc->encodedurl, hc->encodedurl );\n\n\t    /* Read in names. */\n\t    nnames = 0;\n\t    while ( ( de = readdir( dirp ) ) != 0 )     /* dirent or direct */\n\t\t{\n\t\tif ( nnames >= maxnames )\n\t\t    {\n\t\t    if ( maxnames == 0 )\n\t\t\t{\n\t\t\tmaxnames = 100;\n\t\t\tnames = NEW( char, maxnames * ( MAXPATHLEN + 1 ) );\n\t\t\tnameptrs = NEW( char*, maxnames );\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\tmaxnames *= 2;\n\t\t\tnames = RENEW( names, char, maxnames * ( MAXPATHLEN + 1 ) );\n\t\t\tnameptrs = RENEW( nameptrs, char*, maxnames );\n\t\t\t}\n\t\t    if ( names == (char*) 0 || nameptrs == (char**) 0 )\n\t\t\t{\n\t\t\tsyslog( LOG_ERR, \"out of memory reallocating directory names\" );\n\t\t\texit( 1 );\n\t\t\t}\n\t\t    for ( i = 0; i < maxnames; ++i )\n\t\t\tnameptrs[i] = &names[i * ( MAXPATHLEN + 1 )];\n\t\t    }\n\t\tnamlen = NAMLEN(de);\n\t\t(void) strncpy( nameptrs[nnames], de->d_name, namlen );\n\t\tnameptrs[nnames][namlen] = '\\0';\n\t\t++nnames;\n\t\t}\n\t    closedir( dirp );\n\n\t    /* Sort the names. */\n\t    qsort( nameptrs, nnames, sizeof(*nameptrs), name_compare );\n\n\t    /* Generate output. */\n\t    for ( i = 0; i < nnames; ++i )\n\t\t{\n\t\thttpd_realloc_str(\n\t\t    &name, &maxname,\n\t\t    strlen( hc->expnfilename ) + 1 + strlen( nameptrs[i] ) );\n\t\thttpd_realloc_str(\n\t\t    &rname, &maxrname,\n\t\t    strlen( hc->origfilename ) + 1 + strlen( nameptrs[i] ) );\n\t\tif ( hc->expnfilename[0] == '\\0' ||\n\t\t     strcmp( hc->expnfilename, \".\" ) == 0 )\n\t\t    {\n\t\t    (void) strcpy( name, nameptrs[i] );\n\t\t    (void) strcpy( rname, nameptrs[i] );\n\t\t    }\n\t\telse\n\t\t    {\n\t\t    (void) my_snprintf( name, maxname,\n\t\t\t\"%s/%s\", hc->expnfilename, nameptrs[i] );\n\t\t    if ( strcmp( hc->origfilename, \".\" ) == 0 )\n\t\t\t(void) my_snprintf( rname, maxrname,\n\t\t\t    \"%s\", nameptrs[i] );\n\t\t    else\n\t\t\t(void) my_snprintf( rname, maxrname,\n\t\t\t    \"%s%s\", hc->origfilename, nameptrs[i] );\n\t\t    }\n\t\thttpd_realloc_str(\n\t\t    &encrname, &maxencrname, 3 * strlen( rname ) + 1 );\n\t\tstrencode( encrname, maxencrname, rname );\n\n\t\tif ( stat( name, &sb ) < 0 || lstat( name, &lsb ) < 0 )\n\t\t    continue;\n\n\t\tlinkprefix = \"\";\n\t\tlink[0] = '\\0';\n\t\t/* Break down mode word.  First the file type. */\n\t\tswitch ( lsb.st_mode & S_IFMT )\n\t\t    {\n\t\t    case S_IFIFO:  modestr[0] = 'p'; break;\n\t\t    case S_IFCHR:  modestr[0] = 'c'; break;\n\t\t    case S_IFDIR:  modestr[0] = 'd'; break;\n\t\t    case S_IFBLK:  modestr[0] = 'b'; break;\n\t\t    case S_IFREG:  modestr[0] = '-'; break;\n\t\t    case S_IFSOCK: modestr[0] = 's'; break;\n\t\t    case S_IFLNK:  modestr[0] = 'l';\n\t\t    linklen = readlink( name, link, sizeof(link) - 1 );\n\t\t    if ( linklen != -1 )\n\t\t\t{\n\t\t\tlink[linklen] = '\\0';\n\t\t\tlinkprefix = \" -&gt; \";\n\t\t\t}\n\t\t    break;\n\t\t    default:       modestr[0] = '?'; break;\n\t\t    }\n\t\t/* Now the world permissions.  Owner and group permissions\n\t\t** are not of interest to web clients.\n\t\t*/\n\t\tmodestr[1] = ( lsb.st_mode & S_IROTH ) ? 'r' : '-';\n\t\tmodestr[2] = ( lsb.st_mode & S_IWOTH ) ? 'w' : '-';\n\t\tmodestr[3] = ( lsb.st_mode & S_IXOTH ) ? 'x' : '-';\n\t\tmodestr[4] = '\\0';\n\n\t\t/* We also leave out the owner and group name, they are\n\t\t** also not of interest to web clients.  Plus if we're\n\t\t** running under chroot(), they would require a copy\n\t\t** of /etc/passwd and /etc/group, which we want to avoid.\n\t\t*/\n\n\t\t/* Get time string. */\n\t\tnow = time( (time_t*) 0 );\n\t\ttimestr = ctime( &lsb.st_mtime );\n\t\ttimestr[ 0] = timestr[ 4];\n\t\ttimestr[ 1] = timestr[ 5];\n\t\ttimestr[ 2] = timestr[ 6];\n\t\ttimestr[ 3] = ' ';\n\t\ttimestr[ 4] = timestr[ 8];\n\t\ttimestr[ 5] = timestr[ 9];\n\t\ttimestr[ 6] = ' ';\n\t\tif ( now - lsb.st_mtime > 60*60*24*182 )        /* 1/2 year */\n\t\t    {\n\t\t    timestr[ 7] = ' ';\n\t\t    timestr[ 8] = timestr[20];\n\t\t    timestr[ 9] = timestr[21];\n\t\t    timestr[10] = timestr[22];\n\t\t    timestr[11] = timestr[23];\n\t\t    }\n\t\telse\n\t\t    {\n\t\t    timestr[ 7] = timestr[11];\n\t\t    timestr[ 8] = timestr[12];\n\t\t    timestr[ 9] = ':';\n\t\t    timestr[10] = timestr[14];\n\t\t    timestr[11] = timestr[15];\n\t\t    }\n\t\ttimestr[12] = '\\0';\n\n\t\t/* The ls -F file class. */\n\t\tswitch ( sb.st_mode & S_IFMT )\n\t\t    {\n\t\t    case S_IFDIR:  fileclass = \"/\"; break;\n\t\t    case S_IFSOCK: fileclass = \"=\"; break;\n\t\t    case S_IFLNK:  fileclass = \"@\"; break;\n\t\t    default:\n\t\t    fileclass = ( sb.st_mode & S_IXOTH ) ? \"*\" : \"\";\n\t\t    break;\n\t\t    }\n\n\t\t/* And print. */\n\t\t(void)  fprintf( fp,\n\t\t   \"%s %3ld  %10lld  %s  <A HREF=\\\"/%.500s%s\\\">%.80s</A>%s%s%s\\n\",\n\t\t    modestr, (long) lsb.st_nlink, (int64_t) lsb.st_size,\n\t\t    timestr, encrname, S_ISDIR(sb.st_mode) ? \"/\" : \"\",\n\t\t    nameptrs[i], linkprefix, link, fileclass );\n\t\t}\n\n\t    (void) fprintf( fp, \"</PRE></BODY>\\n</HTML>\\n\" );\n\t    (void) fclose( fp );\n\t    exit( 0 );\n\t    }\n\n\t/* Parent process. */\n\tclosedir( dirp );\n\tsyslog( LOG_INFO, \"spawned indexing process %d for directory '%.200s'\", r, hc->expnfilename );\n#ifdef CGI_TIMELIMIT\n\t/* Schedule a kill for the child process, in case it runs too long */\n\tclient_data.i = r;\n\tif ( tmr_create( (struct timeval*) 0, cgi_kill, client_data, CGI_TIMELIMIT * 1000L, 0 ) == (Timer*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"tmr_create(cgi_kill ls) failed\" );\n\t    exit( 1 );\n\t    }\n#endif /* CGI_TIMELIMIT */\n\thc->status = 200;\n\thc->bytes_sent = CGI_BYTECOUNT;\n\thc->should_linger = 0;\n\t}\n    else\n\t{\n\tclosedir( dirp );\n\thttpd_send_err(\n\t    hc, 501, err501title, \"\", err501form, httpd_method_str( hc->method ) );\n\treturn -1;\n\t}\n\n    return 0;\n    }\n\n#endif /* GENERATE_INDEXES */\n\n\nstatic char*\nbuild_env( char* fmt, char* arg )\n    {\n    char* cp;\n    size_t size;\n    static char* buf;\n    static size_t maxbuf = 0;\n\n    size = strlen( fmt ) + strlen( arg );\n    if ( size > maxbuf )\n\thttpd_realloc_str( &buf, &maxbuf, size );\n    (void) my_snprintf( buf, maxbuf, fmt, arg );\n    cp = strdup( buf );\n    if ( cp == (char*) 0 )\n\t{\n\tsyslog( LOG_ERR, \"out of memory copying environment variable\" );\n\texit( 1 );\n\t}\n    return cp;\n    }\n\n\n#ifdef SERVER_NAME_LIST\nstatic char*\nhostname_map( char* hostname )\n    {\n    int len, n;\n    static char* list[] = { SERVER_NAME_LIST };\n\n    len = strlen( hostname );\n    for ( n = sizeof(list) / sizeof(*list) - 1; n >= 0; --n )\n\tif ( strncasecmp( hostname, list[n], len ) == 0 )\n\t    if ( list[n][len] == '/' )  /* check in case of a substring match */\n\t\treturn &list[n][len + 1];\n    return (char*) 0;\n    }\n#endif /* SERVER_NAME_LIST */\n\n\n/* Set up environment variables. Be real careful here to avoid\n** letting malicious clients overrun a buffer.  We don't have\n** to worry about freeing stuff since we're a sub-process.\n*/\nstatic char**\nmake_envp( httpd_conn* hc )\n    {\n    static char* envp[50];\n    int envn;\n    char* cp;\n    char buf[256];\n\n    envn = 0;\n    envp[envn++] = build_env( \"PATH=%s\", CGI_PATH );\n#ifdef CGI_LD_LIBRARY_PATH\n    envp[envn++] = build_env( \"LD_LIBRARY_PATH=%s\", CGI_LD_LIBRARY_PATH );\n#endif /* CGI_LD_LIBRARY_PATH */\n    envp[envn++] = build_env( \"SERVER_SOFTWARE=%s\", SERVER_SOFTWARE );\n    /* If vhosting, use that server-name here. */\n    if ( hc->hs->vhost && hc->hostname != (char*) 0 )\n\tcp = hc->hostname;\n    else\n\tcp = hc->hs->server_hostname;\n    if ( cp != (char*) 0 )\n\tenvp[envn++] = build_env( \"SERVER_NAME=%s\", cp );\n    envp[envn++] = \"GATEWAY_INTERFACE=CGI/1.1\";\n    envp[envn++] = build_env(\"SERVER_PROTOCOL=%s\", hc->protocol);\n    (void) my_snprintf( buf, sizeof(buf), \"%d\", (int) hc->hs->port );\n    envp[envn++] = build_env( \"SERVER_PORT=%s\", buf );\n    envp[envn++] = build_env(\n\t\"REQUEST_METHOD=%s\", httpd_method_str( hc->method ) );\n    if ( hc->pathinfo[0] != '\\0' )\n\t{\n\tchar* cp2;\n\tsize_t l;\n\tenvp[envn++] = build_env( \"PATH_INFO=/%s\", hc->pathinfo );\n\tl = strlen( hc->hs->cwd ) + strlen( hc->pathinfo ) + 1;\n\tcp2 = NEW( char, l );\n\tif ( cp2 != (char*) 0 )\n\t    {\n\t    (void) my_snprintf( cp2, l, \"%s%s\", hc->hs->cwd, hc->pathinfo );\n\t    envp[envn++] = build_env( \"PATH_TRANSLATED=%s\", cp2 );\n\t    }\n\t}\n    envp[envn++] = build_env(\n\t\"SCRIPT_NAME=/%s\", strcmp( hc->origfilename, \".\" ) == 0 ?\n\t\"\" : hc->origfilename );\n    if ( hc->query[0] != '\\0')\n\tenvp[envn++] = build_env( \"QUERY_STRING=%s\", hc->query );\n    envp[envn++] = build_env(\n\t\"REMOTE_ADDR=%s\", httpd_ntoa( &hc->client_addr ) );\n    if ( hc->referer[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_REFERER=%s\", hc->referer );\n    if ( hc->useragent[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_USER_AGENT=%s\", hc->useragent );\n    if ( hc->accept[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_ACCEPT=%s\", hc->accept );\n    if ( hc->accepte[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_ACCEPT_ENCODING=%s\", hc->accepte );\n    if ( hc->acceptl[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_ACCEPT_LANGUAGE=%s\", hc->acceptl );\n    if ( hc->cookie[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_COOKIE=%s\", hc->cookie );\n    if ( hc->contenttype[0] != '\\0' )\n\tenvp[envn++] = build_env( \"CONTENT_TYPE=%s\", hc->contenttype );\n    if ( hc->hdrhost[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_HOST=%s\", hc->hdrhost );\n    if ( hc->contentlength != -1 )\n\t{\n\t(void) my_snprintf(\n\t    buf, sizeof(buf), \"%lu\", (unsigned long) hc->contentlength );\n\tenvp[envn++] = build_env( \"CONTENT_LENGTH=%s\", buf );\n\t}\n    if ( hc->remoteuser[0] != '\\0' )\n\tenvp[envn++] = build_env( \"REMOTE_USER=%s\", hc->remoteuser );\n    if ( hc->authorization[0] != '\\0' )\n\tenvp[envn++] = build_env( \"AUTH_TYPE=%s\", \"Basic\" );\n\t/* We only support Basic auth at the moment. */\n    if ( getenv( \"TZ\" ) != (char*) 0 )\n\tenvp[envn++] = build_env( \"TZ=%s\", getenv( \"TZ\" ) );\n    envp[envn++] = build_env( \"CGI_PATTERN=%s\", hc->hs->cgi_pattern );\n\n    envp[envn] = (char*) 0;\n    return envp;\n    }\n\n\n/* Set up argument vector.  Again, we don't have to worry about freeing stuff\n** since we're a sub-process.  This gets done after make_envp() because we\n** scribble on hc->query.\n*/\nstatic char**\nmake_argp( httpd_conn* hc )\n    {\n    char** argp;\n    int argn;\n    char* cp1;\n    char* cp2;\n\n    /* By allocating an arg slot for every character in the query, plus\n    ** one for the filename and one for the NULL, we are guaranteed to\n    ** have enough.  We could actually use strlen/2.\n    */\n    argp = NEW( char*, strlen( hc->query ) + 2 );\n    if ( argp == (char**) 0 )\n\treturn (char**) 0;\n\n    argp[0] = strrchr( hc->expnfilename, '/' );\n    if ( argp[0] != (char*) 0 )\n\t++argp[0];\n    else\n\targp[0] = hc->expnfilename;\n\n    argn = 1;\n    /* According to the CGI spec at http://hoohoo.ncsa.uiuc.edu/cgi/cl.html,\n    ** \"The server should search the query information for a non-encoded =\n    ** character to determine if the command line is to be used, if it finds\n    ** one, the command line is not to be used.\"\n    */\n    if ( strchr( hc->query, '=' ) == (char*) 0 )\n\t{\n\tfor ( cp1 = cp2 = hc->query; *cp2 != '\\0'; ++cp2 )\n\t    {\n\t    if ( *cp2 == '+' )\n\t\t{\n\t\t*cp2 = '\\0';\n\t\tstrdecode( cp1, cp1 );\n\t\targp[argn++] = cp1;\n\t\tcp1 = cp2 + 1;\n\t\t}\n\t    }\n\tif ( cp2 != cp1 )\n\t    {\n\t    strdecode( cp1, cp1 );\n\t    argp[argn++] = cp1;\n\t    }\n\t}\n\n    argp[argn] = (char*) 0;\n    return argp;\n    }\n\n\n/* This routine is used only for POST requests.  It reads the data\n** from the request and sends it to the child process.  The only reason\n** we need to do it this way instead of just letting the child read\n** directly is that we have already read part of the data into our\n** buffer.\n*/\nstatic void\ncgi_interpose_input( httpd_conn* hc, int wfd )\n    {\n    size_t c;\n    ssize_t r;\n    char buf[1024];\n\n    c = hc->read_idx - hc->checked_idx;\n    if ( c > 0 )\n\t{\n\tif ( httpd_write_fully( wfd, &(hc->read_buf[hc->checked_idx]), c ) != c )\n\t    return;\n\t}\n    while ( c < hc->contentlength )\n\t{\n\tr = read( hc->conn_fd, buf, MIN( sizeof(buf), hc->contentlength - c ) );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r <= 0 )\n\t    return;\n\tif ( httpd_write_fully( wfd, buf, r ) != r )\n\t    return;\n\tc += r;\n\t}\n    post_post_garbage_hack( hc );\n    }\n\n\n/* Special hack to deal with broken browsers that send a LF or CRLF\n** after POST data, causing TCP resets - we just read and discard up\n** to 2 bytes.  Unfortunately this doesn't fix the problem for CGIs\n** which avoid the interposer process due to their POST data being\n** short.  Creating an interposer process for all POST CGIs is\n** unacceptably expensive.  The eventual fix will come when interposing\n** gets integrated into the main loop as a tasklet instead of a process.\n*/\nstatic void\npost_post_garbage_hack( httpd_conn* hc )\n    {\n    char buf[2];\n\n    /* If we are in a sub-process, turn on no-delay mode in case we\n    ** previously cleared it.\n    */\n    if ( sub_process )\n\thttpd_set_ndelay( hc->conn_fd );\n    /* And read up to 2 bytes. */\n    (void) read( hc->conn_fd, buf, sizeof(buf) );\n    }\n\n\n/* This routine is used for parsed-header CGIs.  The idea here is that the\n** CGI can return special headers such as \"Status:\" and \"Location:\" which\n** change the return status of the response.  Since the return status has to\n** be the very first line written out, we have to accumulate all the headers\n** and check for the special ones before writing the status.  Then we write\n** out the saved headers and proceed to echo the rest of the response.\n*/\nstatic void\ncgi_interpose_output( httpd_conn* hc, int rfd )\n    {\n    int r;\n    char buf[1024];\n    size_t headers_size, headers_len;\n    char* headers;\n    char* br;\n    int status;\n    char* title;\n    char* cp;\n\n    /* Make sure the connection is in blocking mode.  It should already\n    ** be blocking, but we might as well be sure.\n    */\n    httpd_clear_ndelay( hc->conn_fd );\n\n    /* Slurp in all headers. */\n    headers_size = 0;\n    httpd_realloc_str( &headers, &headers_size, 500 );\n    headers_len = 0;\n    for (;;)\n\t{\n\tr = read( rfd, buf, sizeof(buf) );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r <= 0 )\n\t    {\n\t    br = &(headers[headers_len]);\n\t    break;\n\t    }\n\thttpd_realloc_str( &headers, &headers_size, headers_len + r );\n\t(void) memmove( &(headers[headers_len]), buf, r );\n\theaders_len += r;\n\theaders[headers_len] = '\\0';\n\tif ( ( br = strstr( headers, \"\\015\\012\\015\\012\" ) ) != (char*) 0 ||\n\t     ( br = strstr( headers, \"\\012\\012\" ) ) != (char*) 0 )\n\t    break;\n\t}\n\n    /* If there were no headers, bail. */\n    if ( headers[0] == '\\0' )\n\treturn;\n\n    /* Figure out the status.  Look for a Status: or Location: header;\n    ** else if there's an HTTP header line, get it from there; else\n    ** default to 200.\n    */\n    status = 200;\n    if ( strncmp( headers, \"HTTP/\", 5 ) == 0 )\n\t{\n\tcp = headers;\n\tcp += strcspn( cp, \" \\t\" );\n\tstatus = atoi( cp );\n\t}\n    if ( ( cp = strstr( headers, \"Status:\" ) ) != (char*) 0 &&\n\t cp < br &&\n\t ( cp == headers || *(cp-1) == '\\012' ) )\n\t{\n\tcp += 7;\n\tcp += strspn( cp, \" \\t\" );\n\tstatus = atoi( cp );\n\t}\n    else if ( ( cp = strstr( headers, \"Location:\" ) ) != (char*) 0 &&\n\t cp < br &&\n\t ( cp == headers || *(cp-1) == '\\012' ) )\n\tstatus = 302;\n\n    /* Write the status line. */\n    switch ( status )\n\t{\n\tcase 200: title = ok200title; break;\n\tcase 302: title = err302title; break;\n\tcase 304: title = err304title; break;\n\tcase 400: title = httpd_err400title; break;\n#ifdef AUTH_FILE\n\tcase 401: title = err401title; break;\n#endif /* AUTH_FILE */\n\tcase 403: title = err403title; break;\n\tcase 404: title = err404title; break;\n\tcase 408: title = httpd_err408title; break;\n\tcase 500: title = err500title; break;\n\tcase 501: title = err501title; break;\n\tcase 503: title = httpd_err503title; break;\n\tdefault: title = \"Something\"; break;\n\t}\n    (void) my_snprintf( buf, sizeof(buf), \"HTTP/1.0 %d %s\\015\\012\", status, title );\n    (void) httpd_write_fully( hc->conn_fd, buf, strlen( buf ) );\n\n    /* Write the saved headers. */\n    (void) httpd_write_fully( hc->conn_fd, headers, headers_len );\n\n    /* Echo the rest of the output. */\n    for (;;)\n\t{\n\tr = read( rfd, buf, sizeof(buf) );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r <= 0 )\n\t    break;\n\tif ( httpd_write_fully( hc->conn_fd, buf, r ) != r )\n\t    break;\n\t}\n    shutdown( hc->conn_fd, SHUT_WR );\n    }\n\n\n/* CGI child process. */\nstatic void\ncgi_child( httpd_conn* hc )\n    {\n    int r;\n    char** argp;\n    char** envp;\n    char* binary;\n    char* directory;\n\n    /* Unset close-on-exec flag for this socket.  This actually shouldn't\n    ** be necessary, according to POSIX a dup()'d file descriptor does\n    ** *not* inherit the close-on-exec flag, its flag is always clear.\n    ** However, Linux messes this up and does copy the flag to the\n    ** dup()'d descriptor, so we have to clear it.  This could be\n    ** ifdeffed for Linux only.\n    */\n    (void) fcntl( hc->conn_fd, F_SETFD, 0 );\n\n    /* Close the syslog descriptor so that the CGI program can't\n    ** mess with it.  All other open descriptors should be either\n    ** the listen socket(s), sockets from accept(), or the file-logging\n    ** fd, and all of those are set to close-on-exec, so we don't\n    ** have to close anything else.\n    */\n    closelog();\n\n    /* If the socket happens to be using one of the stdin/stdout/stderr\n    ** descriptors, move it to another descriptor so that the dup2 calls\n    ** below don't screw things up.  We arbitrarily pick fd 3 - if there\n    ** was already something on it, we clobber it, but that doesn't matter\n    ** since at this point the only fd of interest is the connection.\n    ** All others will be closed on exec.\n    */\n    if ( hc->conn_fd == STDIN_FILENO || hc->conn_fd == STDOUT_FILENO || hc->conn_fd == STDERR_FILENO )\n\t{\n\tint newfd = dup2( hc->conn_fd, STDERR_FILENO + 1 );\n\tif ( newfd >= 0 )\n\t    hc->conn_fd = newfd;\n\t/* If the dup2 fails, shrug.  We'll just take our chances.\n\t** Shouldn't happen though.\n\t*/\n\t}\n\n    /* Make the environment vector. */\n    envp = make_envp( hc );\n\n    /* Make the argument vector. */\n    argp = make_argp( hc );\n\n    /* Set up stdin.  For POSTs we may have to set up a pipe from an\n    ** interposer process, depending on if we've read some of the data\n    ** into our buffer.\n    */\n    if ( hc->method == METHOD_POST && hc->read_idx > hc->checked_idx )\n\t{\n\tint p[2];\n\n\tif ( pipe( p ) < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"pipe - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Interposer process. */\n\t    sub_process = 1;\n\t    (void) close( p[0] );\n\t    cgi_interpose_input( hc, p[1] );\n\t    exit( 0 );\n\t    }\n\t/* Need to schedule a kill for process r; but in the main process! */\n\t(void) close( p[1] );\n\tif ( p[0] != STDIN_FILENO )\n\t    {\n\t    (void) dup2( p[0], STDIN_FILENO );\n\t    (void) close( p[0] );\n\t    }\n\t}\n    else\n\t{\n\t/* Otherwise, the request socket is stdin. */\n\tif ( hc->conn_fd != STDIN_FILENO )\n\t    (void) dup2( hc->conn_fd, STDIN_FILENO );\n\t}\n\n    /* Set up stdout/stderr.  If we're doing CGI header parsing,\n    ** we need an output interposer too.\n    */\n    if ( strncmp( argp[0], \"nph-\", 4 ) != 0 && hc->mime_flag )\n\t{\n\tint p[2];\n\n\tif ( pipe( p ) < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"pipe - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Interposer process. */\n\t    sub_process = 1;\n\t    (void) close( p[1] );\n\t    cgi_interpose_output( hc, p[0] );\n\t    exit( 0 );\n\t    }\n\t/* Need to schedule a kill for process r; but in the main process! */\n\t(void) close( p[0] );\n\tif ( p[1] != STDOUT_FILENO )\n\t    (void) dup2( p[1], STDOUT_FILENO );\n\tif ( p[1] != STDERR_FILENO )\n\t    (void) dup2( p[1], STDERR_FILENO );\n\tif ( p[1] != STDOUT_FILENO && p[1] != STDERR_FILENO )\n\t    (void) close( p[1] );\n\t}\n    else\n\t{\n\t/* Otherwise, the request socket is stdout/stderr. */\n\tif ( hc->conn_fd != STDOUT_FILENO )\n\t    (void) dup2( hc->conn_fd, STDOUT_FILENO );\n\tif ( hc->conn_fd != STDERR_FILENO )\n\t    (void) dup2( hc->conn_fd, STDERR_FILENO );\n\t}\n\n    /* At this point we would like to set close-on-exec again for hc->conn_fd\n    ** (see previous comments on Linux's broken behavior re: close-on-exec\n    ** and dup.)  Unfortunately there seems to be another Linux problem, or\n    ** perhaps a different aspect of the same problem - if we do this\n    ** close-on-exec in Linux, the socket stays open but stderr gets\n    ** closed - the last fd duped from the socket.  What a mess.  So we'll\n    ** just leave the socket as is, which under other OSs means an extra\n    ** file descriptor gets passed to the child process.  Since the child\n    ** probably already has that file open via stdin stdout and/or stderr,\n    ** this is not a problem.\n    */\n    /* (void) fcntl( hc->conn_fd, F_SETFD, 1 ); */\n\n#ifdef CGI_NICE\n    /* Set priority. */\n    (void) nice( CGI_NICE );\n#endif /* CGI_NICE */\n\n    /* Split the program into directory and binary, so we can chdir()\n    ** to the program's own directory.  This isn't in the CGI 1.1\n    ** spec, but it's what other HTTP servers do.\n    */\n    directory = strdup( hc->expnfilename );\n    if ( directory == (char*) 0 )\n\tbinary = hc->expnfilename;      /* ignore errors */\n    else\n\t{\n\tbinary = strrchr( directory, '/' );\n\tif ( binary == (char*) 0 )\n\t    binary = hc->expnfilename;\n\telse\n\t    {\n\t    *binary++ = '\\0';\n\t    (void) chdir( directory );  /* ignore errors */\n\t    }\n\t}\n\n    /* Default behavior for SIGPIPE. */\n#ifdef HAVE_SIGSET\n    (void) sigset( SIGPIPE, SIG_DFL );\n#else /* HAVE_SIGSET */\n    (void) signal( SIGPIPE, SIG_DFL );\n#endif /* HAVE_SIGSET */\n\n    /* Run the program. */\n    (void) execve( binary, argp, envp );\n\n    /* Something went wrong. */\n    syslog( LOG_ERR, \"execve %.80s - %m\", hc->expnfilename );\n    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n    httpd_write_response( hc );\n    exit( 1 );\n    }\n\n\nstatic int\ncgi( httpd_conn* hc )\n    {\n    int r;\n    ClientData client_data;\n\n    if ( hc->method == METHOD_GET || hc->method == METHOD_POST )\n\t{\n\tif ( hc->hs->cgi_limit != 0 && hc->hs->cgi_count >= hc->hs->cgi_limit )\n\t    {\n\t    httpd_send_err(\n\t\thc, 503, httpd_err503title, \"\", httpd_err503form,\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t++hc->hs->cgi_count;\n\thttpd_clear_ndelay( hc->conn_fd );\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    httpd_send_err(\n\t\thc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Child process. */\n\t    sub_process = 1;\n\t    httpd_unlisten( hc->hs );\n\t    cgi_child( hc );\n\t    }\n\n\t/* Parent process. */\n\tsyslog( LOG_INFO, \"spawned CGI process %d for file '%.200s'\", r, hc->expnfilename );\n#ifdef CGI_TIMELIMIT\n\t/* Schedule a kill for the child process, in case it runs too long */\n\tclient_data.i = r;\n\tif ( tmr_create( (struct timeval*) 0, cgi_kill, client_data, CGI_TIMELIMIT * 1000L, 0 ) == (Timer*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"tmr_create(cgi_kill child) failed\" );\n\t    exit( 1 );\n\t    }\n#endif /* CGI_TIMELIMIT */\n\thc->status = 200;\n\thc->bytes_sent = CGI_BYTECOUNT;\n\thc->should_linger = 0;\n\t}\n    else\n\t{\n\thttpd_send_err(\n\t    hc, 501, err501title, \"\", err501form, httpd_method_str( hc->method ) );\n\treturn -1;\n\t}\n\n    return 0;\n    }\n\n\nstatic int\nreally_start_request( httpd_conn* hc, struct timeval* nowP )\n    {\n    static char* indexname;\n    static size_t maxindexname = 0;\n    static const char* index_names[] = { INDEX_NAMES };\n    int i;\n#ifdef AUTH_FILE\n    static char* dirname;\n    static size_t maxdirname = 0;\n#endif /* AUTH_FILE */\n    size_t expnlen, indxlen;\n    char* cp;\n    char* pi;\n\n    expnlen = strlen( hc->expnfilename );\n\n    if ( hc->method != METHOD_GET && hc->method != METHOD_HEAD &&\n\t hc->method != METHOD_POST )\n\t{\n\thttpd_send_err(\n\t    hc, 501, err501title, \"\", err501form, httpd_method_str( hc->method ) );\n\treturn -1;\n\t}\n\n    /* Stat the file. */\n    if ( stat( hc->expnfilename, &hc->sb ) < 0 )\n\t{\n\thttpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Is it world-readable or world-executable?  We check explicitly instead\n    ** of just trying to open it, so that no one ever gets surprised by\n    ** a file that's not set world-readable and yet somehow is\n    ** readable by the HTTP server and therefore the *whole* world.\n    */\n    if ( ! ( hc->sb.st_mode & ( S_IROTH | S_IXOTH ) ) )\n\t{\n\tsyslog(\n\t    LOG_INFO,\n\t    \"%.80s URL \\\"%.80s\\\" resolves to a non world-readable file\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file that is not world-readable.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Is it a directory? */\n    if ( S_ISDIR(hc->sb.st_mode) )\n\t{\n\t/* If there's pathinfo, it's just a non-existent file. */\n\tif ( hc->pathinfo[0] != '\\0' )\n\t    {\n\t    httpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\t    return -1;\n\t    }\n\n\t/* Special handling for directory URLs that don't end in a slash.\n\t** We send back an explicit redirect with the slash, because\n\t** otherwise many clients can't build relative URLs properly.\n\t*/\n\tif ( strcmp( hc->origfilename, \"\" ) != 0 &&\n\t     strcmp( hc->origfilename, \".\" ) != 0 &&\n\t     hc->origfilename[strlen( hc->origfilename ) - 1] != '/' )\n\t    {\n\t    send_dirredirect( hc );\n\t    return -1;\n\t    }\n\n\t/* Check for an index file. */\n\tfor ( i = 0; i < sizeof(index_names) / sizeof(char*); ++i )\n\t    {\n\t    httpd_realloc_str(\n\t\t&indexname, &maxindexname,\n\t\texpnlen + 1 + strlen( index_names[i] ) );\n\t    (void) strcpy( indexname, hc->expnfilename );\n\t    indxlen = strlen( indexname );\n\t    if ( indxlen == 0 || indexname[indxlen - 1] != '/' )\n\t\t(void) strcat( indexname, \"/\" );\n\t    if ( strcmp( indexname, \"./\" ) == 0 )\n\t\tindexname[0] = '\\0';\n\t    (void) strcat( indexname, index_names[i] );\n\t    if ( stat( indexname, &hc->sb ) >= 0 )\n\t\tgoto got_one;\n\t    }\n\n\t/* Nope, no index file, so it's an actual directory request. */\n#ifdef GENERATE_INDEXES\n\t/* Directories must be readable for indexing. */\n\tif ( ! ( hc->sb.st_mode & S_IROTH ) )\n\t    {\n\t    syslog(\n\t\tLOG_INFO,\n\t\t\"%.80s URL \\\"%.80s\\\" tried to index a directory with indexing disabled\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a directory that has indexing disabled.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n#ifdef AUTH_FILE\n\t/* Check authorization for this directory. */\n\tif ( auth_check( hc, hc->expnfilename ) == -1 )\n\t    return -1;\n#endif /* AUTH_FILE */\n\t/* Referer check. */\n\tif ( ! check_referer( hc ) )\n\t    return -1;\n\t/* Ok, generate an index. */\n\treturn ls( hc );\n#else /* GENERATE_INDEXES */\n\tsyslog(\n\t    LOG_INFO, \"%.80s URL \\\"%.80s\\\" tried to index a directory\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' is a directory, and directory indexing is disabled on this server.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n#endif /* GENERATE_INDEXES */\n\n\tgot_one: ;\n\t/* Got an index file.  Expand symlinks again.  More pathinfo means\n\t** something went wrong.\n\t*/\n\tcp = expand_symlinks( indexname, &pi, hc->hs->no_symlink_check, hc->tildemapped );\n\tif ( cp == (char*) 0 || pi[0] != '\\0' )\n\t    {\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\texpnlen = strlen( cp );\n\thttpd_realloc_str( &hc->expnfilename, &hc->maxexpnfilename, expnlen );\n\t(void) strcpy( hc->expnfilename, cp );\n\n\t/* Now, is the index version world-readable or world-executable? */\n\tif ( ! ( hc->sb.st_mode & ( S_IROTH | S_IXOTH ) ) )\n\t    {\n\t    syslog(\n\t\tLOG_INFO,\n\t\t\"%.80s URL \\\"%.80s\\\" resolves to a non-world-readable index file\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' resolves to an index file that is not world-readable.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t}\n\n#ifdef AUTH_FILE\n    /* Check authorization for this directory. */\n    httpd_realloc_str( &dirname, &maxdirname, expnlen );\n    (void) strcpy( dirname, hc->expnfilename );\n    cp = strrchr( dirname, '/' );\n    if ( cp == (char*) 0 )\n\t(void) strcpy( dirname, \".\" );\n    else\n\t*cp = '\\0';\n    if ( auth_check( hc, dirname ) == -1 )\n\treturn -1;\n\n    /* Check if the filename is the AUTH_FILE itself - that's verboten. */\n    if ( expnlen == sizeof(AUTH_FILE) - 1 )\n\t{\n\tif ( strcmp( hc->expnfilename, AUTH_FILE ) == 0 )\n\t    {\n\t    syslog(\n\t\tLOG_NOTICE,\n\t\t\"%.80s URL \\\"%.80s\\\" tried to retrieve an auth file\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t}\n    else if ( expnlen >= sizeof(AUTH_FILE) &&\n\t      strcmp( &(hc->expnfilename[expnlen - sizeof(AUTH_FILE) + 1]), AUTH_FILE ) == 0 &&\n\t      hc->expnfilename[expnlen - sizeof(AUTH_FILE)] == '/' )\n\t{\n\tsyslog(\n\t    LOG_NOTICE,\n\t    \"%.80s URL \\\"%.80s\\\" tried to retrieve an auth file\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n#endif /* AUTH_FILE */\n\n    /* Referer check. */\n    if ( ! check_referer( hc ) )\n\treturn -1;\n\n    /* Is it world-executable and in the CGI area? */\n    if ( hc->hs->cgi_pattern != (char*) 0 &&\n\t ( hc->sb.st_mode & S_IXOTH ) &&\n\t match( hc->hs->cgi_pattern, hc->expnfilename ) )\n\treturn cgi( hc );\n\n    /* It's not CGI.  If it's executable or there's pathinfo, someone's\n    ** trying to either serve or run a non-CGI file as CGI.   Either case\n    ** is prohibited.\n    */\n    if ( hc->sb.st_mode & S_IXOTH )\n\t{\n\tsyslog(\n\t    LOG_NOTICE, \"%.80s URL \\\"%.80s\\\" is executable but isn't CGI\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file which is marked executable but is not a CGI file; retrieving it is forbidden.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n    if ( hc->pathinfo[0] != '\\0' )\n\t{\n\tsyslog(\n\t    LOG_INFO, \"%.80s URL \\\"%.80s\\\" has pathinfo but isn't CGI\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file plus CGI-style pathinfo, but the file is not a valid CGI file.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Fill in last_byte_index, if necessary. */\n    if ( hc->got_range &&\n\t ( hc->last_byte_index == -1 || hc->last_byte_index >= hc->sb.st_size ) )\n\thc->last_byte_index = hc->sb.st_size - 1;\n\n    figure_mime( hc );\n\n    if ( hc->method == METHOD_HEAD )\n\t{\n\tsend_mime(\n\t    hc, 200, ok200title, hc->encodings, \"\", hc->type, hc->sb.st_size,\n\t    hc->sb.st_mtime );\n\t}\n    else if ( hc->if_modified_since != (time_t) -1 &&\n\t hc->if_modified_since >= hc->sb.st_mtime )\n\t{\n\tsend_mime(\n\t    hc, 304, err304title, hc->encodings, \"\", hc->type, (off_t) -1,\n\t    hc->sb.st_mtime );\n\t}\n    else\n\t{\n\thc->file_address = mmc_map( hc->expnfilename, &(hc->sb), nowP );\n\tif ( hc->file_address == (char*) 0 )\n\t    {\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\tsend_mime(\n\t    hc, 200, ok200title, hc->encodings, \"\", hc->type, hc->sb.st_size,\n\t    hc->sb.st_mtime );\n\t}\n\n    return 0;\n    }\n\n\nint\nhttpd_start_request( httpd_conn* hc, struct timeval* nowP )\n    {\n    int r;\n\n    /* Really start the request. */\n    r = really_start_request( hc, nowP );\n\n    /* And return the status. */\n    return r;\n    }\n\n\nstatic void\nmake_log_entry( httpd_conn* hc, struct timeval* nowP )\n    {\n    char* ru;\n    char url[305];\n    char bytes[40];\n\n    if ( hc->hs->no_log )\n\treturn;\n\n    /* This is straight CERN Combined Log Format - the only tweak\n    ** being that if we're using syslog() we leave out the date, because\n    ** syslogd puts it in.  The included syslogtocern script turns the\n    ** results into true CERN format.\n    */\n\n    /* Format remote user. */\n    if ( hc->remoteuser[0] != '\\0' )\n\tru = hc->remoteuser;\n    else\n\tru = \"-\";\n    /* If we're vhosting, prepend the hostname to the url.  This is\n    ** a little weird, perhaps writing separate log files for\n    ** each vhost would make more sense.\n    */\n    if ( hc->hs->vhost && ! hc->tildemapped )\n\t(void) my_snprintf( url, sizeof(url),\n\t    \"/%.100s%.200s\",\n\t    hc->hostname == (char*) 0 ? hc->hs->server_hostname : hc->hostname,\n\t    hc->encodedurl );\n    else\n\t(void) my_snprintf( url, sizeof(url),\n\t    \"%.200s\", hc->encodedurl );\n    /* Format the bytes. */\n    if ( hc->bytes_sent >= 0 )\n\t(void) my_snprintf(\n\t    bytes, sizeof(bytes), \"%lld\", (int64_t) hc->bytes_sent );\n    else\n\t(void) strcpy( bytes, \"-\" );\n\n    /* Logfile or syslog? */\n    if ( hc->hs->logfp != (FILE*) 0 )\n\t{\n\ttime_t now;\n\tstruct tm* t;\n\tconst char* cernfmt_nozone = \"%d/%b/%Y:%H:%M:%S\";\n\tchar date_nozone[100];\n\tint zone;\n\tchar sign;\n\tchar date[100];\n\n\t/* Get the current time, if necessary. */\n\tif ( nowP != (struct timeval*) 0 )\n\t    now = nowP->tv_sec;\n\telse\n\t    now = time( (time_t*) 0 );\n\t/* Format the time, forcing a numeric timezone (some log analyzers\n\t** are stoooopid about this).\n\t*/\n\tt = localtime( &now );\n\t(void) strftime( date_nozone, sizeof(date_nozone), cernfmt_nozone, t );\n\tzone = t->tm_gmtoff / 60L;\n\tif ( zone >= 0 )\n\t    sign = '+';\n\telse\n\t    {\n\t    sign = '-';\n\t    zone = -zone;\n\t    }\n\tzone = ( zone / 60 ) * 100 + zone % 60;\n\t(void) my_snprintf( date, sizeof(date),\n\t    \"%s %c%04d\", date_nozone, sign, zone );\n\t/* And write the log entry. */\n\t(void) fprintf( hc->hs->logfp,\n\t    \"%.80s - %.80s [%s] \\\"%.80s %.300s %.80s\\\" %d %s \\\"%.200s\\\" \\\"%.200s\\\"\\n\",\n\t    httpd_ntoa( &hc->client_addr ), ru, date,\n\t    httpd_method_str( hc->method ), url, hc->protocol,\n\t    hc->status, bytes, hc->referer, hc->useragent );\n#ifdef FLUSH_LOG_EVERY_TIME\n\t(void) fflush( hc->hs->logfp );\n#endif\n\t}\n    else\n\tsyslog( LOG_INFO,\n\t    \"%.80s - %.80s \\\"%.80s %.200s %.80s\\\" %d %s \\\"%.200s\\\" \\\"%.200s\\\"\",\n\t    httpd_ntoa( &hc->client_addr ), ru,\n\t    httpd_method_str( hc->method ), url, hc->protocol,\n\t    hc->status, bytes, hc->referer, hc->useragent );\n    }\n\n\n/* Returns 1 if ok to serve the url, 0 if not. */\nstatic int\ncheck_referer( httpd_conn* hc )\n    {\n    int r;\n    char* cp;\n\n    /* Are we doing referer checking at all? */\n    if ( hc->hs->url_pattern == (char*) 0 )\n\treturn 1;\n\n    r = really_check_referer( hc );\n\n    if ( ! r )\n\t{\n\tif ( hc->hs->vhost && hc->hostname != (char*) 0 )\n\t    cp = hc->hostname;\n\telse\n\t    cp = hc->hs->server_hostname;\n\tif ( cp == (char*) 0 )\n\t    cp = \"\";\n\tsyslog(\n\t    LOG_INFO, \"%.80s non-local referer \\\"%.80s%.80s\\\" \\\"%.80s\\\"\",\n\t    httpd_ntoa( &hc->client_addr ), cp, hc->encodedurl, hc->referer );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"You must supply a local referer to get URL '%.80s' from this server.\\n\" ),\n\t    hc->encodedurl );\n\t}\n    return r;\n    }\n\n\n/* Returns 1 if ok to serve the url, 0 if not. */\nstatic int\nreally_check_referer( httpd_conn* hc )\n    {\n    httpd_server* hs;\n    char* cp1;\n    char* cp2;\n    char* cp3;\n    static char* refhost = (char*) 0;\n    static size_t refhost_size = 0;\n    char *lp;\n\n    hs = hc->hs;\n\n    /* Check for an empty referer. */\n    if ( hc->referer == (char*) 0 || hc->referer[0] == '\\0' ||\n\t ( cp1 = strstr( hc->referer, \"//\" ) ) == (char*) 0 )\n\t{\n\t/* Disallow if we require a referer and the url matches. */\n\tif ( hs->no_empty_referers && match( hs->url_pattern, hc->origfilename ) )\n\t    return 0;\n\t/* Otherwise ok. */\n\treturn 1;\n\t}\n\n    /* Extract referer host. */\n    cp1 += 2;\n    for ( cp2 = cp1; *cp2 != '/' && *cp2 != ':' && *cp2 != '\\0'; ++cp2 )\n\tcontinue;\n    httpd_realloc_str( &refhost, &refhost_size, cp2 - cp1 );\n    for ( cp3 = refhost; cp1 < cp2; ++cp1, ++cp3 )\n\tif ( isupper(*cp1) )\n\t    *cp3 = tolower(*cp1);\n\telse\n\t    *cp3 = *cp1;\n    *cp3 = '\\0';\n\n    /* Local pattern? */\n    if ( hs->local_pattern != (char*) 0 )\n\tlp = hs->local_pattern;\n    else\n\t{\n\t/* No local pattern.  What's our hostname? */\n\tif ( ! hs->vhost )\n\t    {\n\t    /* Not vhosting, use the server name. */\n\t    lp = hs->server_hostname;\n\t    if ( lp == (char*) 0 )\n\t\t/* Couldn't figure out local hostname - give up. */\n\t\treturn 1;\n\t    }\n\telse\n\t    {\n\t    /* We are vhosting, use the hostname on this connection. */\n\t    lp = hc->hostname;\n\t    if ( lp == (char*) 0 )\n\t\t/* Oops, no hostname.  Maybe it's an old browser that\n\t\t** doesn't send a Host: header.  We could figure out\n\t\t** the default hostname for this IP address, but it's\n\t\t** not worth it for the few requests like this.\n\t\t*/\n\t\treturn 1;\n\t    }\n\t}\n\n    /* If the referer host doesn't match the local host pattern, and\n    ** the filename does match the url pattern, it's an illegal reference.\n    */\n    if ( ! match( lp, refhost ) && match( hs->url_pattern, hc->origfilename ) )\n\treturn 0;\n    /* Otherwise ok. */\n    return 1;\n    }\n\n\nchar*\nhttpd_ntoa( httpd_sockaddr* saP )\n    {\n#ifdef USE_IPV6\n    static char str[200];\n\n    if ( getnameinfo( &saP->sa, sockaddr_len( saP ), str, sizeof(str), 0, 0, NI_NUMERICHOST ) != 0 )\n\t{\n\tstr[0] = '?';\n\tstr[1] = '\\0';\n\t}\n    else if ( IN6_IS_ADDR_V4MAPPED( &saP->sa_in6.sin6_addr ) && strncmp( str, \"::ffff:\", 7 ) == 0 )\n\t/* Elide IPv6ish prefix for IPv4 addresses. */\n\t(void) memmove( str, &str[7], strlen( str ) - 6 );\n\n    return str;\n\n#else /* USE_IPV6 */\n\n    return inet_ntoa( saP->sa_in.sin_addr );\n\n#endif /* USE_IPV6 */\n    }\n\n\nstatic int\nsockaddr_check( httpd_sockaddr* saP )\n    {\n    switch ( saP->sa.sa_family )\n\t{\n\tcase AF_INET: return 1;\n#ifdef USE_IPV6\n\tcase AF_INET6: return 1;\n#endif /* USE_IPV6 */\n\tdefault:\n\treturn 0;\n\t}\n    }\n\n\nstatic size_t\nsockaddr_len( httpd_sockaddr* saP )\n    {\n    switch ( saP->sa.sa_family )\n\t{\n\tcase AF_INET: return sizeof(struct sockaddr_in);\n#ifdef USE_IPV6\n\tcase AF_INET6: return sizeof(struct sockaddr_in6);\n#endif /* USE_IPV6 */\n\tdefault:\n\treturn 0;\t/* shouldn't happen */\n\t}\n    }\n\n\n/* Some systems don't have snprintf(), so we make our own that uses\n** either vsnprintf() or vsprintf().  If your system doesn't have\n** vsnprintf(), it is probably vulnerable to buffer overruns.\n** Upgrade!\n*/\nstatic int\nmy_snprintf( char* str, size_t size, const char* format, ... )\n    {\n    va_list ap;\n    int r;\n\n    va_start( ap, format );\n#ifdef HAVE_VSNPRINTF\n    r = vsnprintf( str, size, format, ap );\n#else /* HAVE_VSNPRINTF */\n    r = vsprintf( str, format, ap );\n#endif /* HAVE_VSNPRINTF */\n    va_end( ap );\n    return r;\n    }\n\n\n#ifndef HAVE_ATOLL\nstatic long long\natoll( const char* str )\n    {\n    long long value;\n    long long sign;\n\n    while ( isspace( *str ) )\n\t++str;\n    switch ( *str )\n\t{\n\tcase '-': sign = -1; ++str; break;\n\tcase '+': sign = 1; ++str; break;\n\tdefault: sign = 1; break;\n\t}\n    value = 0;\n    while ( isdigit( *str ) )\n\t{\n\tvalue = value * 10 + ( *str - '0' );\n\t++str;\n\t}\n    return sign * value;\n    }\n#endif /* HAVE_ATOLL */\n\n\n/* Read the requested buffer completely, accounting for interruptions. */\nint\nhttpd_read_fully( int fd, void* buf, size_t nbytes )\n    {\n    int nread;\n\n    nread = 0;\n    while ( nread < nbytes )\n\t{\n\tint r;\n\n\tr = read( fd, (char*) buf + nread, nbytes - nread );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r < 0 )\n\t    return r;\n\tif ( r == 0 )\n\t    break;\n\tnread += r;\n\t}\n\n    return nread;\n    }\n\n\n/* Write the requested buffer completely, accounting for interruptions. */\nint\nhttpd_write_fully( int fd, const void* buf, size_t nbytes )\n    {\n    int nwritten;\n\n    nwritten = 0;\n    while ( nwritten < nbytes )\n\t{\n\tint r;\n\n\tr = write( fd, (char*) buf + nwritten, nbytes - nwritten );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r < 0 )\n\t    return r;\n\tif ( r == 0 )\n\t    break;\n\tnwritten += r;\n\t}\n\n    return nwritten;\n    }\n\n\n/* Generate debugging statistics syslog message. */\nvoid\nhttpd_logstats( long secs )\n    {\n    if ( str_alloc_count > 0 )\n\tsyslog( LOG_INFO,\n\t    \"  libhttpd - %d strings allocated, %lu bytes (%g bytes/str)\",\n\t    str_alloc_count, (unsigned long) str_alloc_size,\n\t    (float) str_alloc_size / str_alloc_count );\n    }\n"], "fixing_code": ["/* libhttpd.c - HTTP protocol library\n**\n** Copyright \ufffd 1995,1998,1999,2000,2001 by Jef Poskanzer <jef@mail.acme.com>.\n** All rights reserved.\n**\n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions\n** are met:\n** 1. Redistributions of source code must retain the above copyright\n**    notice, this list of conditions and the following disclaimer.\n** 2. Redistributions in binary form must reproduce the above copyright\n**    notice, this list of conditions and the following disclaimer in the\n**    documentation and/or other materials provided with the distribution.\n**\n** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n** SUCH DAMAGE.\n*/\n\n\n#include <config.h>\n\n//system headers\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif /* HAVE_MEMORY_H */\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#ifdef HAVE_OSRELDATE_H\n#include <osreldate.h>\n#endif /* HAVE_OSRELDATE_H */\n\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# ifdef HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# ifdef HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# ifdef HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n\nextern char* crypt( const char* key, const char* setting );\n\n//local headers\n#include <libhttpd.h>\n#include <match.h>\n#include <mmc.h>\n#include <tdate_parse.h>\n#include <thttpd.h>\n#include <timers.h>\n#include <version.h>\n\n#ifdef SHOW_SERVER_VERSION\n#define EXPOSED_SERVER_SOFTWARE SERVER_SOFTWARE\n#else /* SHOW_SERVER_VERSION */\n#define EXPOSED_SERVER_SOFTWARE \"sthttpd\"\n#endif /* SHOW_SERVER_VERSION */\n\n#ifndef STDIN_FILENO\n#define STDIN_FILENO 0\n#endif\n#ifndef STDOUT_FILENO\n#define STDOUT_FILENO 1\n#endif\n#ifndef STDERR_FILENO\n#define STDERR_FILENO 2\n#endif\n\n#ifndef SHUT_WR\n#define SHUT_WR 1\n#endif\n\n#ifdef __CYGWIN__\n#define timezone  _timezone\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n\n/* Forwards. */\nstatic void check_options( void );\nstatic void free_httpd_server( httpd_server* hs );\nstatic int initialize_listen_socket( httpd_sockaddr* saP );\nstatic void add_response( httpd_conn* hc, char* str );\nstatic void send_mime( httpd_conn* hc, int status, char* title, char* encodings, char* extraheads, char* type, off_t length, time_t mod );\nstatic void send_response( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg );\nstatic void send_response_tail( httpd_conn* hc );\nstatic void defang( char* str, char* dfstr, int dfsize );\n#ifdef ERR_DIR\nstatic int send_err_file( httpd_conn* hc, int status, char* title, char* extraheads, char* filename );\n#endif /* ERR_DIR */\n#ifdef AUTH_FILE\nstatic void send_authenticate( httpd_conn* hc, char* realm );\nstatic int b64_decode( const char* str, unsigned char* space, int size );\nstatic int auth_check( httpd_conn* hc, char* dirname  );\nstatic int auth_check2( httpd_conn* hc, char* dirname  );\n#endif /* AUTH_FILE */\nstatic void send_dirredirect( httpd_conn* hc );\nstatic int hexit( char c );\nstatic void strdecode( char* to, char* from );\n#ifdef GENERATE_INDEXES\nstatic void strencode( char* to, int tosize, char* from );\n#endif /* GENERATE_INDEXES */\n#ifdef TILDE_MAP_1\nstatic int tilde_map_1( httpd_conn* hc );\n#endif /* TILDE_MAP_1 */\n#ifdef TILDE_MAP_2\nstatic int tilde_map_2( httpd_conn* hc );\n#endif /* TILDE_MAP_2 */\nstatic int vhost_map( httpd_conn* hc );\nstatic char* expand_symlinks( char* path, char** restP, int no_symlink_check, int tildemapped );\nstatic char* bufgets( httpd_conn* hc );\nstatic void de_dotdot( char* file );\nstatic void init_mime( void );\nstatic void figure_mime( httpd_conn* hc );\n#ifdef CGI_TIMELIMIT\nstatic void cgi_kill2( ClientData client_data, struct timeval* nowP );\nstatic void cgi_kill( ClientData client_data, struct timeval* nowP );\n#endif /* CGI_TIMELIMIT */\n#ifdef GENERATE_INDEXES\nstatic int ls( httpd_conn* hc );\n#endif /* GENERATE_INDEXES */\nstatic char* build_env( char* fmt, char* arg );\n#ifdef SERVER_NAME_LIST\nstatic char* hostname_map( char* hostname );\n#endif /* SERVER_NAME_LIST */\nstatic char** make_envp( httpd_conn* hc );\nstatic char** make_argp( httpd_conn* hc );\nstatic void cgi_interpose_input( httpd_conn* hc, int wfd );\nstatic void post_post_garbage_hack( httpd_conn* hc );\nstatic void cgi_interpose_output( httpd_conn* hc, int rfd );\nstatic void cgi_child( httpd_conn* hc );\nstatic int cgi( httpd_conn* hc );\nstatic int really_start_request( httpd_conn* hc, struct timeval* nowP );\nstatic void make_log_entry( httpd_conn* hc, struct timeval* nowP );\nstatic int check_referer( httpd_conn* hc );\nstatic int really_check_referer( httpd_conn* hc );\nstatic int sockaddr_check( httpd_sockaddr* saP );\nstatic size_t sockaddr_len( httpd_sockaddr* saP );\nstatic int my_snprintf( char* str, size_t size, const char* format, ... );\n#ifndef HAVE_ATOLL\nstatic long long atoll( const char* str );\n#endif /* HAVE_ATOLL */\n\n\n/* This global keeps track of whether we are in the main process or a\n** sub-process.  The reason is that httpd_write_response() can get called\n** in either context; when it is called from the main process it must use\n** non-blocking I/O to avoid stalling the server, but when it is called\n** from a sub-process it wants to use blocking I/O so that the whole\n** response definitely gets written.  So, it checks this variable.  A bit\n** of a hack but it seems to do the right thing.\n*/\nstatic int sub_process = 0;\n\n\nstatic void\ncheck_options( void )\n    {\n#if defined(TILDE_MAP_1) && defined(TILDE_MAP_2)\n    syslog( LOG_CRIT, \"both TILDE_MAP_1 and TILDE_MAP_2 are defined\" );\n    exit( 1 );\n#endif /* both */\n    }\n\n\nstatic void\nfree_httpd_server( httpd_server* hs )\n{\n    free(hs->binding_hostname);\n    free(hs->cwd);\n    free(hs->cgi_pattern);\n    free(hs->charset);\n    free(hs->p3p);\n    free(hs->url_pattern);\n    free(hs->local_pattern);\n    free(hs);\n}\n\n\nhttpd_server*\nhttpd_initialize(\n    char* hostname, httpd_sockaddr* sa4P, httpd_sockaddr* sa6P,\n    unsigned short port, char* cgi_pattern, int cgi_limit, char* charset,\n    char* p3p, int max_age, char* cwd, int no_log, FILE* logfp,\n    int no_symlink_check, int vhost, int global_passwd, char* url_pattern,\n    char* local_pattern, int no_empty_referers )\n    {\n    httpd_server* hs;\n    static char ghnbuf[256];\n    char* cp;\n\n    check_options();\n\n    hs = NEW( httpd_server, 1 );\n    if ( hs == (httpd_server*) 0 )\n\t{\n\tsyslog( LOG_CRIT, \"out of memory allocating an httpd_server\" );\n\treturn (httpd_server*) 0;\n\t}\n\n    if ( hostname != (char*) 0 )\n\t{\n\ths->binding_hostname = strdup( hostname );\n\tif ( hs->binding_hostname == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying hostname\" );\n\t    return (httpd_server*) 0;\n\t    }\n\ths->server_hostname = hs->binding_hostname;\n\t}\n    else\n\t{\n\ths->binding_hostname = (char*) 0;\n\ths->server_hostname = (char*) 0;\n\tif ( gethostname( ghnbuf, sizeof(ghnbuf) ) < 0 )\n\t    ghnbuf[0] = '\\0';\n#ifdef SERVER_NAME_LIST\n\tif ( ghnbuf[0] != '\\0' )\n\t    hs->server_hostname = hostname_map( ghnbuf );\n#endif /* SERVER_NAME_LIST */\n\tif ( hs->server_hostname == (char*) 0 )\n\t    {\n#ifdef SERVER_NAME\n\t    hs->server_hostname = SERVER_NAME;\n#else /* SERVER_NAME */\n\t    if ( ghnbuf[0] != '\\0' )\n\t\ths->server_hostname = ghnbuf;\n#endif /* SERVER_NAME */\n\t    }\n\t}\n\n    hs->port = port;\n    if ( cgi_pattern == (char*) 0 )\n\ths->cgi_pattern = (char*) 0;\n    else\n\t{\n\t/* Nuke any leading slashes. */\n\tif ( cgi_pattern[0] == '/' )\n\t    ++cgi_pattern;\n\ths->cgi_pattern = strdup( cgi_pattern );\n\tif ( hs->cgi_pattern == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying cgi_pattern\" );\n\t    return (httpd_server*) 0;\n\t    }\n\t/* Nuke any leading slashes in the cgi pattern. */\n\twhile ( ( cp = strstr( hs->cgi_pattern, \"|/\" ) ) != (char*) 0 )\n\t    /* -2 for the offset, +1 for the '\\0' */\n\t    (void) memmove( cp + 1, cp + 2, strlen( cp ) - 1 );\n\t}\n    hs->cgi_limit = cgi_limit;\n    hs->cgi_count = 0;\n    hs->charset = strdup( charset );\n    hs->p3p = strdup( p3p );\n    hs->max_age = max_age;\n    hs->cwd = strdup( cwd );\n    if ( hs->cwd == (char*) 0 )\n\t{\n\tsyslog( LOG_CRIT, \"out of memory copying cwd\" );\n\treturn (httpd_server*) 0;\n\t}\n    if ( url_pattern == (char*) 0 )\n\ths->url_pattern = (char*) 0;\n    else\n\t{\n\ths->url_pattern = strdup( url_pattern );\n\tif ( hs->url_pattern == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying url_pattern\" );\n\t    return (httpd_server*) 0;\n\t    }\n\t}\n    if ( local_pattern == (char*) 0 )\n\ths->local_pattern = (char*) 0;\n    else\n\t{\n\ths->local_pattern = strdup( local_pattern );\n\tif ( hs->local_pattern == (char*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"out of memory copying local_pattern\" );\n\t    return (httpd_server*) 0;\n\t    }\n\t}\n    hs->no_log = no_log;\n    hs->logfp = (FILE*) 0;\n    httpd_set_logfp( hs, logfp );\n    hs->no_symlink_check = no_symlink_check;\n    hs->vhost = vhost;\n    hs->global_passwd = global_passwd;\n    hs->no_empty_referers = no_empty_referers;\n\n    /* Initialize listen sockets.  Try v6 first because of a Linux peculiarity;\n    ** like some other systems, it has magical v6 sockets that also listen for\n    ** v4, but in Linux if you bind a v4 socket first then the v6 bind fails.\n    */\n    if ( sa6P == (httpd_sockaddr*) 0 )\n\ths->listen6_fd = -1;\n    else\n\ths->listen6_fd = initialize_listen_socket( sa6P );\n    if ( sa4P == (httpd_sockaddr*) 0 )\n\ths->listen4_fd = -1;\n    else\n\ths->listen4_fd = initialize_listen_socket( sa4P );\n    /* If we didn't get any valid sockets, fail. */\n    if ( hs->listen4_fd == -1 && hs->listen6_fd == -1 )\n\t{\n\tfree_httpd_server( hs );\n\treturn (httpd_server*) 0;\n\t}\n\n    init_mime();\n\n    /* Done initializing. */\n    if ( hs->binding_hostname == (char*) 0 )\n\tsyslog(\n\t    LOG_NOTICE, \"%.80s starting on port %d\", SERVER_SOFTWARE,\n\t    (int) hs->port );\n    else\n\tsyslog(\n\t    LOG_NOTICE, \"%.80s starting on %.80s, port %d\", SERVER_SOFTWARE,\n\t    httpd_ntoa( hs->listen4_fd != -1 ? sa4P : sa6P ),\n\t    (int) hs->port );\n    return hs;\n    }\n\n\nstatic int\ninitialize_listen_socket( httpd_sockaddr* saP )\n    {\n    int listen_fd;\n    int on, flags;\n\n    /* Check sockaddr. */\n    if ( ! sockaddr_check( saP ) )\n\t{\n\tsyslog( LOG_CRIT, \"unknown sockaddr family on listen socket\" );\n\treturn -1;\n\t}\n\n    /* Create socket. */\n    listen_fd = socket( saP->sa.sa_family, SOCK_STREAM, 0 );\n    if ( listen_fd < 0 )\n\t{\n\tsyslog( LOG_CRIT, \"socket %.80s - %m\", httpd_ntoa( saP ) );\n\treturn -1;\n\t}\n    (void) fcntl( listen_fd, F_SETFD, 1 );\n\n    /* Allow reuse of local addresses. */\n    on = 1;\n    if ( setsockopt(\n\t     listen_fd, SOL_SOCKET, SO_REUSEADDR, (char*) &on,\n\t     sizeof(on) ) < 0 )\n\tsyslog( LOG_CRIT, \"setsockopt SO_REUSEADDR - %m\" );\n\n    /* Bind to it. */\n    if ( bind( listen_fd, &saP->sa, sockaddr_len( saP ) ) < 0 )\n\t{\n\tsyslog(\n\t    LOG_CRIT, \"bind %.80s - %m\", httpd_ntoa( saP ) );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n\n    /* Set the listen file descriptor to no-delay / non-blocking mode. */\n    flags = fcntl( listen_fd, F_GETFL, 0 );\n    if ( flags == -1 )\n\t{\n\tsyslog( LOG_CRIT, \"fcntl F_GETFL - %m\" );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n    if ( fcntl( listen_fd, F_SETFL, flags | O_NDELAY ) < 0 )\n\t{\n\tsyslog( LOG_CRIT, \"fcntl O_NDELAY - %m\" );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n\n    /* Start a listen going. */\n    if ( listen( listen_fd, LISTEN_BACKLOG ) < 0 )\n\t{\n\tsyslog( LOG_CRIT, \"listen - %m\" );\n\t(void) close( listen_fd );\n\treturn -1;\n\t}\n\n    /* Use accept filtering, if available. */\n#ifdef SO_ACCEPTFILTER\n    {\n#if ( __FreeBSD_version >= 411000 )\n#define ACCEPT_FILTER_NAME \"httpready\"\n#else\n#define ACCEPT_FILTER_NAME \"dataready\"\n#endif\n    struct accept_filter_arg af;\n    (void) bzero( &af, sizeof(af) );\n    (void) strcpy( af.af_name, ACCEPT_FILTER_NAME );\n    (void) setsockopt(\n\tlisten_fd, SOL_SOCKET, SO_ACCEPTFILTER, (char*) &af, sizeof(af) );\n    }\n#endif /* SO_ACCEPTFILTER */\n\n    return listen_fd;\n    }\n\n\nvoid\nhttpd_set_logfp( httpd_server* hs, FILE* logfp )\n    {\n    if ( hs->logfp != (FILE*) 0 )\n\t(void) fclose( hs->logfp );\n    hs->logfp = logfp;\n    }\n\n\nvoid\nhttpd_terminate( httpd_server* hs )\n    {\n    httpd_unlisten( hs );\n    if ( hs->logfp != (FILE*) 0 )\n\t(void) fclose( hs->logfp );\n    free_httpd_server( hs );\n    }\n\n\nvoid\nhttpd_unlisten( httpd_server* hs )\n    {\n    if ( hs->listen4_fd != -1 )\n\t{\n\t(void) close( hs->listen4_fd );\n\ths->listen4_fd = -1;\n\t}\n    if ( hs->listen6_fd != -1 )\n\t{\n\t(void) close( hs->listen6_fd );\n\ths->listen6_fd = -1;\n\t}\n    }\n\n\n/* Conditional macro to allow two alternate forms for use in the built-in\n** error pages.  If EXPLICIT_ERROR_PAGES is defined, the second and more\n** explicit error form is used; otherwise, the first and more generic\n** form is used.\n*/\n#ifdef EXPLICIT_ERROR_PAGES\n#define ERROR_FORM(a,b) b\n#else /* EXPLICIT_ERROR_PAGES */\n#define ERROR_FORM(a,b) a\n#endif /* EXPLICIT_ERROR_PAGES */\n\n\nstatic char* ok200title = \"OK\";\nstatic char* ok206title = \"Partial Content\";\n\nstatic char* err302title = \"Found\";\nstatic char* err302form = \"The actual URL is '%.80s'.\\n\";\n\nstatic char* err304title = \"Not Modified\";\n\nchar* httpd_err400title = \"Bad Request\";\nchar* httpd_err400form =\n    \"Your request has bad syntax or is inherently impossible to satisfy.\\n\";\n\n#ifdef AUTH_FILE\nstatic char* err401title = \"Unauthorized\";\nstatic char* err401form =\n    \"Authorization required for the URL '%.80s'.\\n\";\n#endif /* AUTH_FILE */\n\nstatic char* err403title = \"Forbidden\";\n#ifndef EXPLICIT_ERROR_PAGES\nstatic char* err403form =\n    \"You do not have permission to get URL '%.80s' from this server.\\n\";\n#endif /* !EXPLICIT_ERROR_PAGES */\n\nstatic char* err404title = \"Not Found\";\nstatic char* err404form =\n    \"The requested URL '%.80s' was not found on this server.\\n\";\n\nchar* httpd_err408title = \"Request Timeout\";\nchar* httpd_err408form =\n    \"No request appeared within a reasonable time period.\\n\";\n\nstatic char* err500title = \"Internal Error\";\nstatic char* err500form =\n    \"There was an unusual problem serving the requested URL '%.80s'.\\n\";\n\nstatic char* err501title = \"Not Implemented\";\nstatic char* err501form =\n    \"The requested method '%.80s' is not implemented by this server.\\n\";\n\nchar* httpd_err503title = \"Service Temporarily Overloaded\";\nchar* httpd_err503form =\n    \"The requested URL '%.80s' is temporarily overloaded.  Please try again later.\\n\";\n\n\n/* Append a string to the buffer waiting to be sent as response. */\nstatic void\nadd_response( httpd_conn* hc, char* str )\n    {\n    size_t len;\n\n    len = strlen( str );\n    httpd_realloc_str( &hc->response, &hc->maxresponse, hc->responselen + len );\n    (void) memmove( &(hc->response[hc->responselen]), str, len );\n    hc->responselen += len;\n    }\n\n/* Send the buffered response. */\nvoid\nhttpd_write_response( httpd_conn* hc )\n    {\n    /* If we are in a sub-process, turn off no-delay mode. */\n    if ( sub_process )\n\thttpd_clear_ndelay( hc->conn_fd );\n    /* Send the response, if necessary. */\n    if ( hc->responselen > 0 )\n\t{\n\t(void) httpd_write_fully( hc->conn_fd, hc->response, hc->responselen );\n\thc->responselen = 0;\n\t}\n    }\n\n\n/* Set no-delay / non-blocking mode on a socket. */\nvoid\nhttpd_set_ndelay( int fd )\n    {\n    int flags, newflags;\n\n    flags = fcntl( fd, F_GETFL, 0 );\n    if ( flags != -1 )\n\t{\n\tnewflags = flags | (int) O_NDELAY;\n\tif ( newflags != flags )\n\t    (void) fcntl( fd, F_SETFL, newflags );\n\t}\n    }\n\n\n/* Clear no-delay / non-blocking mode on a socket. */\nvoid\nhttpd_clear_ndelay( int fd )\n    {\n    int flags, newflags;\n\n    flags = fcntl( fd, F_GETFL, 0 );\n    if ( flags != -1 )\n\t{\n\tnewflags = flags & ~ (int) O_NDELAY;\n\tif ( newflags != flags )\n\t    (void) fcntl( fd, F_SETFL, newflags );\n\t}\n    }\n\n\nstatic void\nsend_mime( httpd_conn* hc, int status, char* title, char* encodings, char* extraheads, char* type, off_t length, time_t mod )\n    {\n    time_t now, expires;\n    const char* rfc1123fmt = \"%a, %d %b %Y %H:%M:%S GMT\";\n    char nowbuf[100];\n    char modbuf[100];\n    char expbuf[100];\n    char fixed_type[500];\n    char buf[1000];\n    int partial_content;\n    int s100;\n\n    hc->status = status;\n    hc->bytes_to_send = length;\n    if ( hc->mime_flag )\n\t{\n\tif ( status == 200 && hc->got_range &&\n\t     ( hc->last_byte_index >= hc->first_byte_index ) &&\n\t     ( ( hc->last_byte_index != length - 1 ) ||\n\t       ( hc->first_byte_index != 0 ) ) &&\n\t     ( hc->range_if == (time_t) -1 ||\n\t       hc->range_if == hc->sb.st_mtime ) )\n\t    {\n\t    partial_content = 1;\n\t    hc->status = status = 206;\n\t    title = ok206title;\n\t    }\n\telse\n\t    {\n\t    partial_content = 0;\n\t    hc->got_range = 0;\n\t    }\n\n\tnow = time( (time_t*) 0 );\n\tif ( mod == (time_t) 0 )\n\t    mod = now;\n\t(void) strftime( nowbuf, sizeof(nowbuf), rfc1123fmt, gmtime( &now ) );\n\t(void) strftime( modbuf, sizeof(modbuf), rfc1123fmt, gmtime( &mod ) );\n\t(void) my_snprintf(\n\t    fixed_type, sizeof(fixed_type), type, hc->hs->charset );\n\t(void) my_snprintf( buf, sizeof(buf),\n\t    \"%.20s %d %s\\015\\012Server: %s\\015\\012Content-Type: %s\\015\\012Date: %s\\015\\012Last-Modified: %s\\015\\012Accept-Ranges: bytes\\015\\012Connection: close\\015\\012\",\n\t    hc->protocol, status, title, EXPOSED_SERVER_SOFTWARE, fixed_type,\n\t    nowbuf, modbuf );\n\tadd_response( hc, buf );\n\ts100 = status / 100;\n\tif ( s100 != 2 && s100 != 3 )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Cache-Control: no-cache,no-store\\015\\012\" );\n\t    add_response( hc, buf );\n\t    }\n\tif ( encodings[0] != '\\0' )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Content-Encoding: %s\\015\\012\", encodings );\n\t    add_response( hc, buf );\n\t    }\n\tif ( partial_content )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Content-Range: bytes %lld-%lld/%lld\\015\\012Content-Length: %lld\\015\\012\",\n\t\t(int64_t) hc->first_byte_index, (int64_t) hc->last_byte_index,\n\t\t(int64_t) length,\n\t\t(int64_t) ( hc->last_byte_index - hc->first_byte_index + 1 ) );\n\t    add_response( hc, buf );\n\t    }\n\telse if ( length >= 0 )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Content-Length: %lld\\015\\012\", (int64_t) length );\n\t    add_response( hc, buf );\n\t    }\n\tif ( hc->hs->p3p[0] != '\\0' )\n\t    {\n\t    (void) my_snprintf( buf, sizeof(buf), \"P3P: %s\\015\\012\", hc->hs->p3p );\n\t    add_response( hc, buf );\n\t    }\n\tif ( hc->hs->max_age >= 0 )\n\t    {\n\t    expires = now + hc->hs->max_age;\n\t    (void) strftime(\n\t\texpbuf, sizeof(expbuf), rfc1123fmt, gmtime( &expires ) );\n\t    (void) my_snprintf( buf, sizeof(buf),\n\t\t\"Cache-Control: max-age=%d\\015\\012Expires: %s\\015\\012\",\n\t\thc->hs->max_age, expbuf );\n\t    add_response( hc, buf );\n\t    }\n\tif ( extraheads[0] != '\\0' )\n\t    add_response( hc, extraheads );\n\tadd_response( hc, \"\\015\\012\" );\n\t}\n    }\n\n\nstatic int str_alloc_count = 0;\nstatic size_t str_alloc_size = 0;\n\nvoid\nhttpd_realloc_str( char** strP, size_t* maxsizeP, size_t size )\n    {\n    if ( *maxsizeP == 0 )\n\t{\n\t*maxsizeP = MAX( 200, size + 100 );\n\t*strP = NEW( char, *maxsizeP + 1 );\n\t++str_alloc_count;\n\tstr_alloc_size += *maxsizeP;\n\t}\n    else if ( size > *maxsizeP )\n\t{\n\tstr_alloc_size -= *maxsizeP;\n\t*maxsizeP = MAX( *maxsizeP * 2, size * 5 / 4 );\n\t*strP = RENEW( *strP, char, *maxsizeP + 1 );\n\tstr_alloc_size += *maxsizeP;\n\t}\n    else\n\treturn;\n    if ( *strP == (char*) 0 )\n\t{\n\tsyslog(\n\t    LOG_ERR, \"out of memory reallocating a string to %zu bytes\",\n\t    *maxsizeP );\n\texit( 1 );\n\t}\n    }\n\n\nstatic void\nsend_response( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg )\n    {\n    char defanged_arg[1000], buf[2000];\n\n    send_mime(\n\thc, status, title, \"\", extraheads, \"text/html; charset=%s\", (off_t) -1,\n\t(time_t) 0 );\n    (void) my_snprintf( buf, sizeof(buf), \"\\\n<HTML>\\n\\\n<HEAD><TITLE>%d %s</TITLE></HEAD>\\n\\\n<BODY BGCOLOR=\\\"#cc9999\\\" TEXT=\\\"#000000\\\" LINK=\\\"#2020ff\\\" VLINK=\\\"#4040cc\\\">\\n\\\n<H2>%d %s</H2>\\n\",\n\tstatus, title, status, title );\n    add_response( hc, buf );\n    defang( arg, defanged_arg, sizeof(defanged_arg) );\n    (void) my_snprintf( buf, sizeof(buf), form, defanged_arg );\n    add_response( hc, buf );\n    if ( match( \"**MSIE**\", hc->useragent ) )\n\t{\n\tint n;\n\tadd_response( hc, \"<!--\\n\" );\n\tfor ( n = 0; n < 6; ++n )\n\t    add_response( hc, \"Padding so that MSIE deigns to show this error instead of its own canned one.\\n\");\n\tadd_response( hc, \"-->\\n\" );\n\t}\n    send_response_tail( hc );\n    }\n\n\nstatic void\nsend_response_tail( httpd_conn* hc )\n    {\n    char buf[1000];\n\n    (void) my_snprintf( buf, sizeof(buf), \"\\\n<HR>\\n\\\n<ADDRESS><A HREF=\\\"%s\\\">%s</A></ADDRESS>\\n\\\n</BODY>\\n\\\n</HTML>\\n\",\n\tSERVER_ADDRESS, EXPOSED_SERVER_SOFTWARE );\n    add_response( hc, buf );\n    }\n\n\nstatic void\ndefang( char* str, char* dfstr, int dfsize )\n    {\n    char* cp1;\n    char* cp2;\n\n    for ( cp1 = str, cp2 = dfstr;\n\t  *cp1 != '\\0' && cp2 - dfstr < dfsize - 5;\n\t  ++cp1, ++cp2 )\n\t{\n\tswitch ( *cp1 )\n\t    {\n\t    case '<':\n\t    *cp2++ = '&';\n\t    *cp2++ = 'l';\n\t    *cp2++ = 't';\n\t    *cp2 = ';';\n\t    break;\n\t    case '>':\n\t    *cp2++ = '&';\n\t    *cp2++ = 'g';\n\t    *cp2++ = 't';\n\t    *cp2 = ';';\n\t    break;\n\t    default:\n\t    *cp2 = *cp1;\n\t    break;\n\t    }\n\t}\n    *cp2 = '\\0';\n    }\n\n\nvoid\nhttpd_send_err( httpd_conn* hc, int status, char* title, char* extraheads, char* form, char* arg )\n    {\n#ifdef ERR_DIR\n\n    char filename[1000];\n\n    /* Try virtual host error page. */\n    if ( hc->hs->vhost && hc->hostdir[0] != '\\0' )\n\t{\n\t(void) my_snprintf( filename, sizeof(filename),\n\t    \"%s/%s/err%d.html\", hc->hostdir, ERR_DIR, status );\n\tif ( send_err_file( hc, status, title, extraheads, filename ) )\n\t    return;\n\t}\n\n    /* Try server-wide error page. */\n    (void) my_snprintf( filename, sizeof(filename),\n\t\"%s/err%d.html\", ERR_DIR, status );\n    if ( send_err_file( hc, status, title, extraheads, filename ) )\n\treturn;\n\n    /* Fall back on built-in error page. */\n    send_response( hc, status, title, extraheads, form, arg );\n\n#else /* ERR_DIR */\n\n    send_response( hc, status, title, extraheads, form, arg );\n\n#endif /* ERR_DIR */\n    }\n\n\n#ifdef ERR_DIR\nstatic int\nsend_err_file( httpd_conn* hc, int status, char* title, char* extraheads, char* filename )\n    {\n    FILE* fp;\n    char buf[1000];\n    size_t r;\n\n    fp = fopen( filename, \"r\" );\n    if ( fp == (FILE*) 0 )\n\treturn 0;\n    send_mime(\n\thc, status, title, \"\", extraheads, \"text/html; charset=%s\", (off_t) -1,\n\t(time_t) 0 );\n    for (;;)\n\t{\n\tr = fread( buf, 1, sizeof(buf) - 1, fp );\n\tif ( r == 0 )\n\t    break;\n\tbuf[r] = '\\0';\n\tadd_response( hc, buf );\n\t}\n    (void) fclose( fp );\n\n#ifdef ERR_APPEND_SERVER_INFO\n    send_response_tail( hc );\n#endif /* ERR_APPEND_SERVER_INFO */\n\n    return 1;\n    }\n#endif /* ERR_DIR */\n\n\n#ifdef AUTH_FILE\n\nstatic void\nsend_authenticate( httpd_conn* hc, char* realm )\n    {\n    static char* header;\n    static size_t maxheader = 0;\n    static char headstr[] = \"WWW-Authenticate: Basic realm=\\\"\";\n\n    httpd_realloc_str(\n\t&header, &maxheader, sizeof(headstr) + strlen( realm ) + 3 );\n    (void) my_snprintf( header, maxheader, \"%s%s\\\"\\015\\012\", headstr, realm );\n    httpd_send_err( hc, 401, err401title, header, err401form, hc->encodedurl );\n    /* If the request was a POST then there might still be data to be read,\n    ** so we need to do a lingering close.\n    */\n    if ( hc->method == METHOD_POST )\n\thc->should_linger = 1;\n    }\n\n\n/* Base-64 decoding.  This represents binary data as printable ASCII\n** characters.  Three 8-bit binary bytes are turned into four 6-bit\n** values, like so:\n**\n**   [11111111]  [22222222]  [33333333]\n**\n**   [111111] [112222] [222233] [333333]\n**\n** Then the 6-bit values are represented using the characters \"A-Za-z0-9+/\".\n*/\n\nstatic int b64_decode_table[256] = {\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */\n    52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */\n    -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */\n    15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */\n    -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */\n    41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* C0-CF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* D0-DF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* E0-EF */\n    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1   /* F0-FF */\n    };\n\n/* Do base-64 decoding on a string.  Ignore any non-base64 bytes.\n** Return the actual number of bytes generated.  The decoded size will\n** be at most 3/4 the size of the encoded, and may be smaller if there\n** are padding characters (blanks, newlines).\n*/\nstatic int\nb64_decode( const char* str, unsigned char* space, int size )\n    {\n    const char* cp;\n    int space_idx, phase;\n    int d, prev_d = 0;\n    unsigned char c;\n\n    space_idx = 0;\n    phase = 0;\n    for ( cp = str; *cp != '\\0'; ++cp )\n\t{\n\td = b64_decode_table[(int) *cp];\n\tif ( d != -1 )\n\t    {\n\t    switch ( phase )\n\t\t{\n\t\tcase 0:\n\t\t++phase;\n\t\tbreak;\n\t\tcase 1:\n\t\tc = ( ( prev_d << 2 ) | ( ( d & 0x30 ) >> 4 ) );\n\t\tif ( space_idx < size )\n\t\t    space[space_idx++] = c;\n\t\t++phase;\n\t\tbreak;\n\t\tcase 2:\n\t\tc = ( ( ( prev_d & 0xf ) << 4 ) | ( ( d & 0x3c ) >> 2 ) );\n\t\tif ( space_idx < size )\n\t\t    space[space_idx++] = c;\n\t\t++phase;\n\t\tbreak;\n\t\tcase 3:\n\t\tc = ( ( ( prev_d & 0x03 ) << 6 ) | d );\n\t\tif ( space_idx < size )\n\t\t    space[space_idx++] = c;\n\t\tphase = 0;\n\t\tbreak;\n\t\t}\n\t    prev_d = d;\n\t    }\n\t}\n    return space_idx;\n    }\n\n\n/* Returns -1 == unauthorized, 0 == no auth file, 1 = authorized. */\nstatic int\nauth_check( httpd_conn* hc, char* dirname  )\n    {\n    if ( hc->hs->global_passwd )\n\t{\n\tchar* topdir;\n\tif ( hc->hs->vhost && hc->hostdir[0] != '\\0' )\n\t    topdir = hc->hostdir;\n\telse\n\t    topdir = \".\";\n\tswitch ( auth_check2( hc, topdir ) )\n\t    {\n\t    case -1:\n\t    return -1;\n\t    case 1:\n\t    return 1;\n\t    }\n\t}\n    return auth_check2( hc, dirname );\n    }\n\n\n/* Returns -1 == unauthorized, 0 == no auth file, 1 = authorized. */\nstatic int\nauth_check2( httpd_conn* hc, char* dirname  )\n    {\n    static char* authpath;\n    static size_t maxauthpath = 0;\n    struct stat sb;\n    char authinfo[500];\n    char* authpass;\n    char* colon;\n    int l;\n    FILE* fp;\n    char line[500];\n    char* cryp;\n    static char* prevauthpath;\n    static size_t maxprevauthpath = 0;\n    static time_t prevmtime;\n    static char* prevuser;\n    static size_t maxprevuser = 0;\n    static char* prevcryp;\n    static size_t maxprevcryp = 0;\n    char *crypt_result;\n\n    /* Construct auth filename. */\n    httpd_realloc_str(\n\t&authpath, &maxauthpath, strlen( dirname ) + 1 + sizeof(AUTH_FILE) );\n    (void) my_snprintf( authpath, maxauthpath, \"%s/%s\", dirname, AUTH_FILE );\n\n    /* Does this directory have an auth file? */\n    if ( stat( authpath, &sb ) < 0 )\n\t/* Nope, let the request go through. */\n\treturn 0;\n\n    /* Does this request contain basic authorization info? */\n    if ( hc->authorization[0] == '\\0' ||\n\t strncmp( hc->authorization, \"Basic \", 6 ) != 0 )\n\t{\n\t/* Nope, return a 401 Unauthorized. */\n\tsend_authenticate( hc, dirname );\n\treturn -1;\n\t}\n\n    /* Decode it. */\n    l = b64_decode(\n\t&(hc->authorization[6]), (unsigned char*) authinfo,\n\tsizeof(authinfo) - 1 );\n    authinfo[l] = '\\0';\n    /* Split into user and password. */\n    authpass = strchr( authinfo, ':' );\n    if ( authpass == (char*) 0 )\n\t{\n\t/* No colon?  Bogus auth info. */\n\tsend_authenticate( hc, dirname );\n\treturn -1;\n\t}\n    *authpass++ = '\\0';\n    /* If there are more fields, cut them off. */\n    colon = strchr( authpass, ':' );\n    if ( colon != (char*) 0 )\n\t*colon = '\\0';\n\n    /* See if we have a cached entry and can use it. */\n    if ( maxprevauthpath != 0 &&\n\t strcmp( authpath, prevauthpath ) == 0 &&\n\t sb.st_mtime == prevmtime &&\n\t strcmp( authinfo, prevuser ) == 0 )\n\t{\n\t/* Yes.  Check against the cached encrypted password. */\n\tcrypt_result = crypt( authpass, prevcryp );\n\tif ( ! crypt_result )\n\t    return -1;\n\tif ( strcmp( crypt_result, prevcryp ) == 0 )\n\t    {\n\t    /* Ok! */\n\t    httpd_realloc_str(\n\t\t&hc->remoteuser, &hc->maxremoteuser, strlen( authinfo ) );\n\t    (void) strcpy( hc->remoteuser, authinfo );\n\t    return 1;\n\t    }\n\telse\n\t    {\n\t    /* No. */\n\t    send_authenticate( hc, dirname );\n\t    return -1;\n\t    }\n\t}\n\n    /* Open the password file. */\n    fp = fopen( authpath, \"r\" );\n    if ( fp == (FILE*) 0 )\n\t{\n\t/* The file exists but we can't open it?  Disallow access. */\n\tsyslog(\n\t    LOG_ERR, \"%.80s auth file %.80s could not be opened - %m\",\n\t    httpd_ntoa( &hc->client_addr ), authpath );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' is protected by an authentication file, but the authentication file cannot be opened.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Read it. */\n    while ( fgets( line, sizeof(line), fp ) != (char*) 0 )\n\t{\n\t/* Nuke newline. */\n\tl = strlen( line );\n\tif ( line[l - 1] == '\\n' )\n\t    line[l - 1] = '\\0';\n\t/* Split into user and encrypted password. */\n\tcryp = strchr( line, ':' );\n\tif ( cryp == (char*) 0 )\n\t    continue;\n\t*cryp++ = '\\0';\n\t/* Is this the right user? */\n\tif ( strcmp( line, authinfo ) == 0 )\n\t    {\n\t    /* Yes. */\n\t    (void) fclose( fp );\n\t    /* So is the password right? */\n\t    crypt_result = crypt( authpass, cryp );\n\t    if ( ! crypt_result )\n\t\treturn -1;\n\t    if ( strcmp( crypt_result, cryp ) == 0 )\n\t\t{\n\t\t/* Ok! */\n\t\thttpd_realloc_str(\n\t\t    &hc->remoteuser, &hc->maxremoteuser, strlen( line ) );\n\t\t(void) strcpy( hc->remoteuser, line );\n\t\t/* And cache this user's info for next time. */\n\t\thttpd_realloc_str(\n\t\t    &prevauthpath, &maxprevauthpath, strlen( authpath ) );\n\t\t(void) strcpy( prevauthpath, authpath );\n\t\tprevmtime = sb.st_mtime;\n\t\thttpd_realloc_str(\n\t\t    &prevuser, &maxprevuser, strlen( authinfo ) );\n\t\t(void) strcpy( prevuser, authinfo );\n\t\thttpd_realloc_str( &prevcryp, &maxprevcryp, strlen( cryp ) );\n\t\t(void) strcpy( prevcryp, cryp );\n\t\treturn 1;\n\t\t}\n\t    else\n\t\t{\n\t\t/* No. */\n\t\tsend_authenticate( hc, dirname );\n\t\treturn -1;\n\t\t}\n\t    }\n\t}\n\n    /* Didn't find that user.  Access denied. */\n    (void) fclose( fp );\n    send_authenticate( hc, dirname );\n    return -1;\n    }\n\n#endif /* AUTH_FILE */\n\n\nstatic void\nsend_dirredirect( httpd_conn* hc )\n    {\n    static char* location;\n    static char* header;\n    static size_t maxlocation = 0, maxheader = 0;\n    static char headstr[] = \"Location: \";\n\n    if ( hc->query[0] != '\\0')\n\t{\n\tchar* cp = strchr( hc->encodedurl, '?' );\n\tif ( cp != (char*) 0 )\t/* should always find it */\n\t    *cp = '\\0';\n\thttpd_realloc_str(\n\t    &location, &maxlocation,\n\t    strlen( hc->encodedurl ) + 2 + strlen( hc->query ) );\n\t(void) my_snprintf( location, maxlocation,\n\t    \"%s/?%s\", hc->encodedurl, hc->query );\n\t}\n    else\n\t{\n\thttpd_realloc_str(\n\t    &location, &maxlocation, strlen( hc->encodedurl ) + 1 );\n\t(void) my_snprintf( location, maxlocation,\n\t    \"%s/\", hc->encodedurl );\n\t}\n    httpd_realloc_str(\n\t&header, &maxheader, sizeof(headstr) + strlen( location ) );\n    (void) my_snprintf( header, maxheader,\n\t\"%s%s\\015\\012\", headstr, location );\n    send_response( hc, 302, err302title, header, err302form, location );\n    }\n\n\nchar*\nhttpd_method_str( int method )\n    {\n    switch ( method )\n\t{\n\tcase METHOD_GET: return \"GET\";\n\tcase METHOD_HEAD: return \"HEAD\";\n\tcase METHOD_POST: return \"POST\";\n\tdefault: return \"UNKNOWN\";\n\t}\n    }\n\n\nstatic int\nhexit( char c )\n    {\n    if ( c >= '0' && c <= '9' )\n\treturn c - '0';\n    if ( c >= 'a' && c <= 'f' )\n\treturn c - 'a' + 10;\n    if ( c >= 'A' && c <= 'F' )\n\treturn c - 'A' + 10;\n    return 0;           /* shouldn't happen, we're guarded by isxdigit() */\n    }\n\n\n/* Copies and decodes a string.  It's ok for from and to to be the\n** same string.\n*/\nstatic void\nstrdecode( char* to, char* from )\n    {\n    for ( ; *from != '\\0'; ++to, ++from )\n\t{\n\tif ( from[0] == '%' && isxdigit( from[1] ) && isxdigit( from[2] ) )\n\t    {\n\t    *to = hexit( from[1] ) * 16 + hexit( from[2] );\n\t    from += 2;\n\t    }\n\telse\n\t    *to = *from;\n\t}\n    *to = '\\0';\n    }\n\n\n#ifdef GENERATE_INDEXES\n/* Copies and encodes a string. */\nstatic void\nstrencode( char* to, int tosize, char* from )\n    {\n    int tolen;\n\n    for ( tolen = 0; *from != '\\0' && tolen + 4 < tosize; ++from )\n\t{\n\tif ( isalnum(*from) || strchr( \"/_.-~\", *from ) != (char*) 0 )\n\t    {\n\t    *to = *from;\n\t    ++to;\n\t    ++tolen;\n\t    }\n\telse\n\t    {\n\t    (void) sprintf( to, \"%%%02x\", (int) *from & 0xff );\n\t    to += 3;\n\t    tolen += 3;\n\t    }\n\t}\n    *to = '\\0';\n    }\n#endif /* GENERATE_INDEXES */\n\n\n#ifdef TILDE_MAP_1\n/* Map a ~username/whatever URL into <prefix>/username. */\nstatic int\ntilde_map_1( httpd_conn* hc )\n    {\n    static char* temp;\n    static size_t maxtemp = 0;\n    int len;\n    static char* prefix = TILDE_MAP_1;\n\n    len = strlen( hc->expnfilename ) - 1;\n    httpd_realloc_str( &temp, &maxtemp, len );\n    (void) strcpy( temp, &hc->expnfilename[1] );\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename, strlen( prefix ) + 1 + len );\n    (void) strcpy( hc->expnfilename, prefix );\n    if ( prefix[0] != '\\0' )\n\t(void) strcat( hc->expnfilename, \"/\" );\n    (void) strcat( hc->expnfilename, temp );\n    return 1;\n    }\n#endif /* TILDE_MAP_1 */\n\n#ifdef TILDE_MAP_2\n/* Map a ~username/whatever URL into <user's homedir>/<postfix>. */\nstatic int\ntilde_map_2( httpd_conn* hc )\n    {\n    static char* temp;\n    static size_t maxtemp = 0;\n    static char* postfix = TILDE_MAP_2;\n    char* cp;\n    struct passwd* pw;\n    char* alt;\n    char* rest;\n\n    /* Get the username. */\n    httpd_realloc_str( &temp, &maxtemp, strlen( hc->expnfilename ) - 1 );\n    (void) strcpy( temp, &hc->expnfilename[1] );\n    cp = strchr( temp, '/' );\n    if ( cp != (char*) 0 )\n\t*cp++ = '\\0';\n    else\n\tcp = \"\";\n\n    /* Get the passwd entry. */\n    pw = getpwnam( temp );\n    if ( pw == (struct passwd*) 0 )\n\treturn 0;\n\n    /* Set up altdir. */\n    httpd_realloc_str(\n\t&hc->altdir, &hc->maxaltdir,\n\tstrlen( pw->pw_dir ) + 1 + strlen( postfix ) );\n    (void) strcpy( hc->altdir, pw->pw_dir );\n    if ( postfix[0] != '\\0' )\n\t{\n\t(void) strcat( hc->altdir, \"/\" );\n\t(void) strcat( hc->altdir, postfix );\n\t}\n    alt = expand_symlinks( hc->altdir, &rest, 0, 1 );\n    if ( rest[0] != '\\0' )\n\treturn 0;\n    httpd_realloc_str( &hc->altdir, &hc->maxaltdir, strlen( alt ) );\n    (void) strcpy( hc->altdir, alt );\n\n    /* And the filename becomes altdir plus the post-~ part of the original. */\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename,\n\tstrlen( hc->altdir ) + 1 + strlen( cp ) );\n    (void) my_snprintf( hc->expnfilename, hc->maxexpnfilename,\n\t\"%s/%s\", hc->altdir, cp );\n\n    /* For this type of tilde mapping, we want to defeat vhost mapping. */\n    hc->tildemapped = 1;\n\n    return 1;\n    }\n#endif /* TILDE_MAP_2 */\n\n\n/* Virtual host mapping. */\nstatic int\nvhost_map( httpd_conn* hc )\n    {\n    httpd_sockaddr sa;\n    socklen_t sz;\n    static char* tempfilename;\n    static size_t maxtempfilename = 0;\n    char* cp1;\n    int len;\n#ifdef VHOST_DIRLEVELS\n    int i;\n    char* cp2;\n#endif /* VHOST_DIRLEVELS */\n\n    /* Figure out the virtual hostname. */\n    if ( hc->reqhost[0] != '\\0' )\n\thc->hostname = hc->reqhost;\n    else if ( hc->hdrhost[0] != '\\0' )\n\thc->hostname = hc->hdrhost;\n    else\n\t{\n\tsz = sizeof(sa);\n\tif ( getsockname( hc->conn_fd, &sa.sa, &sz ) < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"getsockname - %m\" );\n\t    return 0;\n\t    }\n\thc->hostname = httpd_ntoa( &sa );\n\t}\n    /* Pound it to lower case. */\n    for ( cp1 = hc->hostname; *cp1 != '\\0'; ++cp1 )\n\tif ( isupper( *cp1 ) )\n\t    *cp1 = tolower( *cp1 );\n\n    if ( hc->tildemapped )\n\treturn 1;\n\n    /* Figure out the host directory. */\n#ifdef VHOST_DIRLEVELS\n    httpd_realloc_str(\n\t&hc->hostdir, &hc->maxhostdir,\n\tstrlen( hc->hostname ) + 2 * VHOST_DIRLEVELS );\n    if ( strncmp( hc->hostname, \"www.\", 4 ) == 0 )\n\tcp1 = &hc->hostname[4];\n    else\n\tcp1 = hc->hostname;\n    for ( cp2 = hc->hostdir, i = 0; i < VHOST_DIRLEVELS; ++i )\n\t{\n\t/* Skip dots in the hostname.  If we don't, then we get vhost\n\t** directories in higher level of filestructure if dot gets\n\t** involved into path construction.  It's `while' used here instead\n\t** of `if' for it's possible to have a hostname formed with two\n\t** dots at the end of it.\n\t*/\n\twhile ( *cp1 == '.' )\n\t    ++cp1;\n\t/* Copy a character from the hostname, or '_' if we ran out. */\n\tif ( *cp1 != '\\0' )\n\t    *cp2++ = *cp1++;\n\telse\n\t    *cp2++ = '_';\n\t/* Copy a slash. */\n\t*cp2++ = '/';\n\t}\n    (void) strcpy( cp2, hc->hostname );\n#else /* VHOST_DIRLEVELS */\n    httpd_realloc_str( &hc->hostdir, &hc->maxhostdir, strlen( hc->hostname ) );\n    (void) strcpy( hc->hostdir, hc->hostname );\n#endif /* VHOST_DIRLEVELS */\n\n    /* Prepend hostdir to the filename. */\n    len = strlen( hc->expnfilename );\n    httpd_realloc_str( &tempfilename, &maxtempfilename, len );\n    (void) strcpy( tempfilename, hc->expnfilename );\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename,\n\tstrlen( hc->hostdir ) + 1 + len );\n    (void) strcpy( hc->expnfilename, hc->hostdir );\n    (void) strcat( hc->expnfilename, \"/\" );\n    (void) strcat( hc->expnfilename, tempfilename );\n    return 1;\n    }\n\n\n/* Expands all symlinks in the given filename, eliding ..'s and leading /'s.\n** Returns the expanded path (pointer to static string), or (char*) 0 on\n** errors.  Also returns, in the string pointed to by restP, any trailing\n** parts of the path that don't exist.\n**\n** This is a fairly nice little routine.  It handles any size filenames\n** without excessive mallocs.\n*/\nstatic char*\nexpand_symlinks( char* path, char** restP, int no_symlink_check, int tildemapped )\n    {\n    static char* checked;\n    static char* rest;\n    char link[5000];\n    static size_t maxchecked = 0, maxrest = 0;\n    size_t checkedlen, restlen, linklen, prevcheckedlen, prevrestlen;\n    int nlinks, i;\n    char* r;\n    char* cp1;\n    char* cp2;\n\n    if ( no_symlink_check )\n\t{\n\t/* If we are chrooted, we can actually skip the symlink-expansion,\n\t** since it's impossible to get out of the tree.  However, we still\n\t** need to do the pathinfo check, and the existing symlink expansion\n\t** code is a pretty reasonable way to do this.  So, what we do is\n\t** a single stat() of the whole filename - if it exists, then we\n\t** return it as is with nothing in restP.  If it doesn't exist, we\n\t** fall through to the existing code.\n\t**\n\t** One side-effect of this is that users can't symlink to central\n\t** approved CGIs any more.  The workaround is to use the central\n\t** URL for the CGI instead of a local symlinked one.\n\t*/\n\tstruct stat sb;\n\tif ( stat( path, &sb ) != -1 )\n\t    {\n\t    checkedlen = strlen( path );\n\t    httpd_realloc_str( &checked, &maxchecked, checkedlen );\n\t    (void) strcpy( checked, path );\n\t    /* Trim trailing slashes. */\n\t    while ( checkedlen && checked[checkedlen - 1] == '/' )\n\t\t{\n\t\tchecked[checkedlen - 1] = '\\0';\n\t\t--checkedlen;\n\t\t}\n\t    httpd_realloc_str( &rest, &maxrest, 0 );\n\t    rest[0] = '\\0';\n\t    *restP = rest;\n\t    return checked;\n\t    }\n\t}\n\n    /* Start out with nothing in checked and the whole filename in rest. */\n    httpd_realloc_str( &checked, &maxchecked, 1 );\n    checked[0] = '\\0';\n    checkedlen = 0;\n    restlen = strlen( path );\n    httpd_realloc_str( &rest, &maxrest, restlen );\n    (void) strcpy( rest, path );\n    if ( restlen && rest[restlen - 1] == '/' )\n\trest[--restlen] = '\\0';         /* trim trailing slash */\n    if ( ! tildemapped )\n\t/* Remove any leading slashes. */\n\twhile ( rest[0] == '/' )\n\t    {\n\t    /*One more for '\\0', one less for the eaten first*/\n\t    (void) memmove( rest, &(rest[1]), strlen(rest) );\n\t    --restlen;\n\t    }\n    r = rest;\n    nlinks = 0;\n\n    /* While there are still components to check... */\n    while ( restlen > 0 )\n\t{\n\t/* Save current checkedlen in case we get a symlink.  Save current\n\t** restlen in case we get a non-existant component.\n\t*/\n\tprevcheckedlen = checkedlen;\n\tprevrestlen = restlen;\n\n\t/* Grab one component from r and transfer it to checked. */\n\tcp1 = strchr( r, '/' );\n\tif ( cp1 != (char*) 0 )\n\t    {\n\t    i = cp1 - r;\n\t    if ( i == 0 )\n\t\t{\n\t\t/* Special case for absolute paths. */\n\t\thttpd_realloc_str( &checked, &maxchecked, checkedlen + 1 );\n\t\t(void) strncpy( &checked[checkedlen], r, 1 );\n\t\tcheckedlen += 1;\n\t\t}\n\t    else if ( strncmp( r, \"..\", MAX( i, 2 ) ) == 0 )\n\t\t{\n\t\t/* Ignore ..'s that go above the start of the path. */\n\t\tif ( checkedlen != 0 )\n\t\t    {\n\t\t    cp2 = strrchr( checked, '/' );\n\t\t    if ( cp2 == (char*) 0 )\n\t\t\tcheckedlen = 0;\n\t\t    else if ( cp2 == checked )\n\t\t\tcheckedlen = 1;\n\t\t    else\n\t\t\tcheckedlen = cp2 - checked;\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\thttpd_realloc_str( &checked, &maxchecked, checkedlen + 1 + i );\n\t\tif ( checkedlen > 0 && checked[checkedlen-1] != '/' )\n\t\t    checked[checkedlen++] = '/';\n\t\t(void) strncpy( &checked[checkedlen], r, i );\n\t\tcheckedlen += i;\n\t\t}\n\t    checked[checkedlen] = '\\0';\n\t    r += i + 1;\n\t    restlen -= i + 1;\n\t    }\n\telse\n\t    {\n\t    /* No slashes remaining, r is all one component. */\n\t    if ( strcmp( r, \"..\" ) == 0 )\n\t\t{\n\t\t/* Ignore ..'s that go above the start of the path. */\n\t\tif ( checkedlen != 0 )\n\t\t    {\n\t\t    cp2 = strrchr( checked, '/' );\n\t\t    if ( cp2 == (char*) 0 )\n\t\t\tcheckedlen = 0;\n\t\t    else if ( cp2 == checked )\n\t\t\tcheckedlen = 1;\n\t\t    else\n\t\t\tcheckedlen = cp2 - checked;\n\t\t    checked[checkedlen] = '\\0';\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\thttpd_realloc_str(\n\t\t    &checked, &maxchecked, checkedlen + 1 + restlen );\n\t\tif ( checkedlen > 0 && checked[checkedlen-1] != '/' )\n\t\t    checked[checkedlen++] = '/';\n\t\t(void) strcpy( &checked[checkedlen], r );\n\t\tcheckedlen += restlen;\n\t\t}\n\t    r += restlen;\n\t    restlen = 0;\n\t    }\n\n\t/* Try reading the current filename as a symlink */\n\tif ( checked[0] == '\\0' )\n\t    continue;\n\tlinklen = readlink( checked, link, sizeof(link) - 1 );\n\tif ( linklen == -1 )\n\t    {\n\t    if ( errno == EINVAL )\n\t\tcontinue;               /* not a symlink */\n\t    if ( errno == EACCES || errno == ENOENT || errno == ENOTDIR )\n\t\t{\n\t\t/* That last component was bogus.  Restore and return. */\n\t\t*restP = r - ( prevrestlen - restlen );\n\t\tif ( prevcheckedlen == 0 )\n\t\t    (void) strcpy( checked, \".\" );\n\t\telse\n\t\t    checked[prevcheckedlen] = '\\0';\n\t\treturn checked;\n\t\t}\n\t    syslog( LOG_ERR, \"readlink %.80s - %m\", checked );\n\t    return (char*) 0;\n\t    }\n\t++nlinks;\n\tif ( nlinks > MAX_LINKS )\n\t    {\n\t    syslog( LOG_ERR, \"too many symlinks in %.80s\", path );\n\t    return (char*) 0;\n\t    }\n\tlink[linklen] = '\\0';\n\tif ( link[linklen - 1] == '/' )\n\t    link[--linklen] = '\\0';     /* trim trailing slash */\n\n\t/* Insert the link contents in front of the rest of the filename. */\n\tif ( restlen != 0 )\n\t    {\n\t    (void) strcpy( rest, r );\n\t    httpd_realloc_str( &rest, &maxrest, restlen + linklen + 1 );\n\t    for ( i = restlen; i >= 0; --i )\n\t\trest[i + linklen + 1] = rest[i];\n\t    (void) strcpy( rest, link );\n\t    rest[linklen] = '/';\n\t    restlen += linklen + 1;\n\t    r = rest;\n\t    }\n\telse\n\t    {\n\t    /* There's nothing left in the filename, so the link contents\n\t    ** becomes the rest.\n\t    */\n\t    httpd_realloc_str( &rest, &maxrest, linklen );\n\t    (void) strcpy( rest, link );\n\t    restlen = linklen;\n\t    r = rest;\n\t    }\n\n\tif ( rest[0] == '/' )\n\t    {\n\t    /* There must have been an absolute symlink - zero out checked. */\n\t    checked[0] = '\\0';\n\t    checkedlen = 0;\n\t    }\n\telse\n\t    {\n\t    /* Re-check this component. */\n\t    checkedlen = prevcheckedlen;\n\t    checked[checkedlen] = '\\0';\n\t    }\n\t}\n\n    /* Ok. */\n    *restP = r;\n    if ( checked[0] == '\\0' )\n\t(void) strcpy( checked, \".\" );\n    return checked;\n    }\n\n\nint\nhttpd_get_conn( httpd_server* hs, int listen_fd, httpd_conn* hc )\n    {\n    httpd_sockaddr sa;\n    socklen_t sz;\n\n    if ( ! hc->initialized )\n\t{\n\thc->read_size = 0;\n\thttpd_realloc_str( &hc->read_buf, &hc->read_size, 500 );\n\thc->maxdecodedurl =\n\t    hc->maxorigfilename = hc->maxexpnfilename = hc->maxencodings =\n\t    hc->maxpathinfo = hc->maxquery = hc->maxaccept =\n\t    hc->maxaccepte = hc->maxreqhost = hc->maxhostdir =\n\t    hc->maxremoteuser = hc->maxresponse = 0;\n#ifdef TILDE_MAP_2\n\thc->maxaltdir = 0;\n#endif /* TILDE_MAP_2 */\n\thttpd_realloc_str( &hc->decodedurl, &hc->maxdecodedurl, 1 );\n\thttpd_realloc_str( &hc->origfilename, &hc->maxorigfilename, 1 );\n\thttpd_realloc_str( &hc->expnfilename, &hc->maxexpnfilename, 0 );\n\thttpd_realloc_str( &hc->encodings, &hc->maxencodings, 0 );\n\thttpd_realloc_str( &hc->pathinfo, &hc->maxpathinfo, 0 );\n\thttpd_realloc_str( &hc->query, &hc->maxquery, 0 );\n\thttpd_realloc_str( &hc->accept, &hc->maxaccept, 0 );\n\thttpd_realloc_str( &hc->accepte, &hc->maxaccepte, 0 );\n\thttpd_realloc_str( &hc->reqhost, &hc->maxreqhost, 0 );\n\thttpd_realloc_str( &hc->hostdir, &hc->maxhostdir, 0 );\n\thttpd_realloc_str( &hc->remoteuser, &hc->maxremoteuser, 0 );\n\thttpd_realloc_str( &hc->response, &hc->maxresponse, 0 );\n#ifdef TILDE_MAP_2\n\thttpd_realloc_str( &hc->altdir, &hc->maxaltdir, 0 );\n#endif /* TILDE_MAP_2 */\n\thc->initialized = 1;\n\t}\n\n    /* Accept the new connection. */\n    sz = sizeof(sa);\n    hc->conn_fd = accept( listen_fd, &sa.sa, &sz );\n    if ( hc->conn_fd < 0 )\n\t{\n\tif ( errno == EWOULDBLOCK )\n\t    return GC_NO_MORE;\n\tsyslog( LOG_ERR, \"accept - %m\" );\n\treturn GC_FAIL;\n\t}\n    if ( ! sockaddr_check( &sa ) )\n\t{\n\tsyslog( LOG_ERR, \"unknown sockaddr family\" );\n\tclose( hc->conn_fd );\n\thc->conn_fd = -1;\n\treturn GC_FAIL;\n\t}\n    (void) fcntl( hc->conn_fd, F_SETFD, 1 );\n    hc->hs = hs;\n    (void) memset( &hc->client_addr, 0, sizeof(hc->client_addr) );\n    (void) memmove( &hc->client_addr, &sa, sockaddr_len( &sa ) );\n    hc->read_idx = 0;\n    hc->checked_idx = 0;\n    hc->checked_state = CHST_FIRSTWORD;\n    hc->method = METHOD_UNKNOWN;\n    hc->status = 0;\n    hc->bytes_to_send = 0;\n    hc->bytes_sent = 0;\n    hc->encodedurl = \"\";\n    hc->decodedurl[0] = '\\0';\n    hc->protocol = \"UNKNOWN\";\n    hc->origfilename[0] = '\\0';\n    hc->expnfilename[0] = '\\0';\n    hc->encodings[0] = '\\0';\n    hc->pathinfo[0] = '\\0';\n    hc->query[0] = '\\0';\n    hc->referer = \"\";\n    hc->useragent = \"\";\n    hc->accept[0] = '\\0';\n    hc->accepte[0] = '\\0';\n    hc->acceptl = \"\";\n    hc->cookie = \"\";\n    hc->contenttype = \"\";\n    hc->reqhost[0] = '\\0';\n    hc->hdrhost = \"\";\n    hc->hostdir[0] = '\\0';\n    hc->authorization = \"\";\n    hc->remoteuser[0] = '\\0';\n    hc->response[0] = '\\0';\n#ifdef TILDE_MAP_2\n    hc->altdir[0] = '\\0';\n#endif /* TILDE_MAP_2 */\n    hc->responselen = 0;\n    hc->if_modified_since = (time_t) -1;\n    hc->range_if = (time_t) -1;\n    hc->contentlength = -1;\n    hc->type = \"\";\n    hc->hostname = (char*) 0;\n    hc->mime_flag = 1;\n    hc->one_one = 0;\n    hc->got_range = 0;\n    hc->tildemapped = 0;\n    hc->first_byte_index = 0;\n    hc->last_byte_index = -1;\n    hc->keep_alive = 0;\n    hc->should_linger = 0;\n    hc->file_address = (char*) 0;\n    return GC_OK;\n    }\n\n\n/* Checks hc->read_buf to see whether a complete request has been read so far;\n** either the first line has two words (an HTTP/0.9 request), or the first\n** line has three words and there's a blank line present.\n**\n** hc->read_idx is how much has been read in; hc->checked_idx is how much we\n** have checked so far; and hc->checked_state is the current state of the\n** finite state machine.\n*/\nint\nhttpd_got_request( httpd_conn* hc )\n    {\n    char c;\n\n    for ( ; hc->checked_idx < hc->read_idx; ++hc->checked_idx )\n\t{\n\tc = hc->read_buf[hc->checked_idx];\n\tswitch ( hc->checked_state )\n\t    {\n\t    case CHST_FIRSTWORD:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\thc->checked_state = CHST_FIRSTWS;\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\t}\n\t    break;\n\t    case CHST_FIRSTWS:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_SECONDWORD;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_SECONDWORD:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\thc->checked_state = CHST_SECONDWS;\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\t/* The first line has only two words - an HTTP/0.9 request. */\n\t\treturn GR_GOT_REQUEST;\n\t\t}\n\t    break;\n\t    case CHST_SECONDWS:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\tbreak;\n\t\tcase '\\012': case '\\015':\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_THIRDWORD;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_THIRDWORD:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\thc->checked_state = CHST_THIRDWS;\n\t\tbreak;\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_LF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_THIRDWS:\n\t    switch ( c )\n\t\t{\n\t\tcase ' ': case '\\t':\n\t\tbreak;\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_LF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\tdefault:\n\t\thc->checked_state = CHST_BOGUS;\n\t\treturn GR_BAD_REQUEST;\n\t\t}\n\t    break;\n\t    case CHST_LINE:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_LF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_LF:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\t/* Two newlines in a row - a blank line - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CR;\n\t\tbreak;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_CR:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\thc->checked_state = CHST_CRLF;\n\t\tbreak;\n\t\tcase '\\015':\n\t\t/* Two returns in a row - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_CRLF:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012':\n\t\t/* Two newlines in a row - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tcase '\\015':\n\t\thc->checked_state = CHST_CRLFCR;\n\t\tbreak;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_CRLFCR:\n\t    switch ( c )\n\t\t{\n\t\tcase '\\012': case '\\015':\n\t\t/* Two CRLFs or two CRs in a row - end of request. */\n\t\treturn GR_GOT_REQUEST;\n\t\tdefault:\n\t\thc->checked_state = CHST_LINE;\n\t\tbreak;\n\t\t}\n\t    break;\n\t    case CHST_BOGUS:\n\t    return GR_BAD_REQUEST;\n\t    }\n\t}\n    return GR_NO_REQUEST;\n    }\n\n\nint\nhttpd_parse_request( httpd_conn* hc )\n    {\n    char* buf;\n    char* method_str;\n    char* url;\n    char* protocol;\n    char* reqhost;\n    char* eol;\n    char* cp;\n    char* pi;\n\n    hc->checked_idx = 0;\t/* reset */\n    method_str = bufgets( hc );\n    url = strpbrk( method_str, \" \\t\\012\\015\" );\n    if ( url == (char*) 0 )\n\t{\n\thttpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\treturn -1;\n\t}\n    *url++ = '\\0';\n    url += strspn( url, \" \\t\\012\\015\" );\n    protocol = strpbrk( url, \" \\t\\012\\015\" );\n    if ( protocol == (char*) 0 )\n\t{\n\tprotocol = \"HTTP/0.9\";\n\thc->mime_flag = 0;\n\t}\n    else\n\t{\n\t*protocol++ = '\\0';\n\tprotocol += strspn( protocol, \" \\t\\012\\015\" );\n\tif ( *protocol != '\\0' )\n\t    {\n\t    eol = strpbrk( protocol, \" \\t\\012\\015\" );\n\t    if ( eol != (char*) 0 )\n\t\t*eol = '\\0';\n\t    if ( strcasecmp( protocol, \"HTTP/1.0\" ) != 0 )\n\t\thc->one_one = 1;\n\t    }\n\t}\n    hc->protocol = protocol;\n\n    /* Check for HTTP/1.1 absolute URL. */\n    if ( strncasecmp( url, \"http://\", 7 ) == 0 )\n\t{\n\tif ( ! hc->one_one )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\treqhost = url + 7;\n\turl = strchr( reqhost, '/' );\n\tif ( url == (char*) 0 )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\t*url = '\\0';\n\tif ( strchr( reqhost, '/' ) != (char*) 0 || reqhost[0] == '.' )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\thttpd_realloc_str( &hc->reqhost, &hc->maxreqhost, strlen( reqhost ) );\n\t(void) strcpy( hc->reqhost, reqhost );\n\t*url = '/';\n\t}\n\n    if ( *url != '/' )\n\t{\n\thttpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\treturn -1;\n\t}\n\n    if ( strcasecmp( method_str, httpd_method_str( METHOD_GET ) ) == 0 )\n\thc->method = METHOD_GET;\n    else if ( strcasecmp( method_str, httpd_method_str( METHOD_HEAD ) ) == 0 )\n\thc->method = METHOD_HEAD;\n    else if ( strcasecmp( method_str, httpd_method_str( METHOD_POST ) ) == 0 )\n\thc->method = METHOD_POST;\n    else\n\t{\n\thttpd_send_err( hc, 501, err501title, \"\", err501form, method_str );\n\treturn -1;\n\t}\n\n    hc->encodedurl = url;\n    httpd_realloc_str(\n\t&hc->decodedurl, &hc->maxdecodedurl, strlen( hc->encodedurl ) );\n    strdecode( hc->decodedurl, hc->encodedurl );\n\n    httpd_realloc_str(\n\t&hc->origfilename, &hc->maxorigfilename, strlen( hc->decodedurl ) );\n    (void) strcpy( hc->origfilename, &hc->decodedurl[1] );\n    /* Special case for top-level URL. */\n    if ( hc->origfilename[0] == '\\0' )\n\t(void) strcpy( hc->origfilename, \".\" );\n\n    /* Extract query string from encoded URL. */\n    cp = strchr( hc->encodedurl, '?' );\n    if ( cp != (char*) 0 )\n\t{\n\t++cp;\n\thttpd_realloc_str( &hc->query, &hc->maxquery, strlen( cp ) );\n\t(void) strcpy( hc->query, cp );\n\t/* Remove query from (decoded) origfilename. */\n\tcp = strchr( hc->origfilename, '?' );\n\tif ( cp != (char*) 0 )\n\t    *cp = '\\0';\n\t}\n\n    de_dotdot( hc->origfilename );\n    if ( hc->origfilename[0] == '/' ||\n\t ( hc->origfilename[0] == '.' && hc->origfilename[1] == '.' &&\n\t   ( hc->origfilename[2] == '\\0' || hc->origfilename[2] == '/' ) ) )\n\t{\n\thttpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\treturn -1;\n\t}\n\n    if ( hc->mime_flag )\n\t{\n\t/* Read the MIME headers. */\n\twhile ( ( buf = bufgets( hc ) ) != (char*) 0 )\n\t    {\n\t    if ( buf[0] == '\\0' )\n\t\tbreak;\n\t    if ( strncasecmp( buf, \"Referer:\", 8 ) == 0 )\n\t\t{\n\t\tcp = &buf[8];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->referer = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"User-Agent:\", 11 ) == 0 )\n\t\t{\n\t\tcp = &buf[11];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->useragent = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Host:\", 5 ) == 0 )\n\t\t{\n\t\tcp = &buf[5];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->hdrhost = cp;\n\t\tcp = strchr( hc->hdrhost, ':' );\n\t\tif ( cp != (char*) 0 )\n\t\t    *cp = '\\0';\n\t\tif ( strchr( hc->hdrhost, '/' ) != (char*) 0 || hc->hdrhost[0] == '.' )\n\t\t    {\n\t\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t\t    return -1;\n\t\t    }\n\t\t}\n\t    else if ( strncasecmp( buf, \"Accept:\", 7 ) == 0 )\n\t\t{\n\t\tcp = &buf[7];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tif ( hc->accept[0] != '\\0' )\n\t\t    {\n\t\t    if ( strlen( hc->accept ) > 5000 )\n\t\t\t{\n\t\t\tsyslog(\n\t\t\t    LOG_ERR, \"%.80s way too much Accept: data\",\n\t\t\t    httpd_ntoa( &hc->client_addr ) );\n\t\t\tcontinue;\n\t\t\t}\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accept, &hc->maxaccept,\n\t\t\tstrlen( hc->accept ) + 2 + strlen( cp ) );\n\t\t    (void) strcat( hc->accept, \", \" );\n\t\t    }\n\t\telse\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accept, &hc->maxaccept, strlen( cp ) );\n\t\t(void) strcat( hc->accept, cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Accept-Encoding:\", 16 ) == 0 )\n\t\t{\n\t\tcp = &buf[16];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tif ( hc->accepte[0] != '\\0' )\n\t\t    {\n\t\t    if ( strlen( hc->accepte ) > 5000 )\n\t\t\t{\n\t\t\tsyslog(\n\t\t\t    LOG_ERR, \"%.80s way too much Accept-Encoding: data\",\n\t\t\t    httpd_ntoa( &hc->client_addr ) );\n\t\t\tcontinue;\n\t\t\t}\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accepte, &hc->maxaccepte,\n\t\t\tstrlen( hc->accepte ) + 2 + strlen( cp ) );\n\t\t    (void) strcat( hc->accepte, \", \" );\n\t\t    }\n\t\telse\n\t\t    httpd_realloc_str(\n\t\t\t&hc->accepte, &hc->maxaccepte, strlen( cp ) );\n\t\t(void) strcpy( hc->accepte, cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Accept-Language:\", 16 ) == 0 )\n\t\t{\n\t\tcp = &buf[16];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->acceptl = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"If-Modified-Since:\", 18 ) == 0 )\n\t\t{\n\t\tcp = &buf[18];\n\t\thc->if_modified_since = tdate_parse( cp );\n\t\tif ( hc->if_modified_since == (time_t) -1 )\n\t\t    syslog( LOG_DEBUG, \"unparsable time: %.80s\", cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Cookie:\", 7 ) == 0 )\n\t\t{\n\t\tcp = &buf[7];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->cookie = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Range:\", 6 ) == 0 )\n\t\t{\n\t\t/* Only support %d- and %d-%d, not %d-%d,%d-%d or -%d. */\n\t\tif ( strchr( buf, ',' ) == (char*) 0 )\n\t\t    {\n\t\t    char* cp_dash;\n\t\t    cp = strpbrk( buf, \"=\" );\n\t\t    if ( cp != (char*) 0 )\n\t\t\t{\n\t\t\tcp_dash = strchr( cp + 1, '-' );\n\t\t\tif ( cp_dash != (char*) 0 && cp_dash != cp + 1 )\n\t\t\t    {\n\t\t\t    *cp_dash = '\\0';\n\t\t\t    hc->got_range = 1;\n\t\t\t    hc->first_byte_index = atoll( cp + 1 );\n\t\t\t    if ( hc->first_byte_index < 0 )\n\t\t\t\thc->first_byte_index = 0;\n\t\t\t    if ( isdigit( (int) cp_dash[1] ) )\n\t\t\t\t{\n\t\t\t\thc->last_byte_index = atoll( cp_dash + 1 );\n\t\t\t\tif ( hc->last_byte_index < 0 )\n\t\t\t\t    hc->last_byte_index = -1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    else if ( strncasecmp( buf, \"Range-If:\", 9 ) == 0 ||\n\t\t      strncasecmp( buf, \"If-Range:\", 9 ) == 0 )\n\t\t{\n\t\tcp = &buf[9];\n\t\thc->range_if = tdate_parse( cp );\n\t\tif ( hc->range_if == (time_t) -1 )\n\t\t    syslog( LOG_DEBUG, \"unparsable time: %.80s\", cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Content-Type:\", 13 ) == 0 )\n\t\t{\n\t\tcp = &buf[13];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->contenttype = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Content-Length:\", 15 ) == 0 )\n\t\t{\n\t\tcp = &buf[15];\n\t\thc->contentlength = atol( cp );\n\t\t}\n\t    else if ( strncasecmp( buf, \"Authorization:\", 14 ) == 0 )\n\t\t{\n\t\tcp = &buf[14];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\thc->authorization = cp;\n\t\t}\n\t    else if ( strncasecmp( buf, \"Connection:\", 11 ) == 0 )\n\t\t{\n\t\tcp = &buf[11];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tif ( strcasecmp( cp, \"keep-alive\" ) == 0 )\n\t\t    hc->keep_alive = 1;\n\t\t}\n\t    else if ( strncasecmp( buf, \"X-Forwarded-For:\", 16 ) == 0 )\n\t\t{ // Use real IP if available \n\t\tcp = &buf[16];\n\t\tcp += strspn( cp, \" \\t\" );\n\t\tinet_aton( cp, &(hc->client_addr.sa_in.sin_addr) );\n\t\t}\n#ifdef LOG_UNKNOWN_HEADERS\n\t    else if ( strncasecmp( buf, \"Accept-Charset:\", 15 ) == 0 ||\n\t\t      strncasecmp( buf, \"Accept-Language:\", 16 ) == 0 ||\n\t\t      strncasecmp( buf, \"Agent:\", 6 ) == 0 ||\n\t\t      strncasecmp( buf, \"Cache-Control:\", 14 ) == 0 ||\n\t\t      strncasecmp( buf, \"Cache-Info:\", 11 ) == 0 ||\n\t\t      strncasecmp( buf, \"Charge-To:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Client-IP:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Date:\", 5 ) == 0 ||\n\t\t      strncasecmp( buf, \"Extension:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Forwarded:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"From:\", 5 ) == 0 ||\n\t\t      strncasecmp( buf, \"HTTP-Version:\", 13 ) == 0 ||\n\t\t      strncasecmp( buf, \"Max-Forwards:\", 13 ) == 0 ||\n\t\t      strncasecmp( buf, \"Message-Id:\", 11 ) == 0 ||\n\t\t      strncasecmp( buf, \"MIME-Version:\", 13 ) == 0 ||\n\t\t      strncasecmp( buf, \"Negotiate:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"Pragma:\", 7 ) == 0 ||\n\t\t      strncasecmp( buf, \"Proxy-Agent:\", 12 ) == 0 ||\n\t\t      strncasecmp( buf, \"Proxy-Connection:\", 17 ) == 0 ||\n\t\t      strncasecmp( buf, \"Security-Scheme:\", 16 ) == 0 ||\n\t\t      strncasecmp( buf, \"Session-Id:\", 11 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-Color:\", 9 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-CPU:\", 7 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-Disp:\", 8 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-OS:\", 6 ) == 0 ||\n\t\t      strncasecmp( buf, \"UA-Pixels:\", 10 ) == 0 ||\n\t\t      strncasecmp( buf, \"User:\", 5 ) == 0 ||\n\t\t      strncasecmp( buf, \"Via:\", 4 ) == 0 ||\n\t\t      strncasecmp( buf, \"X-\", 2 ) == 0 )\n\t\t; /* ignore */\n\t    else\n\t\tsyslog( LOG_DEBUG, \"unknown request header: %.80s\", buf );\n#endif /* LOG_UNKNOWN_HEADERS */\n\t    }\n\t}\n\n    if ( hc->one_one )\n\t{\n\t/* Check that HTTP/1.1 requests specify a host, as required. */\n\tif ( hc->reqhost[0] == '\\0' && hc->hdrhost[0] == '\\0' )\n\t    {\n\t    httpd_send_err( hc, 400, httpd_err400title, \"\", httpd_err400form, \"\" );\n\t    return -1;\n\t    }\n\n\t/* If the client wants to do keep-alives, it might also be doing\n\t** pipelining.  There's no way for us to tell.  Since we don't\n\t** implement keep-alives yet, if we close such a connection there\n\t** might be unread pipelined requests waiting.  So, we have to\n\t** do a lingering close.\n\t*/\n\tif ( hc->keep_alive )\n\t    hc->should_linger = 1;\n\t}\n\n    /* Ok, the request has been parsed.  Now we resolve stuff that\n    ** may require the entire request.\n    */\n\n    /* Copy original filename to expanded filename. */\n    httpd_realloc_str(\n\t&hc->expnfilename, &hc->maxexpnfilename, strlen( hc->origfilename ) );\n    (void) strcpy( hc->expnfilename, hc->origfilename );\n\n    /* Tilde mapping. */\n    if ( hc->expnfilename[0] == '~' )\n\t{\n#ifdef TILDE_MAP_1\n\tif ( ! tilde_map_1( hc ) )\n\t    {\n\t    httpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\t    return -1;\n\t    }\n#endif /* TILDE_MAP_1 */\n#ifdef TILDE_MAP_2\n\tif ( ! tilde_map_2( hc ) )\n\t    {\n\t    httpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\t    return -1;\n\t    }\n#endif /* TILDE_MAP_2 */\n\t}\n\n    /* Virtual host mapping. */\n    if ( hc->hs->vhost )\n\tif ( ! vhost_map( hc ) )\n\t    {\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\n    /* Expand all symbolic links in the filename.  This also gives us\n    ** any trailing non-existing components, for pathinfo.\n    */\n    cp = expand_symlinks( hc->expnfilename, &pi, hc->hs->no_symlink_check, hc->tildemapped );\n    if ( cp == (char*) 0 )\n\t{\n\thttpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\treturn -1;\n\t}\n    httpd_realloc_str( &hc->expnfilename, &hc->maxexpnfilename, strlen( cp ) );\n    (void) strcpy( hc->expnfilename, cp );\n    httpd_realloc_str( &hc->pathinfo, &hc->maxpathinfo, strlen( pi ) );\n    (void) strcpy( hc->pathinfo, pi );\n\n    /* Remove pathinfo stuff from the original filename too. */\n    if ( hc->pathinfo[0] != '\\0' )\n\t{\n\tint i;\n\ti = strlen( hc->origfilename ) - strlen( hc->pathinfo );\n\tif ( strcmp( &hc->origfilename[i], hc->pathinfo ) == 0 )\n\t    {\n\t    if ( i == 0 ) hc->origfilename[0] = '\\0';\n\t    else hc->origfilename[i - 1] = '\\0';\n\t    }\n\t}\n\n    /* If the expanded filename is an absolute path, check that it's still\n    ** within the current directory or the alternate directory.\n    */\n    if ( hc->expnfilename[0] == '/' )\n\t{\n\tif ( strncmp(\n\t\t hc->expnfilename, hc->hs->cwd, strlen( hc->hs->cwd ) ) == 0 )\n\t    {\n\t    /* Elide the current directory. */\n\t    (void) memmove(\n\t\thc->expnfilename, &hc->expnfilename[strlen( hc->hs->cwd )], strlen(hc->expnfilename) - strlen( hc->hs->cwd ) + 1 );\n\t    }\n#ifdef TILDE_MAP_2\n\telse if ( hc->altdir[0] != '\\0' &&\n\t\t  ( strncmp(\n\t\t       hc->expnfilename, hc->altdir,\n\t\t       strlen( hc->altdir ) ) == 0 &&\n\t\t    ( hc->expnfilename[strlen( hc->altdir )] == '\\0' ||\n\t\t      hc->expnfilename[strlen( hc->altdir )] == '/' ) ) )\n\t    {}\n#endif /* TILDE_MAP_2 */\n\telse\n\t    {\n\t    syslog(\n\t\tLOG_NOTICE, \"%.80s URL \\\"%.80s\\\" goes outside the web tree\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file outside the permitted web server directory tree.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t}\n\n    return 0;\n    }\n\n\nstatic char*\nbufgets( httpd_conn* hc )\n    {\n    int i;\n    char c;\n\n    for ( i = hc->checked_idx; hc->checked_idx < hc->read_idx; ++hc->checked_idx )\n\t{\n\tc = hc->read_buf[hc->checked_idx];\n\tif ( c == '\\012' || c == '\\015' )\n\t    {\n\t    hc->read_buf[hc->checked_idx] = '\\0';\n\t    ++hc->checked_idx;\n\t    if ( c == '\\015' && hc->checked_idx < hc->read_idx &&\n\t\t hc->read_buf[hc->checked_idx] == '\\012' )\n\t\t{\n\t\thc->read_buf[hc->checked_idx] = '\\0';\n\t\t++hc->checked_idx;\n\t\t}\n\t    return &(hc->read_buf[i]);\n\t    }\n\t}\n    return (char*) 0;\n    }\n\n\nstatic void\nde_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n\n    /* Collapse any multiple / sequences. */\n    while ( ( cp = strstr( file, \"//\") ) != (char*) 0 )\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n\n    /* Remove leading ./ and any /./ sequences. */\n    while ( strncmp( file, \"./\", 2 ) == 0 )\n\t(void) memmove( file, file + 2, strlen( file ) - 1 );\n    while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( cp ) - 1 );\n\n    /* Alternate between removing leading ../ and removing xxx/../ */\n    for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n\n    /* Also elide any xxx/.. at the end. */\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }\n\n\nvoid\nhttpd_close_conn( httpd_conn* hc, struct timeval* nowP )\n    {\n    make_log_entry( hc, nowP );\n\n    if ( hc->file_address != (char*) 0 )\n\t{\n\tmmc_unmap( hc->file_address, &(hc->sb), nowP );\n\thc->file_address = (char*) 0;\n\t}\n    if ( hc->conn_fd >= 0 )\n\t{\n\t(void) close( hc->conn_fd );\n\thc->conn_fd = -1;\n\t}\n    }\n\nvoid\nhttpd_destroy_conn( httpd_conn* hc )\n{\n    if (hc->initialized) {\n\tfree(hc->read_buf);\n\tfree(hc->decodedurl);\n\tfree(hc->origfilename);\n\tfree(hc->expnfilename);\n\tfree(hc->encodings);\n\tfree(hc->pathinfo);\n\tfree(hc->query);\n\tfree(hc->accept);\n\tfree(hc->accepte);\n\tfree(hc->reqhost);\n\tfree(hc->hostdir);\n\tfree(hc->remoteuser);\n\tfree(hc->response);\n#ifdef TILDE_MAP_2\n\tfree(hc->altdir);\n#endif /* TILDE_MAP_2 */\n\thc->initialized = 0;\n    }\n}\n\n\nstruct mime_entry {\n    char* ext;\n    size_t ext_len;\n    char* val;\n    size_t val_len;\n    };\nstatic struct mime_entry enc_tab[] = {\n#include \"mime_encodings.h\"\n    };\nstatic const int n_enc_tab = sizeof(enc_tab) / sizeof(*enc_tab);\nstatic struct mime_entry typ_tab[] = {\n#include \"mime_types.h\"\n    };\nstatic const int n_typ_tab = sizeof(typ_tab) / sizeof(*typ_tab);\n\n\n/* qsort comparison routine - declared old-style on purpose, for portability. */\nstatic int\next_compare( a, b )\n    struct mime_entry* a;\n    struct mime_entry* b;\n    {\n    return strcmp( a->ext, b->ext );\n    }\n\n\nstatic void\ninit_mime( void )\n    {\n    int i;\n\n    /* Sort the tables so we can do binary search. */\n    qsort( enc_tab, n_enc_tab, sizeof(*enc_tab), ext_compare );\n    qsort( typ_tab, n_typ_tab, sizeof(*typ_tab), ext_compare );\n\n    /* Fill in the lengths. */\n    for ( i = 0; i < n_enc_tab; ++i )\n\t{\n\tenc_tab[i].ext_len = strlen( enc_tab[i].ext );\n\tenc_tab[i].val_len = strlen( enc_tab[i].val );\n\t}\n    for ( i = 0; i < n_typ_tab; ++i )\n\t{\n\ttyp_tab[i].ext_len = strlen( typ_tab[i].ext );\n\ttyp_tab[i].val_len = strlen( typ_tab[i].val );\n\t}\n\n    }\n\n\n/* Figure out MIME encodings and type based on the filename.  Multiple\n** encodings are separated by commas, and are listed in the order in\n** which they were applied to the file.\n*/\nstatic void\nfigure_mime( httpd_conn* hc )\n    {\n    char* prev_dot;\n    char* dot;\n    char* ext;\n    int me_indexes[100], n_me_indexes;\n    size_t ext_len, encodings_len;\n    int i, top, bot, mid;\n    int r;\n    char* default_type = \"application/octet-stream\";\n\n    /* Peel off encoding extensions until there aren't any more. */\n    n_me_indexes = 0;\n    hc->type = default_type;\n    for ( prev_dot = &hc->expnfilename[strlen(hc->expnfilename)]; ; prev_dot = dot )\n\t{\n\tfor ( dot = prev_dot - 1; dot >= hc->expnfilename && *dot != '.'; --dot )\n\t    ;\n\tif ( dot < hc->expnfilename )\n\t    {\n\t    /* No dot found.  No more extensions.  */\n\t    goto done;\n\t    }\n\text = dot + 1;\n\text_len = prev_dot - ext;\n\t/* Search the encodings table.  Linear search is fine here, there\n\t** are only a few entries.\n\t*/\n\tfor ( i = 0; i < n_enc_tab; ++i )\n\t    {\n\t    if ( ext_len == enc_tab[i].ext_len && strncasecmp( ext, enc_tab[i].ext, ext_len ) == 0 )\n\t\t{\n\t\tif ( n_me_indexes < sizeof(me_indexes)/sizeof(*me_indexes) )\n\t\t    {\n\t\t    me_indexes[n_me_indexes] = i;\n\t\t    ++n_me_indexes;\n\t\t    }\n\t\tbreak;\n\t\t}\n\t    }\n\t/* Binary search for a matching type extension. */\n\ttop = n_typ_tab - 1;\n\tbot = 0;\n\twhile ( top >= bot )\n\t    {\n\t    mid = ( top + bot ) / 2;\n\t    r = strncasecmp( ext, typ_tab[mid].ext, ext_len );\n\t    if ( r < 0 )\n\t\ttop = mid - 1;\n\t    else if ( r > 0 )\n\t\tbot = mid + 1;\n\t    else\n\t\tif ( ext_len < typ_tab[mid].ext_len )\n\t\t    top = mid - 1;\n\t\telse if ( ext_len > typ_tab[mid].ext_len )\n\t\t    bot = mid + 1;\n\t\telse\n\t\t    {\n\t\t    hc->type = typ_tab[mid].val;\n\t\t    goto done;\n\t\t    }\n\t    }\n\t}\n\n    done:\n\n    /* The last thing we do is actually generate the mime-encoding header. */\n    hc->encodings[0] = '\\0';\n    encodings_len = 0;\n    for ( i = n_me_indexes - 1; i >= 0; --i )\n\t{\n\thttpd_realloc_str(\n\t    &hc->encodings, &hc->maxencodings,\n\t    encodings_len + enc_tab[me_indexes[i]].val_len + 1 );\n\tif ( hc->encodings[0] != '\\0' )\n\t    {\n\t    (void) strcpy( &hc->encodings[encodings_len], \",\" );\n\t    ++encodings_len;\n\t    }\n\t(void) strcpy( &hc->encodings[encodings_len], enc_tab[me_indexes[i]].val );\n\tencodings_len += enc_tab[me_indexes[i]].val_len;\n\t}\n\n    }\n\n\n#ifdef CGI_TIMELIMIT\nstatic void\ncgi_kill2( ClientData client_data, struct timeval* nowP )\n    {\n    pid_t pid;\n\n    pid = (pid_t) client_data.i;\n    if ( kill( pid, SIGKILL ) == 0 )\n\tsyslog( LOG_ERR, \"hard-killed CGI process %d\", pid );\n    }\n\nstatic void\ncgi_kill( ClientData client_data, struct timeval* nowP )\n    {\n    pid_t pid;\n\n    pid = (pid_t) client_data.i;\n    if ( kill( pid, SIGINT ) == 0 )\n\t{\n\tsyslog( LOG_ERR, \"killed CGI process %d\", pid );\n\t/* In case this isn't enough, schedule an uncatchable kill. */\n\tif ( tmr_create( nowP, cgi_kill2, client_data, 5 * 1000L, 0 ) == (Timer*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"tmr_create(cgi_kill2) failed\" );\n\t    exit( 1 );\n\t    }\n\t}\n    }\n#endif /* CGI_TIMELIMIT */\n\n\n#ifdef GENERATE_INDEXES\n\n/* qsort comparison routine - declared old-style on purpose, for portability. */\nstatic int\nname_compare( a, b )\n    char** a;\n    char** b;\n    {\n    return strcmp( *a, *b );\n    }\n\n\nstatic int\nls( httpd_conn* hc )\n    {\n    DIR* dirp;\n    struct dirent* de;\n    int namlen;\n    static int maxnames = 0;\n    int nnames;\n    static char* names;\n    static char** nameptrs;\n    static char* name;\n    static size_t maxname = 0;\n    static char* rname;\n    static size_t maxrname = 0;\n    static char* encrname;\n    static size_t maxencrname = 0;\n    FILE* fp;\n    int i, r;\n    struct stat sb;\n    struct stat lsb;\n    char modestr[20];\n    char* linkprefix;\n    char link[MAXPATHLEN+1];\n    int linklen;\n    char* fileclass;\n    time_t now;\n    char* timestr;\n    ClientData client_data;\n\n    dirp = opendir( hc->expnfilename );\n    if ( dirp == (DIR*) 0 )\n\t{\n\tsyslog( LOG_ERR, \"opendir %.80s - %m\", hc->expnfilename );\n\thttpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\treturn -1;\n\t}\n\n    if ( hc->method == METHOD_HEAD )\n\t{\n\tclosedir( dirp );\n\tsend_mime(\n\t    hc, 200, ok200title, \"\", \"\", \"text/html; charset=%s\", (off_t) -1,\n\t    hc->sb.st_mtime );\n\t}\n    else if ( hc->method == METHOD_GET )\n\t{\n\tif ( hc->hs->cgi_limit != 0 && hc->hs->cgi_count >= hc->hs->cgi_limit )\n\t    {\n\t    closedir( dirp );\n\t    httpd_send_err(\n\t\thc, 503, httpd_err503title, \"\", httpd_err503form,\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t++hc->hs->cgi_count;\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    closedir( dirp );\n\t    httpd_send_err(\n\t\thc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Child process. */\n\t    sub_process = 1;\n\t    httpd_unlisten( hc->hs );\n\t    send_mime(\n\t\thc, 200, ok200title, \"\", \"\", \"text/html; charset=%s\",\n\t\t(off_t) -1, hc->sb.st_mtime );\n\t    httpd_write_response( hc );\n\n#ifdef CGI_NICE\n\t    /* Set priority. */\n\t    (void) nice( CGI_NICE );\n#endif /* CGI_NICE */\n\n\t    /* Open a stdio stream so that we can use fprintf, which is more\n\t    ** efficient than a bunch of separate write()s.  We don't have\n\t    ** to worry about double closes or file descriptor leaks cause\n\t    ** we're in a subprocess.\n\t    */\n\t    fp = fdopen( hc->conn_fd, \"w\" );\n\t    if ( fp == (FILE*) 0 )\n\t\t{\n\t\tsyslog( LOG_ERR, \"fdopen - %m\" );\n\t\thttpd_send_err(\n\t\t    hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t\thttpd_write_response( hc );\n\t\tclosedir( dirp );\n\t\texit( 1 );\n\t\t}\n\n\t    (void) fprintf( fp, \"\\\n<HTML>\\n\\\n<HEAD><TITLE>Index of %.80s</TITLE></HEAD>\\n\\\n<BODY BGCOLOR=\\\"#99cc99\\\" TEXT=\\\"#000000\\\" LINK=\\\"#2020ff\\\" VLINK=\\\"#4040cc\\\">\\n\\\n<H2>Index of %.80s</H2>\\n\\\n<PRE>\\n\\\nmode  links  bytes  last-changed  name\\n\\\n<HR>\",\n\t\thc->encodedurl, hc->encodedurl );\n\n\t    /* Read in names. */\n\t    nnames = 0;\n\t    while ( ( de = readdir( dirp ) ) != 0 )     /* dirent or direct */\n\t\t{\n\t\tif ( nnames >= maxnames )\n\t\t    {\n\t\t    if ( maxnames == 0 )\n\t\t\t{\n\t\t\tmaxnames = 100;\n\t\t\tnames = NEW( char, maxnames * ( MAXPATHLEN + 1 ) );\n\t\t\tnameptrs = NEW( char*, maxnames );\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\tmaxnames *= 2;\n\t\t\tnames = RENEW( names, char, maxnames * ( MAXPATHLEN + 1 ) );\n\t\t\tnameptrs = RENEW( nameptrs, char*, maxnames );\n\t\t\t}\n\t\t    if ( names == (char*) 0 || nameptrs == (char**) 0 )\n\t\t\t{\n\t\t\tsyslog( LOG_ERR, \"out of memory reallocating directory names\" );\n\t\t\texit( 1 );\n\t\t\t}\n\t\t    for ( i = 0; i < maxnames; ++i )\n\t\t\tnameptrs[i] = &names[i * ( MAXPATHLEN + 1 )];\n\t\t    }\n\t\tnamlen = NAMLEN(de);\n\t\t(void) strncpy( nameptrs[nnames], de->d_name, namlen );\n\t\tnameptrs[nnames][namlen] = '\\0';\n\t\t++nnames;\n\t\t}\n\t    closedir( dirp );\n\n\t    /* Sort the names. */\n\t    qsort( nameptrs, nnames, sizeof(*nameptrs), name_compare );\n\n\t    /* Generate output. */\n\t    for ( i = 0; i < nnames; ++i )\n\t\t{\n\t\thttpd_realloc_str(\n\t\t    &name, &maxname,\n\t\t    strlen( hc->expnfilename ) + 1 + strlen( nameptrs[i] ) );\n\t\thttpd_realloc_str(\n\t\t    &rname, &maxrname,\n\t\t    strlen( hc->origfilename ) + 1 + strlen( nameptrs[i] ) );\n\t\tif ( hc->expnfilename[0] == '\\0' ||\n\t\t     strcmp( hc->expnfilename, \".\" ) == 0 )\n\t\t    {\n\t\t    (void) strcpy( name, nameptrs[i] );\n\t\t    (void) strcpy( rname, nameptrs[i] );\n\t\t    }\n\t\telse\n\t\t    {\n\t\t    (void) my_snprintf( name, maxname,\n\t\t\t\"%s/%s\", hc->expnfilename, nameptrs[i] );\n\t\t    if ( strcmp( hc->origfilename, \".\" ) == 0 )\n\t\t\t(void) my_snprintf( rname, maxrname,\n\t\t\t    \"%s\", nameptrs[i] );\n\t\t    else\n\t\t\t(void) my_snprintf( rname, maxrname,\n\t\t\t    \"%s%s\", hc->origfilename, nameptrs[i] );\n\t\t    }\n\t\thttpd_realloc_str(\n\t\t    &encrname, &maxencrname, 3 * strlen( rname ) + 1 );\n\t\tstrencode( encrname, maxencrname, rname );\n\n\t\tif ( stat( name, &sb ) < 0 || lstat( name, &lsb ) < 0 )\n\t\t    continue;\n\n\t\tlinkprefix = \"\";\n\t\tlink[0] = '\\0';\n\t\t/* Break down mode word.  First the file type. */\n\t\tswitch ( lsb.st_mode & S_IFMT )\n\t\t    {\n\t\t    case S_IFIFO:  modestr[0] = 'p'; break;\n\t\t    case S_IFCHR:  modestr[0] = 'c'; break;\n\t\t    case S_IFDIR:  modestr[0] = 'd'; break;\n\t\t    case S_IFBLK:  modestr[0] = 'b'; break;\n\t\t    case S_IFREG:  modestr[0] = '-'; break;\n\t\t    case S_IFSOCK: modestr[0] = 's'; break;\n\t\t    case S_IFLNK:  modestr[0] = 'l';\n\t\t    linklen = readlink( name, link, sizeof(link) - 1 );\n\t\t    if ( linklen != -1 )\n\t\t\t{\n\t\t\tlink[linklen] = '\\0';\n\t\t\tlinkprefix = \" -&gt; \";\n\t\t\t}\n\t\t    break;\n\t\t    default:       modestr[0] = '?'; break;\n\t\t    }\n\t\t/* Now the world permissions.  Owner and group permissions\n\t\t** are not of interest to web clients.\n\t\t*/\n\t\tmodestr[1] = ( lsb.st_mode & S_IROTH ) ? 'r' : '-';\n\t\tmodestr[2] = ( lsb.st_mode & S_IWOTH ) ? 'w' : '-';\n\t\tmodestr[3] = ( lsb.st_mode & S_IXOTH ) ? 'x' : '-';\n\t\tmodestr[4] = '\\0';\n\n\t\t/* We also leave out the owner and group name, they are\n\t\t** also not of interest to web clients.  Plus if we're\n\t\t** running under chroot(), they would require a copy\n\t\t** of /etc/passwd and /etc/group, which we want to avoid.\n\t\t*/\n\n\t\t/* Get time string. */\n\t\tnow = time( (time_t*) 0 );\n\t\ttimestr = ctime( &lsb.st_mtime );\n\t\ttimestr[ 0] = timestr[ 4];\n\t\ttimestr[ 1] = timestr[ 5];\n\t\ttimestr[ 2] = timestr[ 6];\n\t\ttimestr[ 3] = ' ';\n\t\ttimestr[ 4] = timestr[ 8];\n\t\ttimestr[ 5] = timestr[ 9];\n\t\ttimestr[ 6] = ' ';\n\t\tif ( now - lsb.st_mtime > 60*60*24*182 )        /* 1/2 year */\n\t\t    {\n\t\t    timestr[ 7] = ' ';\n\t\t    timestr[ 8] = timestr[20];\n\t\t    timestr[ 9] = timestr[21];\n\t\t    timestr[10] = timestr[22];\n\t\t    timestr[11] = timestr[23];\n\t\t    }\n\t\telse\n\t\t    {\n\t\t    timestr[ 7] = timestr[11];\n\t\t    timestr[ 8] = timestr[12];\n\t\t    timestr[ 9] = ':';\n\t\t    timestr[10] = timestr[14];\n\t\t    timestr[11] = timestr[15];\n\t\t    }\n\t\ttimestr[12] = '\\0';\n\n\t\t/* The ls -F file class. */\n\t\tswitch ( sb.st_mode & S_IFMT )\n\t\t    {\n\t\t    case S_IFDIR:  fileclass = \"/\"; break;\n\t\t    case S_IFSOCK: fileclass = \"=\"; break;\n\t\t    case S_IFLNK:  fileclass = \"@\"; break;\n\t\t    default:\n\t\t    fileclass = ( sb.st_mode & S_IXOTH ) ? \"*\" : \"\";\n\t\t    break;\n\t\t    }\n\n\t\t/* And print. */\n\t\t(void)  fprintf( fp,\n\t\t   \"%s %3ld  %10lld  %s  <A HREF=\\\"/%.500s%s\\\">%.80s</A>%s%s%s\\n\",\n\t\t    modestr, (long) lsb.st_nlink, (int64_t) lsb.st_size,\n\t\t    timestr, encrname, S_ISDIR(sb.st_mode) ? \"/\" : \"\",\n\t\t    nameptrs[i], linkprefix, link, fileclass );\n\t\t}\n\n\t    (void) fprintf( fp, \"</PRE></BODY>\\n</HTML>\\n\" );\n\t    (void) fclose( fp );\n\t    exit( 0 );\n\t    }\n\n\t/* Parent process. */\n\tclosedir( dirp );\n\tsyslog( LOG_INFO, \"spawned indexing process %d for directory '%.200s'\", r, hc->expnfilename );\n#ifdef CGI_TIMELIMIT\n\t/* Schedule a kill for the child process, in case it runs too long */\n\tclient_data.i = r;\n\tif ( tmr_create( (struct timeval*) 0, cgi_kill, client_data, CGI_TIMELIMIT * 1000L, 0 ) == (Timer*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"tmr_create(cgi_kill ls) failed\" );\n\t    exit( 1 );\n\t    }\n#endif /* CGI_TIMELIMIT */\n\thc->status = 200;\n\thc->bytes_sent = CGI_BYTECOUNT;\n\thc->should_linger = 0;\n\t}\n    else\n\t{\n\tclosedir( dirp );\n\thttpd_send_err(\n\t    hc, 501, err501title, \"\", err501form, httpd_method_str( hc->method ) );\n\treturn -1;\n\t}\n\n    return 0;\n    }\n\n#endif /* GENERATE_INDEXES */\n\n\nstatic char*\nbuild_env( char* fmt, char* arg )\n    {\n    char* cp;\n    size_t size;\n    static char* buf;\n    static size_t maxbuf = 0;\n\n    size = strlen( fmt ) + strlen( arg );\n    if ( size > maxbuf )\n\thttpd_realloc_str( &buf, &maxbuf, size );\n    (void) my_snprintf( buf, maxbuf, fmt, arg );\n    cp = strdup( buf );\n    if ( cp == (char*) 0 )\n\t{\n\tsyslog( LOG_ERR, \"out of memory copying environment variable\" );\n\texit( 1 );\n\t}\n    return cp;\n    }\n\n\n#ifdef SERVER_NAME_LIST\nstatic char*\nhostname_map( char* hostname )\n    {\n    int len, n;\n    static char* list[] = { SERVER_NAME_LIST };\n\n    len = strlen( hostname );\n    for ( n = sizeof(list) / sizeof(*list) - 1; n >= 0; --n )\n\tif ( strncasecmp( hostname, list[n], len ) == 0 )\n\t    if ( list[n][len] == '/' )  /* check in case of a substring match */\n\t\treturn &list[n][len + 1];\n    return (char*) 0;\n    }\n#endif /* SERVER_NAME_LIST */\n\n\n/* Set up environment variables. Be real careful here to avoid\n** letting malicious clients overrun a buffer.  We don't have\n** to worry about freeing stuff since we're a sub-process.\n*/\nstatic char**\nmake_envp( httpd_conn* hc )\n    {\n    static char* envp[50];\n    int envn;\n    char* cp;\n    char buf[256];\n\n    envn = 0;\n    envp[envn++] = build_env( \"PATH=%s\", CGI_PATH );\n#ifdef CGI_LD_LIBRARY_PATH\n    envp[envn++] = build_env( \"LD_LIBRARY_PATH=%s\", CGI_LD_LIBRARY_PATH );\n#endif /* CGI_LD_LIBRARY_PATH */\n    envp[envn++] = build_env( \"SERVER_SOFTWARE=%s\", SERVER_SOFTWARE );\n    /* If vhosting, use that server-name here. */\n    if ( hc->hs->vhost && hc->hostname != (char*) 0 )\n\tcp = hc->hostname;\n    else\n\tcp = hc->hs->server_hostname;\n    if ( cp != (char*) 0 )\n\tenvp[envn++] = build_env( \"SERVER_NAME=%s\", cp );\n    envp[envn++] = \"GATEWAY_INTERFACE=CGI/1.1\";\n    envp[envn++] = build_env(\"SERVER_PROTOCOL=%s\", hc->protocol);\n    (void) my_snprintf( buf, sizeof(buf), \"%d\", (int) hc->hs->port );\n    envp[envn++] = build_env( \"SERVER_PORT=%s\", buf );\n    envp[envn++] = build_env(\n\t\"REQUEST_METHOD=%s\", httpd_method_str( hc->method ) );\n    if ( hc->pathinfo[0] != '\\0' )\n\t{\n\tchar* cp2;\n\tsize_t l;\n\tenvp[envn++] = build_env( \"PATH_INFO=/%s\", hc->pathinfo );\n\tl = strlen( hc->hs->cwd ) + strlen( hc->pathinfo ) + 1;\n\tcp2 = NEW( char, l );\n\tif ( cp2 != (char*) 0 )\n\t    {\n\t    (void) my_snprintf( cp2, l, \"%s%s\", hc->hs->cwd, hc->pathinfo );\n\t    envp[envn++] = build_env( \"PATH_TRANSLATED=%s\", cp2 );\n\t    }\n\t}\n    envp[envn++] = build_env(\n\t\"SCRIPT_NAME=/%s\", strcmp( hc->origfilename, \".\" ) == 0 ?\n\t\"\" : hc->origfilename );\n    if ( hc->query[0] != '\\0')\n\tenvp[envn++] = build_env( \"QUERY_STRING=%s\", hc->query );\n    envp[envn++] = build_env(\n\t\"REMOTE_ADDR=%s\", httpd_ntoa( &hc->client_addr ) );\n    if ( hc->referer[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_REFERER=%s\", hc->referer );\n    if ( hc->useragent[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_USER_AGENT=%s\", hc->useragent );\n    if ( hc->accept[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_ACCEPT=%s\", hc->accept );\n    if ( hc->accepte[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_ACCEPT_ENCODING=%s\", hc->accepte );\n    if ( hc->acceptl[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_ACCEPT_LANGUAGE=%s\", hc->acceptl );\n    if ( hc->cookie[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_COOKIE=%s\", hc->cookie );\n    if ( hc->contenttype[0] != '\\0' )\n\tenvp[envn++] = build_env( \"CONTENT_TYPE=%s\", hc->contenttype );\n    if ( hc->hdrhost[0] != '\\0' )\n\tenvp[envn++] = build_env( \"HTTP_HOST=%s\", hc->hdrhost );\n    if ( hc->contentlength != -1 )\n\t{\n\t(void) my_snprintf(\n\t    buf, sizeof(buf), \"%lu\", (unsigned long) hc->contentlength );\n\tenvp[envn++] = build_env( \"CONTENT_LENGTH=%s\", buf );\n\t}\n    if ( hc->remoteuser[0] != '\\0' )\n\tenvp[envn++] = build_env( \"REMOTE_USER=%s\", hc->remoteuser );\n    if ( hc->authorization[0] != '\\0' )\n\tenvp[envn++] = build_env( \"AUTH_TYPE=%s\", \"Basic\" );\n\t/* We only support Basic auth at the moment. */\n    if ( getenv( \"TZ\" ) != (char*) 0 )\n\tenvp[envn++] = build_env( \"TZ=%s\", getenv( \"TZ\" ) );\n    envp[envn++] = build_env( \"CGI_PATTERN=%s\", hc->hs->cgi_pattern );\n\n    envp[envn] = (char*) 0;\n    return envp;\n    }\n\n\n/* Set up argument vector.  Again, we don't have to worry about freeing stuff\n** since we're a sub-process.  This gets done after make_envp() because we\n** scribble on hc->query.\n*/\nstatic char**\nmake_argp( httpd_conn* hc )\n    {\n    char** argp;\n    int argn;\n    char* cp1;\n    char* cp2;\n\n    /* By allocating an arg slot for every character in the query, plus\n    ** one for the filename and one for the NULL, we are guaranteed to\n    ** have enough.  We could actually use strlen/2.\n    */\n    argp = NEW( char*, strlen( hc->query ) + 2 );\n    if ( argp == (char**) 0 )\n\treturn (char**) 0;\n\n    argp[0] = strrchr( hc->expnfilename, '/' );\n    if ( argp[0] != (char*) 0 )\n\t++argp[0];\n    else\n\targp[0] = hc->expnfilename;\n\n    argn = 1;\n    /* According to the CGI spec at http://hoohoo.ncsa.uiuc.edu/cgi/cl.html,\n    ** \"The server should search the query information for a non-encoded =\n    ** character to determine if the command line is to be used, if it finds\n    ** one, the command line is not to be used.\"\n    */\n    if ( strchr( hc->query, '=' ) == (char*) 0 )\n\t{\n\tfor ( cp1 = cp2 = hc->query; *cp2 != '\\0'; ++cp2 )\n\t    {\n\t    if ( *cp2 == '+' )\n\t\t{\n\t\t*cp2 = '\\0';\n\t\tstrdecode( cp1, cp1 );\n\t\targp[argn++] = cp1;\n\t\tcp1 = cp2 + 1;\n\t\t}\n\t    }\n\tif ( cp2 != cp1 )\n\t    {\n\t    strdecode( cp1, cp1 );\n\t    argp[argn++] = cp1;\n\t    }\n\t}\n\n    argp[argn] = (char*) 0;\n    return argp;\n    }\n\n\n/* This routine is used only for POST requests.  It reads the data\n** from the request and sends it to the child process.  The only reason\n** we need to do it this way instead of just letting the child read\n** directly is that we have already read part of the data into our\n** buffer.\n*/\nstatic void\ncgi_interpose_input( httpd_conn* hc, int wfd )\n    {\n    size_t c;\n    ssize_t r;\n    char buf[1024];\n\n    c = hc->read_idx - hc->checked_idx;\n    if ( c > 0 )\n\t{\n\tif ( httpd_write_fully( wfd, &(hc->read_buf[hc->checked_idx]), c ) != c )\n\t    return;\n\t}\n    while ( c < hc->contentlength )\n\t{\n\tr = read( hc->conn_fd, buf, MIN( sizeof(buf), hc->contentlength - c ) );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r <= 0 )\n\t    return;\n\tif ( httpd_write_fully( wfd, buf, r ) != r )\n\t    return;\n\tc += r;\n\t}\n    post_post_garbage_hack( hc );\n    }\n\n\n/* Special hack to deal with broken browsers that send a LF or CRLF\n** after POST data, causing TCP resets - we just read and discard up\n** to 2 bytes.  Unfortunately this doesn't fix the problem for CGIs\n** which avoid the interposer process due to their POST data being\n** short.  Creating an interposer process for all POST CGIs is\n** unacceptably expensive.  The eventual fix will come when interposing\n** gets integrated into the main loop as a tasklet instead of a process.\n*/\nstatic void\npost_post_garbage_hack( httpd_conn* hc )\n    {\n    char buf[2];\n\n    /* If we are in a sub-process, turn on no-delay mode in case we\n    ** previously cleared it.\n    */\n    if ( sub_process )\n\thttpd_set_ndelay( hc->conn_fd );\n    /* And read up to 2 bytes. */\n    (void) read( hc->conn_fd, buf, sizeof(buf) );\n    }\n\n\n/* This routine is used for parsed-header CGIs.  The idea here is that the\n** CGI can return special headers such as \"Status:\" and \"Location:\" which\n** change the return status of the response.  Since the return status has to\n** be the very first line written out, we have to accumulate all the headers\n** and check for the special ones before writing the status.  Then we write\n** out the saved headers and proceed to echo the rest of the response.\n*/\nstatic void\ncgi_interpose_output( httpd_conn* hc, int rfd )\n    {\n    int r;\n    char buf[1024];\n    size_t headers_size, headers_len;\n    char* headers;\n    char* br;\n    int status;\n    char* title;\n    char* cp;\n\n    /* Make sure the connection is in blocking mode.  It should already\n    ** be blocking, but we might as well be sure.\n    */\n    httpd_clear_ndelay( hc->conn_fd );\n\n    /* Slurp in all headers. */\n    headers_size = 0;\n    httpd_realloc_str( &headers, &headers_size, 500 );\n    headers_len = 0;\n    for (;;)\n\t{\n\tr = read( rfd, buf, sizeof(buf) );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r <= 0 )\n\t    {\n\t    br = &(headers[headers_len]);\n\t    break;\n\t    }\n\thttpd_realloc_str( &headers, &headers_size, headers_len + r );\n\t(void) memmove( &(headers[headers_len]), buf, r );\n\theaders_len += r;\n\theaders[headers_len] = '\\0';\n\tif ( ( br = strstr( headers, \"\\015\\012\\015\\012\" ) ) != (char*) 0 ||\n\t     ( br = strstr( headers, \"\\012\\012\" ) ) != (char*) 0 )\n\t    break;\n\t}\n\n    /* If there were no headers, bail. */\n    if ( headers[0] == '\\0' )\n\treturn;\n\n    /* Figure out the status.  Look for a Status: or Location: header;\n    ** else if there's an HTTP header line, get it from there; else\n    ** default to 200.\n    */\n    status = 200;\n    if ( strncmp( headers, \"HTTP/\", 5 ) == 0 )\n\t{\n\tcp = headers;\n\tcp += strcspn( cp, \" \\t\" );\n\tstatus = atoi( cp );\n\t}\n    if ( ( cp = strstr( headers, \"Status:\" ) ) != (char*) 0 &&\n\t cp < br &&\n\t ( cp == headers || *(cp-1) == '\\012' ) )\n\t{\n\tcp += 7;\n\tcp += strspn( cp, \" \\t\" );\n\tstatus = atoi( cp );\n\t}\n    else if ( ( cp = strstr( headers, \"Location:\" ) ) != (char*) 0 &&\n\t cp < br &&\n\t ( cp == headers || *(cp-1) == '\\012' ) )\n\tstatus = 302;\n\n    /* Write the status line. */\n    switch ( status )\n\t{\n\tcase 200: title = ok200title; break;\n\tcase 302: title = err302title; break;\n\tcase 304: title = err304title; break;\n\tcase 400: title = httpd_err400title; break;\n#ifdef AUTH_FILE\n\tcase 401: title = err401title; break;\n#endif /* AUTH_FILE */\n\tcase 403: title = err403title; break;\n\tcase 404: title = err404title; break;\n\tcase 408: title = httpd_err408title; break;\n\tcase 500: title = err500title; break;\n\tcase 501: title = err501title; break;\n\tcase 503: title = httpd_err503title; break;\n\tdefault: title = \"Something\"; break;\n\t}\n    (void) my_snprintf( buf, sizeof(buf), \"HTTP/1.0 %d %s\\015\\012\", status, title );\n    (void) httpd_write_fully( hc->conn_fd, buf, strlen( buf ) );\n\n    /* Write the saved headers. */\n    (void) httpd_write_fully( hc->conn_fd, headers, headers_len );\n\n    /* Echo the rest of the output. */\n    for (;;)\n\t{\n\tr = read( rfd, buf, sizeof(buf) );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r <= 0 )\n\t    break;\n\tif ( httpd_write_fully( hc->conn_fd, buf, r ) != r )\n\t    break;\n\t}\n    shutdown( hc->conn_fd, SHUT_WR );\n    }\n\n\n/* CGI child process. */\nstatic void\ncgi_child( httpd_conn* hc )\n    {\n    int r;\n    char** argp;\n    char** envp;\n    char* binary;\n    char* directory;\n\n    /* Unset close-on-exec flag for this socket.  This actually shouldn't\n    ** be necessary, according to POSIX a dup()'d file descriptor does\n    ** *not* inherit the close-on-exec flag, its flag is always clear.\n    ** However, Linux messes this up and does copy the flag to the\n    ** dup()'d descriptor, so we have to clear it.  This could be\n    ** ifdeffed for Linux only.\n    */\n    (void) fcntl( hc->conn_fd, F_SETFD, 0 );\n\n    /* Close the syslog descriptor so that the CGI program can't\n    ** mess with it.  All other open descriptors should be either\n    ** the listen socket(s), sockets from accept(), or the file-logging\n    ** fd, and all of those are set to close-on-exec, so we don't\n    ** have to close anything else.\n    */\n    closelog();\n\n    /* If the socket happens to be using one of the stdin/stdout/stderr\n    ** descriptors, move it to another descriptor so that the dup2 calls\n    ** below don't screw things up.  We arbitrarily pick fd 3 - if there\n    ** was already something on it, we clobber it, but that doesn't matter\n    ** since at this point the only fd of interest is the connection.\n    ** All others will be closed on exec.\n    */\n    if ( hc->conn_fd == STDIN_FILENO || hc->conn_fd == STDOUT_FILENO || hc->conn_fd == STDERR_FILENO )\n\t{\n\tint newfd = dup2( hc->conn_fd, STDERR_FILENO + 1 );\n\tif ( newfd >= 0 )\n\t    hc->conn_fd = newfd;\n\t/* If the dup2 fails, shrug.  We'll just take our chances.\n\t** Shouldn't happen though.\n\t*/\n\t}\n\n    /* Make the environment vector. */\n    envp = make_envp( hc );\n\n    /* Make the argument vector. */\n    argp = make_argp( hc );\n\n    /* Set up stdin.  For POSTs we may have to set up a pipe from an\n    ** interposer process, depending on if we've read some of the data\n    ** into our buffer.\n    */\n    if ( hc->method == METHOD_POST && hc->read_idx > hc->checked_idx )\n\t{\n\tint p[2];\n\n\tif ( pipe( p ) < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"pipe - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Interposer process. */\n\t    sub_process = 1;\n\t    (void) close( p[0] );\n\t    cgi_interpose_input( hc, p[1] );\n\t    exit( 0 );\n\t    }\n\t/* Need to schedule a kill for process r; but in the main process! */\n\t(void) close( p[1] );\n\tif ( p[0] != STDIN_FILENO )\n\t    {\n\t    (void) dup2( p[0], STDIN_FILENO );\n\t    (void) close( p[0] );\n\t    }\n\t}\n    else\n\t{\n\t/* Otherwise, the request socket is stdin. */\n\tif ( hc->conn_fd != STDIN_FILENO )\n\t    (void) dup2( hc->conn_fd, STDIN_FILENO );\n\t}\n\n    /* Set up stdout/stderr.  If we're doing CGI header parsing,\n    ** we need an output interposer too.\n    */\n    if ( strncmp( argp[0], \"nph-\", 4 ) != 0 && hc->mime_flag )\n\t{\n\tint p[2];\n\n\tif ( pipe( p ) < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"pipe - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    httpd_write_response( hc );\n\t    exit( 1 );\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Interposer process. */\n\t    sub_process = 1;\n\t    (void) close( p[1] );\n\t    cgi_interpose_output( hc, p[0] );\n\t    exit( 0 );\n\t    }\n\t/* Need to schedule a kill for process r; but in the main process! */\n\t(void) close( p[0] );\n\tif ( p[1] != STDOUT_FILENO )\n\t    (void) dup2( p[1], STDOUT_FILENO );\n\tif ( p[1] != STDERR_FILENO )\n\t    (void) dup2( p[1], STDERR_FILENO );\n\tif ( p[1] != STDOUT_FILENO && p[1] != STDERR_FILENO )\n\t    (void) close( p[1] );\n\t}\n    else\n\t{\n\t/* Otherwise, the request socket is stdout/stderr. */\n\tif ( hc->conn_fd != STDOUT_FILENO )\n\t    (void) dup2( hc->conn_fd, STDOUT_FILENO );\n\tif ( hc->conn_fd != STDERR_FILENO )\n\t    (void) dup2( hc->conn_fd, STDERR_FILENO );\n\t}\n\n    /* At this point we would like to set close-on-exec again for hc->conn_fd\n    ** (see previous comments on Linux's broken behavior re: close-on-exec\n    ** and dup.)  Unfortunately there seems to be another Linux problem, or\n    ** perhaps a different aspect of the same problem - if we do this\n    ** close-on-exec in Linux, the socket stays open but stderr gets\n    ** closed - the last fd duped from the socket.  What a mess.  So we'll\n    ** just leave the socket as is, which under other OSs means an extra\n    ** file descriptor gets passed to the child process.  Since the child\n    ** probably already has that file open via stdin stdout and/or stderr,\n    ** this is not a problem.\n    */\n    /* (void) fcntl( hc->conn_fd, F_SETFD, 1 ); */\n\n#ifdef CGI_NICE\n    /* Set priority. */\n    (void) nice( CGI_NICE );\n#endif /* CGI_NICE */\n\n    /* Split the program into directory and binary, so we can chdir()\n    ** to the program's own directory.  This isn't in the CGI 1.1\n    ** spec, but it's what other HTTP servers do.\n    */\n    directory = strdup( hc->expnfilename );\n    if ( directory == (char*) 0 )\n\tbinary = hc->expnfilename;      /* ignore errors */\n    else\n\t{\n\tbinary = strrchr( directory, '/' );\n\tif ( binary == (char*) 0 )\n\t    binary = hc->expnfilename;\n\telse\n\t    {\n\t    *binary++ = '\\0';\n\t    (void) chdir( directory );  /* ignore errors */\n\t    }\n\t}\n\n    /* Default behavior for SIGPIPE. */\n#ifdef HAVE_SIGSET\n    (void) sigset( SIGPIPE, SIG_DFL );\n#else /* HAVE_SIGSET */\n    (void) signal( SIGPIPE, SIG_DFL );\n#endif /* HAVE_SIGSET */\n\n    /* Run the program. */\n    (void) execve( binary, argp, envp );\n\n    /* Something went wrong. */\n    syslog( LOG_ERR, \"execve %.80s - %m\", hc->expnfilename );\n    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n    httpd_write_response( hc );\n    exit( 1 );\n    }\n\n\nstatic int\ncgi( httpd_conn* hc )\n    {\n    int r;\n    ClientData client_data;\n\n    if ( hc->method == METHOD_GET || hc->method == METHOD_POST )\n\t{\n\tif ( hc->hs->cgi_limit != 0 && hc->hs->cgi_count >= hc->hs->cgi_limit )\n\t    {\n\t    httpd_send_err(\n\t\thc, 503, httpd_err503title, \"\", httpd_err503form,\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t++hc->hs->cgi_count;\n\thttpd_clear_ndelay( hc->conn_fd );\n\tr = fork( );\n\tif ( r < 0 )\n\t    {\n\t    syslog( LOG_ERR, \"fork - %m\" );\n\t    httpd_send_err(\n\t\thc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\tif ( r == 0 )\n\t    {\n\t    /* Child process. */\n\t    sub_process = 1;\n\t    httpd_unlisten( hc->hs );\n\t    cgi_child( hc );\n\t    }\n\n\t/* Parent process. */\n\tsyslog( LOG_INFO, \"spawned CGI process %d for file '%.200s'\", r, hc->expnfilename );\n#ifdef CGI_TIMELIMIT\n\t/* Schedule a kill for the child process, in case it runs too long */\n\tclient_data.i = r;\n\tif ( tmr_create( (struct timeval*) 0, cgi_kill, client_data, CGI_TIMELIMIT * 1000L, 0 ) == (Timer*) 0 )\n\t    {\n\t    syslog( LOG_CRIT, \"tmr_create(cgi_kill child) failed\" );\n\t    exit( 1 );\n\t    }\n#endif /* CGI_TIMELIMIT */\n\thc->status = 200;\n\thc->bytes_sent = CGI_BYTECOUNT;\n\thc->should_linger = 0;\n\t}\n    else\n\t{\n\thttpd_send_err(\n\t    hc, 501, err501title, \"\", err501form, httpd_method_str( hc->method ) );\n\treturn -1;\n\t}\n\n    return 0;\n    }\n\n\nstatic int\nreally_start_request( httpd_conn* hc, struct timeval* nowP )\n    {\n    static char* indexname;\n    static size_t maxindexname = 0;\n    static const char* index_names[] = { INDEX_NAMES };\n    int i;\n#ifdef AUTH_FILE\n    static char* dirname;\n    static size_t maxdirname = 0;\n#endif /* AUTH_FILE */\n    size_t expnlen, indxlen;\n    char* cp;\n    char* pi;\n\n    expnlen = strlen( hc->expnfilename );\n\n    if ( hc->method != METHOD_GET && hc->method != METHOD_HEAD &&\n\t hc->method != METHOD_POST )\n\t{\n\thttpd_send_err(\n\t    hc, 501, err501title, \"\", err501form, httpd_method_str( hc->method ) );\n\treturn -1;\n\t}\n\n    /* Stat the file. */\n    if ( stat( hc->expnfilename, &hc->sb ) < 0 )\n\t{\n\thttpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Is it world-readable or world-executable?  We check explicitly instead\n    ** of just trying to open it, so that no one ever gets surprised by\n    ** a file that's not set world-readable and yet somehow is\n    ** readable by the HTTP server and therefore the *whole* world.\n    */\n    if ( ! ( hc->sb.st_mode & ( S_IROTH | S_IXOTH ) ) )\n\t{\n\tsyslog(\n\t    LOG_INFO,\n\t    \"%.80s URL \\\"%.80s\\\" resolves to a non world-readable file\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file that is not world-readable.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Is it a directory? */\n    if ( S_ISDIR(hc->sb.st_mode) )\n\t{\n\t/* If there's pathinfo, it's just a non-existent file. */\n\tif ( hc->pathinfo[0] != '\\0' )\n\t    {\n\t    httpd_send_err( hc, 404, err404title, \"\", err404form, hc->encodedurl );\n\t    return -1;\n\t    }\n\n\t/* Special handling for directory URLs that don't end in a slash.\n\t** We send back an explicit redirect with the slash, because\n\t** otherwise many clients can't build relative URLs properly.\n\t*/\n\tif ( strcmp( hc->origfilename, \"\" ) != 0 &&\n\t     strcmp( hc->origfilename, \".\" ) != 0 &&\n\t     hc->origfilename[strlen( hc->origfilename ) - 1] != '/' )\n\t    {\n\t    send_dirredirect( hc );\n\t    return -1;\n\t    }\n\n\t/* Check for an index file. */\n\tfor ( i = 0; i < sizeof(index_names) / sizeof(char*); ++i )\n\t    {\n\t    httpd_realloc_str(\n\t\t&indexname, &maxindexname,\n\t\texpnlen + 1 + strlen( index_names[i] ) );\n\t    (void) strcpy( indexname, hc->expnfilename );\n\t    indxlen = strlen( indexname );\n\t    if ( indxlen == 0 || indexname[indxlen - 1] != '/' )\n\t\t(void) strcat( indexname, \"/\" );\n\t    if ( strcmp( indexname, \"./\" ) == 0 )\n\t\tindexname[0] = '\\0';\n\t    (void) strcat( indexname, index_names[i] );\n\t    if ( stat( indexname, &hc->sb ) >= 0 )\n\t\tgoto got_one;\n\t    }\n\n\t/* Nope, no index file, so it's an actual directory request. */\n#ifdef GENERATE_INDEXES\n\t/* Directories must be readable for indexing. */\n\tif ( ! ( hc->sb.st_mode & S_IROTH ) )\n\t    {\n\t    syslog(\n\t\tLOG_INFO,\n\t\t\"%.80s URL \\\"%.80s\\\" tried to index a directory with indexing disabled\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a directory that has indexing disabled.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n#ifdef AUTH_FILE\n\t/* Check authorization for this directory. */\n\tif ( auth_check( hc, hc->expnfilename ) == -1 )\n\t    return -1;\n#endif /* AUTH_FILE */\n\t/* Referer check. */\n\tif ( ! check_referer( hc ) )\n\t    return -1;\n\t/* Ok, generate an index. */\n\treturn ls( hc );\n#else /* GENERATE_INDEXES */\n\tsyslog(\n\t    LOG_INFO, \"%.80s URL \\\"%.80s\\\" tried to index a directory\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' is a directory, and directory indexing is disabled on this server.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n#endif /* GENERATE_INDEXES */\n\n\tgot_one: ;\n\t/* Got an index file.  Expand symlinks again.  More pathinfo means\n\t** something went wrong.\n\t*/\n\tcp = expand_symlinks( indexname, &pi, hc->hs->no_symlink_check, hc->tildemapped );\n\tif ( cp == (char*) 0 || pi[0] != '\\0' )\n\t    {\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\texpnlen = strlen( cp );\n\thttpd_realloc_str( &hc->expnfilename, &hc->maxexpnfilename, expnlen );\n\t(void) strcpy( hc->expnfilename, cp );\n\n\t/* Now, is the index version world-readable or world-executable? */\n\tif ( ! ( hc->sb.st_mode & ( S_IROTH | S_IXOTH ) ) )\n\t    {\n\t    syslog(\n\t\tLOG_INFO,\n\t\t\"%.80s URL \\\"%.80s\\\" resolves to a non-world-readable index file\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' resolves to an index file that is not world-readable.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t}\n\n#ifdef AUTH_FILE\n    /* Check authorization for this directory. */\n    httpd_realloc_str( &dirname, &maxdirname, expnlen );\n    (void) strcpy( dirname, hc->expnfilename );\n    cp = strrchr( dirname, '/' );\n    if ( cp == (char*) 0 )\n\t(void) strcpy( dirname, \".\" );\n    else\n\t*cp = '\\0';\n    if ( auth_check( hc, dirname ) == -1 )\n\treturn -1;\n\n    /* Check if the filename is the AUTH_FILE itself - that's verboten. */\n    if ( expnlen == sizeof(AUTH_FILE) - 1 )\n\t{\n\tif ( strcmp( hc->expnfilename, AUTH_FILE ) == 0 )\n\t    {\n\t    syslog(\n\t\tLOG_NOTICE,\n\t\t\"%.80s URL \\\"%.80s\\\" tried to retrieve an auth file\",\n\t\thttpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\t    httpd_send_err(\n\t\thc, 403, err403title, \"\",\n\t\tERROR_FORM( err403form, \"The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\\n\" ),\n\t\thc->encodedurl );\n\t    return -1;\n\t    }\n\t}\n    else if ( expnlen >= sizeof(AUTH_FILE) &&\n\t      strcmp( &(hc->expnfilename[expnlen - sizeof(AUTH_FILE) + 1]), AUTH_FILE ) == 0 &&\n\t      hc->expnfilename[expnlen - sizeof(AUTH_FILE)] == '/' )\n\t{\n\tsyslog(\n\t    LOG_NOTICE,\n\t    \"%.80s URL \\\"%.80s\\\" tried to retrieve an auth file\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n#endif /* AUTH_FILE */\n\n    /* Referer check. */\n    if ( ! check_referer( hc ) )\n\treturn -1;\n\n    /* Is it world-executable and in the CGI area? */\n    if ( hc->hs->cgi_pattern != (char*) 0 &&\n\t ( hc->sb.st_mode & S_IXOTH ) &&\n\t match( hc->hs->cgi_pattern, hc->expnfilename ) )\n\treturn cgi( hc );\n\n    /* It's not CGI.  If it's executable or there's pathinfo, someone's\n    ** trying to either serve or run a non-CGI file as CGI.   Either case\n    ** is prohibited.\n    */\n    if ( hc->sb.st_mode & S_IXOTH )\n\t{\n\tsyslog(\n\t    LOG_NOTICE, \"%.80s URL \\\"%.80s\\\" is executable but isn't CGI\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file which is marked executable but is not a CGI file; retrieving it is forbidden.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n    if ( hc->pathinfo[0] != '\\0' )\n\t{\n\tsyslog(\n\t    LOG_INFO, \"%.80s URL \\\"%.80s\\\" has pathinfo but isn't CGI\",\n\t    httpd_ntoa( &hc->client_addr ), hc->encodedurl );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"The requested URL '%.80s' resolves to a file plus CGI-style pathinfo, but the file is not a valid CGI file.\\n\" ),\n\t    hc->encodedurl );\n\treturn -1;\n\t}\n\n    /* Fill in last_byte_index, if necessary. */\n    if ( hc->got_range &&\n\t ( hc->last_byte_index == -1 || hc->last_byte_index >= hc->sb.st_size ) )\n\thc->last_byte_index = hc->sb.st_size - 1;\n\n    figure_mime( hc );\n\n    if ( hc->method == METHOD_HEAD )\n\t{\n\tsend_mime(\n\t    hc, 200, ok200title, hc->encodings, \"\", hc->type, hc->sb.st_size,\n\t    hc->sb.st_mtime );\n\t}\n    else if ( hc->if_modified_since != (time_t) -1 &&\n\t hc->if_modified_since >= hc->sb.st_mtime )\n\t{\n\tsend_mime(\n\t    hc, 304, err304title, hc->encodings, \"\", hc->type, (off_t) -1,\n\t    hc->sb.st_mtime );\n\t}\n    else\n\t{\n\thc->file_address = mmc_map( hc->expnfilename, &(hc->sb), nowP );\n\tif ( hc->file_address == (char*) 0 )\n\t    {\n\t    httpd_send_err( hc, 500, err500title, \"\", err500form, hc->encodedurl );\n\t    return -1;\n\t    }\n\tsend_mime(\n\t    hc, 200, ok200title, hc->encodings, \"\", hc->type, hc->sb.st_size,\n\t    hc->sb.st_mtime );\n\t}\n\n    return 0;\n    }\n\n\nint\nhttpd_start_request( httpd_conn* hc, struct timeval* nowP )\n    {\n    int r;\n\n    /* Really start the request. */\n    r = really_start_request( hc, nowP );\n\n    /* And return the status. */\n    return r;\n    }\n\n\nstatic void\nmake_log_entry( httpd_conn* hc, struct timeval* nowP )\n    {\n    char* ru;\n    char url[305];\n    char bytes[40];\n\n    if ( hc->hs->no_log )\n\treturn;\n\n    /* This is straight CERN Combined Log Format - the only tweak\n    ** being that if we're using syslog() we leave out the date, because\n    ** syslogd puts it in.  The included syslogtocern script turns the\n    ** results into true CERN format.\n    */\n\n    /* Format remote user. */\n    if ( hc->remoteuser[0] != '\\0' )\n\tru = hc->remoteuser;\n    else\n\tru = \"-\";\n    /* If we're vhosting, prepend the hostname to the url.  This is\n    ** a little weird, perhaps writing separate log files for\n    ** each vhost would make more sense.\n    */\n    if ( hc->hs->vhost && ! hc->tildemapped )\n\t(void) my_snprintf( url, sizeof(url),\n\t    \"/%.100s%.200s\",\n\t    hc->hostname == (char*) 0 ? hc->hs->server_hostname : hc->hostname,\n\t    hc->encodedurl );\n    else\n\t(void) my_snprintf( url, sizeof(url),\n\t    \"%.200s\", hc->encodedurl );\n    /* Format the bytes. */\n    if ( hc->bytes_sent >= 0 )\n\t(void) my_snprintf(\n\t    bytes, sizeof(bytes), \"%lld\", (int64_t) hc->bytes_sent );\n    else\n\t(void) strcpy( bytes, \"-\" );\n\n    /* Logfile or syslog? */\n    if ( hc->hs->logfp != (FILE*) 0 )\n\t{\n\ttime_t now;\n\tstruct tm* t;\n\tconst char* cernfmt_nozone = \"%d/%b/%Y:%H:%M:%S\";\n\tchar date_nozone[100];\n\tint zone;\n\tchar sign;\n\tchar date[100];\n\n\t/* Get the current time, if necessary. */\n\tif ( nowP != (struct timeval*) 0 )\n\t    now = nowP->tv_sec;\n\telse\n\t    now = time( (time_t*) 0 );\n\t/* Format the time, forcing a numeric timezone (some log analyzers\n\t** are stoooopid about this).\n\t*/\n\tt = localtime( &now );\n\t(void) strftime( date_nozone, sizeof(date_nozone), cernfmt_nozone, t );\n\tzone = t->tm_gmtoff / 60L;\n\tif ( zone >= 0 )\n\t    sign = '+';\n\telse\n\t    {\n\t    sign = '-';\n\t    zone = -zone;\n\t    }\n\tzone = ( zone / 60 ) * 100 + zone % 60;\n\t(void) my_snprintf( date, sizeof(date),\n\t    \"%s %c%04d\", date_nozone, sign, zone );\n\t/* And write the log entry. */\n\t(void) fprintf( hc->hs->logfp,\n\t    \"%.80s - %.80s [%s] \\\"%.80s %.300s %.80s\\\" %d %s \\\"%.200s\\\" \\\"%.200s\\\"\\n\",\n\t    httpd_ntoa( &hc->client_addr ), ru, date,\n\t    httpd_method_str( hc->method ), url, hc->protocol,\n\t    hc->status, bytes, hc->referer, hc->useragent );\n#ifdef FLUSH_LOG_EVERY_TIME\n\t(void) fflush( hc->hs->logfp );\n#endif\n\t}\n    else\n\tsyslog( LOG_INFO,\n\t    \"%.80s - %.80s \\\"%.80s %.200s %.80s\\\" %d %s \\\"%.200s\\\" \\\"%.200s\\\"\",\n\t    httpd_ntoa( &hc->client_addr ), ru,\n\t    httpd_method_str( hc->method ), url, hc->protocol,\n\t    hc->status, bytes, hc->referer, hc->useragent );\n    }\n\n\n/* Returns 1 if ok to serve the url, 0 if not. */\nstatic int\ncheck_referer( httpd_conn* hc )\n    {\n    int r;\n    char* cp;\n\n    /* Are we doing referer checking at all? */\n    if ( hc->hs->url_pattern == (char*) 0 )\n\treturn 1;\n\n    r = really_check_referer( hc );\n\n    if ( ! r )\n\t{\n\tif ( hc->hs->vhost && hc->hostname != (char*) 0 )\n\t    cp = hc->hostname;\n\telse\n\t    cp = hc->hs->server_hostname;\n\tif ( cp == (char*) 0 )\n\t    cp = \"\";\n\tsyslog(\n\t    LOG_INFO, \"%.80s non-local referer \\\"%.80s%.80s\\\" \\\"%.80s\\\"\",\n\t    httpd_ntoa( &hc->client_addr ), cp, hc->encodedurl, hc->referer );\n\thttpd_send_err(\n\t    hc, 403, err403title, \"\",\n\t    ERROR_FORM( err403form, \"You must supply a local referer to get URL '%.80s' from this server.\\n\" ),\n\t    hc->encodedurl );\n\t}\n    return r;\n    }\n\n\n/* Returns 1 if ok to serve the url, 0 if not. */\nstatic int\nreally_check_referer( httpd_conn* hc )\n    {\n    httpd_server* hs;\n    char* cp1;\n    char* cp2;\n    char* cp3;\n    static char* refhost = (char*) 0;\n    static size_t refhost_size = 0;\n    char *lp;\n\n    hs = hc->hs;\n\n    /* Check for an empty referer. */\n    if ( hc->referer == (char*) 0 || hc->referer[0] == '\\0' ||\n\t ( cp1 = strstr( hc->referer, \"//\" ) ) == (char*) 0 )\n\t{\n\t/* Disallow if we require a referer and the url matches. */\n\tif ( hs->no_empty_referers && match( hs->url_pattern, hc->origfilename ) )\n\t    return 0;\n\t/* Otherwise ok. */\n\treturn 1;\n\t}\n\n    /* Extract referer host. */\n    cp1 += 2;\n    for ( cp2 = cp1; *cp2 != '/' && *cp2 != ':' && *cp2 != '\\0'; ++cp2 )\n\tcontinue;\n    httpd_realloc_str( &refhost, &refhost_size, cp2 - cp1 );\n    for ( cp3 = refhost; cp1 < cp2; ++cp1, ++cp3 )\n\tif ( isupper(*cp1) )\n\t    *cp3 = tolower(*cp1);\n\telse\n\t    *cp3 = *cp1;\n    *cp3 = '\\0';\n\n    /* Local pattern? */\n    if ( hs->local_pattern != (char*) 0 )\n\tlp = hs->local_pattern;\n    else\n\t{\n\t/* No local pattern.  What's our hostname? */\n\tif ( ! hs->vhost )\n\t    {\n\t    /* Not vhosting, use the server name. */\n\t    lp = hs->server_hostname;\n\t    if ( lp == (char*) 0 )\n\t\t/* Couldn't figure out local hostname - give up. */\n\t\treturn 1;\n\t    }\n\telse\n\t    {\n\t    /* We are vhosting, use the hostname on this connection. */\n\t    lp = hc->hostname;\n\t    if ( lp == (char*) 0 )\n\t\t/* Oops, no hostname.  Maybe it's an old browser that\n\t\t** doesn't send a Host: header.  We could figure out\n\t\t** the default hostname for this IP address, but it's\n\t\t** not worth it for the few requests like this.\n\t\t*/\n\t\treturn 1;\n\t    }\n\t}\n\n    /* If the referer host doesn't match the local host pattern, and\n    ** the filename does match the url pattern, it's an illegal reference.\n    */\n    if ( ! match( lp, refhost ) && match( hs->url_pattern, hc->origfilename ) )\n\treturn 0;\n    /* Otherwise ok. */\n    return 1;\n    }\n\n\nchar*\nhttpd_ntoa( httpd_sockaddr* saP )\n    {\n#ifdef USE_IPV6\n    static char str[200];\n\n    if ( getnameinfo( &saP->sa, sockaddr_len( saP ), str, sizeof(str), 0, 0, NI_NUMERICHOST ) != 0 )\n\t{\n\tstr[0] = '?';\n\tstr[1] = '\\0';\n\t}\n    else if ( IN6_IS_ADDR_V4MAPPED( &saP->sa_in6.sin6_addr ) && strncmp( str, \"::ffff:\", 7 ) == 0 )\n\t/* Elide IPv6ish prefix for IPv4 addresses. */\n\t(void) memmove( str, &str[7], strlen( str ) - 6 );\n\n    return str;\n\n#else /* USE_IPV6 */\n\n    return inet_ntoa( saP->sa_in.sin_addr );\n\n#endif /* USE_IPV6 */\n    }\n\n\nstatic int\nsockaddr_check( httpd_sockaddr* saP )\n    {\n    switch ( saP->sa.sa_family )\n\t{\n\tcase AF_INET: return 1;\n#ifdef USE_IPV6\n\tcase AF_INET6: return 1;\n#endif /* USE_IPV6 */\n\tdefault:\n\treturn 0;\n\t}\n    }\n\n\nstatic size_t\nsockaddr_len( httpd_sockaddr* saP )\n    {\n    switch ( saP->sa.sa_family )\n\t{\n\tcase AF_INET: return sizeof(struct sockaddr_in);\n#ifdef USE_IPV6\n\tcase AF_INET6: return sizeof(struct sockaddr_in6);\n#endif /* USE_IPV6 */\n\tdefault:\n\treturn 0;\t/* shouldn't happen */\n\t}\n    }\n\n\n/* Some systems don't have snprintf(), so we make our own that uses\n** either vsnprintf() or vsprintf().  If your system doesn't have\n** vsnprintf(), it is probably vulnerable to buffer overruns.\n** Upgrade!\n*/\nstatic int\nmy_snprintf( char* str, size_t size, const char* format, ... )\n    {\n    va_list ap;\n    int r;\n\n    va_start( ap, format );\n#ifdef HAVE_VSNPRINTF\n    r = vsnprintf( str, size, format, ap );\n#else /* HAVE_VSNPRINTF */\n    r = vsprintf( str, format, ap );\n#endif /* HAVE_VSNPRINTF */\n    va_end( ap );\n    return r;\n    }\n\n\n#ifndef HAVE_ATOLL\nstatic long long\natoll( const char* str )\n    {\n    long long value;\n    long long sign;\n\n    while ( isspace( *str ) )\n\t++str;\n    switch ( *str )\n\t{\n\tcase '-': sign = -1; ++str; break;\n\tcase '+': sign = 1; ++str; break;\n\tdefault: sign = 1; break;\n\t}\n    value = 0;\n    while ( isdigit( *str ) )\n\t{\n\tvalue = value * 10 + ( *str - '0' );\n\t++str;\n\t}\n    return sign * value;\n    }\n#endif /* HAVE_ATOLL */\n\n\n/* Read the requested buffer completely, accounting for interruptions. */\nint\nhttpd_read_fully( int fd, void* buf, size_t nbytes )\n    {\n    int nread;\n\n    nread = 0;\n    while ( nread < nbytes )\n\t{\n\tint r;\n\n\tr = read( fd, (char*) buf + nread, nbytes - nread );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r < 0 )\n\t    return r;\n\tif ( r == 0 )\n\t    break;\n\tnread += r;\n\t}\n\n    return nread;\n    }\n\n\n/* Write the requested buffer completely, accounting for interruptions. */\nint\nhttpd_write_fully( int fd, const void* buf, size_t nbytes )\n    {\n    int nwritten;\n\n    nwritten = 0;\n    while ( nwritten < nbytes )\n\t{\n\tint r;\n\n\tr = write( fd, (char*) buf + nwritten, nbytes - nwritten );\n\tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )\n\t    {\n\t    sleep( 1 );\n\t    continue;\n\t    }\n\tif ( r < 0 )\n\t    return r;\n\tif ( r == 0 )\n\t    break;\n\tnwritten += r;\n\t}\n\n    return nwritten;\n    }\n\n\n/* Generate debugging statistics syslog message. */\nvoid\nhttpd_logstats( long secs )\n    {\n    if ( str_alloc_count > 0 )\n\tsyslog( LOG_INFO,\n\t    \"  libhttpd - %d strings allocated, %lu bytes (%g bytes/str)\",\n\t    str_alloc_count, (unsigned long) str_alloc_size,\n\t    (float) str_alloc_size / str_alloc_count );\n    }\n"], "filenames": ["src/libhttpd.c"], "buggy_code_start_loc": [2413], "buggy_code_end_loc": [2414], "fixing_code_start_loc": [2413], "fixing_code_end_loc": [2414], "type": "CWE-119", "message": "Heap-based Buffer Overflow in the de_dotdot function in libhttpd.c in sthttpd before 2.27.1 allows remote attackers to cause a denial of service (daemon crash) or possibly have unspecified other impact via a crafted filename.", "other": {"cve": {"id": "CVE-2017-10671", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-29T08:29:00.217", "lastModified": "2017-07-03T13:01:20.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in the de_dotdot function in libhttpd.c in sthttpd before 2.27.1 allows remote attackers to cause a denial of service (daemon crash) or possibly have unspecified other impact via a crafted filename."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en la funci\u00f3n de_dotdot en libhttpd.c en sthttpd 2.27.1 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (cierre inesperado del demonio) o, posiblemente, provocar cualquier otro tipo de problema mediante un nombre de archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sthttpd_project:sthttpd:-:*:*:*:*:*:*:*", "matchCriteriaId": "9FD1D9F5-DF8B-485B-B199-F916EC4CC20C"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/06/15/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/blueness/sthttpd/commit/c0dc63a49d8605649f1d8e4a96c9b468b0bff660", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/blueness/sthttpd/releases/tag/v2.27.1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/blueness/sthttpd/commit/c0dc63a49d8605649f1d8e4a96c9b468b0bff660"}}