{"buggy_code": ["// @(#)root/rootd:$Id: 4d5ab379c1d34cf9123e315a1a5153b22cb9f404 $\n// Author: Fons Rademakers   11/08/97\n\n/*************************************************************************\n * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// Rootd                                                                //\n//                                                                      //\n// Root remote file server daemon.                                      //\n// This small server is started either by inetd when a client requests  //\n// a connection to a rootd server or by hand (i.e. from the command     //\n// line). The rootd server works with the ROOT TNetFile class. It       //\n// allows remote access to ROOT database files in either read or        //\n// write mode. By default TNetFile uses port 1094 (allocated by IANA,   //\n// www.iana.org, to rootd). To run rootd via inetd add the              //\n// following line to /etc/services:                                     //\n//                                                                      //\n// rootd     1094/tcp                                                   //\n//                                                                      //\n// and to /etc/inetd.conf:                                              //\n//                                                                      //\n// rootd stream tcp nowait root /usr/local/root/bin/rootd rootd -i      //\n//                                                                      //\n// Force inetd to reread its conf file with \"kill -HUP <pid inetd>\".    //\n//                                                                      //\n// If xinetd is used instead, a file named 'rootd' should be created    //\n// under /etc/xinetd.d with content:                                    //\n//                                                                      //\n// # default: off                                                       //\n// # description: The root daemon                                       //\n// #                                                                    //\n// service rootd                                                        //\n// {                                                                    //\n//      disable         = no                                            //\n//      flags           = REUSE                                         //\n//      socket_type     = stream                                        //\n//      wait            = no                                            //\n//      user            = root                                          //\n//      server          = /usr/local/root/bin/rootd                     //\n//      server_args     = -i -d 0                                       //\n// }                                                                    //\n//                                                                      //\n// and xinetd restarted (/sbin/service xinetd restart).                 //\n//                                                                      //\n// You can also start rootd by hand running directly under your private //\n// account (no root system priviliges needed). For example to start     //\n// rootd listening on port 5151 just type:                              //\n//                                                                      //\n// rootd -p 5151                                                        //\n//                                                                      //\n// Notice: no & is needed. Rootd will go in background by itself.       //\n// In this case, the port number and process id will be printed, e.g.   //\n//                                                                      //\n// ROOTD_PORT=5151                                                      //\n// ROOTD_PID=14433                                                      //\n//                                                                      //\n// Rootd arguments:                                                     //\n//   -b tcpwindowsize  specifies the tcp window size in bytes (e.g. see //\n//                     http://www.psc.edu/networking/perf_tune.html)    //\n//                     Default is 65535. Only change default for pipes  //\n//                     with a high bandwidth*delay product.             //\n//   -C hostcertfile   defines a file where to find information for the //\n//                     local host Globus information (see GLOBUS.README //\n//                     for details)                                     //\n//   -d level          level of debug info written to syslog            //\n//                     0 = no debug (default)                           //\n//                     1 = minimum                                      //\n//                     2 = medium                                       //\n//                     3 = maximum                                      //\n//   -D rootdaemonrc   read access rules from file <rootdaemonrc>.      //\n//                     By default <root_etc_dir>/system.rootdaemonrc is //\n//                     used for access rules; for privately started     //\n//                     daemons $HOME/.rootdaemonrc (if present) takes   //\n//                     highest priority.                                //\n//   -E                obsolete; up to v4.00.08 this option was used to //\n//                     force exclusivity of the authentication tokens;  //\n//                     with the new approach for authentication tab     //\n//                     files this option is dummy.                      //\n//   -f                do not run as daemon, run in the foreground      //\n//   -F filename       Specify that rootd is in CASTOR mode and should  //\n//                     serve this file.                                 //\n//   -G gridmapfile    defines the gridmap file to be used for globus   //\n//                     authentication if different from globus default  //\n//                     (/etc/grid-security/gridmap); (re)defines the    //\n//                     GRIDMAP environment variable.                    //\n//   -h                print usage message                              //\n//   -H reqid          In CASTOR mode, specify the ID of the request    //\n//                     that should be accepted                          //\n//   -i                says we were started by inetd                    //\n//   -noauth           do not require client authentication             //\n//   -nologin          do not login the client to its $HOME as it may   //\n//                     not exist                                        //\n//   -p port#          specifies a different port to listen on.         //\n//                     Use port1-port2 to find first available port in  //\n//                     range. Use 0-N for range relative to service     //\n//                     port.                                            //\n//   -P file           use this password file, instead of .srootdpass   //\n//   -r                files can only be opened in read-only mode       //\n//   -R bitmask        bit mask specifies which methods will allow      //\n//                     authentication to be re-used                     //\n//   -s <sshd_port>    specifies the port number for the sshd daemon    //\n//                     (default is 22)                                  //\n//   -S keytabfile     use this keytab file, instead of the default     //\n//                     (option only supported when compiled with        //\n//                     Kerberos5 support)                               //\n//   -T <tmpdir>       specifies the directory path to be used to place //\n//                     temporary files; default is /usr/tmp.            //\n//                     Useful if not running as root.                   //\n//   -w                do not check /etc/hosts.equiv, $HOME/.rhosts     //\n//                     for UsrPwd authentications; by default these     //\n//                     files are checked first by calling ruserok(...); //\n//                     if this option is specified a password is always //\n//                     required.\n//   rootsys_dir       directory containing the ROOT etc and bin        //\n//                     directories. Superseeds ROOTSYS or built-in      //\n//                     (as specified to ./configure).                   //\n//                                                                      //\n// Rootd can also be configured for anonymous usage (like anonymous     //\n// ftp). To setup rootd to accept anonymous logins do the following     //\n// (while being logged in as root):                                     //\n//                                                                      //\n// - Add the following line to /etc/passwd:                             //\n//                                                                      //\n//   rootd:*:71:72:Anonymous rootd:/var/spool/rootd:/bin/false          //\n//                                                                      //\n//   where you may modify the uid, gid (71, 72) and the home directory  //\n//   to suite your system.                                              //\n//                                                                      //\n// - Add the following line to /etc/group:                              //\n//                                                                      //\n//   rootd:*:72:rootd                                                   //\n//                                                                      //\n//   where the gid must match the gid in /etc/passwd.                   //\n//                                                                      //\n// - Create the directories:                                            //\n//                                                                      //\n//   mkdir /var/spool/rootd                                             //\n//   mkdir /var/spool/rootd/tmp                                         //\n//   chmod 777 /var/spool/rootd/tmp                                     //\n//                                                                      //\n//   Where /var/spool/rootd must match the rootd home directory as      //\n//   specified in the rootd /etc/passwd entry.                          //\n//                                                                      //\n// - To make writable directories for anonymous do, for example:       //\n//                                                                      //\n//   mkdir /var/spool/rootd/pub                                         //\n//   chown rootd:rootd /var/spool/rootd/pub                             //\n//                                                                      //\n// That's all.                                                          //\n//                                                                      //\n// Several remarks:                                                     //\n//  - you can login to an anonymous server either with the names        //\n//    \"anonymous\" or \"rootd\".                                           //\n//  - the passwd should be of type user@host.do.main. Only the @ is     //\n//    enforced for the time being.                                      //\n//  - in anonymous mode the top of the file tree is set to the rootd    //\n//    home directory, therefore only files below the home directory     //\n//    can be accessed.                                                  //\n//  - anonymous mode only works when the server is started via inetd.   //\n//                                                                      //\n//  When your system uses shadow passwords you have to compile rootd    //\n//  with -DR__SHADOWPW. Since shadow passwords can only be accessed     //\n//  while being superuser (root) this works only when the server is     //\n//  started via inetd. Another solution is to create a file             //\n//  ~/.rootdpass containing an encrypted password. If this file exists  //\n//  its password is used for authentication. This method overrides      //\n//  all other authentication methods. To create an encrypted password   //\n//  do something like:                                                  //\n//     perl -e '$pw = crypt(\"<secretpasswd>\",\"salt\"); print \"$pw\\n\"'    //\n//  and store this string in ~/.rootdpass.                              //\n//                                                                      //\n//  To use AFS for authentication compile rootd with the -DR__AFS flag. //\n//  In that case you also need to link with the AFS libraries. See      //\n//  the Makefiles for more details.                                     //\n//                                                                      //\n//  To use Secure Remote Passwords (SRP) for authentication compile     //\n//  rootd with the -DR__SRP flag. In that case you also need to link    //\n//  with the SRP and gmp libraries. See the Makefile for more details.  //\n//  SRP is described at: http://srp.stanford.edu/.                      //\n//                                                                      //\n//  See README.AUTH for more details on the authentication features.    //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n// Protocol changes (see gProtocol):\n// 2 -> 3: added handling of kROOTD_FSTAT message.\n// 3 -> 4: added support for TFTP (i.e. kROOTD_PUTFILE, kROOTD_GETFILE, etc.)\n// 4 -> 5: added support for \"+read\" to allow readers when file is opened for writing\n// 5 -> 6: added support for kerberos5 authentication\n// 6 -> 7: added support for kROOTD_BYE and kROOTD_PROTOCOL2\n// 7 -> 8: added support for Globus, SSH and Rfio authentication and negotiation\n// 8 -> 9: change in Kerberos authentication protocol\n// 9 -> 10: Receives client protocol with kROOTD_PROTOCOL + change cleaning protocol\n// 10 -> 11: modified SSH protocol + support for server 'no authentication' mode\n// 11 -> 12: added support for stat functionality (access,opendir,...) (cfr.TNetSystem)\n//           and support for OpenSSL keys for encryption\n// 12 -> 13: changed return message of RootdFstat()\n// 13 -> 14: support for TNetFile setup via TXNetFile\n// 14 -> 15: support for SSH authentication via SSH tunnel\n// 15 -> 16: cope with the bug fix in TUrl::GetFile\n// 16 -> 17: Addition of \"Gets\" (multiple buffers in a single request)\n// 17 -> 18: fix problems with '//' in admin paths; partial logging in castor mode\n\n#include \"RConfigure.h\"\n#include \"RConfig.h\"\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <netinet/in.h>\n#include <errno.h>\n#include <netdb.h>\n#include \"snprintf.h\"\n\n#include <sys/types.h>\n#include <dirent.h>\n\n#if defined(__CYGWIN__) && defined(__GNUC__)\n#   define cygwingcc\n#endif\n#if defined(__APPLE__)\n#include <sys/mount.h>\nextern \"C\" int fstatfs(int file_descriptor, struct statfs *buffer);\n#elif defined(linux) || defined(__hpux) || defined(cygwingcc)\n#include <sys/vfs.h>\n#elif defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <sys/param.h>\n#include <sys/mount.h>\n#else\n#include <sys/statfs.h>\n#endif\n\n#if defined(linux) || defined(__hpux) || defined(_AIX) || \\\n    defined(__sun) || defined(__sgi) || defined(__FreeBSD__) || \\\n    defined(__APPLE__) || defined(cygwingcc) || defined(__OpenBSD__)\n#define HAVE_MMAP\n#endif\n\n#ifdef HAVE_MMAP\n#   include <sys/mman.h>\n#ifndef MAP_FILE\n#define MAP_FILE 0           /* compatability flag */\n#endif\n#endif\n\n#if (defined(__FreeBSD__) && (__FreeBSD__ < 4)) || defined(__OpenBSD__) || \\\n    (defined(__APPLE__) && (!defined(MAC_OS_X_VERSION_10_3) || \\\n     (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_3)))\n#include <sys/file.h>\n#define lockf(fd, op, sz)   flock((fd), (op))\n#ifndef F_LOCK\n#define F_LOCK             (LOCK_EX | LOCK_NB)\n#endif\n#ifndef F_ULOCK\n#define F_ULOCK             LOCK_UN\n#endif\n#endif\n\n#if defined(cygwingcc) && !defined(F_LOCK) && !defined(F_ULOCK)\n#define F_LOCK F_WRLCK\n#define F_ULOCK F_UNLCK\nstatic int fcntl_lockf(int fd, int op, off_t off)\n{\n   flock fl;\n   fl.l_whence = SEEK_SET;\n   fl.l_start  = off;\n   fl.l_len    = 0;       // whole file\n   fl.l_pid    = getpid();\n   fl.l_type   = op;\n   return fcntl(fd, F_SETLK, &fl);\n}\n#define lockf fcntl_lockf\n#endif\n\n#if defined(linux) || defined(__sun) || defined(__sgi) || \\\n    defined(_AIX) || defined(__FreeBSD__) || defined(__APPLE__) || \\\n    defined(__MACH__) || defined(cygwingcc) || defined(__OpenBSD__)\n#include <grp.h>\n#include <sys/types.h>\n#include <signal.h>\n#define ROOT_SIGNAL_INCLUDED\n#endif\n\n#if defined(__sgi) && !defined(__GNUG__) && (SGI_REL<62)\nextern \"C\" {\n   int seteuid(int euid);\n   int setegid(int egid);\n}\n#endif\n\n#if defined(_AIX)\nextern \"C\" {\n   //int initgroups(const char *name, int basegid);\n   int seteuid(uid_t euid);\n   int setegid(gid_t egid);\n}\n#endif\n\n#include \"NetErrors.h\"\n#include \"rootdp.h\"\n\n// Debug flag\nint gDebug  = 0;\n\n//--- Local Globals -----------------------------------------------------------\n\nenum EFileMode{ kBinary, kAscii };\n\nstatic std::string gRootdTab;     // keeps track of open files\nstatic std::string gRpdAuthTab;   // keeps track of authentication info\nstatic EService gService         = kROOTD;\nstatic int gProtocol             = 18;      // increase when protocol changes\nstatic int gClientProtocol       = -1;      // Determined by RpdInitSession\nstatic int gAnon                 = 0;       // anonymous user flag\nstatic double gBytesRead         = 0;\nstatic double gBytesWritten      = 0;\nstatic DIR *gRDDirectory         = 0;\nstatic int gDownloaded           = 0;\nstatic int gFd                   = -1;\nstatic int gFtp                  = 0;\nstatic int gInetdFlag            = 0;\nstatic char gOption[32]          = { 0 };\nstatic char gRdFile[kMAXPATHLEN]   = { 0 };\nstatic int gUploaded             = 0;\nstatic int gWritable             = 0;\nstatic int gReadOnly             = 0;\nstatic std::string gUser;\nstatic std::string gPasswd;\n\n// CASTOR specific\nstatic int gCastorFlag           = 0;\nstatic std::string gCastorFile;\nstatic std::string gCastorReqId;\n\nusing namespace ROOT;\n\n//--- Error handlers -----------------------------------------------------------\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid Err(int level,const char *msg, int size)\n{\n   Perror((char *)msg,size);\n   if (level > -1) NetSendError((ERootdErrors)level);\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid ErrFatal(int level,const char *msg, int size)\n{\n   Perror((char *)msg,size);\n   if (level > -1) NetSendError((ERootdErrors)level);\n   RootdClose();\n   exit(1);\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid ErrSys(int level,const char *msg, int size)\n{\n   Perror((char *)msg,size);\n   ErrFatal(level,msg,size);\n}\n\n//--- Rootd routines -----------------------------------------------------------\n\nconst char *shellMeta   = \"~*[]{}?$\";\nconst char *shellStuff  = \"(){}<>\\\"'\";\nconst char  shellEscape = '\\\\';\n\n////////////////////////////////////////////////////////////////////////////////\n/// Escape specchars in src with escchar and copy to dst.\n\nstatic int EscChar(const char *src, char *dst, int dstlen, const char *specchars, char escchar)\n{\n   const char *p;\n   char *q, *end = dst+dstlen-1;\n\n   for (p = src, q = dst; *p && q < end; ) {\n      if (strchr(specchars, *p)) {\n         *q++ = escchar;\n         if (q < end)\n            *q++ = *p++;\n      } else\n         *q++ = *p++;\n   }\n   *q = '\\0';\n\n   if (*p != 0)\n      return -1;\n   return q-dst;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// After SO_KEEPALIVE times out we probably get a SIGPIPE.\n\nvoid SigPipe(int)\n{\n   ErrorInfo(\"SigPipe: rootd.cxx: got a SIGPIPE\");\n\n   // Terminate properly\n   RpdAuthCleanup(0, 0);\n   RootdClose();\n   exit(1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns the user's home directory.\n\nstatic const char *HomeDirectory(const char *name)\n{\n   static char path[kMAXPATHLEN], mydir[kMAXPATHLEN];\n   struct passwd *pw;\n\n   if (name) {\n      pw = getpwnam(name);\n      if (pw) {\n         strncpy(path, pw->pw_dir, kMAXPATHLEN-1);\n         path[sizeof(path)-1] = '\\0';\n         return path;\n      }\n   } else {\n      if (mydir[0])\n         return mydir;\n      pw = getpwuid(getuid());\n      if (pw) {\n         strncpy(mydir, pw->pw_dir, kMAXPATHLEN-1);\n         mydir[sizeof(mydir)-1] = '\\0';\n         return mydir;\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Expand a pathname getting rid of special shell characters like ~.$, etc.\n/// Returned string must be freed by caller.\n\nchar *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n\n   // skip leading blanks\n   while (*patbuf == ' ')\n      patbuf++;\n\n   // any shell meta characters?\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n\n   return strdup(name);\n\nneedshell:\n   // escape shell quote characters\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n\n   // emulate csh -> popen executes sh\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         // extract user name\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n\n   // read first argument\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   // this will be true if forked process was not yet ready to be read\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n\n   // skip rest of pipe\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n\n   ::pclose(pf);\n\n   return strdup(expPatbuf);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Checks gRootdTab file to see if file can be opened. If mode = 1 then\n/// check if file can safely be opened in write mode, i.e. see if file\n/// is not already opened in either read or write mode. If mode = 0 then\n/// check if file can safely be opened in read mode, i.e. see if file\n/// is not already opened in write mode. If mode = -1 check write mode\n/// like 1 but do not update rootdtab file. Returns 1 if file can be\n/// opened safely, otherwise 0.\n///\n/// The format of the file is:\n/// filename device inode mode username pid\n/// where device is the unique file system id, inode is the unique file\n/// ref number, mode is either \"read\" or \"write\", username the user\n/// who has the file open and pid is the pid of the rootd having the\n/// file open.\n\nint RootdCheckTab(int mode)\n{\n   // Open rootdtab file. Try first /usr/tmp and then /tmp.\n   // The lockf() call can fail if the directory is NFS mounted\n   // and the lockd daemon is not running.\n\n   const char *sfile = gRootdTab.c_str();\n   int fid, create = 0;\n\n   int noupdate = 0;\n   if (mode < 0) {\n      mode = 1;\n      noupdate = 1;\n   }\n\nagain:\n   if (access(sfile, F_OK) == -1) {\n      fid = open(sfile, O_CREAT|O_RDWR, 0644);\n      if (fid != -1) fchmod(fid, 0666);    // override umask setting\n      create = 1;\n   } else\n      fid = open(sfile, O_RDWR);\n\n   if (fid == -1) {\n      if (sfile[1] == 'u') {\n         sfile = gRootdTab.c_str()+4;\n         goto again;\n      }\n      Error(ErrSys, kErrFatal, \"RootdCheckTab: error opening %s\", sfile);\n   }\n\n   // lock the file\n   if (lockf(fid, F_LOCK, (off_t)1) == -1) {\n      if (sfile[1] == 'u' && create) {\n         close(fid);\n         remove(sfile);\n         sfile = gRootdTab.c_str()+4;\n         goto again;\n      }\n      Error(ErrSys, kErrFatal, \"RootdCheckTab: error locking %s\", sfile);\n   }\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCheckTab: file %s locked\", sfile);\n\n   struct stat sbuf;\n   fstat(fid, &sbuf);\n   size_t siz = sbuf.st_size;\n\n   dev_t device;\n   ino_t inode;\n   if (stat(gRdFile, &sbuf) == -1) {\n      device = 0;\n      inode  = 0;\n   } else {\n      device = sbuf.st_dev;\n      inode  = sbuf.st_ino;\n   }\n\n   char msg[kMAXPATHLEN];\n   const char *smode = (mode == 1) ? \"write\" : \"read\";\n   int result = 1;\n\n   if (siz > 0) {\n      int changed = 0;\n      char *fbuf = new char[siz+1];\n      char *flast = fbuf + siz;\n\n      while (read(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n         ResetErrno();\n      fbuf[siz] = 0;\n\n      char *n, *s = fbuf;\n      while ((n = strchr(s, '\\n')) && siz > 0) {\n         n++;\n         char user[64], gmode[32];\n         int  pid;\n         unsigned long dev, ino;\n         sscanf(s, \"%s %lu %lu %s %s %d\", msg, &dev, &ino, gmode, user, &pid);\n         if (kill(pid, 0) == -1 && GetErrno() == ESRCH) {\n            ErrorInfo(\"RootdCheckTab: remove stale lock (%s %lu %lu %s %s %d)\\n\",\n                msg, dev, ino, gmode, user, pid);\n            if (n >= flast) {\n               siz = int(s - fbuf);\n               changed = 1;\n               break;\n            } else {\n               int l = int(flast - n) + 1;\n               memmove(s, n, l);\n               siz -= int(n - s);\n               n = s;\n            }\n            flast = fbuf + siz;\n            changed = 1;\n         } else if ((dev_t)dev == device && (ino_t)ino == inode) {\n            if (mode == 1)\n               result = 0;\n            else if (!strcmp(gmode, \"write\"))\n               result = 0;\n         }\n         s = n;\n      }\n      if (changed) {\n         if (ftruncate(fid, 0) == -1)\n            ErrorInfo(\"RootdCheckTab: ftruncate failed\");\n         lseek(fid, 0, SEEK_SET);\n         if (siz > 0) {\n            while (write(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n               ResetErrno();\n         }\n      }\n      delete [] fbuf;\n   }\n\n   if (result && !noupdate) {\n      unsigned long dev = device;\n      unsigned long ino = inode;\n      char *tmsg = msg;\n      int lmsg = strlen(gRdFile) + gUser.length() + strlen(smode) + 40;\n      if (lmsg > kMAXPATHLEN)\n         tmsg = new char[lmsg];\n      sprintf(tmsg, \"%s %lu %lu %s %s %d\\n\",\n                   gRdFile, dev, ino, smode, gUser.c_str(), (int) getpid());\n      if (write(fid, tmsg, strlen(tmsg)) == -1)\n         Error(ErrSys, kErrFatal, \"RootdCheckTab: error writing %s\", sfile);\n      if (tmsg != msg)\n         delete[] tmsg;\n   }\n\n   // unlock the file\n   lseek(fid, 0, SEEK_SET);\n   if (lockf(fid, F_ULOCK, (off_t)1) == -1)\n      Error(ErrSys, kErrFatal, \"RootdCheckTab: error unlocking %s\", sfile);\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCheckTab: file %s unlocked\", sfile);\n\n   close(fid);\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Removes from the gRootdTab file the reference to gRdFile for the\n/// current rootd. If force = 1, then remove all references for gRdFile\n/// from the gRootdTab file. This might be necessary in case something\n/// funny happened and the original reference was not correctly removed.\n/// Stale locks are detected by checking each pid and then removed.\n\nvoid RootdCloseTab(int force = 0)\n{\n   const char *sfile = gRootdTab.c_str();\n   int fid;\n\nagain:\n   if (access(sfile, F_OK) == -1) {\n      if (sfile[1] == 'u') {\n         sfile = gRootdTab.c_str()+4;\n         goto again;\n      }\n      ErrorInfo(\"RootdCloseTab: file %s does not exist\", sfile);\n      return;\n   }\n\n   fid = open(sfile, O_RDWR);\n\n   if (fid == -1) {\n      ErrorInfo(\"RootdCloseTab: error opening %s\", sfile);\n      return;\n   }\n\n   // lock the file\n   if (lockf(fid, F_LOCK, (off_t)1) == -1) {\n      ErrorInfo(\"RootdCloseTab: error locking %s\", sfile);\n      close(fid);\n      return;\n   }\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCloseTab: file %s locked\", sfile);\n\n   struct stat sbuf;\n   fstat(fid, &sbuf);\n   size_t siz = sbuf.st_size;\n\n   stat(gRdFile, &sbuf);\n   dev_t device = sbuf.st_dev;\n   ino_t inode  = sbuf.st_ino;\n\n   if (siz > 0) {\n      int changed = 0;\n      int mypid   = getpid();\n      char *fbuf  = new char[siz+1];\n      char *flast = fbuf + siz;\n\n      while (read(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n         ResetErrno();\n      fbuf[siz] = 0;\n\n      char *n, *s = fbuf;\n      while ((n = strchr(s, '\\n')) && siz > 0) {\n         n++;\n         char msg[kMAXPATHLEN], user[64], gmode[32];\n         int  pid, stale = 0;\n         unsigned long dev, ino;\n         sscanf(s, \"%s %lu %lu %s %s %d\", msg, &dev, &ino, gmode, user, &pid);\n         if (kill(pid, 0) == -1 && GetErrno() == ESRCH) {\n            stale = 1;\n            ErrorInfo(\"Remove Stale Lock (%s %lu %lu %s %s %d)\\n\",\n                       msg, dev, ino, gmode, user, pid);\n         }\n         if (stale || (!force && mypid == pid) ||\n            (force && device == (dev_t)dev && inode == (ino_t)ino &&\n             !strcmp(gUser.c_str(), user))) {\n            if (n >= flast) {\n               siz = int(s - fbuf);\n               changed = 1;\n               break;\n            } else {\n               int l = int(flast - n) + 1;\n               memmove(s, n, l);\n               siz -= int(n - s);\n               n = s;\n            }\n            flast = fbuf + siz;\n            changed = 1;\n         }\n         s = n;\n      }\n      if (changed) {\n         if (ftruncate(fid, 0) == -1)\n            ErrorInfo(\"RootdCheckTab: ftruncate failed\");\n         lseek(fid, 0, SEEK_SET);\n         if (siz > 0) {\n            while (write(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n               ResetErrno();\n         }\n      }\n      delete [] fbuf;\n   }\n\n   // unlock the file\n   lseek(fid, 0, SEEK_SET);\n   if (lockf(fid, F_ULOCK, (off_t)1) == -1) {\n      ErrorInfo(\"RootdCloseTab: error unlocking %s\", sfile);\n      close(fid);\n      return;\n   }\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCloseTab: file %s unlocked\", sfile);\n\n   close(fid);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint RootdIsOpen()\n{\n   if (gFd == -1) return 0;\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdCloseFtp()\n{\n   if (gDebug > 0)\n      ErrorInfo(\"RootdCloseFtp: %d files uploaded, %d files downloaded,\"\n                \" rd=%g, wr=%g, rx=%g, tx=%g\",\n                gUploaded, gDownloaded, gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n   else\n      ErrorInfo(\"Rootd: %d files uploaded, %d files downloaded, rd=%g,\"\n                \" wr=%g, rx=%g, tx=%g\",\n                gUploaded, gDownloaded, gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdClose()\n{\n   if (gFtp) {\n      RootdCloseFtp();\n      return;\n   }\n\n   if (RootdIsOpen()) {\n      close(gFd);\n      gFd = -1;\n   }\n\n   RootdCloseTab();\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdClose: file %s closed, rd=%g, wr=%g, rx=%g, tx=%g\",\n                gRdFile, gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n   else\n      ErrorInfo(\"Rootd: file %s closed, rd=%g, wr=%g, rx=%g, tx=%g\", gRdFile,\n                gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdFlush()\n{\n   if (RootdIsOpen() && gWritable) {\n#ifndef WIN32\n      if (fsync(gFd) < 0)\n         Error(ErrSys, kErrFatal, \"RootdFlush: error flushing file %s\", gRdFile);\n#endif\n   }\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdFlush: file %s flushed\", gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdStat()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return file stat information in same format as TSystem::GetPathInfo().\n\nvoid RootdFstat(const char *buf)\n{\n   char     msg[256];\n   int      islink = 0;\n\n#if defined(R__SEEK64)\n   struct stat64 statbuf;\n#elif defined(WIN32)\n   struct _stati64 statbuf;\n#else\n   struct stat statbuf;\n#endif\n\n   int rc = -1;\n   if (!buf || !buf[0]) {\n\n      if (RootdIsOpen()) {\n#if defined(R__SEEK64)\n         rc = fstat64(gFd, &statbuf);\n#elif defined(WIN32)\n         rc = _fstati64(gFd, &statbuf);\n#else\n         rc = fstat(gFd, &statbuf);\n#endif\n      }\n   } else {\n\n      char *epath = (char *)buf;\n      if (buf[0] == '/' && buf[1] == '/')\n         epath++;\n#if defined(R__SEEK64)\n      rc = lstat64(epath, &statbuf);\n#elif defined(WIN32)\n      rc = _stati64(epath, &statbuf);\n#else\n      rc = lstat(epath, &statbuf);\n#endif\n      if (rc >= 0) {\n         islink = S_ISLNK(statbuf.st_mode);\n         if (islink) {\n#if defined(R__SEEK64)\n            rc = stat64(epath, &statbuf);\n#elif defined(WIN32)\n            rc = _stati64(epath, &statbuf);\n#else\n            rc = stat(epath, &statbuf);\n#endif\n         }\n      }\n   }\n\n   // New format for recent clients\n   if (gClientProtocol > 11) {\n      if (rc >= 0)\n         sprintf(msg, \"%ld %ld %d %d %d %lld %ld %d\", (long)statbuf.st_dev,\n                 (long)statbuf.st_ino, statbuf.st_mode, (int)(statbuf.st_uid),\n                 (int)(statbuf.st_gid), (Long64_t)statbuf.st_size, statbuf.st_mtime,\n                 islink);\n      else\n         sprintf(msg, \"-1 -1 -1 -1 -1 -1 -1 -1\");\n   } else {\n      // Old client: use previous incomplete format\n      if (rc >= 0) {\n         long id = (statbuf.st_dev << 24) + statbuf.st_ino;\n         Long64_t size = statbuf.st_size;\n         long modtime = statbuf.st_mtime;\n         long flags = 0;\n         if (statbuf.st_mode & ((S_IEXEC)|(S_IEXEC>>3)|(S_IEXEC>>6)))\n            flags |= 1;\n         if ((statbuf.st_mode & S_IFMT) == S_IFDIR)\n            flags |= 2;\n         if ((statbuf.st_mode & S_IFMT) != S_IFREG &&\n             (statbuf.st_mode & S_IFMT) != S_IFDIR)\n            flags |= 4;\n         sprintf(msg, \"%ld %lld %ld %ld\", id, size, flags, modtime);\n      } else\n         sprintf(msg, \"-1 -1 -1 -1\");\n   }\n\n   NetSend(msg, kROOTD_FSTAT);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Handle initialization message from remote host. If size > 1 then\n/// so many parallel sockets will be opened to the remote host.\n\nvoid RootdParallel()\n{\n   int buf[3];\n   if (NetRecvRaw(buf, sizeof(buf)) < 0)\n      Error(ErrFatal, kErrFatal, \"RootdParallel: error receiving message\");\n\n   int size = ntohl(buf[1]);\n   int port = ntohl(buf[2]);\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdParallel: port = %d, size = %d\", port, size);\n\n   if (size > 1)\n      NetParOpen(port, size);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// System independent open().\n\nstatic int SysOpen(const char *pathname, int flags, unsigned int mode)\n{\n#if defined(R__WINGCC)\n   // ALWAYS use binary mode - even cygwin text should be in unix format\n   // although this is posix default it has to be set explicitly\n   return ::open(pathname, flags | O_BINARY, mode);\n#elif defined(R__SEEK64)\n   return ::open64(pathname, flags, mode);\n#else\n   return ::open(pathname, flags, mode);\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Open file in mode depending on specified option. If file is already\n/// opened by another rootd in write mode, do not open the file.\n\nvoid RootdOpen(const char *msg)\n{\n   char file[kMAXPATHLEN], option[32];\n\n   gBytesRead = gBytesWritten = 0;\n   NetResetByteCount();\n\n   sscanf(msg, \"%s %s\", file, option);\n\n   if (gCastorFlag) {\n\n      // Checking the CASTOR Request ID\n      if (gCastorReqId.length() > 0) {\n         if (strstr(file, gCastorReqId.c_str()) == 0) {\n            Error(ErrFatal, kErrNoAccess,\n                  \"RootdOpen: Bad CASTOR Request ID: %s rather than %s\",\n                  file, gCastorReqId.c_str());\n         }\n      }\n\n      ErrorInfo(\"RootdOpen: CASTOR Flag on, file: %s\", gCastorFile.c_str());\n      strncpy(gRdFile, gCastorFile.c_str(), kMAXPATHLEN-1);\n      gRdFile[kMAXPATHLEN-1] = '\\0';\n\n   } else {\n\n      if (gClientProtocol > 14) {\n         strlcpy(gRdFile, file, sizeof(gRdFile));\n      } else {\n         // Old clients send an additional slash at the beginning\n         if (file[0] == '/')\n            strlcpy(gRdFile, &file[1], sizeof(gRdFile));\n         else\n            strlcpy(gRdFile, file, sizeof(gRdFile));\n      }\n\n      gRdFile[strlen(file)] = '\\0';\n   }\n\n   strlcpy(gOption, option, sizeof(gOption));\n\n   int forceOpen = 0;\n   if (option[0] == 'f') {\n      forceOpen = 1;\n      strlcpy(gOption, &option[1], sizeof(gOption));\n   }\n\n   int forceRead = 0;\n   if (!strcmp(option, \"+read\")) {\n      forceRead = 1;\n      strlcpy(gOption, &option[1], sizeof(gOption));\n   }\n\n   int create = 0;\n   if (!strcmp(gOption, \"new\") || !strcmp(gOption, \"create\"))\n      create = 1;\n   int recreate = strcmp(gOption, \"recreate\") ? 0 : 1;\n   int update   = strcmp(gOption, \"update\")   ? 0 : 1;\n   int read     = strcmp(gOption, \"read\")     ? 0 : 1;\n   if (!create && !recreate && !update && !read) {\n      read = 1;\n      strlcpy(gOption, \"read\", sizeof(gOption));\n   }\n\n   if (!read && gReadOnly)\n      Error(ErrFatal, kErrNoAccess,\n            \"RootdOpen: file %s can only be opened in \\\"READ\\\" mode\", gRdFile);\n\n   if (!gAnon) {\n      char *fname;\n      if ((fname = RootdExpandPathName(gRdFile))) {\n         strlcpy(gRdFile, fname, sizeof(gRdFile));\n         free(fname);\n      } else\n         Error(ErrFatal, kErrBadFile, \"RootdOpen: bad file name %s\", gRdFile);\n   }\n\n   if (forceOpen)\n      RootdCloseTab(1);\n\n   int trunc = 0;\n   if (recreate) {\n      if (!RootdCheckTab(-1))\n         Error(ErrFatal, kErrFileWriteOpen,\n               \"RootdOpen: file %s already opened in read or write mode\", gRdFile);\n      if (!access(gRdFile, F_OK))\n         trunc = O_TRUNC;\n      else {\n         recreate = 0;\n         create   = 1;\n         strlcpy(gOption, \"create\", sizeof(gOption));\n      }\n   }\n\n   if (create && !access(gRdFile, F_OK))\n      Error(ErrFatal, kErrFileExists, \"RootdOpen: file %s already exists\", gRdFile);\n\n   int wasupdt = 0;\n   if (update) {\n      if (access(gRdFile, F_OK)) {\n         update = 0;\n         create = 1;\n         wasupdt = 1;\n         strlcpy(gOption, \"create\", sizeof(gOption));\n      }\n      if (update && access(gRdFile, W_OK))\n         Error(ErrFatal, kErrNoAccess,\n               \"RootdOpen: no write permission for file %s\", gRdFile);\n   }\n\n   if (read) {\n      if (access(gRdFile, F_OK))\n         Error(ErrFatal, kErrNoFile,\n               \"RootdOpen: file %s does not exist (errno: 0x%x)\", gRdFile, errno);\n      if (access(gRdFile, R_OK))\n         Error(ErrFatal, kErrNoAccess,\n               \"RootdOpen: no read permission for file %s (errno: 0x%x)\", gRdFile, errno);\n   }\n\n   if (create || recreate || update) {\n      if (create || recreate) {\n         // make sure file exists so RootdCheckTab works correctly\n#ifndef WIN32\n         gFd = SysOpen(gRdFile, O_RDWR | O_CREAT | trunc, 0644);\n#else\n         gFd = SysOpen(gRdFile, O_RDWR | O_CREAT | O_BINARY | trunc, S_IREAD | S_IWRITE);\n#endif\n         if (gFd != -1)\n            close(gFd);\n         gFd = -1;\n      }\n#ifndef WIN32\n      gFd = SysOpen(gRdFile, O_RDWR, 0644);\n#else\n      gFd = SysOpen(gRdFile, O_RDWR | O_BINARY, S_IREAD | S_IWRITE);\n#endif\n      if (gFd == -1)\n         Error(ErrSys, kErrFileOpen, \"RootdOpen: error opening file %s in write mode\", gRdFile);\n\n      if (!RootdCheckTab(1)) {\n         close(gFd);\n         Error(ErrFatal, kErrFileWriteOpen, \"RootdOpen: file %s already opened in read or write mode\", gRdFile);\n      }\n\n      gWritable = wasupdt ? 2 : 1;\n\n   } else {\n#ifndef WIN32\n      gFd = SysOpen(gRdFile, O_RDONLY, 0644);\n#else\n      gFd = SysOpen(gRdFile, O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);\n#endif\n      if (gFd == -1)\n         Error(ErrSys, kErrFileOpen, \"RootdOpen: error opening file %s in read mode\", gRdFile);\n\n      if (!RootdCheckTab(0)) {\n         if (!forceRead) {\n            close(gFd);\n            Error(ErrFatal, kErrFileReadOpen, \"RootdOpen: file %s already opened in write mode\", gRdFile);\n         }\n      }\n\n      gWritable = 0;\n\n   }\n\n   NetSend(gWritable, kROOTD_OPEN);\n\n   struct stat sbuf;\n   fstat(gFd, &sbuf);\n   unsigned long dev = sbuf.st_dev;\n   unsigned long ino = sbuf.st_ino;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdOpen: file %s opened in mode %s\", gRdFile, gOption);\n   else {\n      if (gAnon)\n         ErrorInfo(\"RootdOpen: file %s (dev=%lu,inode=%lu,%s) opened by %s/%s\",\n                   gRdFile, dev, ino, gOption, gUser.c_str(), gPasswd.c_str());\n      else\n         ErrorInfo(\"RootdOpen: file %s (dev=%lu,inode=%lu,%s) opened by %s\",\n                   gRdFile, dev, ino, gOption, gUser.c_str());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Receive a buffer and write it at the specified offset in the currently\n/// open file.\n\nvoid RootdPut(const char *msg)\n{\n   Long64_t offset;\n   int      len;\n\n   sscanf(msg, \"%lld %d\", &offset, &len);\n\n   char *buf = new char[len];\n   NetRecvRaw(buf, len);\n\n   if (!RootdIsOpen() || !gWritable)\n      Error(ErrFatal, kErrNoAccess, \"RootdPut: file %s not opened in write mode\", gRdFile);\n\n#if defined (R__SEEK64)\n   if (lseek64(gFd, offset, SEEK_SET) < 0)\n#elif defined(WIN32)\n   if (_lseeki64(gFd, offset, SEEK_SET) < 0)\n#else\n   if (lseek(gFd, offset, SEEK_SET) < 0)\n#endif\n      Error(ErrSys, kErrFilePut, \"RootdPut: cannot seek to position %lld in file %s\", offset, gRdFile);\n\n   ssize_t siz;\n   while ((siz = write(gFd, buf, len)) < 0 && GetErrno() == EINTR)\n      ResetErrno();\n\n   if (siz < 0)\n      Error(ErrSys, kErrFilePut, \"RootdPut: error writing to file %s\", gRdFile);\n\n   if (siz != len)\n      Error(ErrFatal, kErrFilePut, \"RootdPut: error writing all requested bytes to file %s, wrote %d of %d\",\n            gRdFile, siz, len);\n\n   NetSend(0, kROOTD_PUT);\n\n   delete [] buf;\n\n   gBytesWritten += len;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdPut: written %d bytes starting at %lld to file %s\",\n                len, offset, gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get a buffer from the specified offset from the currently open file\n/// and send it to the client.\n\nvoid RootdGet(const char *msg)\n{\n   Long64_t offset;\n   int      len;\n\n   sscanf(msg, \"%lld %d\", &offset, &len);\n\n   char *buf = new char[len];\n\n   if (!RootdIsOpen())\n      Error(ErrFatal, kErrNoAccess, \"RootdGet: file %s not open\", gRdFile);\n\n#if defined (R__SEEK64)\n   if (lseek64(gFd, offset, SEEK_SET) < 0)\n#elif defined(WIN32)\n   if (_lseeki64(gFd, offset, SEEK_SET) < 0)\n#else\n   if (lseek(gFd, offset, SEEK_SET) < 0)\n#endif\n      Error(ErrSys, kErrFileGet, \"RootdGet: cannot seek to position %lld in\"\n            \" file %s\", offset, gRdFile);\n\n   ssize_t siz;\n   while ((siz = read(gFd, buf, len)) < 0 && GetErrno() == EINTR)\n      ResetErrno();\n\n   if (siz < 0)\n      Error(ErrSys, kErrFileGet, \"RootdGet: error reading from file %s\", gRdFile);\n\n   if (siz != len)\n      Error(ErrFatal, kErrFileGet, \"RootdGet: error reading all requested bytes\"\n            \" from file %s, got %d of %d\",gRdFile, siz, len);\n\n   NetSend(0, kROOTD_GET);\n\n   NetSendRaw(buf, len);\n\n   delete [] buf;\n\n   gBytesRead += len;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdGet: read %d bytes starting at %lld from file %s\",\n                len, offset, gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Gets multiple buffers from the specified list of offsets and lengths from\n/// the currently open file and send it to the client in a single buffer.\n/// (BUt rem it gets the buffer with the info in the same way it would get\n/// new data)\n\nvoid RootdGets(const char *msg)\n{\n   if (!RootdIsOpen())\n      Error(ErrFatal, kErrNoAccess, \"RootdGets: file %s not open\", gRdFile);\n\n   Int_t nbuf;      // Number of buffers\n   Int_t len;       // len of the data buffer with the list of buffers\n   Int_t npar;      // compatibility issues\n   Int_t size;      // size of the readv block (all the small reads)\n   Int_t maxTransz; // blocksize for the transfer\n\n   npar = sscanf(msg, \"%d %d %d\", &nbuf, &len, &maxTransz);\n\n   Long64_t *offsets = new Long64_t[nbuf];  // list to be filled\n   Int_t    *lens    = new Int_t[nbuf];     // list to be filled\n   char     *buf_in  = new char[len+1];     // buff coming from the server\n\n   NetRecvRaw(buf_in, len);\n   buf_in[len] = '\\0';\n\n   char *ptr = buf_in;\n   size = 0;\n   for(Int_t i = 0 ; i < nbuf ; i++) {\n      sscanf(ptr, \"%llu-%d/\", &offsets[i], &lens[i]);\n      ptr = strchr(ptr, '/') + 1;\n      size += lens[i];\n   }\n\n   // If the blocksize is not specified the try to send\n   // just a big block\n   if( npar == 2  )\n      maxTransz = size;\n\n   // We are Ready to begin the transference\n   NetSend(0, kROOTD_GETS);\n\n   char *buf_out  = new char[maxTransz];\n   char *buf_send = new char[maxTransz];\n   Int_t actual_pos = 0; // position for the whole size\n   Int_t buf_pos    = 0; // position in the buffer\n   ssize_t siz = 0;\n\n   for (Int_t i = 0; i < nbuf; i++) {\n      Long64_t left = size - actual_pos;\n      if (left > maxTransz)\n         left = maxTransz;\n\n      Int_t pos = 0; // Position for the disk read\n      while ( pos < lens[i] ) {\n#if defined (R__SEEK64)\n         if (lseek64(gFd, offsets[i] + pos, SEEK_SET) < 0)\n#elif defined(WIN32)\n         if (_lseeki64(gFd, offsets[i] + pos, SEEK_SET) < 0)\n#else\n         if (lseek(gFd, offsets[i] + pos, SEEK_SET) < 0)\n#endif\n         Error(ErrSys, kErrFileGet, \"RootdGets: cannot seek to position %lld in\"\n            \" file %s\", offsets[i], gRdFile);\n\n         Int_t readsz = lens[i] - pos;\n         if( readsz > ( left - buf_pos) )\n            readsz = left - buf_pos;\n\n         while ((siz = read(gFd, buf_out + buf_pos, readsz)) < 0 && GetErrno() == EINTR)\n            ResetErrno();\n\n         if (siz != readsz)\n            goto end;\n\n         pos += readsz;\n         buf_pos += readsz;\n         if ( buf_pos == left ) {\n            if (gDebug > 0 )\n               ErrorInfo(\"RootdGets: Sending %d bytes\", left);\n\n            // Swap buffers\n            char *buf_tmp = buf_out;\n            buf_out = buf_send;\n            buf_send = buf_tmp;\n\n            NetSendRaw(buf_send, left);\n            actual_pos += left;\n            buf_pos = 0;\n\n            if ( left > (size - actual_pos) )\n               left = size - actual_pos;\n         }\n      }\n   }\n\nend:\n   if (siz < 0)\n      Error(ErrSys, kErrFileGet, \"RootdGets: error reading from file %s\", gRdFile);\n\n   if (actual_pos != size)\n      Error(ErrFatal, kErrFileGet, \"RootdGets: error reading all requested bytes\"\n            \" from file %s, got %d of %d\",gRdFile, actual_pos, size);\n\n   delete [] buf_in;\n   delete [] buf_out;\n   delete [] buf_send;\n   delete [] lens;\n   delete [] offsets;\n\n   gBytesRead += actual_pos;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdGets: read %d bytes from file %s\",\n                actual_pos, gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Receive a file from the remote client (upload).\n\nvoid RootdPutFile(const char *msg)\n{\n   char     file[kMAXPATHLEN];\n   Long64_t size, restartat;\n   int      blocksize, mode, forceopen = 0;\n\n   gFtp = 1;   // rootd is used for ftp instead of file serving\n\n   sscanf(msg, \"%s %d %d %lld %lld\", file, &blocksize, &mode, &size, &restartat);\n\n   if (file[0] == '-') {\n      forceopen = 1;\n      strlcpy(gRdFile, file+1, sizeof(gRdFile));\n   } else\n      strlcpy(gRdFile, file, sizeof(gRdFile));\n\n   // anon user may not overwrite existing files...\n   struct stat st;\n   if (!stat(gRdFile, &st)) {\n      if (gAnon) {\n         Error(Err, kErrFileExists, \"RootdPutFile: anonymous users may not overwrite existing file %s\", gRdFile);\n         return;\n      }\n   } else if (GetErrno() != ENOENT) {\n      Error(Err, kErrFatal, \"RootdPutFile: can't check for file presence\");\n      return;\n   }\n\n   // remove lock from file\n   if (restartat || forceopen)\n      RootdCloseTab(1);\n\n   // open local file\n   int fd;\n   if (!restartat) {\n\n      // make sure file exists so RootdCheckTab works correctly\n#ifndef WIN32\n      fd = SysOpen(gRdFile, O_RDWR | O_CREAT, 0600);\n#else\n      fd = SysOpen(gRdFile, O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);\n#endif\n      if (fd < 0) {\n         Error(Err, kErrFileOpen, \"RootdPutFile: cannot open file %s\", gRdFile);\n         return;\n      }\n\n      close(fd);\n\n      // check if file is not in use by somebody and prevent from somebody\n      // using it before upload is completed\n      if (!RootdCheckTab(1)) {\n         Error(Err, kErrFileWriteOpen, \"RootdPutFile: file %s already opened in read or write mode\", gRdFile);\n         return;\n      }\n\n#ifndef WIN32\n      fd = SysOpen(gRdFile, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n#else\n      if (mode == kBinary)\n         fd = SysOpen(gRdFile, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY,\n                      S_IREAD | S_IWRITE);\n      else\n         fd = SysOpen(gRdFile, O_CREAT | O_TRUNC | O_WRONLY,\n                      S_IREAD | S_IWRITE);\n#endif\n   } else {\n#ifndef WIN32\n      fd = SysOpen(gRdFile, O_WRONLY, 0600);\n#else\n      if (mode == kBinary)\n         fd = SysOpen(gRdFile, O_WRONLY | O_BINARY, S_IREAD | S_IWRITE);\n      else\n         fd = SysOpen(gRdFile, O_WRONLY, S_IREAD | S_IWRITE);\n#endif\n      if (fd < 0) {\n         Error(Err, kErrFileOpen, \"RootdPutFile: cannot open file %s\", gRdFile);\n         return;\n      }\n      if (!RootdCheckTab(1)) {\n         close(fd);\n         Error(Err, kErrFileWriteOpen, \"RootdPutFile: file %s already opened in read or write mode\", gRdFile);\n         return;\n      }\n   }\n\n   // check file system space\n   if (strcmp(gRdFile, \"/dev/null\")) {\n      struct statfs statfsbuf;\n#if defined(__sgi) || (defined(__sun) && !defined(linux))\n      if (fstatfs(fd, &statfsbuf, sizeof(struct statfs), 0) == 0) {\n         Long64_t space = (Long64_t)statfsbuf.f_bsize * (Long64_t)statfsbuf.f_bfree;\n#else\n      if (fstatfs(fd, &statfsbuf) == 0) {\n         Long64_t space = (Long64_t)statfsbuf.f_bsize * (Long64_t)statfsbuf.f_bavail;\n#endif\n         if (space < size - restartat) {\n            Error(Err, kErrNoSpace, \"RootdPutFile: not enough space to store file %s\", gRdFile);\n            close(fd);\n            return;\n         }\n      }\n   }\n\n   // seek to restartat position\n   if (restartat) {\n#if defined(R__SEEK64)\n      if (lseek64(fd, restartat, SEEK_SET) < 0) {\n#elif defined(WIN32)\n      if (_lseeki64(fd, restartat, SEEK_SET) < 0) {\n#else\n      if (lseek(fd, restartat, SEEK_SET) < 0) {\n#endif\n         Error(Err, kErrRestartSeek, \"RootdPutFile: cannot seek to position %lld in file %s\",\n               restartat, gRdFile);\n         close(fd);\n         return;\n      }\n   }\n\n   // setup ok\n   NetSend(0, kROOTD_PUTFILE);\n\n   struct timeval started, ended;\n   gettimeofday(&started, 0);\n\n   char *buf = new char[blocksize];\n   char *buf2 = 0;\n   if (mode == 1)\n      buf2 = new char[blocksize];\n\n   Long64_t pos = restartat & ~(blocksize-1);\n   int skip = restartat - pos;\n\n   while (pos < size) {\n      Long64_t left = Long64_t(size - pos);\n      if (left > blocksize)\n         left = blocksize;\n\n      NetRecvRaw(buf, int(left-skip));\n\n      int n = int(left-skip);\n\n      // in case of ascii file, loop here over buffer and remove \\r's\n      ssize_t siz;\n      if (mode == kAscii) {\n         int i = 0, j = 0;\n         while (i < n) {\n            if (buf[i] == '\\r')\n               i++;\n            else\n               buf2[j++] = buf[i++];\n         }\n         n = j;\n         while ((siz = write(fd, buf2, n)) < 0 && GetErrno() == EINTR)\n            ResetErrno();\n      } else {\n         while ((siz = write(fd, buf, n)) < 0 && GetErrno() == EINTR)\n            ResetErrno();\n      }\n\n      if (siz < 0)\n         Error(ErrSys, kErrFilePut, \"RootdPutFile: error writing to file %s\", gRdFile);\n\n      if (siz != n)\n         Error(ErrFatal, kErrFilePut, \"RootdPutFile: error writing all requested bytes to file %s, wrote %d of %d\",\n               gRdFile, siz, int(left-skip));\n\n      gBytesWritten += n;\n\n      pos += left;\n      skip = 0;\n   }\n\n   gettimeofday(&ended, 0);\n\n   // file stored ok\n   NetSend(0, kROOTD_PUTFILE);\n\n   delete [] buf; delete [] buf2;\n\n   fchmod(fd, 0644);\n\n   close(fd);\n\n   RootdCloseTab();\n\n   gUploaded++;\n\n   double speed, t;\n   t = (ended.tv_sec + ended.tv_usec / 1000000.0) -\n       (started.tv_sec + started.tv_usec / 1000000.0);\n   if (t > 0)\n      speed = double(size - restartat) / t;\n   else\n      speed = 0.0;\n   if (speed > 524288)\n      ErrorInfo(\"RootdPutFile: uploaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Mbytes/s)\", gRdFile, size, t, speed / 1048576);\n   else if (speed > 512)\n      ErrorInfo(\"RootdPutFile: uploaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Kbytes/s)\", gRdFile, size, t, speed / 1024);\n   else\n      ErrorInfo(\"RootdPutFile: uploaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f bytes/s)\", gRdFile, size, t, speed);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Send a file to a remote client (download).\n\nvoid RootdGetFile(const char *msg)\n{\n   char     file[kMAXPATHLEN];\n   Long64_t restartat;\n   int      blocksize, mode, forceopen = 0;\n\n   gFtp = 1;   // rootd is used for ftp instead of file serving\n\n   sscanf(msg, \"%s %d %d %lld\", file, &blocksize, &mode, &restartat);\n\n   if (file[0] == '-') {\n      forceopen = 1;\n      strlcpy(gRdFile, file+1, sizeof(gRdFile));\n   } else\n      strlcpy(gRdFile, file, sizeof(gRdFile));\n\n   // remove lock from file\n   if (forceopen)\n      RootdCloseTab(1);\n\n   // open file for reading\n#if defined(WIN32) || defined(R__WINGCC)\n   int fd = SysOpen(gRdFile, O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);\n#else\n   int fd = SysOpen(gRdFile, O_RDONLY, 0600);\n#endif\n   if (fd < 0) {\n      Error(Err, kErrFileOpen, \"RootdGetFile: cannot open file %s\", gRdFile);\n      return;\n   }\n\n   // check if file is not in use by somebody and prevent from somebody\n   // using it before download is completed\n   if (!RootdCheckTab(0)) {\n      close(fd);\n      Error(Err, kErrFileOpen, \"RootdGetFile: file %s is already open in write mode\", gRdFile);\n      return;\n   }\n\n#if defined(R__SEEK64)\n   struct stat64 st;\n   if (fstat64(fd, &st)) {\n#elif defined(WIN32)\n   struct _stati64 st;\n   if (_fstati64(fd, &st)) {\n#else\n   struct stat st;\n   if (fstat(fd, &st)) {\n#endif\n      Error(Err, kErrFatal, \"RootdGetFile: cannot get size of file %s\", gRdFile);\n      close(fd);\n      return;\n   }\n   Long64_t size = st.st_size;\n\n   if (!S_ISREG(st.st_mode)) {\n      Error(Err, kErrBadFile, \"RoodGetFile: not a regular file %s\", gRdFile);\n      close(fd);\n      return;\n   }\n\n   // check if restartat value makes sense\n   if (restartat && (restartat >= size))\n      restartat = 0;\n\n   // setup ok\n   NetSend(0, kROOTD_GETFILE);\n\n   char mess[128];\n   SPrintf(mess, 128, \"%lld\", size);\n   NetSend(mess, kROOTD_GETFILE);\n\n   struct timeval started, ended;\n   gettimeofday(&started, 0);\n\n   Long64_t pos  = restartat & ~(blocksize-1);\n   int  skip = int(restartat - pos);\n\n#ifndef HAVE_MMAP\n   char *buf = new char[blocksize];\n#if defined(R__SEEK64)\n   lseek64(fd, pos, SEEK_SET);\n#elif defined(WIN32)\n   _lseeki64(fd, pos, SEEK_SET);\n#else\n   lseek(fd, pos, SEEK_SET);\n#endif\n#endif\n\n   while (pos < size) {\n      Long64_t left = size - pos;\n      if (left > blocksize)\n         left = blocksize;\n#ifdef HAVE_MMAP\n#if defined(R__SEEK64)\n      char *buf = (char*) mmap64(0, left, PROT_READ, MAP_FILE | MAP_SHARED, fd, pos);\n#else\n      char *buf = (char*) mmap(0, left, PROT_READ, MAP_FILE | MAP_SHARED, fd, pos);\n#endif\n      if (buf == (char *) -1)\n         Error(ErrFatal, kErrFileGet, \"RootdGetFile: mmap of file %s failed\", gRdFile);\n#else\n      int siz;\n      while ((siz = read(fd, buf, (int)left)) < 0 && GetErrno() == EINTR)\n         ResetErrno();\n      if (siz < 0 || siz != left)\n         Error(ErrFatal, kErrFileGet, \"RootdGetFile: error reading from file %s\", gRdFile);\n#endif\n\n      NetSendRaw(buf+skip, int(left-skip));\n\n      gBytesRead += left-skip;\n\n      pos += left;\n      skip = 0;\n\n#ifdef HAVE_MMAP\n      munmap(buf, left);\n#endif\n   }\n\n   gettimeofday(&ended, 0);\n\n#ifndef HAVE_MMAP\n   delete [] buf;\n#endif\n\n   close(fd);\n\n   RootdCloseTab();\n\n   gDownloaded++;\n\n   double speed, t;\n   t = (ended.tv_sec + ended.tv_usec / 1000000.0) -\n       (started.tv_sec + started.tv_usec / 1000000.0);\n   if (t > 0)\n      speed = double(size - restartat) / t;\n   else\n      speed = 0.0;\n   if (speed > 524288)\n      ErrorInfo(\"RootdGetFile: downloaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Mbytes/s)\", gRdFile, size, t, speed / 1048576);\n   else if (speed > 512)\n      ErrorInfo(\"RootdGetFile: downloaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Kbytes/s)\", gRdFile, size, t, speed / 1024);\n   else\n      ErrorInfo(\"RootdGetFile: downloaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f bytes/s)\", gRdFile, size, t, speed);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Change directory.\n\nvoid RootdChdir(const char *dir)\n{\n   const int kMAXBUFLEN = kMAXPATHLEN + 256;\n   char buffer[kMAXBUFLEN];\n\n   if (dir && *dir == '~') {\n      struct passwd *pw;\n      int i = 0;\n      const char *p = dir;\n\n      p++;\n      while (*p && *p != '/')\n         buffer[i++] = *p++;\n      buffer[i] = 0;\n\n      if ((pw = getpwnam(i ? buffer : gUser.c_str())))\n         SPrintf(buffer, kMAXBUFLEN, \"%s%s\", pw->pw_dir, p);\n      else\n         *buffer = 0;\n   } else\n      *buffer = 0;\n\n   if (chdir(*buffer ? buffer : (dir && *dir ? dir : \"/\")) == -1) {\n      SPrintf(buffer,kMAXBUFLEN,\"cannot change directory to %s\",dir);\n      Perror(buffer,kMAXBUFLEN);\n      NetSend(buffer, kROOTD_CHDIR);\n      return;\n   } else {\n      FILE *msg;\n\n      if ((msg = fopen(\".message\", \"r\"))) {\n         int len = fread(buffer, 1, kMAXPATHLEN, msg);\n         fclose(msg);\n         if (len > 0 && len < 1024) {\n            buffer[len] = 0;\n            NetSend(buffer, kMESS_STRING);\n         }\n      }\n\n      if (!getcwd(buffer, kMAXPATHLEN)) {\n         if (dir && *dir == '/')\n            SPrintf(buffer, kMAXBUFLEN, \"%s\", dir);\n      }\n      NetSend(buffer, kROOTD_CHDIR);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Test access permission on path\n\nvoid RootdAccess(const char *buf)\n{\n   char buffer[kMAXPATHLEN];\n   char path[kMAXPATHLEN];\n   int mode = F_OK; // if not told otherwise, check for file access.\n\n   int nw = 0;\n   if (buf)\n      nw = sscanf(buf,\"%s %d\",path,&mode);\n\n   if (nw >= 2) {\n\n      char *epath = &path[0];\n      if (path[0] == '/' && path[1] == '/')\n         epath = &path[1];\n\n      if (access(epath, mode) == -1) {\n         SPrintf(buffer,kMAXPATHLEN,\"cannot stat %s\",epath);\n         Perror(buffer);\n         ErrorInfo(\"RootdAccess: %s\", buffer);\n      } else\n         SPrintf(buffer,kMAXPATHLEN,\"OK\");\n\n   } else {\n      SPrintf(buffer,kMAXPATHLEN,\"bad input format %s\",buf);\n      ErrorInfo(\"RootdAccess: %s\", buffer);\n   }\n\n   NetSend(buffer, kROOTD_ACCESS);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Free open directory.\n\nvoid RootdFreeDir()\n{\n   char buffer[kMAXPATHLEN];\n\n   if (!gRDDirectory) {\n      SPrintf(buffer,kMAXPATHLEN,\"no directory open\");\n      ErrorInfo(\"RootdFreeDir: %s\", buffer);\n   } else if (closedir(gRDDirectory) == -1) {\n      SPrintf(buffer,kMAXPATHLEN,\"cannot free open directory\");\n      Perror(buffer);\n      ErrorInfo(\"RootdFreeDir: %s\", buffer);\n   } else\n      SPrintf(buffer,kMAXPATHLEN,\"open directory freed\");\n\n   NetSend(buffer, kROOTD_FREEDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get directory entry.\n\nvoid RootdGetDirEntry()\n{\n   char buffer[kMAXPATHLEN];\n   struct dirent *dp = 0;\n\n   if (!gRDDirectory) {\n      SPrintf(buffer,kMAXPATHLEN,\"no directory open\");\n      ErrorInfo(\"RootdGetDirEntry: %s\", buffer);\n   } else if ((dp = readdir(gRDDirectory)) == 0) {\n      if (GetErrno() == EBADF) {\n         SPrintf(buffer,kMAXPATHLEN,\"cannot read open directory\");\n         Perror(buffer);\n         ErrorInfo(\"RootdGetDirEntry: %s\", buffer);\n      } else\n         SPrintf(buffer,kMAXPATHLEN,\"no more entries\");\n   } else {\n      SPrintf(buffer,kMAXPATHLEN,\"OK:%s\",dp->d_name);\n   }\n\n   NetSend(buffer, kROOTD_DIRENTRY);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Open directory.\n\nvoid RootdOpenDir(const char *dir)\n{\n   char buffer[kMAXPATHLEN];\n\n   char *edir = (char *)dir;\n   if (dir[0] == '/' && dir[1] == '/')\n      edir++;\n\n   if ((gRDDirectory = opendir(edir)) == 0) {\n      SPrintf(buffer,kMAXPATHLEN,\"cannot open directory %s\",edir);\n      Perror(buffer);\n      ErrorInfo(\"RootdOpenDir: %s\", buffer);\n   } else\n      SPrintf(buffer,kMAXPATHLEN,\"OK: directory %s open\",edir);\n\n   NetSend(buffer, kROOTD_OPENDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Make directory.\n\nvoid RootdMkdir(const char *fdir)\n{\n   char buffer[kMAXPATHLEN];\n\n   char *dir = (char *)fdir;\n   if (fdir[0] == '/' && fdir[1] == '/')\n      dir++;\n\n   if (gAnon) {\n      SPrintf(buffer,kMAXPATHLEN,\n              \"anonymous users may not create directories\");\n      ErrorInfo(\"RootdMkdir: %s\", buffer);\n   } else if (mkdir(dir, 0755) < 0) {\n      SPrintf(buffer,kMAXPATHLEN,\"cannot create directory %s\",dir);\n      Perror(buffer);\n      ErrorInfo(\"RootdMkdir: %s\", buffer);\n   } else\n      SPrintf(buffer,kMAXPATHLEN,\"OK: created directory %s\",dir);\n\n   NetSend(buffer, kROOTD_MKDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete directory.\n\nvoid RootdRmdir(const char *fdir)\n{\n   char buffer[kMAXPATHLEN];\n\n   char *dir = (char *)fdir;\n   if (fdir[0] == '/' && fdir[1] == '/')\n      dir++;\n\n   if (gAnon) {\n      SPrintf(buffer,kMAXPATHLEN,\n              \"anonymous users may not delete directories\");\n      ErrorInfo(\"RootdRmdir: %s\", buffer);\n   } else if (rmdir(dir) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot delete directory %s\", dir);\n      Perror(buffer);\n      ErrorInfo(\"RootdRmdir: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"deleted directory %s\", dir);\n\n   NetSend(buffer, kROOTD_RMDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// List directory.\n\nvoid RootdLsdir(const char *cmd)\n{\n   char buffer[kMAXPATHLEN];\n\n   // make sure all commands start with ls (should use snprintf)\n   if (gAnon) {\n      if (strlen(cmd) < 2 || strncmp(cmd, \"ls\", 2))\n         SPrintf(buffer, kMAXPATHLEN, \"ls %s\", cmd);\n      else\n         SPrintf(buffer, kMAXPATHLEN, \"%s\", cmd);\n   } else {\n      if (strlen(cmd) < 2 || strncmp(cmd, \"ls\", 2))\n         SPrintf(buffer, kMAXPATHLEN, \"ls %s 2>/dev/null\", cmd);\n      else\n         SPrintf(buffer, kMAXPATHLEN, \"%s 2>/dev/null\", cmd);\n   }\n\n   FILE *pf;\n   if ((pf = popen(buffer, \"r\")) == 0) {\n      SPrintf(buffer,kMAXPATHLEN, \"error in popen\");\n      Perror(buffer);\n      NetSend(buffer, kROOTD_LSDIR);\n      ErrorInfo(\"RootdLsdir: %s\", buffer);\n      return;\n   }\n\n   // read output of ls\n   int  ch, i = 0, cnt = 0;\n//again:\n   for (ch = fgetc(pf); ch != EOF; ch = fgetc(pf)) {\n      buffer[i++] = ch;\n      cnt++;\n      if (i == kMAXPATHLEN-1) {\n         buffer[i] = 0;\n         NetSend(buffer, kMESS_STRING);\n         i = 0;\n      }\n   }\n   // this will be true if forked process was not yet ready to be read\n//   if (cnt == 0 && ch == EOF) goto again;\n\n   pclose(pf);\n\n   buffer[i] = 0;\n   NetSend(buffer, kROOTD_LSDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Print path of working directory.\n\nvoid RootdPwd()\n{\n   char buffer[kMAXPATHLEN];\n\n   if (!getcwd(buffer, kMAXPATHLEN)) {\n      SPrintf(buffer, kMAXPATHLEN, \"current directory not readable\");\n      Perror(buffer);\n      ErrorInfo(\"RootdPwd: %s\", buffer);\n   }\n\n   NetSend(buffer, kROOTD_PWD);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Rename a file.\n\nvoid RootdMv(const char *msg)\n{\n   char file1[kMAXPATHLEN], file2[kMAXPATHLEN], buffer[kMAXPATHLEN];\n   sscanf(msg, \"%s %s\", file1, file2);\n\n   if (gAnon) {\n      SPrintf(buffer, kMAXPATHLEN, \"anonymous users may not rename files\");\n      ErrorInfo(\"RootdMv: %s\", buffer);\n   } else if (rename(file1, file2) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot rename file %s to %s\",\n              file1, file2);\n      Perror(buffer);\n      ErrorInfo(\"RootdMv: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"renamed file %s to %s\",\n              file1, file2);\n\n   NetSend(buffer, kROOTD_MV);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete a file.\n\nvoid RootdRm(const char *file)\n{\n   char buffer[kMAXPATHLEN];\n\n   if (gAnon) {\n      SPrintf(buffer, kMAXPATHLEN, \"anonymous users may not delete files\");\n      ErrorInfo(\"RootdRm: %s\", buffer);\n   } else if (unlink(file) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot unlink file %s\", file);\n      Perror(buffer);\n      ErrorInfo(\"RootdRm: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"removed file %s\", file);\n\n   NetSend(buffer, kROOTD_RM);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete a file.\n\nvoid RootdChmod(const char *msg)\n{\n   char file[kMAXPATHLEN], buffer[kMAXPATHLEN];\n   int  mode;\n\n   sscanf(msg, \"%s %d\", file, &mode);\n\n   if (gAnon) {\n      SPrintf(buffer, kMAXPATHLEN,\n              \"anonymous users may not change file permissions\");\n      ErrorInfo(\"RootdChmod: %s\", buffer);\n   } else if (chmod(file, mode) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot chmod file %s to 0%o\", file, mode);\n      Perror(buffer);\n      ErrorInfo(\"RootdChmod: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"changed permission of file %s to 0%o\",\n              file, mode);\n\n   NetSend(buffer, kROOTD_CHMOD);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Termination upon receipt of a SIGTERM or SIGINT.\n\nstatic void RootdTerm(int)\n{\n   ErrorInfo(\"RootdTerm: rootd.cxx: got a SIGTERM/SIGINT\");\n   // Terminate properly\n   RpdAuthCleanup(0,0);\n   // Close network connection\n   NetClose();\n   // exit\n   exit(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Handle all rootd commands. Returns after file close command.\n\nvoid RootdLoop()\n{\n   char recvbuf[kMAXRECVBUF];\n   EMessageTypes kind;\n\n//#define R__ROOTDDBG\n#ifdef R__ROOTDDBG\n   int debug = 1;\n   while (debug)\n      ;\n#endif\n\n   // Check if we will go for parallel sockets\n   // (in early days was done before entering main loop)\n   if (gClientProtocol > 9)\n      RootdParallel();\n\n   // Main loop\n   while (1) {\n\n      if (NetRecv(recvbuf, kMAXRECVBUF, kind) < 0)\n         Error(ErrFatal, kErrFatal, \"RootdLoop: error receiving message\");\n\n      if (gDebug > 2 && kind != kROOTD_PASS)\n         ErrorInfo(\"RootdLoop: kind:%d -- buf:'%s' (len:%d)\",\n                   kind, recvbuf, strlen(recvbuf));\n\n      switch (kind) {\n         case kROOTD_OPEN:\n            RootdOpen(recvbuf);\n            break;\n         case kROOTD_PUT:\n            RootdPut(recvbuf);\n            break;\n         case kROOTD_GET:\n            RootdGet(recvbuf);\n            break;\n         case kROOTD_GETS:\n            RootdGets(recvbuf);\n            break;\n         case kROOTD_FLUSH:\n            RootdFlush();\n            break;\n         case kROOTD_CLOSE:\n            RootdClose();\n            if (gClientProtocol < 7)\n               return;\n            break;\n         case kROOTD_FSTAT:\n            RootdFstat(recvbuf);\n            break;\n         case kROOTD_STAT:\n            RootdStat();\n            break;\n         case kROOTD_PUTFILE:\n            RootdPutFile(recvbuf);\n            break;\n         case kROOTD_GETFILE:\n            RootdGetFile(recvbuf);\n            break;\n         case kROOTD_CHDIR:\n            RootdChdir(recvbuf);\n            break;\n         case kROOTD_MKDIR:\n            RootdMkdir(recvbuf);\n            break;\n         case kROOTD_RMDIR:\n            RootdRmdir(recvbuf);\n            break;\n         case kROOTD_LSDIR:\n            RootdLsdir(recvbuf);\n            break;\n         case kROOTD_PWD:\n            RootdPwd();\n            break;\n         case kROOTD_MV:\n            RootdMv(recvbuf);\n            break;\n         case kROOTD_RM:\n            RootdRm(recvbuf);\n            break;\n         case kROOTD_CHMOD:\n            RootdChmod(recvbuf);\n            break;\n         case kROOTD_OPENDIR:\n            RootdOpenDir(recvbuf);\n            break;\n         case kROOTD_FREEDIR:\n            RootdFreeDir();\n            break;\n         case kROOTD_DIRENTRY:\n            RootdGetDirEntry();\n            break;\n         case kROOTD_ACCESS:\n            RootdAccess(recvbuf);\n            break;\n         case kROOTD_BYE:\n            return;\n         default:\n            Error(ErrFatal, kErrBadOp, \"RootdLoop: received bad opcode %d\", kind);\n      }\n      continue;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid Usage(const char* name, int rc)\n{\n   fprintf(stderr, \"\\nUsage: %s [options] [rootsys-dir]\\n\", name);\n   fprintf(stderr, \"\\nOptions:\\n\");\n   fprintf(stderr, \"\\t-b tcpwindowsize  Specify the tcp window size in bytes\\n\");\n#ifdef R__GLBS\n   fprintf(stderr, \"\\t-C hostcertfile   Specify the location of the Globus host certificate\\n\");\n#endif\n   fprintf(stderr, \"\\t-d level          set debug level [0..3]\\n\");\n   fprintf(stderr, \"\\t-D rootdaemonrc   Use alternate rootdaemonrc file\\n\");\n   fprintf(stderr, \"\\t                  (see documentation)\\n\");\n   fprintf(stderr, \"\\t-E                Ignored for backward compatibility\\n\");\n   fprintf(stderr, \"\\t-f                Run in foreground\\n\");\n#ifdef R__GLBS\n   fprintf(stderr, \"\\t-G gridmapfile    Specify the location of th Globus gridmap\\n\");\n#endif\n   fprintf(stderr, \"\\t-i                Running from inetd\\n\");\n   fprintf(stderr, \"\\t-noauth           Do not require client authentication\\n\");\n   fprintf(stderr, \"\\t-p port#          Specify a different port to listen on\\n\");\n   fprintf(stderr, \"\\t-P pwfile         Use pwfile instead of .srootdpass\\n\");\n   fprintf(stderr, \"\\t-r                Files can only be opened in read-only mode\\n\");\n   fprintf(stderr, \"\\t-R bitmask        Bitmask specifies which methods allow authentication re-use\\n\");\n   fprintf(stderr, \"\\t-s sshd_port#     Specify the port for the sshd daemon\\n\");\n#ifdef R__KRB5\n   fprintf(stderr, \"\\t-S keytabfile     Use an alternate keytab file\\n\");\n#endif\n   fprintf(stderr, \"\\t-T <tmpdir>       Use an alternate temp dir\\n\");\n   fprintf(stderr, \"\\t-w                Do not check /etc/hosts.equiv and $HOME/.rhosts\\n\");\n\n   exit(rc);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char **argv)\n{\n   char *s;\n   int checkhostsequiv= 1;\n   int requireauth    = 1;\n   int tcpwindowsize  = 65535;\n   int sshdport       = 22;\n   int port1          = 0;\n   int port2          = 0;\n   int reuseallow     = 0x1F;\n   int login          = 2; // form rootd we fully login users, by default\n   int foregroundflag = 0;\n   std::string tmpdir = \"\";\n   std::string confdir = \"\";\n   std::string rootbindir = \"\";\n   std::string altSRPpass = \"\";\n   std::string daemonrc = \"\";\n   std::string rootetcdir = \"\";\n#ifdef R__GLBS\n   std::string gridmap = \"\";\n   std::string hostcertconf = \"\";\n#endif\n   char *progname = argv[0];\n\n   // Init error handlers\n   RpdSetErrorHandler(Err, ErrSys, ErrFatal);\n\n   // function for dealing with SIGPIPE signals\n   // (used by NetSetOptions() in rpdutils/net.cxx)\n   NetSetSigPipeHook(SigPipe);\n\n   // Init syslog\n   ErrorInit(argv[0]);\n\n   // Output to syslog ...\n   RpdSetSysLogFlag(1);\n\n   // ... unless we are running in the foreground and we are\n   // attached to terminal; make also sure that \"-i\" and \"-f\"\n   // are not simultaneously specified\n   int i = 1;\n   for (i = 1; i < argc; i++) {\n      if (!strncmp(argv[i],\"-f\",2))\n         foregroundflag = 1;\n      if (!strncmp(argv[i],\"-i\",2))\n         gInetdFlag = 1;\n   }\n   if (foregroundflag) {\n      if (isatty(0) && isatty(1)) {\n         RpdSetSysLogFlag(0);\n         ErrorInfo(\"main: running in foreground mode:\"\n                   \" sending output to stderr\");\n      }\n      if (gInetdFlag)\n         Error(ErrFatal,-1,\"-i and -f options are incompatible\");\n   }\n\n   // To terminate correctly ... maybe not needed\n   signal(SIGTERM, RootdTerm);\n   signal(SIGINT, RootdTerm);\n\n   char *tmp = RootdExpandPathName(argv[0]);\n   if (tmp) {\n      int p = strlen(tmp)-1;\n      while ((p+1) && tmp[p] != '/')\n         p--;\n      if (p+1) {\n         tmp[p] = '\\0';\n         rootbindir = std::string(tmp);\n         while ((p+1) && tmp[p] != '/')\n            p--;\n         if (p+1) {\n            tmp[p] = '\\0';\n            confdir = std::string(tmp);\n         }\n      }\n      free(tmp);\n   }\n\n   while (--argc > 0 && (*++argv)[0] == '-')\n      for (s = argv[0]+1; *s != 0; s++)\n         switch (*s) {\n\n            case 'b':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-b requires a buffersize in bytes\"\n                                    \" as argument\");\n               }\n               tcpwindowsize = atoi(*++argv);\n               break;\n#ifdef R__GLBS\n            case 'C':\n               if (--argc <= 0) {\n                  Error(ErrFatal, kErrFatal,\"-C requires a file name for\"\n                                    \" the host certificates file location\");\n               }\n               hostcertconf = std::string(*++argv);\n               break;\n#endif\n            case 'd':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-d requires a debug level as\"\n                                    \" argument\");\n               }\n               gDebug = atoi(*++argv);\n               break;\n\n            case 'D':\n               if (--argc <= 0) {\n                  Error(ErrFatal, kErrFatal,\"-D requires a file path name\"\n                                    \"  for the file defining access rules\");\n               }\n               daemonrc = std::string(*++argv);\n               break;\n\n            case 'E':\n               Error(ErrFatal, kErrFatal,\"Option '-E' is now dummy \"\n                          \"- ignored (see proofd/src/proofd.cxx for\"\n                          \" additional details)\");\n               break;\n\n            case 'f':\n               if (gInetdFlag) {\n                  Error(ErrFatal,-1,\"-i and -f options are incompatible\");\n               }\n               foregroundflag = 1;\n               break;\n\n            case 'F':\n               gCastorFlag = 1;\n               gInetdFlag  = 1;\n               reuseallow = 0x0; // No auth reuse for castor\n               login = 1; // No full logins for castor (user $HOMEs may not exist on servers)\n               if (--argc <= 0) {\n                  if (!gInetdFlag)\n                     fprintf(stderr,\"-F requires a file path name for the\"\n                             \" CASTOR disk file to be accessed\\n\");\n                  Error(ErrFatal, kErrFatal,\"-F requires a file path name\"\n                        \" for the CASTOR disk file to be accessed\");\n               }\n               gCastorFile = std::string(*++argv);\n               break;\n\n#ifdef R__GLBS\n            case 'G':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-G requires a file name for\"\n                                    \" the gridmap file\");\n               }\n               gridmap = std::string(*++argv);\n               break;\n#endif\n            case 'h':\n               Usage(progname, 0);\n               break;\n\n            case 'H':\n               if (--argc <= 0) {\n                  if (!gInetdFlag && !gCastorFlag)\n                     fprintf(stderr,\"-H requires the CASTOR request ID\");\n                  Error(ErrFatal, kErrFatal,\"-H requires the CASTOR request ID\");\n               }\n               gCastorReqId = std::string(*++argv);\n               break;\n\n            case 'i':\n               if (foregroundflag) {\n                  Error(ErrFatal,-1,\"-i and -f options are incompatible\");\n               }\n               gInetdFlag = 1;\n               break;\n\n            case 'n':\n               if (!strncmp(argv[0]+1,\"noauth\",6)) {\n                  requireauth = 0;\n                  s += 5;\n               } else if (!strncmp(argv[0]+1,\"nologin\",7)) {\n                  login = 0;\n                  s += 6;\n               }\n               break;\n\n            case 'p':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-p requires a port number as\"\n                                    \" argument\");\n               }\n               char *p;\n               port1 = strtol(*++argv, &p, 10);\n               if (*p == '-') {\n                  p++;\n                  port2 = strtol(p, &p, 10);\n               } else if (*p == '\\0')\n                  port2 = port1;\n               if (*p != '\\0' || port2 < port1 || port2 < 0) {\n                  Error(ErrFatal,kErrFatal,\"invalid port number or range: %s\",\n                                     *argv);\n               }\n               break;\n\n            case 'P':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-P requires a file name for SRP\"\n                                    \" password file\");\n               }\n               altSRPpass = std::string(*++argv);\n               break;\n\n            case 'r':\n               gReadOnly = 1;\n               break;\n\n            case 'R':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-R requires a hex but mask as\"\n                                    \" argument\");\n               }\n               reuseallow = strtol(*++argv, (char **)0, 16);\n               break;\n\n            case 's':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-s requires as argument a port\"\n                                    \" number for the sshd daemon\");\n               }\n               sshdport = atoi(*++argv);\n               break;\n#ifdef R__KRB5\n            case 'S':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-S requires a path to your\"\n                                    \" keytab\\n\");\n               }\n               RpdSetKeytabFile((const char *)(*++argv));\n               break;\n#endif\n            case 'T':\n               if (--argc <= 0) {\n                  Error(ErrFatal, kErrFatal,\"-T requires a dir path for\"\n                                    \" temporary files [/usr/tmp]\");\n               }\n               tmpdir = std::string(*++argv);\n               break;\n\n            case 'w':\n               checkhostsequiv = 0;\n               break;\n\n            default:\n               if (!foregroundflag) fprintf(stderr, \"\\nUnknown command line option: %c\\n\", *s);\n               Error(0, -1, \"unknown command line option: %c\", *s);\n               Usage(progname, 1);\n         }\n\n   // dir for temporary files\n   if (!tmpdir.length())\n      tmpdir = std::string(\"/usr/tmp\");\n   if (access(tmpdir.c_str(), W_OK) == -1)\n      tmpdir = std::string(\"/tmp\");\n\n   // root tab file\n   gRootdTab = std::string(tmpdir).append(\"/rootdtab\");\n\n   if (argc > 0) {\n      confdir = std::string(*argv);\n   }\n\n#ifdef ROOTPREFIX\n   if (getenv(\"IGNOREROOTPREFIX\")) {\n#endif\n      if (!confdir.length()) {\n         // try to guess the config directory...\n         if (getenv(\"ROOTSYS\")) {\n            confdir = getenv(\"ROOTSYS\");\n            if (gDebug > 0)\n               ErrorInfo(\"main: no config directory specified using\"\n                         \" ROOTSYS (%s)\", confdir.c_str());\n         } else {\n            if (gDebug > 0)\n               ErrorInfo(\"main: no config directory specified\");\n         }\n      }\n      rootbindir = std::string(confdir).append(\"/bin\");\n      rootetcdir = std::string(confdir).append(\"/etc\");\n#ifdef ROOTPREFIX\n   }\n   else {\n      if (!confdir.length())\n         confdir = ROOTPREFIX;\n      rootbindir = ROOTBINDIR;\n      rootetcdir = ROOTETCDIR;\n   }\n#endif\n\n   // Make rootbindir available to all the session via env\n   if (rootbindir.length()) {\n      char *tmp1 = new char[15 + rootbindir.length()];\n      sprintf(tmp1, \"ROOTBINDIR=%s\", rootbindir.c_str());\n      putenv(tmp1);\n   }\n\n   // Make rootetcdir available to all the session via env\n   if (rootetcdir.length()) {\n      char *tmp1 = new char[15 + rootetcdir.length()];\n      sprintf(tmp1, \"ROOTETCDIR=%s\", rootetcdir.c_str());\n      putenv(tmp1);\n   }\n\n   // If specified, set the special daemonrc file to be used\n   if (daemonrc.length()) {\n      char *tmp1 = new char[15+daemonrc.length()];\n      sprintf(tmp1, \"ROOTDAEMONRC=%s\", daemonrc.c_str());\n      putenv(tmp1);\n   }\n#ifdef R__GLBS\n   // If specified, set the special gridmap file to be used\n   if (gridmap.length()) {\n      char *tmp1 = new char[15+gridmap.length()];\n      sprintf(tmp1, \"GRIDMAP=%s\", gridmap.c_str());\n      putenv(tmp1);\n   }\n   // If specified, set the special hostcert.conf file to be used\n   if (hostcertconf.length()) {\n      char *tmp1 = new char[15+hostcertconf.length()];\n      sprintf(tmp1, \"ROOTHOSTCERT=%s\", hostcertconf.c_str());\n      putenv(tmp1);\n   }\n#endif\n\n   // Parent ID\n   int rootdparentid = -1;      // Parent process ID\n   if (!gInetdFlag)\n      rootdparentid = getpid(); // Identifies this family\n   else\n      rootdparentid = getppid(); // Identifies this family\n\n   // default job options\n   unsigned int options = kDMN_RQAUTH | kDMN_HOSTEQ | kDMN_SYSLOG;\n   // modify them if required\n   if (!requireauth)\n      options &= ~kDMN_RQAUTH;\n   if (!checkhostsequiv)\n      options &= ~kDMN_HOSTEQ;\n   if (foregroundflag)\n      options &= ~kDMN_SYSLOG;\n   RpdInit(gService, rootdparentid, gProtocol, options,\n           reuseallow, sshdport,\n           tmpdir.c_str(),altSRPpass.c_str(),login);\n\n   // Generate Local RSA keys for the session\n   if (RpdGenRSAKeys(0)) {\n      Error(Err, -1, \"rootd: unable to generate local RSA keys\");\n   }\n\n   if (!gInetdFlag) {\n\n      // Start rootd up as a daemon process (in the background).\n      // Also initialize the network connection - create the socket\n      // and bind our well-know address to it.\n\n      int fdkeep = NetInit(gService, port1, port2, tcpwindowsize);\n      if (!foregroundflag)\n         DaemonStart(1, fdkeep, gService);\n   }\n\n   if (gDebug > 0)\n      ErrorInfo(\"main: pid = %d, ppid = %d, gInetdFlag = %d, gProtocol = %d\",\n                getpid(), getppid(), gInetdFlag, gProtocol);\n\n   // Concurrent server loop.\n   // The child created by NetOpen() handles the client's request.\n   // The parent waits for another request. In the inetd case,\n   // the parent from NetOpen() never returns.\n\n   while (1) {\n\n      if (NetOpen(gInetdFlag, gService) == 0) {\n\n         // Init Session (get protocol, run authentication, login, ...)\n         int rci = RpdInitSession(gService, gUser,\n                                  gClientProtocol, gAnon, gPasswd);\n         if (rci == -1)\n            Error(ErrFatal, -1, \"rootd: failure initializing session\");\n         else if (rci == -2)\n            // Special session (eg. cleanup): just exit\n            exit(0);\n\n         ErrorInfo(\"main: rootdparentid = %d (%d)\", rootdparentid, getppid());\n\n         // RootdParallel is called after authentication in RootdLogin\n         RootdLoop();      // child processes client's requests\n         NetClose();       // till we are done\n         exit(0);\n      }\n\n      // parent waits for another client to connect\n      // (except in CASTOR mode)\n      if (gCastorFlag) break;\n\n   }\n\n}\n"], "fixing_code": ["// @(#)root/rootd:$Id: 4d5ab379c1d34cf9123e315a1a5153b22cb9f404 $\n// Author: Fons Rademakers   11/08/97\n\n/*************************************************************************\n * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// Rootd                                                                //\n//                                                                      //\n// Root remote file server daemon.                                      //\n// This small server is started either by inetd when a client requests  //\n// a connection to a rootd server or by hand (i.e. from the command     //\n// line). The rootd server works with the ROOT TNetFile class. It       //\n// allows remote access to ROOT database files in either read or        //\n// write mode. By default TNetFile uses port 1094 (allocated by IANA,   //\n// www.iana.org, to rootd). To run rootd via inetd add the              //\n// following line to /etc/services:                                     //\n//                                                                      //\n// rootd     1094/tcp                                                   //\n//                                                                      //\n// and to /etc/inetd.conf:                                              //\n//                                                                      //\n// rootd stream tcp nowait root /usr/local/root/bin/rootd rootd -i      //\n//                                                                      //\n// Force inetd to reread its conf file with \"kill -HUP <pid inetd>\".    //\n//                                                                      //\n// If xinetd is used instead, a file named 'rootd' should be created    //\n// under /etc/xinetd.d with content:                                    //\n//                                                                      //\n// # default: off                                                       //\n// # description: The root daemon                                       //\n// #                                                                    //\n// service rootd                                                        //\n// {                                                                    //\n//      disable         = no                                            //\n//      flags           = REUSE                                         //\n//      socket_type     = stream                                        //\n//      wait            = no                                            //\n//      user            = root                                          //\n//      server          = /usr/local/root/bin/rootd                     //\n//      server_args     = -i -d 0                                       //\n// }                                                                    //\n//                                                                      //\n// and xinetd restarted (/sbin/service xinetd restart).                 //\n//                                                                      //\n// You can also start rootd by hand running directly under your private //\n// account (no root system priviliges needed). For example to start     //\n// rootd listening on port 5151 just type:                              //\n//                                                                      //\n// rootd -p 5151                                                        //\n//                                                                      //\n// Notice: no & is needed. Rootd will go in background by itself.       //\n// In this case, the port number and process id will be printed, e.g.   //\n//                                                                      //\n// ROOTD_PORT=5151                                                      //\n// ROOTD_PID=14433                                                      //\n//                                                                      //\n// Rootd arguments:                                                     //\n//   -b tcpwindowsize  specifies the tcp window size in bytes (e.g. see //\n//                     http://www.psc.edu/networking/perf_tune.html)    //\n//                     Default is 65535. Only change default for pipes  //\n//                     with a high bandwidth*delay product.             //\n//   -C hostcertfile   defines a file where to find information for the //\n//                     local host Globus information (see GLOBUS.README //\n//                     for details)                                     //\n//   -d level          level of debug info written to syslog            //\n//                     0 = no debug (default)                           //\n//                     1 = minimum                                      //\n//                     2 = medium                                       //\n//                     3 = maximum                                      //\n//   -D rootdaemonrc   read access rules from file <rootdaemonrc>.      //\n//                     By default <root_etc_dir>/system.rootdaemonrc is //\n//                     used for access rules; for privately started     //\n//                     daemons $HOME/.rootdaemonrc (if present) takes   //\n//                     highest priority.                                //\n//   -E                obsolete; up to v4.00.08 this option was used to //\n//                     force exclusivity of the authentication tokens;  //\n//                     with the new approach for authentication tab     //\n//                     files this option is dummy.                      //\n//   -f                do not run as daemon, run in the foreground      //\n//   -F filename       Specify that rootd is in CASTOR mode and should  //\n//                     serve this file.                                 //\n//   -G gridmapfile    defines the gridmap file to be used for globus   //\n//                     authentication if different from globus default  //\n//                     (/etc/grid-security/gridmap); (re)defines the    //\n//                     GRIDMAP environment variable.                    //\n//   -h                print usage message                              //\n//   -H reqid          In CASTOR mode, specify the ID of the request    //\n//                     that should be accepted                          //\n//   -i                says we were started by inetd                    //\n//   -noauth           do not require client authentication             //\n//   -nologin          do not login the client to its $HOME as it may   //\n//                     not exist                                        //\n//   -p port#          specifies a different port to listen on.         //\n//                     Use port1-port2 to find first available port in  //\n//                     range. Use 0-N for range relative to service     //\n//                     port.                                            //\n//   -P file           use this password file, instead of .srootdpass   //\n//   -r                files can only be opened in read-only mode       //\n//   -R bitmask        bit mask specifies which methods will allow      //\n//                     authentication to be re-used                     //\n//   -s <sshd_port>    specifies the port number for the sshd daemon    //\n//                     (default is 22)                                  //\n//   -S keytabfile     use this keytab file, instead of the default     //\n//                     (option only supported when compiled with        //\n//                     Kerberos5 support)                               //\n//   -T <tmpdir>       specifies the directory path to be used to place //\n//                     temporary files; default is /usr/tmp.            //\n//                     Useful if not running as root.                   //\n//   -w                do not check /etc/hosts.equiv, $HOME/.rhosts     //\n//                     for UsrPwd authentications; by default these     //\n//                     files are checked first by calling ruserok(...); //\n//                     if this option is specified a password is always //\n//                     required.\n//   rootsys_dir       directory containing the ROOT etc and bin        //\n//                     directories. Superseeds ROOTSYS or built-in      //\n//                     (as specified to ./configure).                   //\n//                                                                      //\n// Rootd can also be configured for anonymous usage (like anonymous     //\n// ftp). To setup rootd to accept anonymous logins do the following     //\n// (while being logged in as root):                                     //\n//                                                                      //\n// - Add the following line to /etc/passwd:                             //\n//                                                                      //\n//   rootd:*:71:72:Anonymous rootd:/var/spool/rootd:/bin/false          //\n//                                                                      //\n//   where you may modify the uid, gid (71, 72) and the home directory  //\n//   to suite your system.                                              //\n//                                                                      //\n// - Add the following line to /etc/group:                              //\n//                                                                      //\n//   rootd:*:72:rootd                                                   //\n//                                                                      //\n//   where the gid must match the gid in /etc/passwd.                   //\n//                                                                      //\n// - Create the directories:                                            //\n//                                                                      //\n//   mkdir /var/spool/rootd                                             //\n//   mkdir /var/spool/rootd/tmp                                         //\n//   chmod 777 /var/spool/rootd/tmp                                     //\n//                                                                      //\n//   Where /var/spool/rootd must match the rootd home directory as      //\n//   specified in the rootd /etc/passwd entry.                          //\n//                                                                      //\n// - To make writable directories for anonymous do, for example:       //\n//                                                                      //\n//   mkdir /var/spool/rootd/pub                                         //\n//   chown rootd:rootd /var/spool/rootd/pub                             //\n//                                                                      //\n// That's all.                                                          //\n//                                                                      //\n// Several remarks:                                                     //\n//  - you can login to an anonymous server either with the names        //\n//    \"anonymous\" or \"rootd\".                                           //\n//  - the passwd should be of type user@host.do.main. Only the @ is     //\n//    enforced for the time being.                                      //\n//  - in anonymous mode the top of the file tree is set to the rootd    //\n//    home directory, therefore only files below the home directory     //\n//    can be accessed.                                                  //\n//  - anonymous mode only works when the server is started via inetd.   //\n//                                                                      //\n//  When your system uses shadow passwords you have to compile rootd    //\n//  with -DR__SHADOWPW. Since shadow passwords can only be accessed     //\n//  while being superuser (root) this works only when the server is     //\n//  started via inetd. Another solution is to create a file             //\n//  ~/.rootdpass containing an encrypted password. If this file exists  //\n//  its password is used for authentication. This method overrides      //\n//  all other authentication methods. To create an encrypted password   //\n//  do something like:                                                  //\n//     perl -e '$pw = crypt(\"<secretpasswd>\",\"salt\"); print \"$pw\\n\"'    //\n//  and store this string in ~/.rootdpass.                              //\n//                                                                      //\n//  To use AFS for authentication compile rootd with the -DR__AFS flag. //\n//  In that case you also need to link with the AFS libraries. See      //\n//  the Makefiles for more details.                                     //\n//                                                                      //\n//  To use Secure Remote Passwords (SRP) for authentication compile     //\n//  rootd with the -DR__SRP flag. In that case you also need to link    //\n//  with the SRP and gmp libraries. See the Makefile for more details.  //\n//  SRP is described at: http://srp.stanford.edu/.                      //\n//                                                                      //\n//  See README.AUTH for more details on the authentication features.    //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n// Protocol changes (see gProtocol):\n// 2 -> 3: added handling of kROOTD_FSTAT message.\n// 3 -> 4: added support for TFTP (i.e. kROOTD_PUTFILE, kROOTD_GETFILE, etc.)\n// 4 -> 5: added support for \"+read\" to allow readers when file is opened for writing\n// 5 -> 6: added support for kerberos5 authentication\n// 6 -> 7: added support for kROOTD_BYE and kROOTD_PROTOCOL2\n// 7 -> 8: added support for Globus, SSH and Rfio authentication and negotiation\n// 8 -> 9: change in Kerberos authentication protocol\n// 9 -> 10: Receives client protocol with kROOTD_PROTOCOL + change cleaning protocol\n// 10 -> 11: modified SSH protocol + support for server 'no authentication' mode\n// 11 -> 12: added support for stat functionality (access,opendir,...) (cfr.TNetSystem)\n//           and support for OpenSSL keys for encryption\n// 12 -> 13: changed return message of RootdFstat()\n// 13 -> 14: support for TNetFile setup via TXNetFile\n// 14 -> 15: support for SSH authentication via SSH tunnel\n// 15 -> 16: cope with the bug fix in TUrl::GetFile\n// 16 -> 17: Addition of \"Gets\" (multiple buffers in a single request)\n// 17 -> 18: fix problems with '//' in admin paths; partial logging in castor mode\n\n#include \"RConfigure.h\"\n#include \"RConfig.h\"\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <netinet/in.h>\n#include <errno.h>\n#include <netdb.h>\n#include \"snprintf.h\"\n\n#include <sys/types.h>\n#include <dirent.h>\n\n#if defined(__CYGWIN__) && defined(__GNUC__)\n#   define cygwingcc\n#endif\n#if defined(__APPLE__)\n#include <sys/mount.h>\nextern \"C\" int fstatfs(int file_descriptor, struct statfs *buffer);\n#elif defined(linux) || defined(__hpux) || defined(cygwingcc)\n#include <sys/vfs.h>\n#elif defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <sys/param.h>\n#include <sys/mount.h>\n#else\n#include <sys/statfs.h>\n#endif\n\n#if defined(linux) || defined(__hpux) || defined(_AIX) || \\\n    defined(__sun) || defined(__sgi) || defined(__FreeBSD__) || \\\n    defined(__APPLE__) || defined(cygwingcc) || defined(__OpenBSD__)\n#define HAVE_MMAP\n#endif\n\n#ifdef HAVE_MMAP\n#   include <sys/mman.h>\n#ifndef MAP_FILE\n#define MAP_FILE 0           /* compatability flag */\n#endif\n#endif\n\n#if (defined(__FreeBSD__) && (__FreeBSD__ < 4)) || defined(__OpenBSD__) || \\\n    (defined(__APPLE__) && (!defined(MAC_OS_X_VERSION_10_3) || \\\n     (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_3)))\n#include <sys/file.h>\n#define lockf(fd, op, sz)   flock((fd), (op))\n#ifndef F_LOCK\n#define F_LOCK             (LOCK_EX | LOCK_NB)\n#endif\n#ifndef F_ULOCK\n#define F_ULOCK             LOCK_UN\n#endif\n#endif\n\n#if defined(cygwingcc) && !defined(F_LOCK) && !defined(F_ULOCK)\n#define F_LOCK F_WRLCK\n#define F_ULOCK F_UNLCK\nstatic int fcntl_lockf(int fd, int op, off_t off)\n{\n   flock fl;\n   fl.l_whence = SEEK_SET;\n   fl.l_start  = off;\n   fl.l_len    = 0;       // whole file\n   fl.l_pid    = getpid();\n   fl.l_type   = op;\n   return fcntl(fd, F_SETLK, &fl);\n}\n#define lockf fcntl_lockf\n#endif\n\n#if defined(linux) || defined(__sun) || defined(__sgi) || \\\n    defined(_AIX) || defined(__FreeBSD__) || defined(__APPLE__) || \\\n    defined(__MACH__) || defined(cygwingcc) || defined(__OpenBSD__)\n#include <grp.h>\n#include <sys/types.h>\n#include <signal.h>\n#define ROOT_SIGNAL_INCLUDED\n#endif\n\n#if defined(__sgi) && !defined(__GNUG__) && (SGI_REL<62)\nextern \"C\" {\n   int seteuid(int euid);\n   int setegid(int egid);\n}\n#endif\n\n#if defined(_AIX)\nextern \"C\" {\n   //int initgroups(const char *name, int basegid);\n   int seteuid(uid_t euid);\n   int setegid(gid_t egid);\n}\n#endif\n\n#include \"NetErrors.h\"\n#include \"rootdp.h\"\n\n// Debug flag\nint gDebug  = 0;\n\n//--- Local Globals -----------------------------------------------------------\n\nenum EFileMode{ kBinary, kAscii };\n\nstatic std::string gRootdTab;     // keeps track of open files\nstatic std::string gRpdAuthTab;   // keeps track of authentication info\nstatic EService gService         = kROOTD;\nstatic int gProtocol             = 18;      // increase when protocol changes\nstatic int gClientProtocol       = -1;      // Determined by RpdInitSession\nstatic int gAnon                 = 0;       // anonymous user flag\nstatic double gBytesRead         = 0;\nstatic double gBytesWritten      = 0;\nstatic DIR *gRDDirectory         = 0;\nstatic int gDownloaded           = 0;\nstatic int gFd                   = -1;\nstatic int gFtp                  = 0;\nstatic int gInetdFlag            = 0;\nstatic char gOption[32]          = { 0 };\nstatic char gRdFile[kMAXPATHLEN]   = { 0 };\nstatic int gUploaded             = 0;\nstatic int gWritable             = 0;\nstatic int gReadOnly             = 0;\nstatic std::string gUser;\nstatic std::string gPasswd;\n\n// CASTOR specific\nstatic int gCastorFlag           = 0;\nstatic std::string gCastorFile;\nstatic std::string gCastorReqId;\n\nusing namespace ROOT;\n\n//--- Error handlers -----------------------------------------------------------\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid Err(int level,const char *msg, int size)\n{\n   Perror((char *)msg,size);\n   if (level > -1) NetSendError((ERootdErrors)level);\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid ErrFatal(int level,const char *msg, int size)\n{\n   Perror((char *)msg,size);\n   if (level > -1) NetSendError((ERootdErrors)level);\n   RootdClose();\n   exit(1);\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid ErrSys(int level,const char *msg, int size)\n{\n   Perror((char *)msg,size);\n   ErrFatal(level,msg,size);\n}\n\n//--- Rootd routines -----------------------------------------------------------\n\nconst char *shellMeta   = \"~*[]{}?$\";\nconst char *shellStuff  = \"(){}<>\\\"'\";\nconst char  shellEscape = '\\\\';\n\n////////////////////////////////////////////////////////////////////////////////\n/// After SO_KEEPALIVE times out we probably get a SIGPIPE.\n\nvoid SigPipe(int)\n{\n   ErrorInfo(\"SigPipe: rootd.cxx: got a SIGPIPE\");\n\n   // Terminate properly\n   RpdAuthCleanup(0, 0);\n   RootdClose();\n   exit(1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns the user's home directory.\n\nstatic const char *HomeDirectory(const char *name)\n{\n   static char path[kMAXPATHLEN], mydir[kMAXPATHLEN];\n   struct passwd *pw;\n\n   if (name) {\n      pw = getpwnam(name);\n      if (pw) {\n         strncpy(path, pw->pw_dir, kMAXPATHLEN-1);\n         path[sizeof(path)-1] = '\\0';\n         return path;\n      }\n   } else {\n      if (mydir[0])\n         return mydir;\n      pw = getpwuid(getuid());\n      if (pw) {\n         strncpy(mydir, pw->pw_dir, kMAXPATHLEN-1);\n         mydir[sizeof(mydir)-1] = '\\0';\n         return mydir;\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns the current working directory.\n\nstatic const char *WorkingDirectory()\n{\n   static char path[kMAXPATHLEN];\n\n   if (getcwd(path, kMAXPATHLEN)) return path;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////\n/// Method for pathname expansion.\n/// Returns kTRUE in case of error and kFALSE otherwise.\n\nBool_t RootdExpandFileName(const char *fname, char *xname, const int kBufSize)\n{\n   int n, ier, iter, lx, ncopy;\n   char *inp, *out, *x, *t, buff[kBufSize * 4];\n   const char *b, *c, *e;\n   const char *p;\n\n   iter = 0;\n   xname[0] = 0;\n   inp = buff + kBufSize;\n   out = inp + kBufSize;\n   inp[-1] = ' ';\n   inp[0] = 0;\n   out[-1] = ' ';\n   c = fname + strspn(fname, \" \\t\\f\\r\");\n   // VP  if (isalnum(c[0])) { strcpy(inp, WorkingDirectory()); strcat(inp, \"/\"); } // add $cwd\n\n   strncat(inp, c, kBufSize - strlen(inp) - 1);\n\nagain:\n   iter++;\n   c = inp;\n   ier = 0;\n   x = out;\n   x[0] = 0;\n\n   p = 0;\n   e = 0;\n   if (c[0] == '~' && c[1] == '/') { // ~/ case\n      std::string hd = HomeDirectory(0);\n      p = hd.c_str();\n      e = c + 1;\n      if (p) { // we have smth to copy\n         strlcpy(x, p, kBufSize);\n         x += strlen(p);\n         c = e;\n      } else {\n         ++ier;\n         ++c;\n      }\n   } else if (c[0] == '~' && c[1] != '/') { // ~user case\n      n = strcspn(c + 1, \"/ \");\n      buff[0] = 0;\n      strncat(buff, c + 1, n);\n      std::string hd = HomeDirectory(buff);\n      e = c + 1 + n;\n      if (!hd.empty()) { // we have smth to copy\n         p = hd.c_str();\n         strlcpy(x, p, kBufSize);\n         x += strlen(p);\n         c = e;\n      } else {\n         x++ [0] = c[0];\n         //++ier;\n         ++c;\n      }\n   }\n\n   for (; c[0]; c++) {\n\n      p = 0;\n      e = 0;\n\n      if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') { // $cwd\n         std::string wd = WorkingDirectory();\n         strlcpy(buff, wd.c_str(), kBufSize);\n         p = buff;\n         e = c + 1;\n      }\n      if (p) { // we have smth to copy */\n         strlcpy(x, p, kBufSize);\n         x += strlen(p);\n         c = e - 1;\n         continue;\n      }\n\n      if (c[0] != '$') { // not $, simple copy\n         x++ [0] = c[0];\n      } else { // we have a $\n         b = c + 1;\n         if (c[1] == '(') b++;\n         if (c[1] == '{') b++;\n         if (b[0] == '$')\n            e = b + 1;\n         else\n            for (e = b; isalnum(e[0]) || e[0] == '_'; e++)\n               ;\n         buff[0] = 0;\n         strncat(buff, b, e - b);\n         p = getenv(buff);\n         if (!p) { // too bad, try UPPER case\n            for (t = buff; (t[0] = toupper(t[0])); t++)\n               ;\n            p = getenv(buff);\n         }\n         if (!p) { // too bad, try Lower case\n            for (t = buff; (t[0] = tolower(t[0])); t++)\n               ;\n            p = getenv(buff);\n         }\n         if (!p && !strcmp(buff, \"cwd\")) { // it is $cwd\n            std::string wd = WorkingDirectory();\n            strlcpy(buff, wd.c_str(), kBufSize);\n            p = buff;\n         }\n         if (!p && !strcmp(buff, \"$\")) { // it is $$ (replace by getpid())\n            snprintf(buff, kBufSize * 4, \"%d\", (int)getpid());\n            p = buff;\n         }\n         if (!p) { // too bad, nothing can help\n            ier++;\n            x++ [0] = c[0];\n         } else { // It is OK, copy result\n            int lp = strlen(p);\n            if (lp >= kBufSize) {\n               // make sure lx will be >= kBufSize (see below)\n               strlcpy(x, p, kBufSize);\n               x += kBufSize;\n               break;\n            }\n            strcpy(x, p);\n            x += lp;\n            c = (b == c + 1) ? e - 1 : e;\n         }\n      }\n   }\n\n   x[0] = 0;\n   lx = x - out;\n   if (ier && iter < 3) {\n      strlcpy(inp, out, kBufSize);\n      goto again;\n   }\n   ncopy = (lx >= kBufSize) ? kBufSize - 1 : lx;\n   xname[0] = 0;\n   strncat(xname, out, ncopy);\n\n   if (ier || ncopy != lx) {\n      Error(ErrFatal, kErrFatal, \"RootdExpandFileName: fatal error:\\n\\t input: %s\\n\\t output: %s\", fname, xname);\n      return true;\n   }\n\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Expand a pathname getting rid of special shell characters like ~.$, etc.\n/// Returned string must be freed by caller.\n\nchar *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n\n   // skip leading blanks\n   while (*patbuf == ' ') patbuf++;\n\n   // any shell meta characters?\n   bool needesc = false;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p)) {\n         needesc = true;\n         break;\n      }\n\n   // Escape meta characters, if required\n   if (needesc) {\n      const int kBufSize = kMAXPATHLEN;\n      char xname[kBufSize];\n      if (RootdExpandFileName(name, xname, kBufSize)) {\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");\n         return 0;\n      } else {\n         return strdup(xname);\n      }\n   }\n   return strdup(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Checks gRootdTab file to see if file can be opened. If mode = 1 then\n/// check if file can safely be opened in write mode, i.e. see if file\n/// is not already opened in either read or write mode. If mode = 0 then\n/// check if file can safely be opened in read mode, i.e. see if file\n/// is not already opened in write mode. If mode = -1 check write mode\n/// like 1 but do not update rootdtab file. Returns 1 if file can be\n/// opened safely, otherwise 0.\n///\n/// The format of the file is:\n/// filename device inode mode username pid\n/// where device is the unique file system id, inode is the unique file\n/// ref number, mode is either \"read\" or \"write\", username the user\n/// who has the file open and pid is the pid of the rootd having the\n/// file open.\n\nint RootdCheckTab(int mode)\n{\n   // Open rootdtab file. Try first /usr/tmp and then /tmp.\n   // The lockf() call can fail if the directory is NFS mounted\n   // and the lockd daemon is not running.\n\n   const char *sfile = gRootdTab.c_str();\n   int fid, create = 0;\n\n   int noupdate = 0;\n   if (mode < 0) {\n      mode = 1;\n      noupdate = 1;\n   }\n\nagain:\n   if (access(sfile, F_OK) == -1) {\n      fid = open(sfile, O_CREAT|O_RDWR, 0644);\n      if (fid != -1) fchmod(fid, 0666);    // override umask setting\n      create = 1;\n   } else\n      fid = open(sfile, O_RDWR);\n\n   if (fid == -1) {\n      if (sfile[1] == 'u') {\n         sfile = gRootdTab.c_str()+4;\n         goto again;\n      }\n      Error(ErrSys, kErrFatal, \"RootdCheckTab: error opening %s\", sfile);\n   }\n\n   // lock the file\n   if (lockf(fid, F_LOCK, (off_t)1) == -1) {\n      if (sfile[1] == 'u' && create) {\n         close(fid);\n         remove(sfile);\n         sfile = gRootdTab.c_str()+4;\n         goto again;\n      }\n      Error(ErrSys, kErrFatal, \"RootdCheckTab: error locking %s\", sfile);\n   }\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCheckTab: file %s locked\", sfile);\n\n   struct stat sbuf;\n   fstat(fid, &sbuf);\n   size_t siz = sbuf.st_size;\n\n   dev_t device;\n   ino_t inode;\n   if (stat(gRdFile, &sbuf) == -1) {\n      device = 0;\n      inode  = 0;\n   } else {\n      device = sbuf.st_dev;\n      inode  = sbuf.st_ino;\n   }\n\n   char msg[kMAXPATHLEN];\n   const char *smode = (mode == 1) ? \"write\" : \"read\";\n   int result = 1;\n\n   if (siz > 0) {\n      int changed = 0;\n      char *fbuf = new char[siz+1];\n      char *flast = fbuf + siz;\n\n      while (read(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n         ResetErrno();\n      fbuf[siz] = 0;\n\n      char *n, *s = fbuf;\n      while ((n = strchr(s, '\\n')) && siz > 0) {\n         n++;\n         char user[64], gmode[32];\n         int  pid;\n         unsigned long dev, ino;\n         sscanf(s, \"%s %lu %lu %s %s %d\", msg, &dev, &ino, gmode, user, &pid);\n         if (kill(pid, 0) == -1 && GetErrno() == ESRCH) {\n            ErrorInfo(\"RootdCheckTab: remove stale lock (%s %lu %lu %s %s %d)\\n\",\n                msg, dev, ino, gmode, user, pid);\n            if (n >= flast) {\n               siz = int(s - fbuf);\n               changed = 1;\n               break;\n            } else {\n               int l = int(flast - n) + 1;\n               memmove(s, n, l);\n               siz -= int(n - s);\n               n = s;\n            }\n            flast = fbuf + siz;\n            changed = 1;\n         } else if ((dev_t)dev == device && (ino_t)ino == inode) {\n            if (mode == 1)\n               result = 0;\n            else if (!strcmp(gmode, \"write\"))\n               result = 0;\n         }\n         s = n;\n      }\n      if (changed) {\n         if (ftruncate(fid, 0) == -1)\n            ErrorInfo(\"RootdCheckTab: ftruncate failed\");\n         lseek(fid, 0, SEEK_SET);\n         if (siz > 0) {\n            while (write(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n               ResetErrno();\n         }\n      }\n      delete [] fbuf;\n   }\n\n   if (result && !noupdate) {\n      unsigned long dev = device;\n      unsigned long ino = inode;\n      char *tmsg = msg;\n      int lmsg = strlen(gRdFile) + gUser.length() + strlen(smode) + 40;\n      if (lmsg > kMAXPATHLEN)\n         tmsg = new char[lmsg];\n      sprintf(tmsg, \"%s %lu %lu %s %s %d\\n\",\n                   gRdFile, dev, ino, smode, gUser.c_str(), (int) getpid());\n      if (write(fid, tmsg, strlen(tmsg)) == -1)\n         Error(ErrSys, kErrFatal, \"RootdCheckTab: error writing %s\", sfile);\n      if (tmsg != msg)\n         delete[] tmsg;\n   }\n\n   // unlock the file\n   lseek(fid, 0, SEEK_SET);\n   if (lockf(fid, F_ULOCK, (off_t)1) == -1)\n      Error(ErrSys, kErrFatal, \"RootdCheckTab: error unlocking %s\", sfile);\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCheckTab: file %s unlocked\", sfile);\n\n   close(fid);\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Removes from the gRootdTab file the reference to gRdFile for the\n/// current rootd. If force = 1, then remove all references for gRdFile\n/// from the gRootdTab file. This might be necessary in case something\n/// funny happened and the original reference was not correctly removed.\n/// Stale locks are detected by checking each pid and then removed.\n\nvoid RootdCloseTab(int force = 0)\n{\n   const char *sfile = gRootdTab.c_str();\n   int fid;\n\nagain:\n   if (access(sfile, F_OK) == -1) {\n      if (sfile[1] == 'u') {\n         sfile = gRootdTab.c_str()+4;\n         goto again;\n      }\n      ErrorInfo(\"RootdCloseTab: file %s does not exist\", sfile);\n      return;\n   }\n\n   fid = open(sfile, O_RDWR);\n\n   if (fid == -1) {\n      ErrorInfo(\"RootdCloseTab: error opening %s\", sfile);\n      return;\n   }\n\n   // lock the file\n   if (lockf(fid, F_LOCK, (off_t)1) == -1) {\n      ErrorInfo(\"RootdCloseTab: error locking %s\", sfile);\n      close(fid);\n      return;\n   }\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCloseTab: file %s locked\", sfile);\n\n   struct stat sbuf;\n   fstat(fid, &sbuf);\n   size_t siz = sbuf.st_size;\n\n   stat(gRdFile, &sbuf);\n   dev_t device = sbuf.st_dev;\n   ino_t inode  = sbuf.st_ino;\n\n   if (siz > 0) {\n      int changed = 0;\n      int mypid   = getpid();\n      char *fbuf  = new char[siz+1];\n      char *flast = fbuf + siz;\n\n      while (read(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n         ResetErrno();\n      fbuf[siz] = 0;\n\n      char *n, *s = fbuf;\n      while ((n = strchr(s, '\\n')) && siz > 0) {\n         n++;\n         char msg[kMAXPATHLEN], user[64], gmode[32];\n         int  pid, stale = 0;\n         unsigned long dev, ino;\n         sscanf(s, \"%s %lu %lu %s %s %d\", msg, &dev, &ino, gmode, user, &pid);\n         if (kill(pid, 0) == -1 && GetErrno() == ESRCH) {\n            stale = 1;\n            ErrorInfo(\"Remove Stale Lock (%s %lu %lu %s %s %d)\\n\",\n                       msg, dev, ino, gmode, user, pid);\n         }\n         if (stale || (!force && mypid == pid) ||\n            (force && device == (dev_t)dev && inode == (ino_t)ino &&\n             !strcmp(gUser.c_str(), user))) {\n            if (n >= flast) {\n               siz = int(s - fbuf);\n               changed = 1;\n               break;\n            } else {\n               int l = int(flast - n) + 1;\n               memmove(s, n, l);\n               siz -= int(n - s);\n               n = s;\n            }\n            flast = fbuf + siz;\n            changed = 1;\n         }\n         s = n;\n      }\n      if (changed) {\n         if (ftruncate(fid, 0) == -1)\n            ErrorInfo(\"RootdCheckTab: ftruncate failed\");\n         lseek(fid, 0, SEEK_SET);\n         if (siz > 0) {\n            while (write(fid, fbuf, siz) < 0 && GetErrno() == EINTR)\n               ResetErrno();\n         }\n      }\n      delete [] fbuf;\n   }\n\n   // unlock the file\n   lseek(fid, 0, SEEK_SET);\n   if (lockf(fid, F_ULOCK, (off_t)1) == -1) {\n      ErrorInfo(\"RootdCloseTab: error unlocking %s\", sfile);\n      close(fid);\n      return;\n   }\n   if (gDebug > 2)\n      ErrorInfo(\"RootdCloseTab: file %s unlocked\", sfile);\n\n   close(fid);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint RootdIsOpen()\n{\n   if (gFd == -1) return 0;\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdCloseFtp()\n{\n   if (gDebug > 0)\n      ErrorInfo(\"RootdCloseFtp: %d files uploaded, %d files downloaded,\"\n                \" rd=%g, wr=%g, rx=%g, tx=%g\",\n                gUploaded, gDownloaded, gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n   else\n      ErrorInfo(\"Rootd: %d files uploaded, %d files downloaded, rd=%g,\"\n                \" wr=%g, rx=%g, tx=%g\",\n                gUploaded, gDownloaded, gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdClose()\n{\n   if (gFtp) {\n      RootdCloseFtp();\n      return;\n   }\n\n   if (RootdIsOpen()) {\n      close(gFd);\n      gFd = -1;\n   }\n\n   RootdCloseTab();\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdClose: file %s closed, rd=%g, wr=%g, rx=%g, tx=%g\",\n                gRdFile, gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n   else\n      ErrorInfo(\"Rootd: file %s closed, rd=%g, wr=%g, rx=%g, tx=%g\", gRdFile,\n                gBytesRead, gBytesWritten,\n                NetGetBytesRecv(), NetGetBytesSent());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdFlush()\n{\n   if (RootdIsOpen() && gWritable) {\n#ifndef WIN32\n      if (fsync(gFd) < 0)\n         Error(ErrSys, kErrFatal, \"RootdFlush: error flushing file %s\", gRdFile);\n#endif\n   }\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdFlush: file %s flushed\", gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid RootdStat()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return file stat information in same format as TSystem::GetPathInfo().\n\nvoid RootdFstat(const char *buf)\n{\n   char     msg[256];\n   int      islink = 0;\n\n#if defined(R__SEEK64)\n   struct stat64 statbuf;\n#elif defined(WIN32)\n   struct _stati64 statbuf;\n#else\n   struct stat statbuf;\n#endif\n\n   int rc = -1;\n   if (!buf || !buf[0]) {\n\n      if (RootdIsOpen()) {\n#if defined(R__SEEK64)\n         rc = fstat64(gFd, &statbuf);\n#elif defined(WIN32)\n         rc = _fstati64(gFd, &statbuf);\n#else\n         rc = fstat(gFd, &statbuf);\n#endif\n      }\n   } else {\n\n      char *epath = (char *)buf;\n      if (buf[0] == '/' && buf[1] == '/')\n         epath++;\n#if defined(R__SEEK64)\n      rc = lstat64(epath, &statbuf);\n#elif defined(WIN32)\n      rc = _stati64(epath, &statbuf);\n#else\n      rc = lstat(epath, &statbuf);\n#endif\n      if (rc >= 0) {\n         islink = S_ISLNK(statbuf.st_mode);\n         if (islink) {\n#if defined(R__SEEK64)\n            rc = stat64(epath, &statbuf);\n#elif defined(WIN32)\n            rc = _stati64(epath, &statbuf);\n#else\n            rc = stat(epath, &statbuf);\n#endif\n         }\n      }\n   }\n\n   // New format for recent clients\n   if (gClientProtocol > 11) {\n      if (rc >= 0)\n         sprintf(msg, \"%ld %ld %d %d %d %lld %ld %d\", (long)statbuf.st_dev,\n                 (long)statbuf.st_ino, statbuf.st_mode, (int)(statbuf.st_uid),\n                 (int)(statbuf.st_gid), (Long64_t)statbuf.st_size, statbuf.st_mtime,\n                 islink);\n      else\n         sprintf(msg, \"-1 -1 -1 -1 -1 -1 -1 -1\");\n   } else {\n      // Old client: use previous incomplete format\n      if (rc >= 0) {\n         long id = (statbuf.st_dev << 24) + statbuf.st_ino;\n         Long64_t size = statbuf.st_size;\n         long modtime = statbuf.st_mtime;\n         long flags = 0;\n         if (statbuf.st_mode & ((S_IEXEC)|(S_IEXEC>>3)|(S_IEXEC>>6)))\n            flags |= 1;\n         if ((statbuf.st_mode & S_IFMT) == S_IFDIR)\n            flags |= 2;\n         if ((statbuf.st_mode & S_IFMT) != S_IFREG &&\n             (statbuf.st_mode & S_IFMT) != S_IFDIR)\n            flags |= 4;\n         sprintf(msg, \"%ld %lld %ld %ld\", id, size, flags, modtime);\n      } else\n         sprintf(msg, \"-1 -1 -1 -1\");\n   }\n\n   NetSend(msg, kROOTD_FSTAT);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Handle initialization message from remote host. If size > 1 then\n/// so many parallel sockets will be opened to the remote host.\n\nvoid RootdParallel()\n{\n   int buf[3];\n   if (NetRecvRaw(buf, sizeof(buf)) < 0)\n      Error(ErrFatal, kErrFatal, \"RootdParallel: error receiving message\");\n\n   int size = ntohl(buf[1]);\n   int port = ntohl(buf[2]);\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdParallel: port = %d, size = %d\", port, size);\n\n   if (size > 1)\n      NetParOpen(port, size);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// System independent open().\n\nstatic int SysOpen(const char *pathname, int flags, unsigned int mode)\n{\n#if defined(R__WINGCC)\n   // ALWAYS use binary mode - even cygwin text should be in unix format\n   // although this is posix default it has to be set explicitly\n   return ::open(pathname, flags | O_BINARY, mode);\n#elif defined(R__SEEK64)\n   return ::open64(pathname, flags, mode);\n#else\n   return ::open(pathname, flags, mode);\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Open file in mode depending on specified option. If file is already\n/// opened by another rootd in write mode, do not open the file.\n\nvoid RootdOpen(const char *msg)\n{\n   char file[kMAXPATHLEN], option[32];\n\n   gBytesRead = gBytesWritten = 0;\n   NetResetByteCount();\n\n   sscanf(msg, \"%s %s\", file, option);\n\n   if (gCastorFlag) {\n\n      // Checking the CASTOR Request ID\n      if (gCastorReqId.length() > 0) {\n         if (strstr(file, gCastorReqId.c_str()) == 0) {\n            Error(ErrFatal, kErrNoAccess,\n                  \"RootdOpen: Bad CASTOR Request ID: %s rather than %s\",\n                  file, gCastorReqId.c_str());\n         }\n      }\n\n      ErrorInfo(\"RootdOpen: CASTOR Flag on, file: %s\", gCastorFile.c_str());\n      strncpy(gRdFile, gCastorFile.c_str(), kMAXPATHLEN-1);\n      gRdFile[kMAXPATHLEN-1] = '\\0';\n\n   } else {\n\n      if (gClientProtocol > 14) {\n         strlcpy(gRdFile, file, sizeof(gRdFile));\n      } else {\n         // Old clients send an additional slash at the beginning\n         if (file[0] == '/')\n            strlcpy(gRdFile, &file[1], sizeof(gRdFile));\n         else\n            strlcpy(gRdFile, file, sizeof(gRdFile));\n      }\n\n      gRdFile[strlen(file)] = '\\0';\n   }\n\n   strlcpy(gOption, option, sizeof(gOption));\n\n   int forceOpen = 0;\n   if (option[0] == 'f') {\n      forceOpen = 1;\n      strlcpy(gOption, &option[1], sizeof(gOption));\n   }\n\n   int forceRead = 0;\n   if (!strcmp(option, \"+read\")) {\n      forceRead = 1;\n      strlcpy(gOption, &option[1], sizeof(gOption));\n   }\n\n   int create = 0;\n   if (!strcmp(gOption, \"new\") || !strcmp(gOption, \"create\"))\n      create = 1;\n   int recreate = strcmp(gOption, \"recreate\") ? 0 : 1;\n   int update   = strcmp(gOption, \"update\")   ? 0 : 1;\n   int read     = strcmp(gOption, \"read\")     ? 0 : 1;\n   if (!create && !recreate && !update && !read) {\n      read = 1;\n      strlcpy(gOption, \"read\", sizeof(gOption));\n   }\n\n   if (!read && gReadOnly)\n      Error(ErrFatal, kErrNoAccess,\n            \"RootdOpen: file %s can only be opened in \\\"READ\\\" mode\", gRdFile);\n\n   if (!gAnon) {\n      char *fname;\n      if ((fname = RootdExpandPathName(gRdFile))) {\n         strlcpy(gRdFile, fname, sizeof(gRdFile));\n         free(fname);\n      } else\n         Error(ErrFatal, kErrBadFile, \"RootdOpen: bad file name %s\", gRdFile);\n   }\n\n   if (forceOpen)\n      RootdCloseTab(1);\n\n   int trunc = 0;\n   if (recreate) {\n      if (!RootdCheckTab(-1))\n         Error(ErrFatal, kErrFileWriteOpen,\n               \"RootdOpen: file %s already opened in read or write mode\", gRdFile);\n      if (!access(gRdFile, F_OK))\n         trunc = O_TRUNC;\n      else {\n         recreate = 0;\n         create   = 1;\n         strlcpy(gOption, \"create\", sizeof(gOption));\n      }\n   }\n\n   if (create && !access(gRdFile, F_OK))\n      Error(ErrFatal, kErrFileExists, \"RootdOpen: file %s already exists\", gRdFile);\n\n   int wasupdt = 0;\n   if (update) {\n      if (access(gRdFile, F_OK)) {\n         update = 0;\n         create = 1;\n         wasupdt = 1;\n         strlcpy(gOption, \"create\", sizeof(gOption));\n      }\n      if (update && access(gRdFile, W_OK))\n         Error(ErrFatal, kErrNoAccess,\n               \"RootdOpen: no write permission for file %s\", gRdFile);\n   }\n\n   if (read) {\n      if (access(gRdFile, F_OK))\n         Error(ErrFatal, kErrNoFile,\n               \"RootdOpen: file %s does not exist (errno: 0x%x)\", gRdFile, errno);\n      if (access(gRdFile, R_OK))\n         Error(ErrFatal, kErrNoAccess,\n               \"RootdOpen: no read permission for file %s (errno: 0x%x)\", gRdFile, errno);\n   }\n\n   if (create || recreate || update) {\n      if (create || recreate) {\n         // make sure file exists so RootdCheckTab works correctly\n#ifndef WIN32\n         gFd = SysOpen(gRdFile, O_RDWR | O_CREAT | trunc, 0644);\n#else\n         gFd = SysOpen(gRdFile, O_RDWR | O_CREAT | O_BINARY | trunc, S_IREAD | S_IWRITE);\n#endif\n         if (gFd != -1)\n            close(gFd);\n         gFd = -1;\n      }\n#ifndef WIN32\n      gFd = SysOpen(gRdFile, O_RDWR, 0644);\n#else\n      gFd = SysOpen(gRdFile, O_RDWR | O_BINARY, S_IREAD | S_IWRITE);\n#endif\n      if (gFd == -1)\n         Error(ErrSys, kErrFileOpen, \"RootdOpen: error opening file %s in write mode\", gRdFile);\n\n      if (!RootdCheckTab(1)) {\n         close(gFd);\n         Error(ErrFatal, kErrFileWriteOpen, \"RootdOpen: file %s already opened in read or write mode\", gRdFile);\n      }\n\n      gWritable = wasupdt ? 2 : 1;\n\n   } else {\n#ifndef WIN32\n      gFd = SysOpen(gRdFile, O_RDONLY, 0644);\n#else\n      gFd = SysOpen(gRdFile, O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);\n#endif\n      if (gFd == -1)\n         Error(ErrSys, kErrFileOpen, \"RootdOpen: error opening file %s in read mode\", gRdFile);\n\n      if (!RootdCheckTab(0)) {\n         if (!forceRead) {\n            close(gFd);\n            Error(ErrFatal, kErrFileReadOpen, \"RootdOpen: file %s already opened in write mode\", gRdFile);\n         }\n      }\n\n      gWritable = 0;\n\n   }\n\n   NetSend(gWritable, kROOTD_OPEN);\n\n   struct stat sbuf;\n   fstat(gFd, &sbuf);\n   unsigned long dev = sbuf.st_dev;\n   unsigned long ino = sbuf.st_ino;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdOpen: file %s opened in mode %s\", gRdFile, gOption);\n   else {\n      if (gAnon)\n         ErrorInfo(\"RootdOpen: file %s (dev=%lu,inode=%lu,%s) opened by %s/%s\",\n                   gRdFile, dev, ino, gOption, gUser.c_str(), gPasswd.c_str());\n      else\n         ErrorInfo(\"RootdOpen: file %s (dev=%lu,inode=%lu,%s) opened by %s\",\n                   gRdFile, dev, ino, gOption, gUser.c_str());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Receive a buffer and write it at the specified offset in the currently\n/// open file.\n\nvoid RootdPut(const char *msg)\n{\n   Long64_t offset;\n   int      len;\n\n   sscanf(msg, \"%lld %d\", &offset, &len);\n\n   char *buf = new char[len];\n   NetRecvRaw(buf, len);\n\n   if (!RootdIsOpen() || !gWritable)\n      Error(ErrFatal, kErrNoAccess, \"RootdPut: file %s not opened in write mode\", gRdFile);\n\n#if defined (R__SEEK64)\n   if (lseek64(gFd, offset, SEEK_SET) < 0)\n#elif defined(WIN32)\n   if (_lseeki64(gFd, offset, SEEK_SET) < 0)\n#else\n   if (lseek(gFd, offset, SEEK_SET) < 0)\n#endif\n      Error(ErrSys, kErrFilePut, \"RootdPut: cannot seek to position %lld in file %s\", offset, gRdFile);\n\n   ssize_t siz;\n   while ((siz = write(gFd, buf, len)) < 0 && GetErrno() == EINTR)\n      ResetErrno();\n\n   if (siz < 0)\n      Error(ErrSys, kErrFilePut, \"RootdPut: error writing to file %s\", gRdFile);\n\n   if (siz != len)\n      Error(ErrFatal, kErrFilePut, \"RootdPut: error writing all requested bytes to file %s, wrote %d of %d\",\n            gRdFile, siz, len);\n\n   NetSend(0, kROOTD_PUT);\n\n   delete [] buf;\n\n   gBytesWritten += len;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdPut: written %d bytes starting at %lld to file %s\",\n                len, offset, gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get a buffer from the specified offset from the currently open file\n/// and send it to the client.\n\nvoid RootdGet(const char *msg)\n{\n   Long64_t offset;\n   int      len;\n\n   sscanf(msg, \"%lld %d\", &offset, &len);\n\n   char *buf = new char[len];\n\n   if (!RootdIsOpen())\n      Error(ErrFatal, kErrNoAccess, \"RootdGet: file %s not open\", gRdFile);\n\n#if defined (R__SEEK64)\n   if (lseek64(gFd, offset, SEEK_SET) < 0)\n#elif defined(WIN32)\n   if (_lseeki64(gFd, offset, SEEK_SET) < 0)\n#else\n   if (lseek(gFd, offset, SEEK_SET) < 0)\n#endif\n      Error(ErrSys, kErrFileGet, \"RootdGet: cannot seek to position %lld in\"\n            \" file %s\", offset, gRdFile);\n\n   ssize_t siz;\n   while ((siz = read(gFd, buf, len)) < 0 && GetErrno() == EINTR)\n      ResetErrno();\n\n   if (siz < 0)\n      Error(ErrSys, kErrFileGet, \"RootdGet: error reading from file %s\", gRdFile);\n\n   if (siz != len)\n      Error(ErrFatal, kErrFileGet, \"RootdGet: error reading all requested bytes\"\n            \" from file %s, got %d of %d\",gRdFile, siz, len);\n\n   NetSend(0, kROOTD_GET);\n\n   NetSendRaw(buf, len);\n\n   delete [] buf;\n\n   gBytesRead += len;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdGet: read %d bytes starting at %lld from file %s\",\n                len, offset, gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Gets multiple buffers from the specified list of offsets and lengths from\n/// the currently open file and send it to the client in a single buffer.\n/// (BUt rem it gets the buffer with the info in the same way it would get\n/// new data)\n\nvoid RootdGets(const char *msg)\n{\n   if (!RootdIsOpen())\n      Error(ErrFatal, kErrNoAccess, \"RootdGets: file %s not open\", gRdFile);\n\n   Int_t nbuf;      // Number of buffers\n   Int_t len;       // len of the data buffer with the list of buffers\n   Int_t npar;      // compatibility issues\n   Int_t size;      // size of the readv block (all the small reads)\n   Int_t maxTransz; // blocksize for the transfer\n\n   npar = sscanf(msg, \"%d %d %d\", &nbuf, &len, &maxTransz);\n\n   Long64_t *offsets = new Long64_t[nbuf];  // list to be filled\n   Int_t    *lens    = new Int_t[nbuf];     // list to be filled\n   char     *buf_in  = new char[len+1];     // buff coming from the server\n\n   NetRecvRaw(buf_in, len);\n   buf_in[len] = '\\0';\n\n   char *ptr = buf_in;\n   size = 0;\n   for(Int_t i = 0 ; i < nbuf ; i++) {\n      sscanf(ptr, \"%llu-%d/\", &offsets[i], &lens[i]);\n      ptr = strchr(ptr, '/') + 1;\n      size += lens[i];\n   }\n\n   // If the blocksize is not specified the try to send\n   // just a big block\n   if( npar == 2  )\n      maxTransz = size;\n\n   // We are Ready to begin the transference\n   NetSend(0, kROOTD_GETS);\n\n   char *buf_out  = new char[maxTransz];\n   char *buf_send = new char[maxTransz];\n   Int_t actual_pos = 0; // position for the whole size\n   Int_t buf_pos    = 0; // position in the buffer\n   ssize_t siz = 0;\n\n   for (Int_t i = 0; i < nbuf; i++) {\n      Long64_t left = size - actual_pos;\n      if (left > maxTransz)\n         left = maxTransz;\n\n      Int_t pos = 0; // Position for the disk read\n      while ( pos < lens[i] ) {\n#if defined (R__SEEK64)\n         if (lseek64(gFd, offsets[i] + pos, SEEK_SET) < 0)\n#elif defined(WIN32)\n         if (_lseeki64(gFd, offsets[i] + pos, SEEK_SET) < 0)\n#else\n         if (lseek(gFd, offsets[i] + pos, SEEK_SET) < 0)\n#endif\n         Error(ErrSys, kErrFileGet, \"RootdGets: cannot seek to position %lld in\"\n            \" file %s\", offsets[i], gRdFile);\n\n         Int_t readsz = lens[i] - pos;\n         if( readsz > ( left - buf_pos) )\n            readsz = left - buf_pos;\n\n         while ((siz = read(gFd, buf_out + buf_pos, readsz)) < 0 && GetErrno() == EINTR)\n            ResetErrno();\n\n         if (siz != readsz)\n            goto end;\n\n         pos += readsz;\n         buf_pos += readsz;\n         if ( buf_pos == left ) {\n            if (gDebug > 0 )\n               ErrorInfo(\"RootdGets: Sending %d bytes\", left);\n\n            // Swap buffers\n            char *buf_tmp = buf_out;\n            buf_out = buf_send;\n            buf_send = buf_tmp;\n\n            NetSendRaw(buf_send, left);\n            actual_pos += left;\n            buf_pos = 0;\n\n            if ( left > (size - actual_pos) )\n               left = size - actual_pos;\n         }\n      }\n   }\n\nend:\n   if (siz < 0)\n      Error(ErrSys, kErrFileGet, \"RootdGets: error reading from file %s\", gRdFile);\n\n   if (actual_pos != size)\n      Error(ErrFatal, kErrFileGet, \"RootdGets: error reading all requested bytes\"\n            \" from file %s, got %d of %d\",gRdFile, actual_pos, size);\n\n   delete [] buf_in;\n   delete [] buf_out;\n   delete [] buf_send;\n   delete [] lens;\n   delete [] offsets;\n\n   gBytesRead += actual_pos;\n\n   if (gDebug > 0)\n      ErrorInfo(\"RootdGets: read %d bytes from file %s\",\n                actual_pos, gRdFile);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Receive a file from the remote client (upload).\n\nvoid RootdPutFile(const char *msg)\n{\n   char     file[kMAXPATHLEN];\n   Long64_t size, restartat;\n   int      blocksize, mode, forceopen = 0;\n\n   gFtp = 1;   // rootd is used for ftp instead of file serving\n\n   sscanf(msg, \"%s %d %d %lld %lld\", file, &blocksize, &mode, &size, &restartat);\n\n   if (file[0] == '-') {\n      forceopen = 1;\n      strlcpy(gRdFile, file+1, sizeof(gRdFile));\n   } else\n      strlcpy(gRdFile, file, sizeof(gRdFile));\n\n   // anon user may not overwrite existing files...\n   struct stat st;\n   if (!stat(gRdFile, &st)) {\n      if (gAnon) {\n         Error(Err, kErrFileExists, \"RootdPutFile: anonymous users may not overwrite existing file %s\", gRdFile);\n         return;\n      }\n   } else if (GetErrno() != ENOENT) {\n      Error(Err, kErrFatal, \"RootdPutFile: can't check for file presence\");\n      return;\n   }\n\n   // remove lock from file\n   if (restartat || forceopen)\n      RootdCloseTab(1);\n\n   // open local file\n   int fd;\n   if (!restartat) {\n\n      // make sure file exists so RootdCheckTab works correctly\n#ifndef WIN32\n      fd = SysOpen(gRdFile, O_RDWR | O_CREAT, 0600);\n#else\n      fd = SysOpen(gRdFile, O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);\n#endif\n      if (fd < 0) {\n         Error(Err, kErrFileOpen, \"RootdPutFile: cannot open file %s\", gRdFile);\n         return;\n      }\n\n      close(fd);\n\n      // check if file is not in use by somebody and prevent from somebody\n      // using it before upload is completed\n      if (!RootdCheckTab(1)) {\n         Error(Err, kErrFileWriteOpen, \"RootdPutFile: file %s already opened in read or write mode\", gRdFile);\n         return;\n      }\n\n#ifndef WIN32\n      fd = SysOpen(gRdFile, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n#else\n      if (mode == kBinary)\n         fd = SysOpen(gRdFile, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY,\n                      S_IREAD | S_IWRITE);\n      else\n         fd = SysOpen(gRdFile, O_CREAT | O_TRUNC | O_WRONLY,\n                      S_IREAD | S_IWRITE);\n#endif\n   } else {\n#ifndef WIN32\n      fd = SysOpen(gRdFile, O_WRONLY, 0600);\n#else\n      if (mode == kBinary)\n         fd = SysOpen(gRdFile, O_WRONLY | O_BINARY, S_IREAD | S_IWRITE);\n      else\n         fd = SysOpen(gRdFile, O_WRONLY, S_IREAD | S_IWRITE);\n#endif\n      if (fd < 0) {\n         Error(Err, kErrFileOpen, \"RootdPutFile: cannot open file %s\", gRdFile);\n         return;\n      }\n      if (!RootdCheckTab(1)) {\n         close(fd);\n         Error(Err, kErrFileWriteOpen, \"RootdPutFile: file %s already opened in read or write mode\", gRdFile);\n         return;\n      }\n   }\n\n   // check file system space\n   if (strcmp(gRdFile, \"/dev/null\")) {\n      struct statfs statfsbuf;\n#if defined(__sgi) || (defined(__sun) && !defined(linux))\n      if (fstatfs(fd, &statfsbuf, sizeof(struct statfs), 0) == 0) {\n         Long64_t space = (Long64_t)statfsbuf.f_bsize * (Long64_t)statfsbuf.f_bfree;\n#else\n      if (fstatfs(fd, &statfsbuf) == 0) {\n         Long64_t space = (Long64_t)statfsbuf.f_bsize * (Long64_t)statfsbuf.f_bavail;\n#endif\n         if (space < size - restartat) {\n            Error(Err, kErrNoSpace, \"RootdPutFile: not enough space to store file %s\", gRdFile);\n            close(fd);\n            return;\n         }\n      }\n   }\n\n   // seek to restartat position\n   if (restartat) {\n#if defined(R__SEEK64)\n      if (lseek64(fd, restartat, SEEK_SET) < 0) {\n#elif defined(WIN32)\n      if (_lseeki64(fd, restartat, SEEK_SET) < 0) {\n#else\n      if (lseek(fd, restartat, SEEK_SET) < 0) {\n#endif\n         Error(Err, kErrRestartSeek, \"RootdPutFile: cannot seek to position %lld in file %s\",\n               restartat, gRdFile);\n         close(fd);\n         return;\n      }\n   }\n\n   // setup ok\n   NetSend(0, kROOTD_PUTFILE);\n\n   struct timeval started, ended;\n   gettimeofday(&started, 0);\n\n   char *buf = new char[blocksize];\n   char *buf2 = 0;\n   if (mode == 1)\n      buf2 = new char[blocksize];\n\n   Long64_t pos = restartat & ~(blocksize-1);\n   int skip = restartat - pos;\n\n   while (pos < size) {\n      Long64_t left = Long64_t(size - pos);\n      if (left > blocksize)\n         left = blocksize;\n\n      NetRecvRaw(buf, int(left-skip));\n\n      int n = int(left-skip);\n\n      // in case of ascii file, loop here over buffer and remove \\r's\n      ssize_t siz;\n      if (mode == kAscii) {\n         int i = 0, j = 0;\n         while (i < n) {\n            if (buf[i] == '\\r')\n               i++;\n            else\n               buf2[j++] = buf[i++];\n         }\n         n = j;\n         while ((siz = write(fd, buf2, n)) < 0 && GetErrno() == EINTR)\n            ResetErrno();\n      } else {\n         while ((siz = write(fd, buf, n)) < 0 && GetErrno() == EINTR)\n            ResetErrno();\n      }\n\n      if (siz < 0)\n         Error(ErrSys, kErrFilePut, \"RootdPutFile: error writing to file %s\", gRdFile);\n\n      if (siz != n)\n         Error(ErrFatal, kErrFilePut, \"RootdPutFile: error writing all requested bytes to file %s, wrote %d of %d\",\n               gRdFile, siz, int(left-skip));\n\n      gBytesWritten += n;\n\n      pos += left;\n      skip = 0;\n   }\n\n   gettimeofday(&ended, 0);\n\n   // file stored ok\n   NetSend(0, kROOTD_PUTFILE);\n\n   delete [] buf; delete [] buf2;\n\n   fchmod(fd, 0644);\n\n   close(fd);\n\n   RootdCloseTab();\n\n   gUploaded++;\n\n   double speed, t;\n   t = (ended.tv_sec + ended.tv_usec / 1000000.0) -\n       (started.tv_sec + started.tv_usec / 1000000.0);\n   if (t > 0)\n      speed = double(size - restartat) / t;\n   else\n      speed = 0.0;\n   if (speed > 524288)\n      ErrorInfo(\"RootdPutFile: uploaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Mbytes/s)\", gRdFile, size, t, speed / 1048576);\n   else if (speed > 512)\n      ErrorInfo(\"RootdPutFile: uploaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Kbytes/s)\", gRdFile, size, t, speed / 1024);\n   else\n      ErrorInfo(\"RootdPutFile: uploaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f bytes/s)\", gRdFile, size, t, speed);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Send a file to a remote client (download).\n\nvoid RootdGetFile(const char *msg)\n{\n   char     file[kMAXPATHLEN];\n   Long64_t restartat;\n   int      blocksize, mode, forceopen = 0;\n\n   gFtp = 1;   // rootd is used for ftp instead of file serving\n\n   sscanf(msg, \"%s %d %d %lld\", file, &blocksize, &mode, &restartat);\n\n   if (file[0] == '-') {\n      forceopen = 1;\n      strlcpy(gRdFile, file+1, sizeof(gRdFile));\n   } else\n      strlcpy(gRdFile, file, sizeof(gRdFile));\n\n   // remove lock from file\n   if (forceopen)\n      RootdCloseTab(1);\n\n   // open file for reading\n#if defined(WIN32) || defined(R__WINGCC)\n   int fd = SysOpen(gRdFile, O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);\n#else\n   int fd = SysOpen(gRdFile, O_RDONLY, 0600);\n#endif\n   if (fd < 0) {\n      Error(Err, kErrFileOpen, \"RootdGetFile: cannot open file %s\", gRdFile);\n      return;\n   }\n\n   // check if file is not in use by somebody and prevent from somebody\n   // using it before download is completed\n   if (!RootdCheckTab(0)) {\n      close(fd);\n      Error(Err, kErrFileOpen, \"RootdGetFile: file %s is already open in write mode\", gRdFile);\n      return;\n   }\n\n#if defined(R__SEEK64)\n   struct stat64 st;\n   if (fstat64(fd, &st)) {\n#elif defined(WIN32)\n   struct _stati64 st;\n   if (_fstati64(fd, &st)) {\n#else\n   struct stat st;\n   if (fstat(fd, &st)) {\n#endif\n      Error(Err, kErrFatal, \"RootdGetFile: cannot get size of file %s\", gRdFile);\n      close(fd);\n      return;\n   }\n   Long64_t size = st.st_size;\n\n   if (!S_ISREG(st.st_mode)) {\n      Error(Err, kErrBadFile, \"RoodGetFile: not a regular file %s\", gRdFile);\n      close(fd);\n      return;\n   }\n\n   // check if restartat value makes sense\n   if (restartat && (restartat >= size))\n      restartat = 0;\n\n   // setup ok\n   NetSend(0, kROOTD_GETFILE);\n\n   char mess[128];\n   SPrintf(mess, 128, \"%lld\", size);\n   NetSend(mess, kROOTD_GETFILE);\n\n   struct timeval started, ended;\n   gettimeofday(&started, 0);\n\n   Long64_t pos  = restartat & ~(blocksize-1);\n   int  skip = int(restartat - pos);\n\n#ifndef HAVE_MMAP\n   char *buf = new char[blocksize];\n#if defined(R__SEEK64)\n   lseek64(fd, pos, SEEK_SET);\n#elif defined(WIN32)\n   _lseeki64(fd, pos, SEEK_SET);\n#else\n   lseek(fd, pos, SEEK_SET);\n#endif\n#endif\n\n   while (pos < size) {\n      Long64_t left = size - pos;\n      if (left > blocksize)\n         left = blocksize;\n#ifdef HAVE_MMAP\n#if defined(R__SEEK64)\n      char *buf = (char*) mmap64(0, left, PROT_READ, MAP_FILE | MAP_SHARED, fd, pos);\n#else\n      char *buf = (char*) mmap(0, left, PROT_READ, MAP_FILE | MAP_SHARED, fd, pos);\n#endif\n      if (buf == (char *) -1)\n         Error(ErrFatal, kErrFileGet, \"RootdGetFile: mmap of file %s failed\", gRdFile);\n#else\n      int siz;\n      while ((siz = read(fd, buf, (int)left)) < 0 && GetErrno() == EINTR)\n         ResetErrno();\n      if (siz < 0 || siz != left)\n         Error(ErrFatal, kErrFileGet, \"RootdGetFile: error reading from file %s\", gRdFile);\n#endif\n\n      NetSendRaw(buf+skip, int(left-skip));\n\n      gBytesRead += left-skip;\n\n      pos += left;\n      skip = 0;\n\n#ifdef HAVE_MMAP\n      munmap(buf, left);\n#endif\n   }\n\n   gettimeofday(&ended, 0);\n\n#ifndef HAVE_MMAP\n   delete [] buf;\n#endif\n\n   close(fd);\n\n   RootdCloseTab();\n\n   gDownloaded++;\n\n   double speed, t;\n   t = (ended.tv_sec + ended.tv_usec / 1000000.0) -\n       (started.tv_sec + started.tv_usec / 1000000.0);\n   if (t > 0)\n      speed = double(size - restartat) / t;\n   else\n      speed = 0.0;\n   if (speed > 524288)\n      ErrorInfo(\"RootdGetFile: downloaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Mbytes/s)\", gRdFile, size, t, speed / 1048576);\n   else if (speed > 512)\n      ErrorInfo(\"RootdGetFile: downloaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f Kbytes/s)\", gRdFile, size, t, speed / 1024);\n   else\n      ErrorInfo(\"RootdGetFile: downloaded file %s (%lld bytes, %.3f seconds, \"\n                \"%.2f bytes/s)\", gRdFile, size, t, speed);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Change directory.\n\nvoid RootdChdir(const char *dir)\n{\n   const int kMAXBUFLEN = kMAXPATHLEN + 256;\n   char buffer[kMAXBUFLEN];\n\n   if (dir && *dir == '~') {\n      struct passwd *pw;\n      int i = 0;\n      const char *p = dir;\n\n      p++;\n      while (*p && *p != '/')\n         buffer[i++] = *p++;\n      buffer[i] = 0;\n\n      if ((pw = getpwnam(i ? buffer : gUser.c_str())))\n         SPrintf(buffer, kMAXBUFLEN, \"%s%s\", pw->pw_dir, p);\n      else\n         *buffer = 0;\n   } else\n      *buffer = 0;\n\n   if (chdir(*buffer ? buffer : (dir && *dir ? dir : \"/\")) == -1) {\n      SPrintf(buffer,kMAXBUFLEN,\"cannot change directory to %s\",dir);\n      Perror(buffer,kMAXBUFLEN);\n      NetSend(buffer, kROOTD_CHDIR);\n      return;\n   } else {\n      FILE *msg;\n\n      if ((msg = fopen(\".message\", \"r\"))) {\n         int len = fread(buffer, 1, kMAXPATHLEN, msg);\n         fclose(msg);\n         if (len > 0 && len < 1024) {\n            buffer[len] = 0;\n            NetSend(buffer, kMESS_STRING);\n         }\n      }\n\n      if (!getcwd(buffer, kMAXPATHLEN)) {\n         if (dir && *dir == '/')\n            SPrintf(buffer, kMAXBUFLEN, \"%s\", dir);\n      }\n      NetSend(buffer, kROOTD_CHDIR);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Test access permission on path\n\nvoid RootdAccess(const char *buf)\n{\n   char buffer[kMAXPATHLEN];\n   char path[kMAXPATHLEN];\n   int mode = F_OK; // if not told otherwise, check for file access.\n\n   int nw = 0;\n   if (buf)\n      nw = sscanf(buf,\"%s %d\",path,&mode);\n\n   if (nw >= 2) {\n\n      char *epath = &path[0];\n      if (path[0] == '/' && path[1] == '/')\n         epath = &path[1];\n\n      if (access(epath, mode) == -1) {\n         SPrintf(buffer,kMAXPATHLEN,\"cannot stat %s\",epath);\n         Perror(buffer);\n         ErrorInfo(\"RootdAccess: %s\", buffer);\n      } else\n         SPrintf(buffer,kMAXPATHLEN,\"OK\");\n\n   } else {\n      SPrintf(buffer,kMAXPATHLEN,\"bad input format %s\",buf);\n      ErrorInfo(\"RootdAccess: %s\", buffer);\n   }\n\n   NetSend(buffer, kROOTD_ACCESS);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Free open directory.\n\nvoid RootdFreeDir()\n{\n   char buffer[kMAXPATHLEN];\n\n   if (!gRDDirectory) {\n      SPrintf(buffer,kMAXPATHLEN,\"no directory open\");\n      ErrorInfo(\"RootdFreeDir: %s\", buffer);\n   } else if (closedir(gRDDirectory) == -1) {\n      SPrintf(buffer,kMAXPATHLEN,\"cannot free open directory\");\n      Perror(buffer);\n      ErrorInfo(\"RootdFreeDir: %s\", buffer);\n   } else\n      SPrintf(buffer,kMAXPATHLEN,\"open directory freed\");\n\n   NetSend(buffer, kROOTD_FREEDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get directory entry.\n\nvoid RootdGetDirEntry()\n{\n   char buffer[kMAXPATHLEN];\n   struct dirent *dp = 0;\n\n   if (!gRDDirectory) {\n      SPrintf(buffer,kMAXPATHLEN,\"no directory open\");\n      ErrorInfo(\"RootdGetDirEntry: %s\", buffer);\n   } else if ((dp = readdir(gRDDirectory)) == 0) {\n      if (GetErrno() == EBADF) {\n         SPrintf(buffer,kMAXPATHLEN,\"cannot read open directory\");\n         Perror(buffer);\n         ErrorInfo(\"RootdGetDirEntry: %s\", buffer);\n      } else\n         SPrintf(buffer,kMAXPATHLEN,\"no more entries\");\n   } else {\n      SPrintf(buffer,kMAXPATHLEN,\"OK:%s\",dp->d_name);\n   }\n\n   NetSend(buffer, kROOTD_DIRENTRY);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Open directory.\n\nvoid RootdOpenDir(const char *dir)\n{\n   char buffer[kMAXPATHLEN];\n\n   char *edir = (char *)dir;\n   if (dir[0] == '/' && dir[1] == '/')\n      edir++;\n\n   if ((gRDDirectory = opendir(edir)) == 0) {\n      SPrintf(buffer,kMAXPATHLEN,\"cannot open directory %s\",edir);\n      Perror(buffer);\n      ErrorInfo(\"RootdOpenDir: %s\", buffer);\n   } else\n      SPrintf(buffer,kMAXPATHLEN,\"OK: directory %s open\",edir);\n\n   NetSend(buffer, kROOTD_OPENDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Make directory.\n\nvoid RootdMkdir(const char *fdir)\n{\n   char buffer[kMAXPATHLEN];\n\n   char *dir = (char *)fdir;\n   if (fdir[0] == '/' && fdir[1] == '/')\n      dir++;\n\n   if (gAnon) {\n      SPrintf(buffer,kMAXPATHLEN,\n              \"anonymous users may not create directories\");\n      ErrorInfo(\"RootdMkdir: %s\", buffer);\n   } else if (mkdir(dir, 0755) < 0) {\n      SPrintf(buffer,kMAXPATHLEN,\"cannot create directory %s\",dir);\n      Perror(buffer);\n      ErrorInfo(\"RootdMkdir: %s\", buffer);\n   } else\n      SPrintf(buffer,kMAXPATHLEN,\"OK: created directory %s\",dir);\n\n   NetSend(buffer, kROOTD_MKDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete directory.\n\nvoid RootdRmdir(const char *fdir)\n{\n   char buffer[kMAXPATHLEN];\n\n   char *dir = (char *)fdir;\n   if (fdir[0] == '/' && fdir[1] == '/')\n      dir++;\n\n   if (gAnon) {\n      SPrintf(buffer,kMAXPATHLEN,\n              \"anonymous users may not delete directories\");\n      ErrorInfo(\"RootdRmdir: %s\", buffer);\n   } else if (rmdir(dir) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot delete directory %s\", dir);\n      Perror(buffer);\n      ErrorInfo(\"RootdRmdir: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"deleted directory %s\", dir);\n\n   NetSend(buffer, kROOTD_RMDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// List directory.\n\nvoid RootdLsdir(const char *cmd)\n{\n   char buffer[kMAXPATHLEN];\n\n   // make sure all commands start with ls (should use snprintf)\n   if (gAnon) {\n      if (strlen(cmd) < 2 || strncmp(cmd, \"ls\", 2))\n         SPrintf(buffer, kMAXPATHLEN, \"ls %s\", cmd);\n      else\n         SPrintf(buffer, kMAXPATHLEN, \"%s\", cmd);\n   } else {\n      if (strlen(cmd) < 2 || strncmp(cmd, \"ls\", 2))\n         SPrintf(buffer, kMAXPATHLEN, \"ls %s 2>/dev/null\", cmd);\n      else\n         SPrintf(buffer, kMAXPATHLEN, \"%s 2>/dev/null\", cmd);\n   }\n\n   FILE *pf;\n   if ((pf = popen(buffer, \"r\")) == 0) {\n      SPrintf(buffer,kMAXPATHLEN, \"error in popen\");\n      Perror(buffer);\n      NetSend(buffer, kROOTD_LSDIR);\n      ErrorInfo(\"RootdLsdir: %s\", buffer);\n      return;\n   }\n\n   // read output of ls\n   int  ch, i = 0, cnt = 0;\n//again:\n   for (ch = fgetc(pf); ch != EOF; ch = fgetc(pf)) {\n      buffer[i++] = ch;\n      cnt++;\n      if (i == kMAXPATHLEN-1) {\n         buffer[i] = 0;\n         NetSend(buffer, kMESS_STRING);\n         i = 0;\n      }\n   }\n   // this will be true if forked process was not yet ready to be read\n//   if (cnt == 0 && ch == EOF) goto again;\n\n   pclose(pf);\n\n   buffer[i] = 0;\n   NetSend(buffer, kROOTD_LSDIR);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Print path of working directory.\n\nvoid RootdPwd()\n{\n   char buffer[kMAXPATHLEN];\n\n   if (!getcwd(buffer, kMAXPATHLEN)) {\n      SPrintf(buffer, kMAXPATHLEN, \"current directory not readable\");\n      Perror(buffer);\n      ErrorInfo(\"RootdPwd: %s\", buffer);\n   }\n\n   NetSend(buffer, kROOTD_PWD);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Rename a file.\n\nvoid RootdMv(const char *msg)\n{\n   char file1[kMAXPATHLEN], file2[kMAXPATHLEN], buffer[kMAXPATHLEN];\n   sscanf(msg, \"%s %s\", file1, file2);\n\n   if (gAnon) {\n      SPrintf(buffer, kMAXPATHLEN, \"anonymous users may not rename files\");\n      ErrorInfo(\"RootdMv: %s\", buffer);\n   } else if (rename(file1, file2) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot rename file %s to %s\",\n              file1, file2);\n      Perror(buffer);\n      ErrorInfo(\"RootdMv: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"renamed file %s to %s\",\n              file1, file2);\n\n   NetSend(buffer, kROOTD_MV);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete a file.\n\nvoid RootdRm(const char *file)\n{\n   char buffer[kMAXPATHLEN];\n\n   if (gAnon) {\n      SPrintf(buffer, kMAXPATHLEN, \"anonymous users may not delete files\");\n      ErrorInfo(\"RootdRm: %s\", buffer);\n   } else if (unlink(file) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot unlink file %s\", file);\n      Perror(buffer);\n      ErrorInfo(\"RootdRm: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"removed file %s\", file);\n\n   NetSend(buffer, kROOTD_RM);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete a file.\n\nvoid RootdChmod(const char *msg)\n{\n   char file[kMAXPATHLEN], buffer[kMAXPATHLEN];\n   int  mode;\n\n   sscanf(msg, \"%s %d\", file, &mode);\n\n   if (gAnon) {\n      SPrintf(buffer, kMAXPATHLEN,\n              \"anonymous users may not change file permissions\");\n      ErrorInfo(\"RootdChmod: %s\", buffer);\n   } else if (chmod(file, mode) < 0) {\n      SPrintf(buffer, kMAXPATHLEN, \"cannot chmod file %s to 0%o\", file, mode);\n      Perror(buffer);\n      ErrorInfo(\"RootdChmod: %s\", buffer);\n   } else\n      SPrintf(buffer, kMAXPATHLEN, \"changed permission of file %s to 0%o\",\n              file, mode);\n\n   NetSend(buffer, kROOTD_CHMOD);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Termination upon receipt of a SIGTERM or SIGINT.\n\nstatic void RootdTerm(int)\n{\n   ErrorInfo(\"RootdTerm: rootd.cxx: got a SIGTERM/SIGINT\");\n   // Terminate properly\n   RpdAuthCleanup(0,0);\n   // Close network connection\n   NetClose();\n   // exit\n   exit(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Handle all rootd commands. Returns after file close command.\n\nvoid RootdLoop()\n{\n   char recvbuf[kMAXRECVBUF];\n   EMessageTypes kind;\n\n//#define R__ROOTDDBG\n#ifdef R__ROOTDDBG\n   int debug = 1;\n   while (debug)\n      ;\n#endif\n\n   // Check if we will go for parallel sockets\n   // (in early days was done before entering main loop)\n   if (gClientProtocol > 9)\n      RootdParallel();\n\n   // Main loop\n   while (1) {\n\n      if (NetRecv(recvbuf, kMAXRECVBUF, kind) < 0)\n         Error(ErrFatal, kErrFatal, \"RootdLoop: error receiving message\");\n\n      if (gDebug > 2 && kind != kROOTD_PASS)\n         ErrorInfo(\"RootdLoop: kind:%d -- buf:'%s' (len:%d)\",\n                   kind, recvbuf, strlen(recvbuf));\n\n      switch (kind) {\n         case kROOTD_OPEN:\n            RootdOpen(recvbuf);\n            break;\n         case kROOTD_PUT:\n            RootdPut(recvbuf);\n            break;\n         case kROOTD_GET:\n            RootdGet(recvbuf);\n            break;\n         case kROOTD_GETS:\n            RootdGets(recvbuf);\n            break;\n         case kROOTD_FLUSH:\n            RootdFlush();\n            break;\n         case kROOTD_CLOSE:\n            RootdClose();\n            if (gClientProtocol < 7)\n               return;\n            break;\n         case kROOTD_FSTAT:\n            RootdFstat(recvbuf);\n            break;\n         case kROOTD_STAT:\n            RootdStat();\n            break;\n         case kROOTD_PUTFILE:\n            RootdPutFile(recvbuf);\n            break;\n         case kROOTD_GETFILE:\n            RootdGetFile(recvbuf);\n            break;\n         case kROOTD_CHDIR:\n            RootdChdir(recvbuf);\n            break;\n         case kROOTD_MKDIR:\n            RootdMkdir(recvbuf);\n            break;\n         case kROOTD_RMDIR:\n            RootdRmdir(recvbuf);\n            break;\n         case kROOTD_LSDIR:\n            RootdLsdir(recvbuf);\n            break;\n         case kROOTD_PWD:\n            RootdPwd();\n            break;\n         case kROOTD_MV:\n            RootdMv(recvbuf);\n            break;\n         case kROOTD_RM:\n            RootdRm(recvbuf);\n            break;\n         case kROOTD_CHMOD:\n            RootdChmod(recvbuf);\n            break;\n         case kROOTD_OPENDIR:\n            RootdOpenDir(recvbuf);\n            break;\n         case kROOTD_FREEDIR:\n            RootdFreeDir();\n            break;\n         case kROOTD_DIRENTRY:\n            RootdGetDirEntry();\n            break;\n         case kROOTD_ACCESS:\n            RootdAccess(recvbuf);\n            break;\n         case kROOTD_BYE:\n            return;\n         default:\n            Error(ErrFatal, kErrBadOp, \"RootdLoop: received bad opcode %d\", kind);\n      }\n      continue;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid Usage(const char* name, int rc)\n{\n   fprintf(stderr, \"\\nUsage: %s [options] [rootsys-dir]\\n\", name);\n   fprintf(stderr, \"\\nOptions:\\n\");\n   fprintf(stderr, \"\\t-b tcpwindowsize  Specify the tcp window size in bytes\\n\");\n#ifdef R__GLBS\n   fprintf(stderr, \"\\t-C hostcertfile   Specify the location of the Globus host certificate\\n\");\n#endif\n   fprintf(stderr, \"\\t-d level          set debug level [0..3]\\n\");\n   fprintf(stderr, \"\\t-D rootdaemonrc   Use alternate rootdaemonrc file\\n\");\n   fprintf(stderr, \"\\t                  (see documentation)\\n\");\n   fprintf(stderr, \"\\t-E                Ignored for backward compatibility\\n\");\n   fprintf(stderr, \"\\t-f                Run in foreground\\n\");\n#ifdef R__GLBS\n   fprintf(stderr, \"\\t-G gridmapfile    Specify the location of th Globus gridmap\\n\");\n#endif\n   fprintf(stderr, \"\\t-i                Running from inetd\\n\");\n   fprintf(stderr, \"\\t-noauth           Do not require client authentication\\n\");\n   fprintf(stderr, \"\\t-p port#          Specify a different port to listen on\\n\");\n   fprintf(stderr, \"\\t-P pwfile         Use pwfile instead of .srootdpass\\n\");\n   fprintf(stderr, \"\\t-r                Files can only be opened in read-only mode\\n\");\n   fprintf(stderr, \"\\t-R bitmask        Bitmask specifies which methods allow authentication re-use\\n\");\n   fprintf(stderr, \"\\t-s sshd_port#     Specify the port for the sshd daemon\\n\");\n#ifdef R__KRB5\n   fprintf(stderr, \"\\t-S keytabfile     Use an alternate keytab file\\n\");\n#endif\n   fprintf(stderr, \"\\t-T <tmpdir>       Use an alternate temp dir\\n\");\n   fprintf(stderr, \"\\t-w                Do not check /etc/hosts.equiv and $HOME/.rhosts\\n\");\n\n   exit(rc);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char **argv)\n{\n   char *s;\n   int checkhostsequiv= 1;\n   int requireauth    = 1;\n   int tcpwindowsize  = 65535;\n   int sshdport       = 22;\n   int port1          = 0;\n   int port2          = 0;\n   int reuseallow     = 0x1F;\n   int login          = 2; // form rootd we fully login users, by default\n   int foregroundflag = 0;\n   std::string tmpdir = \"\";\n   std::string confdir = \"\";\n   std::string rootbindir = \"\";\n   std::string altSRPpass = \"\";\n   std::string daemonrc = \"\";\n   std::string rootetcdir = \"\";\n#ifdef R__GLBS\n   std::string gridmap = \"\";\n   std::string hostcertconf = \"\";\n#endif\n   char *progname = argv[0];\n\n   // Init error handlers\n   RpdSetErrorHandler(Err, ErrSys, ErrFatal);\n\n   // function for dealing with SIGPIPE signals\n   // (used by NetSetOptions() in rpdutils/net.cxx)\n   NetSetSigPipeHook(SigPipe);\n\n   // Init syslog\n   ErrorInit(argv[0]);\n\n   // Output to syslog ...\n   RpdSetSysLogFlag(1);\n\n   // ... unless we are running in the foreground and we are\n   // attached to terminal; make also sure that \"-i\" and \"-f\"\n   // are not simultaneously specified\n   int i = 1;\n   for (i = 1; i < argc; i++) {\n      if (!strncmp(argv[i],\"-f\",2))\n         foregroundflag = 1;\n      if (!strncmp(argv[i],\"-i\",2))\n         gInetdFlag = 1;\n   }\n   if (foregroundflag) {\n      if (isatty(0) && isatty(1)) {\n         RpdSetSysLogFlag(0);\n         ErrorInfo(\"main: running in foreground mode:\"\n                   \" sending output to stderr\");\n      }\n      if (gInetdFlag)\n         Error(ErrFatal,-1,\"-i and -f options are incompatible\");\n   }\n\n   // To terminate correctly ... maybe not needed\n   signal(SIGTERM, RootdTerm);\n   signal(SIGINT, RootdTerm);\n\n   char *tmp = RootdExpandPathName(argv[0]);\n   if (tmp) {\n      int p = strlen(tmp)-1;\n      while ((p+1) && tmp[p] != '/')\n         p--;\n      if (p+1) {\n         tmp[p] = '\\0';\n         rootbindir = std::string(tmp);\n         while ((p+1) && tmp[p] != '/')\n            p--;\n         if (p+1) {\n            tmp[p] = '\\0';\n            confdir = std::string(tmp);\n         }\n      }\n      free(tmp);\n   }\n\n   while (--argc > 0 && (*++argv)[0] == '-')\n      for (s = argv[0]+1; *s != 0; s++)\n         switch (*s) {\n\n            case 'b':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-b requires a buffersize in bytes\"\n                                    \" as argument\");\n               }\n               tcpwindowsize = atoi(*++argv);\n               break;\n#ifdef R__GLBS\n            case 'C':\n               if (--argc <= 0) {\n                  Error(ErrFatal, kErrFatal,\"-C requires a file name for\"\n                                    \" the host certificates file location\");\n               }\n               hostcertconf = std::string(*++argv);\n               break;\n#endif\n            case 'd':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-d requires a debug level as\"\n                                    \" argument\");\n               }\n               gDebug = atoi(*++argv);\n               break;\n\n            case 'D':\n               if (--argc <= 0) {\n                  Error(ErrFatal, kErrFatal,\"-D requires a file path name\"\n                                    \"  for the file defining access rules\");\n               }\n               daemonrc = std::string(*++argv);\n               break;\n\n            case 'E':\n               Error(ErrFatal, kErrFatal,\"Option '-E' is now dummy \"\n                          \"- ignored (see proofd/src/proofd.cxx for\"\n                          \" additional details)\");\n               break;\n\n            case 'f':\n               if (gInetdFlag) {\n                  Error(ErrFatal,-1,\"-i and -f options are incompatible\");\n               }\n               foregroundflag = 1;\n               break;\n\n            case 'F':\n               gCastorFlag = 1;\n               gInetdFlag  = 1;\n               reuseallow = 0x0; // No auth reuse for castor\n               login = 1; // No full logins for castor (user $HOMEs may not exist on servers)\n               if (--argc <= 0) {\n                  if (!gInetdFlag)\n                     fprintf(stderr,\"-F requires a file path name for the\"\n                             \" CASTOR disk file to be accessed\\n\");\n                  Error(ErrFatal, kErrFatal,\"-F requires a file path name\"\n                        \" for the CASTOR disk file to be accessed\");\n               }\n               gCastorFile = std::string(*++argv);\n               break;\n\n#ifdef R__GLBS\n            case 'G':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-G requires a file name for\"\n                                    \" the gridmap file\");\n               }\n               gridmap = std::string(*++argv);\n               break;\n#endif\n            case 'h':\n               Usage(progname, 0);\n               break;\n\n            case 'H':\n               if (--argc <= 0) {\n                  if (!gInetdFlag && !gCastorFlag)\n                     fprintf(stderr,\"-H requires the CASTOR request ID\");\n                  Error(ErrFatal, kErrFatal,\"-H requires the CASTOR request ID\");\n               }\n               gCastorReqId = std::string(*++argv);\n               break;\n\n            case 'i':\n               if (foregroundflag) {\n                  Error(ErrFatal,-1,\"-i and -f options are incompatible\");\n               }\n               gInetdFlag = 1;\n               break;\n\n            case 'n':\n               if (!strncmp(argv[0]+1,\"noauth\",6)) {\n                  requireauth = 0;\n                  s += 5;\n               } else if (!strncmp(argv[0]+1,\"nologin\",7)) {\n                  login = 0;\n                  s += 6;\n               }\n               break;\n\n            case 'p':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-p requires a port number as\"\n                                    \" argument\");\n               }\n               char *p;\n               port1 = strtol(*++argv, &p, 10);\n               if (*p == '-') {\n                  p++;\n                  port2 = strtol(p, &p, 10);\n               } else if (*p == '\\0')\n                  port2 = port1;\n               if (*p != '\\0' || port2 < port1 || port2 < 0) {\n                  Error(ErrFatal,kErrFatal,\"invalid port number or range: %s\",\n                                     *argv);\n               }\n               break;\n\n            case 'P':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-P requires a file name for SRP\"\n                                    \" password file\");\n               }\n               altSRPpass = std::string(*++argv);\n               break;\n\n            case 'r':\n               gReadOnly = 1;\n               break;\n\n            case 'R':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-R requires a hex but mask as\"\n                                    \" argument\");\n               }\n               reuseallow = strtol(*++argv, (char **)0, 16);\n               break;\n\n            case 's':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-s requires as argument a port\"\n                                    \" number for the sshd daemon\");\n               }\n               sshdport = atoi(*++argv);\n               break;\n#ifdef R__KRB5\n            case 'S':\n               if (--argc <= 0) {\n                  Error(ErrFatal,kErrFatal,\"-S requires a path to your\"\n                                    \" keytab\\n\");\n               }\n               RpdSetKeytabFile((const char *)(*++argv));\n               break;\n#endif\n            case 'T':\n               if (--argc <= 0) {\n                  Error(ErrFatal, kErrFatal,\"-T requires a dir path for\"\n                                    \" temporary files [/usr/tmp]\");\n               }\n               tmpdir = std::string(*++argv);\n               break;\n\n            case 'w':\n               checkhostsequiv = 0;\n               break;\n\n            default:\n               if (!foregroundflag) fprintf(stderr, \"\\nUnknown command line option: %c\\n\", *s);\n               Error(0, -1, \"unknown command line option: %c\", *s);\n               Usage(progname, 1);\n         }\n\n   // dir for temporary files\n   if (!tmpdir.length())\n      tmpdir = std::string(\"/usr/tmp\");\n   if (access(tmpdir.c_str(), W_OK) == -1)\n      tmpdir = std::string(\"/tmp\");\n\n   // root tab file\n   gRootdTab = std::string(tmpdir).append(\"/rootdtab\");\n\n   if (argc > 0) {\n      confdir = std::string(*argv);\n   }\n\n#ifdef ROOTPREFIX\n   if (getenv(\"IGNOREROOTPREFIX\")) {\n#endif\n      if (!confdir.length()) {\n         // try to guess the config directory...\n         if (getenv(\"ROOTSYS\")) {\n            confdir = getenv(\"ROOTSYS\");\n            if (gDebug > 0)\n               ErrorInfo(\"main: no config directory specified using\"\n                         \" ROOTSYS (%s)\", confdir.c_str());\n         } else {\n            if (gDebug > 0)\n               ErrorInfo(\"main: no config directory specified\");\n         }\n      }\n      rootbindir = std::string(confdir).append(\"/bin\");\n      rootetcdir = std::string(confdir).append(\"/etc\");\n#ifdef ROOTPREFIX\n   }\n   else {\n      if (!confdir.length())\n         confdir = ROOTPREFIX;\n      rootbindir = ROOTBINDIR;\n      rootetcdir = ROOTETCDIR;\n   }\n#endif\n\n   // Make rootbindir available to all the session via env\n   if (rootbindir.length()) {\n      char *tmp1 = new char[15 + rootbindir.length()];\n      sprintf(tmp1, \"ROOTBINDIR=%s\", rootbindir.c_str());\n      putenv(tmp1);\n   }\n\n   // Make rootetcdir available to all the session via env\n   if (rootetcdir.length()) {\n      char *tmp1 = new char[15 + rootetcdir.length()];\n      sprintf(tmp1, \"ROOTETCDIR=%s\", rootetcdir.c_str());\n      putenv(tmp1);\n   }\n\n   // If specified, set the special daemonrc file to be used\n   if (daemonrc.length()) {\n      char *tmp1 = new char[15+daemonrc.length()];\n      sprintf(tmp1, \"ROOTDAEMONRC=%s\", daemonrc.c_str());\n      putenv(tmp1);\n   }\n#ifdef R__GLBS\n   // If specified, set the special gridmap file to be used\n   if (gridmap.length()) {\n      char *tmp1 = new char[15+gridmap.length()];\n      sprintf(tmp1, \"GRIDMAP=%s\", gridmap.c_str());\n      putenv(tmp1);\n   }\n   // If specified, set the special hostcert.conf file to be used\n   if (hostcertconf.length()) {\n      char *tmp1 = new char[15+hostcertconf.length()];\n      sprintf(tmp1, \"ROOTHOSTCERT=%s\", hostcertconf.c_str());\n      putenv(tmp1);\n   }\n#endif\n\n   // Parent ID\n   int rootdparentid = -1;      // Parent process ID\n   if (!gInetdFlag)\n      rootdparentid = getpid(); // Identifies this family\n   else\n      rootdparentid = getppid(); // Identifies this family\n\n   // default job options\n   unsigned int options = kDMN_RQAUTH | kDMN_HOSTEQ | kDMN_SYSLOG;\n   // modify them if required\n   if (!requireauth)\n      options &= ~kDMN_RQAUTH;\n   if (!checkhostsequiv)\n      options &= ~kDMN_HOSTEQ;\n   if (foregroundflag)\n      options &= ~kDMN_SYSLOG;\n   RpdInit(gService, rootdparentid, gProtocol, options,\n           reuseallow, sshdport,\n           tmpdir.c_str(),altSRPpass.c_str(),login);\n\n   // Generate Local RSA keys for the session\n   if (RpdGenRSAKeys(0)) {\n      Error(Err, -1, \"rootd: unable to generate local RSA keys\");\n   }\n\n   if (!gInetdFlag) {\n\n      // Start rootd up as a daemon process (in the background).\n      // Also initialize the network connection - create the socket\n      // and bind our well-know address to it.\n\n      int fdkeep = NetInit(gService, port1, port2, tcpwindowsize);\n      if (!foregroundflag)\n         DaemonStart(1, fdkeep, gService);\n   }\n\n   if (gDebug > 0)\n      ErrorInfo(\"main: pid = %d, ppid = %d, gInetdFlag = %d, gProtocol = %d\",\n                getpid(), getppid(), gInetdFlag, gProtocol);\n\n   // Concurrent server loop.\n   // The child created by NetOpen() handles the client's request.\n   // The parent waits for another request. In the inetd case,\n   // the parent from NetOpen() never returns.\n\n   while (1) {\n\n      if (NetOpen(gInetdFlag, gService) == 0) {\n\n         // Init Session (get protocol, run authentication, login, ...)\n         int rci = RpdInitSession(gService, gUser,\n                                  gClientProtocol, gAnon, gPasswd);\n         if (rci == -1)\n            Error(ErrFatal, -1, \"rootd: failure initializing session\");\n         else if (rci == -2)\n            // Special session (eg. cleanup): just exit\n            exit(0);\n\n         ErrorInfo(\"main: rootdparentid = %d (%d)\", rootdparentid, getppid());\n\n         // RootdParallel is called after authentication in RootdLogin\n         RootdLoop();      // child processes client's requests\n         NetClose();       // till we are done\n         exit(0);\n      }\n\n      // parent waits for another client to connect\n      // (except in CASTOR mode)\n      if (gCastorFlag) break;\n\n   }\n\n}\n"], "filenames": ["net/rootd/src/rootd.cxx"], "buggy_code_start_loc": [386], "buggy_code_end_loc": [540], "fixing_code_start_loc": [385], "fixing_code_end_loc": [616], "type": "CWE-78", "message": "ROOT version 6.9.03 and below is vulnerable to an authenticated shell metacharacter injection in the rootd daemon resulting in remote code execution", "other": {"cve": {"id": "CVE-2017-1000203", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-17T15:29:00.233", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ROOT version 6.9.03 and below is vulnerable to an authenticated shell metacharacter injection in the rootd daemon resulting in remote code execution"}, {"lang": "es", "value": "ROOT en versiones 6.9.03 y anteriores es vulnerable a una inyecci\u00f3n de metacaracteres shell con autenticaci\u00f3n en el demonio rootd que tiene como resultado una ejecuci\u00f3n remota de c\u00f3digo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cern:root:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.03", "matchCriteriaId": "75C36037-69F7-4A39-AC1C-DB3EFF6B60FB"}]}]}], "references": [{"url": "https://github.com/root-project/root/commit/88ccff152604e0f1012653a596d802ff7ede3145#diff-6cd6f6c31bac70116b7ca7abdc8e517e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/root-project/root/commit/88ccff152604e0f1012653a596d802ff7ede3145#diff-6cd6f6c31bac70116b7ca7abdc8e517e"}}