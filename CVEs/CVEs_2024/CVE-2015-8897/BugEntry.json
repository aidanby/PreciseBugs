{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%       TTTTT  RRRR    AAA   N   N  SSSSS  FFFFF   OOO   RRRR   M   M         %\n%         T    R   R  A   A  NN  N  SS     F      O   O  R   R  MM MM         %\n%         T    RRRR   AAAAA  N N N   SSS   FFF    O   O  RRRR   M M M         %\n%         T    R R    A   A  N  NN     SS  F      O   O  R R    M   M         %\n%         T    R  R   A   A  N   N  SSSSS  F       OOO   R  R   M   M         %\n%                                                                             %\n%                                                                             %\n%                    MagickCore Image Transform Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/transform.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A u t o O r i e n t I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AutoOrientImage() adjusts an image so that its orientation is suitable for\n%  viewing (i.e. top-left orientation).\n%\n%  The format of the AutoOrientImage method is:\n%\n%      Image *AutoOrientImage(const Image *image,\n%        const OrientationType orientation,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: The image.\n%\n%    o orientation: Current image orientation.\n%\n%    o exception: Return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AutoOrientImage(const Image *image,\n  const OrientationType orientation,ExceptionInfo *exception)\n{\n  Image\n    *orient_image;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  orient_image=(Image *) NULL;\n  switch(orientation)\n  {\n    case UndefinedOrientation:\n    case TopLeftOrientation:\n    default:\n    {\n      orient_image=CloneImage(image,0,0,MagickTrue,exception);\n      break;\n    }\n    case TopRightOrientation:\n    {\n      orient_image=FlopImage(image,exception);\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_image=RotateImage(image,180.0,exception);\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_image=FlipImage(image,exception);\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_image=TransposeImage(image,exception);\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_image=RotateImage(image,90.0,exception);\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_image=TransverseImage(image,exception);\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_image=RotateImage(image,270.0,exception);\n      break;\n    }\n  }\n  if (orient_image != (Image *) NULL)\n    orient_image->orientation=TopLeftOrientation;\n  return(orient_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C h o p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ChopImage() removes a region of an image and collapses the image to occupy\n%  the removed portion.\n%\n%  The format of the ChopImage method is:\n%\n%      Image *ChopImage(const Image *image,const RectangleInfo *chop_info)\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o chop_info: Define the region of the image to chop.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ChopImage(const Image *image,const RectangleInfo *chop_info,\n  ExceptionInfo *exception)\n{\n#define ChopImageTag  \"Chop/Image\"\n\n  CacheView\n    *chop_view,\n    *image_view;\n\n  Image\n    *chop_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    extent;\n\n  ssize_t\n    y;\n\n  /*\n    Check chop geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(chop_info != (RectangleInfo *) NULL);\n  if (((chop_info->x+(ssize_t) chop_info->width) < 0) ||\n      ((chop_info->y+(ssize_t) chop_info->height) < 0) ||\n      (chop_info->x > (ssize_t) image->columns) ||\n      (chop_info->y > (ssize_t) image->rows))\n    ThrowImageException(OptionWarning,\"GeometryDoesNotContainImage\");\n  extent=(*chop_info);\n  if ((extent.x+(ssize_t) extent.width) > (ssize_t) image->columns)\n    extent.width=(size_t) ((ssize_t) image->columns-extent.x);\n  if ((extent.y+(ssize_t) extent.height) > (ssize_t) image->rows)\n    extent.height=(size_t) ((ssize_t) image->rows-extent.y);\n  if (extent.x < 0)\n    {\n      extent.width-=(size_t) (-extent.x);\n      extent.x=0;\n    }\n  if (extent.y < 0)\n    {\n      extent.height-=(size_t) (-extent.y);\n      extent.y=0;\n    }\n  chop_image=CloneImage(image,image->columns-extent.width,image->rows-\n    extent.height,MagickTrue,exception);\n  if (chop_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Extract chop image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  chop_view=AcquireAuthenticCacheView(chop_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,chop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) extent.y; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(chop_view,0,y,chop_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((x < extent.x) || (x >= (ssize_t) (extent.x+extent.width)))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait chop_traits=GetPixelChannelTraits(chop_image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (chop_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(chop_image,channel,p[i],q);\n          }\n          q+=GetPixelChannels(chop_image);\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(chop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ChopImage)\n#endif\n        proceed=SetImageProgress(image,ChopImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  /*\n    Extract chop image.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,chop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) (image->rows-(extent.y+extent.height)); y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,extent.y+extent.height+y,\n      image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(chop_view,0,extent.y+y,chop_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((x < extent.x) || (x >= (ssize_t) (extent.x+extent.width)))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait chop_traits=GetPixelChannelTraits(chop_image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (chop_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(chop_image,channel,p[i],q);\n          }\n          q+=GetPixelChannels(chop_image);\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(chop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ChopImage)\n#endif\n        proceed=SetImageProgress(image,ChopImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  chop_view=DestroyCacheView(chop_view);\n  image_view=DestroyCacheView(image_view);\n  chop_image->type=image->type;\n  if (status == MagickFalse)\n    chop_image=DestroyImage(chop_image);\n  return(chop_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C o n s o l i d a t e C M Y K I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConsolidateCMYKImage() consolidates separate C, M, Y, and K planes into a\n%  single image.\n%\n%  The format of the ConsolidateCMYKImage method is:\n%\n%      Image *ConsolidateCMYKImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image sequence.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ConsolidateCMYKImages(const Image *images,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *cmyk_view,\n    *image_view;\n\n  Image\n    *cmyk_image,\n    *cmyk_images;\n\n  register ssize_t\n    j;\n\n  ssize_t\n    y;\n\n  /*\n    Consolidate separate C, M, Y, and K planes into a single image.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  cmyk_images=NewImageList();\n  for (j=0; j < (ssize_t) GetImageListLength(images); j+=4)\n  {\n    register ssize_t\n      i;\n\n    assert(images != (Image *) NULL);\n    cmyk_image=CloneImage(images,images->columns,images->rows,MagickTrue,\n      exception);\n    if (cmyk_image == (Image *) NULL)\n      break;\n    if (SetImageStorageClass(cmyk_image,DirectClass,exception) == MagickFalse)\n      break;\n    (void) SetImageColorspace(cmyk_image,CMYKColorspace,exception);\n    for (i=0; i < 4; i++)\n    {\n      image_view=AcquireVirtualCacheView(images,exception);\n      cmyk_view=AcquireAuthenticCacheView(cmyk_image,exception);\n      for (y=0; y < (ssize_t) images->rows; y++)\n      {\n        register const Quantum\n          *restrict p;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *restrict q;\n\n        p=GetCacheViewVirtualPixels(image_view,0,y,images->columns,1,exception);\n        q=QueueCacheViewAuthenticPixels(cmyk_view,0,y,cmyk_image->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) images->columns; x++)\n        {\n          Quantum\n            pixel;\n\n          pixel=QuantumRange-GetPixelIntensity(images,p);\n          switch (i)\n          {\n            case 0: SetPixelCyan(cmyk_image,pixel,q);  break;\n            case 1: SetPixelMagenta(cmyk_image,pixel,q);  break;\n            case 2: SetPixelYellow(cmyk_image,pixel,q);  break;\n            case 3: SetPixelBlack(cmyk_image,pixel,q);  break;\n            default: break;\n          }\n          p+=GetPixelChannels(images);\n          q+=GetPixelChannels(cmyk_image);\n        }\n        if (SyncCacheViewAuthenticPixels(cmyk_view,exception) == MagickFalse)\n          break;\n      }\n      cmyk_view=DestroyCacheView(cmyk_view);\n      image_view=DestroyCacheView(image_view);\n      images=GetNextImageInList(images);\n      if (images == (Image *) NULL)\n        break;\n    }\n    AppendImageToList(&cmyk_images,cmyk_image);\n  }\n  return(cmyk_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C r o p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CropImage() extracts a region of the image starting at the offset defined\n%  by geometry.  Region must be fully defined, and no special handling of\n%  geometry flags is performed.\n%\n%  The format of the CropImage method is:\n%\n%      Image *CropImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to crop with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CropImage(const Image *image,const RectangleInfo *geometry,\n  ExceptionInfo *exception)\n{\n#define CropImageTag  \"Crop/Image\"\n\n  CacheView\n    *crop_view,\n    *image_view;\n\n  Image\n    *crop_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  OffsetInfo\n    offset;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  ssize_t\n    y;\n\n  /*\n    Check crop geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  bounding_box=image->page;\n  if ((bounding_box.width == 0) || (bounding_box.height == 0))\n    {\n      bounding_box.width=image->columns;\n      bounding_box.height=image->rows;\n    }\n  page=(*geometry);\n  if (page.width == 0)\n    page.width=bounding_box.width;\n  if (page.height == 0)\n    page.height=bounding_box.height;\n  if (((bounding_box.x-page.x) >= (ssize_t) page.width) ||\n      ((bounding_box.y-page.y) >= (ssize_t) page.height) ||\n      ((page.x-bounding_box.x) > (ssize_t) image->columns) ||\n      ((page.y-bounding_box.y) > (ssize_t) image->rows))\n    {\n      /*\n        Crop is not within virtual canvas, return 1 pixel transparent image.\n      */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"GeometryDoesNotContainImage\",\"`%s'\",image->filename);\n      crop_image=CloneImage(image,1,1,MagickTrue,exception);\n      if (crop_image == (Image *) NULL)\n        return((Image *) NULL);\n      crop_image->background_color.alpha=(Quantum) TransparentAlpha;\n      crop_image->alpha_trait=BlendPixelTrait;\n      (void) SetImageBackgroundColor(crop_image,exception);\n      crop_image->page=bounding_box;\n      crop_image->page.x=(-1);\n      crop_image->page.y=(-1);\n      if (crop_image->dispose == BackgroundDispose)\n        crop_image->dispose=NoneDispose;\n      return(crop_image);\n    }\n  if ((page.x < 0) && (bounding_box.x >= 0))\n    {\n      page.width+=page.x-bounding_box.x;\n      page.x=0;\n    }\n  else\n    {\n      page.width-=bounding_box.x-page.x;\n      page.x-=bounding_box.x;\n      if (page.x < 0)\n        page.x=0;\n    }\n  if ((page.y < 0) && (bounding_box.y >= 0))\n    {\n      page.height+=page.y-bounding_box.y;\n      page.y=0;\n    }\n  else\n    {\n      page.height-=bounding_box.y-page.y;\n      page.y-=bounding_box.y;\n      if (page.y < 0)\n        page.y=0;\n    }\n  if ((page.x+(ssize_t) page.width) > (ssize_t) image->columns)\n    page.width=image->columns-page.x;\n  if ((geometry->width != 0) && (page.width > geometry->width))\n    page.width=geometry->width;\n  if ((page.y+(ssize_t) page.height) > (ssize_t) image->rows)\n    page.height=image->rows-page.y;\n  if ((geometry->height != 0) && (page.height > geometry->height))\n    page.height=geometry->height;\n  bounding_box.x+=page.x;\n  bounding_box.y+=page.y;\n  if ((page.width == 0) || (page.height == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"GeometryDoesNotContainImage\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize crop image attributes.\n  */\n  crop_image=CloneImage(image,page.width,page.height,MagickTrue,exception);\n  if (crop_image == (Image *) NULL)\n    return((Image *) NULL);\n  crop_image->page.width=image->page.width;\n  crop_image->page.height=image->page.height;\n  offset.x=(ssize_t) (bounding_box.x+bounding_box.width);\n  offset.y=(ssize_t) (bounding_box.y+bounding_box.height);\n  if ((offset.x > (ssize_t) image->page.width) ||\n      (offset.y > (ssize_t) image->page.height))\n    {\n      crop_image->page.width=bounding_box.width;\n      crop_image->page.height=bounding_box.height;\n    }\n  crop_image->page.x=bounding_box.x;\n  crop_image->page.y=bounding_box.y;\n  /*\n    Crop image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  crop_view=AcquireAuthenticCacheView(crop_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,crop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) crop_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,page.x,page.y+y,crop_image->columns,\n      1,exception);\n    q=QueueCacheViewAuthenticPixels(crop_view,0,y,crop_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) crop_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(crop_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(crop_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait crop_traits=GetPixelChannelTraits(crop_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (crop_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(crop_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(crop_image);\n    }\n    if (SyncCacheViewAuthenticPixels(crop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CropImage)\n#endif\n        proceed=SetImageProgress(image,CropImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  crop_view=DestroyCacheView(crop_view);\n  image_view=DestroyCacheView(image_view);\n  crop_image->type=image->type;\n  if (status == MagickFalse)\n    crop_image=DestroyImage(crop_image);\n  return(crop_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C r o p I m a g e T o T i l e s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CropImageToTiles() crops a single image, into a possible list of tiles.\n%  This may include a single sub-region of the image.  This basically applies\n%  all the normal geometry flags for Crop.\n%\n%      Image *CropImageToTiles(const Image *image,\n%         const RectangleInfo *crop_geometry, ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image The transformed image is returned as this parameter.\n%\n%    o crop_geometry: A crop geometry string.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n\nMagickExport Image *CropImageToTiles(const Image *image,\n  const char *crop_geometry,ExceptionInfo *exception)\n{\n  Image\n    *next,\n    *crop_image;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  crop_image=NewImageList();\n  next=NewImageList();\n  flags=ParseGravityGeometry(image,crop_geometry,&geometry,exception);\n  if ((flags & AreaValue) != 0)\n    {\n      PointInfo\n        delta,\n        offset;\n\n      RectangleInfo\n        crop;\n\n      size_t\n        height,\n        width;\n\n      /*\n        Crop into NxM tiles (@ flag).\n      */\n      width=image->columns;\n      height=image->rows;\n      if (geometry.width == 0)\n        geometry.width=1;\n      if (geometry.height == 0)\n        geometry.height=1;\n      if ((flags & AspectValue) == 0)\n        {\n          width-=(geometry.x < 0 ? -1 : 1)*geometry.x;\n          height-=(geometry.y < 0 ? -1 : 1)*geometry.y;\n        }\n      else\n        {\n          width+=(geometry.x < 0 ? -1 : 1)*geometry.x;\n          height+=(geometry.y < 0 ? -1 : 1)*geometry.y;\n        }\n      delta.x=(double) width/geometry.width;\n      delta.y=(double) height/geometry.height;\n      if (delta.x < 1.0)\n        delta.x=1.0;\n      if (delta.y < 1.0)\n        delta.y=1.0;\n      for (offset.y=0; offset.y < (double) height; )\n      {\n        if ((flags & AspectValue) == 0)\n          {\n            crop.y=(ssize_t) MagickRound((double) (offset.y-\n              (geometry.y > 0 ? 0 : geometry.y)));\n            offset.y+=delta.y;   /* increment now to find width */\n            crop.height=(size_t) MagickRound((double) (offset.y+\n              (geometry.y < 0 ? 0 : geometry.y)));\n          }\n        else\n          {\n            crop.y=(ssize_t) MagickRound((double) (offset.y-\n              (geometry.y > 0 ? geometry.y : 0)));\n            offset.y+=delta.y;  /* increment now to find width */\n            crop.height=(size_t) MagickRound((double)\n              (offset.y+(geometry.y < -1 ? geometry.y : 0)));\n          }\n        crop.height-=crop.y;\n        crop.y+=image->page.y;\n        for (offset.x=0; offset.x < (double) width; )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              crop.x=(ssize_t) MagickRound((double) (offset.x-\n                (geometry.x > 0 ? 0 : geometry.x)));\n              offset.x+=delta.x;  /* increment now to find height */\n              crop.width=(size_t) MagickRound((double) (offset.x+\n                (geometry.x < 0 ? 0 : geometry.x)));\n            }\n          else\n            {\n              crop.x=(ssize_t) MagickRound((double) (offset.x-\n                (geometry.x > 0 ? geometry.x : 0)));\n              offset.x+=delta.x;  /* increment now to find height */\n              crop.width=(size_t) MagickRound((double) (offset.x+\n                (geometry.x < 0 ? geometry.x : 0)));\n            }\n          crop.width-=crop.x;\n          crop.x+=image->page.x;\n          next=CropImage(image,&crop,exception);\n          if (next != (Image *) NULL)\n            AppendImageToList(&crop_image,next);\n        }\n      }\n      ClearMagickException(exception);\n      return(crop_image);\n    }\n  if (((geometry.width == 0) && (geometry.height == 0)) ||\n      ((flags & XValue) != 0) || ((flags & YValue) != 0))\n    {\n      /*\n        Crop a single region at +X+Y.\n      */\n      crop_image=CropImage(image,&geometry,exception);\n      if ((crop_image != (Image *) NULL) && ((flags & AspectValue) != 0))\n        {\n          crop_image->page.width=geometry.width;\n          crop_image->page.height=geometry.height;\n          crop_image->page.x-=geometry.x;\n          crop_image->page.y-=geometry.y;\n        }\n      return(crop_image);\n    }\n  if ((image->columns > geometry.width) || (image->rows > geometry.height))\n    {\n      RectangleInfo\n        page;\n\n      size_t\n        height,\n        width;\n\n      ssize_t\n        x,\n        y;\n\n      /*\n        Crop into tiles of fixed size WxH.\n      */\n      page=image->page;\n      if (page.width == 0)\n        page.width=image->columns;\n      if (page.height == 0)\n        page.height=image->rows;\n      width=geometry.width;\n      if (width == 0)\n        width=page.width;\n      height=geometry.height;\n      if (height == 0)\n        height=page.height;\n      next=NewImageList();\n      for (y=0; y < (ssize_t) page.height; y+=(ssize_t) height)\n      {\n        for (x=0; x < (ssize_t) page.width; x+=(ssize_t) width)\n        {\n          geometry.width=width;\n          geometry.height=height;\n          geometry.x=x;\n          geometry.y=y;\n          next=CropImage(image,&geometry,exception);\n          if (next == (Image *) NULL)\n            break;\n          AppendImageToList(&crop_image,next);\n        }\n        if (next == (Image *) NULL)\n          break;\n      }\n      return(crop_image);\n    }\n  return(CloneImage(image,0,0,MagickTrue,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E x c e r p t I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExcerptImage() returns a excerpt of the image as defined by the geometry.\n%\n%  The format of the ExcerptImage method is:\n%\n%      Image *ExcerptImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to extend with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ExcerptImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n#define ExcerptImageTag  \"Excerpt/Image\"\n\n  CacheView\n    *excerpt_view,\n    *image_view;\n\n  Image\n    *excerpt_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate excerpt image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  excerpt_image=CloneImage(image,geometry->width,geometry->height,MagickTrue,\n    exception);\n  if (excerpt_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Excerpt each row.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  excerpt_view=AcquireAuthenticCacheView(excerpt_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,excerpt_image,excerpt_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) excerpt_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,geometry->x,geometry->y+y,\n      geometry->width,1,exception);\n    q=GetCacheViewAuthenticPixels(excerpt_view,0,y,excerpt_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) excerpt_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(excerpt_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(excerpt_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait excerpt_traits=GetPixelChannelTraits(excerpt_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (excerpt_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(excerpt_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(excerpt_image);\n    }\n    if (SyncCacheViewAuthenticPixels(excerpt_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ExcerptImage)\n#endif\n        proceed=SetImageProgress(image,ExcerptImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  excerpt_view=DestroyCacheView(excerpt_view);\n  image_view=DestroyCacheView(image_view);\n  excerpt_image->type=image->type;\n  if (status == MagickFalse)\n    excerpt_image=DestroyImage(excerpt_image);\n  return(excerpt_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E x t e n t I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExtentImage() extends the image as defined by the geometry, gravity, and\n%  image background color.  Set the (x,y) offset of the geometry to move the\n%  original image relative to the extended image.\n%\n%  The format of the ExtentImage method is:\n%\n%      Image *ExtentImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to extend with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ExtentImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n  Image\n    *extent_image;\n\n  /*\n    Allocate extent image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((image->columns == geometry->width) &&\n      (image->rows == geometry->height) &&\n      (geometry->x == 0) && (geometry->y == 0))\n    return(CloneImage(image,0,0,MagickTrue,exception));\n  extent_image=CloneImage(image,geometry->width,geometry->height,MagickTrue,\n    exception);\n  if (extent_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) SetImageBackgroundColor(extent_image,exception);\n  (void) CompositeImage(extent_image,image,image->compose,MagickTrue,\n    -geometry->x,-geometry->y,exception);\n  return(extent_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F l i p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FlipImage() creates a vertical mirror image by reflecting the pixels\n%  around the central x-axis.\n%\n%  The format of the FlipImage method is:\n%\n%      Image *FlipImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *FlipImage(const Image *image,ExceptionInfo *exception)\n{\n#define FlipImageTag  \"Flip/Image\"\n\n  CacheView\n    *flip_view,\n    *image_view;\n\n  Image\n    *flip_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  flip_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (flip_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Flip image.\n  */\n  status=MagickTrue;\n  progress=0;\n  page=image->page;\n  image_view=AcquireVirtualCacheView(image,exception);\n  flip_view=AcquireAuthenticCacheView(flip_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,flip_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) flip_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(flip_view,0,(ssize_t) (flip_image->rows-y-\n      1),flip_image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) flip_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(flip_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(flip_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait flip_traits=GetPixelChannelTraits(flip_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (flip_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(flip_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(flip_image);\n    }\n    if (SyncCacheViewAuthenticPixels(flip_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FlipImage)\n#endif\n        proceed=SetImageProgress(image,FlipImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  flip_view=DestroyCacheView(flip_view);\n  image_view=DestroyCacheView(image_view);\n  flip_image->type=image->type;\n  if (page.height != 0)\n    page.y=(ssize_t) (page.height-flip_image->rows-page.y);\n  flip_image->page=page;\n  if (status == MagickFalse)\n    flip_image=DestroyImage(flip_image);\n  return(flip_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F l o p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FlopImage() creates a horizontal mirror image by reflecting the pixels\n%  around the central y-axis.\n%\n%  The format of the FlopImage method is:\n%\n%      Image *FlopImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *FlopImage(const Image *image,ExceptionInfo *exception)\n{\n#define FlopImageTag  \"Flop/Image\"\n\n  CacheView\n    *flop_view,\n    *image_view;\n\n  Image\n    *flop_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  flop_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (flop_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Flop each row.\n  */\n  status=MagickTrue;\n  progress=0;\n  page=image->page;\n  image_view=AcquireVirtualCacheView(image,exception);\n  flop_view=AcquireAuthenticCacheView(flop_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,flop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) flop_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(flop_view,0,y,flop_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    q+=GetPixelChannels(flop_image)*flop_image->columns;\n    for (x=0; x < (ssize_t) flop_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      q-=GetPixelChannels(flop_image);\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait flop_traits=GetPixelChannelTraits(flop_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (flop_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(flop_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(flop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FlopImage)\n#endif\n        proceed=SetImageProgress(image,FlopImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  flop_view=DestroyCacheView(flop_view);\n  image_view=DestroyCacheView(image_view);\n  flop_image->type=image->type;\n  if (page.width != 0)\n    page.x=(ssize_t) (page.width-flop_image->columns-page.x);\n  flop_image->page=page;\n  if (status == MagickFalse)\n    flop_image=DestroyImage(flop_image);\n  return(flop_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R o l l I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RollImage() offsets an image as defined by x_offset and y_offset.\n%\n%  The format of the RollImage method is:\n%\n%      Image *RollImage(const Image *image,const ssize_t x_offset,\n%        const ssize_t y_offset,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x_offset: the number of columns to roll in the horizontal direction.\n%\n%    o y_offset: the number of rows to roll in the vertical direction.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType CopyImageRegion(Image *destination,const Image *source,  const size_t columns,const size_t rows,const ssize_t sx,const ssize_t sy,\n  const ssize_t dx,const ssize_t dy,ExceptionInfo *exception)\n{\n  CacheView\n    *source_view,\n    *destination_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (columns == 0)\n    return(MagickTrue);\n  status=MagickTrue;\n  source_view=AcquireVirtualCacheView(source,exception);\n  destination_view=AcquireAuthenticCacheView(destination,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(source,destination,rows,1)\n#endif\n  for (y=0; y < (ssize_t) rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    /*\n      Transfer scanline.\n    */\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(source_view,sx,sy+y,columns,1,exception);\n    q=GetCacheViewAuthenticPixels(destination_view,dx,dy+y,columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(source,p) == 0)\n        {\n          SetPixelBackgoundColor(destination,q);\n          p+=GetPixelChannels(source);\n          q+=GetPixelChannels(destination);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(source,i);\n        PixelTrait source_traits=GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((source_traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(destination,channel,p[i],q);\n      }\n      p+=GetPixelChannels(source);\n      q+=GetPixelChannels(destination);\n    }\n    sync=SyncCacheViewAuthenticPixels(destination_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n  }\n  destination_view=DestroyCacheView(destination_view);\n  source_view=DestroyCacheView(source_view);\n  return(status);\n}\n\nMagickExport Image *RollImage(const Image *image,const ssize_t x_offset,\n  const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define RollImageTag  \"Roll/Image\"\n\n  Image\n    *roll_image;\n\n  MagickStatusType\n    status;\n\n  RectangleInfo\n    offset;\n\n  /*\n    Initialize roll image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  roll_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (roll_image == (Image *) NULL)\n    return((Image *) NULL);\n  offset.x=x_offset;\n  offset.y=y_offset;\n  while (offset.x < 0)\n    offset.x+=(ssize_t) image->columns;\n  while (offset.x >= (ssize_t) image->columns)\n    offset.x-=(ssize_t) image->columns;\n  while (offset.y < 0)\n    offset.y+=(ssize_t) image->rows;\n  while (offset.y >= (ssize_t) image->rows)\n    offset.y-=(ssize_t) image->rows;\n  /*\n    Roll image.\n  */\n  status=CopyImageRegion(roll_image,image,(size_t) offset.x,\n    (size_t) offset.y,(ssize_t) image->columns-offset.x,(ssize_t) image->rows-\n    offset.y,0,0,exception);\n  (void) SetImageProgress(image,RollImageTag,0,3);\n  status&=CopyImageRegion(roll_image,image,image->columns-offset.x,\n    (size_t) offset.y,0,(ssize_t) image->rows-offset.y,offset.x,0,\n    exception);\n  (void) SetImageProgress(image,RollImageTag,1,3);\n  status&=CopyImageRegion(roll_image,image,(size_t) offset.x,image->rows-\n    offset.y,(ssize_t) image->columns-offset.x,0,0,offset.y,exception);\n  (void) SetImageProgress(image,RollImageTag,2,3);\n  status&=CopyImageRegion(roll_image,image,image->columns-offset.x,image->rows-\n    offset.y,0,0,offset.x,offset.y,exception);\n  (void) SetImageProgress(image,RollImageTag,3,3);\n  roll_image->type=image->type;\n  if (status == MagickFalse)\n    roll_image=DestroyImage(roll_image);\n  return(roll_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S h a v e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ShaveImage() shaves pixels from the image edges.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the ShaveImage method is:\n%\n%      Image *ShaveImage(const Image *image,const RectangleInfo *shave_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o shave_image: Method ShaveImage returns a pointer to the shaved\n%      image.  A null image is returned if there is a memory shortage or\n%      if the image width or height is zero.\n%\n%    o image: the image.\n%\n%    o shave_info: Specifies a pointer to a RectangleInfo which defines the\n%      region of the image to crop.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ShaveImage(const Image *image,\n  const RectangleInfo *shave_info,ExceptionInfo *exception)\n{\n  Image\n    *shave_image;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (((2*shave_info->width) >= image->columns) ||\n      ((2*shave_info->height) >= image->rows))\n    ThrowImageException(OptionWarning,\"GeometryDoesNotContainImage\");\n  SetGeometry(image,&geometry);\n  geometry.width-=2*shave_info->width;\n  geometry.height-=2*shave_info->height;\n  geometry.x=(ssize_t) shave_info->width+image->page.x;\n  geometry.y=(ssize_t) shave_info->height+image->page.y;\n  shave_image=CropImage(image,&geometry,exception);\n  if (shave_image == (Image *) NULL)\n    return((Image *) NULL);\n  shave_image->page.width-=2*shave_info->width;\n  shave_image->page.height-=2*shave_info->height;\n  shave_image->page.x-=(ssize_t) shave_info->width;\n  shave_image->page.y-=(ssize_t) shave_info->height;\n  return(shave_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S p l i c e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SpliceImage() splices a solid color into the image as defined by the\n%  geometry.\n%\n%  The format of the SpliceImage method is:\n%\n%      Image *SpliceImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to splice with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SpliceImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n#define SpliceImageTag  \"Splice/Image\"\n\n  CacheView\n    *image_view,\n    *splice_view;\n\n  Image\n    *splice_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    splice_geometry;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate splice image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  splice_geometry=(*geometry);\n  splice_image=CloneImage(image,image->columns+splice_geometry.width,\n    image->rows+splice_geometry.height,MagickTrue,exception);\n  if (splice_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(splice_image,DirectClass,exception) == MagickFalse)\n    {\n      splice_image=DestroyImage(splice_image);\n      return((Image *) NULL);\n    }\n  if ((IsPixelInfoGray(&splice_image->background_color) == MagickFalse) &&\n      (IsGrayColorspace(splice_image->colorspace) != MagickFalse))\n    (void) SetImageColorspace(splice_image,sRGBColorspace,exception);\n  if ((splice_image->background_color.alpha_trait != UndefinedPixelTrait) &&\n      (splice_image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlpha(splice_image,OpaqueAlpha,exception);\n  (void) SetImageBackgroundColor(splice_image,exception);\n  /*\n    Respect image geometry.\n  */\n  switch (image->gravity)\n  {\n    default:\n    case UndefinedGravity:\n    case NorthWestGravity:\n      break;\n    case NorthGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      break;\n    }\n    case NorthEastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      break;\n    }\n    case WestGravity:\n    {\n      splice_geometry.y+=(ssize_t) splice_geometry.width/2;\n      break;\n    }\n    case CenterGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      splice_geometry.y+=(ssize_t) splice_geometry.height/2;\n      break;\n    }\n    case EastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      splice_geometry.y+=(ssize_t) splice_geometry.height/2;\n      break;\n    }\n    case SouthWestGravity:\n    {\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n    case SouthGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n    case SouthEastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n  }\n  /*\n    Splice image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  splice_view=AcquireAuthenticCacheView(splice_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,splice_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) splice_geometry.y; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < splice_geometry.x; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    for ( ; x < (ssize_t) (splice_geometry.x+splice_geometry.width); x++)\n      q+=GetPixelChannels(splice_image);\n    for ( ; x < (ssize_t) splice_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    if (SyncCacheViewAuthenticPixels(splice_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,SpliceImageTag,progress++,\n          splice_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,splice_image,1,1)\n#endif\n  for (y=(ssize_t) (splice_geometry.y+splice_geometry.height);\n       y < (ssize_t) splice_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y-(ssize_t) splice_geometry.height,\n      image->columns,1,exception);\n    if ((y < 0) || (y >= (ssize_t) splice_image->rows))\n      continue;\n    q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < splice_geometry.x; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    for ( ; x < (ssize_t) (splice_geometry.x+splice_geometry.width); x++)\n      q+=GetPixelChannels(splice_image);\n    for ( ; x < (ssize_t) splice_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    if (SyncCacheViewAuthenticPixels(splice_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,SpliceImageTag,progress++,\n          splice_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  splice_view=DestroyCacheView(splice_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    splice_image=DestroyImage(splice_image);\n  return(splice_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s f o r m I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransformImage() is a convenience method that behaves like ResizeImage() or\n%  CropImage() but accepts scaling and/or cropping information as a region\n%  geometry specification.  If the operation fails, the original image handle\n%  is left as is.\n%\n%  This should only be used for single images.\n%\n%  This function destroys what it assumes to be a single image list.\n%  If the input image is part of a larger list, all other images in that list\n%  will be simply 'lost', not destroyed.\n%\n%  Also if the crop generates a list of images only the first image is resized.\n%  And finally if the crop succeeds and the resize failed, you will get a\n%  cropped image, as well as a 'false' or 'failed' report.\n%\n%  This function and should probably be deprecated in favor of direct calls\n%  to CropImageToTiles() or ResizeImage(), as appropriate.\n%\n%  The format of the TransformImage method is:\n%\n%      MagickBooleanType TransformImage(Image **image,const char *crop_geometry,\n%        const char *image_geometry,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image The transformed image is returned as this parameter.\n%\n%    o crop_geometry: A crop geometry string.  This geometry defines a\n%      subregion of the image to crop.\n%\n%    o image_geometry: An image geometry string.  This geometry defines the\n%      final size of the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType TransformImage(Image **image,\n  const char *crop_geometry,const char *image_geometry,ExceptionInfo *exception)\n{\n  Image\n    *resize_image,\n    *transform_image;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  transform_image=(*image);\n  if (crop_geometry != (const char *) NULL)\n    {\n      Image\n        *crop_image;\n\n      /*\n        Crop image to a user specified size.\n      */\n      crop_image=CropImageToTiles(*image,crop_geometry,exception);\n      if (crop_image == (Image *) NULL)\n        transform_image=CloneImage(*image,0,0,MagickTrue,exception);\n      else\n        {\n          transform_image=DestroyImage(transform_image);\n          transform_image=GetFirstImageInList(crop_image);\n        }\n      *image=transform_image;\n    }\n  if (image_geometry == (const char *) NULL)\n    return(MagickTrue);\n\n  /*\n    Scale image to a user specified size.\n  */\n  flags=ParseRegionGeometry(transform_image,image_geometry,&geometry,exception);\n  (void) flags;\n  if ((transform_image->columns == geometry.width) &&\n      (transform_image->rows == geometry.height))\n    return(MagickTrue);\n  resize_image=ResizeImage(transform_image,geometry.width,geometry.height,\n    transform_image->filter,exception);\n  if (resize_image == (Image *) NULL)\n    return(MagickFalse);\n  transform_image=DestroyImage(transform_image);\n  transform_image=resize_image;\n  *image=transform_image;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s f o r m I m a g e s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransformImages() calls TransformImage() on each image of a sequence.\n%\n%  The format of the TransformImage method is:\n%\n%      MagickBooleanType TransformImages(Image **image,\n%        const char *crop_geometry,const char *image_geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image The transformed image is returned as this parameter.\n%\n%    o crop_geometry: A crop geometry string.  This geometry defines a\n%      subregion of the image to crop.\n%\n%    o image_geometry: An image geometry string.  This geometry defines the\n%      final size of the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType TransformImages(Image **images,\n  const char *crop_geometry,const char *image_geometry,ExceptionInfo *exception)\n{\n  Image\n    *image,\n    **image_list,\n    *transform_images;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  assert(images != (Image **) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  image_list=ImageListToArray(*images,exception);\n  if (image_list == (Image **) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  transform_images=NewImageList();\n  for (i=0; image_list[i] != (Image *) NULL; i++)\n  {\n    image=image_list[i];\n    status&=TransformImage(&image,crop_geometry,image_geometry,exception);\n    AppendImageToList(&transform_images,image);\n  }\n  *images=transform_images;\n  image_list=(Image **) RelinquishMagickMemory(image_list);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s p o s e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransposeImage() creates a horizontal mirror image by reflecting the pixels\n%  around the central y-axis while rotating them by 90 degrees.\n%\n%  The format of the TransposeImage method is:\n%\n%      Image *TransposeImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TransposeImage(const Image *image,ExceptionInfo *exception)\n{\n#define TransposeImageTag  \"Transpose/Image\"\n\n  CacheView\n    *image_view,\n    *transpose_view;\n\n  Image\n    *transpose_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  transpose_image=CloneImage(image,image->rows,image->columns,MagickTrue,\n    exception);\n  if (transpose_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Transpose image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  transpose_view=AcquireAuthenticCacheView(transpose_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,transpose_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,(ssize_t) image->rows-y-1,\n      image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(transpose_view,(ssize_t) (image->rows-y-1),\n      0,1,transpose_image->rows,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(transpose_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(transpose_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait transpose_traits=GetPixelChannelTraits(transpose_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (transpose_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(transpose_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(transpose_image);\n    }\n    if (SyncCacheViewAuthenticPixels(transpose_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,TransposeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  transpose_view=DestroyCacheView(transpose_view);\n  image_view=DestroyCacheView(image_view);\n  transpose_image->type=image->type;\n  page=transpose_image->page;\n  Swap(page.width,page.height);\n  Swap(page.x,page.y);\n  transpose_image->page=page;\n  if (status == MagickFalse)\n    transpose_image=DestroyImage(transpose_image);\n  return(transpose_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s v e r s e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransverseImage() creates a vertical mirror image by reflecting the pixels\n%  around the central x-axis while rotating them by 270 degrees.\n%\n%  The format of the TransverseImage method is:\n%\n%      Image *TransverseImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TransverseImage(const Image *image,ExceptionInfo *exception)\n{\n#define TransverseImageTag  \"Transverse/Image\"\n\n  CacheView\n    *image_view,\n    *transverse_view;\n\n  Image\n    *transverse_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  transverse_image=CloneImage(image,image->rows,image->columns,MagickTrue,\n    exception);\n  if (transverse_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Transverse image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  transverse_view=AcquireAuthenticCacheView(transverse_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,transverse_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(transverse_view,(ssize_t) (image->rows-y-1),\n      0,1,transverse_image->rows,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    q+=GetPixelChannels(transverse_image)*image->columns;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      q-=GetPixelChannels(transverse_image);\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait transverse_traits=GetPixelChannelTraits(transverse_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (transverse_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(transverse_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n    }\n    sync=SyncCacheViewAuthenticPixels(transverse_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransverseImage)\n#endif\n        proceed=SetImageProgress(image,TransverseImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  transverse_view=DestroyCacheView(transverse_view);\n  image_view=DestroyCacheView(image_view);\n  transverse_image->type=image->type;\n  page=transverse_image->page;\n  Swap(page.width,page.height);\n  Swap(page.x,page.y);\n  if (page.width != 0)\n    page.x=(ssize_t) (page.width-transverse_image->columns-page.x);\n  if (page.height != 0)\n    page.y=(ssize_t) (page.height-transverse_image->rows-page.y);\n  transverse_image->page=page;\n  if (status == MagickFalse)\n    transverse_image=DestroyImage(transverse_image);\n  return(transverse_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r i m I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TrimImage() trims pixels from the image edges.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the TrimImage method is:\n%\n%      Image *TrimImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TrimImage(const Image *image,ExceptionInfo *exception)\n{\n  RectangleInfo\n    geometry;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  geometry=GetImageBoundingBox(image,exception);\n  if ((geometry.width == 0) || (geometry.height == 0))\n    {\n      Image\n        *crop_image;\n\n      crop_image=CloneImage(image,1,1,MagickTrue,exception);\n      if (crop_image == (Image *) NULL)\n        return((Image *) NULL);\n      crop_image->background_color.alpha=(Quantum) TransparentAlpha;\n      crop_image->alpha_trait=BlendPixelTrait;\n      (void) SetImageBackgroundColor(crop_image,exception);\n      crop_image->page=image->page;\n      crop_image->page.x=(-1);\n      crop_image->page.y=(-1);\n      return(crop_image);\n    }\n  geometry.x+=image->page.x;\n  geometry.y+=image->page.y;\n  return(CropImage(image,&geometry,exception));\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%       TTTTT  RRRR    AAA   N   N  SSSSS  FFFFF   OOO   RRRR   M   M         %\n%         T    R   R  A   A  NN  N  SS     F      O   O  R   R  MM MM         %\n%         T    RRRR   AAAAA  N N N   SSS   FFF    O   O  RRRR   M M M         %\n%         T    R R    A   A  N  NN     SS  F      O   O  R R    M   M         %\n%         T    R  R   A   A  N   N  SSSSS  F       OOO   R  R   M   M         %\n%                                                                             %\n%                                                                             %\n%                    MagickCore Image Transform Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/transform.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A u t o O r i e n t I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AutoOrientImage() adjusts an image so that its orientation is suitable for\n%  viewing (i.e. top-left orientation).\n%\n%  The format of the AutoOrientImage method is:\n%\n%      Image *AutoOrientImage(const Image *image,\n%        const OrientationType orientation,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: The image.\n%\n%    o orientation: Current image orientation.\n%\n%    o exception: Return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AutoOrientImage(const Image *image,\n  const OrientationType orientation,ExceptionInfo *exception)\n{\n  Image\n    *orient_image;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  orient_image=(Image *) NULL;\n  switch(orientation)\n  {\n    case UndefinedOrientation:\n    case TopLeftOrientation:\n    default:\n    {\n      orient_image=CloneImage(image,0,0,MagickTrue,exception);\n      break;\n    }\n    case TopRightOrientation:\n    {\n      orient_image=FlopImage(image,exception);\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_image=RotateImage(image,180.0,exception);\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_image=FlipImage(image,exception);\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_image=TransposeImage(image,exception);\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_image=RotateImage(image,90.0,exception);\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_image=TransverseImage(image,exception);\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_image=RotateImage(image,270.0,exception);\n      break;\n    }\n  }\n  if (orient_image != (Image *) NULL)\n    orient_image->orientation=TopLeftOrientation;\n  return(orient_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C h o p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ChopImage() removes a region of an image and collapses the image to occupy\n%  the removed portion.\n%\n%  The format of the ChopImage method is:\n%\n%      Image *ChopImage(const Image *image,const RectangleInfo *chop_info)\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o chop_info: Define the region of the image to chop.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ChopImage(const Image *image,const RectangleInfo *chop_info,\n  ExceptionInfo *exception)\n{\n#define ChopImageTag  \"Chop/Image\"\n\n  CacheView\n    *chop_view,\n    *image_view;\n\n  Image\n    *chop_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    extent;\n\n  ssize_t\n    y;\n\n  /*\n    Check chop geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(chop_info != (RectangleInfo *) NULL);\n  if (((chop_info->x+(ssize_t) chop_info->width) < 0) ||\n      ((chop_info->y+(ssize_t) chop_info->height) < 0) ||\n      (chop_info->x > (ssize_t) image->columns) ||\n      (chop_info->y > (ssize_t) image->rows))\n    ThrowImageException(OptionWarning,\"GeometryDoesNotContainImage\");\n  extent=(*chop_info);\n  if ((extent.x+(ssize_t) extent.width) > (ssize_t) image->columns)\n    extent.width=(size_t) ((ssize_t) image->columns-extent.x);\n  if ((extent.y+(ssize_t) extent.height) > (ssize_t) image->rows)\n    extent.height=(size_t) ((ssize_t) image->rows-extent.y);\n  if (extent.x < 0)\n    {\n      extent.width-=(size_t) (-extent.x);\n      extent.x=0;\n    }\n  if (extent.y < 0)\n    {\n      extent.height-=(size_t) (-extent.y);\n      extent.y=0;\n    }\n  chop_image=CloneImage(image,image->columns-extent.width,image->rows-\n    extent.height,MagickTrue,exception);\n  if (chop_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Extract chop image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  chop_view=AcquireAuthenticCacheView(chop_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,chop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) extent.y; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(chop_view,0,y,chop_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((x < extent.x) || (x >= (ssize_t) (extent.x+extent.width)))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait chop_traits=GetPixelChannelTraits(chop_image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (chop_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(chop_image,channel,p[i],q);\n          }\n          q+=GetPixelChannels(chop_image);\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(chop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ChopImage)\n#endif\n        proceed=SetImageProgress(image,ChopImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  /*\n    Extract chop image.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,chop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) (image->rows-(extent.y+extent.height)); y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,extent.y+extent.height+y,\n      image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(chop_view,0,extent.y+y,chop_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((x < extent.x) || (x >= (ssize_t) (extent.x+extent.width)))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait chop_traits=GetPixelChannelTraits(chop_image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (chop_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(chop_image,channel,p[i],q);\n          }\n          q+=GetPixelChannels(chop_image);\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(chop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ChopImage)\n#endif\n        proceed=SetImageProgress(image,ChopImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  chop_view=DestroyCacheView(chop_view);\n  image_view=DestroyCacheView(image_view);\n  chop_image->type=image->type;\n  if (status == MagickFalse)\n    chop_image=DestroyImage(chop_image);\n  return(chop_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     C o n s o l i d a t e C M Y K I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ConsolidateCMYKImage() consolidates separate C, M, Y, and K planes into a\n%  single image.\n%\n%  The format of the ConsolidateCMYKImage method is:\n%\n%      Image *ConsolidateCMYKImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image sequence.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ConsolidateCMYKImages(const Image *images,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *cmyk_view,\n    *image_view;\n\n  Image\n    *cmyk_image,\n    *cmyk_images;\n\n  register ssize_t\n    j;\n\n  ssize_t\n    y;\n\n  /*\n    Consolidate separate C, M, Y, and K planes into a single image.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  cmyk_images=NewImageList();\n  for (j=0; j < (ssize_t) GetImageListLength(images); j+=4)\n  {\n    register ssize_t\n      i;\n\n    assert(images != (Image *) NULL);\n    cmyk_image=CloneImage(images,images->columns,images->rows,MagickTrue,\n      exception);\n    if (cmyk_image == (Image *) NULL)\n      break;\n    if (SetImageStorageClass(cmyk_image,DirectClass,exception) == MagickFalse)\n      break;\n    (void) SetImageColorspace(cmyk_image,CMYKColorspace,exception);\n    for (i=0; i < 4; i++)\n    {\n      image_view=AcquireVirtualCacheView(images,exception);\n      cmyk_view=AcquireAuthenticCacheView(cmyk_image,exception);\n      for (y=0; y < (ssize_t) images->rows; y++)\n      {\n        register const Quantum\n          *restrict p;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *restrict q;\n\n        p=GetCacheViewVirtualPixels(image_view,0,y,images->columns,1,exception);\n        q=QueueCacheViewAuthenticPixels(cmyk_view,0,y,cmyk_image->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) images->columns; x++)\n        {\n          Quantum\n            pixel;\n\n          pixel=QuantumRange-GetPixelIntensity(images,p);\n          switch (i)\n          {\n            case 0: SetPixelCyan(cmyk_image,pixel,q);  break;\n            case 1: SetPixelMagenta(cmyk_image,pixel,q);  break;\n            case 2: SetPixelYellow(cmyk_image,pixel,q);  break;\n            case 3: SetPixelBlack(cmyk_image,pixel,q);  break;\n            default: break;\n          }\n          p+=GetPixelChannels(images);\n          q+=GetPixelChannels(cmyk_image);\n        }\n        if (SyncCacheViewAuthenticPixels(cmyk_view,exception) == MagickFalse)\n          break;\n      }\n      cmyk_view=DestroyCacheView(cmyk_view);\n      image_view=DestroyCacheView(image_view);\n      images=GetNextImageInList(images);\n      if (images == (Image *) NULL)\n        break;\n    }\n    AppendImageToList(&cmyk_images,cmyk_image);\n  }\n  return(cmyk_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C r o p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CropImage() extracts a region of the image starting at the offset defined\n%  by geometry.  Region must be fully defined, and no special handling of\n%  geometry flags is performed.\n%\n%  The format of the CropImage method is:\n%\n%      Image *CropImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to crop with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CropImage(const Image *image,const RectangleInfo *geometry,\n  ExceptionInfo *exception)\n{\n#define CropImageTag  \"Crop/Image\"\n\n  CacheView\n    *crop_view,\n    *image_view;\n\n  Image\n    *crop_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  OffsetInfo\n    offset;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  ssize_t\n    y;\n\n  /*\n    Check crop geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  bounding_box=image->page;\n  if ((bounding_box.width == 0) || (bounding_box.height == 0))\n    {\n      bounding_box.width=image->columns;\n      bounding_box.height=image->rows;\n    }\n  page=(*geometry);\n  if (page.width == 0)\n    page.width=bounding_box.width;\n  if (page.height == 0)\n    page.height=bounding_box.height;\n  if (((bounding_box.x-page.x) >= (ssize_t) page.width) ||\n      ((bounding_box.y-page.y) >= (ssize_t) page.height) ||\n      ((page.x-bounding_box.x) > (ssize_t) image->columns) ||\n      ((page.y-bounding_box.y) > (ssize_t) image->rows))\n    {\n      /*\n        Crop is not within virtual canvas, return 1 pixel transparent image.\n      */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"GeometryDoesNotContainImage\",\"`%s'\",image->filename);\n      crop_image=CloneImage(image,1,1,MagickTrue,exception);\n      if (crop_image == (Image *) NULL)\n        return((Image *) NULL);\n      crop_image->background_color.alpha=(Quantum) TransparentAlpha;\n      crop_image->alpha_trait=BlendPixelTrait;\n      (void) SetImageBackgroundColor(crop_image,exception);\n      crop_image->page=bounding_box;\n      crop_image->page.x=(-1);\n      crop_image->page.y=(-1);\n      if (crop_image->dispose == BackgroundDispose)\n        crop_image->dispose=NoneDispose;\n      return(crop_image);\n    }\n  if ((page.x < 0) && (bounding_box.x >= 0))\n    {\n      page.width+=page.x-bounding_box.x;\n      page.x=0;\n    }\n  else\n    {\n      page.width-=bounding_box.x-page.x;\n      page.x-=bounding_box.x;\n      if (page.x < 0)\n        page.x=0;\n    }\n  if ((page.y < 0) && (bounding_box.y >= 0))\n    {\n      page.height+=page.y-bounding_box.y;\n      page.y=0;\n    }\n  else\n    {\n      page.height-=bounding_box.y-page.y;\n      page.y-=bounding_box.y;\n      if (page.y < 0)\n        page.y=0;\n    }\n  if ((page.x+(ssize_t) page.width) > (ssize_t) image->columns)\n    page.width=image->columns-page.x;\n  if ((geometry->width != 0) && (page.width > geometry->width))\n    page.width=geometry->width;\n  if ((page.y+(ssize_t) page.height) > (ssize_t) image->rows)\n    page.height=image->rows-page.y;\n  if ((geometry->height != 0) && (page.height > geometry->height))\n    page.height=geometry->height;\n  bounding_box.x+=page.x;\n  bounding_box.y+=page.y;\n  if ((page.width == 0) || (page.height == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"GeometryDoesNotContainImage\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize crop image attributes.\n  */\n  crop_image=CloneImage(image,page.width,page.height,MagickTrue,exception);\n  if (crop_image == (Image *) NULL)\n    return((Image *) NULL);\n  crop_image->page.width=image->page.width;\n  crop_image->page.height=image->page.height;\n  offset.x=(ssize_t) (bounding_box.x+bounding_box.width);\n  offset.y=(ssize_t) (bounding_box.y+bounding_box.height);\n  if ((offset.x > (ssize_t) image->page.width) ||\n      (offset.y > (ssize_t) image->page.height))\n    {\n      crop_image->page.width=bounding_box.width;\n      crop_image->page.height=bounding_box.height;\n    }\n  crop_image->page.x=bounding_box.x;\n  crop_image->page.y=bounding_box.y;\n  /*\n    Crop image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  crop_view=AcquireAuthenticCacheView(crop_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,crop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) crop_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,page.x,page.y+y,crop_image->columns,\n      1,exception);\n    q=QueueCacheViewAuthenticPixels(crop_view,0,y,crop_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) crop_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(crop_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(crop_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait crop_traits=GetPixelChannelTraits(crop_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (crop_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(crop_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(crop_image);\n    }\n    if (SyncCacheViewAuthenticPixels(crop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CropImage)\n#endif\n        proceed=SetImageProgress(image,CropImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  crop_view=DestroyCacheView(crop_view);\n  image_view=DestroyCacheView(image_view);\n  crop_image->type=image->type;\n  if (status == MagickFalse)\n    crop_image=DestroyImage(crop_image);\n  return(crop_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C r o p I m a g e T o T i l e s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CropImageToTiles() crops a single image, into a possible list of tiles.\n%  This may include a single sub-region of the image.  This basically applies\n%  all the normal geometry flags for Crop.\n%\n%      Image *CropImageToTiles(const Image *image,\n%         const RectangleInfo *crop_geometry, ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image The transformed image is returned as this parameter.\n%\n%    o crop_geometry: A crop geometry string.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n\nMagickExport Image *CropImageToTiles(const Image *image,\n  const char *crop_geometry,ExceptionInfo *exception)\n{\n  Image\n    *next,\n    *crop_image;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  crop_image=NewImageList();\n  next=NewImageList();\n  flags=ParseGravityGeometry(image,crop_geometry,&geometry,exception);\n  if ((flags & AreaValue) != 0)\n    {\n      PointInfo\n        delta,\n        offset;\n\n      RectangleInfo\n        crop;\n\n      size_t\n        height,\n        width;\n\n      /*\n        Crop into NxM tiles (@ flag).\n      */\n      width=image->columns;\n      height=image->rows;\n      if (geometry.width == 0)\n        geometry.width=1;\n      if (geometry.height == 0)\n        geometry.height=1;\n      if ((flags & AspectValue) == 0)\n        {\n          width-=(geometry.x < 0 ? -1 : 1)*geometry.x;\n          height-=(geometry.y < 0 ? -1 : 1)*geometry.y;\n        }\n      else\n        {\n          width+=(geometry.x < 0 ? -1 : 1)*geometry.x;\n          height+=(geometry.y < 0 ? -1 : 1)*geometry.y;\n        }\n      delta.x=(double) width/geometry.width;\n      delta.y=(double) height/geometry.height;\n      if (delta.x < 1.0)\n        delta.x=1.0;\n      if (delta.y < 1.0)\n        delta.y=1.0;\n      for (offset.y=0; offset.y < (double) height; )\n      {\n        if ((flags & AspectValue) == 0)\n          {\n            crop.y=(ssize_t) MagickRound((double) (offset.y-\n              (geometry.y > 0 ? 0 : geometry.y)));\n            offset.y+=delta.y;   /* increment now to find width */\n            crop.height=(size_t) MagickRound((double) (offset.y+\n              (geometry.y < 0 ? 0 : geometry.y)));\n          }\n        else\n          {\n            crop.y=(ssize_t) MagickRound((double) (offset.y-\n              (geometry.y > 0 ? geometry.y : 0)));\n            offset.y+=delta.y;  /* increment now to find width */\n            crop.height=(size_t) MagickRound((double)\n              (offset.y+(geometry.y < -1 ? geometry.y : 0)));\n          }\n        crop.height-=crop.y;\n        crop.y+=image->page.y;\n        for (offset.x=0; offset.x < (double) width; )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              crop.x=(ssize_t) MagickRound((double) (offset.x-\n                (geometry.x > 0 ? 0 : geometry.x)));\n              offset.x+=delta.x;  /* increment now to find height */\n              crop.width=(size_t) MagickRound((double) (offset.x+\n                (geometry.x < 0 ? 0 : geometry.x)));\n            }\n          else\n            {\n              crop.x=(ssize_t) MagickRound((double) (offset.x-\n                (geometry.x > 0 ? geometry.x : 0)));\n              offset.x+=delta.x;  /* increment now to find height */\n              crop.width=(size_t) MagickRound((double) (offset.x+\n                (geometry.x < 0 ? geometry.x : 0)));\n            }\n          crop.width-=crop.x;\n          crop.x+=image->page.x;\n          next=CropImage(image,&crop,exception);\n          if (next != (Image *) NULL)\n            AppendImageToList(&crop_image,next);\n        }\n      }\n      ClearMagickException(exception);\n      return(crop_image);\n    }\n  if (((geometry.width == 0) && (geometry.height == 0)) ||\n      ((flags & XValue) != 0) || ((flags & YValue) != 0))\n    {\n      /*\n        Crop a single region at +X+Y.\n      */\n      crop_image=CropImage(image,&geometry,exception);\n      if ((crop_image != (Image *) NULL) && ((flags & AspectValue) != 0))\n        {\n          crop_image->page.width=geometry.width;\n          crop_image->page.height=geometry.height;\n          crop_image->page.x-=geometry.x;\n          crop_image->page.y-=geometry.y;\n        }\n      return(crop_image);\n    }\n  if ((image->columns > geometry.width) || (image->rows > geometry.height))\n    {\n      RectangleInfo\n        page;\n\n      size_t\n        height,\n        width;\n\n      ssize_t\n        x,\n        y;\n\n      /*\n        Crop into tiles of fixed size WxH.\n      */\n      page=image->page;\n      if (page.width == 0)\n        page.width=image->columns;\n      if (page.height == 0)\n        page.height=image->rows;\n      width=geometry.width;\n      if (width == 0)\n        width=page.width;\n      height=geometry.height;\n      if (height == 0)\n        height=page.height;\n      next=NewImageList();\n      for (y=0; y < (ssize_t) page.height; y+=(ssize_t) height)\n      {\n        for (x=0; x < (ssize_t) page.width; x+=(ssize_t) width)\n        {\n          geometry.width=width;\n          geometry.height=height;\n          geometry.x=x;\n          geometry.y=y;\n          next=CropImage(image,&geometry,exception);\n          if (next == (Image *) NULL)\n            break;\n          AppendImageToList(&crop_image,next);\n        }\n        if (next == (Image *) NULL)\n          break;\n      }\n      return(crop_image);\n    }\n  return(CloneImage(image,0,0,MagickTrue,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E x c e r p t I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExcerptImage() returns a excerpt of the image as defined by the geometry.\n%\n%  The format of the ExcerptImage method is:\n%\n%      Image *ExcerptImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to extend with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ExcerptImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n#define ExcerptImageTag  \"Excerpt/Image\"\n\n  CacheView\n    *excerpt_view,\n    *image_view;\n\n  Image\n    *excerpt_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate excerpt image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  excerpt_image=CloneImage(image,geometry->width,geometry->height,MagickTrue,\n    exception);\n  if (excerpt_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Excerpt each row.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  excerpt_view=AcquireAuthenticCacheView(excerpt_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,excerpt_image,excerpt_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) excerpt_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,geometry->x,geometry->y+y,\n      geometry->width,1,exception);\n    q=GetCacheViewAuthenticPixels(excerpt_view,0,y,excerpt_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) excerpt_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(excerpt_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(excerpt_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait excerpt_traits=GetPixelChannelTraits(excerpt_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (excerpt_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(excerpt_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(excerpt_image);\n    }\n    if (SyncCacheViewAuthenticPixels(excerpt_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ExcerptImage)\n#endif\n        proceed=SetImageProgress(image,ExcerptImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  excerpt_view=DestroyCacheView(excerpt_view);\n  image_view=DestroyCacheView(image_view);\n  excerpt_image->type=image->type;\n  if (status == MagickFalse)\n    excerpt_image=DestroyImage(excerpt_image);\n  return(excerpt_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E x t e n t I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ExtentImage() extends the image as defined by the geometry, gravity, and\n%  image background color.  Set the (x,y) offset of the geometry to move the\n%  original image relative to the extended image.\n%\n%  The format of the ExtentImage method is:\n%\n%      Image *ExtentImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to extend with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ExtentImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n  Image\n    *extent_image;\n\n  /*\n    Allocate extent image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((image->columns == geometry->width) &&\n      (image->rows == geometry->height) &&\n      (geometry->x == 0) && (geometry->y == 0))\n    return(CloneImage(image,0,0,MagickTrue,exception));\n  extent_image=CloneImage(image,geometry->width,geometry->height,MagickTrue,\n    exception);\n  if (extent_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) SetImageBackgroundColor(extent_image,exception);\n  (void) CompositeImage(extent_image,image,image->compose,MagickTrue,\n    -geometry->x,-geometry->y,exception);\n  return(extent_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F l i p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FlipImage() creates a vertical mirror image by reflecting the pixels\n%  around the central x-axis.\n%\n%  The format of the FlipImage method is:\n%\n%      Image *FlipImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *FlipImage(const Image *image,ExceptionInfo *exception)\n{\n#define FlipImageTag  \"Flip/Image\"\n\n  CacheView\n    *flip_view,\n    *image_view;\n\n  Image\n    *flip_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  flip_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (flip_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Flip image.\n  */\n  status=MagickTrue;\n  progress=0;\n  page=image->page;\n  image_view=AcquireVirtualCacheView(image,exception);\n  flip_view=AcquireAuthenticCacheView(flip_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,flip_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) flip_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(flip_view,0,(ssize_t) (flip_image->rows-y-\n      1),flip_image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) flip_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(flip_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(flip_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait flip_traits=GetPixelChannelTraits(flip_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (flip_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(flip_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(flip_image);\n    }\n    if (SyncCacheViewAuthenticPixels(flip_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FlipImage)\n#endif\n        proceed=SetImageProgress(image,FlipImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  flip_view=DestroyCacheView(flip_view);\n  image_view=DestroyCacheView(image_view);\n  flip_image->type=image->type;\n  if (page.height != 0)\n    page.y=(ssize_t) (page.height-flip_image->rows-page.y);\n  flip_image->page=page;\n  if (status == MagickFalse)\n    flip_image=DestroyImage(flip_image);\n  return(flip_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F l o p I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FlopImage() creates a horizontal mirror image by reflecting the pixels\n%  around the central y-axis.\n%\n%  The format of the FlopImage method is:\n%\n%      Image *FlopImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *FlopImage(const Image *image,ExceptionInfo *exception)\n{\n#define FlopImageTag  \"Flop/Image\"\n\n  CacheView\n    *flop_view,\n    *image_view;\n\n  Image\n    *flop_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  flop_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (flop_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Flop each row.\n  */\n  status=MagickTrue;\n  progress=0;\n  page=image->page;\n  image_view=AcquireVirtualCacheView(image,exception);\n  flop_view=AcquireAuthenticCacheView(flop_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,flop_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) flop_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(flop_view,0,y,flop_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    q+=GetPixelChannels(flop_image)*flop_image->columns;\n    for (x=0; x < (ssize_t) flop_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      q-=GetPixelChannels(flop_image);\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait flop_traits=GetPixelChannelTraits(flop_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (flop_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(flop_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(flop_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FlopImage)\n#endif\n        proceed=SetImageProgress(image,FlopImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  flop_view=DestroyCacheView(flop_view);\n  image_view=DestroyCacheView(image_view);\n  flop_image->type=image->type;\n  if (page.width != 0)\n    page.x=(ssize_t) (page.width-flop_image->columns-page.x);\n  flop_image->page=page;\n  if (status == MagickFalse)\n    flop_image=DestroyImage(flop_image);\n  return(flop_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R o l l I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RollImage() offsets an image as defined by x_offset and y_offset.\n%\n%  The format of the RollImage method is:\n%\n%      Image *RollImage(const Image *image,const ssize_t x_offset,\n%        const ssize_t y_offset,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x_offset: the number of columns to roll in the horizontal direction.\n%\n%    o y_offset: the number of rows to roll in the vertical direction.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType CopyImageRegion(Image *destination,const Image *source,  const size_t columns,const size_t rows,const ssize_t sx,const ssize_t sy,\n  const ssize_t dx,const ssize_t dy,ExceptionInfo *exception)\n{\n  CacheView\n    *source_view,\n    *destination_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (columns == 0)\n    return(MagickTrue);\n  status=MagickTrue;\n  source_view=AcquireVirtualCacheView(source,exception);\n  destination_view=AcquireAuthenticCacheView(destination,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(source,destination,rows,1)\n#endif\n  for (y=0; y < (ssize_t) rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    /*\n      Transfer scanline.\n    */\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(source_view,sx,sy+y,columns,1,exception);\n    q=GetCacheViewAuthenticPixels(destination_view,dx,dy+y,columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(source,p) == 0)\n        {\n          SetPixelBackgoundColor(destination,q);\n          p+=GetPixelChannels(source);\n          q+=GetPixelChannels(destination);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(source); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(source,i);\n        PixelTrait source_traits=GetPixelChannelTraits(source,channel);\n        PixelTrait destination_traits=GetPixelChannelTraits(destination,\n          channel);\n        if ((source_traits == UndefinedPixelTrait) ||\n            (destination_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(destination,channel,p[i],q);\n      }\n      p+=GetPixelChannels(source);\n      q+=GetPixelChannels(destination);\n    }\n    sync=SyncCacheViewAuthenticPixels(destination_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n  }\n  destination_view=DestroyCacheView(destination_view);\n  source_view=DestroyCacheView(source_view);\n  return(status);\n}\n\nMagickExport Image *RollImage(const Image *image,const ssize_t x_offset,\n  const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define RollImageTag  \"Roll/Image\"\n\n  Image\n    *roll_image;\n\n  MagickStatusType\n    status;\n\n  RectangleInfo\n    offset;\n\n  /*\n    Initialize roll image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  roll_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (roll_image == (Image *) NULL)\n    return((Image *) NULL);\n  offset.x=x_offset;\n  offset.y=y_offset;\n  while (offset.x < 0)\n    offset.x+=(ssize_t) image->columns;\n  while (offset.x >= (ssize_t) image->columns)\n    offset.x-=(ssize_t) image->columns;\n  while (offset.y < 0)\n    offset.y+=(ssize_t) image->rows;\n  while (offset.y >= (ssize_t) image->rows)\n    offset.y-=(ssize_t) image->rows;\n  /*\n    Roll image.\n  */\n  status=CopyImageRegion(roll_image,image,(size_t) offset.x,\n    (size_t) offset.y,(ssize_t) image->columns-offset.x,(ssize_t) image->rows-\n    offset.y,0,0,exception);\n  (void) SetImageProgress(image,RollImageTag,0,3);\n  status&=CopyImageRegion(roll_image,image,image->columns-offset.x,\n    (size_t) offset.y,0,(ssize_t) image->rows-offset.y,offset.x,0,\n    exception);\n  (void) SetImageProgress(image,RollImageTag,1,3);\n  status&=CopyImageRegion(roll_image,image,(size_t) offset.x,image->rows-\n    offset.y,(ssize_t) image->columns-offset.x,0,0,offset.y,exception);\n  (void) SetImageProgress(image,RollImageTag,2,3);\n  status&=CopyImageRegion(roll_image,image,image->columns-offset.x,image->rows-\n    offset.y,0,0,offset.x,offset.y,exception);\n  (void) SetImageProgress(image,RollImageTag,3,3);\n  roll_image->type=image->type;\n  if (status == MagickFalse)\n    roll_image=DestroyImage(roll_image);\n  return(roll_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S h a v e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ShaveImage() shaves pixels from the image edges.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the ShaveImage method is:\n%\n%      Image *ShaveImage(const Image *image,const RectangleInfo *shave_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o shave_image: Method ShaveImage returns a pointer to the shaved\n%      image.  A null image is returned if there is a memory shortage or\n%      if the image width or height is zero.\n%\n%    o image: the image.\n%\n%    o shave_info: Specifies a pointer to a RectangleInfo which defines the\n%      region of the image to crop.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ShaveImage(const Image *image,\n  const RectangleInfo *shave_info,ExceptionInfo *exception)\n{\n  Image\n    *shave_image;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (((2*shave_info->width) >= image->columns) ||\n      ((2*shave_info->height) >= image->rows))\n    ThrowImageException(OptionWarning,\"GeometryDoesNotContainImage\");\n  SetGeometry(image,&geometry);\n  geometry.width-=2*shave_info->width;\n  geometry.height-=2*shave_info->height;\n  geometry.x=(ssize_t) shave_info->width+image->page.x;\n  geometry.y=(ssize_t) shave_info->height+image->page.y;\n  shave_image=CropImage(image,&geometry,exception);\n  if (shave_image == (Image *) NULL)\n    return((Image *) NULL);\n  shave_image->page.width-=2*shave_info->width;\n  shave_image->page.height-=2*shave_info->height;\n  shave_image->page.x-=(ssize_t) shave_info->width;\n  shave_image->page.y-=(ssize_t) shave_info->height;\n  return(shave_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S p l i c e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SpliceImage() splices a solid color into the image as defined by the\n%  geometry.\n%\n%  The format of the SpliceImage method is:\n%\n%      Image *SpliceImage(const Image *image,const RectangleInfo *geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o geometry: Define the region of the image to splice with members\n%      x, y, width, and height.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SpliceImage(const Image *image,\n  const RectangleInfo *geometry,ExceptionInfo *exception)\n{\n#define SpliceImageTag  \"Splice/Image\"\n\n  CacheView\n    *image_view,\n    *splice_view;\n\n  Image\n    *splice_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    splice_geometry;\n\n  ssize_t\n    columns,\n    y;\n\n  /*\n    Allocate splice image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(geometry != (const RectangleInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  splice_geometry=(*geometry);\n  splice_image=CloneImage(image,image->columns+splice_geometry.width,\n    image->rows+splice_geometry.height,MagickTrue,exception);\n  if (splice_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(splice_image,DirectClass,exception) == MagickFalse)\n    {\n      splice_image=DestroyImage(splice_image);\n      return((Image *) NULL);\n    }\n  if ((IsPixelInfoGray(&splice_image->background_color) == MagickFalse) &&\n      (IsGrayColorspace(splice_image->colorspace) != MagickFalse))\n    (void) SetImageColorspace(splice_image,sRGBColorspace,exception);\n  if ((splice_image->background_color.alpha_trait != UndefinedPixelTrait) &&\n      (splice_image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlpha(splice_image,OpaqueAlpha,exception);\n  (void) SetImageBackgroundColor(splice_image,exception);\n  /*\n    Respect image geometry.\n  */\n  switch (image->gravity)\n  {\n    default:\n    case UndefinedGravity:\n    case NorthWestGravity:\n      break;\n    case NorthGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      break;\n    }\n    case NorthEastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      break;\n    }\n    case WestGravity:\n    {\n      splice_geometry.y+=(ssize_t) splice_geometry.width/2;\n      break;\n    }\n    case CenterGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      splice_geometry.y+=(ssize_t) splice_geometry.height/2;\n      break;\n    }\n    case EastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      splice_geometry.y+=(ssize_t) splice_geometry.height/2;\n      break;\n    }\n    case SouthWestGravity:\n    {\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n    case SouthGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width/2;\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n    case SouthEastGravity:\n    {\n      splice_geometry.x+=(ssize_t) splice_geometry.width;\n      splice_geometry.y+=(ssize_t) splice_geometry.height;\n      break;\n    }\n  }\n  /*\n    Splice image.\n  */\n  status=MagickTrue;\n  progress=0;\n  columns=MagickMin(splice_geometry.x,(ssize_t) splice_image->columns);\n  image_view=AcquireVirtualCacheView(image,exception);\n  splice_view=AcquireAuthenticCacheView(splice_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,splice_image,1,1)\n#endif\n  for (y=0; y < (ssize_t) splice_geometry.y; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,splice_image->columns,1,\n      exception);\n    q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    for ( ; x < (ssize_t) (splice_geometry.x+splice_geometry.width); x++)\n      q+=GetPixelChannels(splice_image);\n    for ( ; x < (ssize_t) splice_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    if (SyncCacheViewAuthenticPixels(splice_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,SpliceImageTag,progress++,\n          splice_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,splice_image,1,1)\n#endif\n  for (y=(ssize_t) (splice_geometry.y+splice_geometry.height);\n       y < (ssize_t) splice_image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    if ((y < 0) || (y >= (ssize_t)splice_image->rows))\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y-(ssize_t) splice_geometry.height,\n      splice_image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    for ( ; x < (ssize_t) (splice_geometry.x+splice_geometry.width); x++)\n      q+=GetPixelChannels(splice_image);\n    for ( ; x < (ssize_t) splice_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(splice_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(splice_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait splice_traits=GetPixelChannelTraits(splice_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (splice_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(splice_image,channel,p[i],q);\n      }\n      SetPixelRed(splice_image,GetPixelRed(image,p),q);\n      SetPixelGreen(splice_image,GetPixelGreen(image,p),q);\n      SetPixelBlue(splice_image,GetPixelBlue(image,p),q);\n      SetPixelAlpha(splice_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(splice_image);\n    }\n    if (SyncCacheViewAuthenticPixels(splice_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,SpliceImageTag,progress++,\n          splice_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  splice_view=DestroyCacheView(splice_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    splice_image=DestroyImage(splice_image);\n  return(splice_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s f o r m I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransformImage() is a convenience method that behaves like ResizeImage() or\n%  CropImage() but accepts scaling and/or cropping information as a region\n%  geometry specification.  If the operation fails, the original image handle\n%  is left as is.\n%\n%  This should only be used for single images.\n%\n%  This function destroys what it assumes to be a single image list.\n%  If the input image is part of a larger list, all other images in that list\n%  will be simply 'lost', not destroyed.\n%\n%  Also if the crop generates a list of images only the first image is resized.\n%  And finally if the crop succeeds and the resize failed, you will get a\n%  cropped image, as well as a 'false' or 'failed' report.\n%\n%  This function and should probably be deprecated in favor of direct calls\n%  to CropImageToTiles() or ResizeImage(), as appropriate.\n%\n%  The format of the TransformImage method is:\n%\n%      MagickBooleanType TransformImage(Image **image,const char *crop_geometry,\n%        const char *image_geometry,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image The transformed image is returned as this parameter.\n%\n%    o crop_geometry: A crop geometry string.  This geometry defines a\n%      subregion of the image to crop.\n%\n%    o image_geometry: An image geometry string.  This geometry defines the\n%      final size of the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType TransformImage(Image **image,\n  const char *crop_geometry,const char *image_geometry,ExceptionInfo *exception)\n{\n  Image\n    *resize_image,\n    *transform_image;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  transform_image=(*image);\n  if (crop_geometry != (const char *) NULL)\n    {\n      Image\n        *crop_image;\n\n      /*\n        Crop image to a user specified size.\n      */\n      crop_image=CropImageToTiles(*image,crop_geometry,exception);\n      if (crop_image == (Image *) NULL)\n        transform_image=CloneImage(*image,0,0,MagickTrue,exception);\n      else\n        {\n          transform_image=DestroyImage(transform_image);\n          transform_image=GetFirstImageInList(crop_image);\n        }\n      *image=transform_image;\n    }\n  if (image_geometry == (const char *) NULL)\n    return(MagickTrue);\n\n  /*\n    Scale image to a user specified size.\n  */\n  flags=ParseRegionGeometry(transform_image,image_geometry,&geometry,exception);\n  (void) flags;\n  if ((transform_image->columns == geometry.width) &&\n      (transform_image->rows == geometry.height))\n    return(MagickTrue);\n  resize_image=ResizeImage(transform_image,geometry.width,geometry.height,\n    transform_image->filter,exception);\n  if (resize_image == (Image *) NULL)\n    return(MagickFalse);\n  transform_image=DestroyImage(transform_image);\n  transform_image=resize_image;\n  *image=transform_image;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s f o r m I m a g e s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransformImages() calls TransformImage() on each image of a sequence.\n%\n%  The format of the TransformImage method is:\n%\n%      MagickBooleanType TransformImages(Image **image,\n%        const char *crop_geometry,const char *image_geometry,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image The transformed image is returned as this parameter.\n%\n%    o crop_geometry: A crop geometry string.  This geometry defines a\n%      subregion of the image to crop.\n%\n%    o image_geometry: An image geometry string.  This geometry defines the\n%      final size of the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType TransformImages(Image **images,\n  const char *crop_geometry,const char *image_geometry,ExceptionInfo *exception)\n{\n  Image\n    *image,\n    **image_list,\n    *transform_images;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  assert(images != (Image **) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  image_list=ImageListToArray(*images,exception);\n  if (image_list == (Image **) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  transform_images=NewImageList();\n  for (i=0; image_list[i] != (Image *) NULL; i++)\n  {\n    image=image_list[i];\n    status&=TransformImage(&image,crop_geometry,image_geometry,exception);\n    AppendImageToList(&transform_images,image);\n  }\n  *images=transform_images;\n  image_list=(Image **) RelinquishMagickMemory(image_list);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s p o s e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransposeImage() creates a horizontal mirror image by reflecting the pixels\n%  around the central y-axis while rotating them by 90 degrees.\n%\n%  The format of the TransposeImage method is:\n%\n%      Image *TransposeImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TransposeImage(const Image *image,ExceptionInfo *exception)\n{\n#define TransposeImageTag  \"Transpose/Image\"\n\n  CacheView\n    *image_view,\n    *transpose_view;\n\n  Image\n    *transpose_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  transpose_image=CloneImage(image,image->rows,image->columns,MagickTrue,\n    exception);\n  if (transpose_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Transpose image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  transpose_view=AcquireAuthenticCacheView(transpose_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,transpose_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,(ssize_t) image->rows-y-1,\n      image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(transpose_view,(ssize_t) (image->rows-y-1),\n      0,1,transpose_image->rows,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          SetPixelBackgoundColor(transpose_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(transpose_image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait transpose_traits=GetPixelChannelTraits(transpose_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (transpose_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(transpose_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(transpose_image);\n    }\n    if (SyncCacheViewAuthenticPixels(transpose_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransposeImage)\n#endif\n        proceed=SetImageProgress(image,TransposeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  transpose_view=DestroyCacheView(transpose_view);\n  image_view=DestroyCacheView(image_view);\n  transpose_image->type=image->type;\n  page=transpose_image->page;\n  Swap(page.width,page.height);\n  Swap(page.x,page.y);\n  transpose_image->page=page;\n  if (status == MagickFalse)\n    transpose_image=DestroyImage(transpose_image);\n  return(transpose_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r a n s v e r s e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TransverseImage() creates a vertical mirror image by reflecting the pixels\n%  around the central x-axis while rotating them by 270 degrees.\n%\n%  The format of the TransverseImage method is:\n%\n%      Image *TransverseImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TransverseImage(const Image *image,ExceptionInfo *exception)\n{\n#define TransverseImageTag  \"Transverse/Image\"\n\n  CacheView\n    *image_view,\n    *transverse_view;\n\n  Image\n    *transverse_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  transverse_image=CloneImage(image,image->rows,image->columns,MagickTrue,\n    exception);\n  if (transverse_image == (Image *) NULL)\n    return((Image *) NULL);\n  /*\n    Transverse image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  transverse_view=AcquireAuthenticCacheView(transverse_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,transverse_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(transverse_view,(ssize_t) (image->rows-y-1),\n      0,1,transverse_image->rows,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    q+=GetPixelChannels(transverse_image)*image->columns;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      q-=GetPixelChannels(transverse_image);\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait transverse_traits=GetPixelChannelTraits(transverse_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (transverse_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(transverse_image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n    }\n    sync=SyncCacheViewAuthenticPixels(transverse_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TransverseImage)\n#endif\n        proceed=SetImageProgress(image,TransverseImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  transverse_view=DestroyCacheView(transverse_view);\n  image_view=DestroyCacheView(image_view);\n  transverse_image->type=image->type;\n  page=transverse_image->page;\n  Swap(page.width,page.height);\n  Swap(page.x,page.y);\n  if (page.width != 0)\n    page.x=(ssize_t) (page.width-transverse_image->columns-page.x);\n  if (page.height != 0)\n    page.y=(ssize_t) (page.height-transverse_image->rows-page.y);\n  transverse_image->page=page;\n  if (status == MagickFalse)\n    transverse_image=DestroyImage(transverse_image);\n  return(transverse_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T r i m I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TrimImage() trims pixels from the image edges.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the TrimImage method is:\n%\n%      Image *TrimImage(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TrimImage(const Image *image,ExceptionInfo *exception)\n{\n  RectangleInfo\n    geometry;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  geometry=GetImageBoundingBox(image,exception);\n  if ((geometry.width == 0) || (geometry.height == 0))\n    {\n      Image\n        *crop_image;\n\n      crop_image=CloneImage(image,1,1,MagickTrue,exception);\n      if (crop_image == (Image *) NULL)\n        return((Image *) NULL);\n      crop_image->background_color.alpha=(Quantum) TransparentAlpha;\n      crop_image->alpha_trait=BlendPixelTrait;\n      (void) SetImageBackgroundColor(crop_image,exception);\n      crop_image->page=image->page;\n      crop_image->page.x=(-1);\n      crop_image->page.y=(-1);\n      return(crop_image);\n    }\n  geometry.x+=image->page.x;\n  geometry.y+=image->page.y;\n  return(CropImage(image,&geometry,exception));\n}\n"], "filenames": ["MagickCore/transform.c"], "buggy_code_start_loc": [1737], "buggy_code_end_loc": [1959], "fixing_code_start_loc": [1738], "fixing_code_end_loc": [1962], "type": "CWE-125", "message": "The SpliceImage function in MagickCore/transform.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (application crash) via a crafted png file.", "other": {"cve": {"id": "CVE-2015-8897", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T19:59:00.283", "lastModified": "2018-05-18T01:29:02.993", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The SpliceImage function in MagickCore/transform.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (application crash) via a crafted png file."}, {"lang": "es", "value": "La funci\u00f3n SpliceImage en MagickCore/transform.c en ImageMagick en versiones anteriores a 6.9.2-4 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo png manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.2-3", "matchCriteriaId": "B92D28C2-8E57-46C6-B2AF-6F1EB575E6F3"}]}]}], "references": [{"url": "http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=28466", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/02/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/91030", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1237", "source": "cve@mitre.org"}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/7b1cf5784b5bcd85aa9293ecf56769f68c037231", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/7b1cf5784b5bcd85aa9293ecf56769f68c037231"}}