{"buggy_code": ["package middleware\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/ui\"\n\t\"github.com/gin-gonic/gin\"\n\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\nvar ctxUUIDKey = \"ctxUuidKey\"\n\n// AuthUserMiddleware auth user middleware\ntype AuthUserMiddleware struct {\n\tauthService           *auth.AuthService\n\tsiteInfoCommonService siteinfo_common.SiteInfoCommonService\n}\n\n// NewAuthUserMiddleware new auth user middleware\nfunc NewAuthUserMiddleware(\n\tauthService *auth.AuthService,\n\tsiteInfoCommonService siteinfo_common.SiteInfoCommonService) *AuthUserMiddleware {\n\treturn &AuthUserMiddleware{\n\t\tauthService:           authService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// Auth get token and auth user, set user info to context if user is already login\nfunc (am *AuthUserMiddleware) Auth() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\ttoken := ExtractToken(ctx)\n\t\tif len(token) == 0 {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tuserInfo, err := am.authService.GetUserCacheInfo(ctx, token)\n\t\tif err != nil {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tif userInfo != nil {\n\t\t\tctx.Set(ctxUUIDKey, userInfo)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\n// EjectUserBySiteInfo if admin config the site can access by nologin user, eject user.\nfunc (am *AuthUserMiddleware) EjectUserBySiteInfo() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tmustLogin := false\n\t\tsiteInfo, _ := am.siteInfoCommonService.GetSiteLogin(ctx)\n\t\tif siteInfo != nil {\n\t\t\tmustLogin = siteInfo.LoginRequired\n\t\t}\n\t\tif !mustLogin {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\t_, isLogin := ctx.Get(ctxUUIDKey)\n\t\tif !isLogin {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\n// MustAuth auth user info. If the user does not log in, an unauthenticated error is displayed\nfunc (am *AuthUserMiddleware) MustAuth() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\ttoken := ExtractToken(ctx)\n\t\tif len(token) == 0 {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tuserInfo, err := am.authService.GetUserCacheInfo(ctx, token)\n\t\tif err != nil || userInfo == nil {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo.EmailStatus != entity.EmailStatusAvailable {\n\t\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailNeedToBeVerified),\n\t\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeInactive})\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo.UserStatus == entity.UserStatusSuspended {\n\t\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.UserSuspended),\n\t\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeUserSuspended})\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo.UserStatus == entity.UserStatusDeleted {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tctx.Set(ctxUUIDKey, userInfo)\n\t\tctx.Next()\n\t}\n}\n\nfunc (am *AuthUserMiddleware) AdminAuth() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\ttoken := ExtractToken(ctx)\n\t\tif len(token) == 0 {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tuserInfo, err := am.authService.GetAdminUserCacheInfo(ctx, token)\n\t\tif err != nil {\n\t\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo != nil {\n\t\t\tif userInfo.UserStatus == entity.UserStatusDeleted {\n\t\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\t\tctx.Abort()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.Set(ctxUUIDKey, userInfo)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc (am *AuthUserMiddleware) CheckPrivateMode() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tresp, err := am.siteInfoCommonService.GetSiteLogin(ctx)\n\t\tif err != nil {\n\t\t\tShowIndexPage(ctx)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif resp.LoginRequired {\n\t\t\tShowIndexPage(ctx)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tctx.Next()\n\t}\n}\nfunc ShowIndexPage(ctx *gin.Context) {\n\tctx.Header(\"content-type\", \"text/html;charset=utf-8\")\n\tctx.Header(\"X-Frame-Options\", \"DENY\")\n\tfile, err := ui.Build.ReadFile(\"build/index.html\")\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tctx.Status(http.StatusNotFound)\n\t\treturn\n\t}\n\tctx.String(http.StatusOK, string(file))\n}\n\n// GetLoginUserIDFromContext get user id from context\nfunc GetLoginUserIDFromContext(ctx *gin.Context) (userID string) {\n\tuserInfo := GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\treturn \"\"\n\t}\n\treturn userInfo.UserID\n}\n\n// GetIsAdminFromContext get user is admin from context\nfunc GetIsAdminFromContext(ctx *gin.Context) (isAdmin bool) {\n\tuserInfo := GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\treturn false\n\t}\n\treturn userInfo.RoleID == role.RoleAdminID\n}\n\n// GetUserInfoFromContext get user info from context\nfunc GetUserInfoFromContext(ctx *gin.Context) (u *entity.UserCacheInfo) {\n\tuserInfo, exist := ctx.Get(ctxUUIDKey)\n\tif !exist {\n\t\treturn nil\n\t}\n\tu, ok := userInfo.(*entity.UserCacheInfo)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn u\n}\n\nfunc GetUserIsAdminModerator(ctx *gin.Context) (isAdminModerator bool) {\n\tuserInfo, exist := ctx.Get(ctxUUIDKey)\n\tif !exist {\n\t\treturn false\n\t}\n\tu, ok := userInfo.(*entity.UserCacheInfo)\n\tif !ok {\n\t\treturn false\n\t}\n\tif u.RoleID == role.RoleAdminID || u.RoleID == role.RoleModeratorID {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetLoginUserIDInt64FromContext(ctx *gin.Context) (userID int64) {\n\tuserIDStr := GetLoginUserIDFromContext(ctx)\n\treturn converter.StringToInt64(userIDStr)\n}\n\n// ExtractToken extract token from context\nfunc ExtractToken(ctx *gin.Context) (token string) {\n\ttoken = ctx.GetHeader(\"Authorization\")\n\tif len(token) == 0 {\n\t\ttoken = ctx.Query(\"Authorization\")\n\t}\n\treturn strings.TrimPrefix(token, \"Bearer \")\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"time\"\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// AnswerActivityRepo answer accepted\ntype AnswerActivityRepo struct {\n\tdata                     *data.Data\n\tactivityRepo             activity_common.ActivityRepo\n\tuserRankRepo             rank.UserRankRepo\n\tnotificationQueueService notice_queue.NotificationQueueService\n}\n\n// NewAnswerActivityRepo new repository\nfunc NewAnswerActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tnotificationQueueService notice_queue.NotificationQueueService,\n) activity.AnswerActivityRepo {\n\treturn &AnswerActivityRepo{\n\t\tdata:                     data,\n\t\tactivityRepo:             activityRepo,\n\t\tuserRankRepo:             userRankRepo,\n\t\tnotificationQueueService: notificationQueueService,\n\t}\n}\n\nfunc (ar *AnswerActivityRepo) SaveAcceptAnswerActivity(ctx context.Context, op *schema.AcceptAnswerOperationInfo) (\n\terr error) {\n\t// pre check\n\tnoNeedToDo, err := ar.activityPreCheck(ctx, op)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif noNeedToDo {\n\t\treturn nil\n\t}\n\n\tar.data.DB.ShowSQL(true)\n\t// save activity\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuserInfoMapping, err := ar.acquireUserInfo(session, op.GetUserIDs())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.saveActivitiesAvailable(session, op)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.changeUserRank(ctx, session, op, userInfoMapping)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\n\t// notification\n\tar.sendAcceptAnswerNotification(ctx, op)\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) SaveCancelAcceptAnswerActivity(ctx context.Context, op *schema.AcceptAnswerOperationInfo) (\n\terr error) {\n\t// pre check\n\tactivities, err := ar.getExistActivity(ctx, op)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar userIDs []string\n\tfor _, act := range activities {\n\t\tif act.Cancelled == entity.ActivityCancelled {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, act.UserID)\n\t}\n\tif len(userIDs) == 0 {\n\t\treturn nil\n\t}\n\n\t// save activity\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuserInfoMapping, err := ar.acquireUserInfo(session, userIDs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.cancelActivities(session, activities)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.rollbackUserRank(ctx, session, activities, userInfoMapping)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\n\t// notification\n\tar.sendCancelAcceptAnswerNotification(ctx, op)\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) activityPreCheck(ctx context.Context, op *schema.AcceptAnswerOperationInfo) (\n\tnoNeedToDo bool, err error) {\n\tactivities, err := ar.getExistActivity(ctx, op)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdone := 0\n\tfor _, act := range activities {\n\t\tif act.Cancelled == entity.ActivityAvailable {\n\t\t\tdone++\n\t\t}\n\t}\n\treturn done == len(op.Activities), nil\n}\n\nfunc (ar *AnswerActivityRepo) acquireUserInfo(session *xorm.Session, userIDs []string) (map[string]*entity.User, error) {\n\tus := make([]*entity.User, 0)\n\terr := session.In(\"id\", userIDs).ForUpdate().Find(&us)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn nil, err\n\t}\n\n\tusers := make(map[string]*entity.User, 0)\n\tfor _, u := range us {\n\t\tusers[u.ID] = u\n\t}\n\treturn users, nil\n}\n\n// saveActivitiesAvailable save activities\n// If activity not exist it will be created or else will be updated\n// If this activity is already exist, set activity rank to 0\n// So after this function, the activity rank will be correct for update user rank\nfunc (ar *AnswerActivityRepo) saveActivitiesAvailable(session *xorm.Session, op *schema.AcceptAnswerOperationInfo) (\n\terr error) {\n\tfor _, act := range op.Activities {\n\t\texistsActivity := &entity.Activity{}\n\t\texist, err := session.\n\t\t\tWhere(builder.Eq{\"object_id\": op.AnswerObjectID}).\n\t\t\tAnd(builder.Eq{\"user_id\": act.ActivityUserID}).\n\t\t\tAnd(builder.Eq{\"trigger_user_id\": act.TriggerUserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": act.ActivityType}).\n\t\t\tGet(existsActivity)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif exist && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\tact.Rank = 0\n\t\t\tcontinue\n\t\t}\n\t\tif exist {\n\t\t\tbean := &entity.Activity{\n\t\t\t\tCancelled: entity.ActivityAvailable,\n\t\t\t\tRank:      act.Rank,\n\t\t\t\tHasRank:   act.HasRank(),\n\t\t\t}\n\t\t\tsession.Where(\"id = ?\", existsActivity.ID)\n\t\t\tif _, err = session.Cols(\"`cancelled`\", \"`rank`\", \"`has_rank`\").Update(bean); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tinsertActivity := entity.Activity{\n\t\t\t\tObjectID:         op.AnswerObjectID,\n\t\t\t\tOriginalObjectID: act.OriginalObjectID,\n\t\t\t\tUserID:           act.ActivityUserID,\n\t\t\t\tTriggerUserID:    converter.StringToInt64(act.TriggerUserID),\n\t\t\t\tActivityType:     act.ActivityType,\n\t\t\t\tRank:             act.Rank,\n\t\t\t\tHasRank:          act.HasRank(),\n\t\t\t\tCancelled:        entity.ActivityAvailable,\n\t\t\t}\n\t\t\t_, err = session.Insert(&insertActivity)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// cancelActivities cancel activities\n// If this activity is already cancelled, set activity rank to 0\n// So after this function, the activity rank will be correct for update user rank\nfunc (ar *AnswerActivityRepo) cancelActivities(session *xorm.Session, activities []*entity.Activity) (err error) {\n\tfor _, act := range activities {\n\t\tt := &entity.Activity{}\n\t\texist, err := session.ID(act.ID).Get(t)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tif !exist {\n\t\t\tlog.Error(fmt.Errorf(\"%s activity not exist\", act.ID))\n\t\t\treturn fmt.Errorf(\"%s activity not exist\", act.ID)\n\t\t}\n\t\t//  If this activity is already cancelled, set activity rank to 0\n\t\tif t.Cancelled == entity.ActivityCancelled {\n\t\t\tact.Rank = 0\n\t\t}\n\t\tif _, err = session.ID(act.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\tUpdate(&entity.Activity{\n\t\t\t\tCancelled:   entity.ActivityCancelled,\n\t\t\t\tCancelledAt: time.Now(),\n\t\t\t}); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) changeUserRank(ctx context.Context, session *xorm.Session,\n\top *schema.AcceptAnswerOperationInfo,\n\tuserInfoMapping map[string]*entity.User) (err error) {\n\tfor _, act := range op.Activities {\n\t\tif act.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tuser := userInfoMapping[act.ActivityUserID]\n\t\tif user == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = ar.userRankRepo.ChangeUserRank(ctx, session,\n\t\t\tact.ActivityUserID, user.Rank, act.Rank); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) rollbackUserRank(ctx context.Context, session *xorm.Session,\n\tactivities []*entity.Activity,\n\tuserInfoMapping map[string]*entity.User) (err error) {\n\tfor _, act := range activities {\n\t\tif act.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tuser := userInfoMapping[act.UserID]\n\t\tif user == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = ar.userRankRepo.ChangeUserRank(ctx, session,\n\t\t\tact.UserID, user.Rank, -act.Rank); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) getExistActivity(ctx context.Context, op *schema.AcceptAnswerOperationInfo) ([]*entity.Activity, error) {\n\tvar activities []*entity.Activity\n\tfor _, action := range op.Activities {\n\t\tt := &entity.Activity{}\n\t\texist, err := ar.data.DB.Context(ctx).\n\t\t\tWhere(builder.Eq{\"user_id\": action.ActivityUserID}).\n\t\t\tAnd(builder.Eq{\"trigger_user_id\": action.TriggerUserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": action.ActivityType}).\n\t\t\tAnd(builder.Eq{\"object_id\": op.AnswerObjectID}).\n\t\t\tGet(t)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif exist {\n\t\t\tactivities = append(activities, t)\n\t\t}\n\t}\n\treturn activities, nil\n}\n\nfunc (ar *AnswerActivityRepo) sendAcceptAnswerNotification(\n\tctx context.Context, op *schema.AcceptAnswerOperationInfo) {\n\tfor _, act := range op.Activities {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       op.AnswerObjectID,\n\t\t\tReceiverUserID: act.ActivityUserID,\n\t\t}\n\t\tif act.ActivityUserID == op.QuestionUserID {\n\t\t\tmsg.TriggerUserID = op.AnswerUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t} else {\n\t\t\tmsg.TriggerUserID = op.QuestionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\n\tfor _, act := range op.Activities {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.ActivityUserID,\n\t\t\tType:           schema.NotificationTypeInbox,\n\t\t\tObjectID:       op.AnswerObjectID,\n\t\t}\n\t\tif act.ActivityUserID != op.QuestionUserID {\n\t\t\tmsg.TriggerUserID = op.QuestionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t\tmsg.NotificationAction = constant.NotificationAcceptAnswer\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n}\n\nfunc (ar *AnswerActivityRepo) sendCancelAcceptAnswerNotification(\n\tctx context.Context, op *schema.AcceptAnswerOperationInfo) {\n\tfor _, act := range op.Activities {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.ActivityUserID,\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       op.AnswerObjectID,\n\t\t}\n\t\tif act.ActivityUserID == op.QuestionObjectID {\n\t\t\tmsg.TriggerUserID = op.AnswerObjectID\n\t\t\tmsg.ObjectType = constant.QuestionObjectType\n\t\t} else {\n\t\t\tmsg.TriggerUserID = op.QuestionObjectID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n}\n"], "fixing_code": ["package middleware\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/ui\"\n\t\"github.com/gin-gonic/gin\"\n\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\nvar ctxUUIDKey = \"ctxUuidKey\"\n\n// AuthUserMiddleware auth user middleware\ntype AuthUserMiddleware struct {\n\tauthService           *auth.AuthService\n\tsiteInfoCommonService siteinfo_common.SiteInfoCommonService\n}\n\n// NewAuthUserMiddleware new auth user middleware\nfunc NewAuthUserMiddleware(\n\tauthService *auth.AuthService,\n\tsiteInfoCommonService siteinfo_common.SiteInfoCommonService) *AuthUserMiddleware {\n\treturn &AuthUserMiddleware{\n\t\tauthService:           authService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// Auth get token and auth user, set user info to context if user is already login\nfunc (am *AuthUserMiddleware) Auth() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\ttoken := ExtractToken(ctx)\n\t\tif len(token) == 0 {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tuserInfo, err := am.authService.GetUserCacheInfo(ctx, token)\n\t\tif err != nil {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tif userInfo != nil {\n\t\t\tctx.Set(ctxUUIDKey, userInfo)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\n// EjectUserBySiteInfo if admin config the site can access by nologin user, eject user.\nfunc (am *AuthUserMiddleware) EjectUserBySiteInfo() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tmustLogin := false\n\t\tsiteInfo, _ := am.siteInfoCommonService.GetSiteLogin(ctx)\n\t\tif siteInfo != nil {\n\t\t\tmustLogin = siteInfo.LoginRequired\n\t\t}\n\t\tif !mustLogin {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\t_, isLogin := ctx.Get(ctxUUIDKey)\n\t\tif !isLogin {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\n// MustAuth auth user info. If the user does not log in, an unauthenticated error is displayed\nfunc (am *AuthUserMiddleware) MustAuth() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\ttoken := ExtractToken(ctx)\n\t\tif len(token) == 0 {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tuserInfo, err := am.authService.GetUserCacheInfo(ctx, token)\n\t\tif err != nil || userInfo == nil {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo.EmailStatus != entity.EmailStatusAvailable {\n\t\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailNeedToBeVerified),\n\t\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeInactive})\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo.UserStatus == entity.UserStatusSuspended {\n\t\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.UserSuspended),\n\t\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeUserSuspended})\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo.UserStatus == entity.UserStatusDeleted {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tctx.Set(ctxUUIDKey, userInfo)\n\t\tctx.Next()\n\t}\n}\n\nfunc (am *AuthUserMiddleware) AdminAuth() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\ttoken := ExtractToken(ctx)\n\t\tif len(token) == 0 {\n\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tuserInfo, err := am.authService.GetAdminUserCacheInfo(ctx, token)\n\t\tif err != nil || userInfo == nil {\n\t\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.UnauthorizedError), nil)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif userInfo != nil {\n\t\t\tif userInfo.UserStatus == entity.UserStatusDeleted {\n\t\t\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\t\t\tctx.Abort()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.Set(ctxUUIDKey, userInfo)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc (am *AuthUserMiddleware) CheckPrivateMode() gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tresp, err := am.siteInfoCommonService.GetSiteLogin(ctx)\n\t\tif err != nil {\n\t\t\tShowIndexPage(ctx)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tif resp.LoginRequired {\n\t\t\tShowIndexPage(ctx)\n\t\t\tctx.Abort()\n\t\t\treturn\n\t\t}\n\t\tctx.Next()\n\t}\n}\nfunc ShowIndexPage(ctx *gin.Context) {\n\tctx.Header(\"content-type\", \"text/html;charset=utf-8\")\n\tctx.Header(\"X-Frame-Options\", \"DENY\")\n\tfile, err := ui.Build.ReadFile(\"build/index.html\")\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tctx.Status(http.StatusNotFound)\n\t\treturn\n\t}\n\tctx.String(http.StatusOK, string(file))\n}\n\n// GetLoginUserIDFromContext get user id from context\nfunc GetLoginUserIDFromContext(ctx *gin.Context) (userID string) {\n\tuserInfo := GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\treturn \"\"\n\t}\n\treturn userInfo.UserID\n}\n\n// GetIsAdminFromContext get user is admin from context\nfunc GetIsAdminFromContext(ctx *gin.Context) (isAdmin bool) {\n\tuserInfo := GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\treturn false\n\t}\n\treturn userInfo.RoleID == role.RoleAdminID\n}\n\n// GetUserInfoFromContext get user info from context\nfunc GetUserInfoFromContext(ctx *gin.Context) (u *entity.UserCacheInfo) {\n\tuserInfo, exist := ctx.Get(ctxUUIDKey)\n\tif !exist {\n\t\treturn nil\n\t}\n\tu, ok := userInfo.(*entity.UserCacheInfo)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn u\n}\n\nfunc GetUserIsAdminModerator(ctx *gin.Context) (isAdminModerator bool) {\n\tuserInfo, exist := ctx.Get(ctxUUIDKey)\n\tif !exist {\n\t\treturn false\n\t}\n\tu, ok := userInfo.(*entity.UserCacheInfo)\n\tif !ok {\n\t\treturn false\n\t}\n\tif u.RoleID == role.RoleAdminID || u.RoleID == role.RoleModeratorID {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetLoginUserIDInt64FromContext(ctx *gin.Context) (userID int64) {\n\tuserIDStr := GetLoginUserIDFromContext(ctx)\n\treturn converter.StringToInt64(userIDStr)\n}\n\n// ExtractToken extract token from context\nfunc ExtractToken(ctx *gin.Context) (token string) {\n\ttoken = ctx.GetHeader(\"Authorization\")\n\tif len(token) == 0 {\n\t\ttoken = ctx.Query(\"Authorization\")\n\t}\n\treturn strings.TrimPrefix(token, \"Bearer \")\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"time\"\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// AnswerActivityRepo answer accepted\ntype AnswerActivityRepo struct {\n\tdata                     *data.Data\n\tactivityRepo             activity_common.ActivityRepo\n\tuserRankRepo             rank.UserRankRepo\n\tnotificationQueueService notice_queue.NotificationQueueService\n}\n\n// NewAnswerActivityRepo new repository\nfunc NewAnswerActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tnotificationQueueService notice_queue.NotificationQueueService,\n) activity.AnswerActivityRepo {\n\treturn &AnswerActivityRepo{\n\t\tdata:                     data,\n\t\tactivityRepo:             activityRepo,\n\t\tuserRankRepo:             userRankRepo,\n\t\tnotificationQueueService: notificationQueueService,\n\t}\n}\n\nfunc (ar *AnswerActivityRepo) SaveAcceptAnswerActivity(ctx context.Context, op *schema.AcceptAnswerOperationInfo) (\n\terr error) {\n\t// pre check\n\tnoNeedToDo, err := ar.activityPreCheck(ctx, op)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif noNeedToDo {\n\t\treturn nil\n\t}\n\n\t// save activity\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuserInfoMapping, err := ar.acquireUserInfo(session, op.GetUserIDs())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.saveActivitiesAvailable(session, op)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.changeUserRank(ctx, session, op, userInfoMapping)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\n\t// notification\n\tar.sendAcceptAnswerNotification(ctx, op)\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) SaveCancelAcceptAnswerActivity(ctx context.Context, op *schema.AcceptAnswerOperationInfo) (\n\terr error) {\n\t// pre check\n\tactivities, err := ar.getExistActivity(ctx, op)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar userIDs []string\n\tfor _, act := range activities {\n\t\tif act.Cancelled == entity.ActivityCancelled {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, act.UserID)\n\t}\n\tif len(userIDs) == 0 {\n\t\treturn nil\n\t}\n\n\t// save activity\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuserInfoMapping, err := ar.acquireUserInfo(session, userIDs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.cancelActivities(session, activities)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = ar.rollbackUserRank(ctx, session, activities, userInfoMapping)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\n\t// notification\n\tar.sendCancelAcceptAnswerNotification(ctx, op)\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) activityPreCheck(ctx context.Context, op *schema.AcceptAnswerOperationInfo) (\n\tnoNeedToDo bool, err error) {\n\tactivities, err := ar.getExistActivity(ctx, op)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdone := 0\n\tfor _, act := range activities {\n\t\tif act.Cancelled == entity.ActivityAvailable {\n\t\t\tdone++\n\t\t}\n\t}\n\treturn done == len(op.Activities), nil\n}\n\nfunc (ar *AnswerActivityRepo) acquireUserInfo(session *xorm.Session, userIDs []string) (map[string]*entity.User, error) {\n\tus := make([]*entity.User, 0)\n\terr := session.In(\"id\", userIDs).ForUpdate().Find(&us)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn nil, err\n\t}\n\n\tusers := make(map[string]*entity.User, 0)\n\tfor _, u := range us {\n\t\tusers[u.ID] = u\n\t}\n\treturn users, nil\n}\n\n// saveActivitiesAvailable save activities\n// If activity not exist it will be created or else will be updated\n// If this activity is already exist, set activity rank to 0\n// So after this function, the activity rank will be correct for update user rank\nfunc (ar *AnswerActivityRepo) saveActivitiesAvailable(session *xorm.Session, op *schema.AcceptAnswerOperationInfo) (\n\terr error) {\n\tfor _, act := range op.Activities {\n\t\texistsActivity := &entity.Activity{}\n\t\texist, err := session.\n\t\t\tWhere(builder.Eq{\"object_id\": op.AnswerObjectID}).\n\t\t\tAnd(builder.Eq{\"user_id\": act.ActivityUserID}).\n\t\t\tAnd(builder.Eq{\"trigger_user_id\": act.TriggerUserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": act.ActivityType}).\n\t\t\tGet(existsActivity)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif exist && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\tact.Rank = 0\n\t\t\tcontinue\n\t\t}\n\t\tif exist {\n\t\t\tbean := &entity.Activity{\n\t\t\t\tCancelled: entity.ActivityAvailable,\n\t\t\t\tRank:      act.Rank,\n\t\t\t\tHasRank:   act.HasRank(),\n\t\t\t}\n\t\t\tsession.Where(\"id = ?\", existsActivity.ID)\n\t\t\tif _, err = session.Cols(\"`cancelled`\", \"`rank`\", \"`has_rank`\").Update(bean); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tinsertActivity := entity.Activity{\n\t\t\t\tObjectID:         op.AnswerObjectID,\n\t\t\t\tOriginalObjectID: act.OriginalObjectID,\n\t\t\t\tUserID:           act.ActivityUserID,\n\t\t\t\tTriggerUserID:    converter.StringToInt64(act.TriggerUserID),\n\t\t\t\tActivityType:     act.ActivityType,\n\t\t\t\tRank:             act.Rank,\n\t\t\t\tHasRank:          act.HasRank(),\n\t\t\t\tCancelled:        entity.ActivityAvailable,\n\t\t\t}\n\t\t\t_, err = session.Insert(&insertActivity)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// cancelActivities cancel activities\n// If this activity is already cancelled, set activity rank to 0\n// So after this function, the activity rank will be correct for update user rank\nfunc (ar *AnswerActivityRepo) cancelActivities(session *xorm.Session, activities []*entity.Activity) (err error) {\n\tfor _, act := range activities {\n\t\tt := &entity.Activity{}\n\t\texist, err := session.ID(act.ID).Get(t)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tif !exist {\n\t\t\tlog.Error(fmt.Errorf(\"%s activity not exist\", act.ID))\n\t\t\treturn fmt.Errorf(\"%s activity not exist\", act.ID)\n\t\t}\n\t\t//  If this activity is already cancelled, set activity rank to 0\n\t\tif t.Cancelled == entity.ActivityCancelled {\n\t\t\tact.Rank = 0\n\t\t}\n\t\tif _, err = session.ID(act.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\tUpdate(&entity.Activity{\n\t\t\t\tCancelled:   entity.ActivityCancelled,\n\t\t\t\tCancelledAt: time.Now(),\n\t\t\t}); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) changeUserRank(ctx context.Context, session *xorm.Session,\n\top *schema.AcceptAnswerOperationInfo,\n\tuserInfoMapping map[string]*entity.User) (err error) {\n\tfor _, act := range op.Activities {\n\t\tif act.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tuser := userInfoMapping[act.ActivityUserID]\n\t\tif user == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = ar.userRankRepo.ChangeUserRank(ctx, session,\n\t\t\tact.ActivityUserID, user.Rank, act.Rank); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) rollbackUserRank(ctx context.Context, session *xorm.Session,\n\tactivities []*entity.Activity,\n\tuserInfoMapping map[string]*entity.User) (err error) {\n\tfor _, act := range activities {\n\t\tif act.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tuser := userInfoMapping[act.UserID]\n\t\tif user == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = ar.userRankRepo.ChangeUserRank(ctx, session,\n\t\t\tact.UserID, user.Rank, -act.Rank); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ar *AnswerActivityRepo) getExistActivity(ctx context.Context, op *schema.AcceptAnswerOperationInfo) ([]*entity.Activity, error) {\n\tvar activities []*entity.Activity\n\tfor _, action := range op.Activities {\n\t\tt := &entity.Activity{}\n\t\texist, err := ar.data.DB.Context(ctx).\n\t\t\tWhere(builder.Eq{\"user_id\": action.ActivityUserID}).\n\t\t\tAnd(builder.Eq{\"trigger_user_id\": action.TriggerUserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": action.ActivityType}).\n\t\t\tAnd(builder.Eq{\"object_id\": op.AnswerObjectID}).\n\t\t\tGet(t)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif exist {\n\t\t\tactivities = append(activities, t)\n\t\t}\n\t}\n\treturn activities, nil\n}\n\nfunc (ar *AnswerActivityRepo) sendAcceptAnswerNotification(\n\tctx context.Context, op *schema.AcceptAnswerOperationInfo) {\n\tfor _, act := range op.Activities {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       op.AnswerObjectID,\n\t\t\tReceiverUserID: act.ActivityUserID,\n\t\t\tTriggerUserID:  act.TriggerUserID,\n\t\t}\n\t\tif act.ActivityUserID == op.QuestionUserID {\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t} else {\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\n\tfor _, act := range op.Activities {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.ActivityUserID,\n\t\t\tType:           schema.NotificationTypeInbox,\n\t\t\tObjectID:       op.AnswerObjectID,\n\t\t\tTriggerUserID:  op.TriggerUserID,\n\t\t}\n\t\tif act.ActivityUserID != op.QuestionUserID {\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t\tmsg.NotificationAction = constant.NotificationAcceptAnswer\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n}\n\nfunc (ar *AnswerActivityRepo) sendCancelAcceptAnswerNotification(\n\tctx context.Context, op *schema.AcceptAnswerOperationInfo) {\n\tfor _, act := range op.Activities {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tTriggerUserID:  act.TriggerUserID,\n\t\t\tReceiverUserID: act.ActivityUserID,\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       op.AnswerObjectID,\n\t\t}\n\t\tif act.ActivityUserID == op.QuestionObjectID {\n\t\t\tmsg.ObjectType = constant.QuestionObjectType\n\t\t} else {\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n}\n"], "filenames": ["internal/base/middleware/auth.go", "internal/repo/activity/answer_repo.go"], "buggy_code_start_loc": [129, 58], "buggy_code_end_loc": [130, 355], "fixing_code_start_loc": [129, 57], "fixing_code_end_loc": [130, 351], "type": "CWE-306", "message": "Missing Authentication for Critical Function in GitHub repository answerdev/answer prior to v1.1.3.", "other": {"cve": {"id": "CVE-2023-4815", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-07T07:15:08.747", "lastModified": "2023-09-12T11:58:59.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Missing Authentication for Critical Function in GitHub repository answerdev/answer prior to v1.1.3."}, {"lang": "es", "value": "Falta de Autenticaci\u00f3n para la Funci\u00f3n Cr\u00edtica en el repositorio de GitHub answerdev/answer antes de la versi\u00f3n 1.1.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.3", "matchCriteriaId": "E54D63D0-16AA-42D4-93AA-0D09E0DE9700"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/e75142a55546e01d8904f59db228422561f51666", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/4cd3eeb4-57c9-4af2-ad19-2166c9e0fd2c", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/e75142a55546e01d8904f59db228422561f51666"}}