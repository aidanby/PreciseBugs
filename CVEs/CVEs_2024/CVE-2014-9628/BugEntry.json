{"buggy_code": ["/*****************************************************************************\n * libmp4.c : LibMP4 library for mp4 module for vlc\n *****************************************************************************\n * Copyright (C) 2001-2004, 2010 VLC authors and VideoLAN\n *\n * Author: Laurent Aimar <fenrir@via.ecp.fr>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <vlc_common.h>\n#include <vlc_stream.h>                               /* stream_Peek*/\n\n#ifdef HAVE_ZLIB_H\n#   include <zlib.h>                                  /* for compressed moov */\n#endif\n\n#include \"libmp4.h\"\n#include \"languages.h\"\n#include <math.h>\n\n/* Some assumptions:\n * The input method HAS to be seekable\n */\n\n/* convert 16.16 fixed point to floating point */\nstatic double conv_fx( int32_t fx ) {\n    double fp = fx;\n    fp /= 65536.;\n    return fp;\n}\n\n/* some functions for mp4 encoding of variables */\n#ifdef MP4_VERBOSE\nstatic void MP4_ConvertDate2Str( char *psz, uint64_t i_date, bool b_relative )\n{\n    int i_day;\n    int i_hour;\n    int i_min;\n    int i_sec;\n\n    /* date begin at 1 jan 1904 */\n    if ( !b_relative )\n        i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;\n\n    i_day = i_date / ( 60*60*24);\n    i_hour = ( i_date /( 60*60 ) ) % 60;\n    i_min  = ( i_date / 60 ) % 60;\n    i_sec =  i_date % 60;\n    sprintf( psz, \"%dd-%2.2dh:%2.2dm:%2.2ds\", i_day, i_hour, i_min, i_sec );\n}\n#endif\n\n/*****************************************************************************\n * Some prototypes.\n *****************************************************************************/\nstatic MP4_Box_t *MP4_ReadBox( stream_t *p_stream, MP4_Box_t *p_father );\n\n\n/*****************************************************************************\n * MP4_ReadBoxCommon : Load only common parameters for all boxes\n *****************************************************************************\n * p_box need to be an already allocated MP4_Box_t, and all data\n *  will only be peek not read\n *\n * RETURN : 0 if it fail, 1 otherwise\n *****************************************************************************/\nint MP4_ReadBoxCommon( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int      i_read;\n    const uint8_t  *p_peek;\n\n    if( ( ( i_read = stream_Peek( p_stream, &p_peek, 32 ) ) < 8 ) )\n    {\n        return 0;\n    }\n    p_box->i_pos = stream_Tell( p_stream );\n\n    p_box->data.p_payload = NULL;\n    p_box->p_father = NULL;\n    p_box->p_first  = NULL;\n    p_box->p_last  = NULL;\n    p_box->p_next   = NULL;\n\n    MP4_GET4BYTES( p_box->i_shortsize );\n    MP4_GETFOURCC( p_box->i_type );\n\n    /* Now special case */\n\n    if( p_box->i_shortsize == 1 )\n    {\n        /* get the true size on 64 bits */\n        MP4_GET8BYTES( p_box->i_size );\n    }\n    else\n    {\n        p_box->i_size = p_box->i_shortsize;\n        /* XXX size of 0 means that the box extends to end of file */\n    }\n\n    if( p_box->i_type == ATOM_uuid )\n    {\n        /* get extented type on 16 bytes */\n        GetUUID( &p_box->i_uuid, p_peek );\n        p_peek += 16; i_read -= 16;\n    }\n    else\n    {\n        CreateUUID( &p_box->i_uuid, p_box->i_type );\n    }\n#ifdef MP4_ULTRA_VERBOSE\n    if( p_box->i_size )\n    {\n        if MP4_BOX_TYPE_ASCII()\n            msg_Dbg( p_stream, \"found Box: %4.4s size %\"PRId64\" %\"PRId64,\n                    (char*)&p_box->i_type, p_box->i_size, p_box->i_pos );\n        else\n            msg_Dbg( p_stream, \"found Box: c%3.3s size %\"PRId64,\n                    (char*)&p_box->i_type+1, p_box->i_size );\n    }\n#endif\n\n    return 1;\n}\n\n/*****************************************************************************\n * MP4_NextBox : Go to the next box\n *****************************************************************************\n * if p_box == NULL, go to the next box in which we are( at the begining ).\n *****************************************************************************/\nstatic int MP4_NextBox( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_t box;\n\n    if( !p_box )\n    {\n        if ( !MP4_ReadBoxCommon( p_stream, &box ) )\n            return 0;\n        p_box = &box;\n    }\n\n    if( !p_box->i_size )\n    {\n        return 2; /* Box with infinite size */\n    }\n\n    if( p_box->p_father )\n    {\n        /* if father's size == 0, it means unknown or infinite size,\n         * and we skip the followong check */\n        if( p_box->p_father->i_size > 0 )\n        {\n            const off_t i_box_end = p_box->i_size + p_box->i_pos;\n            const off_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;\n\n            /* check if it's within p-father */\n            if( i_box_end >= i_father_end )\n            {\n                if( i_box_end > i_father_end )\n                    msg_Dbg( p_stream, \"out of bound child\" );\n                return 0; /* out of bound */\n            }\n        }\n    }\n    if( stream_Seek( p_stream, p_box->i_size + p_box->i_pos ) )\n    {\n        return 0;\n    }\n\n    return 1;\n}\n\n/*****************************************************************************\n * For all known box a loader is given,\n *  XXX: all common struct have to be already read by MP4_ReadBoxCommon\n *       after called one of theses functions, file position is unknown\n *       you need to call MP4_GotoBox to go where you want\n *****************************************************************************/\nstatic int MP4_ReadBoxContainerChildrenIndexed( stream_t *p_stream,\n               MP4_Box_t *p_container, uint32_t i_last_child, bool b_indexed )\n{\n    MP4_Box_t *p_box;\n\n    /* Size of root container is set to 0 when unknown, for exemple\n     * with a DASH stream. In that case, we skip the following check */\n    if( p_container->i_size\n            && ( stream_Tell( p_stream ) + ((b_indexed)?16:8) >\n        (off_t)(p_container->i_pos + p_container->i_size) )\n      )\n    {\n        /* there is no box to load */\n        return 0;\n    }\n\n    do\n    {\n        uint32_t i_index = 0;\n        if ( b_indexed )\n        {\n            uint8_t read[8];\n            if ( stream_Read( p_stream, read, 8 ) < 8 )\n                return 0;\n            i_index = GetDWBE(&read[4]);\n        }\n        if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) continue;\n        p_box->i_index = i_index;\n\n        /* chain this box with the father and the other at same level */\n        if( !p_container->p_first ) p_container->p_first = p_box;\n        else p_container->p_last->p_next = p_box;\n        p_container->p_last = p_box;\n\n        if( p_box->i_type == i_last_child )\n        {\n            MP4_NextBox( p_stream, p_box );\n            break;\n        }\n\n    } while( MP4_NextBox( p_stream, p_box ) == 1 );\n\n    return 1;\n}\n\nint MP4_ReadBoxContainerChildren( stream_t *p_stream, MP4_Box_t *p_container,\n                                  uint32_t i_last_child )\n{\n    return MP4_ReadBoxContainerChildrenIndexed( p_stream, p_container,\n                                                i_last_child, false );\n}\n\nstatic int MP4_ReadBoxContainerRaw( stream_t *p_stream, MP4_Box_t *p_container )\n{\n    return MP4_ReadBoxContainerChildren( p_stream, p_container, 0 );\n}\n\nstatic int MP4_ReadBoxContainer( stream_t *p_stream, MP4_Box_t *p_container )\n{\n    if( p_container->i_size &&\n        ( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 ) )\n    {\n        /* container is empty, 8 stand for the first header in this box */\n        return 1;\n    }\n\n    /* enter box */\n    stream_Seek( p_stream, p_container->i_pos +\n                 mp4_box_headersize( p_container ) );\n\n    return MP4_ReadBoxContainerRaw( p_stream, p_container );\n}\n\nstatic void MP4_FreeBox_Common( MP4_Box_t *p_box )\n{\n    /* Up to now do nothing */\n    (void)p_box;\n}\n\nstatic int MP4_ReadBoxSkip( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    /* XXX sometime moov is hiden in a free box */\n    if( p_box->p_father &&\n        p_box->p_father->i_type == ATOM_root &&\n        p_box->i_type == ATOM_free )\n    {\n        const uint8_t *p_peek;\n        int     i_read;\n        vlc_fourcc_t i_fcc;\n\n        i_read  = stream_Peek( p_stream, &p_peek, 44 );\n\n        p_peek += mp4_box_headersize( p_box ) + 4;\n        i_read -= mp4_box_headersize( p_box ) + 4;\n\n        if( i_read >= 8 )\n        {\n            i_fcc = VLC_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );\n\n            if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )\n            {\n                msg_Warn( p_stream, \"detected moov hidden in a free box ...\" );\n\n                p_box->i_type = ATOM_foov;\n                return MP4_ReadBoxContainer( p_stream, p_box );\n            }\n        }\n    }\n\n    /* Nothing to do */\n#ifdef MP4_ULTRA_VERBOSE\n    if MP4_BOX_TYPE_ASCII()\n        msg_Dbg( p_stream, \"skip box: \\\"%4.4s\\\"\", (char*)&p_box->i_type );\n    else\n        msg_Dbg( p_stream, \"skip box: \\\"c%3.3s\\\"\", (char*)&p_box->i_type+1 );\n#endif\n    return 1;\n}\n\nstatic int MP4_ReadBox_ilst( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if( p_box->i_size < 8 || stream_Read( p_stream, NULL, 8 ) < 8 )\n        return 0;\n\n    /* Find our handler */\n    if ( !p_box->i_handler && p_box->p_father )\n    {\n        const MP4_Box_t *p_sibling = p_box->p_father->p_first;\n        while( p_sibling )\n        {\n            if ( p_sibling->i_type == ATOM_hdlr && p_sibling->data.p_hdlr )\n            {\n                p_box->i_handler = p_sibling->data.p_hdlr->i_handler_type;\n                break;\n            }\n            p_sibling = p_sibling->p_next;\n        }\n    }\n\n    switch( p_box->i_handler )\n    {\n    case 0:\n        msg_Warn( p_stream, \"no handler for ilst atom\" );\n        return 0;\n    case HANDLER_mdta:\n        return MP4_ReadBoxContainerChildrenIndexed( p_stream, p_box, 0, true );\n    case HANDLER_mdir:\n        return MP4_ReadBoxContainerChildren( p_stream, p_box, 0 );\n    default:\n        msg_Warn( p_stream, \"Unknown ilst handler type '%4.4s'\", (char*)&p_box->i_handler );\n        return 0;\n    }\n}\n\nstatic int MP4_ReadBox_ftyp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_ftyp_t );\n\n    MP4_GETFOURCC( p_box->data.p_ftyp->i_major_brand );\n    MP4_GET4BYTES( p_box->data.p_ftyp->i_minor_version );\n\n    if( ( p_box->data.p_ftyp->i_compatible_brands_count = i_read / 4 ) )\n    {\n        uint32_t *tab = p_box->data.p_ftyp->i_compatible_brands =\n            calloc( p_box->data.p_ftyp->i_compatible_brands_count,\n                    sizeof(uint32_t));\n\n        if( unlikely( tab == NULL ) )\n            MP4_READBOX_EXIT( 0 );\n\n        for( unsigned i = 0; i < p_box->data.p_ftyp->i_compatible_brands_count; i++ )\n        {\n            MP4_GETFOURCC( tab[i] );\n        }\n    }\n    else\n    {\n        p_box->data.p_ftyp->i_compatible_brands = NULL;\n    }\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_ftyp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_ftyp->i_compatible_brands );\n}\n\n\nstatic int MP4_ReadBox_mvhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n#ifdef MP4_VERBOSE\n    char s_creation_time[128];\n    char s_modification_time[128];\n    char s_duration[128];\n#endif\n    MP4_READBOX_ENTER( MP4_Box_data_mvhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );\n\n    if( p_box->data.p_mvhd->i_version )\n    {\n        MP4_GET8BYTES( p_box->data.p_mvhd->i_creation_time );\n        MP4_GET8BYTES( p_box->data.p_mvhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_timescale );\n        MP4_GET8BYTES( p_box->data.p_mvhd->i_duration );\n    }\n    else\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_creation_time );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_timescale );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_duration );\n    }\n    MP4_GET4BYTES( p_box->data.p_mvhd->i_rate );\n    MP4_GET2BYTES( p_box->data.p_mvhd->i_volume );\n    MP4_GET2BYTES( p_box->data.p_mvhd->i_reserved1 );\n\n\n    for( unsigned i = 0; i < 2; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_reserved2[i] );\n    }\n    for( unsigned i = 0; i < 9; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_matrix[i] );\n    }\n    for( unsigned i = 0; i < 6; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_predefined[i] );\n    }\n\n    MP4_GET4BYTES( p_box->data.p_mvhd->i_next_track_id );\n\n\n#ifdef MP4_VERBOSE\n    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->i_creation_time, false );\n    MP4_ConvertDate2Str( s_modification_time,\n                         p_box->data.p_mvhd->i_modification_time, false );\n    if( p_box->data.p_mvhd->i_rate )\n    {\n        MP4_ConvertDate2Str( s_duration,\n                 p_box->data.p_mvhd->i_duration / p_box->data.p_mvhd->i_rate, true );\n    }\n    else\n    {\n        s_duration[0] = 0;\n    }\n    msg_Dbg( p_stream, \"read box: \\\"mvhd\\\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d\",\n                  s_creation_time,\n                  s_modification_time,\n                  (uint32_t)p_box->data.p_mvhd->i_timescale,\n                  s_duration,\n                  (float)p_box->data.p_mvhd->i_rate / (1<<16 ),\n                  (float)p_box->data.p_mvhd->i_volume / 256 ,\n                  (uint32_t)p_box->data.p_mvhd->i_next_track_id );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mfhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_mfhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );\n\n    MP4_GET4BYTES( p_box->data.p_mfhd->i_sequence_number );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"mfhd\\\" sequence number %d\",\n                  p_box->data.p_mfhd->i_sequence_number );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tfxd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tfxd_t );\n\n    MP4_Box_data_tfxd_t *p_tfxd_data = p_box->data.p_tfxd;\n    MP4_GETVERSIONFLAGS( p_tfxd_data );\n\n    if( p_tfxd_data->i_version == 0 )\n    {\n        MP4_GET4BYTES( p_tfxd_data->i_fragment_abs_time );\n        MP4_GET4BYTES( p_tfxd_data->i_fragment_duration );\n    }\n    else\n    {\n        MP4_GET8BYTES( p_tfxd_data->i_fragment_abs_time );\n        MP4_GET8BYTES( p_tfxd_data->i_fragment_duration );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"tfxd\\\" version %d, flags 0x%x, \"\\\n            \"fragment duration %\"PRIu64\", fragment abs time %\"PRIu64,\n                p_tfxd_data->i_version,\n                p_tfxd_data->i_flags,\n                p_tfxd_data->i_fragment_duration,\n                p_tfxd_data->i_fragment_abs_time\n           );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tfrf(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tfxd_t );\n\n    MP4_Box_data_tfrf_t *p_tfrf_data = p_box->data.p_tfrf;\n    MP4_GETVERSIONFLAGS( p_tfrf_data );\n\n    MP4_GET1BYTE( p_tfrf_data->i_fragment_count );\n\n    p_tfrf_data->p_tfrf_data_fields = calloc( p_tfrf_data->i_fragment_count,\n                                              sizeof( TfrfBoxDataFields_t ) );\n    if( !p_tfrf_data->p_tfrf_data_fields )\n        MP4_READBOX_EXIT( 0 );\n\n    for( uint8_t i = 0; i < p_tfrf_data->i_fragment_count; i++ )\n    {\n        TfrfBoxDataFields_t *TfrfBoxDataField = &p_tfrf_data->p_tfrf_data_fields[i];\n        if( p_tfrf_data->i_version == 0 )\n        {\n            MP4_GET4BYTES( TfrfBoxDataField->i_fragment_abs_time );\n            MP4_GET4BYTES( TfrfBoxDataField->i_fragment_duration );\n        }\n        else\n        {\n            MP4_GET8BYTES( TfrfBoxDataField->i_fragment_abs_time );\n            MP4_GET8BYTES( TfrfBoxDataField->i_fragment_duration );\n        }\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"tfrf\\\" version %d, flags 0x%x, \"\\\n            \"fragment count %\"PRIu8, p_tfrf_data->i_version,\n                p_tfrf_data->i_flags, p_tfrf_data->i_fragment_count );\n\n    for( uint8_t i = 0; i < p_tfrf_data->i_fragment_count; i++ )\n    {\n        TfrfBoxDataFields_t *TfrfBoxDataField = &p_tfrf_data->p_tfrf_data_fields[i];\n        msg_Dbg( p_stream, \"\\\"tfrf\\\" fragment duration %\"PRIu64\", \"\\\n                                    \"fragment abs time %\"PRIu64,\n                    TfrfBoxDataField->i_fragment_duration,\n                    TfrfBoxDataField->i_fragment_abs_time );\n    }\n\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_tfrf( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_tfrf->p_tfrf_data_fields );\n}\n\nstatic int MP4_ReadBox_stra( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stra_t );\n    MP4_Box_data_stra_t *p_stra = p_box->data.p_stra;\n\n    uint8_t i_reserved;\n    VLC_UNUSED(i_reserved);\n    MP4_GET1BYTE( p_stra->i_es_cat );\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET2BYTES( p_stra->i_track_ID );\n\n    MP4_GET4BYTES( p_stra->i_timescale );\n    MP4_GET8BYTES( p_stra->i_duration );\n\n    MP4_GET4BYTES( p_stra->FourCC );\n    MP4_GET4BYTES( p_stra->Bitrate );\n    MP4_GET4BYTES( p_stra->MaxWidth );\n    MP4_GET4BYTES( p_stra->MaxHeight );\n    MP4_GET4BYTES( p_stra->SamplingRate );\n    MP4_GET4BYTES( p_stra->Channels );\n    MP4_GET4BYTES( p_stra->BitsPerSample );\n    MP4_GET4BYTES( p_stra->AudioTag );\n    MP4_GET2BYTES( p_stra->nBlockAlign );\n\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET1BYTE( p_stra->cpd_len );\n    if( p_stra->cpd_len > i_read )\n        goto error;\n    p_stra->CodecPrivateData = malloc( p_stra->cpd_len );\n    if( unlikely( p_stra->CodecPrivateData == NULL ) )\n        goto error;\n    memcpy( p_stra->CodecPrivateData, p_peek, p_stra->cpd_len );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"es_cat is %\"PRIu8\", birate is %\"PRIu32,\n              p_stra->i_es_cat, p_stra->Bitrate );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\nerror:\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic void MP4_FreeBox_stra( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stra->CodecPrivateData );\n}\n\nstatic int MP4_ReadBox_uuid( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if( !CmpUUID( &p_box->i_uuid, &TfrfBoxUUID ) )\n        return MP4_ReadBox_tfrf( p_stream, p_box );\n    if( !CmpUUID( &p_box->i_uuid, &TfxdBoxUUID ) )\n        return MP4_ReadBox_tfxd( p_stream, p_box );\n    if( !CmpUUID( &p_box->i_uuid, &SmooBoxUUID ) )\n        return MP4_ReadBoxContainer( p_stream, p_box );\n    if( !CmpUUID( &p_box->i_uuid, &StraBoxUUID ) )\n        return MP4_ReadBox_stra( p_stream, p_box );\n\n    msg_Warn( p_stream, \"Unknown uuid type box\" );\n    return 1;\n}\n\nstatic void MP4_FreeBox_uuid( MP4_Box_t *p_box )\n{\n    if( !CmpUUID( &p_box->i_uuid, &TfrfBoxUUID ) )\n        return MP4_FreeBox_tfrf( p_box );\n    if( !CmpUUID( &p_box->i_uuid, &TfxdBoxUUID ) )\n        return MP4_FreeBox_Common( p_box );\n    if( !CmpUUID( &p_box->i_uuid, &SmooBoxUUID ) )\n        return MP4_FreeBox_Common( p_box );\n    if( !CmpUUID( &p_box->i_uuid, &StraBoxUUID ) )\n        return MP4_FreeBox_stra( p_box );\n}\n\nstatic int MP4_ReadBox_sidx(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_sidx_t );\n\n    MP4_Box_data_sidx_t *p_sidx_data = p_box->data.p_sidx;\n    MP4_GETVERSIONFLAGS( p_sidx_data );\n\n    MP4_GET4BYTES( p_sidx_data->i_reference_ID );\n    MP4_GET4BYTES( p_sidx_data->i_timescale );\n\n    if( p_sidx_data->i_version == 0 )\n    {\n        MP4_GET4BYTES( p_sidx_data->i_earliest_presentation_time );\n        MP4_GET4BYTES( p_sidx_data->i_first_offset );\n    }\n    else\n    {\n        MP4_GET8BYTES( p_sidx_data->i_earliest_presentation_time );\n        MP4_GET8BYTES( p_sidx_data->i_first_offset );\n    }\n\n    uint16_t i_reserved;\n    VLC_UNUSED(i_reserved);\n    MP4_GET2BYTES( i_reserved );\n    MP4_GET2BYTES( p_sidx_data->i_reference_count );\n    uint16_t i_count = p_sidx_data->i_reference_count;\n\n    p_sidx_data->p_items = calloc( i_count, sizeof( MP4_Box_sidx_item_t ) );\n    uint32_t tmp;\n    for( unsigned i = 0; i < i_count; i++ )\n    {\n        MP4_GET4BYTES( tmp );\n        p_sidx_data->p_items[i].b_reference_type = (bool)((tmp & 0x80000000)>>24);\n        p_sidx_data->p_items[i].i_referenced_size = tmp & 0x7fffffff;\n        MP4_GET4BYTES( p_sidx_data->p_items[i].i_subsegment_duration );\n\n        MP4_GET4BYTES( tmp );\n        p_sidx_data->p_items[i].b_starts_with_SAP = (bool)((tmp & 0x80000000)>>24);\n        p_sidx_data->p_items[i].i_SAP_type = (tmp & 0x70000000)>>24;\n        p_sidx_data->p_items[i].i_SAP_delta_time = tmp & 0xfffffff;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"sidx\\\" version %d, flags 0x%x, \"\\\n            \"ref_ID %\"PRIu32\", timescale %\"PRIu32\", ref_count %\"PRIu16\", \"\\\n            \"first subsegmt duration %\"PRIu32,\n                p_sidx_data->i_version,\n                p_sidx_data->i_flags,\n                p_sidx_data->i_reference_ID,\n                p_sidx_data->i_timescale,\n                p_sidx_data->i_reference_count,\n                p_sidx_data->p_items[0].i_subsegment_duration\n           );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_sidx( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sidx->p_items );\n}\n\nstatic int MP4_ReadBox_tfhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tfhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_tfhd );\n\n    if( p_box->data.p_tfhd->i_version != 0 )\n    {\n        msg_Warn( p_stream, \"'tfhd' box with version != 0. \"\\\n                \" Don't know what to do with that, please patch\" );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    MP4_GET4BYTES( p_box->data.p_tfhd->i_track_ID );\n\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DURATION_IS_EMPTY )\n    {\n        msg_Dbg( p_stream, \"'duration-is-empty' flag is present \"\\\n                \"=> no samples for this time interval.\" );\n        p_box->data.p_tfhd->b_empty = true;\n    }\n    else\n        p_box->data.p_tfhd->b_empty = false;\n\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )\n        MP4_GET8BYTES( p_box->data.p_tfhd->i_base_data_offset );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_sample_description_index );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_default_sample_duration );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_default_sample_size );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_default_sample_flags );\n\n#ifdef MP4_VERBOSE\n    char psz_base[128] = \"\\0\";\n    char psz_desc[128] = \"\\0\";\n    char psz_dura[128] = \"\\0\";\n    char psz_size[128] = \"\\0\";\n    char psz_flag[128] = \"\\0\";\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )\n        snprintf(psz_base, sizeof(psz_base), \"base offset %\"PRId64, p_box->data.p_tfhd->i_base_data_offset);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )\n        snprintf(psz_desc, sizeof(psz_desc), \"sample description index %d\", p_box->data.p_tfhd->i_sample_description_index);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )\n        snprintf(psz_dura, sizeof(psz_dura), \"sample duration %d\", p_box->data.p_tfhd->i_default_sample_duration);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )\n        snprintf(psz_size, sizeof(psz_size), \"sample size %d\", p_box->data.p_tfhd->i_default_sample_size);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )\n        snprintf(psz_flag, sizeof(psz_flag), \"sample flags 0x%x\", p_box->data.p_tfhd->i_default_sample_flags);\n\n    msg_Dbg( p_stream, \"read box: \\\"tfhd\\\" version %d flags 0x%x track ID %d %s %s %s %s %s\",\n                p_box->data.p_tfhd->i_version,\n                p_box->data.p_tfhd->i_flags,\n                p_box->data.p_tfhd->i_track_ID,\n                psz_base, psz_desc, psz_dura, psz_size, psz_flag );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_trun(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_trun_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_trun );\n\n    MP4_GET4BYTES( p_box->data.p_trun->i_sample_count );\n\n    if( p_box->data.p_trun->i_flags & MP4_TRUN_DATA_OFFSET )\n        MP4_GET4BYTES( p_box->data.p_trun->i_data_offset );\n    if( p_box->data.p_trun->i_flags & MP4_TRUN_FIRST_FLAGS )\n        MP4_GET4BYTES( p_box->data.p_trun->i_first_sample_flags );\n\n    p_box->data.p_trun->p_samples =\n      calloc( p_box->data.p_trun->i_sample_count, sizeof(MP4_descriptor_trun_sample_t) );\n    if ( p_box->data.p_trun->p_samples == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned int i = 0; i<p_box->data.p_trun->i_sample_count; i++ )\n    {\n        MP4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->p_samples[i];\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_DURATION )\n            MP4_GET4BYTES( p_sample->i_duration );\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_SIZE )\n            MP4_GET4BYTES( p_sample->i_size );\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_FLAGS )\n            MP4_GET4BYTES( p_sample->i_flags );\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_TIME_OFFSET )\n            MP4_GET4BYTES( p_sample->i_composition_time_offset );\n    }\n\n#ifdef MP4_ULTRA_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"trun\\\" version %u flags 0x%x sample count %u\",\n                  p_box->data.p_trun->i_version,\n                  p_box->data.p_trun->i_flags,\n                  p_box->data.p_trun->i_sample_count );\n\n    for( unsigned int i = 0; i<p_box->data.p_trun->i_sample_count; i++ )\n    {\n        MP4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->p_samples[i];\n        msg_Dbg( p_stream, \"read box: \\\"trun\\\" sample %4.4u flags 0x%x \"\\\n            \"duration %\"PRIu32\" size %\"PRIu32\" composition time offset %\"PRIu32,\n                        i, p_sample->i_flags, p_sample->i_duration,\n                        p_sample->i_size, p_sample->i_composition_time_offset );\n    }\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_trun( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_trun->p_samples );\n}\n\n\nstatic int MP4_ReadBox_tkhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n#ifdef MP4_VERBOSE\n    char s_creation_time[128];\n    char s_modification_time[128];\n    char s_duration[128];\n#endif\n    MP4_READBOX_ENTER( MP4_Box_data_tkhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_tkhd );\n\n    if( p_box->data.p_tkhd->i_version )\n    {\n        MP4_GET8BYTES( p_box->data.p_tkhd->i_creation_time );\n        MP4_GET8BYTES( p_box->data.p_tkhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_track_ID );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_reserved );\n        MP4_GET8BYTES( p_box->data.p_tkhd->i_duration );\n    }\n    else\n    {\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_creation_time );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_track_ID );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_reserved );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_duration );\n    }\n\n    for( unsigned i = 0; i < 2; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_reserved2[i] );\n    }\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_layer );\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_predefined );\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_volume );\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_reserved3 );\n\n    for( unsigned i = 0; i < 9; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_matrix[i] );\n    }\n    MP4_GET4BYTES( p_box->data.p_tkhd->i_width );\n    MP4_GET4BYTES( p_box->data.p_tkhd->i_height );\n\n    double rotation;    //angle in degrees to be rotated clockwise\n    double scale[2];    // scale factor; sx = scale[0] , sy = scale[1]\n    double translate[2];// amount to translate; tx = translate[0] , ty = translate[1]\n\n    int32_t *matrix = p_box->data.p_tkhd->i_matrix;\n\n    translate[0] = conv_fx(matrix[6]);\n    translate[1] = conv_fx(matrix[7]);\n\n    scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +\n                    conv_fx(matrix[3]) * conv_fx(matrix[3]));\n    scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +\n                    conv_fx(matrix[4]) * conv_fx(matrix[4]));\n\n    rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;\n\n    if (rotation < 0)\n        rotation += 360.;\n\n    p_box->data.p_tkhd->f_rotation = rotation;\n\n#ifdef MP4_VERBOSE\n    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->i_creation_time, false );\n    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->i_modification_time, false );\n    MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->i_duration, true );\n\n    msg_Dbg( p_stream, \"read box: \\\"tkhd\\\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. \"\n            \"Matrix: %i %i %i %i %i %i %i %i %i\",\n                  s_creation_time,\n                  s_modification_time,\n                  s_duration,\n                  p_box->data.p_tkhd->i_track_ID,\n                  p_box->data.p_tkhd->i_layer,\n                  (float)p_box->data.p_tkhd->i_volume / 256 ,\n                  rotation,\n                  scale[0],\n                  scale[1],\n                  translate[0],\n                  translate[1],\n                  (float)p_box->data.p_tkhd->i_width / BLOCK16x16,\n                  (float)p_box->data.p_tkhd->i_height / BLOCK16x16,\n                  p_box->data.p_tkhd->i_matrix[0],\n                  p_box->data.p_tkhd->i_matrix[1],\n                  p_box->data.p_tkhd->i_matrix[2],\n                  p_box->data.p_tkhd->i_matrix[3],\n                  p_box->data.p_tkhd->i_matrix[4],\n                  p_box->data.p_tkhd->i_matrix[5],\n                  p_box->data.p_tkhd->i_matrix[6],\n                  p_box->data.p_tkhd->i_matrix[7],\n                  p_box->data.p_tkhd->i_matrix[8] );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_load( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if ( p_box->i_size != 24 )\n        return 0;\n    MP4_READBOX_ENTER( MP4_Box_data_load_t );\n    MP4_GET4BYTES( p_box->data.p_load->i_start_time );\n    MP4_GET4BYTES( p_box->data.p_load->i_duration );\n    MP4_GET4BYTES( p_box->data.p_load->i_flags );\n    MP4_GET4BYTES( p_box->data.p_load->i_hints );\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mdhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint16_t i_language;\n#ifdef MP4_VERBOSE\n    char s_creation_time[128];\n    char s_modification_time[128];\n    char s_duration[128];\n#endif\n    MP4_READBOX_ENTER( MP4_Box_data_mdhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mdhd );\n\n    if( p_box->data.p_mdhd->i_version )\n    {\n        MP4_GET8BYTES( p_box->data.p_mdhd->i_creation_time );\n        MP4_GET8BYTES( p_box->data.p_mdhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_timescale );\n        MP4_GET8BYTES( p_box->data.p_mdhd->i_duration );\n    }\n    else\n    {\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_creation_time );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_timescale );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_duration );\n    }\n\n    MP4_GET2BYTES( i_language );\n    decodeQtLanguageCode( i_language, p_box->data.p_mdhd->rgs_language,\n                          &p_box->data.p_mdhd->b_mac_encoding );\n\n    MP4_GET2BYTES( p_box->data.p_mdhd->i_quality );\n\n#ifdef MP4_VERBOSE\n    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->i_creation_time, false );\n    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->i_modification_time, false );\n    MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->i_duration, true );\n    msg_Dbg( p_stream, \"read box: \\\"mdhd\\\" creation %s modification %s time scale %d duration %s language %3.3s\",\n                  s_creation_time,\n                  s_modification_time,\n                  (uint32_t)p_box->data.p_mdhd->i_timescale,\n                  s_duration,\n                  (char*) &p_box->data.p_mdhd->rgs_language );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_hdlr( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int32_t i_reserved;\n    VLC_UNUSED(i_reserved);\n\n    MP4_READBOX_ENTER( MP4_Box_data_hdlr_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_hdlr );\n\n    MP4_GETFOURCC( p_box->data.p_hdlr->i_predefined );\n    MP4_GETFOURCC( p_box->data.p_hdlr->i_handler_type );\n\n    MP4_GET4BYTES( i_reserved );\n    MP4_GET4BYTES( i_reserved );\n    MP4_GET4BYTES( i_reserved );\n    p_box->data.p_hdlr->psz_name = NULL;\n\n    if( i_read > 0 )\n    {\n        uint8_t *psz = p_box->data.p_hdlr->psz_name = malloc( i_read + 1 );\n        if( unlikely( psz == NULL ) )\n            MP4_READBOX_EXIT( 0 );\n\n        /* Yes, I love .mp4 :( */\n        if( p_box->data.p_hdlr->i_predefined == VLC_FOURCC( 'm', 'h', 'l', 'r' ) )\n        {\n            uint8_t i_len;\n            int i_copy;\n\n            MP4_GET1BYTE( i_len );\n            i_copy = __MIN( i_read, i_len );\n\n            memcpy( psz, p_peek, i_copy );\n            p_box->data.p_hdlr->psz_name[i_copy] = '\\0';\n        }\n        else\n        {\n            memcpy( psz, p_peek, i_read );\n            p_box->data.p_hdlr->psz_name[i_read] = '\\0';\n        }\n    }\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"hdlr\\\" handler type: \\\"%4.4s\\\" name: \\\"%s\\\"\",\n                   (char*)&p_box->data.p_hdlr->i_handler_type,\n                   p_box->data.p_hdlr->psz_name );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_hdlr( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_hdlr->psz_name );\n}\n\nstatic int MP4_ReadBox_vmhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_vmhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );\n\n    MP4_GET2BYTES( p_box->data.p_vmhd->i_graphics_mode );\n    for( unsigned i = 0; i < 3; i++ )\n    {\n        MP4_GET2BYTES( p_box->data.p_vmhd->i_opcolor[i] );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"vmhd\\\" graphics-mode %d opcolor (%d, %d, %d)\",\n                      p_box->data.p_vmhd->i_graphics_mode,\n                      p_box->data.p_vmhd->i_opcolor[0],\n                      p_box->data.p_vmhd->i_opcolor[1],\n                      p_box->data.p_vmhd->i_opcolor[2] );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_smhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_smhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_smhd );\n\n\n\n    MP4_GET2BYTES( p_box->data.p_smhd->i_balance );\n\n    MP4_GET2BYTES( p_box->data.p_smhd->i_reserved );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"smhd\\\" balance %f\",\n                      (float)p_box->data.p_smhd->i_balance / 256 );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_hmhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_hmhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_hmhd );\n\n    MP4_GET2BYTES( p_box->data.p_hmhd->i_max_PDU_size );\n    MP4_GET2BYTES( p_box->data.p_hmhd->i_avg_PDU_size );\n\n    MP4_GET4BYTES( p_box->data.p_hmhd->i_max_bitrate );\n    MP4_GET4BYTES( p_box->data.p_hmhd->i_avg_bitrate );\n\n    MP4_GET4BYTES( p_box->data.p_hmhd->i_reserved );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"hmhd\\\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d\",\n                      p_box->data.p_hmhd->i_max_PDU_size,\n                      p_box->data.p_hmhd->i_avg_PDU_size,\n                      p_box->data.p_hmhd->i_max_bitrate,\n                      p_box->data.p_hmhd->i_avg_bitrate );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_url( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_url_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_url );\n    MP4_GETSTRINGZ( p_box->data.p_url->psz_location );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"url\\\" url: %s\",\n                       p_box->data.p_url->psz_location );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic void MP4_FreeBox_url( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_url->psz_location );\n}\n\nstatic int MP4_ReadBox_urn( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_urn_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_urn );\n\n    MP4_GETSTRINGZ( p_box->data.p_urn->psz_name );\n    MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"urn\\\" name %s location %s\",\n                      p_box->data.p_urn->psz_name,\n                      p_box->data.p_urn->psz_location );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\nstatic void MP4_FreeBox_urn( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_urn->psz_name );\n    FREENULL( p_box->data.p_urn->psz_location );\n}\n\n\nstatic int MP4_ReadBox_dref( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_dref_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_dref );\n\n    MP4_GET4BYTES( p_box->data.p_dref->i_entry_count );\n\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8 );\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"dref\\\" entry-count %d\",\n                      p_box->data.p_dref->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stts( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stts->pi_sample_count );\n    FREENULL( p_box->data.p_stts->pi_sample_delta );\n}\n\nstatic int MP4_ReadBox_stts( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stts_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stts );\n    MP4_GET4BYTES( p_box->data.p_stts->i_entry_count );\n\n    p_box->data.p_stts->pi_sample_count =\n        calloc( p_box->data.p_stts->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stts->pi_sample_delta =\n        calloc( p_box->data.p_stts->i_entry_count, sizeof(int32_t) );\n    if( p_box->data.p_stts->pi_sample_count == NULL\n     || p_box->data.p_stts->pi_sample_delta == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    uint32_t i = 0;\n    for( ; (i < p_box->data.p_stts->i_entry_count )&&( i_read >=8 ); i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_stts->pi_sample_count[i] );\n        MP4_GET4BYTES( p_box->data.p_stts->pi_sample_delta[i] );\n    }\n\n    if ( i < p_box->data.p_stts->i_entry_count )\n        p_box->data.p_stts->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stts\\\" entry-count %d\",\n                      p_box->data.p_stts->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic void MP4_FreeBox_ctts( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_ctts->pi_sample_count );\n    FREENULL( p_box->data.p_ctts->pi_sample_offset );\n}\n\nstatic int MP4_ReadBox_ctts( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_ctts_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_ctts );\n\n    MP4_GET4BYTES( p_box->data.p_ctts->i_entry_count );\n\n    p_box->data.p_ctts->pi_sample_count =\n        calloc( p_box->data.p_ctts->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_ctts->pi_sample_offset =\n        calloc( p_box->data.p_ctts->i_entry_count, sizeof(int32_t) );\n    if( ( p_box->data.p_ctts->pi_sample_count == NULL )\n     || ( p_box->data.p_ctts->pi_sample_offset == NULL ) )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    uint32_t i = 0;\n    for( ; (i < p_box->data.p_ctts->i_entry_count )&&( i_read >=8 ); i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_ctts->pi_sample_count[i] );\n        MP4_GET4BYTES( p_box->data.p_ctts->pi_sample_offset[i] );\n    }\n    if ( i < p_box->data.p_ctts->i_entry_count )\n        p_box->data.p_ctts->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"ctts\\\" entry-count %d\",\n                      p_box->data.p_ctts->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadLengthDescriptor( uint8_t **pp_peek, int64_t  *i_read )\n{\n    unsigned int i_b;\n    unsigned int i_len = 0;\n    do\n    {\n        i_b = **pp_peek;\n\n        (*pp_peek)++;\n        (*i_read)--;\n        i_len = ( i_len << 7 ) + ( i_b&0x7f );\n    } while( i_b&0x80 );\n    return( i_len );\n}\n\n\nstatic void MP4_FreeBox_esds( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_esds->es_descriptor.psz_URL );\n    if( p_box->data.p_esds->es_descriptor.p_decConfigDescr )\n    {\n        FREENULL( p_box->data.p_esds->es_descriptor.p_decConfigDescr->p_decoder_specific_info );\n        FREENULL( p_box->data.p_esds->es_descriptor.p_decConfigDescr );\n    }\n}\n\nstatic int MP4_ReadBox_esds( stream_t *p_stream, MP4_Box_t *p_box )\n{\n#define es_descriptor p_box->data.p_esds->es_descriptor\n    unsigned int i_len;\n    unsigned int i_flags;\n    unsigned int i_type;\n\n    MP4_READBOX_ENTER( MP4_Box_data_esds_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_esds );\n\n\n    MP4_GET1BYTE( i_type );\n    if( i_type == 0x03 ) /* MP4ESDescrTag ISO/IEC 14496-1 8.3.3 */\n    {\n        i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"found esds MPEG4ESDescr (%dBytes)\",\n                 i_len );\n#endif\n\n        MP4_GET2BYTES( es_descriptor.i_ES_ID );\n        MP4_GET1BYTE( i_flags );\n        es_descriptor.b_stream_dependence = ( (i_flags&0x80) != 0);\n        es_descriptor.b_url = ( (i_flags&0x40) != 0);\n        es_descriptor.b_OCRstream = ( (i_flags&0x20) != 0);\n\n        es_descriptor.i_stream_priority = i_flags&0x1f;\n        if( es_descriptor.b_stream_dependence )\n        {\n            MP4_GET2BYTES( es_descriptor.i_depend_on_ES_ID );\n        }\n        if( es_descriptor.b_url )\n        {\n            unsigned int i_len;\n\n            MP4_GET1BYTE( i_len );\n            i_len = __MIN(i_read, i_len);\n            es_descriptor.psz_URL = malloc( i_len + 1 );\n            if( es_descriptor.psz_URL )\n            {\n                memcpy( es_descriptor.psz_URL, p_peek, i_len );\n                es_descriptor.psz_URL[i_len] = 0;\n            }\n            p_peek += i_len;\n            i_read -= i_len;\n        }\n        else\n        {\n            es_descriptor.psz_URL = NULL;\n        }\n        if( es_descriptor.b_OCRstream )\n        {\n            MP4_GET2BYTES( es_descriptor.i_OCR_ES_ID );\n        }\n        MP4_GET1BYTE( i_type ); /* get next type */\n    }\n\n    if( i_type != 0x04)/* MP4DecConfigDescrTag ISO/IEC 14496-1 8.3.4 */\n    {\n         es_descriptor.p_decConfigDescr = NULL;\n         MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */\n    }\n\n    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"found esds MP4DecConfigDescr (%dBytes)\",\n                 i_len );\n#endif\n\n    es_descriptor.p_decConfigDescr =\n            calloc( 1, sizeof( MP4_descriptor_decoder_config_t ));\n    if( unlikely( es_descriptor.p_decConfigDescr == NULL ) )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET1BYTE( es_descriptor.p_decConfigDescr->i_objectProfileIndication );\n    MP4_GET1BYTE( i_flags );\n    es_descriptor.p_decConfigDescr->i_streamType = i_flags >> 2;\n    es_descriptor.p_decConfigDescr->b_upStream = ( i_flags >> 1 )&0x01;\n    MP4_GET3BYTES( es_descriptor.p_decConfigDescr->i_buffer_sizeDB );\n    MP4_GET4BYTES( es_descriptor.p_decConfigDescr->i_max_bitrate );\n    MP4_GET4BYTES( es_descriptor.p_decConfigDescr->i_avg_bitrate );\n    MP4_GET1BYTE( i_type );\n    if( i_type !=  0x05 )/* MP4DecSpecificDescrTag ISO/IEC 14496-1 8.3.5 */\n    {\n        es_descriptor.p_decConfigDescr->i_decoder_specific_info_len = 0;\n        es_descriptor.p_decConfigDescr->p_decoder_specific_info  = NULL;\n        MP4_READBOX_EXIT( 1 );\n    }\n\n    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"found esds MP4DecSpecificDescr (%dBytes)\",\n                 i_len );\n#endif\n    if( i_len > i_read )\n        MP4_READBOX_EXIT( 0 );\n\n    es_descriptor.p_decConfigDescr->i_decoder_specific_info_len = i_len;\n    es_descriptor.p_decConfigDescr->p_decoder_specific_info = malloc( i_len );\n    if( unlikely( es_descriptor.p_decConfigDescr->p_decoder_specific_info == NULL ) )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( es_descriptor.p_decConfigDescr->p_decoder_specific_info,\n            p_peek, i_len );\n\n    MP4_READBOX_EXIT( 1 );\n#undef es_descriptor\n}\n\nstatic void MP4_FreeBox_hvcC(MP4_Box_t *p_box )\n{\n    MP4_Box_data_hvcC_t *p_hvcC =  p_box->data.p_hvcC;\n    if( p_hvcC->i_hvcC > 0 ) FREENULL( p_hvcC->p_hvcC) ;\n}\n\nstatic int MP4_ReadBox_hvcC( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_hvcC_t *p_hvcC;\n\n    MP4_READBOX_ENTER( MP4_Box_data_hvcC_t );\n    p_hvcC = p_box->data.p_hvcC;\n\n    p_hvcC->i_hvcC = i_read;\n    if( p_hvcC->i_hvcC > 0 )\n    {\n        uint8_t * p = p_hvcC->p_hvcC = malloc( p_hvcC->i_hvcC );\n        if( p )\n            memcpy( p, p_peek, i_read );\n    }\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_avcC( MP4_Box_t *p_box )\n{\n    MP4_Box_data_avcC_t *p_avcC = p_box->data.p_avcC;\n    int i;\n\n    if( p_avcC->i_avcC > 0 ) FREENULL( p_avcC->p_avcC );\n\n    if( p_avcC->sps )\n    {\n        for( i = 0; i < p_avcC->i_sps; i++ )\n            FREENULL( p_avcC->sps[i] );\n    }\n    if( p_avcC->pps )\n    {\n        for( i = 0; i < p_avcC->i_pps; i++ )\n            FREENULL( p_avcC->pps[i] );\n    }\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->sps );\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->i_sps_length );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->pps );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->i_pps_length );\n}\n\nstatic int MP4_ReadBox_avcC( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_avcC_t *p_avcC;\n    int i;\n\n    MP4_READBOX_ENTER( MP4_Box_data_avcC_t );\n    p_avcC = p_box->data.p_avcC;\n\n    p_avcC->i_avcC = i_read;\n    if( p_avcC->i_avcC > 0 )\n    {\n        uint8_t * p = p_avcC->p_avcC = malloc( p_avcC->i_avcC );\n        if( p )\n            memcpy( p, p_peek, i_read );\n    }\n\n    MP4_GET1BYTE( p_avcC->i_version );\n    MP4_GET1BYTE( p_avcC->i_profile );\n    MP4_GET1BYTE( p_avcC->i_profile_compatibility );\n    MP4_GET1BYTE( p_avcC->i_level );\n    MP4_GET1BYTE( p_avcC->i_reserved1 );\n    p_avcC->i_length_size = (p_avcC->i_reserved1&0x03) + 1;\n    p_avcC->i_reserved1 >>= 2;\n\n    MP4_GET1BYTE( p_avcC->i_reserved2 );\n    p_avcC->i_sps = p_avcC->i_reserved2&0x1f;\n    p_avcC->i_reserved2 >>= 5;\n\n    if( p_avcC->i_sps > 0 )\n    {\n        p_avcC->i_sps_length = calloc( p_avcC->i_sps, sizeof( uint16_t ) );\n        p_avcC->sps = calloc( p_avcC->i_sps, sizeof( uint8_t* ) );\n\n        if( !p_avcC->i_sps_length || !p_avcC->sps )\n            goto error;\n\n        for( i = 0; i < p_avcC->i_sps && i_read > 2; i++ )\n        {\n            MP4_GET2BYTES( p_avcC->i_sps_length[i] );\n            if ( p_avcC->i_sps_length[i] > i_read )\n                goto error;\n            p_avcC->sps[i] = malloc( p_avcC->i_sps_length[i] );\n            if( p_avcC->sps[i] )\n                memcpy( p_avcC->sps[i], p_peek, p_avcC->i_sps_length[i] );\n\n            p_peek += p_avcC->i_sps_length[i];\n            i_read -= p_avcC->i_sps_length[i];\n        }\n        if ( i != p_avcC->i_sps )\n            goto error;\n    }\n\n    MP4_GET1BYTE( p_avcC->i_pps );\n    if( p_avcC->i_pps > 0 )\n    {\n        p_avcC->i_pps_length = calloc( p_avcC->i_pps, sizeof( uint16_t ) );\n        p_avcC->pps = calloc( p_avcC->i_pps, sizeof( uint8_t* ) );\n\n        if( !p_avcC->i_pps_length || !p_avcC->pps )\n            goto error;\n\n        for( i = 0; i < p_avcC->i_pps && i_read > 2; i++ )\n        {\n            MP4_GET2BYTES( p_avcC->i_pps_length[i] );\n            if( p_avcC->i_pps_length[i] > i_read )\n                goto error;\n            p_avcC->pps[i] = malloc( p_avcC->i_pps_length[i] );\n            if( p_avcC->pps[i] )\n                memcpy( p_avcC->pps[i], p_peek, p_avcC->i_pps_length[i] );\n\n            p_peek += p_avcC->i_pps_length[i];\n            i_read -= p_avcC->i_pps_length[i];\n        }\n        if ( i != p_avcC->i_pps )\n            goto error;\n    }\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"avcC\\\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d\",\n             p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,\n             p_avcC->i_length_size,\n             p_avcC->i_sps, p_avcC->i_pps );\n    for( i = 0; i < p_avcC->i_sps; i++ )\n    {\n        msg_Dbg( p_stream, \"         - sps[%d] length=%d\",\n                 i, p_avcC->i_sps_length[i] );\n    }\n    for( i = 0; i < p_avcC->i_pps; i++ )\n    {\n        msg_Dbg( p_stream, \"         - pps[%d] length=%d\",\n                 i, p_avcC->i_pps_length[i] );\n    }\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n\nerror:\n    MP4_FreeBox_avcC( p_box );\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic int MP4_ReadBox_WMA2( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_WMA2_t );\n\n    MP4_Box_data_WMA2_t *p_WMA2 = p_box->data.p_WMA2;\n\n    MP4_GET2BYTESLE( p_WMA2->Format.wFormatTag );\n    MP4_GET2BYTESLE( p_WMA2->Format.nChannels );\n    MP4_GET4BYTESLE( p_WMA2->Format.nSamplesPerSec );\n    MP4_GET4BYTESLE( p_WMA2->Format.nAvgBytesPerSec );\n    MP4_GET2BYTESLE( p_WMA2->Format.nBlockAlign );\n    MP4_GET2BYTESLE( p_WMA2->Format.wBitsPerSample );\n\n    uint16_t i_cbSize;\n    MP4_GET2BYTESLE( i_cbSize );\n\n    if ( i_read < 0 || i_cbSize > i_read )\n        goto error;\n\n    p_WMA2->i_extra = i_cbSize;\n    if ( p_WMA2->i_extra )\n    {\n        p_WMA2->p_extra = malloc( p_WMA2->i_extra );\n        if ( ! p_WMA2->p_extra )\n            goto error;\n        memcpy( p_WMA2->p_extra, p_peek, p_WMA2->i_extra );\n    }\n\n    MP4_READBOX_EXIT( 1 );\n\nerror:\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic void MP4_FreeBox_WMA2( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_WMA2->p_extra );\n}\n\nstatic int MP4_ReadBox_strf( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_strf_t );\n\n    MP4_Box_data_strf_t *p_strf = p_box->data.p_strf;\n\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biSize );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biWidth );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biHeight );\n    MP4_GET2BYTESLE( p_strf->bmiHeader.biPlanes );\n    MP4_GET2BYTESLE( p_strf->bmiHeader.biBitCount );\n    MP4_GETFOURCC( p_strf->bmiHeader.biCompression );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biSizeImage );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biXPelsPerMeter );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biYPelsPerMeter );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biClrUsed );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biClrImportant );\n\n    if ( i_read < 0 )\n        goto error;\n\n    p_strf->i_extra = i_read;\n    if ( p_strf->i_extra )\n    {\n        p_strf->p_extra = malloc( p_strf->i_extra );\n        if ( ! p_strf->p_extra )\n            goto error;\n        memcpy( p_strf->p_extra, p_peek, i_read );\n    }\n\n    MP4_READBOX_EXIT( 1 );\n\nerror:\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic void MP4_FreeBox_strf( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_strf->p_extra );\n}\n\nstatic int MP4_ReadBox_ASF( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_ASF_t );\n\n    MP4_Box_data_ASF_t *p_asf = p_box->data.p_asf;\n\n    if (i_read != 8)\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET1BYTE( p_asf->i_stream_number );\n    /* remaining is unknown */\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_stsdext_chan( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_chan_t );\n    MP4_Box_data_chan_t *p_chan = p_box->data.p_chan;\n\n    if ( i_read < 16 )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET1BYTE( p_chan->i_version );\n    MP4_GET3BYTES( p_chan->i_channels_flags );\n    MP4_GET4BYTES( p_chan->layout.i_channels_layout_tag );\n    MP4_GET4BYTES( p_chan->layout.i_channels_bitmap );\n    MP4_GET4BYTES( p_chan->layout.i_channels_description_count );\n\n    size_t i_descsize = 8 + 3 * sizeof(float);\n    if ( (size_t)i_read < p_chan->layout.i_channels_description_count * i_descsize )\n        MP4_READBOX_EXIT( 0 );\n\n    p_chan->layout.p_descriptions =\n        malloc( p_chan->layout.i_channels_description_count * i_descsize );\n\n    if ( !p_chan->layout.p_descriptions )\n        MP4_READBOX_EXIT( 0 );\n\n    uint32_t i;\n    for( i=0; i<p_chan->layout.i_channels_description_count; i++ )\n    {\n        if ( i_read < 20 )\n            break;\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].i_channel_label );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].i_channel_flags );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].f_coordinates[0] );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].f_coordinates[1] );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].f_coordinates[2] );\n    }\n    if ( i<p_chan->layout.i_channels_description_count )\n        p_chan->layout.i_channels_description_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"chan\\\" flags=0x%x tag=0x%x bitmap=0x%x descriptions=%u\",\n             p_chan->i_channels_flags, p_chan->layout.i_channels_layout_tag,\n             p_chan->layout.i_channels_bitmap, p_chan->layout.i_channels_description_count );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stsdext_chan( MP4_Box_t *p_box )\n{\n    MP4_Box_data_chan_t *p_chan = p_box->data.p_chan;\n    free( p_chan->layout.p_descriptions );\n}\n\nstatic int MP4_ReadBox_dec3( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_dec3_t );\n\n    MP4_Box_data_dec3_t *p_dec3 = p_box->data.p_dec3;\n\n    unsigned i_header;\n    MP4_GET2BYTES( i_header );\n\n    p_dec3->i_data_rate = i_header >> 3;\n    p_dec3->i_num_ind_sub = (i_header & 0x7) + 1;\n    for (uint8_t i = 0; i < p_dec3->i_num_ind_sub; i++) {\n        MP4_GET3BYTES( i_header );\n        p_dec3->stream[i].i_fscod = ( i_header >> 22 ) & 0x03;\n        p_dec3->stream[i].i_bsid  = ( i_header >> 17 ) & 0x01f;\n        p_dec3->stream[i].i_bsmod = ( i_header >> 12 ) & 0x01f;\n        p_dec3->stream[i].i_acmod = ( i_header >> 9 ) & 0x07;\n        p_dec3->stream[i].i_lfeon = ( i_header >> 8 ) & 0x01;\n        p_dec3->stream[i].i_num_dep_sub = (i_header >> 1) & 0x0f;\n        if (p_dec3->stream[i].i_num_dep_sub) {\n            MP4_GET1BYTE( p_dec3->stream[i].i_chan_loc );\n            p_dec3->stream[i].i_chan_loc |= (i_header & 1) << 8;\n        } else\n            p_dec3->stream[i].i_chan_loc = 0;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n        \"read box: \\\"dec3\\\" bitrate %dkbps %d independant substreams\",\n            p_dec3->i_data_rate, p_dec3->i_num_ind_sub);\n\n    for (uint8_t i = 0; i < p_dec3->i_num_ind_sub; i++)\n        msg_Dbg( p_stream,\n                \"\\tstream %d: bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x \"\n                \"num dependant subs=%d chan_loc=0x%x\",\n                i, p_dec3->stream[i].i_bsid, p_dec3->stream[i].i_bsmod, p_dec3->stream[i].i_acmod,\n                p_dec3->stream[i].i_lfeon, p_dec3->stream[i].i_num_dep_sub, p_dec3->stream[i].i_chan_loc );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_dac3( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_dac3_t *p_dac3;\n    MP4_READBOX_ENTER( MP4_Box_data_dac3_t );\n\n    p_dac3 = p_box->data.p_dac3;\n\n    unsigned i_header;\n    MP4_GET3BYTES( i_header );\n\n    p_dac3->i_fscod = ( i_header >> 22 ) & 0x03;\n    p_dac3->i_bsid  = ( i_header >> 17 ) & 0x01f;\n    p_dac3->i_bsmod = ( i_header >> 14 ) & 0x07;\n    p_dac3->i_acmod = ( i_header >> 11 ) & 0x07;\n    p_dac3->i_lfeon = ( i_header >> 10 ) & 0x01;\n    p_dac3->i_bitrate_code = ( i_header >> 5) & 0x1f;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"dac3\\\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x\",\n             p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_dvc1( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_dvc1_t *p_dvc1;\n\n    MP4_READBOX_ENTER( MP4_Box_data_dvc1_t );\n    p_dvc1 = p_box->data.p_dvc1;\n\n    MP4_GET1BYTE( p_dvc1->i_profile_level ); /* profile is on 4bits, level 3bits */\n    uint8_t i_profile = (p_dvc1->i_profile_level & 0xf0) >> 4;\n    if( i_profile != 0x06 && i_profile != 0x0c )\n    {\n        msg_Warn( p_stream, \"unsupported VC-1 profile (%\"PRIu8\"), please report\", i_profile );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n\n    p_dvc1->i_vc1 = p_box->i_size - 7; /* Header + profile_level */\n\n    if( p_dvc1->i_vc1 > 0 )\n    {\n        uint8_t *p = p_dvc1->p_vc1 = malloc( p_dvc1->i_vc1 );\n        if( p )\n            memcpy( p, p_peek, i_read );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"dvc1\\\" profile=%\"PRIu8\" level=%i\",\n             i_profile, p_dvc1->i_profile_level & 0x0e >> 1 );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_enda( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_enda_t *p_enda;\n    MP4_READBOX_ENTER( MP4_Box_data_enda_t );\n\n    p_enda = p_box->data.p_enda;\n\n    MP4_GET2BYTES( p_enda->i_little_endian );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"enda\\\" little_endian=%d\", p_enda->i_little_endian );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_sample_soun( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    p_box->i_handler = ATOM_soun;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_soun_t );\n    p_box->data.p_sample_soun->p_qt_description = NULL;\n\n    /* Sanity check needed because the \"wave\" box does also contain an\n     * \"mp4a\" box that we don't understand. */\n    if( i_read < 28 )\n    {\n        i_read -= 30;\n        MP4_READBOX_EXIT( 1 );\n    }\n\n    for( unsigned i = 0; i < 6 ; i++ )\n    {\n        MP4_GET1BYTE( p_box->data.p_sample_soun->i_reserved1[i] );\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_data_reference_index );\n\n    /*\n     * XXX hack -> produce a copy of the nearly complete chunk\n     */\n    p_box->data.p_sample_soun->i_qt_description = 0;\n    p_box->data.p_sample_soun->p_qt_description = NULL;\n    if( i_read > 0 )\n    {\n        p_box->data.p_sample_soun->p_qt_description = malloc( i_read );\n        if( p_box->data.p_sample_soun->p_qt_description )\n        {\n            p_box->data.p_sample_soun->i_qt_description = i_read;\n            memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );\n        }\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_qt_version );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_qt_revision_level );\n    MP4_GET4BYTES( p_box->data.p_sample_soun->i_qt_vendor );\n\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_channelcount );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_samplesize );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_compressionid );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_reserved3 );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_sampleratehi );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_sampleratelo );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"soun\\\" stsd qt_version %\"PRIu16\" compid=%\"PRIx16,\n             p_box->data.p_sample_soun->i_qt_version,\n             p_box->data.p_sample_soun->i_compressionid );\n#endif\n\n    if( p_box->data.p_sample_soun->i_qt_version == 1 && i_read >= 16 )\n    {\n        /* SoundDescriptionV1 */\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_sample_per_packet );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_bytes_per_packet );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_bytes_per_frame );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_bytes_per_sample );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream,\n                 \"read box: \\\"soun\\\" V1 sample/packet=%d bytes/packet=%d \"\n                 \"bytes/frame=%d bytes/sample=%d\",\n                 p_box->data.p_sample_soun->i_sample_per_packet,\n                 p_box->data.p_sample_soun->i_bytes_per_packet,\n                 p_box->data.p_sample_soun->i_bytes_per_frame,\n                 p_box->data.p_sample_soun->i_bytes_per_sample );\n#endif\n        stream_Seek( p_stream, p_box->i_pos +\n                        mp4_box_headersize( p_box ) + 44 );\n    }\n    else if( p_box->data.p_sample_soun->i_qt_version == 2 && i_read >= 36 )\n    {\n        /* SoundDescriptionV2 */\n        double f_sample_rate;\n        int64_t i_dummy64;\n        uint32_t i_channel, i_extoffset, i_dummy32;\n\n        /* Checks */\n        if ( p_box->data.p_sample_soun->i_channelcount != 0x3  ||\n             p_box->data.p_sample_soun->i_samplesize != 0x0010 ||\n             p_box->data.p_sample_soun->i_compressionid != 0xFFFE ||\n             p_box->data.p_sample_soun->i_reserved3 != 0x0     ||\n             p_box->data.p_sample_soun->i_sampleratehi != 0x1  ||//65536\n             p_box->data.p_sample_soun->i_sampleratelo != 0x0 )  //remainder\n        {\n            msg_Err( p_stream, \"invalid stsd V2 box defaults\" );\n            MP4_READBOX_EXIT( 0 );\n        }\n        /* !Checks */\n\n        MP4_GET4BYTES( i_extoffset ); /* offset to stsd extentions */\n        MP4_GET8BYTES( i_dummy64 );\n        memcpy( &f_sample_rate, &i_dummy64, 8 );\n        msg_Dbg( p_stream, \"read box: %f Hz\", f_sample_rate );\n        p_box->data.p_sample_soun->i_sampleratehi = (int)f_sample_rate % BLOCK16x16;\n        p_box->data.p_sample_soun->i_sampleratelo = f_sample_rate / BLOCK16x16;\n\n        MP4_GET4BYTES( i_channel );\n        p_box->data.p_sample_soun->i_channelcount = i_channel;\n\n        MP4_GET4BYTES( i_dummy32 );\n        if ( i_dummy32 != 0x7F000000 )\n        {\n            msg_Err( p_stream, \"invalid stsd V2 box\" );\n            MP4_READBOX_EXIT( 0 );\n        }\n\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_constbitsperchannel );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_formatflags );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_constbytesperaudiopacket );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_constLPCMframesperaudiopacket );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"soun\\\" V2 rate=%f bitsperchannel=%u \"\n                           \"flags=%u bytesperpacket=%u lpcmframesperpacket=%u\",\n                 f_sample_rate,\n                 p_box->data.p_sample_soun->i_constbitsperchannel,\n                 p_box->data.p_sample_soun->i_formatflags,\n                 p_box->data.p_sample_soun->i_constbytesperaudiopacket,\n                 p_box->data.p_sample_soun->i_constLPCMframesperaudiopacket );\n#endif\n        if ( i_extoffset < p_box->i_size )\n            stream_Seek( p_stream, p_box->i_pos + i_extoffset );\n        else\n            stream_Seek( p_stream, p_box->i_pos + p_box->i_size );\n    }\n    else\n    {\n        p_box->data.p_sample_soun->i_sample_per_packet = 0;\n        p_box->data.p_sample_soun->i_bytes_per_packet = 0;\n        p_box->data.p_sample_soun->i_bytes_per_frame = 0;\n        p_box->data.p_sample_soun->i_bytes_per_sample = 0;\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"soun\\\" V0 or qt1/2 (rest=%\"PRId64\")\",\n                 i_read );\n#endif\n        stream_Seek( p_stream, p_box->i_pos +\n                        mp4_box_headersize( p_box ) + 28 );\n    }\n\n    if( p_box->i_type == ATOM_drms )\n    {\n        msg_Warn( p_stream, \"DRM protected streams are not supported.\" );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )\n    {\n        /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */\n        p_box->data.p_sample_soun->i_channelcount = 1;\n    }\n\n    /* Loads extensions */\n    MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"soun\\\" in stsd channel %d \"\n             \"sample size %d sample rate %f\",\n             p_box->data.p_sample_soun->i_channelcount,\n             p_box->data.p_sample_soun->i_samplesize,\n             (float)p_box->data.p_sample_soun->i_sampleratehi +\n             (float)p_box->data.p_sample_soun->i_sampleratelo / BLOCK16x16 );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic void MP4_FreeBox_sample_soun( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sample_soun->p_qt_description );\n}\n\n\nint MP4_ReadBox_sample_vide( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    p_box->i_handler = ATOM_vide;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_vide_t );\n\n    for( unsigned i = 0; i < 6 ; i++ )\n    {\n        MP4_GET1BYTE( p_box->data.p_sample_vide->i_reserved1[i] );\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_data_reference_index );\n\n    /*\n     * XXX hack -> produce a copy of the nearly complete chunk\n     */\n    if( i_read > 0 )\n    {\n        p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );\n        if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )\n            MP4_READBOX_EXIT( 0 );\n        p_box->data.p_sample_vide->i_qt_image_description = i_read;\n        memcpy( p_box->data.p_sample_vide->p_qt_image_description,\n                p_peek, i_read );\n    }\n    else\n    {\n        p_box->data.p_sample_vide->i_qt_image_description = 0;\n        p_box->data.p_sample_vide->p_qt_image_description = NULL;\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_version );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_revision_level );\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_vendor );\n\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_temporal_quality );\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_spatial_quality );\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_width );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_height );\n\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_horizresolution );\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_vertresolution );\n\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_data_size );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_frame_count );\n\n    if ( i_read < 32 )\n        MP4_READBOX_EXIT( 0 );\n    memcpy( &p_box->data.p_sample_vide->i_compressorname, p_peek, 32 );\n    p_peek += 32; i_read -= 32;\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_depth );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_color_table );\n\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78);\n\n    if( p_box->i_type == ATOM_drmi )\n    {\n        msg_Warn( p_stream, \"DRM protected streams are not supported.\" );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"vide\\\" in stsd %dx%d depth %d\",\n                      p_box->data.p_sample_vide->i_width,\n                      p_box->data.p_sample_vide->i_height,\n                      p_box->data.p_sample_vide->i_depth );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nvoid MP4_FreeBox_sample_vide( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sample_vide->p_qt_image_description );\n}\n\nstatic int MP4_ReadBox_sample_mp4s( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8 );\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n    return 1;\n}\n\nstatic int MP4_ReadBox_sample_text( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int32_t t;\n\n    p_box->i_handler = ATOM_text;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_text_t );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_reserved1 );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_reserved2 );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_data_reference_index );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_display_flags );\n\n    MP4_GET4BYTES( t );\n    switch( t )\n    {\n        /* FIXME search right signification */\n        case 1: // Center\n            p_box->data.p_sample_text->i_justification_horizontal = 1;\n            p_box->data.p_sample_text->i_justification_vertical = 1;\n            break;\n        case -1:    // Flush Right\n            p_box->data.p_sample_text->i_justification_horizontal = -1;\n            p_box->data.p_sample_text->i_justification_vertical = -1;\n            break;\n        case -2:    // Flush Left\n            p_box->data.p_sample_text->i_justification_horizontal = 0;\n            p_box->data.p_sample_text->i_justification_vertical = 0;\n            break;\n        case 0: // Flush Default\n        default:\n            p_box->data.p_sample_text->i_justification_horizontal = 1;\n            p_box->data.p_sample_text->i_justification_vertical = -1;\n            break;\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_background_color[0] );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_background_color[1] );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_background_color[2] );\n    p_box->data.p_sample_text->i_background_color[3] = 0xFF;\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_top );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_left );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_bottom );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_right );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"text\\\" in stsd text\" );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_sample_tx3g( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    p_box->i_handler = ATOM_text;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_text_t );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_reserved1 );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_reserved2 );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_data_reference_index );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_display_flags );\n\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_justification_horizontal );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_justification_vertical );\n\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[0] );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[1] );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[2] );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[3] );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_top );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_left );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_bottom );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_right );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_reserved3 );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_font_id );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_font_face );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_font_size );\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_font_color );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"tx3g\\\" in stsd text\" );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\n#if 0\n/* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */\nstatic void MP4_FreeBox_sample_text( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sample_text->psz_text_name );\n}\n#endif\n\n\nstatic int MP4_ReadBox_stsd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n\n    MP4_READBOX_ENTER( MP4_Box_data_stsd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsd );\n\n    MP4_GET4BYTES( p_box->data.p_stsd->i_entry_count );\n\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8 );\n\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsd\\\" entry-count %d\",\n                      p_box->data.p_stsd->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_stsz( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stsz_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsz );\n\n    MP4_GET4BYTES( p_box->data.p_stsz->i_sample_size );\n    MP4_GET4BYTES( p_box->data.p_stsz->i_sample_count );\n\n    if( p_box->data.p_stsz->i_sample_size == 0 )\n    {\n        p_box->data.p_stsz->i_entry_size =\n            calloc( p_box->data.p_stsz->i_sample_count, sizeof(uint32_t) );\n        if( unlikely( !p_box->data.p_stsz->i_entry_size ) )\n            MP4_READBOX_EXIT( 0 );\n\n        for( unsigned int i = 0; (i<p_box->data.p_stsz->i_sample_count)&&(i_read >= 4 ); i++ )\n        {\n            MP4_GET4BYTES( p_box->data.p_stsz->i_entry_size[i] );\n        }\n    }\n    else\n        p_box->data.p_stsz->i_entry_size = NULL;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsz\\\" sample-size %d sample-count %d\",\n                      p_box->data.p_stsz->i_sample_size,\n                      p_box->data.p_stsz->i_sample_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stsz( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stsz->i_entry_size );\n}\n\nstatic void MP4_FreeBox_stsc( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stsc->i_first_chunk );\n    FREENULL( p_box->data.p_stsc->i_samples_per_chunk );\n    FREENULL( p_box->data.p_stsc->i_sample_description_index );\n}\n\nstatic int MP4_ReadBox_stsc( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stsc_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsc );\n\n    MP4_GET4BYTES( p_box->data.p_stsc->i_entry_count );\n\n    p_box->data.p_stsc->i_first_chunk =\n        calloc( p_box->data.p_stsc->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stsc->i_samples_per_chunk =\n        calloc( p_box->data.p_stsc->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stsc->i_sample_description_index =\n        calloc( p_box->data.p_stsc->i_entry_count, sizeof(uint32_t) );\n    if( unlikely( p_box->data.p_stsc->i_first_chunk == NULL\n     || p_box->data.p_stsc->i_samples_per_chunk == NULL\n     || p_box->data.p_stsc->i_sample_description_index == NULL ) )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    for( unsigned int i = 0; (i < p_box->data.p_stsc->i_entry_count )&&( i_read >= 12 );i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_stsc->i_first_chunk[i] );\n        MP4_GET4BYTES( p_box->data.p_stsc->i_samples_per_chunk[i] );\n        MP4_GET4BYTES( p_box->data.p_stsc->i_sample_description_index[i] );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsc\\\" entry-count %d\",\n                      p_box->data.p_stsc->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_stco_co64( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_co64_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_co64 );\n\n    MP4_GET4BYTES( p_box->data.p_co64->i_entry_count );\n\n    p_box->data.p_co64->i_chunk_offset =\n        calloc( p_box->data.p_co64->i_entry_count, sizeof(uint64_t) );\n    if( p_box->data.p_co64->i_chunk_offset == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned int i = 0; i < p_box->data.p_co64->i_entry_count; i++ )\n    {\n        if( p_box->i_type == ATOM_stco )\n        {\n            if( i_read < 4 )\n            {\n                break;\n            }\n            MP4_GET4BYTES( p_box->data.p_co64->i_chunk_offset[i] );\n        }\n        else\n        {\n            if( i_read < 8 )\n            {\n                break;\n            }\n            MP4_GET8BYTES( p_box->data.p_co64->i_chunk_offset[i] );\n        }\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"co64\\\" entry-count %d\",\n                      p_box->data.p_co64->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stco_co64( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_co64->i_chunk_offset );\n}\n\nstatic int MP4_ReadBox_stss( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stss_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stss );\n\n    MP4_GET4BYTES( p_box->data.p_stss->i_entry_count );\n\n    p_box->data.p_stss->i_sample_number =\n        calloc( p_box->data.p_stss->i_entry_count, sizeof(uint32_t) );\n    if( unlikely( p_box->data.p_stss->i_sample_number == NULL ) )\n        MP4_READBOX_EXIT( 0 );\n\n    unsigned int i;\n    for( i = 0; (i < p_box->data.p_stss->i_entry_count )&&( i_read >= 4 ); i++ )\n    {\n\n        MP4_GET4BYTES( p_box->data.p_stss->i_sample_number[i] );\n        /* XXX in libmp4 sample begin at 0 */\n        p_box->data.p_stss->i_sample_number[i]--;\n    }\n    if ( i < p_box->data.p_stss->i_entry_count )\n        p_box->data.p_stss->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stss\\\" entry-count %d\",\n                      p_box->data.p_stss->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stss( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stss->i_sample_number );\n}\n\nstatic void MP4_FreeBox_stsh( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stsh->i_shadowed_sample_number );\n    FREENULL( p_box->data.p_stsh->i_sync_sample_number );\n}\n\nstatic int MP4_ReadBox_stsh( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stsh_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsh );\n\n\n    MP4_GET4BYTES( p_box->data.p_stsh->i_entry_count );\n\n    p_box->data.p_stsh->i_shadowed_sample_number =\n        calloc( p_box->data.p_stsh->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stsh->i_sync_sample_number =\n        calloc( p_box->data.p_stsh->i_entry_count, sizeof(uint32_t) );\n\n    if( p_box->data.p_stsh->i_shadowed_sample_number == NULL\n     || p_box->data.p_stsh->i_sync_sample_number == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    unsigned i;\n    for( i = 0; (i < p_box->data.p_stss->i_entry_count )&&( i_read >= 8 ); i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_stsh->i_shadowed_sample_number[i] );\n        MP4_GET4BYTES( p_box->data.p_stsh->i_sync_sample_number[i] );\n    }\n    if ( i < p_box->data.p_stss->i_entry_count )\n        p_box->data.p_stss->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsh\\\" entry-count %d\",\n                      p_box->data.p_stsh->i_entry_count );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_stdp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stdp_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stdp );\n\n    p_box->data.p_stdp->i_priority =\n        calloc( i_read / 2, sizeof(uint16_t) );\n\n    if( unlikely( !p_box->data.p_stdp->i_priority ) )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned i = 0; i < i_read / 2 ; i++ )\n    {\n        MP4_GET2BYTES( p_box->data.p_stdp->i_priority[i] );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stdp\\\" entry-count %\"PRId64,\n                      i_read / 2 );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stdp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stdp->i_priority );\n}\n\nstatic void MP4_FreeBox_padb( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_padb->i_reserved1 );\n    FREENULL( p_box->data.p_padb->i_pad2 );\n    FREENULL( p_box->data.p_padb->i_reserved2 );\n    FREENULL( p_box->data.p_padb->i_pad1 );\n}\n\nstatic int MP4_ReadBox_padb( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint32_t count;\n\n    MP4_READBOX_ENTER( MP4_Box_data_padb_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_padb );\n\n    MP4_GET4BYTES( p_box->data.p_padb->i_sample_count );\n    count = (p_box->data.p_padb->i_sample_count + 1) / 2;\n\n    p_box->data.p_padb->i_reserved1 = calloc( count, sizeof(uint16_t) );\n    p_box->data.p_padb->i_pad2 = calloc( count, sizeof(uint16_t) );\n    p_box->data.p_padb->i_reserved2 = calloc( count, sizeof(uint16_t) );\n    p_box->data.p_padb->i_pad1 = calloc( count, sizeof(uint16_t) );\n    if( p_box->data.p_padb->i_reserved1 == NULL\n     || p_box->data.p_padb->i_pad2 == NULL\n     || p_box->data.p_padb->i_reserved2 == NULL\n     || p_box->data.p_padb->i_pad1 == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    for( unsigned int i = 0; i < i_read / 2 ; i++ )\n    {\n        if( i >= count )\n        {\n            MP4_READBOX_EXIT( 0 );\n        }\n        p_box->data.p_padb->i_reserved1[i] = ( (*p_peek) >> 7 )&0x01;\n        p_box->data.p_padb->i_pad2[i] = ( (*p_peek) >> 4 )&0x07;\n        p_box->data.p_padb->i_reserved1[i] = ( (*p_peek) >> 3 )&0x01;\n        p_box->data.p_padb->i_pad1[i] = ( (*p_peek) )&0x07;\n\n        p_peek += 1; i_read -= 1;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stdp\\\" entry-count %\"PRId64,\n                      i_read / 2 );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_elst( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_elst->i_segment_duration );\n    FREENULL( p_box->data.p_elst->i_media_time );\n    FREENULL( p_box->data.p_elst->i_media_rate_integer );\n    FREENULL( p_box->data.p_elst->i_media_rate_fraction );\n}\n\nstatic int MP4_ReadBox_elst( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_elst_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_elst );\n\n\n    MP4_GET4BYTES( p_box->data.p_elst->i_entry_count );\n\n    p_box->data.p_elst->i_segment_duration =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(uint64_t) );\n    p_box->data.p_elst->i_media_time =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(int64_t) );\n    p_box->data.p_elst->i_media_rate_integer =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(uint16_t) );\n    p_box->data.p_elst->i_media_rate_fraction =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(uint16_t) );\n    if( p_box->data.p_elst->i_segment_duration == NULL\n     || p_box->data.p_elst->i_media_time == NULL\n     || p_box->data.p_elst->i_media_rate_integer == NULL\n     || p_box->data.p_elst->i_media_rate_fraction == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    unsigned i;\n    for( i = 0; i < p_box->data.p_elst->i_entry_count; i++ )\n    {\n        if( p_box->data.p_elst->i_version == 1 )\n        {\n            if ( i_read < 20 )\n                break;\n            MP4_GET8BYTES( p_box->data.p_elst->i_segment_duration[i] );\n\n            MP4_GET8BYTES( p_box->data.p_elst->i_media_time[i] );\n        }\n        else\n        {\n            if ( i_read < 12 )\n                break;\n            MP4_GET4BYTES( p_box->data.p_elst->i_segment_duration[i] );\n\n            MP4_GET4BYTES( p_box->data.p_elst->i_media_time[i] );\n            p_box->data.p_elst->i_media_time[i] = (int32_t)p_box->data.p_elst->i_media_time[i];\n        }\n\n        MP4_GET2BYTES( p_box->data.p_elst->i_media_rate_integer[i] );\n        MP4_GET2BYTES( p_box->data.p_elst->i_media_rate_fraction[i] );\n    }\n    if ( i < p_box->data.p_elst->i_entry_count )\n        p_box->data.p_elst->i_entry_count = i;\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"elst\\\" entry-count %lu\",\n             (unsigned long)p_box->data.p_elst->i_entry_count );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_cprt( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint16_t i_language;\n    bool b_mac;\n\n    MP4_READBOX_ENTER( MP4_Box_data_cprt_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );\n\n    MP4_GET2BYTES( i_language );\n    decodeQtLanguageCode( i_language, p_box->data.p_cprt->rgs_language, &b_mac );\n\n    MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"cprt\\\" language %3.3s notice %s\",\n                      p_box->data.p_cprt->rgs_language,\n                      p_box->data.p_cprt->psz_notice );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_cprt( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_cprt->psz_notice );\n}\n\n\nstatic int MP4_ReadBox_dcom( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_dcom_t );\n\n    MP4_GETFOURCC( p_box->data.p_dcom->i_algorithm );\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"dcom\\\" compression algorithm : %4.4s\",\n                      (char*)&p_box->data.p_dcom->i_algorithm );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_cmvd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_cmvd_t );\n\n    MP4_GET4BYTES( p_box->data.p_cmvd->i_uncompressed_size );\n\n    p_box->data.p_cmvd->i_compressed_size = i_read;\n\n    if( !( p_box->data.p_cmvd->p_data = malloc( i_read ) ) )\n        MP4_READBOX_EXIT( 0 );\n\n    /* now copy compressed data */\n    memcpy( p_box->data.p_cmvd->p_data, p_peek,i_read);\n\n    p_box->data.p_cmvd->b_compressed = 1;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"cmvd\\\" compressed data size %d\",\n                      p_box->data.p_cmvd->i_compressed_size );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\nstatic void MP4_FreeBox_cmvd( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_cmvd->p_data );\n}\n\n\nstatic int MP4_ReadBox_cmov( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_t *p_dcom;\n    MP4_Box_t *p_cmvd;\n\n#ifdef HAVE_ZLIB_H\n    stream_t *p_stream_memory;\n    z_stream z_data;\n    uint8_t *p_data;\n    int i_result;\n#endif\n\n    if( !( p_box->data.p_cmov = calloc(1, sizeof( MP4_Box_data_cmov_t ) ) ) )\n        return 0;\n\n    if( !p_box->p_father ||\n        ( p_box->p_father->i_type != ATOM_moov &&\n          p_box->p_father->i_type != ATOM_foov ) )\n    {\n        msg_Warn( p_stream, \"Read box: \\\"cmov\\\" box alone\" );\n        return 1;\n    }\n\n    if( !MP4_ReadBoxContainer( p_stream, p_box ) )\n    {\n        return 0;\n    }\n\n    if( ( p_dcom = MP4_BoxGet( p_box, \"dcom\" ) ) == NULL ||\n        ( p_cmvd = MP4_BoxGet( p_box, \"cmvd\" ) ) == NULL ||\n        p_cmvd->data.p_cmvd->p_data == NULL )\n    {\n        msg_Warn( p_stream, \"read box: \\\"cmov\\\" incomplete\" );\n        return 0;\n    }\n\n    if( p_dcom->data.p_dcom->i_algorithm != ATOM_zlib )\n    {\n        msg_Dbg( p_stream, \"read box: \\\"cmov\\\" compression algorithm : %4.4s \"\n                 \"not supported\", (char*)&p_dcom->data.p_dcom->i_algorithm );\n        return 0;\n    }\n\n#ifndef HAVE_ZLIB_H\n    msg_Dbg( p_stream, \"read box: \\\"cmov\\\" zlib unsupported\" );\n    return 0;\n\n#else\n    /* decompress data */\n    /* allocate a new buffer */\n    if( !( p_data = malloc( p_cmvd->data.p_cmvd->i_uncompressed_size ) ) )\n        return 0;\n    /* init default structures */\n    z_data.next_in   = p_cmvd->data.p_cmvd->p_data;\n    z_data.avail_in  = p_cmvd->data.p_cmvd->i_compressed_size;\n    z_data.next_out  = p_data;\n    z_data.avail_out = p_cmvd->data.p_cmvd->i_uncompressed_size;\n    z_data.zalloc    = (alloc_func)Z_NULL;\n    z_data.zfree     = (free_func)Z_NULL;\n    z_data.opaque    = (voidpf)Z_NULL;\n\n    /* init zlib */\n    if( inflateInit( &z_data ) != Z_OK )\n    {\n        msg_Err( p_stream, \"read box: \\\"cmov\\\" error while uncompressing\" );\n        free( p_data );\n        return 0;\n    }\n\n    /* uncompress */\n    i_result = inflate( &z_data, Z_NO_FLUSH );\n    if( i_result != Z_OK && i_result != Z_STREAM_END )\n    {\n        msg_Err( p_stream, \"read box: \\\"cmov\\\" error while uncompressing\" );\n        free( p_data );\n        return 0;\n    }\n\n    if( p_cmvd->data.p_cmvd->i_uncompressed_size != z_data.total_out )\n    {\n        msg_Warn( p_stream, \"read box: \\\"cmov\\\" uncompressing data size \"\n                  \"mismatch\" );\n    }\n    p_cmvd->data.p_cmvd->i_uncompressed_size = z_data.total_out;\n\n    /* close zlib */\n    if( inflateEnd( &z_data ) != Z_OK )\n    {\n        msg_Warn( p_stream, \"read box: \\\"cmov\\\" error while uncompressing \"\n                  \"data (ignored)\" );\n    }\n\n    free( p_cmvd->data.p_cmvd->p_data );\n    p_cmvd->data.p_cmvd->p_data = p_data;\n    p_cmvd->data.p_cmvd->b_compressed = 0;\n\n    msg_Dbg( p_stream, \"read box: \\\"cmov\\\" box successfully uncompressed\" );\n\n    /* now create a memory stream */\n    p_stream_memory =\n        stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->p_data,\n                          p_cmvd->data.p_cmvd->i_uncompressed_size, true );\n\n    /* and read uncompressd moov */\n    p_box->data.p_cmov->p_moov = MP4_ReadBox( p_stream_memory, NULL );\n\n    stream_Delete( p_stream_memory );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"cmov\\\" compressed movie header completed\");\n#endif\n\n    return p_box->data.p_cmov->p_moov ? 1 : 0;\n#endif /* HAVE_ZLIB_H */\n}\n\nstatic int MP4_ReadBox_rdrf( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint32_t i_len;\n    MP4_READBOX_ENTER( MP4_Box_data_rdrf_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );\n    MP4_GETFOURCC( p_box->data.p_rdrf->i_ref_type );\n    MP4_GET4BYTES( i_len );\n    i_len++;\n\n    if( i_len > 0 )\n    {\n        p_box->data.p_rdrf->psz_ref = malloc( i_len );\n        if( p_box->data.p_rdrf->psz_ref == NULL )\n            MP4_READBOX_EXIT( 0 );\n        i_len--;\n\n        for( unsigned i = 0; i < i_len; i++ )\n        {\n            MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );\n        }\n        p_box->data.p_rdrf->psz_ref[i_len] = '\\0';\n    }\n    else\n    {\n        p_box->data.p_rdrf->psz_ref = NULL;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n            \"read box: \\\"rdrf\\\" type:%4.4s ref %s\",\n            (char*)&p_box->data.p_rdrf->i_ref_type,\n            p_box->data.p_rdrf->psz_ref );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_rdrf( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_rdrf->psz_ref );\n}\n\n\nstatic int MP4_ReadBox_rmdr( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_rmdr_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );\n\n    MP4_GET4BYTES( p_box->data.p_rmdr->i_rate );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"rmdr\\\" rate:%d\",\n             p_box->data.p_rmdr->i_rate );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_rmqu( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_rmqu_t );\n\n    MP4_GET4BYTES( p_box->data.p_rmqu->i_quality );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"rmqu\\\" quality:%d\",\n             p_box->data.p_rmqu->i_quality );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_rmvc( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_rmvc_t );\n    MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );\n\n    MP4_GETFOURCC( p_box->data.p_rmvc->i_gestaltType );\n    MP4_GET4BYTES( p_box->data.p_rmvc->i_val1 );\n    MP4_GET4BYTES( p_box->data.p_rmvc->i_val2 );\n    MP4_GET2BYTES( p_box->data.p_rmvc->i_checkType );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"rmvc\\\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x\",\n             (char*)&p_box->data.p_rmvc->i_gestaltType,\n             p_box->data.p_rmvc->i_val1,p_box->data.p_rmvc->i_val2,\n             p_box->data.p_rmvc->i_checkType );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_frma( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_frma_t );\n\n    MP4_GETFOURCC( p_box->data.p_frma->i_type );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"frma\\\" i_type:%4.4s\",\n             (char *)&p_box->data.p_frma->i_type );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_skcr( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_skcr_t );\n\n    MP4_GET4BYTES( p_box->data.p_skcr->i_init );\n    MP4_GET4BYTES( p_box->data.p_skcr->i_encr );\n    MP4_GET4BYTES( p_box->data.p_skcr->i_decr );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"skcr\\\" i_init:%d i_encr:%d i_decr:%d\",\n             p_box->data.p_skcr->i_init,\n             p_box->data.p_skcr->i_encr,\n             p_box->data.p_skcr->i_decr );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_drms( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    VLC_UNUSED(p_box);\n    /* ATOMs 'user', 'key', 'iviv', and 'priv' will be skipped,\n     * so unless data decrypt itself by magic, there will be no playback,\n     * but we never know... */\n    msg_Warn( p_stream, \"DRM protected streams are not supported.\" );\n    return 1;\n}\n\nstatic int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_String( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_string->psz_text );\n}\n\nstatic int MP4_ReadBox_Binary( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_binary_t );\n    i_read = __MIN( i_read, UINT32_MAX );\n    if ( i_read > 0 )\n    {\n        p_box->data.p_binary->p_blob = malloc( i_read );\n        if ( p_box->data.p_binary->p_blob )\n        {\n            memcpy( p_box->data.p_binary->p_blob, p_peek, i_read );\n            p_box->data.p_binary->i_blob = i_read;\n        }\n    }\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_Binary( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_binary->p_blob );\n    p_box->data.p_binary->i_blob = 0;\n}\n\nstatic int MP4_ReadBox_data( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_data_t );\n    MP4_Box_data_data_t *p_data = p_box->data.p_data;\n\n    if ( i_read < 8 || i_read - 8 > UINT32_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    uint8_t i_type;\n    MP4_GET1BYTE( i_type );\n    if ( i_type != 0 )\n    {\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"skipping unknown 'data' atom with type %\"PRIu8, i_type );\n#endif\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    MP4_GET3BYTES( p_data->e_wellknowntype );\n    MP4_GET2BYTES( p_data->locale.i_country );\n    MP4_GET2BYTES( p_data->locale.i_language );\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read 'data' atom: knowntype=%\"PRIu32\", country=%\"PRIu16\" lang=%\"PRIu16\n                 \", size %\"PRId64\" bytes\", p_data->e_wellknowntype,\n                 p_data->locale.i_country, p_data->locale.i_language, i_read );\n#endif\n    p_box->data.p_data->p_blob = malloc( i_read );\n    if ( !p_box->data.p_data->p_blob )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_data->i_blob = i_read;\n    memcpy( p_box->data.p_data->p_blob, p_peek, i_read);\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_data( MP4_Box_t *p_box )\n{\n    free( p_box->data.p_data->p_blob );\n}\n\nstatic int MP4_ReadBox_Metadata( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    const uint8_t *p_peek;\n    if ( stream_Peek( p_stream, &p_peek, 16 ) < 16 )\n        return 0;\n    if ( stream_Read( p_stream, NULL, 8 ) < 8 )\n        return 0;\n    return MP4_ReadBoxContainerChildren( p_stream, p_box, ATOM_data );\n}\n\n/* Chapter support */\nstatic void MP4_FreeBox_chpl( MP4_Box_t *p_box )\n{\n    MP4_Box_data_chpl_t *p_chpl = p_box->data.p_chpl;\n    for( unsigned i = 0; i < p_chpl->i_chapter; i++ )\n        free( p_chpl->chapter[i].psz_name );\n}\n\nstatic int MP4_ReadBox_chpl( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_chpl_t *p_chpl;\n    uint32_t i_dummy;\n    VLC_UNUSED(i_dummy);\n    int i;\n    MP4_READBOX_ENTER( MP4_Box_data_chpl_t );\n\n    p_chpl = p_box->data.p_chpl;\n\n    MP4_GETVERSIONFLAGS( p_chpl );\n\n    if ( i_read < 5 || p_chpl->i_version != 0x1 )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET4BYTES( i_dummy );\n\n    MP4_GET1BYTE( p_chpl->i_chapter );\n\n    for( i = 0; i < p_chpl->i_chapter; i++ )\n    {\n        uint64_t i_start;\n        uint8_t i_len;\n        int i_copy;\n        if ( i_read < 9 )\n            break;\n        MP4_GET8BYTES( i_start );\n        MP4_GET1BYTE( i_len );\n\n        p_chpl->chapter[i].psz_name = malloc( i_len + 1 );\n        if( !p_chpl->chapter[i].psz_name )\n            MP4_READBOX_EXIT( 0 );\n\n        i_copy = __MIN( i_len, i_read );\n        if( i_copy > 0 )\n            memcpy( p_chpl->chapter[i].psz_name, p_peek, i_copy );\n        p_chpl->chapter[i].psz_name[i_copy] = '\\0';\n        p_chpl->chapter[i].i_start = i_start;\n\n        p_peek += i_copy;\n        i_read -= i_copy;\n    }\n\n    if ( i != p_chpl->i_chapter )\n        p_chpl->i_chapter = i;\n\n    /* Bubble sort by increasing start date */\n    do\n    {\n        for( i = 0; i < p_chpl->i_chapter - 1; i++ )\n        {\n            if( p_chpl->chapter[i].i_start > p_chpl->chapter[i+1].i_start )\n            {\n                char *psz = p_chpl->chapter[i+1].psz_name;\n                int64_t i64 = p_chpl->chapter[i+1].i_start;\n\n                p_chpl->chapter[i+1].psz_name = p_chpl->chapter[i].psz_name;\n                p_chpl->chapter[i+1].i_start = p_chpl->chapter[i].i_start;\n\n                p_chpl->chapter[i].psz_name = psz;\n                p_chpl->chapter[i].i_start = i64;\n\n                i = -1;\n                break;\n            }\n        }\n    } while( i == -1 );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"chpl\\\" %d chapters\",\n                       p_chpl->i_chapter );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tref_generic( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tref_generic_t );\n\n    p_box->data.p_tref_generic->i_track_ID = NULL;\n    p_box->data.p_tref_generic->i_entry_count = i_read / sizeof(uint32_t);\n    if( p_box->data.p_tref_generic->i_entry_count > 0 )\n        p_box->data.p_tref_generic->i_track_ID = calloc( p_box->data.p_tref_generic->i_entry_count, sizeof(uint32_t) );\n    if( p_box->data.p_tref_generic->i_track_ID == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned i = 0; i < p_box->data.p_tref_generic->i_entry_count; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_tref_generic->i_track_ID[i] );\n    }\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"chap\\\" %d references\",\n                 p_box->data.p_tref_generic->i_entry_count );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\nstatic void MP4_FreeBox_tref_generic( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_tref_generic->i_track_ID );\n}\n\nstatic int MP4_ReadBox_keys( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_keys_t );\n\n    if ( i_read < 8 )\n        MP4_READBOX_EXIT( 0 );\n\n    uint32_t i_count;\n    MP4_GET4BYTES( i_count ); /* reserved + flags */\n    if ( i_count != 0 )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET4BYTES( i_count );\n    p_box->data.p_keys->p_entries = calloc( i_count, sizeof(*p_box->data.p_keys->p_entries) );\n    if ( !p_box->data.p_keys->p_entries )\n        MP4_READBOX_EXIT( 0 );\n    p_box->data.p_keys->i_entry_count = i_count;\n\n    uint32_t i=0;\n    for( ; i < i_count; i++ )\n    {\n        if ( i_read < 8 )\n            break;\n        uint32_t i_keysize;\n        MP4_GET4BYTES( i_keysize );\n        if ( (i_keysize < 8) || (i_keysize - 4 > i_read) )\n            break;\n        MP4_GETFOURCC( p_box->data.p_keys->p_entries[i].i_namespace );\n        i_keysize -= 8;\n        p_box->data.p_keys->p_entries[i].psz_value = malloc( i_keysize + 1 );\n        if ( !p_box->data.p_keys->p_entries[i].psz_value )\n            break;\n        memcpy( p_box->data.p_keys->p_entries[i].psz_value, p_peek, i_keysize );\n        p_box->data.p_keys->p_entries[i].psz_value[i_keysize] = 0;\n        p_peek += i_keysize;\n        i_read -= i_keysize;\n#ifdef MP4_ULTRA_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"keys\\\": %u '%s'\", i + 1,\n                 p_box->data.p_keys->p_entries[i].psz_value );\n#endif\n    }\n    if ( i < i_count )\n        p_box->data.p_keys->i_entry_count = i;\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_keys( MP4_Box_t *p_box )\n{\n    for( uint32_t i=0; i<p_box->data.p_keys->i_entry_count; i++ )\n        free( p_box->data.p_keys->p_entries[i].psz_value );\n    free( p_box->data.p_keys->p_entries );\n}\n\nstatic int MP4_ReadBox_meta( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint8_t meta_data[8];\n    int i_actually_read;\n\n    // skip over box header\n    i_actually_read = stream_Read( p_stream, meta_data, 8 );\n    if( i_actually_read < 8 )\n        return 0;\n\n    if ( p_box->p_father && p_box->p_father->i_type == ATOM_udta ) /* itunes udta/meta */\n    {\n        /* meta content starts with a 4 byte version/flags value (should be 0) */\n        i_actually_read = stream_Read( p_stream, meta_data, 4 );\n        if( i_actually_read < 4 || memcmp( meta_data, \"\\0\\0\\0\", 4 ) )\n            return 0;\n    }\n\n    if ( !MP4_ReadBoxContainerChildren( p_stream, p_box, ATOM_hdlr ) )\n        return 0;\n\n    /* Mandatory */\n    const MP4_Box_t *p_hdlr = MP4_BoxGet( p_box, \"hdlr\" );\n    if ( !p_hdlr || !BOXDATA(p_hdlr) ||\n         ( BOXDATA(p_hdlr)->i_handler_type != HANDLER_mdta &&\n           BOXDATA(p_hdlr)->i_handler_type != HANDLER_mdir ) ||\n         BOXDATA(p_hdlr)->i_version != 0 )\n        return 0;\n\n    /* then it behaves like a container */\n    return MP4_ReadBoxContainerRaw( p_stream, p_box );\n}\n\nstatic int MP4_ReadBox_iods( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    char i_unused;\n    VLC_UNUSED(i_unused);\n\n    MP4_READBOX_ENTER( MP4_Box_data_iods_t );\n    MP4_GETVERSIONFLAGS( p_box->data.p_iods );\n\n    MP4_GET1BYTE( i_unused ); /* tag */\n    MP4_GET1BYTE( i_unused ); /* length */\n\n    MP4_GET2BYTES( p_box->data.p_iods->i_object_descriptor ); /* 10bits, 6 other bits\n                                                              are used for other flags */\n    MP4_GET1BYTE( p_box->data.p_iods->i_OD_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_scene_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_audio_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_visual_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_graphics_profile_level );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"iods\\\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, \"\n             \"visual: %i, graphics: %i\",\n             p_box->data.p_iods->i_object_descriptor >> 6,\n             p_box->data.p_iods->i_OD_profile_level,\n             p_box->data.p_iods->i_scene_profile_level,\n             p_box->data.p_iods->i_audio_profile_level,\n             p_box->data.p_iods->i_visual_profile_level,\n             p_box->data.p_iods->i_graphics_profile_level );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_pasp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_pasp_t );\n\n    MP4_GET4BYTES( p_box->data.p_pasp->i_horizontal_spacing );\n    MP4_GET4BYTES( p_box->data.p_pasp->i_vertical_spacing );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"paps\\\" %dx%d\",\n             p_box->data.p_pasp->i_horizontal_spacing,\n             p_box->data.p_pasp->i_vertical_spacing);\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mehd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_mehd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mehd );\n    if( p_box->data.p_mehd->i_version == 1 )\n        MP4_GET8BYTES( p_box->data.p_mehd->i_fragment_duration );\n    else /* version == 0 */\n        MP4_GET4BYTES( p_box->data.p_mehd->i_fragment_duration );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"mehd\\\" frag dur. %\"PRIu64\"\",\n             p_box->data.p_mehd->i_fragment_duration );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_trex( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_trex_t );\n    MP4_GETVERSIONFLAGS( p_box->data.p_trex );\n\n    MP4_GET4BYTES( p_box->data.p_trex->i_track_ID );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_description_index );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_duration );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_size );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_flags );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"trex\\\" trackID: %\"PRIu32\"\",\n             p_box->data.p_trex->i_track_ID );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_sdtp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint32_t i_sample_count;\n    MP4_READBOX_ENTER( MP4_Box_data_sdtp_t );\n    MP4_Box_data_sdtp_t *p_sdtp = p_box->data.p_sdtp;\n    MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );\n    i_sample_count = i_read;\n\n    p_sdtp->p_sample_table = calloc( i_sample_count, 1 );\n\n    if( !p_sdtp->p_sample_table )\n        MP4_READBOX_EXIT( 0 );\n\n    for( uint32_t i = 0; i < i_sample_count; i++ )\n        MP4_GET1BYTE( p_sdtp->p_sample_table[i] );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"i_sample_count is %\"PRIu32\"\", i_sample_count );\n    if ( i_sample_count > 3 )\n        msg_Dbg( p_stream,\n             \"read box: \\\"sdtp\\\" head: %\"PRIx8\" %\"PRIx8\" %\"PRIx8\" %\"PRIx8\"\",\n                 p_sdtp->p_sample_table[0],\n                 p_sdtp->p_sample_table[1],\n                 p_sdtp->p_sample_table[2],\n                 p_sdtp->p_sample_table[3] );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_sdtp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sdtp->p_sample_table );\n}\n\nstatic int MP4_ReadBox_tsel( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tsel_t );\n    uint32_t i_version;\n    MP4_GET4BYTES( i_version );\n    if ( i_version != 0 || i_read < 4 )\n        MP4_READBOX_EXIT( 0 );\n    MP4_GET4BYTES( p_box->data.p_tsel->i_switch_group );\n    /* ignore list of attributes as es are present before switch */\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mfro( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_mfro_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mfro );\n    MP4_GET4BYTES( p_box->data.p_mfro->i_size );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"mfro\\\" size: %\"PRIu32\"\",\n             p_box->data.p_mfro->i_size);\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tfra( stream_t *p_stream, MP4_Box_t *p_box )\n{\n#define READ_VARIABLE_LENGTH(lengthvar, p_array) switch (lengthvar)\\\n{\\\n    case 0:\\\n        MP4_GET1BYTE( p_array[i] );\\\n        break;\\\n    case 1:\\\n        MP4_GET2BYTES( *((uint16_t *)&p_array[i*2]) );\\\n        break;\\\n    case 2:\\\n        MP4_GET3BYTES( *((uint32_t *)&p_array[i*4]) );\\\n        break;\\\n    case 3:\\\n        MP4_GET4BYTES( *((uint32_t *)&p_array[i*4]) );\\\n        break;\\\n    default:\\\n        goto error;\\\n}\n#define FIX_VARIABLE_LENGTH(lengthvar) if ( lengthvar == 3 ) lengthvar = 4\n\n    uint32_t i_number_of_entries;\n    MP4_READBOX_ENTER( MP4_Box_data_tfra_t );\n    MP4_Box_data_tfra_t *p_tfra = p_box->data.p_tfra;\n    MP4_GETVERSIONFLAGS( p_box->data.p_tfra );\n    if ( p_tfra->i_version > 1 )\n        MP4_READBOX_EXIT( 0 );\n    MP4_GET4BYTES( p_tfra->i_track_ID );\n    uint32_t i_lengths = 0;\n    MP4_GET4BYTES( i_lengths );\n    MP4_GET4BYTES( p_tfra->i_number_of_entries );\n    i_number_of_entries = p_tfra->i_number_of_entries;\n    p_tfra->i_length_size_of_traf_num = i_lengths >> 4;\n    p_tfra->i_length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;\n    p_tfra->i_length_size_of_sample_num = i_lengths & 0x03;\n\n    size_t size = 4 + 4*p_tfra->i_version; /* size in {4, 8} */\n    p_tfra->p_time = calloc( i_number_of_entries, size );\n    p_tfra->p_moof_offset = calloc( i_number_of_entries, size );\n\n    size = 1 + p_tfra->i_length_size_of_traf_num; /* size in [|1, 4|] */\n    if ( size == 3 ) size++;\n    p_tfra->p_traf_number = calloc( i_number_of_entries, size );\n    size = 1 + p_tfra->i_length_size_of_trun_num;\n    if ( size == 3 ) size++;\n    p_tfra->p_trun_number = calloc( i_number_of_entries, size );\n    size = 1 + p_tfra->i_length_size_of_sample_num;\n    if ( size == 3 ) size++;\n    p_tfra->p_sample_number = calloc( i_number_of_entries, size );\n\n    if( !p_tfra->p_time || !p_tfra->p_moof_offset || !p_tfra->p_traf_number\n                        || !p_tfra->p_trun_number || !p_tfra->p_sample_number )\n        goto error;\n\n    int i_fields_length = 3 + p_tfra->i_length_size_of_traf_num\n            + p_tfra->i_length_size_of_trun_num\n            + p_tfra->i_length_size_of_sample_num;\n\n    uint32_t i;\n    for( i = 0; i < i_number_of_entries; i++ )\n    {\n\n        if( p_tfra->i_version == 1 )\n        {\n            if ( i_read < i_fields_length + 16 )\n                break;\n            MP4_GET8BYTES( *((uint64_t *)&p_tfra->p_time[i*2]) );\n            MP4_GET8BYTES( *((uint64_t *)&p_tfra->p_moof_offset[i*2]) );\n        }\n        else\n        {\n            if ( i_read < i_fields_length + 8 )\n                break;\n            MP4_GET4BYTES( p_tfra->p_time[i] );\n            MP4_GET4BYTES( p_tfra->p_moof_offset[i] );\n        }\n\n        READ_VARIABLE_LENGTH(p_tfra->i_length_size_of_traf_num, p_tfra->p_traf_number);\n        READ_VARIABLE_LENGTH(p_tfra->i_length_size_of_trun_num, p_tfra->p_trun_number);\n        READ_VARIABLE_LENGTH(p_tfra->i_length_size_of_sample_num, p_tfra->p_sample_number);\n    }\n    if ( i < i_number_of_entries )\n        i_number_of_entries = i;\n\n    FIX_VARIABLE_LENGTH(p_tfra->i_length_size_of_traf_num);\n    FIX_VARIABLE_LENGTH(p_tfra->i_length_size_of_trun_num);\n    FIX_VARIABLE_LENGTH(p_tfra->i_length_size_of_sample_num);\n\n#ifdef MP4_ULTRA_VERBOSE\n    for( i = 0; i < i_number_of_entries; i++ )\n    {\n        if( p_tfra->i_version == 0 )\n        {\n            msg_Dbg( p_stream, \"tfra[%\"PRIu32\"] time[%\"PRIu32\"]: %\"PRIu32\", \"\n                               \"moof_offset[%\"PRIu32\"]: %\"PRIu32\"\",\n                     p_tfra->i_track_ID,\n                     i, p_tfra->p_time[i],\n                     i, p_tfra->p_moof_offset[i] );\n        }\n        else\n        {\n            msg_Dbg( p_stream, \"tfra[%\"PRIu32\"] time[%\"PRIu32\"]: %\"PRIu64\", \"\n                               \"moof_offset[%\"PRIu32\"]: %\"PRIu64\"\",\n                     p_tfra->i_track_ID,\n                     i, ((uint64_t *)(p_tfra->p_time))[i],\n                     i, ((uint64_t *)(p_tfra->p_moof_offset))[i] );\n        }\n    }\n#endif\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"tfra[%\"PRIu32\"] %\"PRIu32\" entries\",\n             p_tfra->i_track_ID, i_number_of_entries );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\nerror:\n    MP4_READBOX_EXIT( 0 );\n\n#undef READ_VARIABLE_LENGTH\n#undef FIX_VARIABLE_LENGTH\n}\n\nstatic void MP4_FreeBox_tfra( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_tfra->p_time );\n    FREENULL( p_box->data.p_tfra->p_moof_offset );\n    FREENULL( p_box->data.p_tfra->p_traf_number );\n    FREENULL( p_box->data.p_tfra->p_trun_number );\n    FREENULL( p_box->data.p_tfra->p_sample_number );\n}\n\nstatic int MP4_ReadBox_pnot( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if ( p_box->i_size != 20 )\n        return 0;\n    MP4_READBOX_ENTER( MP4_Box_data_pnot_t );\n    MP4_GET4BYTES( p_box->data.p_pnot->i_date );\n    uint16_t i_version;\n    MP4_GET2BYTES( i_version );\n    if ( i_version != 0 )\n        MP4_READBOX_EXIT( 0 );\n    MP4_GETFOURCC( p_box->data.p_pnot->i_type );\n    MP4_GET2BYTES( p_box->data.p_pnot->i_index );\n    MP4_READBOX_EXIT( 1 );\n}\n\n/* For generic */\nstatic int MP4_ReadBox_default( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if( !p_box->p_father )\n    {\n        goto unknown;\n    }\n    if( p_box->p_father->i_type == ATOM_stsd )\n    {\n        MP4_Box_t *p_mdia = MP4_BoxGet( p_box, \"../../../..\" );\n        MP4_Box_t *p_hdlr;\n\n        if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||\n            (p_hdlr = MP4_BoxGet( p_mdia, \"hdlr\" )) == NULL )\n        {\n            goto unknown;\n        }\n        switch( p_hdlr->data.p_hdlr->i_handler_type )\n        {\n            case ATOM_soun:\n                return MP4_ReadBox_sample_soun( p_stream, p_box );\n            case ATOM_vide:\n                return MP4_ReadBox_sample_vide( p_stream, p_box );\n            case ATOM_text:\n                return MP4_ReadBox_sample_text( p_stream, p_box );\n            case ATOM_tx3g:\n            case ATOM_sbtl:\n                return MP4_ReadBox_sample_tx3g( p_stream, p_box );\n            default:\n                msg_Warn( p_stream,\n                          \"unknown handler type in stsd (incompletely loaded)\" );\n                return 1;\n        }\n    }\n\nunknown:\n    if MP4_BOX_TYPE_ASCII()\n        msg_Warn( p_stream,\n                \"unknown box type %4.4s (incompletely loaded)\",\n                (char*)&p_box->i_type );\n    else\n        msg_Warn( p_stream,\n                \"unknown box type c%3.3s (incompletely loaded)\",\n                (char*)&p_box->i_type+1 );\n    p_box->e_flags |= BOX_FLAG_INCOMPLETE;\n\n    return 1;\n}\n\n/**** ------------------------------------------------------------------- ****/\n/****                   \"Higher level\" Functions                          ****/\n/**** ------------------------------------------------------------------- ****/\n\nstatic const struct\n{\n    uint32_t i_type;\n    int  (*MP4_ReadBox_function )( stream_t *p_stream, MP4_Box_t *p_box );\n    void (*MP4_FreeBox_function )( MP4_Box_t *p_box );\n    uint32_t i_parent; /* set parent to restrict, duplicating if needed; 0 for any */\n} MP4_Box_Function [] =\n{\n    /* Containers */\n    { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_foov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_foov },\n    { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_mdia },\n    { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_meta },\n    { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_udta },\n    { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_rmra },\n    { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_stsd },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_mp4a }, /* some quicktime mp4a/wave/mp4a.. */\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_WMA2 }, /* flip4mac */\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_in24 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_in32 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_fl32 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_fl64 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_QDMC },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_QDM2 },\n    { ATOM_ilst,    MP4_ReadBox_ilst,         MP4_FreeBox_Common, ATOM_meta },\n    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_ftyp },\n\n    /* specific box */\n    { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp, 0 },\n    { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common, 0 },\n    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common, ATOM_foov },\n    { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_load,    MP4_ReadBox_load,         MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common, ATOM_mdia },\n    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr,   ATOM_mdia },\n    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr,   ATOM_meta },\n    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr,   ATOM_minf },\n    { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_alis,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, ATOM_dref },\n    { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url, 0 },\n    { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn, 0 },\n    { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common, 0 },\n    { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts,   ATOM_stbl },\n    { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts,   ATOM_stbl },\n    { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common, ATOM_stbl },\n    { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz,   ATOM_stbl },\n    { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc,   ATOM_stbl },\n    { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64, ATOM_stbl },\n    { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64, ATOM_stbl },\n    { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss, ATOM_stbl },\n    { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh, ATOM_stbl },\n    { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp, 0 },\n    { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb, 0 },\n    { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst, ATOM_edts },\n    { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt, 0 },\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_wave }, /* mp4a in wave chunk */\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_mp4a },\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_mp4v },\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_mp4s },\n    { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common, 0 },\n    { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd, 0 },\n    { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC, ATOM_avc1 },\n    { ATOM_hvcC,    MP4_ReadBox_hvcC,         MP4_FreeBox_hvcC, 0 },\n    { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common, 0 },\n    { ATOM_dec3,    MP4_ReadBox_dec3,         MP4_FreeBox_Common, 0 },\n    { ATOM_dvc1,    MP4_ReadBox_dvc1,         MP4_FreeBox_Common, 0 },\n    { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common, 0 },\n    { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common, 0 },\n    { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common, 0 },\n    { ATOM_keys,    MP4_ReadBox_keys,         MP4_FreeBox_keys,   ATOM_meta },\n\n    /* Quicktime preview atoms, all at root */\n    { ATOM_pnot,    MP4_ReadBox_pnot,         MP4_FreeBox_Common, 0 },\n    { ATOM_pict,    MP4_ReadBox_Binary,       MP4_FreeBox_Binary, 0 },\n    { ATOM_PICT,    MP4_ReadBox_Binary,       MP4_FreeBox_Binary, 0 },\n\n    /* Nothing to do with this box */\n    { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_binm,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n\n    /* Subtitles */\n    { ATOM_tx3g,    MP4_ReadBox_sample_tx3g,      MP4_FreeBox_Common, 0 },\n    //{ ATOM_text,    MP4_ReadBox_sample_text,      MP4_FreeBox_Common, 0 },\n\n    /* for codecs */\n    { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ac3,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_eac3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_lpcm,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_WMA2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd }, /* flip4mac */\n    /* Sound extensions */\n    { ATOM_chan,    MP4_ReadBox_stsdext_chan, MP4_FreeBox_stsdext_chan, 0 },\n    { ATOM_WMA2,    MP4_ReadBox_WMA2,         MP4_FreeBox_WMA2,        ATOM_wave }, /* flip4mac */\n\n    { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_WMV3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n\n    { ATOM_mjqt,    MP4_ReadBox_default,      NULL, 0 }, /* found in mjpa/b */\n    { ATOM_mjht,    MP4_ReadBox_default,      NULL, 0 },\n\n    { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n\n    { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n\n    { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, 0 },\n    { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, 0 },\n\n    { ATOM_strf,    MP4_ReadBox_strf,         MP4_FreeBox_strf,        ATOM_WMV3 }, /* flip4mac */\n    { ATOM_ASF ,    MP4_ReadBox_ASF,          MP4_FreeBox_Common,      ATOM_WMV3 }, /* flip4mac */\n    { ATOM_ASF ,    MP4_ReadBox_ASF,          MP4_FreeBox_Common,      ATOM_wave }, /* flip4mac */\n\n    { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common,      ATOM_stsd },\n\n    /* XXX there is 2 box where we could find this entry stbl and tref*/\n    { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common, 0 },\n\n    /* found in tref box */\n    { ATOM_dpnd,    MP4_ReadBox_default,      NULL, 0 },\n    { ATOM_ipir,    MP4_ReadBox_default,      NULL, 0 },\n    { ATOM_mpod,    MP4_ReadBox_default,      NULL, 0 },\n    { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic, 0 },\n\n    /* found in hnti */\n    { ATOM_rtp,     MP4_ReadBox_default,      NULL, 0 },\n\n    /* found in rmra/rmda */\n    { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf  , ATOM_rmda },\n    { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common, ATOM_rmda },\n    { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common, ATOM_rmda },\n    { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common, ATOM_rmda },\n\n    { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, 0 },\n    { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common, ATOM_sinf }, /* and rinf */\n    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common, ATOM_wave }, /* flip4mac */\n    { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common, 0 },\n\n    /* ilst meta tags */\n    { ATOM_0xa9ART, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9alb, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9cmt, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9com, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9day, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9des, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9enc, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9gen, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9grp, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9lyr, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9nam, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9too, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9trk, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9wrt, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_aART,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_atID,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst }, /* iTunes */\n    { ATOM_cnID,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst }, /* iTunes */\n    { ATOM_covr,    MP4_ReadBoxContainer,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_disk,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_flvr,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_gnre,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_rtng,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_trkn,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_xid_,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n\n    /* udta */\n    { ATOM_0x40PRM, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0x40PRQ, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9ART, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9alb, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9ard, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9arg, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9aut, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9cak, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9cmt, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9con, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9com, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9cpy, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9day, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9des, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9dir, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9dis, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9dsa, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9fmt, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9gen, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9grp, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9hst, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9inf, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9isr, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lab, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lal, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lnt, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lyr, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9mak, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9mal, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9mod, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9nam, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9ope, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9phg, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9PRD, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9prd, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9prf, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9pub, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9req, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9sne, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9snm, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9sol, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9src, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9st3, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9swr, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9thx, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9too, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9trk, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9url, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9wrn, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9xpd, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9xyz, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl,    ATOM_udta }, /* nero unlabeled chapters list */\n    { ATOM_MCPS,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_name,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_vndr,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_SDLN,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n\n    /* udta, non meta */\n    { ATOM_tsel,    MP4_ReadBox_tsel,         MP4_FreeBox_Common,  ATOM_udta },\n\n    /* iTunes/Quicktime meta info */\n    { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common,  0 },\n    { ATOM_data,    MP4_ReadBox_data,         MP4_FreeBox_data,    0 },\n\n    /* found in smoothstreaming */\n    { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common,  ATOM_moof },\n    { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common,  0 },\n    { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common,  ATOM_moof },\n    { ATOM_sidx,    MP4_ReadBox_sidx,         MP4_FreeBox_sidx,    0 },\n    { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common,  ATOM_traf },\n    { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun,    ATOM_traf },\n    { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common,  ATOM_mvex },\n    { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common,  ATOM_mvex },\n    { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp,    0 },\n    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra,    ATOM_mfra },\n    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common,  ATOM_mfra },\n    { ATOM_uuid,    MP4_ReadBox_uuid,         MP4_FreeBox_uuid,    0 },\n\n    /* Last entry */\n    { 0,              MP4_ReadBox_default,      NULL, 0 }\n};\n\n\n/*****************************************************************************\n * MP4_ReadBox : parse the actual box and the children\n *  XXX : Do not go to the next box\n *****************************************************************************/\nstatic MP4_Box_t *MP4_ReadBox( stream_t *p_stream, MP4_Box_t *p_father )\n{\n    MP4_Box_t *p_box = calloc( 1, sizeof( MP4_Box_t ) ); /* Needed to ensure simple on error handler */\n    unsigned int i_index;\n\n    if( p_box == NULL )\n        return NULL;\n\n    if( !MP4_ReadBoxCommon( p_stream, p_box ) )\n    {\n        msg_Warn( p_stream, \"cannot read one box\" );\n        free( p_box );\n        return NULL;\n    }\n    if( !p_box->i_size )\n    {\n        msg_Dbg( p_stream, \"found an empty box (null size)\" );\n        free( p_box );\n        return NULL;\n    }\n    p_box->p_father = p_father;\n\n    /* Now search function to call */\n    for( i_index = 0; ; i_index++ )\n    {\n        if ( MP4_Box_Function[i_index].i_parent &&\n             p_box->p_father &&\n             p_box->p_father->i_type != MP4_Box_Function[i_index].i_parent )\n            continue;\n\n        if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||\n            ( MP4_Box_Function[i_index].i_type == 0 ) )\n        {\n            break;\n        }\n    }\n\n    if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )\n    {\n        off_t i_end = p_box->i_pos + p_box->i_size;\n        MP4_BoxFree( p_stream, p_box );\n        stream_Seek( p_stream, i_end ); /* Skip the failed box */\n        return NULL;\n    }\n\n    p_box->pf_free = MP4_Box_Function[i_index].MP4_FreeBox_function;\n\n    return p_box;\n}\n\n/*****************************************************************************\n * MP4_FreeBox : free memory after read with MP4_ReadBox and all\n * the children\n *****************************************************************************/\nvoid MP4_BoxFree( stream_t *s, MP4_Box_t *p_box )\n{\n    MP4_Box_t    *p_child;\n\n    if( !p_box )\n        return; /* hehe */\n\n    for( p_child = p_box->p_first; p_child != NULL; )\n    {\n        MP4_Box_t *p_next;\n\n        p_next = p_child->p_next;\n        MP4_BoxFree( s, p_child );\n        p_child = p_next;\n    }\n\n    /* Now search function to call */\n    if( p_box->data.p_payload )\n    {\n        if (unlikely( p_box->pf_free == NULL ))\n        {\n            /* Should not happen */\n            if MP4_BOX_TYPE_ASCII()\n                msg_Warn( s,\n                        \"cannot free box %4.4s, type unknown\",\n                        (char*)&p_box->i_type );\n            else\n                msg_Warn( s,\n                        \"cannot free box c%3.3s, type unknown\",\n                        (char*)&p_box->i_type+1 );\n        }\n        else\n        {\n            p_box->pf_free( p_box );\n        }\n        free( p_box->data.p_payload );\n    }\n    free( p_box );\n}\n\n/* SmooBox is a very simple MP4 box, VLC specific, used only for the stream_filter to\n * send information to the demux. SmooBox is actually a simplified moov box (we wanted\n * to avoid the hassle of building a moov box at the stream_filter level) */\nMP4_Box_t *MP4_BoxGetSmooBox( stream_t *s )\n{\n    /* p_chunk is a virtual root container for the smoo box */\n    MP4_Box_t *p_chunk;\n    MP4_Box_t *p_smoo;\n\n    p_chunk = calloc( 1, sizeof( MP4_Box_t ) );\n    if( unlikely( p_chunk == NULL ) )\n        return NULL;\n\n    p_chunk->i_type = ATOM_root;\n    p_chunk->i_shortsize = 1;\n\n    p_smoo = MP4_ReadBox( s, p_chunk );\n    if( !p_smoo || p_smoo->i_type != ATOM_uuid || CmpUUID( &p_smoo->i_uuid, &SmooBoxUUID ) )\n    {\n        msg_Warn( s, \"no smoo box found!\");\n        goto error;\n    }\n\n    p_chunk->p_first = p_smoo;\n    p_chunk->p_last = p_smoo;\n\n    return p_chunk;\n\nerror:\n    free( p_chunk );\n    return NULL;\n}\n\nMP4_Box_t *MP4_BoxGetNextChunk( stream_t *s )\n{\n    /* p_chunk is a virtual root container for the moof and mdat boxes */\n    MP4_Box_t *p_chunk;\n    MP4_Box_t *p_tmp_box = NULL;\n\n    p_tmp_box = calloc( 1, sizeof( MP4_Box_t ) );\n    if( unlikely( p_tmp_box == NULL ) )\n        return NULL;\n\n    /* We might get a ftyp box or a SmooBox */\n    MP4_ReadBoxCommon( s, p_tmp_box );\n\n    if( (p_tmp_box->i_type == ATOM_uuid && !CmpUUID( &p_tmp_box->i_uuid, &SmooBoxUUID )) )\n    {\n        free( p_tmp_box );\n        return MP4_BoxGetSmooBox( s );\n    }\n    else if( p_tmp_box->i_type == ATOM_ftyp )\n    {\n        free( p_tmp_box );\n        return MP4_BoxGetRoot( s );\n    }\n    free( p_tmp_box );\n\n    p_chunk = calloc( 1, sizeof( MP4_Box_t ) );\n    if( unlikely( p_chunk == NULL ) )\n        return NULL;\n\n    p_chunk->i_type = ATOM_root;\n    p_chunk->i_shortsize = 1;\n\n    MP4_ReadBoxContainerChildren( s, p_chunk, ATOM_moof );\n\n    p_tmp_box = p_chunk->p_first;\n    while( p_tmp_box )\n    {\n        p_chunk->i_size += p_tmp_box->i_size;\n        p_tmp_box = p_tmp_box->p_next;\n    }\n\n    return p_chunk;\n}\n\n/*****************************************************************************\n * MP4_BoxGetRoot : Parse the entire file, and create all boxes in memory\n *****************************************************************************\n *  The first box is a virtual box \"root\" and is the father for all first\n *  level boxes for the file, a sort of virtual contener\n *****************************************************************************/\nMP4_Box_t *MP4_BoxGetRoot( stream_t *s )\n{\n    MP4_Box_t *p_root;\n    stream_t *p_stream;\n    int i_result;\n\n    p_root = malloc( sizeof( MP4_Box_t ) );\n    if( p_root == NULL )\n        return NULL;\n\n    p_root->i_pos = 0;\n    p_root->i_type = ATOM_root;\n    p_root->i_shortsize = 1;\n    /* could be a DASH stream for exemple, 0 means unknown or infinite size */\n    p_root->i_size = 0;\n    CreateUUID( &p_root->i_uuid, p_root->i_type );\n\n    p_root->data.p_payload = NULL;\n    p_root->p_father    = NULL;\n    p_root->p_first     = NULL;\n    p_root->p_last      = NULL;\n    p_root->p_next      = NULL;\n\n    p_stream = s;\n\n    /* First get the moov */\n    i_result = MP4_ReadBoxContainerChildren( p_stream, p_root, ATOM_moov );\n\n    if( !i_result )\n        goto error;\n    /* If there is a mvex box, it means fragmented MP4, and we're done */\n    else if( MP4_BoxCount( p_root, \"moov/mvex\" ) > 0 )\n        return p_root;\n\n    p_root->i_size = stream_Size( s );\n    if( stream_Tell( s ) + 8 < stream_Size( s ) )\n    {\n        /* Get the rest of the file */\n        i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );\n\n        if( !i_result )\n            goto error;\n    }\n\n    MP4_Box_t *p_moov;\n    MP4_Box_t *p_cmov;\n\n    /* check if there is a cmov, if so replace\n      compressed moov by  uncompressed one */\n    if( ( ( p_moov = MP4_BoxGet( p_root, \"moov\" ) ) &&\n          ( p_cmov = MP4_BoxGet( p_root, \"moov/cmov\" ) ) ) ||\n        ( ( p_moov = MP4_BoxGet( p_root, \"foov\" ) ) &&\n          ( p_cmov = MP4_BoxGet( p_root, \"foov/cmov\" ) ) ) )\n    {\n        /* rename the compressed moov as a box to skip */\n        p_moov->i_type = ATOM_skip;\n\n        /* get uncompressed p_moov */\n        p_moov = p_cmov->data.p_cmov->p_moov;\n        p_cmov->data.p_cmov->p_moov = NULL;\n\n        /* make p_root father of this new moov */\n        p_moov->p_father = p_root;\n\n        /* insert this new moov box as first child of p_root */\n        p_moov->p_next = p_root->p_first;\n        p_root->p_first = p_moov;\n    }\n\n    return p_root;\n\nerror:\n    free( p_root );\n    stream_Seek( p_stream, 0 );\n    return NULL;\n}\n\n\nstatic void MP4_BoxDumpStructure_Internal( stream_t *s,\n                                    MP4_Box_t *p_box, unsigned int i_level )\n{\n    MP4_Box_t *p_child;\n    uint32_t i_displayedtype = p_box->i_type;\n    if( ! MP4_BOX_TYPE_ASCII() ) ((char*)&i_displayedtype)[0] = 'c';\n\n    if( !i_level )\n    {\n        msg_Dbg( s, \"dumping root Box \\\"%4.4s\\\"\",\n                          (char*)&i_displayedtype );\n    }\n    else\n    {\n        char str[512];\n        if( i_level >= (sizeof(str) - 1)/4 )\n            return;\n\n        memset( str, ' ', sizeof(str) );\n        for( unsigned i = 0; i < i_level; i++ )\n        {\n            str[i*4] = '|';\n        }\n\n        snprintf( &str[i_level * 4], sizeof(str) - 4*i_level,\n                  \"+ %4.4s size %\"PRIu64\" offset %\" PRIuMAX \"%s\",\n                    (char*)&i_displayedtype, p_box->i_size,\n                  (uintmax_t)p_box->i_pos,\n                p_box->e_flags & BOX_FLAG_INCOMPLETE ? \" (\\?\\?\\?\\?)\" : \"\" );\n        msg_Dbg( s, \"%s\", str );\n    }\n    p_child = p_box->p_first;\n    while( p_child )\n    {\n        MP4_BoxDumpStructure_Internal( s, p_child, i_level + 1 );\n        p_child = p_child->p_next;\n    }\n}\n\nvoid MP4_BoxDumpStructure( stream_t *s, MP4_Box_t *p_box )\n{\n    MP4_BoxDumpStructure_Internal( s, p_box, 0 );\n}\n\n\n/*****************************************************************************\n *****************************************************************************\n **\n **  High level methods to acces an MP4 file\n **\n *****************************************************************************\n *****************************************************************************/\nstatic void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )\n{\n    size_t i_len ;\n    if( !*ppsz_path[0] )\n    {\n        *ppsz_token = NULL;\n        *pi_number = 0;\n        return;\n    }\n    i_len = strcspn( *ppsz_path, \"/[\" );\n    if( !i_len && **ppsz_path == '/' )\n    {\n        i_len = 1;\n    }\n    *ppsz_token = strndup( *ppsz_path, i_len );\n    if( unlikely(!*ppsz_token) )\n        abort();\n\n    *ppsz_path += i_len;\n\n    if( **ppsz_path == '[' )\n    {\n        (*ppsz_path)++;\n        *pi_number = strtol( *ppsz_path, NULL, 10 );\n        while( **ppsz_path && **ppsz_path != ']' )\n        {\n            (*ppsz_path)++;\n        }\n        if( **ppsz_path == ']' )\n        {\n            (*ppsz_path)++;\n        }\n    }\n    else\n    {\n        *pi_number = 0;\n    }\n    while( **ppsz_path == '/' )\n    {\n        (*ppsz_path)++;\n    }\n}\n\nstatic void MP4_BoxGet_Internal( MP4_Box_t **pp_result,\n                          MP4_Box_t *p_box, const char *psz_fmt, va_list args)\n{\n    char *psz_dup;\n    char *psz_path;\n    char *psz_token;\n\n    if( !p_box )\n    {\n        *pp_result = NULL;\n        return;\n    }\n\n    if( vasprintf( &psz_path, psz_fmt, args ) == -1 )\n        psz_path = NULL;\n\n    if( !psz_path || !psz_path[0] )\n    {\n        free( psz_path );\n        *pp_result = NULL;\n        return;\n    }\n\n//    fprintf( stderr, \"path:'%s'\\n\", psz_path );\n    psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */\n    for( ; ; )\n    {\n        int i_number;\n\n        get_token( &psz_path, &psz_token, &i_number );\n//        fprintf( stderr, \"path:'%s', token:'%s' n:%d\\n\",\n//                 psz_path,psz_token,i_number );\n        if( !psz_token )\n        {\n            free( psz_dup );\n            *pp_result = p_box;\n            return;\n        }\n        else\n        if( !strcmp( psz_token, \"/\" ) )\n        {\n            /* Find root box */\n            while( p_box && p_box->i_type != ATOM_root )\n            {\n                p_box = p_box->p_father;\n            }\n            if( !p_box )\n            {\n                goto error_box;\n            }\n        }\n        else\n        if( !strcmp( psz_token, \".\" ) )\n        {\n            /* Do nothing */\n        }\n        else\n        if( !strcmp( psz_token, \"..\" ) )\n        {\n            p_box = p_box->p_father;\n            if( !p_box )\n            {\n                goto error_box;\n            }\n        }\n        else\n        if( strlen( psz_token ) == 4 )\n        {\n            uint32_t i_fourcc;\n            i_fourcc = VLC_FOURCC( psz_token[0], psz_token[1],\n                                   psz_token[2], psz_token[3] );\n            p_box = p_box->p_first;\n            for( ; ; )\n            {\n                if( !p_box )\n                {\n                    goto error_box;\n                }\n                if( p_box->i_type == i_fourcc )\n                {\n                    if( !i_number )\n                    {\n                        break;\n                    }\n                    i_number--;\n                }\n                p_box = p_box->p_next;\n            }\n        }\n        else\n        if( *psz_token == '\\0' )\n        {\n            p_box = p_box->p_first;\n            for( ; ; )\n            {\n                if( !p_box )\n                {\n                    goto error_box;\n                }\n                if( !i_number )\n                {\n                    break;\n                }\n                i_number--;\n                p_box = p_box->p_next;\n            }\n        }\n        else\n        {\n//            fprintf( stderr, \"Argg malformed token \\\"%s\\\"\",psz_token );\n            goto error_box;\n        }\n\n        FREENULL( psz_token );\n    }\n\n    return;\n\nerror_box:\n    free( psz_token );\n    free( psz_dup );\n    *pp_result = NULL;\n    return;\n}\n\n/*****************************************************************************\n * MP4_BoxGet: find a box given a path relative to p_box\n *****************************************************************************\n * Path Format: . .. / as usual\n *              [number] to specifie box number ex: trak[12]\n *\n * ex: /moov/trak[12]\n *     ../mdia\n *****************************************************************************/\nMP4_Box_t *MP4_BoxGet( MP4_Box_t *p_box, const char *psz_fmt, ... )\n{\n    va_list args;\n    MP4_Box_t *p_result;\n\n    va_start( args, psz_fmt );\n    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );\n    va_end( args );\n\n    return( p_result );\n}\n\n/*****************************************************************************\n * MP4_BoxCount: count box given a path relative to p_box\n *****************************************************************************\n * Path Format: . .. / as usual\n *              [number] to specifie box number ex: trak[12]\n *\n * ex: /moov/trak[12]\n *     ../mdia\n *****************************************************************************/\nint MP4_BoxCount( MP4_Box_t *p_box, const char *psz_fmt, ... )\n{\n    va_list args;\n    int     i_count;\n    MP4_Box_t *p_result, *p_next;\n\n    va_start( args, psz_fmt );\n    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );\n    va_end( args );\n    if( !p_result )\n    {\n        return( 0 );\n    }\n\n    i_count = 1;\n    for( p_next = p_result->p_next; p_next != NULL; p_next = p_next->p_next)\n    {\n        if( p_next->i_type == p_result->i_type)\n        {\n            i_count++;\n        }\n    }\n    return( i_count );\n}\n"], "fixing_code": ["/*****************************************************************************\n * libmp4.c : LibMP4 library for mp4 module for vlc\n *****************************************************************************\n * Copyright (C) 2001-2004, 2010 VLC authors and VideoLAN\n *\n * Author: Laurent Aimar <fenrir@via.ecp.fr>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <vlc_common.h>\n#include <vlc_stream.h>                               /* stream_Peek*/\n\n#ifdef HAVE_ZLIB_H\n#   include <zlib.h>                                  /* for compressed moov */\n#endif\n\n#include \"libmp4.h\"\n#include \"languages.h\"\n#include <math.h>\n\n/* Some assumptions:\n * The input method HAS to be seekable\n */\n\n/* convert 16.16 fixed point to floating point */\nstatic double conv_fx( int32_t fx ) {\n    double fp = fx;\n    fp /= 65536.;\n    return fp;\n}\n\n/* some functions for mp4 encoding of variables */\n#ifdef MP4_VERBOSE\nstatic void MP4_ConvertDate2Str( char *psz, uint64_t i_date, bool b_relative )\n{\n    int i_day;\n    int i_hour;\n    int i_min;\n    int i_sec;\n\n    /* date begin at 1 jan 1904 */\n    if ( !b_relative )\n        i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;\n\n    i_day = i_date / ( 60*60*24);\n    i_hour = ( i_date /( 60*60 ) ) % 60;\n    i_min  = ( i_date / 60 ) % 60;\n    i_sec =  i_date % 60;\n    sprintf( psz, \"%dd-%2.2dh:%2.2dm:%2.2ds\", i_day, i_hour, i_min, i_sec );\n}\n#endif\n\n/*****************************************************************************\n * Some prototypes.\n *****************************************************************************/\nstatic MP4_Box_t *MP4_ReadBox( stream_t *p_stream, MP4_Box_t *p_father );\n\n\n/*****************************************************************************\n * MP4_ReadBoxCommon : Load only common parameters for all boxes\n *****************************************************************************\n * p_box need to be an already allocated MP4_Box_t, and all data\n *  will only be peek not read\n *\n * RETURN : 0 if it fail, 1 otherwise\n *****************************************************************************/\nint MP4_ReadBoxCommon( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int      i_read;\n    const uint8_t  *p_peek;\n\n    if( ( ( i_read = stream_Peek( p_stream, &p_peek, 32 ) ) < 8 ) )\n    {\n        return 0;\n    }\n    p_box->i_pos = stream_Tell( p_stream );\n\n    p_box->data.p_payload = NULL;\n    p_box->p_father = NULL;\n    p_box->p_first  = NULL;\n    p_box->p_last  = NULL;\n    p_box->p_next   = NULL;\n\n    MP4_GET4BYTES( p_box->i_shortsize );\n    MP4_GETFOURCC( p_box->i_type );\n\n    /* Now special case */\n\n    if( p_box->i_shortsize == 1 )\n    {\n        /* get the true size on 64 bits */\n        MP4_GET8BYTES( p_box->i_size );\n    }\n    else\n    {\n        p_box->i_size = p_box->i_shortsize;\n        /* XXX size of 0 means that the box extends to end of file */\n    }\n\n    if( p_box->i_type == ATOM_uuid )\n    {\n        /* get extented type on 16 bytes */\n        GetUUID( &p_box->i_uuid, p_peek );\n        p_peek += 16; i_read -= 16;\n    }\n    else\n    {\n        CreateUUID( &p_box->i_uuid, p_box->i_type );\n    }\n#ifdef MP4_ULTRA_VERBOSE\n    if( p_box->i_size )\n    {\n        if MP4_BOX_TYPE_ASCII()\n            msg_Dbg( p_stream, \"found Box: %4.4s size %\"PRId64\" %\"PRId64,\n                    (char*)&p_box->i_type, p_box->i_size, p_box->i_pos );\n        else\n            msg_Dbg( p_stream, \"found Box: c%3.3s size %\"PRId64,\n                    (char*)&p_box->i_type+1, p_box->i_size );\n    }\n#endif\n\n    return 1;\n}\n\n/*****************************************************************************\n * MP4_NextBox : Go to the next box\n *****************************************************************************\n * if p_box == NULL, go to the next box in which we are( at the begining ).\n *****************************************************************************/\nstatic int MP4_NextBox( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_t box;\n\n    if( !p_box )\n    {\n        if ( !MP4_ReadBoxCommon( p_stream, &box ) )\n            return 0;\n        p_box = &box;\n    }\n\n    if( !p_box->i_size )\n    {\n        return 2; /* Box with infinite size */\n    }\n\n    if( p_box->p_father )\n    {\n        /* if father's size == 0, it means unknown or infinite size,\n         * and we skip the followong check */\n        if( p_box->p_father->i_size > 0 )\n        {\n            const off_t i_box_end = p_box->i_size + p_box->i_pos;\n            const off_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;\n\n            /* check if it's within p-father */\n            if( i_box_end >= i_father_end )\n            {\n                if( i_box_end > i_father_end )\n                    msg_Dbg( p_stream, \"out of bound child\" );\n                return 0; /* out of bound */\n            }\n        }\n    }\n    if( stream_Seek( p_stream, p_box->i_size + p_box->i_pos ) )\n    {\n        return 0;\n    }\n\n    return 1;\n}\n\n/*****************************************************************************\n * For all known box a loader is given,\n *  XXX: all common struct have to be already read by MP4_ReadBoxCommon\n *       after called one of theses functions, file position is unknown\n *       you need to call MP4_GotoBox to go where you want\n *****************************************************************************/\nstatic int MP4_ReadBoxContainerChildrenIndexed( stream_t *p_stream,\n               MP4_Box_t *p_container, uint32_t i_last_child, bool b_indexed )\n{\n    MP4_Box_t *p_box;\n\n    /* Size of root container is set to 0 when unknown, for exemple\n     * with a DASH stream. In that case, we skip the following check */\n    if( p_container->i_size\n            && ( stream_Tell( p_stream ) + ((b_indexed)?16:8) >\n        (off_t)(p_container->i_pos + p_container->i_size) )\n      )\n    {\n        /* there is no box to load */\n        return 0;\n    }\n\n    do\n    {\n        uint32_t i_index = 0;\n        if ( b_indexed )\n        {\n            uint8_t read[8];\n            if ( stream_Read( p_stream, read, 8 ) < 8 )\n                return 0;\n            i_index = GetDWBE(&read[4]);\n        }\n        if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) continue;\n        p_box->i_index = i_index;\n\n        /* chain this box with the father and the other at same level */\n        if( !p_container->p_first ) p_container->p_first = p_box;\n        else p_container->p_last->p_next = p_box;\n        p_container->p_last = p_box;\n\n        if( p_box->i_type == i_last_child )\n        {\n            MP4_NextBox( p_stream, p_box );\n            break;\n        }\n\n    } while( MP4_NextBox( p_stream, p_box ) == 1 );\n\n    return 1;\n}\n\nint MP4_ReadBoxContainerChildren( stream_t *p_stream, MP4_Box_t *p_container,\n                                  uint32_t i_last_child )\n{\n    return MP4_ReadBoxContainerChildrenIndexed( p_stream, p_container,\n                                                i_last_child, false );\n}\n\nstatic int MP4_ReadBoxContainerRaw( stream_t *p_stream, MP4_Box_t *p_container )\n{\n    return MP4_ReadBoxContainerChildren( p_stream, p_container, 0 );\n}\n\nstatic int MP4_ReadBoxContainer( stream_t *p_stream, MP4_Box_t *p_container )\n{\n    if( p_container->i_size &&\n        ( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 ) )\n    {\n        /* container is empty, 8 stand for the first header in this box */\n        return 1;\n    }\n\n    /* enter box */\n    stream_Seek( p_stream, p_container->i_pos +\n                 mp4_box_headersize( p_container ) );\n\n    return MP4_ReadBoxContainerRaw( p_stream, p_container );\n}\n\nstatic void MP4_FreeBox_Common( MP4_Box_t *p_box )\n{\n    /* Up to now do nothing */\n    (void)p_box;\n}\n\nstatic int MP4_ReadBoxSkip( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    /* XXX sometime moov is hiden in a free box */\n    if( p_box->p_father &&\n        p_box->p_father->i_type == ATOM_root &&\n        p_box->i_type == ATOM_free )\n    {\n        const uint8_t *p_peek;\n        int     i_read;\n        vlc_fourcc_t i_fcc;\n\n        i_read  = stream_Peek( p_stream, &p_peek, 44 );\n\n        p_peek += mp4_box_headersize( p_box ) + 4;\n        i_read -= mp4_box_headersize( p_box ) + 4;\n\n        if( i_read >= 8 )\n        {\n            i_fcc = VLC_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );\n\n            if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )\n            {\n                msg_Warn( p_stream, \"detected moov hidden in a free box ...\" );\n\n                p_box->i_type = ATOM_foov;\n                return MP4_ReadBoxContainer( p_stream, p_box );\n            }\n        }\n    }\n\n    /* Nothing to do */\n#ifdef MP4_ULTRA_VERBOSE\n    if MP4_BOX_TYPE_ASCII()\n        msg_Dbg( p_stream, \"skip box: \\\"%4.4s\\\"\", (char*)&p_box->i_type );\n    else\n        msg_Dbg( p_stream, \"skip box: \\\"c%3.3s\\\"\", (char*)&p_box->i_type+1 );\n#endif\n    return 1;\n}\n\nstatic int MP4_ReadBox_ilst( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if( p_box->i_size < 8 || stream_Read( p_stream, NULL, 8 ) < 8 )\n        return 0;\n\n    /* Find our handler */\n    if ( !p_box->i_handler && p_box->p_father )\n    {\n        const MP4_Box_t *p_sibling = p_box->p_father->p_first;\n        while( p_sibling )\n        {\n            if ( p_sibling->i_type == ATOM_hdlr && p_sibling->data.p_hdlr )\n            {\n                p_box->i_handler = p_sibling->data.p_hdlr->i_handler_type;\n                break;\n            }\n            p_sibling = p_sibling->p_next;\n        }\n    }\n\n    switch( p_box->i_handler )\n    {\n    case 0:\n        msg_Warn( p_stream, \"no handler for ilst atom\" );\n        return 0;\n    case HANDLER_mdta:\n        return MP4_ReadBoxContainerChildrenIndexed( p_stream, p_box, 0, true );\n    case HANDLER_mdir:\n        return MP4_ReadBoxContainerChildren( p_stream, p_box, 0 );\n    default:\n        msg_Warn( p_stream, \"Unknown ilst handler type '%4.4s'\", (char*)&p_box->i_handler );\n        return 0;\n    }\n}\n\nstatic int MP4_ReadBox_ftyp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_ftyp_t );\n\n    MP4_GETFOURCC( p_box->data.p_ftyp->i_major_brand );\n    MP4_GET4BYTES( p_box->data.p_ftyp->i_minor_version );\n\n    if( ( p_box->data.p_ftyp->i_compatible_brands_count = i_read / 4 ) )\n    {\n        uint32_t *tab = p_box->data.p_ftyp->i_compatible_brands =\n            calloc( p_box->data.p_ftyp->i_compatible_brands_count,\n                    sizeof(uint32_t));\n\n        if( unlikely( tab == NULL ) )\n            MP4_READBOX_EXIT( 0 );\n\n        for( unsigned i = 0; i < p_box->data.p_ftyp->i_compatible_brands_count; i++ )\n        {\n            MP4_GETFOURCC( tab[i] );\n        }\n    }\n    else\n    {\n        p_box->data.p_ftyp->i_compatible_brands = NULL;\n    }\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_ftyp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_ftyp->i_compatible_brands );\n}\n\n\nstatic int MP4_ReadBox_mvhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n#ifdef MP4_VERBOSE\n    char s_creation_time[128];\n    char s_modification_time[128];\n    char s_duration[128];\n#endif\n    MP4_READBOX_ENTER( MP4_Box_data_mvhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );\n\n    if( p_box->data.p_mvhd->i_version )\n    {\n        MP4_GET8BYTES( p_box->data.p_mvhd->i_creation_time );\n        MP4_GET8BYTES( p_box->data.p_mvhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_timescale );\n        MP4_GET8BYTES( p_box->data.p_mvhd->i_duration );\n    }\n    else\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_creation_time );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_timescale );\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_duration );\n    }\n    MP4_GET4BYTES( p_box->data.p_mvhd->i_rate );\n    MP4_GET2BYTES( p_box->data.p_mvhd->i_volume );\n    MP4_GET2BYTES( p_box->data.p_mvhd->i_reserved1 );\n\n\n    for( unsigned i = 0; i < 2; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_reserved2[i] );\n    }\n    for( unsigned i = 0; i < 9; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_matrix[i] );\n    }\n    for( unsigned i = 0; i < 6; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_mvhd->i_predefined[i] );\n    }\n\n    MP4_GET4BYTES( p_box->data.p_mvhd->i_next_track_id );\n\n\n#ifdef MP4_VERBOSE\n    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->i_creation_time, false );\n    MP4_ConvertDate2Str( s_modification_time,\n                         p_box->data.p_mvhd->i_modification_time, false );\n    if( p_box->data.p_mvhd->i_rate )\n    {\n        MP4_ConvertDate2Str( s_duration,\n                 p_box->data.p_mvhd->i_duration / p_box->data.p_mvhd->i_rate, true );\n    }\n    else\n    {\n        s_duration[0] = 0;\n    }\n    msg_Dbg( p_stream, \"read box: \\\"mvhd\\\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d\",\n                  s_creation_time,\n                  s_modification_time,\n                  (uint32_t)p_box->data.p_mvhd->i_timescale,\n                  s_duration,\n                  (float)p_box->data.p_mvhd->i_rate / (1<<16 ),\n                  (float)p_box->data.p_mvhd->i_volume / 256 ,\n                  (uint32_t)p_box->data.p_mvhd->i_next_track_id );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mfhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_mfhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );\n\n    MP4_GET4BYTES( p_box->data.p_mfhd->i_sequence_number );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"mfhd\\\" sequence number %d\",\n                  p_box->data.p_mfhd->i_sequence_number );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tfxd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tfxd_t );\n\n    MP4_Box_data_tfxd_t *p_tfxd_data = p_box->data.p_tfxd;\n    MP4_GETVERSIONFLAGS( p_tfxd_data );\n\n    if( p_tfxd_data->i_version == 0 )\n    {\n        MP4_GET4BYTES( p_tfxd_data->i_fragment_abs_time );\n        MP4_GET4BYTES( p_tfxd_data->i_fragment_duration );\n    }\n    else\n    {\n        MP4_GET8BYTES( p_tfxd_data->i_fragment_abs_time );\n        MP4_GET8BYTES( p_tfxd_data->i_fragment_duration );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"tfxd\\\" version %d, flags 0x%x, \"\\\n            \"fragment duration %\"PRIu64\", fragment abs time %\"PRIu64,\n                p_tfxd_data->i_version,\n                p_tfxd_data->i_flags,\n                p_tfxd_data->i_fragment_duration,\n                p_tfxd_data->i_fragment_abs_time\n           );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tfrf(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tfxd_t );\n\n    MP4_Box_data_tfrf_t *p_tfrf_data = p_box->data.p_tfrf;\n    MP4_GETVERSIONFLAGS( p_tfrf_data );\n\n    MP4_GET1BYTE( p_tfrf_data->i_fragment_count );\n\n    p_tfrf_data->p_tfrf_data_fields = calloc( p_tfrf_data->i_fragment_count,\n                                              sizeof( TfrfBoxDataFields_t ) );\n    if( !p_tfrf_data->p_tfrf_data_fields )\n        MP4_READBOX_EXIT( 0 );\n\n    for( uint8_t i = 0; i < p_tfrf_data->i_fragment_count; i++ )\n    {\n        TfrfBoxDataFields_t *TfrfBoxDataField = &p_tfrf_data->p_tfrf_data_fields[i];\n        if( p_tfrf_data->i_version == 0 )\n        {\n            MP4_GET4BYTES( TfrfBoxDataField->i_fragment_abs_time );\n            MP4_GET4BYTES( TfrfBoxDataField->i_fragment_duration );\n        }\n        else\n        {\n            MP4_GET8BYTES( TfrfBoxDataField->i_fragment_abs_time );\n            MP4_GET8BYTES( TfrfBoxDataField->i_fragment_duration );\n        }\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"tfrf\\\" version %d, flags 0x%x, \"\\\n            \"fragment count %\"PRIu8, p_tfrf_data->i_version,\n                p_tfrf_data->i_flags, p_tfrf_data->i_fragment_count );\n\n    for( uint8_t i = 0; i < p_tfrf_data->i_fragment_count; i++ )\n    {\n        TfrfBoxDataFields_t *TfrfBoxDataField = &p_tfrf_data->p_tfrf_data_fields[i];\n        msg_Dbg( p_stream, \"\\\"tfrf\\\" fragment duration %\"PRIu64\", \"\\\n                                    \"fragment abs time %\"PRIu64,\n                    TfrfBoxDataField->i_fragment_duration,\n                    TfrfBoxDataField->i_fragment_abs_time );\n    }\n\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_tfrf( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_tfrf->p_tfrf_data_fields );\n}\n\nstatic int MP4_ReadBox_stra( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stra_t );\n    MP4_Box_data_stra_t *p_stra = p_box->data.p_stra;\n\n    uint8_t i_reserved;\n    VLC_UNUSED(i_reserved);\n    MP4_GET1BYTE( p_stra->i_es_cat );\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET2BYTES( p_stra->i_track_ID );\n\n    MP4_GET4BYTES( p_stra->i_timescale );\n    MP4_GET8BYTES( p_stra->i_duration );\n\n    MP4_GET4BYTES( p_stra->FourCC );\n    MP4_GET4BYTES( p_stra->Bitrate );\n    MP4_GET4BYTES( p_stra->MaxWidth );\n    MP4_GET4BYTES( p_stra->MaxHeight );\n    MP4_GET4BYTES( p_stra->SamplingRate );\n    MP4_GET4BYTES( p_stra->Channels );\n    MP4_GET4BYTES( p_stra->BitsPerSample );\n    MP4_GET4BYTES( p_stra->AudioTag );\n    MP4_GET2BYTES( p_stra->nBlockAlign );\n\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET1BYTE( i_reserved );\n    MP4_GET1BYTE( p_stra->cpd_len );\n    if( p_stra->cpd_len > i_read )\n        goto error;\n    p_stra->CodecPrivateData = malloc( p_stra->cpd_len );\n    if( unlikely( p_stra->CodecPrivateData == NULL ) )\n        goto error;\n    memcpy( p_stra->CodecPrivateData, p_peek, p_stra->cpd_len );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"es_cat is %\"PRIu8\", birate is %\"PRIu32,\n              p_stra->i_es_cat, p_stra->Bitrate );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\nerror:\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic void MP4_FreeBox_stra( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stra->CodecPrivateData );\n}\n\nstatic int MP4_ReadBox_uuid( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if( !CmpUUID( &p_box->i_uuid, &TfrfBoxUUID ) )\n        return MP4_ReadBox_tfrf( p_stream, p_box );\n    if( !CmpUUID( &p_box->i_uuid, &TfxdBoxUUID ) )\n        return MP4_ReadBox_tfxd( p_stream, p_box );\n    if( !CmpUUID( &p_box->i_uuid, &SmooBoxUUID ) )\n        return MP4_ReadBoxContainer( p_stream, p_box );\n    if( !CmpUUID( &p_box->i_uuid, &StraBoxUUID ) )\n        return MP4_ReadBox_stra( p_stream, p_box );\n\n    msg_Warn( p_stream, \"Unknown uuid type box\" );\n    return 1;\n}\n\nstatic void MP4_FreeBox_uuid( MP4_Box_t *p_box )\n{\n    if( !CmpUUID( &p_box->i_uuid, &TfrfBoxUUID ) )\n        return MP4_FreeBox_tfrf( p_box );\n    if( !CmpUUID( &p_box->i_uuid, &TfxdBoxUUID ) )\n        return MP4_FreeBox_Common( p_box );\n    if( !CmpUUID( &p_box->i_uuid, &SmooBoxUUID ) )\n        return MP4_FreeBox_Common( p_box );\n    if( !CmpUUID( &p_box->i_uuid, &StraBoxUUID ) )\n        return MP4_FreeBox_stra( p_box );\n}\n\nstatic int MP4_ReadBox_sidx(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_sidx_t );\n\n    MP4_Box_data_sidx_t *p_sidx_data = p_box->data.p_sidx;\n    MP4_GETVERSIONFLAGS( p_sidx_data );\n\n    MP4_GET4BYTES( p_sidx_data->i_reference_ID );\n    MP4_GET4BYTES( p_sidx_data->i_timescale );\n\n    if( p_sidx_data->i_version == 0 )\n    {\n        MP4_GET4BYTES( p_sidx_data->i_earliest_presentation_time );\n        MP4_GET4BYTES( p_sidx_data->i_first_offset );\n    }\n    else\n    {\n        MP4_GET8BYTES( p_sidx_data->i_earliest_presentation_time );\n        MP4_GET8BYTES( p_sidx_data->i_first_offset );\n    }\n\n    uint16_t i_reserved;\n    VLC_UNUSED(i_reserved);\n    MP4_GET2BYTES( i_reserved );\n    MP4_GET2BYTES( p_sidx_data->i_reference_count );\n    uint16_t i_count = p_sidx_data->i_reference_count;\n\n    p_sidx_data->p_items = calloc( i_count, sizeof( MP4_Box_sidx_item_t ) );\n    uint32_t tmp;\n    for( unsigned i = 0; i < i_count; i++ )\n    {\n        MP4_GET4BYTES( tmp );\n        p_sidx_data->p_items[i].b_reference_type = (bool)((tmp & 0x80000000)>>24);\n        p_sidx_data->p_items[i].i_referenced_size = tmp & 0x7fffffff;\n        MP4_GET4BYTES( p_sidx_data->p_items[i].i_subsegment_duration );\n\n        MP4_GET4BYTES( tmp );\n        p_sidx_data->p_items[i].b_starts_with_SAP = (bool)((tmp & 0x80000000)>>24);\n        p_sidx_data->p_items[i].i_SAP_type = (tmp & 0x70000000)>>24;\n        p_sidx_data->p_items[i].i_SAP_delta_time = tmp & 0xfffffff;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"sidx\\\" version %d, flags 0x%x, \"\\\n            \"ref_ID %\"PRIu32\", timescale %\"PRIu32\", ref_count %\"PRIu16\", \"\\\n            \"first subsegmt duration %\"PRIu32,\n                p_sidx_data->i_version,\n                p_sidx_data->i_flags,\n                p_sidx_data->i_reference_ID,\n                p_sidx_data->i_timescale,\n                p_sidx_data->i_reference_count,\n                p_sidx_data->p_items[0].i_subsegment_duration\n           );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_sidx( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sidx->p_items );\n}\n\nstatic int MP4_ReadBox_tfhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tfhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_tfhd );\n\n    if( p_box->data.p_tfhd->i_version != 0 )\n    {\n        msg_Warn( p_stream, \"'tfhd' box with version != 0. \"\\\n                \" Don't know what to do with that, please patch\" );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    MP4_GET4BYTES( p_box->data.p_tfhd->i_track_ID );\n\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DURATION_IS_EMPTY )\n    {\n        msg_Dbg( p_stream, \"'duration-is-empty' flag is present \"\\\n                \"=> no samples for this time interval.\" );\n        p_box->data.p_tfhd->b_empty = true;\n    }\n    else\n        p_box->data.p_tfhd->b_empty = false;\n\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )\n        MP4_GET8BYTES( p_box->data.p_tfhd->i_base_data_offset );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_sample_description_index );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_default_sample_duration );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_default_sample_size );\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )\n        MP4_GET4BYTES( p_box->data.p_tfhd->i_default_sample_flags );\n\n#ifdef MP4_VERBOSE\n    char psz_base[128] = \"\\0\";\n    char psz_desc[128] = \"\\0\";\n    char psz_dura[128] = \"\\0\";\n    char psz_size[128] = \"\\0\";\n    char psz_flag[128] = \"\\0\";\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )\n        snprintf(psz_base, sizeof(psz_base), \"base offset %\"PRId64, p_box->data.p_tfhd->i_base_data_offset);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )\n        snprintf(psz_desc, sizeof(psz_desc), \"sample description index %d\", p_box->data.p_tfhd->i_sample_description_index);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )\n        snprintf(psz_dura, sizeof(psz_dura), \"sample duration %d\", p_box->data.p_tfhd->i_default_sample_duration);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )\n        snprintf(psz_size, sizeof(psz_size), \"sample size %d\", p_box->data.p_tfhd->i_default_sample_size);\n    if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )\n        snprintf(psz_flag, sizeof(psz_flag), \"sample flags 0x%x\", p_box->data.p_tfhd->i_default_sample_flags);\n\n    msg_Dbg( p_stream, \"read box: \\\"tfhd\\\" version %d flags 0x%x track ID %d %s %s %s %s %s\",\n                p_box->data.p_tfhd->i_version,\n                p_box->data.p_tfhd->i_flags,\n                p_box->data.p_tfhd->i_track_ID,\n                psz_base, psz_desc, psz_dura, psz_size, psz_flag );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_trun(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_trun_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_trun );\n\n    MP4_GET4BYTES( p_box->data.p_trun->i_sample_count );\n\n    if( p_box->data.p_trun->i_flags & MP4_TRUN_DATA_OFFSET )\n        MP4_GET4BYTES( p_box->data.p_trun->i_data_offset );\n    if( p_box->data.p_trun->i_flags & MP4_TRUN_FIRST_FLAGS )\n        MP4_GET4BYTES( p_box->data.p_trun->i_first_sample_flags );\n\n    p_box->data.p_trun->p_samples =\n      calloc( p_box->data.p_trun->i_sample_count, sizeof(MP4_descriptor_trun_sample_t) );\n    if ( p_box->data.p_trun->p_samples == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned int i = 0; i<p_box->data.p_trun->i_sample_count; i++ )\n    {\n        MP4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->p_samples[i];\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_DURATION )\n            MP4_GET4BYTES( p_sample->i_duration );\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_SIZE )\n            MP4_GET4BYTES( p_sample->i_size );\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_FLAGS )\n            MP4_GET4BYTES( p_sample->i_flags );\n        if( p_box->data.p_trun->i_flags & MP4_TRUN_SAMPLE_TIME_OFFSET )\n            MP4_GET4BYTES( p_sample->i_composition_time_offset );\n    }\n\n#ifdef MP4_ULTRA_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"trun\\\" version %u flags 0x%x sample count %u\",\n                  p_box->data.p_trun->i_version,\n                  p_box->data.p_trun->i_flags,\n                  p_box->data.p_trun->i_sample_count );\n\n    for( unsigned int i = 0; i<p_box->data.p_trun->i_sample_count; i++ )\n    {\n        MP4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->p_samples[i];\n        msg_Dbg( p_stream, \"read box: \\\"trun\\\" sample %4.4u flags 0x%x \"\\\n            \"duration %\"PRIu32\" size %\"PRIu32\" composition time offset %\"PRIu32,\n                        i, p_sample->i_flags, p_sample->i_duration,\n                        p_sample->i_size, p_sample->i_composition_time_offset );\n    }\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_trun( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_trun->p_samples );\n}\n\n\nstatic int MP4_ReadBox_tkhd(  stream_t *p_stream, MP4_Box_t *p_box )\n{\n#ifdef MP4_VERBOSE\n    char s_creation_time[128];\n    char s_modification_time[128];\n    char s_duration[128];\n#endif\n    MP4_READBOX_ENTER( MP4_Box_data_tkhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_tkhd );\n\n    if( p_box->data.p_tkhd->i_version )\n    {\n        MP4_GET8BYTES( p_box->data.p_tkhd->i_creation_time );\n        MP4_GET8BYTES( p_box->data.p_tkhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_track_ID );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_reserved );\n        MP4_GET8BYTES( p_box->data.p_tkhd->i_duration );\n    }\n    else\n    {\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_creation_time );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_track_ID );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_reserved );\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_duration );\n    }\n\n    for( unsigned i = 0; i < 2; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_reserved2[i] );\n    }\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_layer );\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_predefined );\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_volume );\n    MP4_GET2BYTES( p_box->data.p_tkhd->i_reserved3 );\n\n    for( unsigned i = 0; i < 9; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_tkhd->i_matrix[i] );\n    }\n    MP4_GET4BYTES( p_box->data.p_tkhd->i_width );\n    MP4_GET4BYTES( p_box->data.p_tkhd->i_height );\n\n    double rotation;    //angle in degrees to be rotated clockwise\n    double scale[2];    // scale factor; sx = scale[0] , sy = scale[1]\n    double translate[2];// amount to translate; tx = translate[0] , ty = translate[1]\n\n    int32_t *matrix = p_box->data.p_tkhd->i_matrix;\n\n    translate[0] = conv_fx(matrix[6]);\n    translate[1] = conv_fx(matrix[7]);\n\n    scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +\n                    conv_fx(matrix[3]) * conv_fx(matrix[3]));\n    scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +\n                    conv_fx(matrix[4]) * conv_fx(matrix[4]));\n\n    rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;\n\n    if (rotation < 0)\n        rotation += 360.;\n\n    p_box->data.p_tkhd->f_rotation = rotation;\n\n#ifdef MP4_VERBOSE\n    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->i_creation_time, false );\n    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->i_modification_time, false );\n    MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->i_duration, true );\n\n    msg_Dbg( p_stream, \"read box: \\\"tkhd\\\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. \"\n            \"Matrix: %i %i %i %i %i %i %i %i %i\",\n                  s_creation_time,\n                  s_modification_time,\n                  s_duration,\n                  p_box->data.p_tkhd->i_track_ID,\n                  p_box->data.p_tkhd->i_layer,\n                  (float)p_box->data.p_tkhd->i_volume / 256 ,\n                  rotation,\n                  scale[0],\n                  scale[1],\n                  translate[0],\n                  translate[1],\n                  (float)p_box->data.p_tkhd->i_width / BLOCK16x16,\n                  (float)p_box->data.p_tkhd->i_height / BLOCK16x16,\n                  p_box->data.p_tkhd->i_matrix[0],\n                  p_box->data.p_tkhd->i_matrix[1],\n                  p_box->data.p_tkhd->i_matrix[2],\n                  p_box->data.p_tkhd->i_matrix[3],\n                  p_box->data.p_tkhd->i_matrix[4],\n                  p_box->data.p_tkhd->i_matrix[5],\n                  p_box->data.p_tkhd->i_matrix[6],\n                  p_box->data.p_tkhd->i_matrix[7],\n                  p_box->data.p_tkhd->i_matrix[8] );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_load( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if ( p_box->i_size != 24 )\n        return 0;\n    MP4_READBOX_ENTER( MP4_Box_data_load_t );\n    MP4_GET4BYTES( p_box->data.p_load->i_start_time );\n    MP4_GET4BYTES( p_box->data.p_load->i_duration );\n    MP4_GET4BYTES( p_box->data.p_load->i_flags );\n    MP4_GET4BYTES( p_box->data.p_load->i_hints );\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mdhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint16_t i_language;\n#ifdef MP4_VERBOSE\n    char s_creation_time[128];\n    char s_modification_time[128];\n    char s_duration[128];\n#endif\n    MP4_READBOX_ENTER( MP4_Box_data_mdhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mdhd );\n\n    if( p_box->data.p_mdhd->i_version )\n    {\n        MP4_GET8BYTES( p_box->data.p_mdhd->i_creation_time );\n        MP4_GET8BYTES( p_box->data.p_mdhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_timescale );\n        MP4_GET8BYTES( p_box->data.p_mdhd->i_duration );\n    }\n    else\n    {\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_creation_time );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_modification_time );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_timescale );\n        MP4_GET4BYTES( p_box->data.p_mdhd->i_duration );\n    }\n\n    MP4_GET2BYTES( i_language );\n    decodeQtLanguageCode( i_language, p_box->data.p_mdhd->rgs_language,\n                          &p_box->data.p_mdhd->b_mac_encoding );\n\n    MP4_GET2BYTES( p_box->data.p_mdhd->i_quality );\n\n#ifdef MP4_VERBOSE\n    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->i_creation_time, false );\n    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->i_modification_time, false );\n    MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->i_duration, true );\n    msg_Dbg( p_stream, \"read box: \\\"mdhd\\\" creation %s modification %s time scale %d duration %s language %3.3s\",\n                  s_creation_time,\n                  s_modification_time,\n                  (uint32_t)p_box->data.p_mdhd->i_timescale,\n                  s_duration,\n                  (char*) &p_box->data.p_mdhd->rgs_language );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_hdlr( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int32_t i_reserved;\n    VLC_UNUSED(i_reserved);\n\n    MP4_READBOX_ENTER( MP4_Box_data_hdlr_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_hdlr );\n\n    MP4_GETFOURCC( p_box->data.p_hdlr->i_predefined );\n    MP4_GETFOURCC( p_box->data.p_hdlr->i_handler_type );\n\n    MP4_GET4BYTES( i_reserved );\n    MP4_GET4BYTES( i_reserved );\n    MP4_GET4BYTES( i_reserved );\n    p_box->data.p_hdlr->psz_name = NULL;\n\n    if( i_read > 0 )\n    {\n        uint8_t *psz = p_box->data.p_hdlr->psz_name = malloc( i_read + 1 );\n        if( unlikely( psz == NULL ) )\n            MP4_READBOX_EXIT( 0 );\n\n        /* Yes, I love .mp4 :( */\n        if( p_box->data.p_hdlr->i_predefined == VLC_FOURCC( 'm', 'h', 'l', 'r' ) )\n        {\n            uint8_t i_len;\n            int i_copy;\n\n            MP4_GET1BYTE( i_len );\n            i_copy = __MIN( i_read, i_len );\n\n            memcpy( psz, p_peek, i_copy );\n            p_box->data.p_hdlr->psz_name[i_copy] = '\\0';\n        }\n        else\n        {\n            memcpy( psz, p_peek, i_read );\n            p_box->data.p_hdlr->psz_name[i_read] = '\\0';\n        }\n    }\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"hdlr\\\" handler type: \\\"%4.4s\\\" name: \\\"%s\\\"\",\n                   (char*)&p_box->data.p_hdlr->i_handler_type,\n                   p_box->data.p_hdlr->psz_name );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_hdlr( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_hdlr->psz_name );\n}\n\nstatic int MP4_ReadBox_vmhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_vmhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );\n\n    MP4_GET2BYTES( p_box->data.p_vmhd->i_graphics_mode );\n    for( unsigned i = 0; i < 3; i++ )\n    {\n        MP4_GET2BYTES( p_box->data.p_vmhd->i_opcolor[i] );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"vmhd\\\" graphics-mode %d opcolor (%d, %d, %d)\",\n                      p_box->data.p_vmhd->i_graphics_mode,\n                      p_box->data.p_vmhd->i_opcolor[0],\n                      p_box->data.p_vmhd->i_opcolor[1],\n                      p_box->data.p_vmhd->i_opcolor[2] );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_smhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_smhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_smhd );\n\n\n\n    MP4_GET2BYTES( p_box->data.p_smhd->i_balance );\n\n    MP4_GET2BYTES( p_box->data.p_smhd->i_reserved );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"smhd\\\" balance %f\",\n                      (float)p_box->data.p_smhd->i_balance / 256 );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_hmhd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_hmhd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_hmhd );\n\n    MP4_GET2BYTES( p_box->data.p_hmhd->i_max_PDU_size );\n    MP4_GET2BYTES( p_box->data.p_hmhd->i_avg_PDU_size );\n\n    MP4_GET4BYTES( p_box->data.p_hmhd->i_max_bitrate );\n    MP4_GET4BYTES( p_box->data.p_hmhd->i_avg_bitrate );\n\n    MP4_GET4BYTES( p_box->data.p_hmhd->i_reserved );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"hmhd\\\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d\",\n                      p_box->data.p_hmhd->i_max_PDU_size,\n                      p_box->data.p_hmhd->i_avg_PDU_size,\n                      p_box->data.p_hmhd->i_max_bitrate,\n                      p_box->data.p_hmhd->i_avg_bitrate );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_url( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_url_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_url );\n    MP4_GETSTRINGZ( p_box->data.p_url->psz_location );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"url\\\" url: %s\",\n                       p_box->data.p_url->psz_location );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic void MP4_FreeBox_url( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_url->psz_location );\n}\n\nstatic int MP4_ReadBox_urn( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_urn_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_urn );\n\n    MP4_GETSTRINGZ( p_box->data.p_urn->psz_name );\n    MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"urn\\\" name %s location %s\",\n                      p_box->data.p_urn->psz_name,\n                      p_box->data.p_urn->psz_location );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\nstatic void MP4_FreeBox_urn( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_urn->psz_name );\n    FREENULL( p_box->data.p_urn->psz_location );\n}\n\n\nstatic int MP4_ReadBox_dref( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_dref_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_dref );\n\n    MP4_GET4BYTES( p_box->data.p_dref->i_entry_count );\n\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8 );\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"dref\\\" entry-count %d\",\n                      p_box->data.p_dref->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stts( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stts->pi_sample_count );\n    FREENULL( p_box->data.p_stts->pi_sample_delta );\n}\n\nstatic int MP4_ReadBox_stts( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stts_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stts );\n    MP4_GET4BYTES( p_box->data.p_stts->i_entry_count );\n\n    p_box->data.p_stts->pi_sample_count =\n        calloc( p_box->data.p_stts->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stts->pi_sample_delta =\n        calloc( p_box->data.p_stts->i_entry_count, sizeof(int32_t) );\n    if( p_box->data.p_stts->pi_sample_count == NULL\n     || p_box->data.p_stts->pi_sample_delta == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    uint32_t i = 0;\n    for( ; (i < p_box->data.p_stts->i_entry_count )&&( i_read >=8 ); i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_stts->pi_sample_count[i] );\n        MP4_GET4BYTES( p_box->data.p_stts->pi_sample_delta[i] );\n    }\n\n    if ( i < p_box->data.p_stts->i_entry_count )\n        p_box->data.p_stts->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stts\\\" entry-count %d\",\n                      p_box->data.p_stts->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic void MP4_FreeBox_ctts( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_ctts->pi_sample_count );\n    FREENULL( p_box->data.p_ctts->pi_sample_offset );\n}\n\nstatic int MP4_ReadBox_ctts( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_ctts_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_ctts );\n\n    MP4_GET4BYTES( p_box->data.p_ctts->i_entry_count );\n\n    p_box->data.p_ctts->pi_sample_count =\n        calloc( p_box->data.p_ctts->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_ctts->pi_sample_offset =\n        calloc( p_box->data.p_ctts->i_entry_count, sizeof(int32_t) );\n    if( ( p_box->data.p_ctts->pi_sample_count == NULL )\n     || ( p_box->data.p_ctts->pi_sample_offset == NULL ) )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    uint32_t i = 0;\n    for( ; (i < p_box->data.p_ctts->i_entry_count )&&( i_read >=8 ); i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_ctts->pi_sample_count[i] );\n        MP4_GET4BYTES( p_box->data.p_ctts->pi_sample_offset[i] );\n    }\n    if ( i < p_box->data.p_ctts->i_entry_count )\n        p_box->data.p_ctts->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"ctts\\\" entry-count %d\",\n                      p_box->data.p_ctts->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadLengthDescriptor( uint8_t **pp_peek, int64_t  *i_read )\n{\n    unsigned int i_b;\n    unsigned int i_len = 0;\n    do\n    {\n        i_b = **pp_peek;\n\n        (*pp_peek)++;\n        (*i_read)--;\n        i_len = ( i_len << 7 ) + ( i_b&0x7f );\n    } while( i_b&0x80 );\n    return( i_len );\n}\n\n\nstatic void MP4_FreeBox_esds( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_esds->es_descriptor.psz_URL );\n    if( p_box->data.p_esds->es_descriptor.p_decConfigDescr )\n    {\n        FREENULL( p_box->data.p_esds->es_descriptor.p_decConfigDescr->p_decoder_specific_info );\n        FREENULL( p_box->data.p_esds->es_descriptor.p_decConfigDescr );\n    }\n}\n\nstatic int MP4_ReadBox_esds( stream_t *p_stream, MP4_Box_t *p_box )\n{\n#define es_descriptor p_box->data.p_esds->es_descriptor\n    unsigned int i_len;\n    unsigned int i_flags;\n    unsigned int i_type;\n\n    MP4_READBOX_ENTER( MP4_Box_data_esds_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_esds );\n\n\n    MP4_GET1BYTE( i_type );\n    if( i_type == 0x03 ) /* MP4ESDescrTag ISO/IEC 14496-1 8.3.3 */\n    {\n        i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"found esds MPEG4ESDescr (%dBytes)\",\n                 i_len );\n#endif\n\n        MP4_GET2BYTES( es_descriptor.i_ES_ID );\n        MP4_GET1BYTE( i_flags );\n        es_descriptor.b_stream_dependence = ( (i_flags&0x80) != 0);\n        es_descriptor.b_url = ( (i_flags&0x40) != 0);\n        es_descriptor.b_OCRstream = ( (i_flags&0x20) != 0);\n\n        es_descriptor.i_stream_priority = i_flags&0x1f;\n        if( es_descriptor.b_stream_dependence )\n        {\n            MP4_GET2BYTES( es_descriptor.i_depend_on_ES_ID );\n        }\n        if( es_descriptor.b_url )\n        {\n            unsigned int i_len;\n\n            MP4_GET1BYTE( i_len );\n            i_len = __MIN(i_read, i_len);\n            es_descriptor.psz_URL = malloc( i_len + 1 );\n            if( es_descriptor.psz_URL )\n            {\n                memcpy( es_descriptor.psz_URL, p_peek, i_len );\n                es_descriptor.psz_URL[i_len] = 0;\n            }\n            p_peek += i_len;\n            i_read -= i_len;\n        }\n        else\n        {\n            es_descriptor.psz_URL = NULL;\n        }\n        if( es_descriptor.b_OCRstream )\n        {\n            MP4_GET2BYTES( es_descriptor.i_OCR_ES_ID );\n        }\n        MP4_GET1BYTE( i_type ); /* get next type */\n    }\n\n    if( i_type != 0x04)/* MP4DecConfigDescrTag ISO/IEC 14496-1 8.3.4 */\n    {\n         es_descriptor.p_decConfigDescr = NULL;\n         MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */\n    }\n\n    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"found esds MP4DecConfigDescr (%dBytes)\",\n                 i_len );\n#endif\n\n    es_descriptor.p_decConfigDescr =\n            calloc( 1, sizeof( MP4_descriptor_decoder_config_t ));\n    if( unlikely( es_descriptor.p_decConfigDescr == NULL ) )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET1BYTE( es_descriptor.p_decConfigDescr->i_objectProfileIndication );\n    MP4_GET1BYTE( i_flags );\n    es_descriptor.p_decConfigDescr->i_streamType = i_flags >> 2;\n    es_descriptor.p_decConfigDescr->b_upStream = ( i_flags >> 1 )&0x01;\n    MP4_GET3BYTES( es_descriptor.p_decConfigDescr->i_buffer_sizeDB );\n    MP4_GET4BYTES( es_descriptor.p_decConfigDescr->i_max_bitrate );\n    MP4_GET4BYTES( es_descriptor.p_decConfigDescr->i_avg_bitrate );\n    MP4_GET1BYTE( i_type );\n    if( i_type !=  0x05 )/* MP4DecSpecificDescrTag ISO/IEC 14496-1 8.3.5 */\n    {\n        es_descriptor.p_decConfigDescr->i_decoder_specific_info_len = 0;\n        es_descriptor.p_decConfigDescr->p_decoder_specific_info  = NULL;\n        MP4_READBOX_EXIT( 1 );\n    }\n\n    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"found esds MP4DecSpecificDescr (%dBytes)\",\n                 i_len );\n#endif\n    if( i_len > i_read )\n        MP4_READBOX_EXIT( 0 );\n\n    es_descriptor.p_decConfigDescr->i_decoder_specific_info_len = i_len;\n    es_descriptor.p_decConfigDescr->p_decoder_specific_info = malloc( i_len );\n    if( unlikely( es_descriptor.p_decConfigDescr->p_decoder_specific_info == NULL ) )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( es_descriptor.p_decConfigDescr->p_decoder_specific_info,\n            p_peek, i_len );\n\n    MP4_READBOX_EXIT( 1 );\n#undef es_descriptor\n}\n\nstatic void MP4_FreeBox_hvcC(MP4_Box_t *p_box )\n{\n    MP4_Box_data_hvcC_t *p_hvcC =  p_box->data.p_hvcC;\n    if( p_hvcC->i_hvcC > 0 ) FREENULL( p_hvcC->p_hvcC) ;\n}\n\nstatic int MP4_ReadBox_hvcC( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_hvcC_t *p_hvcC;\n\n    MP4_READBOX_ENTER( MP4_Box_data_hvcC_t );\n    p_hvcC = p_box->data.p_hvcC;\n\n    p_hvcC->i_hvcC = i_read;\n    if( p_hvcC->i_hvcC > 0 )\n    {\n        uint8_t * p = p_hvcC->p_hvcC = malloc( p_hvcC->i_hvcC );\n        if( p )\n            memcpy( p, p_peek, i_read );\n    }\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_avcC( MP4_Box_t *p_box )\n{\n    MP4_Box_data_avcC_t *p_avcC = p_box->data.p_avcC;\n    int i;\n\n    if( p_avcC->i_avcC > 0 ) FREENULL( p_avcC->p_avcC );\n\n    if( p_avcC->sps )\n    {\n        for( i = 0; i < p_avcC->i_sps; i++ )\n            FREENULL( p_avcC->sps[i] );\n    }\n    if( p_avcC->pps )\n    {\n        for( i = 0; i < p_avcC->i_pps; i++ )\n            FREENULL( p_avcC->pps[i] );\n    }\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->sps );\n    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->i_sps_length );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->pps );\n    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->i_pps_length );\n}\n\nstatic int MP4_ReadBox_avcC( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_avcC_t *p_avcC;\n    int i;\n\n    MP4_READBOX_ENTER( MP4_Box_data_avcC_t );\n    p_avcC = p_box->data.p_avcC;\n\n    p_avcC->i_avcC = i_read;\n    if( p_avcC->i_avcC > 0 )\n    {\n        uint8_t * p = p_avcC->p_avcC = malloc( p_avcC->i_avcC );\n        if( p )\n            memcpy( p, p_peek, i_read );\n    }\n\n    MP4_GET1BYTE( p_avcC->i_version );\n    MP4_GET1BYTE( p_avcC->i_profile );\n    MP4_GET1BYTE( p_avcC->i_profile_compatibility );\n    MP4_GET1BYTE( p_avcC->i_level );\n    MP4_GET1BYTE( p_avcC->i_reserved1 );\n    p_avcC->i_length_size = (p_avcC->i_reserved1&0x03) + 1;\n    p_avcC->i_reserved1 >>= 2;\n\n    MP4_GET1BYTE( p_avcC->i_reserved2 );\n    p_avcC->i_sps = p_avcC->i_reserved2&0x1f;\n    p_avcC->i_reserved2 >>= 5;\n\n    if( p_avcC->i_sps > 0 )\n    {\n        p_avcC->i_sps_length = calloc( p_avcC->i_sps, sizeof( uint16_t ) );\n        p_avcC->sps = calloc( p_avcC->i_sps, sizeof( uint8_t* ) );\n\n        if( !p_avcC->i_sps_length || !p_avcC->sps )\n            goto error;\n\n        for( i = 0; i < p_avcC->i_sps && i_read > 2; i++ )\n        {\n            MP4_GET2BYTES( p_avcC->i_sps_length[i] );\n            if ( p_avcC->i_sps_length[i] > i_read )\n                goto error;\n            p_avcC->sps[i] = malloc( p_avcC->i_sps_length[i] );\n            if( p_avcC->sps[i] )\n                memcpy( p_avcC->sps[i], p_peek, p_avcC->i_sps_length[i] );\n\n            p_peek += p_avcC->i_sps_length[i];\n            i_read -= p_avcC->i_sps_length[i];\n        }\n        if ( i != p_avcC->i_sps )\n            goto error;\n    }\n\n    MP4_GET1BYTE( p_avcC->i_pps );\n    if( p_avcC->i_pps > 0 )\n    {\n        p_avcC->i_pps_length = calloc( p_avcC->i_pps, sizeof( uint16_t ) );\n        p_avcC->pps = calloc( p_avcC->i_pps, sizeof( uint8_t* ) );\n\n        if( !p_avcC->i_pps_length || !p_avcC->pps )\n            goto error;\n\n        for( i = 0; i < p_avcC->i_pps && i_read > 2; i++ )\n        {\n            MP4_GET2BYTES( p_avcC->i_pps_length[i] );\n            if( p_avcC->i_pps_length[i] > i_read )\n                goto error;\n            p_avcC->pps[i] = malloc( p_avcC->i_pps_length[i] );\n            if( p_avcC->pps[i] )\n                memcpy( p_avcC->pps[i], p_peek, p_avcC->i_pps_length[i] );\n\n            p_peek += p_avcC->i_pps_length[i];\n            i_read -= p_avcC->i_pps_length[i];\n        }\n        if ( i != p_avcC->i_pps )\n            goto error;\n    }\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"avcC\\\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d\",\n             p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,\n             p_avcC->i_length_size,\n             p_avcC->i_sps, p_avcC->i_pps );\n    for( i = 0; i < p_avcC->i_sps; i++ )\n    {\n        msg_Dbg( p_stream, \"         - sps[%d] length=%d\",\n                 i, p_avcC->i_sps_length[i] );\n    }\n    for( i = 0; i < p_avcC->i_pps; i++ )\n    {\n        msg_Dbg( p_stream, \"         - pps[%d] length=%d\",\n                 i, p_avcC->i_pps_length[i] );\n    }\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n\nerror:\n    MP4_FreeBox_avcC( p_box );\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic int MP4_ReadBox_WMA2( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_WMA2_t );\n\n    MP4_Box_data_WMA2_t *p_WMA2 = p_box->data.p_WMA2;\n\n    MP4_GET2BYTESLE( p_WMA2->Format.wFormatTag );\n    MP4_GET2BYTESLE( p_WMA2->Format.nChannels );\n    MP4_GET4BYTESLE( p_WMA2->Format.nSamplesPerSec );\n    MP4_GET4BYTESLE( p_WMA2->Format.nAvgBytesPerSec );\n    MP4_GET2BYTESLE( p_WMA2->Format.nBlockAlign );\n    MP4_GET2BYTESLE( p_WMA2->Format.wBitsPerSample );\n\n    uint16_t i_cbSize;\n    MP4_GET2BYTESLE( i_cbSize );\n\n    if ( i_read < 0 || i_cbSize > i_read )\n        goto error;\n\n    p_WMA2->i_extra = i_cbSize;\n    if ( p_WMA2->i_extra )\n    {\n        p_WMA2->p_extra = malloc( p_WMA2->i_extra );\n        if ( ! p_WMA2->p_extra )\n            goto error;\n        memcpy( p_WMA2->p_extra, p_peek, p_WMA2->i_extra );\n    }\n\n    MP4_READBOX_EXIT( 1 );\n\nerror:\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic void MP4_FreeBox_WMA2( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_WMA2->p_extra );\n}\n\nstatic int MP4_ReadBox_strf( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_strf_t );\n\n    MP4_Box_data_strf_t *p_strf = p_box->data.p_strf;\n\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biSize );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biWidth );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biHeight );\n    MP4_GET2BYTESLE( p_strf->bmiHeader.biPlanes );\n    MP4_GET2BYTESLE( p_strf->bmiHeader.biBitCount );\n    MP4_GETFOURCC( p_strf->bmiHeader.biCompression );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biSizeImage );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biXPelsPerMeter );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biYPelsPerMeter );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biClrUsed );\n    MP4_GET4BYTESLE( p_strf->bmiHeader.biClrImportant );\n\n    if ( i_read < 0 )\n        goto error;\n\n    p_strf->i_extra = i_read;\n    if ( p_strf->i_extra )\n    {\n        p_strf->p_extra = malloc( p_strf->i_extra );\n        if ( ! p_strf->p_extra )\n            goto error;\n        memcpy( p_strf->p_extra, p_peek, i_read );\n    }\n\n    MP4_READBOX_EXIT( 1 );\n\nerror:\n    MP4_READBOX_EXIT( 0 );\n}\n\nstatic void MP4_FreeBox_strf( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_strf->p_extra );\n}\n\nstatic int MP4_ReadBox_ASF( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_ASF_t );\n\n    MP4_Box_data_ASF_t *p_asf = p_box->data.p_asf;\n\n    if (i_read != 8)\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET1BYTE( p_asf->i_stream_number );\n    /* remaining is unknown */\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_stsdext_chan( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_chan_t );\n    MP4_Box_data_chan_t *p_chan = p_box->data.p_chan;\n\n    if ( i_read < 16 )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET1BYTE( p_chan->i_version );\n    MP4_GET3BYTES( p_chan->i_channels_flags );\n    MP4_GET4BYTES( p_chan->layout.i_channels_layout_tag );\n    MP4_GET4BYTES( p_chan->layout.i_channels_bitmap );\n    MP4_GET4BYTES( p_chan->layout.i_channels_description_count );\n\n    size_t i_descsize = 8 + 3 * sizeof(float);\n    if ( (size_t)i_read < p_chan->layout.i_channels_description_count * i_descsize )\n        MP4_READBOX_EXIT( 0 );\n\n    p_chan->layout.p_descriptions =\n        malloc( p_chan->layout.i_channels_description_count * i_descsize );\n\n    if ( !p_chan->layout.p_descriptions )\n        MP4_READBOX_EXIT( 0 );\n\n    uint32_t i;\n    for( i=0; i<p_chan->layout.i_channels_description_count; i++ )\n    {\n        if ( i_read < 20 )\n            break;\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].i_channel_label );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].i_channel_flags );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].f_coordinates[0] );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].f_coordinates[1] );\n        MP4_GET4BYTES( p_chan->layout.p_descriptions[i].f_coordinates[2] );\n    }\n    if ( i<p_chan->layout.i_channels_description_count )\n        p_chan->layout.i_channels_description_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"chan\\\" flags=0x%x tag=0x%x bitmap=0x%x descriptions=%u\",\n             p_chan->i_channels_flags, p_chan->layout.i_channels_layout_tag,\n             p_chan->layout.i_channels_bitmap, p_chan->layout.i_channels_description_count );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stsdext_chan( MP4_Box_t *p_box )\n{\n    MP4_Box_data_chan_t *p_chan = p_box->data.p_chan;\n    free( p_chan->layout.p_descriptions );\n}\n\nstatic int MP4_ReadBox_dec3( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_dec3_t );\n\n    MP4_Box_data_dec3_t *p_dec3 = p_box->data.p_dec3;\n\n    unsigned i_header;\n    MP4_GET2BYTES( i_header );\n\n    p_dec3->i_data_rate = i_header >> 3;\n    p_dec3->i_num_ind_sub = (i_header & 0x7) + 1;\n    for (uint8_t i = 0; i < p_dec3->i_num_ind_sub; i++) {\n        MP4_GET3BYTES( i_header );\n        p_dec3->stream[i].i_fscod = ( i_header >> 22 ) & 0x03;\n        p_dec3->stream[i].i_bsid  = ( i_header >> 17 ) & 0x01f;\n        p_dec3->stream[i].i_bsmod = ( i_header >> 12 ) & 0x01f;\n        p_dec3->stream[i].i_acmod = ( i_header >> 9 ) & 0x07;\n        p_dec3->stream[i].i_lfeon = ( i_header >> 8 ) & 0x01;\n        p_dec3->stream[i].i_num_dep_sub = (i_header >> 1) & 0x0f;\n        if (p_dec3->stream[i].i_num_dep_sub) {\n            MP4_GET1BYTE( p_dec3->stream[i].i_chan_loc );\n            p_dec3->stream[i].i_chan_loc |= (i_header & 1) << 8;\n        } else\n            p_dec3->stream[i].i_chan_loc = 0;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n        \"read box: \\\"dec3\\\" bitrate %dkbps %d independant substreams\",\n            p_dec3->i_data_rate, p_dec3->i_num_ind_sub);\n\n    for (uint8_t i = 0; i < p_dec3->i_num_ind_sub; i++)\n        msg_Dbg( p_stream,\n                \"\\tstream %d: bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x \"\n                \"num dependant subs=%d chan_loc=0x%x\",\n                i, p_dec3->stream[i].i_bsid, p_dec3->stream[i].i_bsmod, p_dec3->stream[i].i_acmod,\n                p_dec3->stream[i].i_lfeon, p_dec3->stream[i].i_num_dep_sub, p_dec3->stream[i].i_chan_loc );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_dac3( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_dac3_t *p_dac3;\n    MP4_READBOX_ENTER( MP4_Box_data_dac3_t );\n\n    p_dac3 = p_box->data.p_dac3;\n\n    unsigned i_header;\n    MP4_GET3BYTES( i_header );\n\n    p_dac3->i_fscod = ( i_header >> 22 ) & 0x03;\n    p_dac3->i_bsid  = ( i_header >> 17 ) & 0x01f;\n    p_dac3->i_bsmod = ( i_header >> 14 ) & 0x07;\n    p_dac3->i_acmod = ( i_header >> 11 ) & 0x07;\n    p_dac3->i_lfeon = ( i_header >> 10 ) & 0x01;\n    p_dac3->i_bitrate_code = ( i_header >> 5) & 0x1f;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"dac3\\\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x\",\n             p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_dvc1( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_dvc1_t *p_dvc1;\n\n    MP4_READBOX_ENTER( MP4_Box_data_dvc1_t );\n    p_dvc1 = p_box->data.p_dvc1;\n\n    MP4_GET1BYTE( p_dvc1->i_profile_level ); /* profile is on 4bits, level 3bits */\n    uint8_t i_profile = (p_dvc1->i_profile_level & 0xf0) >> 4;\n    if( i_profile != 0x06 && i_profile != 0x0c )\n    {\n        msg_Warn( p_stream, \"unsupported VC-1 profile (%\"PRIu8\"), please report\", i_profile );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n\n    p_dvc1->i_vc1 = p_box->i_size - 7; /* Header + profile_level */\n\n    if( p_dvc1->i_vc1 > 0 )\n    {\n        uint8_t *p = p_dvc1->p_vc1 = malloc( p_dvc1->i_vc1 );\n        if( p )\n            memcpy( p, p_peek, i_read );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"dvc1\\\" profile=%\"PRIu8\" level=%i\",\n             i_profile, p_dvc1->i_profile_level & 0x0e >> 1 );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_enda( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_enda_t *p_enda;\n    MP4_READBOX_ENTER( MP4_Box_data_enda_t );\n\n    p_enda = p_box->data.p_enda;\n\n    MP4_GET2BYTES( p_enda->i_little_endian );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"enda\\\" little_endian=%d\", p_enda->i_little_endian );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_sample_soun( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    p_box->i_handler = ATOM_soun;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_soun_t );\n    p_box->data.p_sample_soun->p_qt_description = NULL;\n\n    /* Sanity check needed because the \"wave\" box does also contain an\n     * \"mp4a\" box that we don't understand. */\n    if( i_read < 28 )\n    {\n        i_read -= 30;\n        MP4_READBOX_EXIT( 1 );\n    }\n\n    for( unsigned i = 0; i < 6 ; i++ )\n    {\n        MP4_GET1BYTE( p_box->data.p_sample_soun->i_reserved1[i] );\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_data_reference_index );\n\n    /*\n     * XXX hack -> produce a copy of the nearly complete chunk\n     */\n    p_box->data.p_sample_soun->i_qt_description = 0;\n    p_box->data.p_sample_soun->p_qt_description = NULL;\n    if( i_read > 0 )\n    {\n        p_box->data.p_sample_soun->p_qt_description = malloc( i_read );\n        if( p_box->data.p_sample_soun->p_qt_description )\n        {\n            p_box->data.p_sample_soun->i_qt_description = i_read;\n            memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );\n        }\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_qt_version );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_qt_revision_level );\n    MP4_GET4BYTES( p_box->data.p_sample_soun->i_qt_vendor );\n\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_channelcount );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_samplesize );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_compressionid );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_reserved3 );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_sampleratehi );\n    MP4_GET2BYTES( p_box->data.p_sample_soun->i_sampleratelo );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"soun\\\" stsd qt_version %\"PRIu16\" compid=%\"PRIx16,\n             p_box->data.p_sample_soun->i_qt_version,\n             p_box->data.p_sample_soun->i_compressionid );\n#endif\n\n    if( p_box->data.p_sample_soun->i_qt_version == 1 && i_read >= 16 )\n    {\n        /* SoundDescriptionV1 */\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_sample_per_packet );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_bytes_per_packet );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_bytes_per_frame );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_bytes_per_sample );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream,\n                 \"read box: \\\"soun\\\" V1 sample/packet=%d bytes/packet=%d \"\n                 \"bytes/frame=%d bytes/sample=%d\",\n                 p_box->data.p_sample_soun->i_sample_per_packet,\n                 p_box->data.p_sample_soun->i_bytes_per_packet,\n                 p_box->data.p_sample_soun->i_bytes_per_frame,\n                 p_box->data.p_sample_soun->i_bytes_per_sample );\n#endif\n        stream_Seek( p_stream, p_box->i_pos +\n                        mp4_box_headersize( p_box ) + 44 );\n    }\n    else if( p_box->data.p_sample_soun->i_qt_version == 2 && i_read >= 36 )\n    {\n        /* SoundDescriptionV2 */\n        double f_sample_rate;\n        int64_t i_dummy64;\n        uint32_t i_channel, i_extoffset, i_dummy32;\n\n        /* Checks */\n        if ( p_box->data.p_sample_soun->i_channelcount != 0x3  ||\n             p_box->data.p_sample_soun->i_samplesize != 0x0010 ||\n             p_box->data.p_sample_soun->i_compressionid != 0xFFFE ||\n             p_box->data.p_sample_soun->i_reserved3 != 0x0     ||\n             p_box->data.p_sample_soun->i_sampleratehi != 0x1  ||//65536\n             p_box->data.p_sample_soun->i_sampleratelo != 0x0 )  //remainder\n        {\n            msg_Err( p_stream, \"invalid stsd V2 box defaults\" );\n            MP4_READBOX_EXIT( 0 );\n        }\n        /* !Checks */\n\n        MP4_GET4BYTES( i_extoffset ); /* offset to stsd extentions */\n        MP4_GET8BYTES( i_dummy64 );\n        memcpy( &f_sample_rate, &i_dummy64, 8 );\n        msg_Dbg( p_stream, \"read box: %f Hz\", f_sample_rate );\n        p_box->data.p_sample_soun->i_sampleratehi = (int)f_sample_rate % BLOCK16x16;\n        p_box->data.p_sample_soun->i_sampleratelo = f_sample_rate / BLOCK16x16;\n\n        MP4_GET4BYTES( i_channel );\n        p_box->data.p_sample_soun->i_channelcount = i_channel;\n\n        MP4_GET4BYTES( i_dummy32 );\n        if ( i_dummy32 != 0x7F000000 )\n        {\n            msg_Err( p_stream, \"invalid stsd V2 box\" );\n            MP4_READBOX_EXIT( 0 );\n        }\n\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_constbitsperchannel );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_formatflags );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_constbytesperaudiopacket );\n        MP4_GET4BYTES( p_box->data.p_sample_soun->i_constLPCMframesperaudiopacket );\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"soun\\\" V2 rate=%f bitsperchannel=%u \"\n                           \"flags=%u bytesperpacket=%u lpcmframesperpacket=%u\",\n                 f_sample_rate,\n                 p_box->data.p_sample_soun->i_constbitsperchannel,\n                 p_box->data.p_sample_soun->i_formatflags,\n                 p_box->data.p_sample_soun->i_constbytesperaudiopacket,\n                 p_box->data.p_sample_soun->i_constLPCMframesperaudiopacket );\n#endif\n        if ( i_extoffset < p_box->i_size )\n            stream_Seek( p_stream, p_box->i_pos + i_extoffset );\n        else\n            stream_Seek( p_stream, p_box->i_pos + p_box->i_size );\n    }\n    else\n    {\n        p_box->data.p_sample_soun->i_sample_per_packet = 0;\n        p_box->data.p_sample_soun->i_bytes_per_packet = 0;\n        p_box->data.p_sample_soun->i_bytes_per_frame = 0;\n        p_box->data.p_sample_soun->i_bytes_per_sample = 0;\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"soun\\\" V0 or qt1/2 (rest=%\"PRId64\")\",\n                 i_read );\n#endif\n        stream_Seek( p_stream, p_box->i_pos +\n                        mp4_box_headersize( p_box ) + 28 );\n    }\n\n    if( p_box->i_type == ATOM_drms )\n    {\n        msg_Warn( p_stream, \"DRM protected streams are not supported.\" );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )\n    {\n        /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */\n        p_box->data.p_sample_soun->i_channelcount = 1;\n    }\n\n    /* Loads extensions */\n    MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"soun\\\" in stsd channel %d \"\n             \"sample size %d sample rate %f\",\n             p_box->data.p_sample_soun->i_channelcount,\n             p_box->data.p_sample_soun->i_samplesize,\n             (float)p_box->data.p_sample_soun->i_sampleratehi +\n             (float)p_box->data.p_sample_soun->i_sampleratelo / BLOCK16x16 );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic void MP4_FreeBox_sample_soun( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sample_soun->p_qt_description );\n}\n\n\nint MP4_ReadBox_sample_vide( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    p_box->i_handler = ATOM_vide;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_vide_t );\n\n    for( unsigned i = 0; i < 6 ; i++ )\n    {\n        MP4_GET1BYTE( p_box->data.p_sample_vide->i_reserved1[i] );\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_data_reference_index );\n\n    /*\n     * XXX hack -> produce a copy of the nearly complete chunk\n     */\n    if( i_read > 0 )\n    {\n        p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );\n        if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )\n            MP4_READBOX_EXIT( 0 );\n        p_box->data.p_sample_vide->i_qt_image_description = i_read;\n        memcpy( p_box->data.p_sample_vide->p_qt_image_description,\n                p_peek, i_read );\n    }\n    else\n    {\n        p_box->data.p_sample_vide->i_qt_image_description = 0;\n        p_box->data.p_sample_vide->p_qt_image_description = NULL;\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_version );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_revision_level );\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_vendor );\n\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_temporal_quality );\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_spatial_quality );\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_width );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_height );\n\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_horizresolution );\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_vertresolution );\n\n    MP4_GET4BYTES( p_box->data.p_sample_vide->i_qt_data_size );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_frame_count );\n\n    if ( i_read < 32 )\n        MP4_READBOX_EXIT( 0 );\n    memcpy( &p_box->data.p_sample_vide->i_compressorname, p_peek, 32 );\n    p_peek += 32; i_read -= 32;\n\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_depth );\n    MP4_GET2BYTES( p_box->data.p_sample_vide->i_qt_color_table );\n\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78);\n\n    if( p_box->i_type == ATOM_drmi )\n    {\n        msg_Warn( p_stream, \"DRM protected streams are not supported.\" );\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"vide\\\" in stsd %dx%d depth %d\",\n                      p_box->data.p_sample_vide->i_width,\n                      p_box->data.p_sample_vide->i_height,\n                      p_box->data.p_sample_vide->i_depth );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nvoid MP4_FreeBox_sample_vide( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sample_vide->p_qt_image_description );\n}\n\nstatic int MP4_ReadBox_sample_mp4s( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8 );\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n    return 1;\n}\n\nstatic int MP4_ReadBox_sample_text( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int32_t t;\n\n    p_box->i_handler = ATOM_text;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_text_t );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_reserved1 );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_reserved2 );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_data_reference_index );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_display_flags );\n\n    MP4_GET4BYTES( t );\n    switch( t )\n    {\n        /* FIXME search right signification */\n        case 1: // Center\n            p_box->data.p_sample_text->i_justification_horizontal = 1;\n            p_box->data.p_sample_text->i_justification_vertical = 1;\n            break;\n        case -1:    // Flush Right\n            p_box->data.p_sample_text->i_justification_horizontal = -1;\n            p_box->data.p_sample_text->i_justification_vertical = -1;\n            break;\n        case -2:    // Flush Left\n            p_box->data.p_sample_text->i_justification_horizontal = 0;\n            p_box->data.p_sample_text->i_justification_vertical = 0;\n            break;\n        case 0: // Flush Default\n        default:\n            p_box->data.p_sample_text->i_justification_horizontal = 1;\n            p_box->data.p_sample_text->i_justification_vertical = -1;\n            break;\n    }\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_background_color[0] );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_background_color[1] );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_background_color[2] );\n    p_box->data.p_sample_text->i_background_color[3] = 0xFF;\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_top );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_left );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_bottom );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_right );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"text\\\" in stsd text\" );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_sample_tx3g( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    p_box->i_handler = ATOM_text;\n    MP4_READBOX_ENTER( MP4_Box_data_sample_text_t );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_reserved1 );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_reserved2 );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_data_reference_index );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_display_flags );\n\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_justification_horizontal );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_justification_vertical );\n\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[0] );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[1] );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[2] );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_background_color[3] );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_top );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_left );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_bottom );\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_text_box_right );\n\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_reserved3 );\n\n    MP4_GET2BYTES( p_box->data.p_sample_text->i_font_id );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_font_face );\n    MP4_GET1BYTE ( p_box->data.p_sample_text->i_font_size );\n    MP4_GET4BYTES( p_box->data.p_sample_text->i_font_color );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"tx3g\\\" in stsd text\" );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\n#if 0\n/* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */\nstatic void MP4_FreeBox_sample_text( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sample_text->psz_text_name );\n}\n#endif\n\n\nstatic int MP4_ReadBox_stsd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n\n    MP4_READBOX_ENTER( MP4_Box_data_stsd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsd );\n\n    MP4_GET4BYTES( p_box->data.p_stsd->i_entry_count );\n\n    stream_Seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8 );\n\n    MP4_ReadBoxContainerRaw( p_stream, p_box );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsd\\\" entry-count %d\",\n                      p_box->data.p_stsd->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_stsz( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stsz_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsz );\n\n    MP4_GET4BYTES( p_box->data.p_stsz->i_sample_size );\n    MP4_GET4BYTES( p_box->data.p_stsz->i_sample_count );\n\n    if( p_box->data.p_stsz->i_sample_size == 0 )\n    {\n        p_box->data.p_stsz->i_entry_size =\n            calloc( p_box->data.p_stsz->i_sample_count, sizeof(uint32_t) );\n        if( unlikely( !p_box->data.p_stsz->i_entry_size ) )\n            MP4_READBOX_EXIT( 0 );\n\n        for( unsigned int i = 0; (i<p_box->data.p_stsz->i_sample_count)&&(i_read >= 4 ); i++ )\n        {\n            MP4_GET4BYTES( p_box->data.p_stsz->i_entry_size[i] );\n        }\n    }\n    else\n        p_box->data.p_stsz->i_entry_size = NULL;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsz\\\" sample-size %d sample-count %d\",\n                      p_box->data.p_stsz->i_sample_size,\n                      p_box->data.p_stsz->i_sample_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stsz( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stsz->i_entry_size );\n}\n\nstatic void MP4_FreeBox_stsc( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stsc->i_first_chunk );\n    FREENULL( p_box->data.p_stsc->i_samples_per_chunk );\n    FREENULL( p_box->data.p_stsc->i_sample_description_index );\n}\n\nstatic int MP4_ReadBox_stsc( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stsc_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsc );\n\n    MP4_GET4BYTES( p_box->data.p_stsc->i_entry_count );\n\n    p_box->data.p_stsc->i_first_chunk =\n        calloc( p_box->data.p_stsc->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stsc->i_samples_per_chunk =\n        calloc( p_box->data.p_stsc->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stsc->i_sample_description_index =\n        calloc( p_box->data.p_stsc->i_entry_count, sizeof(uint32_t) );\n    if( unlikely( p_box->data.p_stsc->i_first_chunk == NULL\n     || p_box->data.p_stsc->i_samples_per_chunk == NULL\n     || p_box->data.p_stsc->i_sample_description_index == NULL ) )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    for( unsigned int i = 0; (i < p_box->data.p_stsc->i_entry_count )&&( i_read >= 12 );i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_stsc->i_first_chunk[i] );\n        MP4_GET4BYTES( p_box->data.p_stsc->i_samples_per_chunk[i] );\n        MP4_GET4BYTES( p_box->data.p_stsc->i_sample_description_index[i] );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsc\\\" entry-count %d\",\n                      p_box->data.p_stsc->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_stco_co64( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_co64_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_co64 );\n\n    MP4_GET4BYTES( p_box->data.p_co64->i_entry_count );\n\n    p_box->data.p_co64->i_chunk_offset =\n        calloc( p_box->data.p_co64->i_entry_count, sizeof(uint64_t) );\n    if( p_box->data.p_co64->i_chunk_offset == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned int i = 0; i < p_box->data.p_co64->i_entry_count; i++ )\n    {\n        if( p_box->i_type == ATOM_stco )\n        {\n            if( i_read < 4 )\n            {\n                break;\n            }\n            MP4_GET4BYTES( p_box->data.p_co64->i_chunk_offset[i] );\n        }\n        else\n        {\n            if( i_read < 8 )\n            {\n                break;\n            }\n            MP4_GET8BYTES( p_box->data.p_co64->i_chunk_offset[i] );\n        }\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"co64\\\" entry-count %d\",\n                      p_box->data.p_co64->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stco_co64( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_co64->i_chunk_offset );\n}\n\nstatic int MP4_ReadBox_stss( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stss_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stss );\n\n    MP4_GET4BYTES( p_box->data.p_stss->i_entry_count );\n\n    p_box->data.p_stss->i_sample_number =\n        calloc( p_box->data.p_stss->i_entry_count, sizeof(uint32_t) );\n    if( unlikely( p_box->data.p_stss->i_sample_number == NULL ) )\n        MP4_READBOX_EXIT( 0 );\n\n    unsigned int i;\n    for( i = 0; (i < p_box->data.p_stss->i_entry_count )&&( i_read >= 4 ); i++ )\n    {\n\n        MP4_GET4BYTES( p_box->data.p_stss->i_sample_number[i] );\n        /* XXX in libmp4 sample begin at 0 */\n        p_box->data.p_stss->i_sample_number[i]--;\n    }\n    if ( i < p_box->data.p_stss->i_entry_count )\n        p_box->data.p_stss->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stss\\\" entry-count %d\",\n                      p_box->data.p_stss->i_entry_count );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stss( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stss->i_sample_number );\n}\n\nstatic void MP4_FreeBox_stsh( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stsh->i_shadowed_sample_number );\n    FREENULL( p_box->data.p_stsh->i_sync_sample_number );\n}\n\nstatic int MP4_ReadBox_stsh( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stsh_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stsh );\n\n\n    MP4_GET4BYTES( p_box->data.p_stsh->i_entry_count );\n\n    p_box->data.p_stsh->i_shadowed_sample_number =\n        calloc( p_box->data.p_stsh->i_entry_count, sizeof(uint32_t) );\n    p_box->data.p_stsh->i_sync_sample_number =\n        calloc( p_box->data.p_stsh->i_entry_count, sizeof(uint32_t) );\n\n    if( p_box->data.p_stsh->i_shadowed_sample_number == NULL\n     || p_box->data.p_stsh->i_sync_sample_number == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    unsigned i;\n    for( i = 0; (i < p_box->data.p_stss->i_entry_count )&&( i_read >= 8 ); i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_stsh->i_shadowed_sample_number[i] );\n        MP4_GET4BYTES( p_box->data.p_stsh->i_sync_sample_number[i] );\n    }\n    if ( i < p_box->data.p_stss->i_entry_count )\n        p_box->data.p_stss->i_entry_count = i;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stsh\\\" entry-count %d\",\n                      p_box->data.p_stsh->i_entry_count );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\n\nstatic int MP4_ReadBox_stdp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_stdp_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_stdp );\n\n    p_box->data.p_stdp->i_priority =\n        calloc( i_read / 2, sizeof(uint16_t) );\n\n    if( unlikely( !p_box->data.p_stdp->i_priority ) )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned i = 0; i < i_read / 2 ; i++ )\n    {\n        MP4_GET2BYTES( p_box->data.p_stdp->i_priority[i] );\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stdp\\\" entry-count %\"PRId64,\n                      i_read / 2 );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_stdp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_stdp->i_priority );\n}\n\nstatic void MP4_FreeBox_padb( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_padb->i_reserved1 );\n    FREENULL( p_box->data.p_padb->i_pad2 );\n    FREENULL( p_box->data.p_padb->i_reserved2 );\n    FREENULL( p_box->data.p_padb->i_pad1 );\n}\n\nstatic int MP4_ReadBox_padb( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint32_t count;\n\n    MP4_READBOX_ENTER( MP4_Box_data_padb_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_padb );\n\n    MP4_GET4BYTES( p_box->data.p_padb->i_sample_count );\n    count = (p_box->data.p_padb->i_sample_count + 1) / 2;\n\n    p_box->data.p_padb->i_reserved1 = calloc( count, sizeof(uint16_t) );\n    p_box->data.p_padb->i_pad2 = calloc( count, sizeof(uint16_t) );\n    p_box->data.p_padb->i_reserved2 = calloc( count, sizeof(uint16_t) );\n    p_box->data.p_padb->i_pad1 = calloc( count, sizeof(uint16_t) );\n    if( p_box->data.p_padb->i_reserved1 == NULL\n     || p_box->data.p_padb->i_pad2 == NULL\n     || p_box->data.p_padb->i_reserved2 == NULL\n     || p_box->data.p_padb->i_pad1 == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    for( unsigned int i = 0; i < i_read / 2 ; i++ )\n    {\n        if( i >= count )\n        {\n            MP4_READBOX_EXIT( 0 );\n        }\n        p_box->data.p_padb->i_reserved1[i] = ( (*p_peek) >> 7 )&0x01;\n        p_box->data.p_padb->i_pad2[i] = ( (*p_peek) >> 4 )&0x07;\n        p_box->data.p_padb->i_reserved1[i] = ( (*p_peek) >> 3 )&0x01;\n        p_box->data.p_padb->i_pad1[i] = ( (*p_peek) )&0x07;\n\n        p_peek += 1; i_read -= 1;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"stdp\\\" entry-count %\"PRId64,\n                      i_read / 2 );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_elst( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_elst->i_segment_duration );\n    FREENULL( p_box->data.p_elst->i_media_time );\n    FREENULL( p_box->data.p_elst->i_media_rate_integer );\n    FREENULL( p_box->data.p_elst->i_media_rate_fraction );\n}\n\nstatic int MP4_ReadBox_elst( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_elst_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_elst );\n\n\n    MP4_GET4BYTES( p_box->data.p_elst->i_entry_count );\n\n    p_box->data.p_elst->i_segment_duration =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(uint64_t) );\n    p_box->data.p_elst->i_media_time =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(int64_t) );\n    p_box->data.p_elst->i_media_rate_integer =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(uint16_t) );\n    p_box->data.p_elst->i_media_rate_fraction =\n        calloc( p_box->data.p_elst->i_entry_count, sizeof(uint16_t) );\n    if( p_box->data.p_elst->i_segment_duration == NULL\n     || p_box->data.p_elst->i_media_time == NULL\n     || p_box->data.p_elst->i_media_rate_integer == NULL\n     || p_box->data.p_elst->i_media_rate_fraction == NULL )\n    {\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    unsigned i;\n    for( i = 0; i < p_box->data.p_elst->i_entry_count; i++ )\n    {\n        if( p_box->data.p_elst->i_version == 1 )\n        {\n            if ( i_read < 20 )\n                break;\n            MP4_GET8BYTES( p_box->data.p_elst->i_segment_duration[i] );\n\n            MP4_GET8BYTES( p_box->data.p_elst->i_media_time[i] );\n        }\n        else\n        {\n            if ( i_read < 12 )\n                break;\n            MP4_GET4BYTES( p_box->data.p_elst->i_segment_duration[i] );\n\n            MP4_GET4BYTES( p_box->data.p_elst->i_media_time[i] );\n            p_box->data.p_elst->i_media_time[i] = (int32_t)p_box->data.p_elst->i_media_time[i];\n        }\n\n        MP4_GET2BYTES( p_box->data.p_elst->i_media_rate_integer[i] );\n        MP4_GET2BYTES( p_box->data.p_elst->i_media_rate_fraction[i] );\n    }\n    if ( i < p_box->data.p_elst->i_entry_count )\n        p_box->data.p_elst->i_entry_count = i;\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"elst\\\" entry-count %lu\",\n             (unsigned long)p_box->data.p_elst->i_entry_count );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_cprt( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint16_t i_language;\n    bool b_mac;\n\n    MP4_READBOX_ENTER( MP4_Box_data_cprt_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );\n\n    MP4_GET2BYTES( i_language );\n    decodeQtLanguageCode( i_language, p_box->data.p_cprt->rgs_language, &b_mac );\n\n    MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"cprt\\\" language %3.3s notice %s\",\n                      p_box->data.p_cprt->rgs_language,\n                      p_box->data.p_cprt->psz_notice );\n\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_cprt( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_cprt->psz_notice );\n}\n\n\nstatic int MP4_ReadBox_dcom( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_dcom_t );\n\n    MP4_GETFOURCC( p_box->data.p_dcom->i_algorithm );\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"dcom\\\" compression algorithm : %4.4s\",\n                      (char*)&p_box->data.p_dcom->i_algorithm );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_cmvd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_cmvd_t );\n\n    MP4_GET4BYTES( p_box->data.p_cmvd->i_uncompressed_size );\n\n    p_box->data.p_cmvd->i_compressed_size = i_read;\n\n    if( !( p_box->data.p_cmvd->p_data = malloc( i_read ) ) )\n        MP4_READBOX_EXIT( 0 );\n\n    /* now copy compressed data */\n    memcpy( p_box->data.p_cmvd->p_data, p_peek,i_read);\n\n    p_box->data.p_cmvd->b_compressed = 1;\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"cmvd\\\" compressed data size %d\",\n                      p_box->data.p_cmvd->i_compressed_size );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\nstatic void MP4_FreeBox_cmvd( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_cmvd->p_data );\n}\n\n\nstatic int MP4_ReadBox_cmov( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_t *p_dcom;\n    MP4_Box_t *p_cmvd;\n\n#ifdef HAVE_ZLIB_H\n    stream_t *p_stream_memory;\n    z_stream z_data;\n    uint8_t *p_data;\n    int i_result;\n#endif\n\n    if( !( p_box->data.p_cmov = calloc(1, sizeof( MP4_Box_data_cmov_t ) ) ) )\n        return 0;\n\n    if( !p_box->p_father ||\n        ( p_box->p_father->i_type != ATOM_moov &&\n          p_box->p_father->i_type != ATOM_foov ) )\n    {\n        msg_Warn( p_stream, \"Read box: \\\"cmov\\\" box alone\" );\n        return 1;\n    }\n\n    if( !MP4_ReadBoxContainer( p_stream, p_box ) )\n    {\n        return 0;\n    }\n\n    if( ( p_dcom = MP4_BoxGet( p_box, \"dcom\" ) ) == NULL ||\n        ( p_cmvd = MP4_BoxGet( p_box, \"cmvd\" ) ) == NULL ||\n        p_cmvd->data.p_cmvd->p_data == NULL )\n    {\n        msg_Warn( p_stream, \"read box: \\\"cmov\\\" incomplete\" );\n        return 0;\n    }\n\n    if( p_dcom->data.p_dcom->i_algorithm != ATOM_zlib )\n    {\n        msg_Dbg( p_stream, \"read box: \\\"cmov\\\" compression algorithm : %4.4s \"\n                 \"not supported\", (char*)&p_dcom->data.p_dcom->i_algorithm );\n        return 0;\n    }\n\n#ifndef HAVE_ZLIB_H\n    msg_Dbg( p_stream, \"read box: \\\"cmov\\\" zlib unsupported\" );\n    return 0;\n\n#else\n    /* decompress data */\n    /* allocate a new buffer */\n    if( !( p_data = malloc( p_cmvd->data.p_cmvd->i_uncompressed_size ) ) )\n        return 0;\n    /* init default structures */\n    z_data.next_in   = p_cmvd->data.p_cmvd->p_data;\n    z_data.avail_in  = p_cmvd->data.p_cmvd->i_compressed_size;\n    z_data.next_out  = p_data;\n    z_data.avail_out = p_cmvd->data.p_cmvd->i_uncompressed_size;\n    z_data.zalloc    = (alloc_func)Z_NULL;\n    z_data.zfree     = (free_func)Z_NULL;\n    z_data.opaque    = (voidpf)Z_NULL;\n\n    /* init zlib */\n    if( inflateInit( &z_data ) != Z_OK )\n    {\n        msg_Err( p_stream, \"read box: \\\"cmov\\\" error while uncompressing\" );\n        free( p_data );\n        return 0;\n    }\n\n    /* uncompress */\n    i_result = inflate( &z_data, Z_NO_FLUSH );\n    if( i_result != Z_OK && i_result != Z_STREAM_END )\n    {\n        msg_Err( p_stream, \"read box: \\\"cmov\\\" error while uncompressing\" );\n        free( p_data );\n        return 0;\n    }\n\n    if( p_cmvd->data.p_cmvd->i_uncompressed_size != z_data.total_out )\n    {\n        msg_Warn( p_stream, \"read box: \\\"cmov\\\" uncompressing data size \"\n                  \"mismatch\" );\n    }\n    p_cmvd->data.p_cmvd->i_uncompressed_size = z_data.total_out;\n\n    /* close zlib */\n    if( inflateEnd( &z_data ) != Z_OK )\n    {\n        msg_Warn( p_stream, \"read box: \\\"cmov\\\" error while uncompressing \"\n                  \"data (ignored)\" );\n    }\n\n    free( p_cmvd->data.p_cmvd->p_data );\n    p_cmvd->data.p_cmvd->p_data = p_data;\n    p_cmvd->data.p_cmvd->b_compressed = 0;\n\n    msg_Dbg( p_stream, \"read box: \\\"cmov\\\" box successfully uncompressed\" );\n\n    /* now create a memory stream */\n    p_stream_memory =\n        stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->p_data,\n                          p_cmvd->data.p_cmvd->i_uncompressed_size, true );\n\n    /* and read uncompressd moov */\n    p_box->data.p_cmov->p_moov = MP4_ReadBox( p_stream_memory, NULL );\n\n    stream_Delete( p_stream_memory );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"cmov\\\" compressed movie header completed\");\n#endif\n\n    return p_box->data.p_cmov->p_moov ? 1 : 0;\n#endif /* HAVE_ZLIB_H */\n}\n\nstatic int MP4_ReadBox_rdrf( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint32_t i_len;\n    MP4_READBOX_ENTER( MP4_Box_data_rdrf_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );\n    MP4_GETFOURCC( p_box->data.p_rdrf->i_ref_type );\n    MP4_GET4BYTES( i_len );\n    i_len++;\n\n    if( i_len > 0 )\n    {\n        p_box->data.p_rdrf->psz_ref = malloc( i_len );\n        if( p_box->data.p_rdrf->psz_ref == NULL )\n            MP4_READBOX_EXIT( 0 );\n        i_len--;\n\n        for( unsigned i = 0; i < i_len; i++ )\n        {\n            MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );\n        }\n        p_box->data.p_rdrf->psz_ref[i_len] = '\\0';\n    }\n    else\n    {\n        p_box->data.p_rdrf->psz_ref = NULL;\n    }\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n            \"read box: \\\"rdrf\\\" type:%4.4s ref %s\",\n            (char*)&p_box->data.p_rdrf->i_ref_type,\n            p_box->data.p_rdrf->psz_ref );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_rdrf( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_rdrf->psz_ref );\n}\n\n\nstatic int MP4_ReadBox_rmdr( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_rmdr_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );\n\n    MP4_GET4BYTES( p_box->data.p_rmdr->i_rate );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"rmdr\\\" rate:%d\",\n             p_box->data.p_rmdr->i_rate );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_rmqu( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_rmqu_t );\n\n    MP4_GET4BYTES( p_box->data.p_rmqu->i_quality );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"rmqu\\\" quality:%d\",\n             p_box->data.p_rmqu->i_quality );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_rmvc( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_rmvc_t );\n    MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );\n\n    MP4_GETFOURCC( p_box->data.p_rmvc->i_gestaltType );\n    MP4_GET4BYTES( p_box->data.p_rmvc->i_val1 );\n    MP4_GET4BYTES( p_box->data.p_rmvc->i_val2 );\n    MP4_GET2BYTES( p_box->data.p_rmvc->i_checkType );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"rmvc\\\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x\",\n             (char*)&p_box->data.p_rmvc->i_gestaltType,\n             p_box->data.p_rmvc->i_val1,p_box->data.p_rmvc->i_val2,\n             p_box->data.p_rmvc->i_checkType );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_frma( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_frma_t );\n\n    MP4_GETFOURCC( p_box->data.p_frma->i_type );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"frma\\\" i_type:%4.4s\",\n             (char *)&p_box->data.p_frma->i_type );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_skcr( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_skcr_t );\n\n    MP4_GET4BYTES( p_box->data.p_skcr->i_init );\n    MP4_GET4BYTES( p_box->data.p_skcr->i_encr );\n    MP4_GET4BYTES( p_box->data.p_skcr->i_decr );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"skcr\\\" i_init:%d i_encr:%d i_decr:%d\",\n             p_box->data.p_skcr->i_init,\n             p_box->data.p_skcr->i_encr,\n             p_box->data.p_skcr->i_decr );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_drms( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    VLC_UNUSED(p_box);\n    /* ATOMs 'user', 'key', 'iviv', and 'priv' will be skipped,\n     * so unless data decrypt itself by magic, there will be no playback,\n     * but we never know... */\n    msg_Warn( p_stream, \"DRM protected streams are not supported.\" );\n    return 1;\n}\n\nstatic int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_String( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_string->psz_text );\n}\n\nstatic int MP4_ReadBox_Binary( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_binary_t );\n    i_read = __MIN( i_read, UINT32_MAX );\n    if ( i_read > 0 )\n    {\n        p_box->data.p_binary->p_blob = malloc( i_read );\n        if ( p_box->data.p_binary->p_blob )\n        {\n            memcpy( p_box->data.p_binary->p_blob, p_peek, i_read );\n            p_box->data.p_binary->i_blob = i_read;\n        }\n    }\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_Binary( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_binary->p_blob );\n    p_box->data.p_binary->i_blob = 0;\n}\n\nstatic int MP4_ReadBox_data( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_data_t );\n    MP4_Box_data_data_t *p_data = p_box->data.p_data;\n\n    if ( i_read < 8 || i_read - 8 > UINT32_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    uint8_t i_type;\n    MP4_GET1BYTE( i_type );\n    if ( i_type != 0 )\n    {\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"skipping unknown 'data' atom with type %\"PRIu8, i_type );\n#endif\n        MP4_READBOX_EXIT( 0 );\n    }\n\n    MP4_GET3BYTES( p_data->e_wellknowntype );\n    MP4_GET2BYTES( p_data->locale.i_country );\n    MP4_GET2BYTES( p_data->locale.i_language );\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read 'data' atom: knowntype=%\"PRIu32\", country=%\"PRIu16\" lang=%\"PRIu16\n                 \", size %\"PRId64\" bytes\", p_data->e_wellknowntype,\n                 p_data->locale.i_country, p_data->locale.i_language, i_read );\n#endif\n    p_box->data.p_data->p_blob = malloc( i_read );\n    if ( !p_box->data.p_data->p_blob )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_data->i_blob = i_read;\n    memcpy( p_box->data.p_data->p_blob, p_peek, i_read);\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_data( MP4_Box_t *p_box )\n{\n    free( p_box->data.p_data->p_blob );\n}\n\nstatic int MP4_ReadBox_Metadata( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    const uint8_t *p_peek;\n    if ( stream_Peek( p_stream, &p_peek, 16 ) < 16 )\n        return 0;\n    if ( stream_Read( p_stream, NULL, 8 ) < 8 )\n        return 0;\n    return MP4_ReadBoxContainerChildren( p_stream, p_box, ATOM_data );\n}\n\n/* Chapter support */\nstatic void MP4_FreeBox_chpl( MP4_Box_t *p_box )\n{\n    MP4_Box_data_chpl_t *p_chpl = p_box->data.p_chpl;\n    for( unsigned i = 0; i < p_chpl->i_chapter; i++ )\n        free( p_chpl->chapter[i].psz_name );\n}\n\nstatic int MP4_ReadBox_chpl( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_Box_data_chpl_t *p_chpl;\n    uint32_t i_dummy;\n    VLC_UNUSED(i_dummy);\n    int i;\n    MP4_READBOX_ENTER( MP4_Box_data_chpl_t );\n\n    p_chpl = p_box->data.p_chpl;\n\n    MP4_GETVERSIONFLAGS( p_chpl );\n\n    if ( i_read < 5 || p_chpl->i_version != 0x1 )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET4BYTES( i_dummy );\n\n    MP4_GET1BYTE( p_chpl->i_chapter );\n\n    for( i = 0; i < p_chpl->i_chapter; i++ )\n    {\n        uint64_t i_start;\n        uint8_t i_len;\n        int i_copy;\n        if ( i_read < 9 )\n            break;\n        MP4_GET8BYTES( i_start );\n        MP4_GET1BYTE( i_len );\n\n        p_chpl->chapter[i].psz_name = malloc( i_len + 1 );\n        if( !p_chpl->chapter[i].psz_name )\n            MP4_READBOX_EXIT( 0 );\n\n        i_copy = __MIN( i_len, i_read );\n        if( i_copy > 0 )\n            memcpy( p_chpl->chapter[i].psz_name, p_peek, i_copy );\n        p_chpl->chapter[i].psz_name[i_copy] = '\\0';\n        p_chpl->chapter[i].i_start = i_start;\n\n        p_peek += i_copy;\n        i_read -= i_copy;\n    }\n\n    if ( i != p_chpl->i_chapter )\n        p_chpl->i_chapter = i;\n\n    /* Bubble sort by increasing start date */\n    do\n    {\n        for( i = 0; i < p_chpl->i_chapter - 1; i++ )\n        {\n            if( p_chpl->chapter[i].i_start > p_chpl->chapter[i+1].i_start )\n            {\n                char *psz = p_chpl->chapter[i+1].psz_name;\n                int64_t i64 = p_chpl->chapter[i+1].i_start;\n\n                p_chpl->chapter[i+1].psz_name = p_chpl->chapter[i].psz_name;\n                p_chpl->chapter[i+1].i_start = p_chpl->chapter[i].i_start;\n\n                p_chpl->chapter[i].psz_name = psz;\n                p_chpl->chapter[i].i_start = i64;\n\n                i = -1;\n                break;\n            }\n        }\n    } while( i == -1 );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"read box: \\\"chpl\\\" %d chapters\",\n                       p_chpl->i_chapter );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tref_generic( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tref_generic_t );\n\n    p_box->data.p_tref_generic->i_track_ID = NULL;\n    p_box->data.p_tref_generic->i_entry_count = i_read / sizeof(uint32_t);\n    if( p_box->data.p_tref_generic->i_entry_count > 0 )\n        p_box->data.p_tref_generic->i_track_ID = calloc( p_box->data.p_tref_generic->i_entry_count, sizeof(uint32_t) );\n    if( p_box->data.p_tref_generic->i_track_ID == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    for( unsigned i = 0; i < p_box->data.p_tref_generic->i_entry_count; i++ )\n    {\n        MP4_GET4BYTES( p_box->data.p_tref_generic->i_track_ID[i] );\n    }\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"chap\\\" %d references\",\n                 p_box->data.p_tref_generic->i_entry_count );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\nstatic void MP4_FreeBox_tref_generic( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_tref_generic->i_track_ID );\n}\n\nstatic int MP4_ReadBox_keys( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_keys_t );\n\n    if ( i_read < 8 )\n        MP4_READBOX_EXIT( 0 );\n\n    uint32_t i_count;\n    MP4_GET4BYTES( i_count ); /* reserved + flags */\n    if ( i_count != 0 )\n        MP4_READBOX_EXIT( 0 );\n\n    MP4_GET4BYTES( i_count );\n    p_box->data.p_keys->p_entries = calloc( i_count, sizeof(*p_box->data.p_keys->p_entries) );\n    if ( !p_box->data.p_keys->p_entries )\n        MP4_READBOX_EXIT( 0 );\n    p_box->data.p_keys->i_entry_count = i_count;\n\n    uint32_t i=0;\n    for( ; i < i_count; i++ )\n    {\n        if ( i_read < 8 )\n            break;\n        uint32_t i_keysize;\n        MP4_GET4BYTES( i_keysize );\n        if ( (i_keysize < 8) || (i_keysize - 4 > i_read) )\n            break;\n        MP4_GETFOURCC( p_box->data.p_keys->p_entries[i].i_namespace );\n        i_keysize -= 8;\n        p_box->data.p_keys->p_entries[i].psz_value = malloc( i_keysize + 1 );\n        if ( !p_box->data.p_keys->p_entries[i].psz_value )\n            break;\n        memcpy( p_box->data.p_keys->p_entries[i].psz_value, p_peek, i_keysize );\n        p_box->data.p_keys->p_entries[i].psz_value[i_keysize] = 0;\n        p_peek += i_keysize;\n        i_read -= i_keysize;\n#ifdef MP4_ULTRA_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"keys\\\": %u '%s'\", i + 1,\n                 p_box->data.p_keys->p_entries[i].psz_value );\n#endif\n    }\n    if ( i < i_count )\n        p_box->data.p_keys->i_entry_count = i;\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_keys( MP4_Box_t *p_box )\n{\n    for( uint32_t i=0; i<p_box->data.p_keys->i_entry_count; i++ )\n        free( p_box->data.p_keys->p_entries[i].psz_value );\n    free( p_box->data.p_keys->p_entries );\n}\n\nstatic int MP4_ReadBox_meta( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint8_t meta_data[8];\n    int i_actually_read;\n\n    // skip over box header\n    i_actually_read = stream_Read( p_stream, meta_data, 8 );\n    if( i_actually_read < 8 )\n        return 0;\n\n    if ( p_box->p_father && p_box->p_father->i_type == ATOM_udta ) /* itunes udta/meta */\n    {\n        /* meta content starts with a 4 byte version/flags value (should be 0) */\n        i_actually_read = stream_Read( p_stream, meta_data, 4 );\n        if( i_actually_read < 4 || memcmp( meta_data, \"\\0\\0\\0\", 4 ) )\n            return 0;\n    }\n\n    if ( !MP4_ReadBoxContainerChildren( p_stream, p_box, ATOM_hdlr ) )\n        return 0;\n\n    /* Mandatory */\n    const MP4_Box_t *p_hdlr = MP4_BoxGet( p_box, \"hdlr\" );\n    if ( !p_hdlr || !BOXDATA(p_hdlr) ||\n         ( BOXDATA(p_hdlr)->i_handler_type != HANDLER_mdta &&\n           BOXDATA(p_hdlr)->i_handler_type != HANDLER_mdir ) ||\n         BOXDATA(p_hdlr)->i_version != 0 )\n        return 0;\n\n    /* then it behaves like a container */\n    return MP4_ReadBoxContainerRaw( p_stream, p_box );\n}\n\nstatic int MP4_ReadBox_iods( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    char i_unused;\n    VLC_UNUSED(i_unused);\n\n    MP4_READBOX_ENTER( MP4_Box_data_iods_t );\n    MP4_GETVERSIONFLAGS( p_box->data.p_iods );\n\n    MP4_GET1BYTE( i_unused ); /* tag */\n    MP4_GET1BYTE( i_unused ); /* length */\n\n    MP4_GET2BYTES( p_box->data.p_iods->i_object_descriptor ); /* 10bits, 6 other bits\n                                                              are used for other flags */\n    MP4_GET1BYTE( p_box->data.p_iods->i_OD_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_scene_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_audio_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_visual_profile_level );\n    MP4_GET1BYTE( p_box->data.p_iods->i_graphics_profile_level );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"iods\\\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, \"\n             \"visual: %i, graphics: %i\",\n             p_box->data.p_iods->i_object_descriptor >> 6,\n             p_box->data.p_iods->i_OD_profile_level,\n             p_box->data.p_iods->i_scene_profile_level,\n             p_box->data.p_iods->i_audio_profile_level,\n             p_box->data.p_iods->i_visual_profile_level,\n             p_box->data.p_iods->i_graphics_profile_level );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_pasp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_pasp_t );\n\n    MP4_GET4BYTES( p_box->data.p_pasp->i_horizontal_spacing );\n    MP4_GET4BYTES( p_box->data.p_pasp->i_vertical_spacing );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"paps\\\" %dx%d\",\n             p_box->data.p_pasp->i_horizontal_spacing,\n             p_box->data.p_pasp->i_vertical_spacing);\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mehd( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_mehd_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mehd );\n    if( p_box->data.p_mehd->i_version == 1 )\n        MP4_GET8BYTES( p_box->data.p_mehd->i_fragment_duration );\n    else /* version == 0 */\n        MP4_GET4BYTES( p_box->data.p_mehd->i_fragment_duration );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"mehd\\\" frag dur. %\"PRIu64\"\",\n             p_box->data.p_mehd->i_fragment_duration );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_trex( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_trex_t );\n    MP4_GETVERSIONFLAGS( p_box->data.p_trex );\n\n    MP4_GET4BYTES( p_box->data.p_trex->i_track_ID );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_description_index );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_duration );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_size );\n    MP4_GET4BYTES( p_box->data.p_trex->i_default_sample_flags );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"trex\\\" trackID: %\"PRIu32\"\",\n             p_box->data.p_trex->i_track_ID );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_sdtp( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    uint32_t i_sample_count;\n    MP4_READBOX_ENTER( MP4_Box_data_sdtp_t );\n    MP4_Box_data_sdtp_t *p_sdtp = p_box->data.p_sdtp;\n    MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );\n    i_sample_count = i_read;\n\n    p_sdtp->p_sample_table = calloc( i_sample_count, 1 );\n\n    if( !p_sdtp->p_sample_table )\n        MP4_READBOX_EXIT( 0 );\n\n    for( uint32_t i = 0; i < i_sample_count; i++ )\n        MP4_GET1BYTE( p_sdtp->p_sample_table[i] );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"i_sample_count is %\"PRIu32\"\", i_sample_count );\n    if ( i_sample_count > 3 )\n        msg_Dbg( p_stream,\n             \"read box: \\\"sdtp\\\" head: %\"PRIx8\" %\"PRIx8\" %\"PRIx8\" %\"PRIx8\"\",\n                 p_sdtp->p_sample_table[0],\n                 p_sdtp->p_sample_table[1],\n                 p_sdtp->p_sample_table[2],\n                 p_sdtp->p_sample_table[3] );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic void MP4_FreeBox_sdtp( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_sdtp->p_sample_table );\n}\n\nstatic int MP4_ReadBox_tsel( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_tsel_t );\n    uint32_t i_version;\n    MP4_GET4BYTES( i_version );\n    if ( i_version != 0 || i_read < 4 )\n        MP4_READBOX_EXIT( 0 );\n    MP4_GET4BYTES( p_box->data.p_tsel->i_switch_group );\n    /* ignore list of attributes as es are present before switch */\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_mfro( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_mfro_t );\n\n    MP4_GETVERSIONFLAGS( p_box->data.p_mfro );\n    MP4_GET4BYTES( p_box->data.p_mfro->i_size );\n\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream,\n             \"read box: \\\"mfro\\\" size: %\"PRIu32\"\",\n             p_box->data.p_mfro->i_size);\n#endif\n\n    MP4_READBOX_EXIT( 1 );\n}\n\nstatic int MP4_ReadBox_tfra( stream_t *p_stream, MP4_Box_t *p_box )\n{\n#define READ_VARIABLE_LENGTH(lengthvar, p_array) switch (lengthvar)\\\n{\\\n    case 0:\\\n        MP4_GET1BYTE( p_array[i] );\\\n        break;\\\n    case 1:\\\n        MP4_GET2BYTES( *((uint16_t *)&p_array[i*2]) );\\\n        break;\\\n    case 2:\\\n        MP4_GET3BYTES( *((uint32_t *)&p_array[i*4]) );\\\n        break;\\\n    case 3:\\\n        MP4_GET4BYTES( *((uint32_t *)&p_array[i*4]) );\\\n        break;\\\n    default:\\\n        goto error;\\\n}\n#define FIX_VARIABLE_LENGTH(lengthvar) if ( lengthvar == 3 ) lengthvar = 4\n\n    uint32_t i_number_of_entries;\n    MP4_READBOX_ENTER( MP4_Box_data_tfra_t );\n    MP4_Box_data_tfra_t *p_tfra = p_box->data.p_tfra;\n    MP4_GETVERSIONFLAGS( p_box->data.p_tfra );\n    if ( p_tfra->i_version > 1 )\n        MP4_READBOX_EXIT( 0 );\n    MP4_GET4BYTES( p_tfra->i_track_ID );\n    uint32_t i_lengths = 0;\n    MP4_GET4BYTES( i_lengths );\n    MP4_GET4BYTES( p_tfra->i_number_of_entries );\n    i_number_of_entries = p_tfra->i_number_of_entries;\n    p_tfra->i_length_size_of_traf_num = i_lengths >> 4;\n    p_tfra->i_length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;\n    p_tfra->i_length_size_of_sample_num = i_lengths & 0x03;\n\n    size_t size = 4 + 4*p_tfra->i_version; /* size in {4, 8} */\n    p_tfra->p_time = calloc( i_number_of_entries, size );\n    p_tfra->p_moof_offset = calloc( i_number_of_entries, size );\n\n    size = 1 + p_tfra->i_length_size_of_traf_num; /* size in [|1, 4|] */\n    if ( size == 3 ) size++;\n    p_tfra->p_traf_number = calloc( i_number_of_entries, size );\n    size = 1 + p_tfra->i_length_size_of_trun_num;\n    if ( size == 3 ) size++;\n    p_tfra->p_trun_number = calloc( i_number_of_entries, size );\n    size = 1 + p_tfra->i_length_size_of_sample_num;\n    if ( size == 3 ) size++;\n    p_tfra->p_sample_number = calloc( i_number_of_entries, size );\n\n    if( !p_tfra->p_time || !p_tfra->p_moof_offset || !p_tfra->p_traf_number\n                        || !p_tfra->p_trun_number || !p_tfra->p_sample_number )\n        goto error;\n\n    int i_fields_length = 3 + p_tfra->i_length_size_of_traf_num\n            + p_tfra->i_length_size_of_trun_num\n            + p_tfra->i_length_size_of_sample_num;\n\n    uint32_t i;\n    for( i = 0; i < i_number_of_entries; i++ )\n    {\n\n        if( p_tfra->i_version == 1 )\n        {\n            if ( i_read < i_fields_length + 16 )\n                break;\n            MP4_GET8BYTES( *((uint64_t *)&p_tfra->p_time[i*2]) );\n            MP4_GET8BYTES( *((uint64_t *)&p_tfra->p_moof_offset[i*2]) );\n        }\n        else\n        {\n            if ( i_read < i_fields_length + 8 )\n                break;\n            MP4_GET4BYTES( p_tfra->p_time[i] );\n            MP4_GET4BYTES( p_tfra->p_moof_offset[i] );\n        }\n\n        READ_VARIABLE_LENGTH(p_tfra->i_length_size_of_traf_num, p_tfra->p_traf_number);\n        READ_VARIABLE_LENGTH(p_tfra->i_length_size_of_trun_num, p_tfra->p_trun_number);\n        READ_VARIABLE_LENGTH(p_tfra->i_length_size_of_sample_num, p_tfra->p_sample_number);\n    }\n    if ( i < i_number_of_entries )\n        i_number_of_entries = i;\n\n    FIX_VARIABLE_LENGTH(p_tfra->i_length_size_of_traf_num);\n    FIX_VARIABLE_LENGTH(p_tfra->i_length_size_of_trun_num);\n    FIX_VARIABLE_LENGTH(p_tfra->i_length_size_of_sample_num);\n\n#ifdef MP4_ULTRA_VERBOSE\n    for( i = 0; i < i_number_of_entries; i++ )\n    {\n        if( p_tfra->i_version == 0 )\n        {\n            msg_Dbg( p_stream, \"tfra[%\"PRIu32\"] time[%\"PRIu32\"]: %\"PRIu32\", \"\n                               \"moof_offset[%\"PRIu32\"]: %\"PRIu32\"\",\n                     p_tfra->i_track_ID,\n                     i, p_tfra->p_time[i],\n                     i, p_tfra->p_moof_offset[i] );\n        }\n        else\n        {\n            msg_Dbg( p_stream, \"tfra[%\"PRIu32\"] time[%\"PRIu32\"]: %\"PRIu64\", \"\n                               \"moof_offset[%\"PRIu32\"]: %\"PRIu64\"\",\n                     p_tfra->i_track_ID,\n                     i, ((uint64_t *)(p_tfra->p_time))[i],\n                     i, ((uint64_t *)(p_tfra->p_moof_offset))[i] );\n        }\n    }\n#endif\n#ifdef MP4_VERBOSE\n    msg_Dbg( p_stream, \"tfra[%\"PRIu32\"] %\"PRIu32\" entries\",\n             p_tfra->i_track_ID, i_number_of_entries );\n#endif\n\n    MP4_READBOX_EXIT( 1 );\nerror:\n    MP4_READBOX_EXIT( 0 );\n\n#undef READ_VARIABLE_LENGTH\n#undef FIX_VARIABLE_LENGTH\n}\n\nstatic void MP4_FreeBox_tfra( MP4_Box_t *p_box )\n{\n    FREENULL( p_box->data.p_tfra->p_time );\n    FREENULL( p_box->data.p_tfra->p_moof_offset );\n    FREENULL( p_box->data.p_tfra->p_traf_number );\n    FREENULL( p_box->data.p_tfra->p_trun_number );\n    FREENULL( p_box->data.p_tfra->p_sample_number );\n}\n\nstatic int MP4_ReadBox_pnot( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if ( p_box->i_size != 20 )\n        return 0;\n    MP4_READBOX_ENTER( MP4_Box_data_pnot_t );\n    MP4_GET4BYTES( p_box->data.p_pnot->i_date );\n    uint16_t i_version;\n    MP4_GET2BYTES( i_version );\n    if ( i_version != 0 )\n        MP4_READBOX_EXIT( 0 );\n    MP4_GETFOURCC( p_box->data.p_pnot->i_type );\n    MP4_GET2BYTES( p_box->data.p_pnot->i_index );\n    MP4_READBOX_EXIT( 1 );\n}\n\n/* For generic */\nstatic int MP4_ReadBox_default( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    if( !p_box->p_father )\n    {\n        goto unknown;\n    }\n    if( p_box->p_father->i_type == ATOM_stsd )\n    {\n        MP4_Box_t *p_mdia = MP4_BoxGet( p_box, \"../../../..\" );\n        MP4_Box_t *p_hdlr;\n\n        if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||\n            (p_hdlr = MP4_BoxGet( p_mdia, \"hdlr\" )) == NULL )\n        {\n            goto unknown;\n        }\n        switch( p_hdlr->data.p_hdlr->i_handler_type )\n        {\n            case ATOM_soun:\n                return MP4_ReadBox_sample_soun( p_stream, p_box );\n            case ATOM_vide:\n                return MP4_ReadBox_sample_vide( p_stream, p_box );\n            case ATOM_text:\n                return MP4_ReadBox_sample_text( p_stream, p_box );\n            case ATOM_tx3g:\n            case ATOM_sbtl:\n                return MP4_ReadBox_sample_tx3g( p_stream, p_box );\n            default:\n                msg_Warn( p_stream,\n                          \"unknown handler type in stsd (incompletely loaded)\" );\n                return 1;\n        }\n    }\n\nunknown:\n    if MP4_BOX_TYPE_ASCII()\n        msg_Warn( p_stream,\n                \"unknown box type %4.4s (incompletely loaded)\",\n                (char*)&p_box->i_type );\n    else\n        msg_Warn( p_stream,\n                \"unknown box type c%3.3s (incompletely loaded)\",\n                (char*)&p_box->i_type+1 );\n    p_box->e_flags |= BOX_FLAG_INCOMPLETE;\n\n    return 1;\n}\n\n/**** ------------------------------------------------------------------- ****/\n/****                   \"Higher level\" Functions                          ****/\n/**** ------------------------------------------------------------------- ****/\n\nstatic const struct\n{\n    uint32_t i_type;\n    int  (*MP4_ReadBox_function )( stream_t *p_stream, MP4_Box_t *p_box );\n    void (*MP4_FreeBox_function )( MP4_Box_t *p_box );\n    uint32_t i_parent; /* set parent to restrict, duplicating if needed; 0 for any */\n} MP4_Box_Function [] =\n{\n    /* Containers */\n    { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_foov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_foov },\n    { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_mdia },\n    { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_meta },\n    { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_udta },\n    { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_rmra },\n    { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_stsd },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_mp4a }, /* some quicktime mp4a/wave/mp4a.. */\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_WMA2 }, /* flip4mac */\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_in24 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_in32 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_fl32 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_fl64 },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_QDMC },\n    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_QDM2 },\n    { ATOM_ilst,    MP4_ReadBox_ilst,         MP4_FreeBox_Common, ATOM_meta },\n    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, ATOM_ftyp },\n\n    /* specific box */\n    { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp, 0 },\n    { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common, 0 },\n    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common, ATOM_moov },\n    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common, ATOM_foov },\n    { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_load,    MP4_ReadBox_load,         MP4_FreeBox_Common, ATOM_trak },\n    { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common, ATOM_mdia },\n    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr,   ATOM_mdia },\n    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr,   ATOM_meta },\n    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr,   ATOM_minf },\n    { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common, ATOM_minf },\n    { ATOM_alis,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, ATOM_dref },\n    { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url, 0 },\n    { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn, 0 },\n    { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common, 0 },\n    { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts,   ATOM_stbl },\n    { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts,   ATOM_stbl },\n    { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common, ATOM_stbl },\n    { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz,   ATOM_stbl },\n    { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc,   ATOM_stbl },\n    { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64, ATOM_stbl },\n    { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64, ATOM_stbl },\n    { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss, ATOM_stbl },\n    { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh, ATOM_stbl },\n    { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp, 0 },\n    { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb, 0 },\n    { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst, ATOM_edts },\n    { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt, 0 },\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_wave }, /* mp4a in wave chunk */\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_mp4a },\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_mp4v },\n    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds, ATOM_mp4s },\n    { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common, 0 },\n    { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd, 0 },\n    { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC, ATOM_avc1 },\n    { ATOM_hvcC,    MP4_ReadBox_hvcC,         MP4_FreeBox_hvcC, 0 },\n    { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common, 0 },\n    { ATOM_dec3,    MP4_ReadBox_dec3,         MP4_FreeBox_Common, 0 },\n    { ATOM_dvc1,    MP4_ReadBox_dvc1,         MP4_FreeBox_Common, 0 },\n    { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common, 0 },\n    { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common, 0 },\n    { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common, 0 },\n    { ATOM_keys,    MP4_ReadBox_keys,         MP4_FreeBox_keys,   ATOM_meta },\n\n    /* Quicktime preview atoms, all at root */\n    { ATOM_pnot,    MP4_ReadBox_pnot,         MP4_FreeBox_Common, 0 },\n    { ATOM_pict,    MP4_ReadBox_Binary,       MP4_FreeBox_Binary, 0 },\n    { ATOM_PICT,    MP4_ReadBox_Binary,       MP4_FreeBox_Binary, 0 },\n\n    /* Nothing to do with this box */\n    { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n    { ATOM_binm,    MP4_ReadBoxSkip,          MP4_FreeBox_Common, 0 },\n\n    /* Subtitles */\n    { ATOM_tx3g,    MP4_ReadBox_sample_tx3g,      MP4_FreeBox_Common, 0 },\n    //{ ATOM_text,    MP4_ReadBox_sample_text,      MP4_FreeBox_Common, 0 },\n\n    /* for codecs */\n    { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ac3,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_eac3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_lpcm,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd },\n    { ATOM_WMA2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, ATOM_stsd }, /* flip4mac */\n    /* Sound extensions */\n    { ATOM_chan,    MP4_ReadBox_stsdext_chan, MP4_FreeBox_stsdext_chan, 0 },\n    { ATOM_WMA2,    MP4_ReadBox_WMA2,         MP4_FreeBox_WMA2,        ATOM_wave }, /* flip4mac */\n\n    { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_WMV3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n\n    { ATOM_mjqt,    MP4_ReadBox_default,      NULL, 0 }, /* found in mjpa/b */\n    { ATOM_mjht,    MP4_ReadBox_default,      NULL, 0 },\n\n    { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n\n    { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n    { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, ATOM_stsd },\n\n    { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, 0 },\n    { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide, 0 },\n\n    { ATOM_strf,    MP4_ReadBox_strf,         MP4_FreeBox_strf,        ATOM_WMV3 }, /* flip4mac */\n    { ATOM_ASF ,    MP4_ReadBox_ASF,          MP4_FreeBox_Common,      ATOM_WMV3 }, /* flip4mac */\n    { ATOM_ASF ,    MP4_ReadBox_ASF,          MP4_FreeBox_Common,      ATOM_wave }, /* flip4mac */\n\n    { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common,      ATOM_stsd },\n\n    /* XXX there is 2 box where we could find this entry stbl and tref*/\n    { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common, 0 },\n\n    /* found in tref box */\n    { ATOM_dpnd,    MP4_ReadBox_default,      NULL, 0 },\n    { ATOM_ipir,    MP4_ReadBox_default,      NULL, 0 },\n    { ATOM_mpod,    MP4_ReadBox_default,      NULL, 0 },\n    { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic, 0 },\n\n    /* found in hnti */\n    { ATOM_rtp,     MP4_ReadBox_default,      NULL, 0 },\n\n    /* found in rmra/rmda */\n    { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf  , ATOM_rmda },\n    { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common, ATOM_rmda },\n    { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common, ATOM_rmda },\n    { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common, ATOM_rmda },\n\n    { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun, 0 },\n    { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common, 0 },\n    { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common, 0 },\n    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common, ATOM_sinf }, /* and rinf */\n    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common, ATOM_wave }, /* flip4mac */\n    { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common, 0 },\n\n    /* ilst meta tags */\n    { ATOM_0xa9ART, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9alb, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9cmt, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9com, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9day, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9des, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9enc, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9gen, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9grp, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9lyr, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9nam, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9too, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9trk, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_0xa9wrt, MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_aART,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_atID,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst }, /* iTunes */\n    { ATOM_cnID,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst }, /* iTunes */\n    { ATOM_covr,    MP4_ReadBoxContainer,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_disk,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_flvr,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_gnre,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_rtng,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_trkn,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n    { ATOM_xid_,    MP4_ReadBox_Metadata,     MP4_FreeBox_Common,  ATOM_ilst },\n\n    /* udta */\n    { ATOM_0x40PRM, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0x40PRQ, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9ART, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9alb, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9ard, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9arg, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9aut, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9cak, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9cmt, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9con, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9com, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9cpy, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9day, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9des, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9dir, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9dis, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9dsa, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9fmt, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9gen, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9grp, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9hst, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9inf, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9isr, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lab, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lal, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lnt, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9lyr, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9mak, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9mal, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9mod, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9nam, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9ope, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9phg, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9PRD, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9prd, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9prf, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9pub, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9req, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9sne, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9snm, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9sol, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9src, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9st3, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9swr, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9thx, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9too, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9trk, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9url, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9wrn, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9xpd, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_0xa9xyz, MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl,    ATOM_udta }, /* nero unlabeled chapters list */\n    { ATOM_MCPS,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_name,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_vndr,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n    { ATOM_SDLN,    MP4_ReadBox_String,       MP4_FreeBox_String,  ATOM_udta },\n\n    /* udta, non meta */\n    { ATOM_tsel,    MP4_ReadBox_tsel,         MP4_FreeBox_Common,  ATOM_udta },\n\n    /* iTunes/Quicktime meta info */\n    { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common,  0 },\n    { ATOM_data,    MP4_ReadBox_data,         MP4_FreeBox_data,    0 },\n\n    /* found in smoothstreaming */\n    { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common,  ATOM_moof },\n    { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common,  0 },\n    { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common,  ATOM_moof },\n    { ATOM_sidx,    MP4_ReadBox_sidx,         MP4_FreeBox_sidx,    0 },\n    { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common,  ATOM_traf },\n    { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun,    ATOM_traf },\n    { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common,  ATOM_mvex },\n    { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common,  ATOM_mvex },\n    { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp,    0 },\n    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra,    ATOM_mfra },\n    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common,  ATOM_mfra },\n    { ATOM_uuid,    MP4_ReadBox_uuid,         MP4_FreeBox_uuid,    0 },\n\n    /* Last entry */\n    { 0,              MP4_ReadBox_default,      NULL, 0 }\n};\n\n\n/*****************************************************************************\n * MP4_ReadBox : parse the actual box and the children\n *  XXX : Do not go to the next box\n *****************************************************************************/\nstatic MP4_Box_t *MP4_ReadBox( stream_t *p_stream, MP4_Box_t *p_father )\n{\n    MP4_Box_t *p_box = calloc( 1, sizeof( MP4_Box_t ) ); /* Needed to ensure simple on error handler */\n    unsigned int i_index;\n\n    if( p_box == NULL )\n        return NULL;\n\n    if( !MP4_ReadBoxCommon( p_stream, p_box ) )\n    {\n        msg_Warn( p_stream, \"cannot read one box\" );\n        free( p_box );\n        return NULL;\n    }\n    if( !p_box->i_size )\n    {\n        msg_Dbg( p_stream, \"found an empty box (null size)\" );\n        free( p_box );\n        return NULL;\n    }\n    p_box->p_father = p_father;\n\n    /* Now search function to call */\n    for( i_index = 0; ; i_index++ )\n    {\n        if ( MP4_Box_Function[i_index].i_parent &&\n             p_box->p_father &&\n             p_box->p_father->i_type != MP4_Box_Function[i_index].i_parent )\n            continue;\n\n        if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||\n            ( MP4_Box_Function[i_index].i_type == 0 ) )\n        {\n            break;\n        }\n    }\n\n    if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )\n    {\n        off_t i_end = p_box->i_pos + p_box->i_size;\n        MP4_BoxFree( p_stream, p_box );\n        stream_Seek( p_stream, i_end ); /* Skip the failed box */\n        return NULL;\n    }\n\n    p_box->pf_free = MP4_Box_Function[i_index].MP4_FreeBox_function;\n\n    return p_box;\n}\n\n/*****************************************************************************\n * MP4_FreeBox : free memory after read with MP4_ReadBox and all\n * the children\n *****************************************************************************/\nvoid MP4_BoxFree( stream_t *s, MP4_Box_t *p_box )\n{\n    MP4_Box_t    *p_child;\n\n    if( !p_box )\n        return; /* hehe */\n\n    for( p_child = p_box->p_first; p_child != NULL; )\n    {\n        MP4_Box_t *p_next;\n\n        p_next = p_child->p_next;\n        MP4_BoxFree( s, p_child );\n        p_child = p_next;\n    }\n\n    /* Now search function to call */\n    if( p_box->data.p_payload )\n    {\n        if (unlikely( p_box->pf_free == NULL ))\n        {\n            /* Should not happen */\n            if MP4_BOX_TYPE_ASCII()\n                msg_Warn( s,\n                        \"cannot free box %4.4s, type unknown\",\n                        (char*)&p_box->i_type );\n            else\n                msg_Warn( s,\n                        \"cannot free box c%3.3s, type unknown\",\n                        (char*)&p_box->i_type+1 );\n        }\n        else\n        {\n            p_box->pf_free( p_box );\n        }\n        free( p_box->data.p_payload );\n    }\n    free( p_box );\n}\n\n/* SmooBox is a very simple MP4 box, VLC specific, used only for the stream_filter to\n * send information to the demux. SmooBox is actually a simplified moov box (we wanted\n * to avoid the hassle of building a moov box at the stream_filter level) */\nMP4_Box_t *MP4_BoxGetSmooBox( stream_t *s )\n{\n    /* p_chunk is a virtual root container for the smoo box */\n    MP4_Box_t *p_chunk;\n    MP4_Box_t *p_smoo;\n\n    p_chunk = calloc( 1, sizeof( MP4_Box_t ) );\n    if( unlikely( p_chunk == NULL ) )\n        return NULL;\n\n    p_chunk->i_type = ATOM_root;\n    p_chunk->i_shortsize = 1;\n\n    p_smoo = MP4_ReadBox( s, p_chunk );\n    if( !p_smoo || p_smoo->i_type != ATOM_uuid || CmpUUID( &p_smoo->i_uuid, &SmooBoxUUID ) )\n    {\n        msg_Warn( s, \"no smoo box found!\");\n        goto error;\n    }\n\n    p_chunk->p_first = p_smoo;\n    p_chunk->p_last = p_smoo;\n\n    return p_chunk;\n\nerror:\n    free( p_chunk );\n    return NULL;\n}\n\nMP4_Box_t *MP4_BoxGetNextChunk( stream_t *s )\n{\n    /* p_chunk is a virtual root container for the moof and mdat boxes */\n    MP4_Box_t *p_chunk;\n    MP4_Box_t *p_tmp_box = NULL;\n\n    p_tmp_box = calloc( 1, sizeof( MP4_Box_t ) );\n    if( unlikely( p_tmp_box == NULL ) )\n        return NULL;\n\n    /* We might get a ftyp box or a SmooBox */\n    MP4_ReadBoxCommon( s, p_tmp_box );\n\n    if( (p_tmp_box->i_type == ATOM_uuid && !CmpUUID( &p_tmp_box->i_uuid, &SmooBoxUUID )) )\n    {\n        free( p_tmp_box );\n        return MP4_BoxGetSmooBox( s );\n    }\n    else if( p_tmp_box->i_type == ATOM_ftyp )\n    {\n        free( p_tmp_box );\n        return MP4_BoxGetRoot( s );\n    }\n    free( p_tmp_box );\n\n    p_chunk = calloc( 1, sizeof( MP4_Box_t ) );\n    if( unlikely( p_chunk == NULL ) )\n        return NULL;\n\n    p_chunk->i_type = ATOM_root;\n    p_chunk->i_shortsize = 1;\n\n    MP4_ReadBoxContainerChildren( s, p_chunk, ATOM_moof );\n\n    p_tmp_box = p_chunk->p_first;\n    while( p_tmp_box )\n    {\n        p_chunk->i_size += p_tmp_box->i_size;\n        p_tmp_box = p_tmp_box->p_next;\n    }\n\n    return p_chunk;\n}\n\n/*****************************************************************************\n * MP4_BoxGetRoot : Parse the entire file, and create all boxes in memory\n *****************************************************************************\n *  The first box is a virtual box \"root\" and is the father for all first\n *  level boxes for the file, a sort of virtual contener\n *****************************************************************************/\nMP4_Box_t *MP4_BoxGetRoot( stream_t *s )\n{\n    MP4_Box_t *p_root;\n    stream_t *p_stream;\n    int i_result;\n\n    p_root = malloc( sizeof( MP4_Box_t ) );\n    if( p_root == NULL )\n        return NULL;\n\n    p_root->i_pos = 0;\n    p_root->i_type = ATOM_root;\n    p_root->i_shortsize = 1;\n    /* could be a DASH stream for exemple, 0 means unknown or infinite size */\n    p_root->i_size = 0;\n    CreateUUID( &p_root->i_uuid, p_root->i_type );\n\n    p_root->data.p_payload = NULL;\n    p_root->p_father    = NULL;\n    p_root->p_first     = NULL;\n    p_root->p_last      = NULL;\n    p_root->p_next      = NULL;\n\n    p_stream = s;\n\n    /* First get the moov */\n    i_result = MP4_ReadBoxContainerChildren( p_stream, p_root, ATOM_moov );\n\n    if( !i_result )\n        goto error;\n    /* If there is a mvex box, it means fragmented MP4, and we're done */\n    else if( MP4_BoxCount( p_root, \"moov/mvex\" ) > 0 )\n        return p_root;\n\n    p_root->i_size = stream_Size( s );\n    if( stream_Tell( s ) + 8 < stream_Size( s ) )\n    {\n        /* Get the rest of the file */\n        i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );\n\n        if( !i_result )\n            goto error;\n    }\n\n    MP4_Box_t *p_moov;\n    MP4_Box_t *p_cmov;\n\n    /* check if there is a cmov, if so replace\n      compressed moov by  uncompressed one */\n    if( ( ( p_moov = MP4_BoxGet( p_root, \"moov\" ) ) &&\n          ( p_cmov = MP4_BoxGet( p_root, \"moov/cmov\" ) ) ) ||\n        ( ( p_moov = MP4_BoxGet( p_root, \"foov\" ) ) &&\n          ( p_cmov = MP4_BoxGet( p_root, \"foov/cmov\" ) ) ) )\n    {\n        /* rename the compressed moov as a box to skip */\n        p_moov->i_type = ATOM_skip;\n\n        /* get uncompressed p_moov */\n        p_moov = p_cmov->data.p_cmov->p_moov;\n        p_cmov->data.p_cmov->p_moov = NULL;\n\n        /* make p_root father of this new moov */\n        p_moov->p_father = p_root;\n\n        /* insert this new moov box as first child of p_root */\n        p_moov->p_next = p_root->p_first;\n        p_root->p_first = p_moov;\n    }\n\n    return p_root;\n\nerror:\n    free( p_root );\n    stream_Seek( p_stream, 0 );\n    return NULL;\n}\n\n\nstatic void MP4_BoxDumpStructure_Internal( stream_t *s,\n                                    MP4_Box_t *p_box, unsigned int i_level )\n{\n    MP4_Box_t *p_child;\n    uint32_t i_displayedtype = p_box->i_type;\n    if( ! MP4_BOX_TYPE_ASCII() ) ((char*)&i_displayedtype)[0] = 'c';\n\n    if( !i_level )\n    {\n        msg_Dbg( s, \"dumping root Box \\\"%4.4s\\\"\",\n                          (char*)&i_displayedtype );\n    }\n    else\n    {\n        char str[512];\n        if( i_level >= (sizeof(str) - 1)/4 )\n            return;\n\n        memset( str, ' ', sizeof(str) );\n        for( unsigned i = 0; i < i_level; i++ )\n        {\n            str[i*4] = '|';\n        }\n\n        snprintf( &str[i_level * 4], sizeof(str) - 4*i_level,\n                  \"+ %4.4s size %\"PRIu64\" offset %\" PRIuMAX \"%s\",\n                    (char*)&i_displayedtype, p_box->i_size,\n                  (uintmax_t)p_box->i_pos,\n                p_box->e_flags & BOX_FLAG_INCOMPLETE ? \" (\\?\\?\\?\\?)\" : \"\" );\n        msg_Dbg( s, \"%s\", str );\n    }\n    p_child = p_box->p_first;\n    while( p_child )\n    {\n        MP4_BoxDumpStructure_Internal( s, p_child, i_level + 1 );\n        p_child = p_child->p_next;\n    }\n}\n\nvoid MP4_BoxDumpStructure( stream_t *s, MP4_Box_t *p_box )\n{\n    MP4_BoxDumpStructure_Internal( s, p_box, 0 );\n}\n\n\n/*****************************************************************************\n *****************************************************************************\n **\n **  High level methods to acces an MP4 file\n **\n *****************************************************************************\n *****************************************************************************/\nstatic void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )\n{\n    size_t i_len ;\n    if( !*ppsz_path[0] )\n    {\n        *ppsz_token = NULL;\n        *pi_number = 0;\n        return;\n    }\n    i_len = strcspn( *ppsz_path, \"/[\" );\n    if( !i_len && **ppsz_path == '/' )\n    {\n        i_len = 1;\n    }\n    *ppsz_token = strndup( *ppsz_path, i_len );\n    if( unlikely(!*ppsz_token) )\n        abort();\n\n    *ppsz_path += i_len;\n\n    if( **ppsz_path == '[' )\n    {\n        (*ppsz_path)++;\n        *pi_number = strtol( *ppsz_path, NULL, 10 );\n        while( **ppsz_path && **ppsz_path != ']' )\n        {\n            (*ppsz_path)++;\n        }\n        if( **ppsz_path == ']' )\n        {\n            (*ppsz_path)++;\n        }\n    }\n    else\n    {\n        *pi_number = 0;\n    }\n    while( **ppsz_path == '/' )\n    {\n        (*ppsz_path)++;\n    }\n}\n\nstatic void MP4_BoxGet_Internal( MP4_Box_t **pp_result,\n                          MP4_Box_t *p_box, const char *psz_fmt, va_list args)\n{\n    char *psz_dup;\n    char *psz_path;\n    char *psz_token;\n\n    if( !p_box )\n    {\n        *pp_result = NULL;\n        return;\n    }\n\n    if( vasprintf( &psz_path, psz_fmt, args ) == -1 )\n        psz_path = NULL;\n\n    if( !psz_path || !psz_path[0] )\n    {\n        free( psz_path );\n        *pp_result = NULL;\n        return;\n    }\n\n//    fprintf( stderr, \"path:'%s'\\n\", psz_path );\n    psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */\n    for( ; ; )\n    {\n        int i_number;\n\n        get_token( &psz_path, &psz_token, &i_number );\n//        fprintf( stderr, \"path:'%s', token:'%s' n:%d\\n\",\n//                 psz_path,psz_token,i_number );\n        if( !psz_token )\n        {\n            free( psz_dup );\n            *pp_result = p_box;\n            return;\n        }\n        else\n        if( !strcmp( psz_token, \"/\" ) )\n        {\n            /* Find root box */\n            while( p_box && p_box->i_type != ATOM_root )\n            {\n                p_box = p_box->p_father;\n            }\n            if( !p_box )\n            {\n                goto error_box;\n            }\n        }\n        else\n        if( !strcmp( psz_token, \".\" ) )\n        {\n            /* Do nothing */\n        }\n        else\n        if( !strcmp( psz_token, \"..\" ) )\n        {\n            p_box = p_box->p_father;\n            if( !p_box )\n            {\n                goto error_box;\n            }\n        }\n        else\n        if( strlen( psz_token ) == 4 )\n        {\n            uint32_t i_fourcc;\n            i_fourcc = VLC_FOURCC( psz_token[0], psz_token[1],\n                                   psz_token[2], psz_token[3] );\n            p_box = p_box->p_first;\n            for( ; ; )\n            {\n                if( !p_box )\n                {\n                    goto error_box;\n                }\n                if( p_box->i_type == i_fourcc )\n                {\n                    if( !i_number )\n                    {\n                        break;\n                    }\n                    i_number--;\n                }\n                p_box = p_box->p_next;\n            }\n        }\n        else\n        if( *psz_token == '\\0' )\n        {\n            p_box = p_box->p_first;\n            for( ; ; )\n            {\n                if( !p_box )\n                {\n                    goto error_box;\n                }\n                if( !i_number )\n                {\n                    break;\n                }\n                i_number--;\n                p_box = p_box->p_next;\n            }\n        }\n        else\n        {\n//            fprintf( stderr, \"Argg malformed token \\\"%s\\\"\",psz_token );\n            goto error_box;\n        }\n\n        FREENULL( psz_token );\n    }\n\n    return;\n\nerror_box:\n    free( psz_token );\n    free( psz_dup );\n    *pp_result = NULL;\n    return;\n}\n\n/*****************************************************************************\n * MP4_BoxGet: find a box given a path relative to p_box\n *****************************************************************************\n * Path Format: . .. / as usual\n *              [number] to specifie box number ex: trak[12]\n *\n * ex: /moov/trak[12]\n *     ../mdia\n *****************************************************************************/\nMP4_Box_t *MP4_BoxGet( MP4_Box_t *p_box, const char *psz_fmt, ... )\n{\n    va_list args;\n    MP4_Box_t *p_result;\n\n    va_start( args, psz_fmt );\n    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );\n    va_end( args );\n\n    return( p_result );\n}\n\n/*****************************************************************************\n * MP4_BoxCount: count box given a path relative to p_box\n *****************************************************************************\n * Path Format: . .. / as usual\n *              [number] to specifie box number ex: trak[12]\n *\n * ex: /moov/trak[12]\n *     ../mdia\n *****************************************************************************/\nint MP4_BoxCount( MP4_Box_t *p_box, const char *psz_fmt, ... )\n{\n    va_list args;\n    int     i_count;\n    MP4_Box_t *p_result, *p_next;\n\n    va_start( args, psz_fmt );\n    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );\n    va_end( args );\n    if( !p_result )\n    {\n        return( 0 );\n    }\n\n    i_count = 1;\n    for( p_next = p_result->p_next; p_next != NULL; p_next = p_next->p_next)\n    {\n        if( p_next->i_type == p_result->i_type)\n        {\n            i_count++;\n        }\n    }\n    return( i_count );\n}\n"], "filenames": ["modules/demux/mp4/libmp4.c"], "buggy_code_start_loc": [2859], "buggy_code_end_loc": [2859], "fixing_code_start_loc": [2860], "fixing_code_end_loc": [2863], "type": "CWE-120", "message": "The MP4_ReadBox_String function in modules/demux/mp4/libmp4.c in VideoLAN VLC media player before 2.1.6 allows remote attackers to trigger an unintended zero-size malloc and conduct buffer overflow attacks, and consequently execute arbitrary code, via a box size of 7.", "other": {"cve": {"id": "CVE-2014-9628", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-24T22:15:12.520", "lastModified": "2020-01-29T18:09:59.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The MP4_ReadBox_String function in modules/demux/mp4/libmp4.c in VideoLAN VLC media player before 2.1.6 allows remote attackers to trigger an unintended zero-size malloc and conduct buffer overflow attacks, and consequently execute arbitrary code, via a box size of 7."}, {"lang": "es", "value": "La funci\u00f3n MP4_ReadBox_String en el archivo modules/demux/mp4/libmp4.c en el reproductor multimedia VLC de VideoLAN versiones anteriores a 2.1.6, permite a atacantes remotos desencadenar un malloc involuntario de tama\u00f1o cero y llevar a cabo ataques de desbordamiento del b\u00fafer, y en consecuencia ejecutar c\u00f3digo arbitrario, por medio de un tama\u00f1o de caja de 7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:videolan:vlc_media_player:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.6", "matchCriteriaId": "6E9B8F06-93FB-4A2B-B550-A30BD8F1C5D6"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2015/01/20/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/videolan/vlc/commit/2e7c7091a61aa5d07e7997b393d821e91f593c39", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.videolan.org/security/sa1501.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/videolan/vlc/commit/2e7c7091a61aa5d07e7997b393d821e91f593c39"}}