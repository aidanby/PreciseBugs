{"buggy_code": ["/*\n * Copyright (c) 2011-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\\file sn_coap_parser.c\n *\n * \\brief CoAP Header parser\n *\n * Functionality: Parses CoAP Header\n *\n */\n\n/* * * * * * * * * * * * * * */\n/* * * * INCLUDE FILES * * * */\n/* * * * * * * * * * * * * * */\n\n#include <stdio.h>\n#include <string.h> /* For memset() and memcpy() */\n\n#include \"ns_types.h\"\n#include \"mbed-coap/sn_coap_header.h\"\n#include \"mbed-coap/sn_coap_protocol.h\"\n#include \"sn_coap_header_internal.h\"\n#include \"sn_coap_protocol_internal.h\"\n#include \"mbed-trace/mbed_trace.h\"\n\n#define TRACE_GROUP \"coap\"\n/* * * * * * * * * * * * * * * * * * * * */\n/* * * * LOCAL FUNCTION PROTOTYPES * * * */\n/* * * * * * * * * * * * * * * * * * * * */\n\nstatic void     sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr);\nstatic int8_t   sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len);\nstatic int8_t   sn_coap_parser_options_parse_multiple_options(struct coap_s *handle, uint8_t **packet_data_pptr, uint16_t packet_left_len,  uint8_t **dst_pptr, uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len);\nstatic int16_t  sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint16_t packet_left_len, sn_coap_option_numbers_e option, uint16_t option_number_len);\nstatic int8_t   sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_start_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr);\n\nsn_coap_hdr_s *sn_coap_parser_init_message(sn_coap_hdr_s *coap_msg_ptr)\n{\n    /* * * * Check given pointer * * * */\n    if (coap_msg_ptr == NULL) {\n        tr_error(\"sn_coap_parser_init_message - message null!\");\n        return NULL;\n    }\n\n    /* XXX not technically legal to memset pointers to 0 */\n    memset(coap_msg_ptr, 0x00, sizeof(sn_coap_hdr_s));\n\n    coap_msg_ptr->content_format = COAP_CT_NONE;\n\n    return coap_msg_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser_alloc_message_with_options(struct coap_s *handle)\n{\n    // check the handle just as in any other place\n    if (handle == NULL) {\n        return NULL;\n    }\n\n    sn_coap_hdr_s *coap_msg_ptr = sn_coap_parser_alloc_message(handle);\n\n    sn_coap_options_list_s *options_list_ptr = sn_coap_parser_alloc_options(handle, coap_msg_ptr);\n\n    if ((coap_msg_ptr == NULL) || (options_list_ptr == NULL)) {\n\n        // oops, out of memory free if got already any\n        handle->sn_coap_protocol_free(coap_msg_ptr);\n        handle->sn_coap_protocol_free(options_list_ptr);\n\n        coap_msg_ptr = NULL;\n    }\n\n    return coap_msg_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser_alloc_message(struct coap_s *handle)\n{\n    sn_coap_hdr_s *returned_coap_msg_ptr;\n\n    /* * * * Check given pointer * * * */\n    if (handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Allocate memory for returned CoAP message and initialize allocated memory with with default values  * * * */\n    returned_coap_msg_ptr = handle->sn_coap_protocol_malloc(sizeof(sn_coap_hdr_s));\n\n    return sn_coap_parser_init_message(returned_coap_msg_ptr);\n}\n\nsn_coap_options_list_s *sn_coap_parser_alloc_options(struct coap_s *handle, sn_coap_hdr_s *coap_msg_ptr)\n{\n    sn_coap_options_list_s *options_list_ptr;\n\n    /* * * * Check given pointers * * * */\n    if (handle == NULL || coap_msg_ptr == NULL) {\n        return NULL;\n    }\n\n    /* * * * If the message already has options, return them * * * */\n    if (coap_msg_ptr->options_list_ptr) {\n        return coap_msg_ptr->options_list_ptr;\n    }\n\n    /* * * * Allocate memory for options and initialize allocated memory with with default values  * * * */\n    /* XXX not technically legal to memset pointers to 0 */\n    options_list_ptr = sn_coap_protocol_calloc(handle, sizeof(sn_coap_options_list_s));\n\n    if (options_list_ptr == NULL) {\n        tr_error(\"sn_coap_parser_alloc_options - failed to allocate options list!\");\n        return NULL;\n    }\n\n    coap_msg_ptr->options_list_ptr = options_list_ptr;\n\n    options_list_ptr->uri_port = COAP_OPTION_URI_PORT_NONE;\n    options_list_ptr->observe = COAP_OBSERVE_NONE;\n    options_list_ptr->accept = COAP_CT_NONE;\n    options_list_ptr->block2 = COAP_OPTION_BLOCK_NONE;\n    options_list_ptr->block1 = COAP_OPTION_BLOCK_NONE;\n\n    return options_list_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser(struct coap_s *handle, uint16_t packet_data_len, uint8_t *packet_data_ptr, coap_version_e *coap_version_ptr)\n{\n    uint8_t       *data_temp_ptr                    = packet_data_ptr;\n    sn_coap_hdr_s *parsed_and_returned_coap_msg_ptr = NULL;\n\n    /* * * * Check given pointer * * * */\n    if (packet_data_ptr == NULL || packet_data_len < 4 || handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Allocate and initialize CoAP message  * * * */\n    parsed_and_returned_coap_msg_ptr = sn_coap_parser_alloc_message(handle);\n\n    if (parsed_and_returned_coap_msg_ptr == NULL) {\n        tr_error(\"sn_coap_parser - failed to allocate message!\");\n        return NULL;\n    }\n\n    /* * * * Header parsing, move pointer over the header...  * * * */\n    sn_coap_parser_header_parse(&data_temp_ptr, parsed_and_returned_coap_msg_ptr, coap_version_ptr);\n    /* * * * Options parsing, move pointer over the options... * * * */\n    if (sn_coap_parser_options_parse(handle, &data_temp_ptr, parsed_and_returned_coap_msg_ptr, packet_data_ptr, packet_data_len) != 0) {\n        parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_ERROR_IN_HEADER;\n        return parsed_and_returned_coap_msg_ptr;\n    }\n\n    /* * * * Payload parsing * * * */\n    if (sn_coap_parser_payload_parse(packet_data_len, packet_data_ptr, &data_temp_ptr, parsed_and_returned_coap_msg_ptr) == -1) {\n        parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_ERROR_IN_HEADER;\n        return parsed_and_returned_coap_msg_ptr;\n    }\n\n    parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_OK;\n\n    /* * * * Return parsed CoAP message  * * * * */\n    return parsed_and_returned_coap_msg_ptr;\n}\n\nvoid sn_coap_parser_release_allocated_coap_msg_mem(struct coap_s *handle, sn_coap_hdr_s *freed_coap_msg_ptr)\n{\n    if (handle == NULL) {\n        return;\n    }\n\n    if (freed_coap_msg_ptr != NULL) {\n\n        // As there are multiple sequential calls to the protocol_free, caching pointer to it\n        // saves one instruction per call.\n        void (*local_free)(void *) = handle->sn_coap_protocol_free;\n\n        local_free(freed_coap_msg_ptr->uri_path_ptr);\n        local_free(freed_coap_msg_ptr->token_ptr);\n\n        // same here, caching the struct start saves a bit.\n        sn_coap_options_list_s *options_list_ptr = freed_coap_msg_ptr->options_list_ptr;\n\n        if (options_list_ptr != NULL) {\n\n            local_free(options_list_ptr->proxy_uri_ptr);\n\n            local_free(options_list_ptr->etag_ptr);\n\n            local_free(options_list_ptr->uri_host_ptr);\n\n            local_free(options_list_ptr->location_path_ptr);\n\n            local_free(options_list_ptr->location_query_ptr);\n\n            local_free(options_list_ptr->uri_query_ptr);\n\n            local_free(options_list_ptr);\n        }\n\n        local_free(freed_coap_msg_ptr);\n    }\n}\n\n/**\n * \\fn static void sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr)\n *\n * \\brief Parses CoAP message's Header part from given Packet data\n *\n * \\param **packet_data_ptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\param *coap_version_ptr is destination for parsed CoAP specification version\n */\nstatic void sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr)\n{\n    /* Parse CoAP Version and message type*/\n    *coap_version_ptr = (coap_version_e)(**packet_data_pptr & COAP_HEADER_VERSION_MASK);\n    dst_coap_msg_ptr->msg_type = (sn_coap_msg_type_e)(**packet_data_pptr & COAP_HEADER_MSG_TYPE_MASK);\n    (*packet_data_pptr) += 1;\n\n    /* Parse Message code */\n    dst_coap_msg_ptr->msg_code = (sn_coap_msg_code_e) **packet_data_pptr;\n    (*packet_data_pptr) += 1;\n\n    /* Parse Message ID */\n    dst_coap_msg_ptr->msg_id = *(*packet_data_pptr + 1);\n    dst_coap_msg_ptr->msg_id += **packet_data_pptr << COAP_HEADER_MSG_ID_MSB_SHIFT;\n    (*packet_data_pptr) += 2;\n\n}\n\n/**\n * \\brief Parses a variable-length uint value from an option\n *\n * \\param **packet_data_pptr is source of option data to be parsed\n * \\param option_len is length of option data (will be 0-4)\n *\n * \\return Return value is value of uint\n */\nstatic uint32_t sn_coap_parser_options_parse_uint(uint8_t **packet_data_pptr, uint8_t option_len)\n{\n    uint32_t value = 0;\n    while (option_len--) {\n        value <<= 8;\n        value |= *(*packet_data_pptr)++;\n    }\n    return value;\n}\n\n\n/**\n * \\brief Performs data packet pointer boundary check\n *\n * \\param packet_data_ptr           current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n * \\param delta                     the number of bytes forward to check\n *\n * \\return Return 0 if the data is within the bounds, -1 otherwise\n */\nstatic int8_t sn_coap_parser_check_packet_ptr(uint8_t *packet_data_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t delta)\n{\n    uint8_t *packet_end = packet_data_start_ptr + packet_len;\n    uint8_t *new_data_ptr = packet_data_ptr + delta;\n\n    if (delta > packet_len) {\n        return -1;\n    }\n\n    if (new_data_ptr < packet_data_start_ptr ||\n        new_data_ptr > packet_end) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * \\brief Increments data packet pointer with boundary check\n *\n * \\param packet_data_pptr          pointer to data packet current pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n * \\param delta                     the number of bytes to move *packet_data_pptr forward\n *\n * \\return Return The remaining packet data length\n */\nstatic uint16_t sn_coap_parser_move_packet_ptr(uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t delta)\n{\n    uint8_t *packet_end = packet_data_start_ptr + packet_len;\n    uint8_t *new_data_ptr = *packet_data_pptr + delta;\n\n    if (new_data_ptr < packet_data_start_ptr){\n        return 0;\n    } else if (new_data_ptr >= packet_end) {\n        *packet_data_pptr = packet_end;\n        return 0;\n    }\n\n    *packet_data_pptr = new_data_ptr;\n\n    return (uint16_t)(packet_end - new_data_ptr);\n}\n\n/**\n * \\brief Read byte from buffer with boundary check\n *\n * \\param dst                       pointer to destination variable\n * \\param packet_data_ptr           current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n *\n * \\return Return 0 if the data is within the bounds, -1 otherwise\n */\nstatic int8_t sn_coap_parser_read_packet_u8(uint8_t *dst, uint8_t *packet_data_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    int8_t ptr_check_result;\n\n    ptr_check_result = sn_coap_parser_check_packet_ptr(packet_data_ptr, packet_data_start_ptr, packet_len, 1);\n\n    if (ptr_check_result != 0) {\n        return ptr_check_result;\n    }\n\n    *dst = *packet_data_ptr;\n\n    return 0;\n}\n\n/**\n * \\brief Read unsinged 16-bit variable from buffer with boundary check.\n *\n * The read is performed in big-endian order.\n *\n * \\param dst                       pointer to destination variable\n * \\param packet_data_ptr           current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n *\n * \\return Return 0 if the data is within the bounds, -1 otherwise\n */\nstatic int8_t sn_coap_parser_read_packet_u16(uint16_t *dst, uint8_t *packet_data_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    int8_t ptr_check_result;\n    uint16_t value;\n\n    ptr_check_result = sn_coap_parser_check_packet_ptr(packet_data_ptr, packet_data_start_ptr, packet_len, 2);\n\n    if (ptr_check_result != 0) {\n        return ptr_check_result;\n    }\n\n    value = *(packet_data_ptr) << 8;\n    value |= *(packet_data_ptr + 1);\n    *dst = value;\n\n    return 0;\n}\n\n/**\n * \\brief Read extended option length or delta with buffer boundary check.\n *\n * \\param dst                       pointer to destination option delta or length variable\n * \\param packet_data_pptr          current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n * \\param message_left              pointer to variable holding remaining bytes to parse\n *\n * \\return Return 0 if the read was successful, -1 otherwise\n */\nstatic int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                /* packet_data_pptr would overflow! */\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    /* Option number 15 reserved for payload marker. This is handled as a error! */\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n\n    *dst = option_number;\n    return 0;\n}\n\n/**\n * \\fn static uint8_t sn_coap_parser_options_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n *\n * \\brief Parses CoAP message's Options part from given Packet data\n *\n * \\param **packet_data_pptr is source of Packet data to be parsed to CoAP message\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\return Return value is 0 in ok case and -1 in failure case\n */\nstatic int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    uint8_t previous_option_number = 0;\n    int8_t  ret_status             = 0;\n    uint16_t message_left          = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                                    packet_data_start_ptr,\n                                                                    packet_len,\n                                                                    0);\n\n    /*  Parse token, if exists  */\n    dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n\n    if (dst_coap_msg_ptr->token_len) {\n        int8_t ptr_check_result;\n        if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n            tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n            return -1;\n        }\n\n        ptr_check_result = sn_coap_parser_check_packet_ptr(*packet_data_pptr, packet_data_start_ptr, packet_len, dst_coap_msg_ptr->token_len);\n        if (0 != ptr_check_result) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n\n        dst_coap_msg_ptr->token_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n\n        if (dst_coap_msg_ptr->token_ptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n            return -1;\n        }\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      dst_coap_msg_ptr->token_len);\n    }\n\n    /* Loop all Options */\n    while (message_left && (**packet_data_pptr != 0xff)) {\n        /* Get option length WITHOUT extensions */\n        uint16_t option_len = (**packet_data_pptr & 0x0F);\n        /* Get option number WITHOUT extensions */\n        uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, 1);\n\n        int8_t    option_parse_result;\n        /* Add possible option delta extension */\n        option_parse_result = parse_ext_option(&option_number,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n        /* Add previous option to option delta and get option number */\n        option_number += previous_option_number;\n\n        /* Add possible option length extension to resolve full length of the option */\n        option_parse_result = parse_ext_option(&option_len,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n\n        /* * * Parse option itself * * */\n        /* Some options are handled independently in own functions */\n        previous_option_number = option_number;\n        /* Allocate options_list_ptr if needed */\n        switch (option_number) {\n            case COAP_OPTION_MAX_AGE:\n            case COAP_OPTION_PROXY_URI:\n            case COAP_OPTION_ETAG:\n            case COAP_OPTION_URI_HOST:\n            case COAP_OPTION_LOCATION_PATH:\n            case COAP_OPTION_URI_PORT:\n            case COAP_OPTION_LOCATION_QUERY:\n            case COAP_OPTION_OBSERVE:\n            case COAP_OPTION_URI_QUERY:\n            case COAP_OPTION_BLOCK2:\n            case COAP_OPTION_BLOCK1:\n            case COAP_OPTION_ACCEPT:\n            case COAP_OPTION_SIZE1:\n            case COAP_OPTION_SIZE2:\n                if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                    return -1;\n                }\n                break;\n        }\n\n        if (message_left < option_len){\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr would overflow when parsing options!\");\n            return -1;\n        }\n\n        /* Parse option */\n        switch (option_number) {\n            case COAP_OPTION_CONTENT_FORMAT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_MAX_AGE:\n                if (option_len > 4) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_PROXY_URI:\n                if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_ETAG:\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                             message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                             (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                             COAP_OPTION_ETAG, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_HOST:\n                if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_PATH:\n                if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                             COAP_OPTION_LOCATION_PATH, option_len);\n                if (ret_status <0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_PORT:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                             COAP_OPTION_LOCATION_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_URI_PATH:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                             COAP_OPTION_URI_PATH, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_OBSERVE:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_URI_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                             COAP_OPTION_URI_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_BLOCK2:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_BLOCK1:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_ACCEPT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE1:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE2:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            default:\n                tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                return -1;\n        }\n\n        /* Check for overflow */\n        if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n            return -1;\n        }\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      0);\n    }\n    return 0;\n}\n\n\n/**\n * \\fn static int8_t sn_coap_parser_options_parse_multiple_options(uint8_t **packet_data_pptr, uint8_t options_count_left, uint8_t *previous_option_number_ptr, uint8_t **dst_pptr,\n *                                                                  uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len)\n *\n * \\brief Parses CoAP message's Uri-query options\n *\n * \\param **packet_data_pptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\param options_count_left tells how many options are unhandled in Packet data\n *\n * \\param *previous_option_number_ptr is pointer to used and returned previous Option number\n *\n * \\return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\n*/\nstatic int8_t sn_coap_parser_options_parse_multiple_options(struct coap_s *handle, uint8_t **packet_data_pptr, uint16_t packet_left_len,  uint8_t **dst_pptr, uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len)\n{\n    int16_t     uri_query_needed_heap       = sn_coap_parser_options_count_needed_memory_multiple_option(*packet_data_pptr, packet_left_len, option, option_number_len);\n    uint8_t    *temp_parsed_uri_query_ptr   = NULL;\n    uint8_t     returned_option_counter     = 0;\n    uint8_t    *start_ptr = *packet_data_pptr;\n    uint16_t    message_left = packet_left_len;\n\n    if (uri_query_needed_heap == -1) {\n        return -1;\n    }\n\n    if (uri_query_needed_heap) {\n        *dst_pptr = (uint8_t *) handle->sn_coap_protocol_malloc(uri_query_needed_heap);\n\n        if (*dst_pptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse_multiple_options - failed to allocate options!\");\n            return -1;\n        }\n    }\n\n    *dst_len_ptr = uri_query_needed_heap;\n    temp_parsed_uri_query_ptr = *dst_pptr;\n\n    /* Loop all Uri-Query options */\n    while ((temp_parsed_uri_query_ptr - *dst_pptr) < uri_query_needed_heap\n           && message_left) {\n        /* Check if this is first Uri-Query option */\n        if (returned_option_counter > 0) {\n            /* Uri-Query is modified to following format: temp1'\\0'temp2'\\0'temp3 i.e.  */\n            /* Uri-Path is modified to following format: temp1\\temp2\\temp3 i.e.  */\n            if (option == COAP_OPTION_URI_QUERY || option == COAP_OPTION_LOCATION_QUERY || option == COAP_OPTION_ETAG || option == COAP_OPTION_ACCEPT) {\n                *temp_parsed_uri_query_ptr = '&';\n            } else if (option == COAP_OPTION_URI_PATH || option == COAP_OPTION_LOCATION_PATH) {\n                *temp_parsed_uri_query_ptr = '/';\n            }\n\n            temp_parsed_uri_query_ptr++;\n        }\n\n        returned_option_counter++;\n\n        if (((temp_parsed_uri_query_ptr - *dst_pptr) + option_number_len) > uri_query_needed_heap) {\n            return -1;\n        }\n\n        if (0 != sn_coap_parser_check_packet_ptr(*packet_data_pptr, start_ptr, packet_left_len, option_number_len))\n        {\n            /* Bufer read overflow. */\n            return -1;\n        }\n\n        /* Copy the option value to URI query buffer */\n        memcpy(temp_parsed_uri_query_ptr, *packet_data_pptr, option_number_len);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      option_number_len);\n        temp_parsed_uri_query_ptr += option_number_len;\n\n        /* Check if there is more input to process */\n        if ( message_left == 0 ||\n            ((**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT) != 0)) {\n            return returned_option_counter;\n        }\n\n        /* Porcess next option */\n        option_number_len = (**packet_data_pptr & 0x0F);\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, \n                                                      start_ptr, \n                                                      packet_left_len, \n                                                      1);\n\n        /* Add possible option length extension to resolve full length of the option */\n        int8_t option_parse_result = parse_ext_option(&option_number_len,\n                                                      packet_data_pptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      &message_left);\n        if (option_parse_result != 0)\n        {\n            /* Extended option parsing failed. */\n            return -1;\n        }\n    }\n\n    return returned_option_counter;\n}\n\n/**\n * \\fn static uint16_t sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint8_t options_count_left, uint8_t previous_option_number, sn_coap_option_numbers_e option, uint16_t option_number_len)\n *\n * \\brief Counts needed memory for uri query option\n *\n * \\param *packet_data_ptr is start of source for Packet data to be parsed to CoAP message\n *\n * \\param options_count_left tells how many options are unhandled in Packet data\n *\n * \\param previous_option_number is previous Option number\n *\n * \\param sn_coap_option_numbers_e option option number to be calculated\n *\n * \\param uint16_t option_number_len length of the first option part\n */\nstatic int16_t sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint16_t packet_left_len, sn_coap_option_numbers_e option, uint16_t option_number_len)\n{\n    uint16_t ret_value              = 0;\n    uint16_t message_left           = packet_left_len;\n    uint8_t *start_ptr              = packet_data_ptr;\n\n    /* Loop all Uri-Query options */\n    while (message_left > 0) {\n        if (option == COAP_OPTION_LOCATION_PATH && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_URI_PATH && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_URI_QUERY && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_LOCATION_QUERY && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_ACCEPT && option_number_len > 2) {\n            return -1;\n        }\n        if (option == COAP_OPTION_ETAG && option_number_len > 8) {\n            return -1;\n        }\n\n        /* Check if the value lenght is within buffer limits */\n        int8_t ptr_check_result = sn_coap_parser_check_packet_ptr(packet_data_ptr,\n                                                                  start_ptr,\n                                                                  packet_left_len,\n                                                                  option_number_len);\n        if (ptr_check_result != 0) {\n            return -1;\n        }\n\n        ret_value += option_number_len + 1; /* + 1 is for separator */\n\n        /* Skip the option value */\n        message_left = sn_coap_parser_move_packet_ptr(&packet_data_ptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      option_number_len);\n        if(message_left == 0) {\n            break;\n        }\n\n        /* Read the option delta */\n        if (((*packet_data_ptr) >> COAP_OPTIONS_OPTION_NUMBER_SHIFT) != 0) {\n            break;\n        }\n\n        /* Read the option length without extensions */\n        option_number_len = (*packet_data_ptr & 0x0F);\n\n        /* Skip the option byte */\n        message_left = sn_coap_parser_move_packet_ptr(&packet_data_ptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      1);\n\n        /* Add possible option length extension to resolve full length of the option */\n        int8_t option_parse_result = parse_ext_option(&option_number_len,\n                                                      &packet_data_ptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n    }\n\n    if (ret_value != 0) {\n        return (ret_value - 1);    /* -1 because last Part path does not include separator */\n    } else {\n        return 0;\n    }\n}\n\n/**\n * \\fn static void sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n *\n * \\brief Parses CoAP message's Payload part from given Packet data\n *\n * \\param packet_data_len is length of given Packet data to be parsed to CoAP message\n *\n * \\param *packet_data_ptr is start of source for Packet data to be parsed to CoAP message\n *\n * \\param **packet_data_pptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *****************************************************************************/\nstatic int8_t sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_start_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n{\n    /* If there is payload */\n    if ((*packet_data_pptr - packet_data_start_ptr) < packet_data_len) {\n        if (**packet_data_pptr == 0xff) {\n            (*packet_data_pptr)++;\n            /* Parse Payload length */\n            dst_coap_msg_ptr->payload_len = packet_data_len - (*packet_data_pptr - packet_data_start_ptr);\n\n            /* The presence of a marker followed by a zero-length payload MUST be processed as a message format error */\n            if (dst_coap_msg_ptr->payload_len == 0) {\n                return -1;\n            }\n\n            /* Parse Payload by setting CoAP message's payload_ptr to point Payload in Packet data */\n            dst_coap_msg_ptr->payload_ptr = *packet_data_pptr;\n        }\n        /* No payload marker.. */\n        else {\n            tr_error(\"sn_coap_parser_payload_parse - payload marker not found!\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 2011-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\\file sn_coap_parser.c\n *\n * \\brief CoAP Header parser\n *\n * Functionality: Parses CoAP Header\n *\n */\n\n/* * * * * * * * * * * * * * */\n/* * * * INCLUDE FILES * * * */\n/* * * * * * * * * * * * * * */\n\n#include <stdio.h>\n#include <string.h> /* For memset() and memcpy() */\n\n#include \"ns_types.h\"\n#include \"mbed-coap/sn_coap_header.h\"\n#include \"mbed-coap/sn_coap_protocol.h\"\n#include \"sn_coap_header_internal.h\"\n#include \"sn_coap_protocol_internal.h\"\n#include \"mbed-trace/mbed_trace.h\"\n\n#define TRACE_GROUP \"coap\"\n/* * * * * * * * * * * * * * * * * * * * */\n/* * * * LOCAL FUNCTION PROTOTYPES * * * */\n/* * * * * * * * * * * * * * * * * * * * */\n\nstatic void     sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr);\nstatic int8_t   sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len);\nstatic int8_t   sn_coap_parser_options_parse_multiple_options(struct coap_s *handle, uint8_t **packet_data_pptr, uint16_t packet_left_len,  uint8_t **dst_pptr, uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len);\nstatic int16_t  sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint16_t packet_left_len, sn_coap_option_numbers_e option, uint16_t option_number_len);\nstatic int8_t   sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_start_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr);\n\nsn_coap_hdr_s *sn_coap_parser_init_message(sn_coap_hdr_s *coap_msg_ptr)\n{\n    /* * * * Check given pointer * * * */\n    if (coap_msg_ptr == NULL) {\n        tr_error(\"sn_coap_parser_init_message - message null!\");\n        return NULL;\n    }\n\n    /* XXX not technically legal to memset pointers to 0 */\n    memset(coap_msg_ptr, 0x00, sizeof(sn_coap_hdr_s));\n\n    coap_msg_ptr->content_format = COAP_CT_NONE;\n\n    return coap_msg_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser_alloc_message_with_options(struct coap_s *handle)\n{\n    // check the handle just as in any other place\n    if (handle == NULL) {\n        return NULL;\n    }\n\n    sn_coap_hdr_s *coap_msg_ptr = sn_coap_parser_alloc_message(handle);\n\n    sn_coap_options_list_s *options_list_ptr = sn_coap_parser_alloc_options(handle, coap_msg_ptr);\n\n    if ((coap_msg_ptr == NULL) || (options_list_ptr == NULL)) {\n\n        // oops, out of memory free if got already any\n        handle->sn_coap_protocol_free(coap_msg_ptr);\n        handle->sn_coap_protocol_free(options_list_ptr);\n\n        coap_msg_ptr = NULL;\n    }\n\n    return coap_msg_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser_alloc_message(struct coap_s *handle)\n{\n    sn_coap_hdr_s *returned_coap_msg_ptr;\n\n    /* * * * Check given pointer * * * */\n    if (handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Allocate memory for returned CoAP message and initialize allocated memory with with default values  * * * */\n    returned_coap_msg_ptr = handle->sn_coap_protocol_malloc(sizeof(sn_coap_hdr_s));\n\n    return sn_coap_parser_init_message(returned_coap_msg_ptr);\n}\n\nsn_coap_options_list_s *sn_coap_parser_alloc_options(struct coap_s *handle, sn_coap_hdr_s *coap_msg_ptr)\n{\n    sn_coap_options_list_s *options_list_ptr;\n\n    /* * * * Check given pointers * * * */\n    if (handle == NULL || coap_msg_ptr == NULL) {\n        return NULL;\n    }\n\n    /* * * * If the message already has options, return them * * * */\n    if (coap_msg_ptr->options_list_ptr) {\n        return coap_msg_ptr->options_list_ptr;\n    }\n\n    /* * * * Allocate memory for options and initialize allocated memory with with default values  * * * */\n    /* XXX not technically legal to memset pointers to 0 */\n    options_list_ptr = sn_coap_protocol_calloc(handle, sizeof(sn_coap_options_list_s));\n\n    if (options_list_ptr == NULL) {\n        tr_error(\"sn_coap_parser_alloc_options - failed to allocate options list!\");\n        return NULL;\n    }\n\n    coap_msg_ptr->options_list_ptr = options_list_ptr;\n\n    options_list_ptr->uri_port = COAP_OPTION_URI_PORT_NONE;\n    options_list_ptr->observe = COAP_OBSERVE_NONE;\n    options_list_ptr->accept = COAP_CT_NONE;\n    options_list_ptr->block2 = COAP_OPTION_BLOCK_NONE;\n    options_list_ptr->block1 = COAP_OPTION_BLOCK_NONE;\n\n    return options_list_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser(struct coap_s *handle, uint16_t packet_data_len, uint8_t *packet_data_ptr, coap_version_e *coap_version_ptr)\n{\n    uint8_t       *data_temp_ptr                    = packet_data_ptr;\n    sn_coap_hdr_s *parsed_and_returned_coap_msg_ptr = NULL;\n\n    /* * * * Check given pointer * * * */\n    if (packet_data_ptr == NULL || packet_data_len < 4 || handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Allocate and initialize CoAP message  * * * */\n    parsed_and_returned_coap_msg_ptr = sn_coap_parser_alloc_message(handle);\n\n    if (parsed_and_returned_coap_msg_ptr == NULL) {\n        tr_error(\"sn_coap_parser - failed to allocate message!\");\n        return NULL;\n    }\n\n    /* * * * Header parsing, move pointer over the header...  * * * */\n    sn_coap_parser_header_parse(&data_temp_ptr, parsed_and_returned_coap_msg_ptr, coap_version_ptr);\n    /* * * * Options parsing, move pointer over the options... * * * */\n    if (sn_coap_parser_options_parse(handle, &data_temp_ptr, parsed_and_returned_coap_msg_ptr, packet_data_ptr, packet_data_len) != 0) {\n        parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_ERROR_IN_HEADER;\n        return parsed_and_returned_coap_msg_ptr;\n    }\n\n    /* * * * Payload parsing * * * */\n    if (sn_coap_parser_payload_parse(packet_data_len, packet_data_ptr, &data_temp_ptr, parsed_and_returned_coap_msg_ptr) == -1) {\n        parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_ERROR_IN_HEADER;\n        return parsed_and_returned_coap_msg_ptr;\n    }\n\n    parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_OK;\n\n    /* * * * Return parsed CoAP message  * * * * */\n    return parsed_and_returned_coap_msg_ptr;\n}\n\nvoid sn_coap_parser_release_allocated_coap_msg_mem(struct coap_s *handle, sn_coap_hdr_s *freed_coap_msg_ptr)\n{\n    if (handle == NULL) {\n        return;\n    }\n\n    if (freed_coap_msg_ptr != NULL) {\n\n        // As there are multiple sequential calls to the protocol_free, caching pointer to it\n        // saves one instruction per call.\n        void (*local_free)(void *) = handle->sn_coap_protocol_free;\n\n        local_free(freed_coap_msg_ptr->uri_path_ptr);\n        local_free(freed_coap_msg_ptr->token_ptr);\n\n        // same here, caching the struct start saves a bit.\n        sn_coap_options_list_s *options_list_ptr = freed_coap_msg_ptr->options_list_ptr;\n\n        if (options_list_ptr != NULL) {\n\n            local_free(options_list_ptr->proxy_uri_ptr);\n\n            local_free(options_list_ptr->etag_ptr);\n\n            local_free(options_list_ptr->uri_host_ptr);\n\n            local_free(options_list_ptr->location_path_ptr);\n\n            local_free(options_list_ptr->location_query_ptr);\n\n            local_free(options_list_ptr->uri_query_ptr);\n\n            local_free(options_list_ptr);\n        }\n\n        local_free(freed_coap_msg_ptr);\n    }\n}\n\n/**\n * \\fn static void sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr)\n *\n * \\brief Parses CoAP message's Header part from given Packet data\n *\n * \\param **packet_data_ptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\param *coap_version_ptr is destination for parsed CoAP specification version\n */\nstatic void sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr)\n{\n    /* Parse CoAP Version and message type*/\n    *coap_version_ptr = (coap_version_e)(**packet_data_pptr & COAP_HEADER_VERSION_MASK);\n    dst_coap_msg_ptr->msg_type = (sn_coap_msg_type_e)(**packet_data_pptr & COAP_HEADER_MSG_TYPE_MASK);\n    (*packet_data_pptr) += 1;\n\n    /* Parse Message code */\n    dst_coap_msg_ptr->msg_code = (sn_coap_msg_code_e) **packet_data_pptr;\n    (*packet_data_pptr) += 1;\n\n    /* Parse Message ID */\n    dst_coap_msg_ptr->msg_id = *(*packet_data_pptr + 1);\n    dst_coap_msg_ptr->msg_id += **packet_data_pptr << COAP_HEADER_MSG_ID_MSB_SHIFT;\n    (*packet_data_pptr) += 2;\n\n}\n\n/**\n * \\brief Parses a variable-length uint value from an option\n *\n * \\param **packet_data_pptr is source of option data to be parsed\n * \\param option_len is length of option data (will be 0-4)\n *\n * \\return Return value is value of uint\n */\nstatic uint32_t sn_coap_parser_options_parse_uint(uint8_t **packet_data_pptr, uint8_t option_len)\n{\n    uint32_t value = 0;\n    while (option_len--) {\n        value <<= 8;\n        value |= *(*packet_data_pptr)++;\n    }\n    return value;\n}\n\n/**\n * \\brief Add u16 integers with overflow detection\n *\n * \\param a            first term of addition\n * \\param b            second term of addion\n * \\param result       pointer to the result variable\n *\n * \\return Return 0 if there was no overflow, -1 otherwise\n */\nstatic int8_t sn_coap_parser_add_u16_limit(uint16_t a, uint16_t b, uint16_t *result)\n{\n    uint16_t c;\n\n    c = a + b;\n    if (c < a || c < b)\n    {\n        return -1;\n    }\n\n    *result = c;\n\n    return 0;\n}\n\n/**\n * \\brief Performs data packet pointer boundary check\n *\n * \\param packet_data_ptr           current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n * \\param delta                     the number of bytes forward to check\n *\n * \\return Return 0 if the data is within the bounds, -1 otherwise\n */\nstatic int8_t sn_coap_parser_check_packet_ptr(uint8_t *packet_data_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t delta)\n{\n    uint8_t *packet_end = packet_data_start_ptr + packet_len;\n    uint8_t *new_data_ptr = packet_data_ptr + delta;\n\n    if (delta > packet_len) {\n        return -1;\n    }\n\n    if (new_data_ptr < packet_data_start_ptr ||\n        new_data_ptr > packet_end) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * \\brief Increments data packet pointer with boundary check\n *\n * \\param packet_data_pptr          pointer to data packet current pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n * \\param delta                     the number of bytes to move *packet_data_pptr forward\n *\n * \\return Return The remaining packet data length\n */\nstatic uint16_t sn_coap_parser_move_packet_ptr(uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t delta)\n{\n    uint8_t *packet_end = packet_data_start_ptr + packet_len;\n    uint8_t *new_data_ptr = *packet_data_pptr + delta;\n\n    if (new_data_ptr < packet_data_start_ptr){\n        return 0;\n    } else if (new_data_ptr >= packet_end) {\n        *packet_data_pptr = packet_end;\n        return 0;\n    }\n\n    *packet_data_pptr = new_data_ptr;\n\n    return (uint16_t)(packet_end - new_data_ptr);\n}\n\n/**\n * \\brief Read byte from buffer with boundary check\n *\n * \\param dst                       pointer to destination variable\n * \\param packet_data_ptr           current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n *\n * \\return Return 0 if the data is within the bounds, -1 otherwise\n */\nstatic int8_t sn_coap_parser_read_packet_u8(uint8_t *dst, uint8_t *packet_data_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    int8_t ptr_check_result;\n\n    ptr_check_result = sn_coap_parser_check_packet_ptr(packet_data_ptr, packet_data_start_ptr, packet_len, 1);\n\n    if (ptr_check_result != 0) {\n        return ptr_check_result;\n    }\n\n    *dst = *packet_data_ptr;\n\n    return 0;\n}\n\n/**\n * \\brief Read unsinged 16-bit variable from buffer with boundary check.\n *\n * The read is performed in big-endian order.\n *\n * \\param dst                       pointer to destination variable\n * \\param packet_data_ptr           current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n *\n * \\return Return 0 if the data is within the bounds, -1 otherwise\n */\nstatic int8_t sn_coap_parser_read_packet_u16(uint16_t *dst, uint8_t *packet_data_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    int8_t ptr_check_result;\n    uint16_t value;\n\n    ptr_check_result = sn_coap_parser_check_packet_ptr(packet_data_ptr, packet_data_start_ptr, packet_len, 2);\n\n    if (ptr_check_result != 0) {\n        return ptr_check_result;\n    }\n\n    value = *(packet_data_ptr) << 8;\n    value |= *(packet_data_ptr + 1);\n    *dst = value;\n\n    return 0;\n}\n\n/**\n * \\brief Read extended option length or delta with buffer boundary check.\n *\n * \\param dst                       pointer to destination option delta or length variable\n * \\param packet_data_pptr          current data packet read pointer\n * \\param packet_data_start_ptr     pointer to data packet start\n * \\param packet_len                total packet length\n * \\param message_left              pointer to variable holding remaining bytes to parse\n *\n * \\return Return 0 if the read was successful, -1 otherwise\n */\nstatic int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n            if(sn_coap_parser_add_u16_limit(option_number, option_ext, &option_number) != 0)\n            {\n                return -1;\n            }\n\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len,\n                                                            1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                /* packet_data_pptr would overflow! */\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n                if(sn_coap_parser_add_u16_limit(option_number, 269, &option_number) != 0)\n                {\n                    return -1;\n                }\n\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len,\n                                                            2);\n            }\n    }\n    /* Option number 15 reserved for payload marker. This is handled as a error! */\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n\n    *dst = option_number;\n    return 0;\n}\n\n/**\n * \\fn static uint8_t sn_coap_parser_options_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n *\n * \\brief Parses CoAP message's Options part from given Packet data\n *\n * \\param **packet_data_pptr is source of Packet data to be parsed to CoAP message\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\return Return value is 0 in ok case and -1 in failure case\n */\nstatic int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    uint8_t previous_option_number = 0;\n    int8_t  ret_status             = 0;\n    uint16_t message_left          = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                                    packet_data_start_ptr,\n                                                                    packet_len,\n                                                                    0);\n\n    /*  Parse token, if exists  */\n    dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n\n    if (dst_coap_msg_ptr->token_len) {\n        int8_t ptr_check_result;\n        if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n            tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n            return -1;\n        }\n\n        ptr_check_result = sn_coap_parser_check_packet_ptr(*packet_data_pptr, packet_data_start_ptr, packet_len, dst_coap_msg_ptr->token_len);\n        if (0 != ptr_check_result) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n\n        dst_coap_msg_ptr->token_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n\n        if (dst_coap_msg_ptr->token_ptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n            return -1;\n        }\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      dst_coap_msg_ptr->token_len);\n    }\n\n    /* Loop all Options */\n    while (message_left && (**packet_data_pptr != 0xff)) {\n        /* Get option length WITHOUT extensions */\n        uint16_t option_len = (**packet_data_pptr & 0x0F);\n        /* Get option number WITHOUT extensions */\n        uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, 1);\n\n        int8_t    option_parse_result;\n        /* Add possible option delta extension */\n        option_parse_result = parse_ext_option(&option_number,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n        /* Add previous option to option delta and get option number */\n        if(sn_coap_parser_add_u16_limit(option_number, previous_option_number, &option_number) != 0)\n        {\n            return -1;\n        }\n\n        /* Add possible option length extension to resolve full length of the option */\n        option_parse_result = parse_ext_option(&option_len,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n\n        /* * * Parse option itself * * */\n        /* Some options are handled independently in own functions */\n        previous_option_number = option_number;\n        /* Allocate options_list_ptr if needed */\n        switch (option_number) {\n            case COAP_OPTION_MAX_AGE:\n            case COAP_OPTION_PROXY_URI:\n            case COAP_OPTION_ETAG:\n            case COAP_OPTION_URI_HOST:\n            case COAP_OPTION_LOCATION_PATH:\n            case COAP_OPTION_URI_PORT:\n            case COAP_OPTION_LOCATION_QUERY:\n            case COAP_OPTION_OBSERVE:\n            case COAP_OPTION_URI_QUERY:\n            case COAP_OPTION_BLOCK2:\n            case COAP_OPTION_BLOCK1:\n            case COAP_OPTION_ACCEPT:\n            case COAP_OPTION_SIZE1:\n            case COAP_OPTION_SIZE2:\n                if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                    return -1;\n                }\n                break;\n        }\n\n        if (message_left < option_len){\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr would overflow when parsing options!\");\n            return -1;\n        }\n\n        /* Parse option */\n        switch (option_number) {\n            case COAP_OPTION_CONTENT_FORMAT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_MAX_AGE:\n                if (option_len > 4) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_PROXY_URI:\n                if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_ETAG:\n                if (dst_coap_msg_ptr->options_list_ptr->etag_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                             message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                             (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                             COAP_OPTION_ETAG, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_HOST:\n                if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_PATH:\n                if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                             COAP_OPTION_LOCATION_PATH, option_len);\n                if (ret_status <0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_PORT:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_QUERY:\n                if (dst_coap_msg_ptr->options_list_ptr->location_query_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY exists!\");\n                    return -1;\n                }\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                             COAP_OPTION_LOCATION_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_URI_PATH:\n                if (dst_coap_msg_ptr->uri_path_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH exists!\");\n                    return -1;\n                }\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                             COAP_OPTION_URI_PATH, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_OBSERVE:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_URI_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                             COAP_OPTION_URI_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_BLOCK2:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_BLOCK1:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_ACCEPT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE1:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE2:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            default:\n                tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                return -1;\n        }\n\n        /* Check for overflow */\n        if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n            return -1;\n        }\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      0);\n    }\n    return 0;\n}\n\n\n/**\n * \\fn static int8_t sn_coap_parser_options_parse_multiple_options(uint8_t **packet_data_pptr, uint8_t options_count_left, uint8_t *previous_option_number_ptr, uint8_t **dst_pptr,\n *                                                                  uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len)\n *\n * \\brief Parses CoAP message's Uri-query options\n *\n * \\param **packet_data_pptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\param options_count_left tells how many options are unhandled in Packet data\n *\n * \\param *previous_option_number_ptr is pointer to used and returned previous Option number\n *\n * \\return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\n*/\nstatic int8_t sn_coap_parser_options_parse_multiple_options(struct coap_s *handle, uint8_t **packet_data_pptr, uint16_t packet_left_len,  uint8_t **dst_pptr, uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len)\n{\n    int16_t     uri_query_needed_heap       = sn_coap_parser_options_count_needed_memory_multiple_option(*packet_data_pptr, packet_left_len, option, option_number_len);\n    uint8_t    *temp_parsed_uri_query_ptr   = NULL;\n    uint8_t     returned_option_counter     = 0;\n    uint8_t    *start_ptr = *packet_data_pptr;\n    uint16_t    message_left = packet_left_len;\n\n    if (uri_query_needed_heap == -1) {\n        return -1;\n    }\n\n    if (uri_query_needed_heap) {\n        *dst_pptr = (uint8_t *) handle->sn_coap_protocol_malloc(uri_query_needed_heap);\n\n        if (*dst_pptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse_multiple_options - failed to allocate options!\");\n            return -1;\n        }\n    }\n\n    *dst_len_ptr = uri_query_needed_heap;\n    temp_parsed_uri_query_ptr = *dst_pptr;\n\n    /* Loop all Uri-Query options */\n    while ((temp_parsed_uri_query_ptr - *dst_pptr) < uri_query_needed_heap\n           && message_left) {\n        /* Check if this is first Uri-Query option */\n        if (returned_option_counter > 0) {\n            /* Uri-Query is modified to following format: temp1'\\0'temp2'\\0'temp3 i.e.  */\n            /* Uri-Path is modified to following format: temp1\\temp2\\temp3 i.e.  */\n            if (option == COAP_OPTION_URI_QUERY || option == COAP_OPTION_LOCATION_QUERY || option == COAP_OPTION_ETAG || option == COAP_OPTION_ACCEPT) {\n                *temp_parsed_uri_query_ptr = '&';\n            } else if (option == COAP_OPTION_URI_PATH || option == COAP_OPTION_LOCATION_PATH) {\n                *temp_parsed_uri_query_ptr = '/';\n            }\n\n            temp_parsed_uri_query_ptr++;\n        }\n\n        returned_option_counter++;\n\n        if (((temp_parsed_uri_query_ptr - *dst_pptr) + option_number_len) > uri_query_needed_heap) {\n            return -1;\n        }\n\n        if (0 != sn_coap_parser_check_packet_ptr(*packet_data_pptr, start_ptr, packet_left_len, option_number_len))\n        {\n            /* Bufer read overflow. */\n            return -1;\n        }\n\n        /* Copy the option value to URI query buffer */\n        memcpy(temp_parsed_uri_query_ptr, *packet_data_pptr, option_number_len);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      option_number_len);\n        temp_parsed_uri_query_ptr += option_number_len;\n\n        /* Check if there is more input to process */\n        if ( message_left == 0 ||\n            ((**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT) != 0)) {\n            return returned_option_counter;\n        }\n\n        /* Porcess next option */\n        option_number_len = (**packet_data_pptr & 0x0F);\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, \n                                                      start_ptr, \n                                                      packet_left_len, \n                                                      1);\n\n        /* Add possible option length extension to resolve full length of the option */\n        int8_t option_parse_result = parse_ext_option(&option_number_len,\n                                                      packet_data_pptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      &message_left);\n        if (option_parse_result != 0)\n        {\n            /* Extended option parsing failed. */\n            return -1;\n        }\n    }\n\n    return returned_option_counter;\n}\n\n/**\n * \\fn static uint16_t sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint8_t options_count_left, uint8_t previous_option_number, sn_coap_option_numbers_e option, uint16_t option_number_len)\n *\n * \\brief Counts needed memory for uri query option\n *\n * \\param *packet_data_ptr is start of source for Packet data to be parsed to CoAP message\n *\n * \\param options_count_left tells how many options are unhandled in Packet data\n *\n * \\param previous_option_number is previous Option number\n *\n * \\param sn_coap_option_numbers_e option option number to be calculated\n *\n * \\param uint16_t option_number_len length of the first option part\n */\nstatic int16_t sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint16_t packet_left_len, sn_coap_option_numbers_e option, uint16_t option_number_len)\n{\n    uint16_t ret_value              = 0;\n    uint16_t message_left           = packet_left_len;\n    uint8_t *start_ptr              = packet_data_ptr;\n\n    /* Loop all Uri-Query options */\n    while (message_left > 0) {\n        if (option == COAP_OPTION_LOCATION_PATH && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_URI_PATH && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_URI_QUERY && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_LOCATION_QUERY && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_ACCEPT && option_number_len > 2) {\n            return -1;\n        }\n        if (option == COAP_OPTION_ETAG && option_number_len > 8) {\n            return -1;\n        }\n\n        /* Check if the value lenght is within buffer limits */\n        int8_t ptr_check_result = sn_coap_parser_check_packet_ptr(packet_data_ptr,\n                                                                  start_ptr,\n                                                                  packet_left_len,\n                                                                  option_number_len);\n        if (ptr_check_result != 0) {\n            return -1;\n        }\n\n        ret_value += option_number_len + 1; /* + 1 is for separator */\n\n        /* Skip the option value */\n        message_left = sn_coap_parser_move_packet_ptr(&packet_data_ptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      option_number_len);\n        if(message_left == 0) {\n            break;\n        }\n\n        /* Read the option delta */\n        if (((*packet_data_ptr) >> COAP_OPTIONS_OPTION_NUMBER_SHIFT) != 0) {\n            break;\n        }\n\n        /* Read the option length without extensions */\n        option_number_len = (*packet_data_ptr & 0x0F);\n\n        /* Skip the option byte */\n        message_left = sn_coap_parser_move_packet_ptr(&packet_data_ptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      1);\n\n        /* Add possible option length extension to resolve full length of the option */\n        int8_t option_parse_result = parse_ext_option(&option_number_len,\n                                                      &packet_data_ptr,\n                                                      start_ptr,\n                                                      packet_left_len,\n                                                      &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n    }\n\n    if (ret_value != 0) {\n        return (ret_value - 1);    /* -1 because last Part path does not include separator */\n    } else {\n        return 0;\n    }\n}\n\n/**\n * \\fn static void sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n *\n * \\brief Parses CoAP message's Payload part from given Packet data\n *\n * \\param packet_data_len is length of given Packet data to be parsed to CoAP message\n *\n * \\param *packet_data_ptr is start of source for Packet data to be parsed to CoAP message\n *\n * \\param **packet_data_pptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *****************************************************************************/\nstatic int8_t sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_start_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n{\n    /* If there is payload */\n    if ((*packet_data_pptr - packet_data_start_ptr) < packet_data_len) {\n        if (**packet_data_pptr == 0xff) {\n            (*packet_data_pptr)++;\n            /* Parse Payload length */\n            dst_coap_msg_ptr->payload_len = packet_data_len - (*packet_data_pptr - packet_data_start_ptr);\n\n            /* The presence of a marker followed by a zero-length payload MUST be processed as a message format error */\n            if (dst_coap_msg_ptr->payload_len == 0) {\n                return -1;\n            }\n\n            /* Parse Payload by setting CoAP message's payload_ptr to point Payload in Packet data */\n            dst_coap_msg_ptr->payload_ptr = *packet_data_pptr;\n        }\n        /* No payload marker.. */\n        else {\n            tr_error(\"sn_coap_parser_payload_parse - payload marker not found!\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n"], "filenames": ["source/sn_coap_parser.c"], "buggy_code_start_loc": [262], "buggy_code_end_loc": [641], "fixing_code_start_loc": [263], "fixing_code_end_loc": [691], "type": "CWE-190", "message": "Memory leaks were discovered in the CoAP library in Arm Mbed OS 5.15.3 when using the Arm mbed-coap library 5.1.5. The CoAP parser is responsible for parsing received CoAP packets. The function sn_coap_parser_options_parse() parses the CoAP option number field of all options present in the input packet. Each option number is calculated as a sum of the previous option number and a delta of the current option. The delta and the previous option number are expressed as unsigned 16-bit integers. Due to lack of overflow detection, it is possible to craft a packet that wraps the option number around and results in the same option number being processed again in a single packet. Certain options allocate memory by calling a memory allocation function. In the cases of COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY, and COAP_OPTION_ETAG, there is no check on whether memory has already been allocated, which in conjunction with the option number integer overflow may lead to multiple assignments of allocated memory to a single pointer. This has been demonstrated to lead to memory leak by buffer orphaning. As a result, the memory is never freed.", "other": {"cve": {"id": "CVE-2020-12887", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-18T19:15:11.783", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory leaks were discovered in the CoAP library in Arm Mbed OS 5.15.3 when using the Arm mbed-coap library 5.1.5. The CoAP parser is responsible for parsing received CoAP packets. The function sn_coap_parser_options_parse() parses the CoAP option number field of all options present in the input packet. Each option number is calculated as a sum of the previous option number and a delta of the current option. The delta and the previous option number are expressed as unsigned 16-bit integers. Due to lack of overflow detection, it is possible to craft a packet that wraps the option number around and results in the same option number being processed again in a single packet. Certain options allocate memory by calling a memory allocation function. In the cases of COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY, and COAP_OPTION_ETAG, there is no check on whether memory has already been allocated, which in conjunction with the option number integer overflow may lead to multiple assignments of allocated memory to a single pointer. This has been demonstrated to lead to memory leak by buffer orphaning. As a result, the memory is never freed."}, {"lang": "es", "value": "Se detectaron p\u00e9rdidas de la memoria en la biblioteca CoAP en Arm Mbed OS versi\u00f3n 5.15.3 cuando se usa la biblioteca Arm mbed-coap versi\u00f3n 5.1.5. El analizador CoAP es responsable de analizar los paquetes CoAP recibidos. La funci\u00f3n sn_coap_parser_options_parse() analiza el campo CoAP option number de todas las opciones presentes en el paquete de entrada. Cada n\u00famero de opci\u00f3n es calculado como una suma del n\u00famero de opci\u00f3n previo y un delta de la opci\u00f3n actual. El delta y el n\u00famero de opci\u00f3n anterior son expresados como enteros de 16 bits sin signo. Debido a la falta de detecci\u00f3n de desbordamiento, es posible crear un paquete que contenga el n\u00famero de opci\u00f3n y resulte en que el mismo n\u00famero de opci\u00f3n sea procesado nuevamente en un solo paquete. Determinadas opciones asignan memoria llamando a una funci\u00f3n de asignaci\u00f3n de memoria. En los casos de COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY y COAP_OPTION_ETAG, no se comprueba si ya se ha asignado memoria, lo que en conjunto con el desbordamiento de enteros del n\u00famero de opci\u00f3n puede conllevar a m\u00faltiples asignaciones de memoria asignada a un \u00fanico puntero. Se ha demostrado que esto conlleva a una p\u00e9rdida de memoria mediante un hu\u00e9rfano de b\u00fafer. Como resultado, la memoria nunca es liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed-coap:5.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "514FAB1A-AD34-4295-BD7B-E417F85F16FD"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:arm:mbed_os:5.15.3:*:*:*:*:*:*:*", "matchCriteriaId": "B314FCEF-12B7-4510-AC5E-12D3574E3E68"}]}]}], "references": [{"url": "https://github.com/ARMmbed/mbed-coap/pull/116", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ARMmbed/mbed-os/issues/12930", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ARMmbed/mbed-os/issues/12957", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93"}}