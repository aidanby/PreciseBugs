{"buggy_code": ["/* Task credentials management - see Documentation/security/credentials.txt\n *\n * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n#include <linux/export.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/init_task.h>\n#include <linux/security.h>\n#include <linux/binfmts.h>\n#include <linux/cn_proc.h>\n\n#if 0\n#define kdebug(FMT, ...) \\\n\tprintk(\"[%-5.5s%5u] \"FMT\"\\n\", current->comm, current->pid ,##__VA_ARGS__)\n#else\n#define kdebug(FMT, ...) \\\n\tno_printk(\"[%-5.5s%5u] \"FMT\"\\n\", current->comm, current->pid ,##__VA_ARGS__)\n#endif\n\nstatic struct kmem_cache *cred_jar;\n\n/*\n * The common credentials for the initial task's thread group\n */\n#ifdef CONFIG_KEYS\nstatic struct thread_group_cred init_tgcred = {\n\t.usage\t= ATOMIC_INIT(2),\n\t.tgid\t= 0,\n\t.lock\t= __SPIN_LOCK_UNLOCKED(init_cred.tgcred.lock),\n};\n#endif\n\n/*\n * The initial credentials for the initial task\n */\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n#ifdef CONFIG_KEYS\n\t.tgcred\t\t\t= &init_tgcred,\n#endif\n};\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}\n\n/*\n * Dispose of the shared task group credentials\n */\n#ifdef CONFIG_KEYS\nstatic void release_tgcred_rcu(struct rcu_head *rcu)\n{\n\tstruct thread_group_cred *tgcred =\n\t\tcontainer_of(rcu, struct thread_group_cred, rcu);\n\n\tBUG_ON(atomic_read(&tgcred->usage) != 0);\n\n\tkey_put(tgcred->session_keyring);\n\tkey_put(tgcred->process_keyring);\n\tkfree(tgcred);\n}\n#endif\n\n/*\n * Release a set of thread group credentials.\n */\nstatic void release_tgcred(struct cred *cred)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred = cred->tgcred;\n\n\tif (atomic_dec_and_test(&tgcred->usage))\n\t\tcall_rcu(&tgcred->rcu, release_tgcred_rcu);\n#endif\n}\n\n/*\n * The RCU callback to actually dispose of a set of credentials\n */\nstatic void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\trelease_tgcred(cred);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tkmem_cache_free(cred_jar, cred);\n}\n\n/**\n * __put_cred - Destroy a set of credentials\n * @cred: The record to release\n *\n * Destroy a set of credentials on which no references remain.\n */\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}\nEXPORT_SYMBOL(__put_cred);\n\n/*\n * Clean up a task's credentials when it exits\n */\nvoid exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->replacement_session_keyring;\n\tif (cred) {\n\t\ttsk->replacement_session_keyring = NULL;\n\t\tvalidate_creds(cred);\n\t\tput_cred(cred);\n\t}\n}\n\n/**\n * get_task_cred - Get another task's objective credentials\n * @task: The task to query\n *\n * Get the objective credentials of a task, pinning them so that they can't go\n * away.  Accessing a task's credentials directly is not permitted.\n *\n * The caller must also make sure task doesn't get deleted, either by holding a\n * ref on task or by holding tasklist_lock to prevent it from being unlinked.\n */\nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\n\n\trcu_read_unlock();\n\treturn cred;\n}\n\n/*\n * Allocate blank credentials, such that the credentials can be filled in at a\n * later date without risk of ENOMEM.\n */\nstruct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n#ifdef CONFIG_KEYS\n\tnew->tgcred = kzalloc(sizeof(*new->tgcred), GFP_KERNEL);\n\tif (!new->tgcred) {\n\t\tkmem_cache_free(cred_jar, new);\n\t\treturn NULL;\n\t}\n\tatomic_set(&new->tgcred->usage, 1);\n#endif\n\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\n\tif (security_cred_alloc_blank(new, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}\n\n/**\n * prepare_creds - Prepare a new set of credentials for modification\n *\n * Prepare a new set of task credentials for modification.  A task's creds\n * shouldn't generally be modified directly, therefore this function is used to\n * prepare a new copy, which the caller then modifies and then commits by\n * calling commit_creds().\n *\n * Preparation involves making a copy of the objective creds for modification.\n *\n * Returns a pointer to the new creds-to-be if successful, NULL otherwise.\n *\n * Call commit_creds() or abort_creds() to clean up.\n */\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n\tatomic_inc(&new->tgcred->usage);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}\nEXPORT_SYMBOL(prepare_creds);\n\n/*\n * Prepare credentials for current to perform an execve()\n * - The caller must hold ->cred_guard_mutex\n */\nstruct cred *prepare_exec_creds(void)\n{\n\tstruct thread_group_cred *tgcred = NULL;\n\tstruct cred *new;\n\n#ifdef CONFIG_KEYS\n\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\tif (!tgcred)\n\t\treturn NULL;\n#endif\n\n\tnew = prepare_creds();\n\tif (!new) {\n\t\tkfree(tgcred);\n\t\treturn new;\n\t}\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* create a new per-thread-group creds for all this set of threads to\n\t * share */\n\tmemcpy(tgcred, new->tgcred, sizeof(struct thread_group_cred));\n\n\tatomic_set(&tgcred->usage, 1);\n\tspin_lock_init(&tgcred->lock);\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_get(tgcred->session_keyring);\n\ttgcred->process_keyring = NULL;\n\n\trelease_tgcred(new);\n\tnew->tgcred = tgcred;\n#endif\n\n\treturn new;\n}\n\n/*\n * Copy credentials for the new process created by fork()\n *\n * We share if we can, but under some circumstances we have to generate a new\n * set.\n *\n * The new process gets the current process's subjective credentials as its\n * objective and subjective credentials\n */\nint copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n\n/**\n * commit_creds - Install new credentials upon the current task\n * @new: The credentials to be assigned\n *\n * Install a new set of credentials to the current task, using RCU to replace\n * the old set.  Both the objective and the subjective credentials pointers are\n * updated.  This function may not be called if the subjective credentials are\n * in an overridden state.\n *\n * This function eats the caller's reference to the new credentials.\n *\n * Always returns 0 thus allowing this function to be tail-called at the end\n * of, say, sys_setgid().\n */\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (old->euid != new->euid ||\n\t    old->egid != new->egid ||\n\t    old->fsuid != new->fsuid ||\n\t    old->fsgid != new->fsgid ||\n\t    !cap_issubset(new->cap_permitted, old->cap_permitted)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (new->fsuid != old->fsuid)\n\t\tkey_fsuid_changed(task);\n\tif (new->fsgid != old->fsgid)\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (new->uid   != old->uid  ||\n\t    new->euid  != old->euid ||\n\t    new->suid  != old->suid ||\n\t    new->fsuid != old->fsuid)\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (new->gid   != old->gid  ||\n\t    new->egid  != old->egid ||\n\t    new->sgid  != old->sgid ||\n\t    new->fsgid != old->fsgid)\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}\nEXPORT_SYMBOL(commit_creds);\n\n/**\n * abort_creds - Discard a set of credentials and unlock the current task\n * @new: The credentials that were going to be applied\n *\n * Discard a set of credentials that were under construction and unlock the\n * current task.\n */\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}\nEXPORT_SYMBOL(abort_creds);\n\n/**\n * override_creds - Override the current process's subjective credentials\n * @new: The credentials to be assigned\n *\n * Install a set of temporary override subjective credentials on the current\n * process, returning the old set for later reversion.\n */\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\tget_cred(new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}\nEXPORT_SYMBOL(override_creds);\n\n/**\n * revert_creds - Revert a temporary subjective credentials override\n * @old: The credentials to be restored\n *\n * Revert a temporary set of override subjective credentials to an old set,\n * discarding the override set.\n */\nvoid revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}\nEXPORT_SYMBOL(revert_creds);\n\n/*\n * initialise the credentials stuff\n */\nvoid __init cred_init(void)\n{\n\t/* allocate a slab in which we can store credentials */\n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred),\n\t\t\t\t     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n\n/**\n * prepare_kernel_cred - Prepare a set of credentials for a kernel service\n * @daemon: A userspace daemon to be used as a reference\n *\n * Prepare a set of credentials for a kernel service.  This can then be used to\n * override a task's own credentials so that work can be done on behalf of that\n * task that requires a different subjective context.\n *\n * @daemon is used to provide a base for the security record, but can be NULL.\n * If @daemon is supplied, then the security data will be derived from that;\n * otherwise they'll be set to 0 and no groups, full capabilities and no keys.\n *\n * The caller may change these controls afterwards if desired.\n *\n * Returns the new credentials or NULL if out of memory.\n *\n * Does not take, and does not return holding current->cred_replace_mutex.\n */\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n#ifdef CONFIG_KEYS\n\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\tif (!tgcred) {\n\t\tkmem_cache_free(cred_jar, new);\n\t\treturn NULL;\n\t}\n#endif\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tatomic_set(&tgcred->usage, 1);\n\tspin_lock_init(&tgcred->lock);\n\ttgcred->process_keyring = NULL;\n\ttgcred->session_keyring = NULL;\n\tnew->tgcred = tgcred;\n\tnew->request_key_auth = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}\nEXPORT_SYMBOL(prepare_kernel_cred);\n\n/**\n * set_security_override - Set the security ID in a set of credentials\n * @new: The credentials to alter\n * @secid: The LSM security ID to set\n *\n * Set the LSM security ID in a set of credentials so that the subjective\n * security is overridden when an alternative set of credentials is used.\n */\nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}\nEXPORT_SYMBOL(set_security_override);\n\n/**\n * set_security_override_from_ctx - Set the security ID in a set of credentials\n * @new: The credentials to alter\n * @secctx: The LSM security context to generate the security ID from.\n *\n * Set the LSM security ID in a set of credentials so that the subjective\n * security is overridden when an alternative set of credentials is used.  The\n * security ID is specified in string form as a security context to be\n * interpreted by the LSM.\n */\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}\nEXPORT_SYMBOL(set_security_override_from_ctx);\n\n/**\n * set_create_files_as - Set the LSM file create context in a set of credentials\n * @new: The credentials to alter\n * @inode: The inode to take the context from\n *\n * Change the LSM file creation context in a set of credentials to be the same\n * as the object context of the specified inode, so that the new inodes have\n * the same MAC context as that inode.\n */\nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}\nEXPORT_SYMBOL(set_create_files_as);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\nbool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n#ifdef CONFIG_SECURITY_SELINUX\n\t/*\n\t * cred->security == NULL if security_cred_alloc_blank() or\n\t * security_prepare_creds() returned an error.\n\t */\n\tif (selinux_is_enabled() && cred->security) {\n\t\tif ((unsigned long) cred->security < PAGE_SIZE)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->security & 0xffffff00) ==\n\t\t    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\nEXPORT_SYMBOL(creds_are_invalid);\n\n/*\n * dump invalid credentials\n */\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t       cred->uid, cred->euid, cred->suid, cred->fsuid);\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t       cred->gid, cred->egid, cred->sgid, cred->fsgid);\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}\n\n/*\n * report use of invalid credentials\n */\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(KERN_ERR \"CRED: Invalid credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\tdump_invalid_creds(cred, \"Specified\", current);\n\tBUG();\n}\nEXPORT_SYMBOL(__invalid_creds);\n\n/*\n * check the credentials on a process\n */\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}\nEXPORT_SYMBOL(__validate_process_creds);\n\n/*\n * check creds for do_exit()\n */\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}\n\n#endif /* CONFIG_DEBUG_CREDENTIALS */\n"], "fixing_code": ["/* Task credentials management - see Documentation/security/credentials.txt\n *\n * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n#include <linux/export.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/init_task.h>\n#include <linux/security.h>\n#include <linux/binfmts.h>\n#include <linux/cn_proc.h>\n\n#if 0\n#define kdebug(FMT, ...) \\\n\tprintk(\"[%-5.5s%5u] \"FMT\"\\n\", current->comm, current->pid ,##__VA_ARGS__)\n#else\n#define kdebug(FMT, ...) \\\n\tno_printk(\"[%-5.5s%5u] \"FMT\"\\n\", current->comm, current->pid ,##__VA_ARGS__)\n#endif\n\nstatic struct kmem_cache *cred_jar;\n\n/*\n * The common credentials for the initial task's thread group\n */\n#ifdef CONFIG_KEYS\nstatic struct thread_group_cred init_tgcred = {\n\t.usage\t= ATOMIC_INIT(2),\n\t.tgid\t= 0,\n\t.lock\t= __SPIN_LOCK_UNLOCKED(init_cred.tgcred.lock),\n};\n#endif\n\n/*\n * The initial credentials for the initial task\n */\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n#ifdef CONFIG_KEYS\n\t.tgcred\t\t\t= &init_tgcred,\n#endif\n};\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}\n\n/*\n * Dispose of the shared task group credentials\n */\n#ifdef CONFIG_KEYS\nstatic void release_tgcred_rcu(struct rcu_head *rcu)\n{\n\tstruct thread_group_cred *tgcred =\n\t\tcontainer_of(rcu, struct thread_group_cred, rcu);\n\n\tBUG_ON(atomic_read(&tgcred->usage) != 0);\n\n\tkey_put(tgcred->session_keyring);\n\tkey_put(tgcred->process_keyring);\n\tkfree(tgcred);\n}\n#endif\n\n/*\n * Release a set of thread group credentials.\n */\nstatic void release_tgcred(struct cred *cred)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred = cred->tgcred;\n\n\tif (atomic_dec_and_test(&tgcred->usage))\n\t\tcall_rcu(&tgcred->rcu, release_tgcred_rcu);\n#endif\n}\n\n/*\n * The RCU callback to actually dispose of a set of credentials\n */\nstatic void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\trelease_tgcred(cred);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tkmem_cache_free(cred_jar, cred);\n}\n\n/**\n * __put_cred - Destroy a set of credentials\n * @cred: The record to release\n *\n * Destroy a set of credentials on which no references remain.\n */\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}\nEXPORT_SYMBOL(__put_cred);\n\n/*\n * Clean up a task's credentials when it exits\n */\nvoid exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->replacement_session_keyring;\n\tif (cred) {\n\t\ttsk->replacement_session_keyring = NULL;\n\t\tvalidate_creds(cred);\n\t\tput_cred(cred);\n\t}\n}\n\n/**\n * get_task_cred - Get another task's objective credentials\n * @task: The task to query\n *\n * Get the objective credentials of a task, pinning them so that they can't go\n * away.  Accessing a task's credentials directly is not permitted.\n *\n * The caller must also make sure task doesn't get deleted, either by holding a\n * ref on task or by holding tasklist_lock to prevent it from being unlinked.\n */\nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\n\n\trcu_read_unlock();\n\treturn cred;\n}\n\n/*\n * Allocate blank credentials, such that the credentials can be filled in at a\n * later date without risk of ENOMEM.\n */\nstruct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n#ifdef CONFIG_KEYS\n\tnew->tgcred = kzalloc(sizeof(*new->tgcred), GFP_KERNEL);\n\tif (!new->tgcred) {\n\t\tkmem_cache_free(cred_jar, new);\n\t\treturn NULL;\n\t}\n\tatomic_set(&new->tgcred->usage, 1);\n#endif\n\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\n\tif (security_cred_alloc_blank(new, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}\n\n/**\n * prepare_creds - Prepare a new set of credentials for modification\n *\n * Prepare a new set of task credentials for modification.  A task's creds\n * shouldn't generally be modified directly, therefore this function is used to\n * prepare a new copy, which the caller then modifies and then commits by\n * calling commit_creds().\n *\n * Preparation involves making a copy of the objective creds for modification.\n *\n * Returns a pointer to the new creds-to-be if successful, NULL otherwise.\n *\n * Call commit_creds() or abort_creds() to clean up.\n */\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n\tatomic_inc(&new->tgcred->usage);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}\nEXPORT_SYMBOL(prepare_creds);\n\n/*\n * Prepare credentials for current to perform an execve()\n * - The caller must hold ->cred_guard_mutex\n */\nstruct cred *prepare_exec_creds(void)\n{\n\tstruct thread_group_cred *tgcred = NULL;\n\tstruct cred *new;\n\n#ifdef CONFIG_KEYS\n\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\tif (!tgcred)\n\t\treturn NULL;\n#endif\n\n\tnew = prepare_creds();\n\tif (!new) {\n\t\tkfree(tgcred);\n\t\treturn new;\n\t}\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* create a new per-thread-group creds for all this set of threads to\n\t * share */\n\tmemcpy(tgcred, new->tgcred, sizeof(struct thread_group_cred));\n\n\tatomic_set(&tgcred->usage, 1);\n\tspin_lock_init(&tgcred->lock);\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_get(tgcred->session_keyring);\n\ttgcred->process_keyring = NULL;\n\n\trelease_tgcred(new);\n\tnew->tgcred = tgcred;\n#endif\n\n\treturn new;\n}\n\n/*\n * Copy credentials for the new process created by fork()\n *\n * We share if we can, but under some circumstances we have to generate a new\n * set.\n *\n * The new process gets the current process's subjective credentials as its\n * objective and subjective credentials\n */\nint copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tp->replacement_session_keyring = NULL;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n\n/**\n * commit_creds - Install new credentials upon the current task\n * @new: The credentials to be assigned\n *\n * Install a new set of credentials to the current task, using RCU to replace\n * the old set.  Both the objective and the subjective credentials pointers are\n * updated.  This function may not be called if the subjective credentials are\n * in an overridden state.\n *\n * This function eats the caller's reference to the new credentials.\n *\n * Always returns 0 thus allowing this function to be tail-called at the end\n * of, say, sys_setgid().\n */\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (old->euid != new->euid ||\n\t    old->egid != new->egid ||\n\t    old->fsuid != new->fsuid ||\n\t    old->fsgid != new->fsgid ||\n\t    !cap_issubset(new->cap_permitted, old->cap_permitted)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (new->fsuid != old->fsuid)\n\t\tkey_fsuid_changed(task);\n\tif (new->fsgid != old->fsgid)\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (new->uid   != old->uid  ||\n\t    new->euid  != old->euid ||\n\t    new->suid  != old->suid ||\n\t    new->fsuid != old->fsuid)\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (new->gid   != old->gid  ||\n\t    new->egid  != old->egid ||\n\t    new->sgid  != old->sgid ||\n\t    new->fsgid != old->fsgid)\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}\nEXPORT_SYMBOL(commit_creds);\n\n/**\n * abort_creds - Discard a set of credentials and unlock the current task\n * @new: The credentials that were going to be applied\n *\n * Discard a set of credentials that were under construction and unlock the\n * current task.\n */\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}\nEXPORT_SYMBOL(abort_creds);\n\n/**\n * override_creds - Override the current process's subjective credentials\n * @new: The credentials to be assigned\n *\n * Install a set of temporary override subjective credentials on the current\n * process, returning the old set for later reversion.\n */\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\tget_cred(new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}\nEXPORT_SYMBOL(override_creds);\n\n/**\n * revert_creds - Revert a temporary subjective credentials override\n * @old: The credentials to be restored\n *\n * Revert a temporary set of override subjective credentials to an old set,\n * discarding the override set.\n */\nvoid revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}\nEXPORT_SYMBOL(revert_creds);\n\n/*\n * initialise the credentials stuff\n */\nvoid __init cred_init(void)\n{\n\t/* allocate a slab in which we can store credentials */\n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred),\n\t\t\t\t     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n\n/**\n * prepare_kernel_cred - Prepare a set of credentials for a kernel service\n * @daemon: A userspace daemon to be used as a reference\n *\n * Prepare a set of credentials for a kernel service.  This can then be used to\n * override a task's own credentials so that work can be done on behalf of that\n * task that requires a different subjective context.\n *\n * @daemon is used to provide a base for the security record, but can be NULL.\n * If @daemon is supplied, then the security data will be derived from that;\n * otherwise they'll be set to 0 and no groups, full capabilities and no keys.\n *\n * The caller may change these controls afterwards if desired.\n *\n * Returns the new credentials or NULL if out of memory.\n *\n * Does not take, and does not return holding current->cred_replace_mutex.\n */\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n#ifdef CONFIG_KEYS\n\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\tif (!tgcred) {\n\t\tkmem_cache_free(cred_jar, new);\n\t\treturn NULL;\n\t}\n#endif\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tatomic_set(&tgcred->usage, 1);\n\tspin_lock_init(&tgcred->lock);\n\ttgcred->process_keyring = NULL;\n\ttgcred->session_keyring = NULL;\n\tnew->tgcred = tgcred;\n\tnew->request_key_auth = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}\nEXPORT_SYMBOL(prepare_kernel_cred);\n\n/**\n * set_security_override - Set the security ID in a set of credentials\n * @new: The credentials to alter\n * @secid: The LSM security ID to set\n *\n * Set the LSM security ID in a set of credentials so that the subjective\n * security is overridden when an alternative set of credentials is used.\n */\nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}\nEXPORT_SYMBOL(set_security_override);\n\n/**\n * set_security_override_from_ctx - Set the security ID in a set of credentials\n * @new: The credentials to alter\n * @secctx: The LSM security context to generate the security ID from.\n *\n * Set the LSM security ID in a set of credentials so that the subjective\n * security is overridden when an alternative set of credentials is used.  The\n * security ID is specified in string form as a security context to be\n * interpreted by the LSM.\n */\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}\nEXPORT_SYMBOL(set_security_override_from_ctx);\n\n/**\n * set_create_files_as - Set the LSM file create context in a set of credentials\n * @new: The credentials to alter\n * @inode: The inode to take the context from\n *\n * Change the LSM file creation context in a set of credentials to be the same\n * as the object context of the specified inode, so that the new inodes have\n * the same MAC context as that inode.\n */\nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}\nEXPORT_SYMBOL(set_create_files_as);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\nbool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n#ifdef CONFIG_SECURITY_SELINUX\n\t/*\n\t * cred->security == NULL if security_cred_alloc_blank() or\n\t * security_prepare_creds() returned an error.\n\t */\n\tif (selinux_is_enabled() && cred->security) {\n\t\tif ((unsigned long) cred->security < PAGE_SIZE)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->security & 0xffffff00) ==\n\t\t    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\nEXPORT_SYMBOL(creds_are_invalid);\n\n/*\n * dump invalid credentials\n */\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t       cred->uid, cred->euid, cred->suid, cred->fsuid);\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t       cred->gid, cred->egid, cred->sgid, cred->fsgid);\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}\n\n/*\n * report use of invalid credentials\n */\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(KERN_ERR \"CRED: Invalid credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\tdump_invalid_creds(cred, \"Specified\", current);\n\tBUG();\n}\nEXPORT_SYMBOL(__invalid_creds);\n\n/*\n * check the credentials on a process\n */\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}\nEXPORT_SYMBOL(__validate_process_creds);\n\n/*\n * check creds for do_exit()\n */\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}\n\n#endif /* CONFIG_DEBUG_CREDENTIALS */\n"], "filenames": ["kernel/cred.c"], "buggy_code_start_loc": [387], "buggy_code_end_loc": [387], "fixing_code_start_loc": [388], "fixing_code_end_loc": [390], "type": "CWE-119", "message": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call.", "other": {"cve": {"id": "CVE-2012-2745", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-09T10:29:47.027", "lastModified": "2023-02-13T04:33:48.110", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call."}, {"lang": "es", "value": "La funci\u00f3n copy_creds en kernel/cred.c en el kernel de Linux anteriores a v3.3.2 ofrece un reemplazo invalido de claves de sesi\u00f3n a un proceso hijo,  permitiendo a usuarios locales causar una denegaci\u00f3n de servicio a trav\u00e9s de una aplicaci\u00f3n especialmente dise\u00f1ada que utiliza la llamada al sistema fork"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.1", "matchCriteriaId": "A414BCFE-F436-4E67-BF24-05766DA92376"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=79549c6dfda0603dba9a70a53467ce62d9335c33", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-1064.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.3.2", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/54365", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id?1027236", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1567-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1597-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1606-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=833428", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33"}}