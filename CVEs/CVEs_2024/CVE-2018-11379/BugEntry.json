{"buggy_code": ["/* radare - LGPL - Copyright 2008-2017 nibble, pancake, inisider */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"pe.h\"\n#include <time.h>\n\n#define PE_IMAGE_FILE_MACHINE_RPI2 452\n#define MAX_METADATA_STRING_LENGTH 256\n#define bprintf if(bin->verbose) eprintf\n#define COFF_SYMBOL_SIZE 18\n\nstruct SCV_NB10_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tut32 offset;\n\tut32 timestamp;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_NB10_HEADER* cv_nb10_header);\n} SCV_NB10_HEADER;\n\ntypedef struct {\n\tut32 data1;\n\tut16 data2;\n\tut16 data3;\n\tut8 data4[8];\n} SGUID;\n\nstruct SCV_RSDS_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tSGUID guid;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_RSDS_HEADER* rsds_hdr);\n} SCV_RSDS_HEADER;\n\nstatic inline int is_thumb(struct PE_(r_bin_pe_obj_t)* bin) {\n\treturn bin->nt_headers->optional_header.AddressOfEntryPoint & 1;\n}\n\nstatic inline int is_arm(struct PE_(r_bin_pe_obj_t)* bin) {\n\tswitch (bin->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_msvcseh) (struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t* entry;\n\tut8 b[512];\n\tint n = 0;\n\tif (!bin || !bin->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (bin);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tbprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t// MSVC SEH\n\t// E8 13 09 00 00  call    0x44C388\n\t// E9 05 00 00 00  jmp     0x44BA7F\n\tif (b[0] == 0xe8 && b[5] == 0xe9) {\n\t\tconst st32 jmp_dst = r_read_ble32 (b + 6, bin->big_endian);\n\t\tentry->paddr += (5 + 5 + jmp_dst);\n\t\tentry->vaddr += (5 + 5 + jmp_dst);\n\t\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) > 0) {\n\t\t\t// case1:\n\t\t\t// from des address of jmp search for 68 xx xx xx xx e8 and test xx xx xx xx = imagebase\n\t\t\t// 68 00 00 40 00  push    0x400000\n\t\t\t// E8 3E F9 FF FF  call    0x44B4FF\n\t\t\tut32 imageBase = bin->nt_headers->optional_header.ImageBase;\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tconst ut32 tmp_imgbase = r_read_ble32 (b + n + 1, bin->big_endian);\n\t\t\t\tif (b[n] == 0x68 && tmp_imgbase == imageBase && b[n + 5] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 6, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case2:\n\t\t\t// from des address of jmp search for 50 FF xx FF xx E8\n\t\t\t//50\t\t\t push    eax\n\t\t\t//FF 37\t\t\t push    dword ptr[edi]\n\t\t\t//FF 36          push    dword ptr[esi]\n\t\t\t//E8 6F FC FF FF call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n+1] == 0xff && b[n + 3] == 0xff && b[n + 5] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 6, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case3:\n\t\t\t//50                                         push    eax\n\t\t\t//FF 35 0C E2 40 00                          push    xxxxxxxx\n\t\t\t//FF 35 08 E2 40 00                          push    xxxxxxxx\n\t\t\t//E8 2B FD FF FF                             call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 20; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0xff && b[n + 7] == 0xff && b[n + 13] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 14, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 13 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 13 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case4:\n\t\t\t//50                                        push    eax\n\t\t\t//57                                        push    edi\n\t\t\t//FF 36                                     push    dword ptr[esi]\n\t\t\t//E8 D9 FD FF FF                            call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 5; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0x57 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 5, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 4 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 4 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t// MSVC AMD64\n\t// 48 83 EC 28       sub     rsp, 0x28\n\t// E8 xx xx xx xx    call    xxxxxxxx\n\t// 48 83 C4 28       add     rsp, 0x28\n\t// E9 xx xx xx xx    jmp     xxxxxxxx\n\tif (b[4] == 0xe8 && b[13] == 0xe9) {\n\t\t//const st32 jmp_dst = b[14] | (b[15] << 8) | (b[16] << 16) | (b[17] << 24);\n\t\tconst st32 jmp_dst = r_read_ble32 (b + 14, bin->big_endian);\n\t\tentry->paddr += (5 + 13 + jmp_dst);\n\t\tentry->vaddr += (5 + 13 + jmp_dst);\n\t\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) > 0) {\n\t\t\t// from des address of jmp, search for 4C ... 48 ... 8B ... E8\n\t\t\t// 4C 8B C0                    mov     r8, rax\n\t\t\t// 48 8B 17                    mov     rdx, qword [rdi]\n\t\t\t// 8B 0B                       mov     ecx, dword [rbx]\n\t\t\t// E8 xx xx xx xx              call    main\n\t\t\tfor (n = 0; n < sizeof (b) - 13; n++) {\n\t\t\t\tif (b[n] == 0x4c && b[n + 3] == 0x48 && b[n + 6] == 0x8b && b[n + 8] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 9, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Microsoft Visual-C\n\t// 50                  push eax\n\t// FF 75 9C            push dword [ebp - local_64h]\n\t// 56                  push    esi\n\t// 56                  push    esi\n\t// FF 15 CC C0  44 00  call dword [sym.imp.KERNEL32.dll_GetModuleHandleA]\n\t// 50                  push    eax\n\t// E8 DB DA 00 00      call    main\n\t// 89 45 A0            mov dword [ebp - local_60h], eax\n\t// 50                  push    eax\n\t// E8 2D 00 00  00     call 0x4015a6\n\tif (b[188] == 0x50 && b[201] == 0xe8) {\n\t\tconst st32 call_dst = r_read_ble32 (b + 202, bin->big_endian);\n\t\tentry->paddr += (201 + 5 + call_dst);\n\t\tentry->vaddr += (201 + 5 + call_dst);\n\t\treturn entry;\n\t}\n\n\tif (b[292] == 0x50 && b[303] == 0xe8) {\n\t\tconst st32 call_dst = r_read_ble32 (b + 304, bin->big_endian);\n\t\tentry->paddr += (303 + 5 + call_dst);\n\t\tentry->vaddr += (303 + 5 + call_dst);\n\t\treturn entry;\n\t}\n\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_mingw) (struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t* entry;\n\tint sw = 0;\n\tut8 b[1024];\n\tint n = 0;\n\tif (!bin || !bin->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (bin);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tbprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t// mingw\n\t//55                                         push    ebp\n\t//89 E5                                      mov     ebp, esp\n\t//83 EC 08                                   sub     esp, 8\n\t//C7 04 24 01 00 00 00                       mov     dword ptr[esp], 1\n\t//FF 15 C8 63 41 00                          call    ds : __imp____set_app_type\n\t//E8 B8 FE FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[20]);\n\t\tentry->paddr += (5 + 19 + jmp_dst);\n\t\tentry->vaddr += (5 + 19 + jmp_dst);\n\t\tsw = 1;\n\t}\n\t//83 EC 1C                                   sub     esp, 1Ch\n\t//C7 04 24 01 00 00 00                       mov[esp + 1Ch + var_1C], 1\n\t//FF 15 F8 60 40 00                          call    ds : __imp____set_app_type\n\t//E8 6B FD FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[17]);\n\t\tentry->paddr += (5 + 16 + jmp_dst);\n\t\tentry->vaddr += (5 + 16 + jmp_dst);\n\t\tsw = 1;\n\t}\n\t//83 EC 0C                                            sub     esp, 0Ch\n\t//C7 05 F4 0A 81 00 00 00 00 00                       mov     ds : _mingw_app_type, 0\n\t//ED E8 3E AD 24 00                                      call    ___security_init_cookie\n\t//F2 83 C4 0C                                            add     esp, 0Ch\n\t//F5 E9 86 FC FF FF                                      jmp     ___tmainCRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[22]);\n\t\tentry->paddr += (5 + 21 + jmp_dst);\n\t\tentry->vaddr += (5 + 21 + jmp_dst);\n\t\tsw = 1;\n\t}\n\tif (sw) {\n\t\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) > 0) {\n\t\t\t// case1:\n\t\t\t// from des address of call search for a1 xx xx xx xx 89 xx xx e8 xx xx xx xx\n\t\t\t//A1 04 50 44 00                             mov     eax, ds:dword_445004\n\t\t\t//89 04 24                                   mov[esp + 28h + lpTopLevelExceptionFilter], eax\n\t\t\t//E8 A3 01 00 00                             call    sub_4013EE\n\t\t\t// ut32 imageBase = bin->nt_headers->optional_header.ImageBase;\n\t\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = (st32) r_read_le32 (&b[n + 9]);\n\t\t\t\t\tentry->paddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_unknow) (struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!bin || !bin->b) {\n\t\treturn 0LL;\n\t}\n\tut8 *b = calloc (1, 512);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tentry = PE_ (r_bin_pe_get_entrypoint) (bin);\n\t// option2: /x 8bff558bec83ec20\n\tif (r_buf_read_at (bin->b, entry->paddr, b, 512) < 1) {\n\t\tbprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\tfree (b);\n\t\treturn NULL;\n\t}\n\t/* Decode the jmp instruction, this gets the address of the 'main'\n\t   function for PE produced by a compiler whose name someone forgot to\n\t   write down. */\n\t// this is dirty only a single byte check, can return false positives\n\tif (b[367] == 0xe8) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[368]);\n\t\tentry->paddr += 367 + 5 + jmp_dst;\n\t\tentry->vaddr += 367 + 5 + jmp_dst;\n\t\tfree (b);\n\t\treturn entry;\n\t}\n\tint i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\t// 5. ff 15 .. .. .. .. 50 e8 [main]\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i+6] == 0x50) {\n\t\t\t\tif (b[i+7] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = (st32) r_read_le32 (&b[i + 8]);\n\t\t\t\t\tentry->paddr = entry->vaddr - entry->paddr;\n\t\t\t\t\tentry->vaddr += (i + 7 + 5 + (long)call_dst);\n\t\t\t\t\tentry->paddr += entry->vaddr;\n\t\t\t\t\tfree (b);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\tfree (b);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(r_bin_pe_get_main_vaddr)(struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t *winmain = PE_(check_msvcseh) (bin);\n\tif (!winmain) {\n\t\twinmain = PE_(check_mingw) (bin);\n\t\tif (!winmain) {\n\t\t\twinmain = PE_(check_unknow) (bin);\n\t\t}\n\t}\n\treturn winmain;\n}\n\n#define RBinPEObj struct PE_(r_bin_pe_obj_t)\nstatic PE_DWord bin_pe_rva_to_paddr(RBinPEObj* bin, PE_DWord rva) {\n\tPE_DWord section_base;\n\tint i, section_size;\n\tfor (i = 0; i < bin->num_sections; i++) {\n\t\tsection_base = bin->section_header[i].VirtualAddress;\n\t\tsection_size = bin->section_header[i].Misc.VirtualSize;\n\t\tif (rva >= section_base && rva < section_base + section_size) {\n\t\t\treturn bin->section_header[i].PointerToRawData + (rva - section_base);\n\t\t}\n\t}\n\treturn rva;\n}\n\nut64 PE_(r_bin_pe_get_image_base)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tut64 imageBase = 0;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn 0LL;\n\t}\n\timageBase = bin->nt_headers->optional_header.ImageBase;\n\tif (!imageBase) {\n\t\t//this should only happens with messed up binaries\n\t\t//XXX this value should be user defined by bin.baddr\n\t\t//but from here we can not access config API\n\t\timageBase = 0x10000;\n\t}\n\treturn imageBase;\n}\n\nstatic PE_DWord bin_pe_rva_to_va(RBinPEObj* bin, PE_DWord rva) {\n\treturn PE_(r_bin_pe_get_image_base) (bin) + rva;\n}\n\nstatic PE_DWord bin_pe_va_to_rva(RBinPEObj* bin, PE_DWord va) {\n\tut64 imageBase = PE_(r_bin_pe_get_image_base) (bin);\n\tif (va < imageBase) {\n\t\treturn va;\n\t}\n\treturn va - imageBase;\n}\n\nstatic char* resolveModuleOrdinal(Sdb* sdb, const char* module, int ordinal) {\n\tSdb* db = sdb;\n\tchar* foo = sdb_get (db, sdb_fmt (\"%d\", ordinal), 0);\n\tif (foo && *foo) {\n\t\treturn foo;\n\t} else {\n\t\tfree (foo); // should never happen\n\t}\n\treturn NULL;\n}\n\nstatic int bin_pe_parse_imports(struct PE_(r_bin_pe_obj_t)* bin,\n                                struct r_bin_pe_import_t** importp, int* nimp,\n                                const char* dll_name,\n                                PE_DWord OriginalFirstThunk,\n                                PE_DWord FirstThunk) {\n\tchar import_name[PE_NAME_LENGTH + 1];\n\tchar name[PE_NAME_LENGTH + 1];\n\tPE_Word import_hint, import_ordinal = 0;\n\tPE_DWord import_table = 0, off = 0;\n\tint i = 0, len;\n\tSdb* db = NULL;\n\tchar* sdb_module = NULL;\n\tchar* symname;\n\tchar* filename;\n\tchar* symdllname = NULL;\n\n\tif (!dll_name || *dll_name == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(off = bin_pe_rva_to_paddr (bin, OriginalFirstThunk)) &&\n\t!(off = bin_pe_rva_to_paddr (bin, FirstThunk))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (import_ordinal >= UT16_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (off + i * sizeof(PE_DWord) > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off + i * sizeof (PE_DWord), (ut8*) &import_table, sizeof (PE_DWord));\n\t\tif (len != sizeof (PE_DWord)) {\n\t\t\tbprintf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (import_table) {\n\t\t\tif (import_table & ILT_MASK1) {\n\t\t\t\timport_ordinal = import_table & ILT_MASK2;\n\t\t\t\timport_hint = 0;\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s_Ordinal_%i\", dll_name, import_ordinal);\n\t\t\t\tfree (symdllname);\n\t\t\t\tstrncpy (name, dll_name, sizeof (name) - 1);\n\t\t\t\tname[sizeof(name) - 1] = 0;\n\t\t\t\tsymdllname = strdup (name);\n\n\t\t\t\t// remove the trailling \".dll\"\n\t\t\t\tsize_t len = strlen (symdllname);\n\t\t\t\tr_str_case (symdllname, 0);\n\t\t\t\tlen = len < 4? 0: len - 4;\n\t\t\t\tsymdllname[len] = 0;\n\n\t\t\t\tif (!sdb_module || strcmp (symdllname, sdb_module)) {\n\t\t\t\t\tsdb_free (db);\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\tsdb_free (db);\n\t\t\t\t\t}\n\t\t\t\t\tdb = NULL;\n\t\t\t\t\tfree (sdb_module);\n\t\t\t\t\tsdb_module = strdup (symdllname);\n\t\t\t\t\tfilename = sdb_fmt (\"%s.sdb\", symdllname);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n#if __WINDOWS__\n\t\t\t\t\t\tchar invoke_dir[MAX_PATH];\n\t\t\t\t\t\tif (r_sys_get_src_dir_w32 (invoke_dir)) {\n\t\t\t\t\t\t\tfilename = sdb_fmt (\"%s\\\\share\\\\radare2\\\\\"R2_VERSION \"\\\\format\\\\dll\\\\%s.sdb\", invoke_dir, symdllname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilename = sdb_fmt (\"share/radare2/\"R2_VERSION \"/format/dll/%s.sdb\", symdllname);\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\" R2_VERSION \"/format/dll/%s.sdb\", dirPrefix, symdllname);\n#endif\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (db) {\n\t\t\t\t\tsymname = resolveModuleOrdinal (db, symdllname, import_ordinal);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s_%s\", dll_name, symname);\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbprintf (\"Cannot find %s\\n\", filename);\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\timport_ordinal++;\n\t\t\t\tconst ut64 off = bin_pe_rva_to_paddr (bin, import_table);\n\t\t\t\tif (off > bin->size || (off + sizeof (PE_Word)) > bin->size) {\n\t\t\t\t\tbprintf (\"Warning: off > bin->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlen = r_buf_read_at (bin->b, off, (ut8*) &import_hint, sizeof (PE_Word));\n\t\t\t\tif (len != sizeof (PE_Word)) {\n\t\t\t\t\tbprintf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tname[0] = '\\0';\n\t\t\t\tlen = r_buf_read_at (bin->b, off + sizeof(PE_Word), (ut8*) name, PE_NAME_LENGTH);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tbprintf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (!*name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s_%s\", dll_name, name);\n\t\t\t}\n\t\t\tif (!(*importp = realloc (*importp, (*nimp + 1) * sizeof(struct r_bin_pe_import_t)))) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';\n\t\t\t(*importp)[*nimp].vaddr = bin_pe_rva_to_va (bin, FirstThunk + i * sizeof (PE_DWord));\n\t\t\t(*importp)[*nimp].paddr = bin_pe_rva_to_paddr (bin, FirstThunk) + i * sizeof(PE_DWord);\n\t\t\t(*importp)[*nimp].hint = import_hint;\n\t\t\t(*importp)[*nimp].ordinal = import_ordinal;\n\t\t\t(*importp)[*nimp].last = 0;\n\t\t\t(*nimp)++;\n\t\t\ti++;\n\t\t}\n\t} while (import_table);\n\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn i;\n\nerror:\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn false;\n}\n\nstatic char *_time_stamp_to_str(ut32 timeStamp) {\n#ifdef _MSC_VER\n\ttime_t rawtime;\n\tstruct tm *tminfo;\n\trawtime = (time_t)timeStamp;\n\ttminfo = localtime (&rawtime);\n\t//tminfo = gmtime (&rawtime);\n\treturn r_str_trim (strdup (asctime (tminfo)));\n#else\n\tstruct my_timezone {\n\t\tint tz_minuteswest;     /* minutes west of Greenwich */\n\t\tint tz_dsttime;         /* type of DST correction */\n\t} tz;\n\tstruct timeval tv;\n\tint gmtoff;\n\ttime_t ts = (time_t) timeStamp;\n\tgettimeofday (&tv, (void*) &tz);\n\tgmtoff = (int) (tz.tz_minuteswest * 60); // in seconds\n\tts += (time_t)gmtoff;\n\treturn r_str_trim (strdup (ctime (&ts)));\n#endif\n}\n\nstatic int bin_pe_init_hdr(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!(bin->dos_header = malloc (sizeof(PE_(image_dos_header))))) {\n\t\tr_sys_perror (\"malloc (dos header)\");\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, 0, (ut8*) bin->dos_header, sizeof(PE_(image_dos_header))) == -1) {\n\t\tbprintf (\"Warning: read (dos header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"pe_dos_header.offset\", 0, 0);\n\tsdb_set (bin->kv, \"pe_dos_header.format\", \"[2]zwwwwwwwwwwwww[4]www[10]wx\"\n\t\t\" e_magic e_cblp e_cp e_crlc e_cparhdr e_minalloc e_maxalloc\"\n\t\t\" e_ss e_sp e_csum e_ip e_cs e_lfarlc e_ovno e_res e_oemid\"\n\t\t\" e_oeminfo e_res2 e_lfanew\", 0);\n\tif (bin->dos_header->e_lfanew > (unsigned int) bin->size) {\n\t\tbprintf (\"Invalid e_lfanew field\\n\");\n\t\treturn false;\n\t}\n\tif (!(bin->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {\n\t\tr_sys_perror (\"malloc (nt header)\");\n\t\treturn false;\n\t}\n\tbin->nt_header_offset = bin->dos_header->e_lfanew;\n\tif (r_buf_read_at (bin->b, bin->dos_header->e_lfanew, (ut8*) bin->nt_headers, sizeof (PE_(image_nt_headers))) < -1) {\n\t\tbprintf (\"Warning: read (dos header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"pe_magic.cparse\",     \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);\n\tsdb_set (bin->kv, \"pe_subsystem.cparse\", \"enum pe_subsystem { IMAGE_SUBSYSTEM_UNKNOWN=0, IMAGE_SUBSYSTEM_NATIVE=1, IMAGE_SUBSYSTEM_WINDOWS_GUI=2, \"\n\t\t\" IMAGE_SUBSYSTEM_WINDOWS_CUI=3, IMAGE_SUBSYSTEM_OS2_CUI=5, IMAGE_SUBSYSTEM_POSIX_CUI=7, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI=9, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_APPLICATION=10, IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER=11, IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER=12, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_ROM=13, IMAGE_SUBSYSTEM_XBOX=14, IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION=16 };\", 0);\n\tsdb_set (bin->kv, \"pe_dllcharacteristics.cparse\", \"enum pe_dllcharacteristics { IMAGE_LIBRARY_PROCESS_INIT=0x0001, IMAGE_LIBRARY_PROCESS_TERM=0x0002, \"\n\t\t\" IMAGE_LIBRARY_THREAD_INIT=0x0004, IMAGE_LIBRARY_THREAD_TERM=0x0008, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA=0x0020, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE=0x0040, IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY=0x0080, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NX_COMPAT=0x0100, IMAGE_DLLCHARACTERISTICS_NO_ISOLATION=0x0200,IMAGE_DLLCHARACTERISTICS_NO_SEH=0x0400, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NO_BIND=0x0800, IMAGE_DLLCHARACTERISTICS_APPCONTAINER=0x1000, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER=0x2000, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_GUARD_CF=0x4000, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE=0x8000};\", 0);\n#if R_BIN_PE64\n\tsdb_num_set (bin->kv, \"pe_nt_image_headers64.offset\", bin->dos_header->e_lfanew, 0);\n\tsdb_set (bin->kv, \"pe_nt_image_headers64.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header64)optionalHeader\", 0);\n\tsdb_set (bin->kv, \"pe_image_optional_header64.format\", \"[2]Ebbxxxxxqxxwwwwwwxxxx[2]E[2]Bqqqqxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags\"\n\t\t\" numberOfRvaAndSizes (pe_image_data_directory)dataDirectory\", 0);\n#else\n\tsdb_num_set (bin->kv, \"pe_nt_image_headers32.offset\", bin->dos_header->e_lfanew, 0);\n\tsdb_set (bin->kv, \"pe_nt_image_headers32.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header32)optionalHeader\", 0);\n\tsdb_set (bin->kv, \"pe_image_optional_header32.format\", \"[2]Ebbxxxxxxxxxwwwwwwxxxx[2]E[2]Bxxxxxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode baseOfData imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags numberOfRvaAndSizes\"\n\t\t\" (pe_image_data_directory)dataDirectory\", 0);\n#endif\n\tsdb_set (bin->kv, \"pe_machine.cparse\",         \"enum pe_machine { IMAGE_FILE_MACHINE_I386=0x014c, IMAGE_FILE_MACHINE_IA64=0x0200, IMAGE_FILE_MACHINE_AMD64=0x8664 };\", 0);\n\tsdb_set (bin->kv, \"pe_characteristics.cparse\", \"enum pe_characteristics { \"\n\t\t\" IMAGE_FILE_RELOCS_STRIPPED=0x0001, IMAGE_FILE_EXECUTABLE_IMAGE=0x0002, IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004, \"\n\t\t\" IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008, IMAGE_FILE_AGGRESIVE_WS_TRIM=0x0010, IMAGE_FILE_LARGE_ADDRESS_AWARE=0x0020, \"\n\t\t\" IMAGE_FILE_BYTES_REVERSED_LO=0x0080, IMAGE_FILE_32BIT_MACHINE=0x0100, IMAGE_FILE_DEBUG_STRIPPED=0x0200, \"\n\t\t\" IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP=0x0400, IMAGE_FILE_NET_RUN_FROM_SWAP=0x0800, IMAGE_FILE_SYSTEM=0x1000, \"\n\t\t\" IMAGE_FILE_DLL=0x2000, IMAGE_FILE_UP_SYSTEM_ONLY=0x4000, IMAGE_FILE_BYTES_REVERSED_HI=0x8000 };\", 0);\n\tsdb_set (bin->kv, \"pe_image_file_header.format\",    \"[2]Ewtxxw[2]B\"\n\t\t\" (pe_machine)machine numberOfSections timeDateStamp pointerToSymbolTable\"\n\t\t\" numberOfSymbols sizeOfOptionalHeader (pe_characteristics)characteristics\", 0);\n\tsdb_set (bin->kv, \"pe_image_data_directory.format\", \"xx virtualAddress size\",0);\n\n\t// adding compile time to the SDB\n\t{\n\t\tsdb_num_set (bin->kv, \"image_file_header.TimeDateStamp\", bin->nt_headers->file_header.TimeDateStamp, 0);\n\t\tchar *timestr = _time_stamp_to_str (bin->nt_headers->file_header.TimeDateStamp);\n\t\tsdb_set_owned (bin->kv, \"image_file_header.TimeDateStamp_string\", timestr, 0);\n\t}\n\tbin->optional_header = &bin->nt_headers->optional_header;\n\tbin->data_directory = (PE_(image_data_directory*)) & bin->optional_header->DataDirectory;\n\n\tif (strncmp ((char*) &bin->dos_header->e_magic, \"MZ\", 2) ||\n\t(strncmp ((char*) &bin->nt_headers->Signature, \"PE\", 2) &&\n\t/* Check also for Phar Lap TNT DOS extender PL executable */\n\tstrncmp ((char*) &bin->nt_headers->Signature, \"PL\", 2))) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntypedef struct {\n\tut64 shortname;\n\tut32 value;\n\tut16 secnum;\n\tut16 symtype;\n\tut8 symclass;\n\tut8 numaux;\n} SymbolRecord;\n\nstatic struct r_bin_pe_export_t* parse_symbol_table(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_export_t* exports, int sz) {\n\tut64 sym_tbl_off, num = 0;\n\tconst int srsz = COFF_SYMBOL_SIZE; // symbol record size\n\tstruct r_bin_pe_section_t* sections;\n\tstruct r_bin_pe_export_t* exp;\n\tint bufsz, i, shsz;\n\tSymbolRecord* sr;\n\tut64 text_off = 0LL;\n\tut64 text_rva = 0LL;\n\tint textn = 0;\n\tint exports_sz;\n\tint symctr = 0;\n\tchar* buf;\n\n\tif (!bin || !bin->nt_headers) {\n\t\treturn NULL;\n\t}\n\n\tsym_tbl_off = bin->nt_headers->file_header.PointerToSymbolTable;\n\tnum = bin->nt_headers->file_header.NumberOfSymbols;\n\tshsz = bufsz = num * srsz;\n\tif (bufsz < 1 || bufsz > bin->size) {\n\t\treturn NULL;\n\t}\n\tbuf = calloc (num, srsz);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\texports_sz = sizeof(struct r_bin_pe_export_t) * num;\n\tif (exports) {\n\t\tint osz = sz;\n\t\tsz += exports_sz;\n\t\texports = realloc (exports, sz);\n\t\tif (!exports) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\texp = (struct r_bin_pe_export_t*) (((const ut8*) exports) + osz);\n\t} else {\n\t\tsz = exports_sz;\n\t\texports = malloc (sz);\n\t\texp = exports;\n\t}\n\n\tsections = PE_(r_bin_pe_get_sections) (bin);\n\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t//XXX search by section with +x permission since the section can be left blank\n\t\tif (!strcmp ((char*) sections[i].name, \".text\")) {\n\t\t\ttext_rva = sections[i].vaddr;\n\t\t\ttext_off = sections[i].paddr;\n\t\t\ttextn = i + 1;\n\t\t}\n\t}\n\tfree (sections);\n\tsymctr = 0;\n\tif (r_buf_read_at (bin->b, sym_tbl_off, (ut8*) buf, bufsz)) {\n\t\tfor (i = 0; i < shsz; i += srsz) {\n\t\t\tsr = (SymbolRecord*) (buf + i);\n\t\t\t//bprintf (\"SECNUM %d\\n\", sr->secnum);\n\t\t\tif (sr->secnum == textn) {\n\t\t\t\tif (sr->symtype == 32) {\n\t\t\t\t\tchar shortname[9];\n\t\t\t\t\tmemcpy (shortname, &sr->shortname, 8);\n\t\t\t\t\tshortname[8] = 0;\n\t\t\t\t\tif (*shortname) {\n\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, shortname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar* longname, name[128];\n\t\t\t\t\t\tut32* idx = (ut32*) (buf + i + 4);\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, sym_tbl_off + *idx + shsz, (ut8*) name, 128)) { // == 128) {\n\t\t\t\t\t\t\tlongname = name;\n\t\t\t\t\t\t\tname[sizeof(name) - 1] = 0;\n\t\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, longname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsprintf ((char*) exp[symctr].name, \"unk_%d\", symctr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texp[symctr].name[PE_NAME_LENGTH] = 0;\n\t\t\t\t\texp[symctr].vaddr = bin_pe_rva_to_va (bin, text_rva + sr->value);\n\t\t\t\t\texp[symctr].paddr = text_off + sr->value;\n\t\t\t\t\texp[symctr].ordinal = symctr;\n\t\t\t\t\texp[symctr].forwarder[0] = 0;\n\t\t\t\t\texp[symctr].last = 0;\n\t\t\t\t\tsymctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t} // for\n\t} // if read ok\n\texp[symctr].last = 1;\n\tfree (buf);\n\treturn exports;\n}\n\nstatic int bin_pe_init_sections(struct PE_(r_bin_pe_obj_t)* bin) {\n\tbin->num_sections = bin->nt_headers->file_header.NumberOfSections;\n\tint sections_size;\n\tif (bin->num_sections < 1) {\n\t\treturn true;\n\t}\n\tsections_size = sizeof (PE_(image_section_header)) * bin->num_sections;\n\tif (sections_size > bin->size) {\n\t\tsections_size = bin->size;\n\t\tbin->num_sections = bin->size / sizeof (PE_(image_section_header));\n\t\t// massage this to make corkami happy\n\t\t//bprintf (\"Invalid NumberOfSections value\\n\");\n\t\t//goto out_error;\n\t}\n\tif (!(bin->section_header = malloc (sections_size))) {\n\t\tr_sys_perror (\"malloc (section header)\");\n\t\tgoto out_error;\n\t}\n\tbin->section_header_offset = bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +\n\t\tbin->nt_headers->file_header.SizeOfOptionalHeader;\n\tif (r_buf_read_at (bin->b, bin->section_header_offset,\n\t\t(ut8*) bin->section_header, sections_size) == -1) {\n\t\tbprintf (\"Warning: read (sections)\\n\");\n\t\tR_FREE (bin->section_header);\n\t\tgoto out_error;\n\t}\n#if 0\n\tEach symbol table entry includes a name, storage class, type, value and section number.Short names (8 characters or fewer) are stored directly in the symbol table;\n\tlonger names are stored as an paddr into the string table at the end of the COFF object.\n\n\t================================================================\n\tCOFF SYMBOL TABLE RECORDS (18 BYTES)\n\t================================================================\n\trecord\n\tpaddr\n\n\tstruct symrec {\n\t\tunion {\n\t\t\tchar string[8]; // short name\n\t\t\tstruct {\n\t\t\t\tut32 seros;\n\t\t\t\tut32 stridx;\n\t\t\t} stridx;\n\t\t} name;\n\t\tut32 value;\n\t\tut16 secnum;\n\t\tut16 symtype;\n\t\tut8 symclass;\n\t\tut8 numaux;\n\t}\n\t------------------------------------------------------ -\n\t0 | 8 - char symbol name |\n\t| or 32 - bit zeroes followed by 32 - bit |\n\t| index into string table |\n\t------------------------------------------------------ -\n\t8 | symbol value |\n\t------------------------------------------------------ -\n\t0Ch | section number | symbol type |\n\t------------------------------------------------------ -\n\t10h | sym class | num aux |\n\t-------------------------- -\n\t12h\n\n#endif\n\treturn true;\nout_error:\n\tbin->num_sections = 0;\n\treturn false;\n}\n\nint PE_(bin_pe_get_claimed_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->optional_header) {\n\t\treturn 0;\n\t}\n\treturn bin->optional_header->CheckSum;\n}\n\nint PE_(bin_pe_get_actual_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tint i, j, checksum_offset = 0;\n\tut8* buf = NULL;\n\tut64 computed_cs = 0;\n\tint remaining_bytes;\n\tint shift;\n\tut32 cur;\n\tif (!bin || !bin->nt_header_offset) {\n\t\treturn 0;\n\t}\n\tbuf = bin->b->buf;\n\tchecksum_offset = bin->nt_header_offset + 4 + sizeof(PE_(image_file_header)) + 0x40;\n\tfor (i = 0; i < bin->size / 4; i++) {\n\t\tcur = r_read_le32 (&buf[i * 4]);\n\n\t\t// skip the checksum bytes\n\t\tif (i * 4 == checksum_offset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t}\n\n\t// add resultant bytes to checksum\n\tremaining_bytes = bin->size % 4;\n\ti = i * 4;\n\tif (remaining_bytes != 0) {\n\t\tcur = buf[i];\n\t\tshift = 8;\n\t\tfor (j = 1; j < remaining_bytes; j++, shift += 8) {\n\t\t\tcur |= buf[i + j] << shift;\n\t\t}\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t}\n\n\t// 32bits -> 16bits\n\tcomputed_cs = (computed_cs & 0xFFFF) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs & 0xFFFF);\n\n\t// add filesize\n\tcomputed_cs += bin->size;\n\treturn computed_cs;\n}\n\nstatic void computeOverlayOffset(ut64 offset, ut64 size, ut64 file_size, ut64* largest_offset, ut64* largest_size) {\n\tif (offset + size <= file_size && offset + size > (*largest_offset + *largest_size)) {\n\t\t*largest_offset = offset;\n\t\t*largest_size = size;\n\t}\n}\n\n/* Inspired from https://github.com/erocarrera/pefile/blob/master/pefile.py#L5425 */\nint PE_(bin_pe_get_overlay)(struct PE_(r_bin_pe_obj_t)* bin, ut64* size) {\n\tut64 largest_offset = 0;\n\tut64 largest_size = 0;\n\t*size = 0;\n\tint i;\n\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\n\tif (bin->optional_header) {\n\t\tcomputeOverlayOffset (\n\t\t\t\tbin->nt_header_offset+4+sizeof(bin->nt_headers->file_header),\n\t\t\t\tbin->nt_headers->file_header.SizeOfOptionalHeader,\n\t\t\t\tbin->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t}\n\n\tstruct r_bin_pe_section_t *sects = NULL;\n\tsects = PE_(r_bin_pe_get_sections) (bin);\n\tfor (i = 0; !sects[i].last; i++) {\n\t\tcomputeOverlayOffset(\n\t\t\t\tsects[i].paddr,\n\t\t\t\tsects[i].size,\n\t\t\t\tbin->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size\n\t\t\t\t);\n\t}\n\n\tif (bin->optional_header) {\n\t\tfor (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {\n\t\t\tif (i == PE_IMAGE_DIRECTORY_ENTRY_SECURITY) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcomputeOverlayOffset (\n\t\t\t\tbin_pe_rva_to_paddr (bin, bin->data_directory[i].VirtualAddress),\n\t\t\t\tbin->data_directory[i].Size,\n\t\t\t\tbin->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t\t}\n\n\t}\n\n\tif ((ut64) bin->size > largest_offset + largest_size) {\n\t\t*size = bin->size - largest_offset - largest_size;\n\t\tfree (sects);\n\t\treturn largest_offset + largest_size;\n\t}\n\tfree (sects);\n\treturn 0;\n}\n\nstatic int bin_pe_read_metadata_string(char* to, char* from) {\n\tint covered = 0;\n\twhile (covered < MAX_METADATA_STRING_LENGTH) {\n\t\tto[covered] = from[covered];\n\t\tif (from[covered] == '\\0') {\n\t\t\tcovered += 1;\n\t\t\tbreak;\n\t\t}\n\t\tcovered++;\n\t}\n\twhile (covered % 4 != 0) { covered++; }\n\treturn covered;\n}\n\nstatic int bin_pe_init_metadata_hdr(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_DWord metadata_directory = bin->clr_hdr? bin_pe_rva_to_paddr (bin, bin->clr_hdr->MetaDataDirectoryAddress): 0;\n\tPE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));\n\tint rr;\n\tif (!metadata) {\n\t\treturn 0;\n\t}\n\tif (!metadata_directory) {\n\t\tfree (metadata);\n\t\treturn 0;\n\t}\n\n\n\trr = r_buf_fread_at (bin->b, metadata_directory,\n\t\t(ut8*) metadata, bin->big_endian? \"1I2S\": \"1i2s\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (bin->b, metadata_directory + 8,\n\t\t(ut8*) (&metadata->Reserved), bin->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (bin->b, metadata_directory + 12,\n\t\t(ut8*) (&metadata->VersionStringLength), bin->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Metadata Signature: 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d\\n\",\n\t\t(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);\n\n\t// read the version string\n\tint len = metadata->VersionStringLength; // XXX: dont trust this length\n\tif (len > 0) {\n\t\tmetadata->VersionString = calloc (1, len + 1);\n\t\tif (!metadata->VersionString) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\trr = r_buf_read_at (bin->b, metadata_directory + 16, (ut8*)(metadata->VersionString),  len);\n\t\tif (rr != len) {\n\t\t\teprintf (\"Warning: read (metadata header) - cannot parse version string\\n\");\n\t\t\tfree (metadata->VersionString);\n\t\t\tfree (metadata);\n\t\t\treturn 0;\n\t\t}\n\t\teprintf (\".NET Version: %s\\n\", metadata->VersionString);\n\t}\n\n\t// read the header after the string\n\trr = r_buf_fread_at (bin->b, metadata_directory + 16 + metadata->VersionStringLength,\n\t\t(ut8*) (&metadata->Flags), bin->big_endian? \"2S\": \"2s\", 1);\n\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Number of Metadata Streams: %d\\n\", metadata->NumberOfStreams);\n\tbin->metadata_header = metadata;\n\n\n\t// read metadata streams\n\tint start_of_stream = metadata_directory + 20 + metadata->VersionStringLength;\n\tPE_(image_metadata_stream) * stream;\n\tPE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);\n\tif (!streams) {\n\t\tgoto fail;\n\t}\n\tint count = 0;\n\n\twhile (count < metadata->NumberOfStreams) {\n\t\tstream = R_NEW0 (PE_(image_metadata_stream));\n\t\tif (!stream) {\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (r_buf_fread_at (bin->b, start_of_stream, (ut8*) stream, bin->big_endian? \"2I\": \"2i\", 1) < 1) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"DirectoryAddress: %x Size: %x\\n\", stream->Offset, stream->Size);\n\t\tchar* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);\n\n\t\tif (!stream_name) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (r_buf_size (bin->b) < (start_of_stream + 8 + MAX_METADATA_STRING_LENGTH)) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tint c = bin_pe_read_metadata_string (stream_name,\n\t\t\t(char *)(bin->b->buf + start_of_stream + 8));\n\t\tif (c == 0) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"Stream name: %s %d\\n\", stream_name, c);\n\t\tstream->Name = stream_name;\n\t\tstreams[count] = stream;\n\t\tstart_of_stream += 8 + c;\n\t\tcount += 1;\n\t}\n\tbin->streams = streams;\n\treturn 1;\nfail:\n\teprintf (\"Warning: read (metadata header)\\n\");\n\tfree (metadata);\n\treturn 0;\n}\n\nstatic int bin_pe_init_overlay(struct PE_(r_bin_pe_obj_t)* bin) {\n\tut64 pe_overlay_size;\n\tut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (bin, &pe_overlay_size);\n\tif (pe_overlay_offset) {\n\t\tsdb_num_set (bin->kv, \"pe_overlay.offset\", pe_overlay_offset, 0);\n\t\tsdb_num_set (bin->kv, \"pe_overlay.size\", pe_overlay_size, 0);\n\t}\n\treturn 0;\n}\n\nstatic int bin_pe_init_clr_hdr(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * clr_dir = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];\n\tPE_DWord image_clr_hdr_paddr = bin_pe_rva_to_paddr (bin, clr_dir->VirtualAddress);\n\t// int clr_dir_size = clr_dir? clr_dir->Size: 0;\n\tPE_(image_clr_header) * clr_hdr = R_NEW0 (PE_(image_clr_header));\n\tint rr, len = sizeof (PE_(image_clr_header));\n\n\tif (!clr_hdr) {\n\t\treturn 0;\n\t}\n\trr = r_buf_read_at (bin->b, image_clr_hdr_paddr, (ut8*) (clr_hdr), len);\n\n//\tprintf(\"%x\\n\", clr_hdr->HeaderSize);\n\n\tif (clr_hdr->HeaderSize != 0x48) {\n\t\t// probably not a .NET binary\n\t\t// 64bit?\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\tif (rr != len) {\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\n\tbin->clr_hdr = clr_hdr;\n\treturn 1;\n}\n\nstatic int bin_pe_init_imports(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * data_dir_import = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_IMPORT];\n\tPE_(image_data_directory) * data_dir_delay_import = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];\n\n\tPE_DWord import_dir_paddr = bin_pe_rva_to_paddr (bin, data_dir_import->VirtualAddress);\n\tPE_DWord import_dir_offset = bin_pe_rva_to_paddr (bin, data_dir_import->VirtualAddress);\n\tPE_DWord delay_import_dir_offset = data_dir_delay_import\n\t? bin_pe_rva_to_paddr (bin, data_dir_delay_import->VirtualAddress)\n\t\t\t\t\t: 0;\n\n\tPE_(image_import_directory) * import_dir = NULL;\n\tPE_(image_import_directory) * new_import_dir = NULL;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\n\tPE_(image_delay_import_directory) * delay_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = NULL;\n\n\tint dir_size = sizeof(PE_(image_import_directory));\n\tint delay_import_size = sizeof(PE_(image_delay_import_directory));\n\tint indx = 0;\n\tint rr, count = 0;\n\tint import_dir_size = data_dir_import->Size;\n\tint delay_import_dir_size = data_dir_delay_import->Size;\n\t/// HACK to modify import size because of begin 0.. this may report wrong info con corkami tests\n\tif (!import_dir_size) {\n\t\t// asume 1 entry for each\n\t\timport_dir_size = data_dir_import->Size = 0xffff;\n\t}\n\tif (!delay_import_dir_size) {\n\t\t// asume 1 entry for each\n\t\tdelay_import_dir_size = data_dir_delay_import->Size = 0xffff;\n\t}\n\tint maxidsz = R_MIN ((PE_DWord) bin->size, import_dir_offset + import_dir_size);\n\tmaxidsz -= import_dir_offset;\n\tif (maxidsz < 0) {\n\t\tmaxidsz = 0;\n\t}\n\t//int maxcount = maxidsz/ sizeof (struct r_bin_pe_import_t);\n\n\tfree (bin->import_directory);\n\tbin->import_directory = NULL;\n\tif (import_dir_paddr != 0) {\n\t\tif (import_dir_size < 1 || import_dir_size > maxidsz) {\n\t\t\tbprintf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);\n\t\t\timport_dir_size = maxidsz;\n\t\t}\n\t\tbin->import_directory_offset = import_dir_offset;\n\t\tcount = 0;\n\t\tdo {\n\t\t\tindx++;\n\t\t\tif (((2 + indx) * dir_size) > import_dir_size) {\n\t\t\t\tbreak; //goto fail;\n\t\t\t}\n\t\t\tnew_import_dir = (PE_(image_import_directory)*)realloc (import_dir, ((1 + indx) * dir_size));\n\t\t\tif (!new_import_dir) {\n\t\t\t\tr_sys_perror (\"malloc (import directory)\");\n\t\t\t\tfree (import_dir);\n\t\t\t\timport_dir = NULL;\n\t\t\t\tbreak; //\n\t\t\t\t//\t\t\tgoto fail;\n\t\t\t}\n\t\t\timport_dir = new_import_dir;\n\t\t\tnew_import_dir = NULL;\n\t\t\tcurr_import_dir = import_dir + (indx - 1);\n\t\t\tif (r_buf_read_at (bin->b, import_dir_offset + (indx - 1) * dir_size, (ut8*) (curr_import_dir), dir_size) < 1) {\n\t\t\t\tbprintf (\"Warning: read (import directory)\\n\");\n\t\t\t\tfree (import_dir);\n\t\t\t\timport_dir = NULL;\n\t\t\t\tbreak; //return false;\n\t\t\t}\n\t\t\tcount++;\n\t\t} while (curr_import_dir->FirstThunk != 0 || curr_import_dir->Name != 0 ||\n\t\tcurr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||\n\t\tcurr_import_dir->ForwarderChain != 0);\n\n\t\tbin->import_directory = import_dir;\n\t\tbin->import_directory_size = import_dir_size;\n\t}\n\n\tindx = 0;\n\tif (bin->b->length > 0) {\n\t\tif ((delay_import_dir_offset != 0) && (delay_import_dir_offset < (ut32) bin->b->length)) {\n\t\t\tut64 off;\n\t\t\tbin->delay_import_directory_offset = delay_import_dir_offset;\n\t\t\tdo {\n\t\t\t\tindx++;\n\t\t\t\toff = indx * delay_import_size;\n\t\t\t\tif (off >= bin->b->length) {\n\t\t\t\t\tbprintf (\"Warning: Cannot find end of import symbols\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelay_import_dir = (PE_(image_delay_import_directory)*)realloc (\n\t\t\t\t\tdelay_import_dir, (indx * delay_import_size) + 1);\n\t\t\t\tif (delay_import_dir == 0) {\n\t\t\t\t\tr_sys_perror (\"malloc (delay import directory)\");\n\t\t\t\t\tfree (delay_import_dir);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tcurr_delay_import_dir = delay_import_dir + (indx - 1);\n\t\t\t\trr = r_buf_read_at (bin->b, delay_import_dir_offset + (indx - 1) * delay_import_size,\n\t\t\t\t\t(ut8*) (curr_delay_import_dir), dir_size);\n\t\t\t\tif (rr != dir_size) {\n\t\t\t\t\tbprintf (\"Warning: read (delay import directory)\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t} while (curr_delay_import_dir->Name != 0);\n\t\t\tbin->delay_import_directory = delay_import_dir;\n\t\t}\n\t}\n\n\treturn true;\nfail:\n\tfree (import_dir);\n\timport_dir = NULL;\n\tbin->import_directory = import_dir;\n\tfree (delay_import_dir);\n\treturn false;\n}\n\nstatic int bin_pe_init_exports(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * data_dir_export = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\tPE_DWord export_dir_paddr = bin_pe_rva_to_paddr (bin, data_dir_export->VirtualAddress);\n\tif (!export_dir_paddr) {\n\t\t// This export-dir-paddr should only appear in DLL files\n\t\t// bprintf (\"Warning: Cannot find the paddr of the export directory\\n\");\n\t\treturn false;\n\t}\n\t// sdb_setn (DB, \"hdr.exports_directory\", export_dir_paddr);\n\t// bprintf (\"Pexports paddr at 0x%\"PFMT64x\"\\n\", export_dir_paddr);\n\tif (!(bin->export_directory = malloc (sizeof(PE_(image_export_directory))))) {\n\t\tr_sys_perror (\"malloc (export directory)\");\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, export_dir_paddr, (ut8*) bin->export_directory, sizeof (PE_(image_export_directory))) == -1) {\n\t\tbprintf (\"Warning: read (export directory)\\n\");\n\t\tfree (bin->export_directory);\n\t\tbin->export_directory = NULL;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void _free_resources(r_pe_resource *rs) {\n\tif (rs) {\n\t\tfree (rs->timestr);\n\t\tfree (rs->data);\n\t\tfree (rs->type);\n\t\tfree (rs->language);\n\t\tfree (rs);\n\t}\n}\n\n\nstatic int bin_pe_init_resource(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * resource_dir = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_RESOURCE];\n\tPE_DWord resource_dir_paddr = bin_pe_rva_to_paddr (bin, resource_dir->VirtualAddress);\n\tif (!resource_dir_paddr) {\n\t\treturn false;\n\t}\n\n\tbin->resources = r_list_newf ((RListFree)_free_resources);\n\tif (!bin->resources) {\n\t\treturn false;\n\t}\n\tif (!(bin->resource_directory = malloc (sizeof(*bin->resource_directory)))) {\n\t\tr_sys_perror (\"malloc (resource directory)\");\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, resource_dir_paddr, (ut8*) bin->resource_directory,\n\t\tsizeof (*bin->resource_directory)) != sizeof (*bin->resource_directory)) {\n\t\tbprintf (\"Warning: read (resource directory)\\n\");\n\t\tfree (bin->resource_directory);\n\t\tbin->resource_directory = NULL;\n\t\treturn false;\n\t}\n\tbin->resource_directory_offset = resource_dir_paddr;\n\treturn true;\n}\n\n\n\nstatic void bin_pe_store_tls_callbacks(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord callbacks) {\n\tPE_DWord paddr, haddr;\n\tint count = 0;\n\tPE_DWord addressOfTLSCallback = 1;\n\tchar* key;\n\n\twhile (addressOfTLSCallback != 0) {\n\t\tif (r_buf_read_at (bin->b, callbacks, (ut8*) &addressOfTLSCallback, sizeof(addressOfTLSCallback)) != sizeof (addressOfTLSCallback)) {\n\t\t\tbprintf (\"Warning: read (tls_callback)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!addressOfTLSCallback) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->optional_header->SizeOfImage) {\n\t\t\tint rva_callback = bin_pe_va_to_rva (bin, (PE_DWord) addressOfTLSCallback);\n\t\t\tif (rva_callback > bin->optional_header->SizeOfImage) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkey = sdb_fmt (\"pe.tls_callback%d_vaddr\", count);\n\t\tsdb_num_set (bin->kv, key, addressOfTLSCallback, 0);\n\t\tkey = sdb_fmt (\"pe.tls_callback%d_paddr\", count);\n\t\tpaddr = bin_pe_rva_to_paddr (bin, bin_pe_va_to_rva (bin, (PE_DWord) addressOfTLSCallback));\n\t\tsdb_num_set (bin->kv, key, paddr,                0);\n\t\tkey = sdb_fmt (\"pe.tls_callback%d_haddr\", count);\n\t\thaddr = callbacks;\n\t\tsdb_num_set (bin->kv, key, haddr,                0);\n\t\tcount++;\n\t\tcallbacks += sizeof (addressOfTLSCallback);\n\t}\n}\n\nstatic int bin_pe_init_tls(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_tls_directory) * image_tls_directory;\n\tPE_(image_data_directory) * data_dir_tls = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_TLS];\n\tPE_DWord tls_paddr = bin_pe_rva_to_paddr (bin, data_dir_tls->VirtualAddress);\n\n\timage_tls_directory = R_NEW0 (PE_(image_tls_directory));\n\tif (r_buf_read_at (bin->b, tls_paddr, (ut8*) image_tls_directory, sizeof (PE_(image_tls_directory))) != sizeof (PE_(image_tls_directory))) {\n\t\tbprintf (\"Warning: read (image_tls_directory)\\n\");\n\t\tfree (image_tls_directory);\n\t\treturn 0;\n\t}\n\tbin->tls_directory = image_tls_directory;\n\tif (!image_tls_directory->AddressOfCallBacks) {\n\t\treturn 0;\n\t}\n\tif (image_tls_directory->EndAddressOfRawData < image_tls_directory->StartAddressOfRawData) {\n\t\treturn 0;\n\t}\n\tPE_DWord callbacks_paddr = bin_pe_rva_to_paddr (bin, bin_pe_va_to_rva (bin,\n\t\t\t(PE_DWord) image_tls_directory->AddressOfCallBacks));\n\tbin_pe_store_tls_callbacks (bin, callbacks_paddr);\n\treturn 0;\n}\n\nstatic void free_Var(Var* var) {\n\tif (var) {\n\t\tfree (var->szKey);\n\t\tfree (var->Value);\n\t\tfree (var);\n\t}\n}\n\nstatic void free_VarFileInfo(VarFileInfo* varFileInfo) {\n\tif (varFileInfo) {\n\t\tfree (varFileInfo->szKey);\n\t\tif (varFileInfo->Children) {\n\t\t\tut32 children = 0;\n\t\t\tfor (; children < varFileInfo->numOfChildren; children++) {\n\t\t\t\tfree_Var (varFileInfo->Children[children]);\n\t\t\t}\n\t\t\tfree (varFileInfo->Children);\n\t\t}\n\t\tfree (varFileInfo);\n\t}\n}\n\nstatic void free_String(String* string) {\n\tif (string) {\n\t\tfree (string->szKey);\n\t\tfree (string->Value);\n\t\tfree (string);\n\t}\n}\n\nstatic void free_StringTable(StringTable* stringTable) {\n\tif (stringTable) {\n\t\tfree (stringTable->szKey);\n\t\tif (stringTable->Children) {\n\t\t\tut32 childrenST = 0;\n\t\t\tfor (; childrenST < stringTable->numOfChildren; childrenST++) {\n\t\t\t\tfree_String (stringTable->Children[childrenST]);\n\t\t\t}\n\t\t\tfree (stringTable->Children);\n\t\t}\n\t\tfree (stringTable);\n\t}\n}\n\nstatic void free_StringFileInfo(StringFileInfo* stringFileInfo) {\n\tif (stringFileInfo) {\n\t\tfree (stringFileInfo->szKey);\n\t\tif (stringFileInfo->Children) {\n\t\t\tut32 childrenSFI = 0;\n\t\t\tfor (; childrenSFI < stringFileInfo->numOfChildren; childrenSFI++) {\n\t\t\t\tfree_StringTable (stringFileInfo->Children[childrenSFI]);\n\t\t\t}\n\t\t\tfree (stringFileInfo->Children);\n\t\t}\n\t\tfree (stringFileInfo);\n\t}\n}\n\n#define align32(x) x = ((x & 0x3) == 0)? x: (x & ~0x3) + 0x4;\n\nstatic void free_VS_VERSIONINFO(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tif (vs_VersionInfo) {\n\t\tfree (vs_VersionInfo->szKey);\n\t\tfree (vs_VersionInfo->Value);\n\t\tfree_VarFileInfo (vs_VersionInfo->varFileInfo);\n\t\tfree_StringFileInfo (vs_VersionInfo->stringFileInfo);\n\t\tfree (vs_VersionInfo);\n\t}\n}\n\nvoid PE_(free_VS_VERSIONINFO)(PE_VS_VERSIONINFO * vs_VersionInfo) {\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n}\n\nstatic Var* Pe_r_bin_pe_parse_var(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tVar* var = calloc (1, sizeof(*var));\n\tif (!var) {\n\t\tbprintf (\"Warning: calloc (Var)\\n\");\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &var->wLength, sizeof(var->wLength)) != sizeof(var->wLength)) {\n\t\tbprintf (\"Warning: read (Var wLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(var->wLength);\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &var->wValueLength, sizeof(var->wValueLength)) != sizeof(var->wValueLength)) {\n\t\tbprintf (\"Warning: read (Var wValueLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(var->wValueLength);\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &var->wType, sizeof(var->wType)) != sizeof(var->wType)) {\n\t\tbprintf (\"Warning: read (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(var->wType);\n\tif (var->wType != 0 && var->wType != 1) {\n\t\tbprintf (\"Warning: check (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"\n\tif (!var->szKey) {\n\t\tbprintf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {\n\t\tbprintf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tbprintf (\"Warning: check (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\tvar->numOfValues = var->wValueLength / 4;\n\tif (!var->numOfValues) {\n\t\tbprintf (\"Warning: check (Var numOfValues)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tvar->Value = (ut32*) malloc (var->wValueLength);\n\tif (!var->Value) {\n\t\tbprintf (\"Warning: malloc (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {\n\t\tbprintf (\"Warning: read (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += var->wValueLength;\n\treturn var;\n}\n\nstatic VarFileInfo* Pe_r_bin_pe_parse_var_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tVarFileInfo* varFileInfo = calloc (1, sizeof(*varFileInfo));\n\tif (!varFileInfo) {\n\t\tbprintf (\"Warning: calloc (VarFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = *curAddr;\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &varFileInfo->wLength, sizeof(varFileInfo->wLength)) != sizeof(varFileInfo->wLength)) {\n\t\tbprintf (\"Warning: read (VarFileInfo wLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(varFileInfo->wLength);\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &varFileInfo->wValueLength, sizeof(varFileInfo->wValueLength)) != sizeof(varFileInfo->wValueLength)) {\n\t\tbprintf (\"Warning: read (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(varFileInfo->wValueLength);\n\n\tif (varFileInfo->wValueLength != 0) {\n\t\tbprintf (\"Warning: check (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &varFileInfo->wType, sizeof(varFileInfo->wType)) != sizeof(varFileInfo->wType)) {\n\t\tbprintf (\"Warning: read (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(varFileInfo->wType);\n\tif (varFileInfo->wType && varFileInfo->wType != 1) {\n\t\tbprintf (\"Warning: check (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tvarFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (VARFILEINFO_UTF_16_LEN ));  //L\"VarFileInfo\"\n\tif (!varFileInfo->szKey) {\n\t\tbprintf (\"Warning: malloc (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {\n\t\tbprintf (\"Warning: read (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += VARFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (varFileInfo->szKey, VARFILEINFO_UTF_16, VARFILEINFO_UTF_16_LEN)) {\n\t\tbprintf (\"Warning: check (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\twhile (startAddr + varFileInfo->wLength > *curAddr) {\n\t\tVar** tmp = (Var**) realloc (varFileInfo->Children, (varFileInfo->numOfChildren + 1) * sizeof(*varFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tbprintf (\"Warning: realloc (VarFileInfo Children)\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->Children = tmp;\n\t\tif (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var (bin, curAddr))) {\n\t\t\tbprintf (\"Warning: bad parsing Var\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\treturn varFileInfo;\n}\n\nstatic String* Pe_r_bin_pe_parse_string(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tString* string = calloc (1, sizeof(*string));\n\tPE_DWord begAddr = *curAddr;\n\tint len_value = 0;\n\tint i = 0;\n\tif (!string) {\n\t\tbprintf (\"Warning: calloc (String)\\n\");\n\t\treturn NULL;\n\t}\n\tif (begAddr > bin->size || begAddr + sizeof(string->wLength) > bin->size) {\n\t\tfree_String (string);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &string->wLength, sizeof(string->wLength)) != sizeof(string->wLength)) {\n\t\tbprintf (\"Warning: read (String wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof(string->wLength);\n\tif (*curAddr > bin->size || *curAddr + sizeof(string->wValueLength) > bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &string->wValueLength, sizeof(string->wValueLength)) != sizeof(string->wValueLength)) {\n\t\tbprintf (\"Warning: read (String wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof(string->wValueLength);\n\n\tif (*curAddr > bin->size || *curAddr + sizeof(string->wType) > bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &string->wType, sizeof(string->wType)) != sizeof(string->wType)) {\n\t\tbprintf (\"Warning: read (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof(string->wType);\n\tif (string->wType != 0 && string->wType != 1) {\n\t\tbprintf (\"Warning: check (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tfor (i = 0; *curAddr < begAddr + string->wLength; ++i, *curAddr += sizeof (ut16)) {\n\t\tut16 utf16_char;\n\t\tif (*curAddr > bin->size || *curAddr + sizeof (ut16) > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &utf16_char, sizeof (ut16)) != sizeof (ut16)) {\n\t\t\tbprintf (\"Warning: check (String szKey)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tstring->szKey = (ut16*) realloc (string->szKey, (i + 1) * sizeof (ut16));\n\t\tstring->szKey[i] = utf16_char;\n\t\tstring->wKeyLen += sizeof (ut16);\n\t\tif (!utf16_char) {\n\t\t\t*curAddr += sizeof (ut16);\n\t\t\tbreak;\n\t\t}\n\t}\n\talign32 (*curAddr);\n\tlen_value = R_MIN (string->wValueLength * 2, string->wLength - (*curAddr - begAddr));\n\tstring->wValueLength = len_value;\n\tif (len_value < 0) {\n\t\tlen_value = 0;\n\t}\n\tstring->Value = (ut16*) calloc (len_value + 1, 1);\n\tif (!string->Value) {\n\t\tbprintf (\"Warning: malloc (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\tif (*curAddr > bin->size || *curAddr + len_value > bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) string->Value, len_value) != len_value) {\n\t\tbprintf (\"Warning: read (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += len_value;\n\treturn string;\nout_error:\n\tfree_String (string);\n\treturn NULL;\n}\n\nstatic StringTable* Pe_r_bin_pe_parse_string_table(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tStringTable* stringTable = calloc (1, sizeof(*stringTable));\n\tif (!stringTable) {\n\t\tbprintf (\"Warning: calloc (stringTable)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringTable->wLength, sizeof(stringTable->wLength)) != sizeof(stringTable->wLength)) {\n\t\tbprintf (\"Warning: read (StringTable wLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringTable->wLength);\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringTable->wValueLength, sizeof(stringTable->wValueLength)) != sizeof(stringTable->wValueLength)) {\n\t\tbprintf (\"Warning: read (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringTable->wValueLength);\n\n\tif (stringTable->wValueLength) {\n\t\tbprintf (\"Warning: check (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringTable->wType, sizeof(stringTable->wType)) != sizeof(stringTable->wType)) {\n\t\tbprintf (\"Warning: read (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringTable->wType);\n\tif (stringTable->wType && stringTable->wType != 1) {\n\t\tbprintf (\"Warning: check (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\tstringTable->szKey = (ut16*) malloc (UT16_ALIGN (EIGHT_HEX_DIG_UTF_16_LEN));  //EIGHT_HEX_DIG_UTF_16_LEN\n\tif (!stringTable->szKey) {\n\t\tbprintf (\"Warning: malloc (stringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {\n\t\tbprintf (\"Warning: read (StringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += EIGHT_HEX_DIG_UTF_16_LEN;\n\talign32 (*curAddr);\n\twhile (startAddr + stringTable->wLength > *curAddr) {\n\t\tString** tmp = (String**) realloc (stringTable->Children, (stringTable->numOfChildren + 1) * sizeof(*stringTable->Children));\n\t\tif (!tmp) {\n\t\t\tbprintf (\"Warning: realloc (StringTable Children)\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->Children = tmp;\n\t\tif (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string (bin, curAddr))) {\n\t\t\tbprintf (\"Warning: bad parsing String\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringTable->numOfChildren) {\n\t\tbprintf (\"Warning: check (StringTable numOfChildren)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\treturn stringTable;\n}\n\nstatic StringFileInfo* Pe_r_bin_pe_parse_string_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tStringFileInfo* stringFileInfo = calloc (1, sizeof(*stringFileInfo));\n\tif (!stringFileInfo) {\n\t\tbprintf (\"Warning: calloc (StringFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringFileInfo->wLength, sizeof(stringFileInfo->wLength)) != sizeof(stringFileInfo->wLength)) {\n\t\tbprintf (\"Warning: read (StringFileInfo wLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringFileInfo->wLength);\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringFileInfo->wValueLength, sizeof(stringFileInfo->wValueLength)) != sizeof(stringFileInfo->wValueLength)) {\n\t\tbprintf (\"Warning: read (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringFileInfo->wValueLength);\n\n\tif (stringFileInfo->wValueLength) {\n\t\tbprintf (\"Warning: check (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringFileInfo->wType, sizeof(stringFileInfo->wType)) != sizeof(stringFileInfo->wType)) {\n\t\tbprintf (\"Warning: read (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringFileInfo->wType);\n\n\tif (stringFileInfo->wType && stringFileInfo->wType != 1) {\n\t\tbprintf (\"Warning: check (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tstringFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (STRINGFILEINFO_UTF_16_LEN));  //L\"StringFileInfo\"\n\tif (!stringFileInfo->szKey) {\n\t\tbprintf (\"Warning: malloc (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {\n\t\tbprintf (\"Warning: read (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += STRINGFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (stringFileInfo->szKey, STRINGFILEINFO_UTF_16, STRINGFILEINFO_UTF_16_LEN) != 0) {\n\t\tbprintf (\"Warning: check (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\talign32 (*curAddr);\n\n\twhile (startAddr + stringFileInfo->wLength > *curAddr) {\n\t\tStringTable** tmp = (StringTable**) realloc (stringFileInfo->Children, (stringFileInfo->numOfChildren + 1) * sizeof(*stringFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tbprintf (\"Warning: realloc (StringFileInfo Children)\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->Children = tmp;\n\t\tif (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table (bin, curAddr))) {\n\t\t\tbprintf (\"Warning: bad parsing StringTable\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringFileInfo->numOfChildren) {\n\t\tbprintf (\"Warning: check (StringFileInfo numOfChildren)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\treturn stringFileInfo;\n}\n\n#define EXIT_ON_OVERFLOW(S)\\\n\tif (curAddr > bin->size || curAddr + (S) > bin->size) { \\\n\t\tgoto out_error; }\nstatic PE_VS_VERSIONINFO* Pe_r_bin_pe_parse_version_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord version_info_paddr) {\n\tut32 sz;\n\tPE_VS_VERSIONINFO* vs_VersionInfo = calloc (1, sizeof(PE_VS_VERSIONINFO));\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = version_info_paddr;\n\tPE_DWord curAddr = version_info_paddr;\n\t//align32(curAddr); // XXX: do we really need this? Because in msdn\n\t//wLength is The length, in bytes, of the VS_VERSIONINFO structure.\n\t//This length does not include any padding that aligns any subsequent\n\t//version resource data on a 32-bit boundary.\n\t//Mb we are in subsequent version resource data and not aligned.\n\tsz = sizeof(ut16);\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) &vs_VersionInfo->wLength, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) &vs_VersionInfo->wValueLength, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) &vs_VersionInfo->wType, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (vs_VersionInfo->wType && vs_VersionInfo->wType != 1) {\n\t\tbprintf (\"Warning: check (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tvs_VersionInfo->szKey = (ut16*) malloc (UT16_ALIGN (VS_VERSION_INFO_UTF_16_LEN));  //L\"VS_VERSION_INFO\"\n\tif (!vs_VersionInfo->szKey) {\n\t\tbprintf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tsz = VS_VERSION_INFO_UTF_16_LEN;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) vs_VersionInfo->szKey, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (memcmp (vs_VersionInfo->szKey, VS_VERSION_INFO_UTF_16, sz)) {\n\t\tgoto out_error;\n\t}\n\talign32 (curAddr);\n\tif (vs_VersionInfo->wValueLength) {\n\t\tif (vs_VersionInfo->wValueLength != sizeof (*vs_VersionInfo->Value)) {\n\t\t\tbprintf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tvs_VersionInfo->Value = (PE_VS_FIXEDFILEINFO*) malloc (sizeof(*vs_VersionInfo->Value));\n\t\tif (!vs_VersionInfo->Value) {\n\t\t\tbprintf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tsz = sizeof(PE_VS_FIXEDFILEINFO);\n\t\tEXIT_ON_OVERFLOW (sz);\n\t\tif (r_buf_read_at (bin->b, curAddr, (ut8*) vs_VersionInfo->Value, sz) != sz) {\n\t\t\tbprintf (\"Warning: read (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (vs_VersionInfo->Value->dwSignature != 0xFEEF04BD) {\n\t\t\tbprintf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurAddr += sz;\n\t\talign32 (curAddr);\n\t}\n\n\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\tchar t = '\\0';\n\t\tif (curAddr + 3 * sizeof(ut16) > bin->size || curAddr + 3 + sizeof(ut64) + 1 > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, curAddr + 3 * sizeof(ut16), (ut8*) &t, 1) != 1) {\n\t\t\tbprintf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (!(t == 'S' || t == 'V')) {\n\t\t\tbprintf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (t == 'S') {\n\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (bin, &curAddr))) {\n\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t\tif (t == 'V') {\n\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (bin, &curAddr))) {\n\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\n\t\talign32 (curAddr);\n\n\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\tif (t == 'V') {\n\t\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (bin, &curAddr))) {\n\t\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t} else if (t == 'S') {\n\t\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (bin, &curAddr))) {\n\t\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\treturn vs_VersionInfo;\nout_error:\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\treturn NULL;\n\n}\n\nstatic Sdb* Pe_r_bin_store_var(Var* var) {\n\tunsigned int i = 0;\n\tchar key[20];\n\tSdb* sdb = NULL;\n\tif (var) {\n\t\tsdb = sdb_new0 ();\n\t\tif (sdb) {\n\t\t\tfor (; i < var->numOfValues; i++) {\n\t\t\t\tsnprintf (key, 20, \"%d\", i);\n\t\t\t\tsdb_num_set (sdb, key, var->Value[i], 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_var_file_info(VarFileInfo* varFileInfo) {\n\tchar key[20];\n\tunsigned int i = 0;\n\tif (!varFileInfo) {\n\t\treturn NULL;\n\t}\n\tSdb* sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < varFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"var%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_var (varFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string(String* string) {\n\tSdb* sdb = NULL;\n\tchar* encodedVal = NULL, * encodedKey = NULL;\n\tif (!string) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) string->szKey, string->wKeyLen);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tencodedVal = sdb_encode ((unsigned char*) string->Value, string->wValueLength);\n\tif (!encodedVal) {\n\t\tfree (encodedKey);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\",   encodedKey, 0);\n\tsdb_set (sdb, \"value\", encodedVal, 0);\n\tfree (encodedKey);\n\tfree (encodedVal);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_table(StringTable* stringTable) {\n\tchar key[20];\n\tchar* encodedKey = NULL;\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringTable) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\", encodedKey, 0);\n\tfree (encodedKey);\n\tfor (; i < stringTable->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"string%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string (stringTable->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_file_info(StringFileInfo* stringFileInfo) {\n\tchar key[30];\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < stringFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 30, \"stringtable%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string_table (stringFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_fixed_file_info(PE_VS_FIXEDFILEINFO* vs_fixedFileInfo) {\n\tSdb* sdb = NULL;\n\tif (!vs_fixedFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tsdb_num_set (sdb, \"Signature\",        vs_fixedFileInfo->dwSignature,        0);\n\tsdb_num_set (sdb, \"StrucVersion\",     vs_fixedFileInfo->dwStrucVersion,     0);\n\tsdb_num_set (sdb, \"FileVersionMS\",    vs_fixedFileInfo->dwFileVersionMS,    0);\n\tsdb_num_set (sdb, \"FileVersionLS\",    vs_fixedFileInfo->dwFileVersionLS,    0);\n\tsdb_num_set (sdb, \"ProductVersionMS\", vs_fixedFileInfo->dwProductVersionMS, 0);\n\tsdb_num_set (sdb, \"ProductVersionLS\", vs_fixedFileInfo->dwProductVersionLS, 0);\n\tsdb_num_set (sdb, \"FileFlagsMask\",    vs_fixedFileInfo->dwFileFlagsMask,    0);\n\tsdb_num_set (sdb, \"FileFlags\",        vs_fixedFileInfo->dwFileFlags,        0);\n\tsdb_num_set (sdb, \"FileOS\",           vs_fixedFileInfo->dwFileOS,           0);\n\tsdb_num_set (sdb, \"FileType\",         vs_fixedFileInfo->dwFileType,         0);\n\tsdb_num_set (sdb, \"FileSubtype\",      vs_fixedFileInfo->dwFileSubtype,      0);\n\tsdb_num_set (sdb, \"FileDateMS\",       vs_fixedFileInfo->dwFileDateMS,       0);\n\tsdb_num_set (sdb, \"FileDateLS\",       vs_fixedFileInfo->dwFileDateLS,       0);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_resource_version_info(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tSdb* sdb = NULL;\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (vs_VersionInfo->Value) {\n\t\tsdb_ns_set (sdb, \"fixed_file_info\", Pe_r_bin_store_fixed_file_info (vs_VersionInfo->Value));\n\t}\n\tif (vs_VersionInfo->varFileInfo) {\n\t\tsdb_ns_set (sdb, \"var_file_info\", Pe_r_bin_store_var_file_info (vs_VersionInfo->varFileInfo));\n\t}\n\tif (vs_VersionInfo->stringFileInfo) {\n\t\tsdb_ns_set (sdb, \"string_file_info\", Pe_r_bin_store_string_file_info (vs_VersionInfo->stringFileInfo));\n\t}\n\treturn sdb;\n}\n\nstatic char* _resource_lang_str(int id) {\n\tswitch(id) {\n\tcase 0x00: return \"LANG_NEUTRAL\";\n\tcase 0x7f: return \"LANG_INVARIANT\";\n\tcase 0x36: return \"LANG_AFRIKAANS\";\n\tcase 0x1c: return \"LANG_ALBANIAN \";\n\tcase 0x01: return \"LANG_ARABIC\";\n\tcase 0x2b: return \"LANG_ARMENIAN\";\n\tcase 0x4d: return \"LANG_ASSAMESE\";\n\tcase 0x2c: return \"LANG_AZERI\";\n\tcase 0x2d: return \"LANG_BASQUE\";\n\tcase 0x23: return \"LANG_BELARUSIAN\";\n\tcase 0x45: return \"LANG_BENGALI\";\n\tcase 0x02: return \"LANG_BULGARIAN\";\n\tcase 0x03: return \"LANG_CATALAN\";\n\tcase 0x04: return \"LANG_CHINESE\";\n\tcase 0x1a: return \"LANG_CROATIAN\";\n\tcase 0x05: return \"LANG_CZECH\";\n\tcase 0x06: return \"LANG_DANISH\";\n\tcase 0x65: return \"LANG_DIVEHI\";\n\tcase 0x13: return \"LANG_DUTCH\";\n\tcase 0x09: return \"LANG_ENGLISH\";\n\tcase 0x25: return \"LANG_ESTONIAN\";\n\tcase 0x38: return \"LANG_FAEROESE\";\n\tcase 0x29: return \"LANG_FARSI\";\n\tcase 0x0b: return \"LANG_FINNISH\";\n\tcase 0x0c: return \"LANG_FRENCH\";\n\tcase 0x56: return \"LANG_GALICIAN\";\n\tcase 0x37: return \"LANG_GEORGIAN\";\n\tcase 0x07: return \"LANG_GERMAN\";\n\tcase 0x08: return \"LANG_GREEK\";\n\tcase 0x47: return \"LANG_GUJARATI\";\n\tcase 0x0d: return \"LANG_HEBREW\";\n\tcase 0x39: return \"LANG_HINDI\";\n\tcase 0x0e: return \"LANG_HUNGARIAN\";\n\tcase 0x0f: return \"LANG_ICELANDIC\";\n\tcase 0x21: return \"LANG_INDONESIAN\";\n\tcase 0x10: return \"LANG_ITALIAN\";\n\tcase 0x11: return \"LANG_JAPANESE\";\n\tcase 0x4b: return \"LANG_KANNADA\";\n\tcase 0x60: return \"LANG_KASHMIRI\";\n\tcase 0x3f: return \"LANG_KAZAK\";\n\tcase 0x57: return \"LANG_KONKANI\";\n\tcase 0x12: return \"LANG_KOREAN\";\n\tcase 0x40: return \"LANG_KYRGYZ\";\n\tcase 0x26: return \"LANG_LATVIAN\";\n\tcase 0x27: return \"LANG_LITHUANIAN\";\n\tcase 0x2f: return \"LANG_MACEDONIAN\";\n\tcase 0x3e: return \"LANG_MALAY\";\n\tcase 0x4c: return \"LANG_MALAYALAM\";\n\tcase 0x58: return \"LANG_MANIPURI\";\n\tcase 0x4e: return \"LANG_MARATHI\";\n\tcase 0x50: return \"LANG_MONGOLIAN\";\n\tcase 0x61: return \"LANG_NEPALI\";\n\tcase 0x14: return \"LANG_NORWEGIAN\";\n\tcase 0x48: return \"LANG_ORIYA\";\n\tcase 0x15: return \"LANG_POLISH\";\n\tcase 0x16: return \"LANG_PORTUGUESE\";\n\tcase 0x46: return \"LANG_PUNJABI\";\n\tcase 0x18: return \"LANG_ROMANIAN\";\n\tcase 0x19: return \"LANG_RUSSIAN\";\n\tcase 0x4f: return \"LANG_SANSKRIT\";\n\tcase 0x59: return \"LANG_SINDHI\";\n\tcase 0x1b: return \"LANG_SLOVAK\";\n\tcase 0x24: return \"LANG_SLOVENIAN\";\n\tcase 0x0a: return \"LANG_SPANISH \";\n\tcase 0x41: return \"LANG_SWAHILI\";\n\tcase 0x1d: return \"LANG_SWEDISH\";\n\tcase 0x5a: return \"LANG_SYRIAC\";\n\tcase 0x49: return \"LANG_TAMIL\";\n\tcase 0x44: return \"LANG_TATAR\";\n\tcase 0x4a: return \"LANG_TELUGU\";\n\tcase 0x1e: return \"LANG_THAI\";\n\tcase 0x1f: return \"LANG_TURKISH\";\n\tcase 0x22: return \"LANG_UKRAINIAN\";\n\tcase 0x20: return \"LANG_URDU\";\n\tcase 0x43: return \"LANG_UZBEK\";\n\tcase 0x2a: return \"LANG_VIETNAMESE\";\n\tcase 0x3c: return \"LANG_GAELIC\";\n\tcase 0x3a: return \"LANG_MALTESE\";\n\tcase 0x28: return \"LANG_MAORI\";\n\tcase 0x17: return \"LANG_RHAETO_ROMANCE\";\n\tcase 0x3b: return \"LANG_SAAMI\";\n\tcase 0x2e: return \"LANG_SORBIAN\";\n\tcase 0x30: return \"LANG_SUTU\";\n\tcase 0x31: return \"LANG_TSONGA\";\n\tcase 0x32: return \"LANG_TSWANA\";\n\tcase 0x33: return \"LANG_VENDA\";\n\tcase 0x34: return \"LANG_XHOSA\";\n\tcase 0x35: return \"LANG_ZULU\";\n\tcase 0x8f: return \"LANG_ESPERANTO\";\n\tcase 0x90: return \"LANG_WALON\";\n\tcase 0x91: return \"LANG_CORNISH\";\n\tcase 0x92: return \"LANG_WELSH\";\n\tcase 0x93: return \"LANG_BRETON\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\nstatic char* _resource_type_str(int type) {\n\tswitch (type) {\n\tcase 1: return \"CURSOR\";\n\tcase 2: return \"BITMAP\";\n\tcase 3: return \"ICON\";\n\tcase 4: return \"MENU\";\n\tcase 5: return \"DIALOG\";\n\tcase 6: return \"STRING\";\n\tcase 7: return \"FONTDIR\";\n\tcase 8: return \"FONT\";\n\tcase 9: return \"ACCELERATOR\";\n\tcase 10: return \"RCDATA\";\n\tcase 11: return \"MESSAGETABLE\";\n\tcase 12: return \"GROUP_CURSOR\";\n\tcase 14: return \"GROUP_ICON\";\n\tcase 16: return \"VERSION\";\n\tcase 17: return \"DLGINCLUDE\";\n\tcase 19: return \"PLUGPLAY\";\n\tcase 20: return \"VXD\";\n\tcase 21: return \"ANICURSOR\";\n\tcase 22: return \"ANIICON\";\n\tcase 23: return \"HTML\";\n\tcase 24: return \"MANIFEST\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\nstatic void _parse_resource_directory(struct PE_(r_bin_pe_obj_t) *bin, Pe_image_resource_directory *dir, ut64 offDir, int type, int id, SdbHash *dirs) {\n\tint index = 0;\n\tut32 totalRes = dir->NumberOfNamedEntries + dir->NumberOfIdEntries;\n\tut64 rsrc_base = bin->resource_directory_offset;\n\tut64 off;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry entry;\n\t\toff = rsrc_base + offDir + sizeof(*dir) + index * sizeof(entry);\n\t\tchar *key = sdb_fmt (\"0x%08\"PFMT64x, off);\n\t\tif (sdb_ht_find (dirs, key, NULL)) {\n\t\t\tbreak;\n\t\t}\n\t\tsdb_ht_insert (dirs, key, \"1\");\n\t\tif (off > bin->size || off + sizeof (entry) > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, off, (ut8*)&entry, sizeof(entry)) < 1) {\n\t\t\teprintf (\"Warning: read resource entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (entry.u2.s.DataIsDirectory) {\n\t\t\t//detect here malicious file trying to making us infinite loop\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\toff = rsrc_base + entry.u2.s.OffsetToDirectory;\n\t\t\tint len = r_buf_read_at (bin->b, off, (ut8*) &identEntry, sizeof (identEntry));\n\t\t\tif (len < 1 || len != sizeof (Pe_image_resource_directory)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t_parse_resource_directory (bin, &identEntry,\n\t\t\t\tentry.u2.s.OffsetToDirectory, type, entry.u1.Id, dirs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tPe_image_resource_data_entry *data = R_NEW0 (Pe_image_resource_data_entry);\n\t\tif (!data) {\n\t\t\tbreak;\n\t\t}\n\t\toff = rsrc_base + entry.u2.OffsetToData;\n\t\tif (off > bin->size || off + sizeof (data) > bin->size) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, off, (ut8*)data, sizeof (*data)) != sizeof (*data)) {\n\t\t\teprintf (\"Warning: read (resource data entry)\\n\");\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (type == PE_RESOURCE_ENTRY_VERSION) {\n\t\t\tchar key[64];\n\t\t\tint counter = 0;\n\t\t\tSdb *sdb = sdb_new0 ();\n\t\t\tif (!sdb) {\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord data_paddr = bin_pe_rva_to_paddr (bin, data->OffsetToData);\n\t\t\tif (!data_paddr) {\n\t\t\t\tbprintf (\"Warning: bad RVA in resource data entry\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord cur_paddr = data_paddr;\n\t\t\tif ((cur_paddr & 0x3) != 0) {\n\t\t\t\tbprintf (\"Warning: not aligned version info address\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (cur_paddr < (data_paddr + data->Size) && cur_paddr < bin->size) {\n\t\t\t\tPE_VS_VERSIONINFO* vs_VersionInfo = Pe_r_bin_pe_parse_version_info (bin, cur_paddr);\n\t\t\t\tif (vs_VersionInfo) {\n\t\t\t\t\tsnprintf (key, 30, \"VS_VERSIONINFO%d\", counter++);\n\t\t\t\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_resource_version_info (vs_VersionInfo));\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (vs_VersionInfo->wLength < 1) {\n\t\t\t\t\t// Invalid version length\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_paddr += vs_VersionInfo->wLength;\n\t\t\t\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\t\t\t\talign32 (cur_paddr);\n\t\t\t}\n\t\t\tsdb_ns_set (bin->kv, \"vs_version_info\", sdb);\n\t\t}\n\t\tr_pe_resource *rs = R_NEW0 (r_pe_resource);\n\t\tif (!rs) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\trs->timestr = _time_stamp_to_str (dir->TimeDateStamp);\n\t\trs->type = strdup (_resource_type_str (type));\n\t\trs->language = strdup (_resource_lang_str (entry.u1.Name & 0x3ff));\n\t\trs->data = data;\n\t\trs->name = id;\n\t\tr_list_append (bin->resources, rs);\n\t}\n}\n\nstatic void _store_resource_sdb(struct PE_(r_bin_pe_obj_t) *bin) {\n\tRListIter *iter;\n\tr_pe_resource *rs;\n\tint index = 0;\n\tut64 vaddr = 0;\n\tchar *key;\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn;\n\t}\n\tr_list_foreach (bin->resources, iter, rs) {\n\t\tkey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tsdb_set (sdb, key, rs->timestr, 0);\n\t\tkey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tvaddr = bin_pe_rva_to_va (bin, rs->data->OffsetToData);\n\t\tsdb_num_set (sdb, key, vaddr, 0);\n\t\tkey = sdb_fmt (\"resource.%d.name\", index);\n\t\tsdb_num_set (sdb, key, rs->name, 0);\n\t\tkey = sdb_fmt (\"resource.%d.size\", index);\n\t\tsdb_num_set (sdb, key, rs->data->Size, 0);\n\t\tkey = sdb_fmt (\"resource.%d.type\", index);\n\t\tsdb_set (sdb, key, rs->type, 0);\n\t\tkey = sdb_fmt (\"resource.%d.language\", index);\n\t\tsdb_set (sdb, key, rs->language, 0);\n\t\tindex++;\n\t}\n\tsdb_ns_set (bin->kv, \"pe_resource\", sdb);\n}\n\n\nR_API void PE_(bin_pe_parse_resource)(struct PE_(r_bin_pe_obj_t) *bin) {\n\tint index = 0;\n\tut64 off = 0, rsrc_base = bin->resource_directory_offset;\n\tPe_image_resource_directory *rs_directory = bin->resource_directory;\n\tut32 curRes = 0;\n\tint totalRes = 0;\n\tSdbHash *dirs = sdb_ht_new (); //to avoid infinite loops\n\tif (!dirs) {\n\t\treturn;\n\t}\n\tif (!rs_directory) {\n\t\tsdb_ht_free (dirs);\n\t\treturn;\n\t}\n\tcurRes = rs_directory->NumberOfNamedEntries;\n\ttotalRes = curRes + rs_directory->NumberOfIdEntries;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\teprintf (\"Error parsing resource directory\\n\");\n\t\tsdb_ht_free (dirs);\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry typeEntry;\n\t\toff = rsrc_base + sizeof (*rs_directory) + index * sizeof (typeEntry);\n\t\tsdb_ht_insert (dirs, sdb_fmt (\"0x%08\"PFMT64x, off), \"1\");\n\t\tif (off > bin->size || off + sizeof(typeEntry) > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, off, (ut8*)&typeEntry, sizeof(typeEntry)) < 1) {\n\t\t\teprintf (\"Warning: read resource  directory entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (typeEntry.u2.s.DataIsDirectory) {\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\toff = rsrc_base + typeEntry.u2.s.OffsetToDirectory;\n\t\t\tint len = r_buf_read_at (bin->b, off, (ut8*)&identEntry, sizeof(identEntry));\n\t\t\tif (len < 1 || len != sizeof (identEntry)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t_parse_resource_directory (bin, &identEntry, typeEntry.u2.s.OffsetToDirectory, typeEntry.u1.Id, 0, dirs);\n\t\t}\n\t}\n\tsdb_ht_free (dirs);\n\t_store_resource_sdb (bin);\n}\n\nstatic void bin_pe_get_certificate(struct PE_ (r_bin_pe_obj_t) * bin) {\n\tut64 size, vaddr;\n\tut8 *data = NULL;\n\tint len;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn;\n\t}\n\tbin->cms = NULL;\n\tsize = bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY].Size;\n\tvaddr = bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress;\n\tdata = calloc (1, size);\n\tif (!data) {\n\t\treturn;\n\t}\n\tif (vaddr > bin->size || vaddr + size > bin->size) {\n\t\tbprintf (\"vaddr greater than the file\\n\");\n\t\tfree (data);\n\t\treturn;\n\t}\n\t//skipping useless header..\n\tlen = r_buf_read_at (bin->b, vaddr + 8, data, size - 8);\n\tif (len < 1) {\n\t\tR_FREE (data);\n\t\treturn;\n\t}\n\tbin->cms = r_pkcs7_parse_cms (data, size);\n\tbin->is_signed = bin->cms != NULL;\n\tR_FREE (data);\n}\n\nstatic int bin_pe_init(struct PE_(r_bin_pe_obj_t)* bin) {\n\tbin->dos_header = NULL;\n\tbin->nt_headers = NULL;\n\tbin->section_header = NULL;\n\tbin->export_directory = NULL;\n\tbin->import_directory = NULL;\n\tbin->resource_directory = NULL;\n\tbin->delay_import_directory = NULL;\n\tbin->optional_header = NULL;\n\tbin->data_directory = NULL;\n\tbin->big_endian = 0;\n\tif (!bin_pe_init_hdr (bin)) {\n\t\teprintf (\"Warning: File is not PE\\n\");\n\t\treturn false;\n\t}\n\tif (!bin_pe_init_sections (bin)) {\n\t\teprintf (\"Warning: Cannot initialize sections\\n\");\n\t\treturn false;\n\t}\n\tbin_pe_init_imports (bin);\n\tbin_pe_init_exports (bin);\n\tbin_pe_init_resource (bin);\n\tbin_pe_get_certificate(bin);\n\n\tbin->big_endian = PE_(r_bin_pe_is_big_endian) (bin);\n\n\tbin_pe_init_tls (bin);\n\tbin_pe_init_clr_hdr (bin);\n\tbin_pe_init_metadata_hdr (bin);\n\tbin_pe_init_overlay (bin);\n\tPE_(bin_pe_parse_resource) (bin);\n\tbin->relocs = NULL;\n\treturn true;\n}\n\nchar* PE_(r_bin_pe_get_arch)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* arch;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn strdup (\"x86\");\n\t}\n\tswitch (bin->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA:\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA64:\n\t\tarch = strdup (\"alpha\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_M68K:\n\t\tarch = strdup (\"m68k\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_MIPS16:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16:\n\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2:\n\t\tarch = strdup (\"mips\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_POWERPC:\n\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP:\n\t\tarch = strdup (\"ppc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_EBC:\n\t\tarch = strdup (\"ebc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_ARM64:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tdefault:\n\t\tarch = strdup (\"x86\");\n\t}\n\treturn arch;\n}\n\nstruct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_addr_t* entry = NULL;\n\tstatic bool debug = false;\n\tPE_DWord pe_entry;\n\tint i;\n\tut64 base_addr = PE_(r_bin_pe_get_image_base) (bin);\n\tif (!bin || !bin->optional_header) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = malloc (sizeof (struct r_bin_pe_addr_t)))) {\n\t\tr_sys_perror (\"malloc (entrypoint)\");\n\t\treturn NULL;\n\t}\n\tpe_entry = bin->optional_header->AddressOfEntryPoint;\n\tentry->vaddr = bin_pe_rva_to_va (bin, pe_entry);\n\tentry->paddr = bin_pe_rva_to_paddr (bin, pe_entry);\n\t// haddr is the address of AddressOfEntryPoint in header.\n\tentry->haddr = bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) + 16;\n\n\tif (entry->paddr >= bin->size) {\n\t\tstruct r_bin_pe_section_t* sections = PE_(r_bin_pe_get_sections) (bin);\n\t\tut64 paddr = 0;\n\t\tif (!debug) {\n\t\t\tbprintf (\"Warning: Invalid entrypoint ... \"\n\t\t\t\t\"trying to fix it but i do not promise nothing\\n\");\n\t\t}\n\t\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t\tif (sections[i].flags & PE_IMAGE_SCN_MEM_EXECUTE) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tpaddr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (!paddr) {\n\t\t\tut64 min_off = -1;\n\t\t\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t\t\t//get the lowest section's paddr\n\t\t\t\tif (sections[i].paddr < min_off) {\n\t\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\t\tmin_off = sections[i].paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_off == -1) {\n\t\t\t\t//no section just a hack to try to fix entrypoint\n\t\t\t\t//maybe doesn't work always\n\t\t\t\tint sa = R_MAX (bin->optional_header->SectionAlignment, 0x1000);\n\t\t\t\tentry->paddr = pe_entry & ((sa << 1) - 1);\n\t\t\t\tentry->vaddr = entry->paddr + base_addr;\n\t\t\t}\n\t\t}\n\t\tfree (sections);\n\n\t}\n\tif (!entry->paddr) {\n\t\tif (!debug) {\n\t\t\tbprintf (\"Warning: NULL entrypoint\\n\");\n\t\t}\n\t\tstruct r_bin_pe_section_t* sections = PE_(r_bin_pe_get_sections) (bin);\n\t\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t\t//If there is a section with x without w perm is a good candidate to be the entrypoint\n\t\t\tif (sections[i].flags & PE_IMAGE_SCN_MEM_EXECUTE && !(sections[i].flags & PE_IMAGE_SCN_MEM_WRITE)) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tfree (sections);\n\t}\n\n\tif (is_arm (bin) && entry->vaddr & 1) {\n\t\tentry->vaddr--;\n\t\tif (entry->paddr & 1) {\n\t\t\tentry->paddr--;\n\t\t}\n\t}\n\tif (!debug) {\n\t\tdebug = true;\n\t}\n\treturn entry;\n}\n\nstruct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_export_t* exp, * exports = NULL;\n\tPE_Word function_ordinal;\n\tPE_VWord functions_paddr, names_paddr, ordinals_paddr, function_rva, name_vaddr, name_paddr;\n\tchar function_name[PE_NAME_LENGTH + 1], forwarder_name[PE_NAME_LENGTH + 1];\n\tchar dll_name[PE_NAME_LENGTH + 1], export_name[256];\n\tPE_(image_data_directory) * data_dir_export;\n\tPE_VWord export_dir_rva;\n\tint n,i, export_dir_size;\n\tst64 exports_sz = 0;\n\n\tif (!bin || !bin->data_directory) {\n\t\treturn NULL;\n\t}\n\tdata_dir_export = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\texport_dir_rva = data_dir_export->VirtualAddress;\n\texport_dir_size = data_dir_export->Size;\n\tif (bin->export_directory) {\n\t\tif (bin->export_directory->NumberOfFunctions + 1 <\n\t\tbin->export_directory->NumberOfFunctions) {\n\t\t\t// avoid integer overflow\n\t\t\treturn NULL;\n\t\t}\n\t\texports_sz = (bin->export_directory->NumberOfFunctions + 1) * sizeof (struct r_bin_pe_export_t);\n\t\t// we cant exit with export_sz > bin->size, us r_bin_pe_export_t is 256+256+8+8+8+4 bytes is easy get over file size\n\t\t// to avoid fuzzing we can abort on export_directory->NumberOfFunctions>0xffff\n\t\tif (exports_sz < 0 || bin->export_directory->NumberOfFunctions + 1 > 0xffff) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(exports = malloc (exports_sz))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, bin_pe_rva_to_paddr (bin, bin->export_directory->Name), (ut8*) dll_name, PE_NAME_LENGTH) < 1) {\n\t\t\tbprintf (\"Warning: read (dll name)\\n\");\n\t\t\tfree (exports);\n\t\t\treturn NULL;\n\t\t}\n\t\tfunctions_paddr = bin_pe_rva_to_paddr (bin, bin->export_directory->AddressOfFunctions);\n\t\tnames_paddr = bin_pe_rva_to_paddr (bin, bin->export_directory->AddressOfNames);\n\t\tordinals_paddr = bin_pe_rva_to_paddr (bin, bin->export_directory->AddressOfOrdinals);\n\t\tfor (i = 0; i < bin->export_directory->NumberOfFunctions; i++) {\n\t\t\t// get vaddr from AddressOfFunctions array\n\t\t\tint ret = r_buf_read_at (bin->b, functions_paddr + i * sizeof(PE_VWord), (ut8*) &function_rva, sizeof(PE_VWord));\n\t\t\tif (ret < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// have exports by name?\n\t\t\tif (bin->export_directory->NumberOfNames != 0) {\n\t\t\t\t// search for value of i into AddressOfOrdinals\n\t\t\t\tname_vaddr = 0;\n\t\t\t\tfor (n = 0; n < bin->export_directory->NumberOfNames; n++) {\n\t\t\t\t\tret = r_buf_read_at (bin->b, ordinals_paddr + n * sizeof(PE_Word), (ut8*) &function_ordinal, sizeof (PE_Word));\n\t\t\t\t\tif (ret < 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// if exist this index into AddressOfOrdinals\n\t\t\t\t\tif (i == function_ordinal) {\n\t\t\t\t\t\t// get the VA of export name  from AddressOfNames\n\t\t\t\t\t\tr_buf_read_at (bin->b, names_paddr + n * sizeof (PE_VWord), (ut8*) &name_vaddr, sizeof (PE_VWord));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// have an address into name_vaddr?\n\t\t\t\tif (name_vaddr) {\n\t\t\t\t\t// get the name of the Export\n\t\t\t\t\tname_paddr = bin_pe_rva_to_paddr (bin, name_vaddr);\n\t\t\t\t\tif (r_buf_read_at (bin->b, name_paddr, (ut8*) function_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\t\tbprintf (\"Warning: read (function name)\\n\");\n\t\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\t\treturn exports;\n\t\t\t\t\t}\n\t\t\t\t} else { // No name export, get the ordinal\n\t\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + 1);\n\t\t\t\t}\n\t\t\t}else { // if dont export by name exist, get the ordinal taking in mind the Base value.\n\t\t\t\tfunction_ordinal = i + bin->export_directory->Base;\n\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", function_ordinal);\n\t\t\t}\n\t\t\t// check if VA are into export directory, this mean a forwarder export\n\t\t\tif (function_rva >= export_dir_rva && function_rva < (export_dir_rva + export_dir_size)) {\n\t\t\t\t// if forwarder, the VA point to Forwarded name\n\t\t\t\tif (r_buf_read_at (bin->b, bin_pe_rva_to_paddr (bin, function_rva), (ut8*) forwarder_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\treturn exports;\n\t\t\t\t}\n\t\t\t} else { // no forwarder export\n\t\t\t\tsnprintf (forwarder_name, PE_NAME_LENGTH, \"NONE\");\n\t\t\t}\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tfunction_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tsnprintf (export_name, sizeof (export_name) - 1, \"%s_%s\", dll_name, function_name);\n\t\t\texports[i].vaddr = bin_pe_rva_to_va (bin, function_rva);\n\t\t\texports[i].paddr = bin_pe_rva_to_paddr (bin, function_rva);\n\t\t\texports[i].ordinal = function_ordinal;\n\t\t\tmemcpy (exports[i].forwarder, forwarder_name, PE_NAME_LENGTH);\n\t\t\texports[i].forwarder[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy (exports[i].name,      export_name,    PE_NAME_LENGTH);\n\t\t\texports[i].name[PE_NAME_LENGTH] = '\\0';\n\t\t\texports[i].last = 0;\n\t\t}\n\t\texports[i].last = 1;\n\t}\n\texp = parse_symbol_table (bin, exports, exports_sz - 1);\n\tif (exp) {\n\t\texports = exp;\n\t}\n\treturn exports;\n}\n\nstatic void free_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tR_FREE (rsds_hdr->file_name);\n}\n\nstatic void init_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tmemset (rsds_hdr, 0, sizeof (SCV_RSDS_HEADER));\n\trsds_hdr->free = (void (*)(struct SCV_RSDS_HEADER*))free_rsdr_hdr;\n}\n\nstatic void free_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tR_FREE (cv_nb10_header->file_name);\n}\n\nstatic void init_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tmemset (cv_nb10_header, 0, sizeof (SCV_NB10_HEADER));\n\tcv_nb10_header->free = (void (*)(struct SCV_NB10_HEADER*))free_cv_nb10_header;\n}\n\nstatic bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {\n\tconst int rsds_sz = 4 + sizeof (SGUID) + 4;\n\tif (dbg_data_len < rsds_sz) {\n\t\treturn false;\n\t}\n\tmemcpy (res, dbg_data, rsds_sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + rsds_sz);\n\treturn true;\n}\n\nstatic void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}\n\nstatic int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n\t#define SIZEOF_FILE_NAME 255\n\tint i = 0;\n\tconst char* basename;\n\tif (!dbg_data) {\n\t\treturn 0;\n\t}\n\tswitch (dbg_dir_entry->Type) {\n\tcase IMAGE_DEBUG_TYPE_CODEVIEW:\n\t\tif (!strncmp ((char*) dbg_data, \"RSDS\", 4)) {\n\t\t\tSCV_RSDS_HEADER rsds_hdr;\n\t\t\tinit_rsdr_hdr (&rsds_hdr);\n\t\t\tif (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {\n\t\t\t\tbprintf (\"Warning: Cannot read PE debug info\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsnprintf (res->guidstr, GUIDSTR_LEN,\n\t\t\t\t\"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\",\n\t\t\t\trsds_hdr.guid.data1,\n\t\t\t\trsds_hdr.guid.data2,\n\t\t\t\trsds_hdr.guid.data3,\n\t\t\t\trsds_hdr.guid.data4[0],\n\t\t\t\trsds_hdr.guid.data4[1],\n\t\t\t\trsds_hdr.guid.data4[2],\n\t\t\t\trsds_hdr.guid.data4[3],\n\t\t\t\trsds_hdr.guid.data4[4],\n\t\t\t\trsds_hdr.guid.data4[5],\n\t\t\t\trsds_hdr.guid.data4[6],\n\t\t\t\trsds_hdr.guid.data4[7],\n\t\t\t\trsds_hdr.age);\n\t\t\tbasename = r_file_basename ((char*) rsds_hdr.file_name);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tbasename, sizeof (res->file_name));\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n\t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n\t\t\tSCV_NB10_HEADER nb10_hdr;\n\t\t\tinit_cv_nb10_header (&nb10_hdr);\n\t\t\tget_nb10 (dbg_data, &nb10_hdr);\n\t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n\t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tnb10_hdr.file_name, sizeof(res->file_name) - 1);\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n\t\t} else {\n\t\t\tbprintf (\"CodeView section not NB10 or RSDS\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//bprintf(\"get_debug_info(): not supported type\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (i < 33) {\n\t\tres->guidstr[i] = toupper ((int) res->guidstr[i]);\n\t\ti++;\n\t}\n\n\treturn 1;\n}\n\nint PE_(r_bin_pe_get_debug_data)(struct PE_(r_bin_pe_obj_t)* bin, SDebugInfo* res) {\n\tPE_(image_debug_directory_entry)* img_dbg_dir_entry = NULL;\n\tPE_(image_data_directory) * dbg_dir;\n\tPE_DWord dbg_dir_offset;\n\tut8* dbg_data = 0;\n\tint result = 0;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tdbg_dir = &bin->nt_headers->optional_header.DataDirectory[6 /*IMAGE_DIRECTORY_ENTRY_DEBUG*/];\n\tdbg_dir_offset = bin_pe_rva_to_paddr (bin, dbg_dir->VirtualAddress);\n\tif ((int) dbg_dir_offset < 0 || dbg_dir_offset >= bin->size) {\n\t\treturn false;\n\t}\n\tif (dbg_dir_offset >= bin->b->length) {\n\t\treturn false;\n\t}\n\timg_dbg_dir_entry = (PE_(image_debug_directory_entry)*)(bin->b->buf + dbg_dir_offset);\n\tif ((bin->b->length - dbg_dir_offset) < sizeof (PE_(image_debug_directory_entry))) {\n\t\treturn false;\n\t}\n\tif (img_dbg_dir_entry) {\n\t\tut32 dbg_data_poff = R_MIN (img_dbg_dir_entry->PointerToRawData, bin->b->length);\n\t\tint dbg_data_len = R_MIN (img_dbg_dir_entry->SizeOfData, bin->b->length - dbg_data_poff);\n\t\tif (dbg_data_len < 1) {\n\t\t\treturn false;\n\t\t}\n\t\tdbg_data = (ut8*) calloc (1, dbg_data_len + 1);\n\t\tif (dbg_data) {\n\t\t\tr_buf_read_at (bin->b, dbg_data_poff, dbg_data, dbg_data_len);\n\t\t\tresult = get_debug_info (bin, img_dbg_dir_entry, dbg_data, dbg_data_len, res);\n\t\t\tR_FREE (dbg_data);\n\t\t}\n\t}\n\treturn result;\n}\n\nstruct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_import_t* imps, * imports = NULL;\n\tchar dll_name[PE_NAME_LENGTH + 1];\n\tint nimp = 0;\n\tut64 off; //used to cache value\n\tPE_DWord dll_name_offset = 0;\n\tPE_DWord paddr = 0;\n\tPE_DWord import_func_name_offset;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = 0;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->import_directory_offset >= bin->size) {\n\t\treturn NULL;\n\t}\n\tif (bin->import_directory_offset + 32 >= bin->size) {\n\t\treturn NULL;\n\t}\n\n\toff = bin->import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tvoid* last;\n\t\tif (off + sizeof(PE_(image_import_directory)) > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcurr_import_dir = (PE_(image_import_directory)*)(bin->b->buf + bin->import_directory_offset);\n\t\tdll_name_offset = curr_import_dir->Name;\n\n\t\tif (bin->import_directory_size < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (off + bin->import_directory_size > bin->size) {\n\t\t\t//why chopping instead of returning and cleaning?\n\t\t\tbprintf (\"Warning: read (import directory too big)\\n\");\n\t\t\tbin->import_directory_size = bin->size - bin->import_directory_offset;\n\t\t}\n\t\tlast = (char*) curr_import_dir + bin->import_directory_size;\n\t\twhile ((void*) (curr_import_dir + 1) <= last && (\n\t\t\tcurr_import_dir->FirstThunk != 0 || curr_import_dir->Name != 0 ||\n\t\t\tcurr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||\n\t\t\tcurr_import_dir->ForwarderChain != 0)) {\n\t\t\tint rr;\n\t\t\tdll_name_offset = curr_import_dir->Name;\n\t\t\tpaddr = bin_pe_rva_to_paddr (bin, dll_name_offset);\n\t\t\tif (paddr > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (paddr + PE_NAME_LENGTH > bin->size) {\n\t\t\t\trr = r_buf_read_at (bin->b, paddr, (ut8*) dll_name, bin->size - paddr);\n\t\t\t\tif (rr != bin->size - paddr) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[bin->size - paddr] = '\\0';\n\t\t\t}else {\n\t\t\t\trr = r_buf_read_at (bin->b, paddr, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\t\tif (rr != PE_NAME_LENGTH) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\t}\n\t\t\tif (!bin_pe_parse_imports (bin, &imports, &nimp, dll_name,\n\t\t\t\tcurr_import_dir->Characteristics,\n\t\t\t\tcurr_import_dir->FirstThunk)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurr_import_dir++;\n\t\t}\n\t}\n\toff = bin->delay_import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tif (off + sizeof(PE_(image_delay_import_directory)) > bin->size) {\n\t\t\tgoto beach;\n\t\t}\n\t\tcurr_delay_import_dir = (PE_(image_delay_import_directory)*)(bin->b->buf + off);\n\t\tif (!curr_delay_import_dir->Attributes) {\n\t\t\tdll_name_offset = bin_pe_rva_to_paddr (bin,\n\t\t\t\tcurr_delay_import_dir->Name - PE_(r_bin_pe_get_image_base)(bin));\n\t\t\timport_func_name_offset = curr_delay_import_dir->DelayImportNameTable -\n\t\t\tPE_(r_bin_pe_get_image_base)(bin);\n\t\t} else {\n\t\t\tdll_name_offset = bin_pe_rva_to_paddr (bin, curr_delay_import_dir->Name);\n\t\t\timport_func_name_offset = curr_delay_import_dir->DelayImportNameTable;\n\t\t}\n\t\twhile ((curr_delay_import_dir->Name != 0) && (curr_delay_import_dir->DelayImportAddressTable !=0)) {\n\t\t\tif (dll_name_offset > bin->size || dll_name_offset + PE_NAME_LENGTH > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tint rr = r_buf_read_at (bin->b, dll_name_offset, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\tif (rr < 5) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tif (!bin_pe_parse_imports (bin, &imports, &nimp, dll_name, import_func_name_offset,\n\t\t\t\tcurr_delay_import_dir->DelayImportAddressTable)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((char*) (curr_delay_import_dir + 2) > (char*) (bin->b->buf + bin->size)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tcurr_delay_import_dir++;\n\t\t}\n\t}\nbeach:\n\tif (nimp) {\n\t\timps = realloc (imports, (nimp + 1) * sizeof(struct r_bin_pe_import_t));\n\t\tif (!imps) {\n\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\treturn NULL;\n\t\t}\n\t\timports = imps;\n\t\timports[nimp].last = 1;\n\t}\n\treturn imports;\n}\n\nstruct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_pe_lib_t* libs = NULL;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = NULL;\n\tPE_DWord name_off = 0;\n\tSdbHash* lib_map = NULL;\n\tut64 off; //cache value\n\tint index = 0;\n\tint len = 0;\n\tint max_libs = 20;\n\tlibs = calloc (max_libs + 1, sizeof(struct r_bin_pe_lib_t));\n\tif (!libs) {\n\t\tr_sys_perror (\"malloc (libs)\");\n\t\treturn NULL;\n\t}\n\n\tif (bin->import_directory_offset + bin->import_directory_size > bin->size) {\n\t\tbprintf (\"import directory offset bigger than file\\n\");\n\t\tgoto out_error;\n\t}\n\tlib_map = sdb_ht_new ();\n\toff = bin->import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tvoid* last = NULL;\n\t\t// normal imports\n\t\tif (off + sizeof (PE_(image_import_directory)) > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurr_import_dir = (PE_(image_import_directory)*)(bin->b->buf + off);\n\t\tlast = (char*) curr_import_dir + bin->import_directory_size;\n\t\twhile ((void*) (curr_import_dir + 1) <= last && (\n\t\t\tcurr_import_dir->FirstThunk || curr_import_dir->Name ||\n\t\t\tcurr_import_dir->TimeDateStamp || curr_import_dir->Characteristics ||\n\t\t\tcurr_import_dir->ForwarderChain)) {\n\t\t\tname_off = bin_pe_rva_to_paddr (bin, curr_import_dir->Name);\n\t\t\tlen = r_buf_read_at (bin->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (!libs[index].name[0]) { // minimum string length\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (len < 2 || libs[index].name[0] == 0) { // minimum string length\n\t\t\t\tbprintf (\"Warning: read (libs - import dirs) %d\\n\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tlibs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!libs) {\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\tgoto out_error;\n\t\t\t\t\t}\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tcurr_import_dir++;\n\t\t}\n\t}\n\toff = bin->delay_import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tif (off + sizeof(PE_(image_delay_import_directory)) > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurr_delay_import_dir = (PE_(image_delay_import_directory)*)(bin->b->buf + off);\n\t\twhile (curr_delay_import_dir->Name != 0 && curr_delay_import_dir->DelayImportNameTable != 0) {\n\t\t\tname_off = bin_pe_rva_to_paddr (bin, curr_delay_import_dir->Name);\n\t\t\tif (name_off > bin->size || name_off + PE_STRING_LENGTH > bin->size) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tlen = r_buf_read_at (bin->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (len != PE_STRING_LENGTH) {\n\t\t\t\tbprintf (\"Warning: read (libs - delay import dirs)\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tlibs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!libs) {\n\t\t\t\t\t\tsdb_ht_free (lib_map);\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr_delay_import_dir++;\n\t\t\tif ((const ut8*) (curr_delay_import_dir + 1) >= (const ut8*) (bin->b->buf + bin->size)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsdb_ht_free (lib_map);\n\tlibs[index].last = 1;\n\treturn libs;\nout_error:\n\tsdb_ht_free (lib_map);\n\tfree (libs);\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_image_size)(struct PE_(r_bin_pe_obj_t)* bin) {\n\treturn bin->nt_headers->optional_header.SizeOfImage;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_machine)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* machine = NULL;\n\n\tif (bin && bin->nt_headers) {\n\t\tswitch (bin->nt_headers->file_header.Machine) {\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA: machine = \"Alpha\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA64: machine = \"Alpha 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AM33: machine = \"AM33\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AMD64: machine = \"AMD 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ARM: machine = \"ARM\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEE: machine = \"CEE\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEF: machine = \"CEF\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_EBC: machine = \"EBC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_I386: machine = \"i386\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_IA64: machine = \"ia64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M32R: machine = \"M32R\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M68K: machine = \"M68K\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPS16: machine = \"Mips 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU: machine = \"Mips FPU\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16: machine = \"Mips FPU 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPC: machine = \"PowerPC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP: machine = \"PowerPC FP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R10000: machine = \"R10000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R3000: machine = \"R3000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R4000: machine = \"R4000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3: machine = \"SH3\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3DSP: machine = \"SH3DSP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3E: machine = \"SH3E\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH4: machine = \"SH4\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH5: machine = \"SH5\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_THUMB: machine = \"Thumb\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_TRICORE: machine = \"Tricore\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2: machine = \"WCE Mips V2\"; break;\n\t\tdefault: machine = \"unknown\";\n\t\t}\n\t}\n\treturn machine? strdup (machine): NULL;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_os)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* os;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn NULL;\n\t}\n\tswitch (bin->nt_headers->optional_header.Subsystem) {\n\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\tos = strdup (\"native\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\tos = strdup (\"windows\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\tos = strdup (\"posix\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\tos = strdup (\"efi\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\tos = strdup (\"xbox\");\n\t\tbreak;\n\tdefault:\n\t\t// XXX: this is unknown\n\t\tos = strdup (\"windows\");\n\t}\n\treturn os;\n}\n\n// TODO: make it const\nchar* PE_(r_bin_pe_get_class)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (bin && bin->nt_headers) {\n\t\tswitch (bin->nt_headers->optional_header.Magic) {\n\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"PE32\");\n\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"PE32+\");\n\t\tdefault: return strdup (\"Unknown\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_bits)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tint bits = 32;\n\tif (bin && bin->nt_headers) {\n\t\tif (is_arm (bin)) {\n\t\t\tif (is_thumb (bin)) {\n\t\t\t\tbits = 16;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (bin->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: bits = 32; break;\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: bits = 64; break;\n\t\t\tdefault: bits = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn bits;\n}\n\n//This function try to detect anomalies within section\n//we check if there is a section mapped at entrypoint, otherwise add it up\nvoid PE_(r_bin_pe_check_sections)(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_section_t* * sects) {\n\tint i = 0;\n\tstruct r_bin_pe_section_t* sections = *sects;\n\tut64 addr_beg, addr_end, new_section_size, new_perm, base_addr;\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (bin);\n\n\tif (!entry) {\n\t\treturn;\n\t}\n\tnew_section_size = bin->size;\n\tnew_section_size -= entry->paddr > bin->size? 0: entry->paddr;\n\tnew_perm = (PE_IMAGE_SCN_MEM_READ | PE_IMAGE_SCN_MEM_WRITE | PE_IMAGE_SCN_MEM_EXECUTE);\n\tbase_addr = PE_(r_bin_pe_get_image_base) (bin);\n\n\tfor (i = 0; !sections[i].last; i++) {\n\t\t//strcmp against .text doesn't work in somes cases\n\t\tif (strstr ((const char*) sections[i].name, \"text\")) {\n\t\t\tbool fix = false;\n\t\t\tint j;\n\t\t\t//check paddr boundaries\n\t\t\taddr_beg = sections[i].paddr;\n\t\t\taddr_end = addr_beg + sections[i].size;\n\t\t\tif (entry->paddr < addr_beg || entry->paddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//check vaddr boundaries\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//look for other segment with x that is already mapped and hold entrypoint\n\t\t\tfor (j = 0; !sections[j].last; j++) {\n\t\t\t\tif (sections[j].flags & PE_IMAGE_SCN_MEM_EXECUTE) {\n\t\t\t\t\taddr_beg = sections[j].paddr;\n\t\t\t\t\taddr_end = addr_beg + sections[j].size;\n\t\t\t\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\t\t\t\tif (!sections[j].vsize) {\n\t\t\t\t\t\t\tsections[j].vsize = sections[j].size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddr_beg = sections[j].vaddr + base_addr;\n\t\t\t\t\t\taddr_end = addr_beg + sections[j].vsize;\n\t\t\t\t\t\tif (addr_beg <= entry->vaddr || entry->vaddr < addr_end) {\n\t\t\t\t\t\t\tfix = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//if either vaddr or paddr fail we should update this section\n\t\t\tif (fix) {\n\t\t\t\tstrcpy ((char*) sections[i].name, \"blob\");\n\t\t\t\tsections[i].paddr = entry->paddr;\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t\tsections[i].size = sections[i].vsize = new_section_size;\n\t\t\t\tsections[i].flags = new_perm;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//if we arrive til here means there is no text section find one that is holding the code\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tif (sections[i].size > bin->size) {\n\t\t\tcontinue;\n\t\t}\n\t\taddr_beg = sections[i].paddr;\n\t\taddr_end = addr_beg + sections[i].size;\n\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\tif (!sections[i].vsize) {\n\t\t\t\tsections[i].vsize = sections[i].size;\n\t\t\t}\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//we need to create another section in order to load the entrypoint\n\tsections = realloc (sections, (bin->num_sections + 2) * sizeof(struct r_bin_pe_section_t));\n\ti = bin->num_sections;\n\tsections[i].last = 0;\n\tstrcpy ((char*) sections[i].name, \"blob\");\n\tsections[i].paddr = entry->paddr;\n\tsections[i].vaddr = entry->vaddr - base_addr;\n\tsections[i].size = sections[i].vsize = new_section_size;\n\tsections[i].flags = new_perm;\n\tsections[i + 1].last = 1;\n\t*sects = sections;\nout_function:\n\tfree (entry);\n\treturn;\n\n}\n\nstruct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_section_t* sections = NULL;\n\tPE_(image_section_header) * shdr;\n\tint i, j, section_count = 0;\n\n\tif (!bin || !bin->nt_headers) {\n\t\treturn NULL;\n\t}\n\tshdr = bin->section_header;\n\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t//just allocate the needed\n\t\tif (shdr[i].SizeOfRawData || shdr[i].Misc.VirtualSize) {\n\t\t\tsection_count++;\n\t\t}\n\t}\n\tsections = calloc (section_count + 1, sizeof(struct r_bin_pe_section_t));\n\tif (!sections) {\n\t\tr_sys_perror (\"malloc (sections)\");\n\t\treturn NULL;\n\t}\n\tfor (i = 0, j = 0; i < bin->num_sections; i++) {\n\t\t//if sz = 0 r_io_section_add will not add it so just skeep\n\t\tif (!shdr[i].SizeOfRawData && !shdr[i].Misc.VirtualSize) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (shdr[i].Name[0] == '\\0') {\n\t\t\tchar* new_name = r_str_newf (\"sect_%d\", j);\n\t\t\tstrncpy ((char*) sections[j].name, new_name, R_ARRAY_SIZE (sections[j].name) - 1);\n\t\t\tfree (new_name);\n\t\t} else if (shdr[i].Name[0] == '/') {\n\t\t\t//long name is something deprecated but still used\n\t\t\tint idx = atoi ((const char *)shdr[i].Name + 1);\n\t\t\tut64 sym_tbl_off = bin->nt_headers->file_header.PointerToSymbolTable;\n\t\t\tint num_symbols = bin->nt_headers->file_header.NumberOfSymbols;\n\t\t\tint off = num_symbols * COFF_SYMBOL_SIZE;\n\t\t\tif (sym_tbl_off &&\n\t\t\t    sym_tbl_off + off + idx < bin->size &&\n\t\t\t    sym_tbl_off + off + idx > off) {\n\t\t\t\tint sz = PE_IMAGE_SIZEOF_SHORT_NAME * 3;\n\t\t\t\tchar* buf[64] = {0};\n\t\t\t\tif (r_buf_read_at (bin->b,\n\t\t\t\t\t\t   sym_tbl_off + off + idx,\n\t\t\t\t\t\t   (ut8*)buf, 64)) {\n\t\t\t\t\tmemcpy (sections[j].name, buf, sz);\n\t\t\t\t\tsections[j].name[sz - 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy (sections[j].name, shdr[i].Name, PE_IMAGE_SIZEOF_SHORT_NAME);\n\t\t\tsections[j].name[PE_IMAGE_SIZEOF_SHORT_NAME] = '\\0';\n\t\t}\n\t\tsections[j].vaddr = shdr[i].VirtualAddress;\n\t\tsections[j].size = shdr[i].SizeOfRawData;\n\t\tsections[j].vsize = shdr[i].Misc.VirtualSize;\n\t\tif (bin->optional_header) {\n\t\t\tint sa = R_MAX (bin->optional_header->SectionAlignment, 0x1000);\n\t\t\tut64 diff = sections[j].vsize % sa;\n\t\t\tif (diff) {\n\t\t\t\tsections[j].vsize += sa - diff;\n\t\t\t}\n\t\t}\n\t\tsections[j].paddr = shdr[i].PointerToRawData;\n\t\tsections[j].flags = shdr[i].Characteristics;\n\t\tsections[j].last = 0;\n\t\tj++;\n\t}\n\tsections[j].last = 1;\n\tbin->num_sections = section_count;\n\treturn sections;\n}\n\nchar* PE_(r_bin_pe_get_subsystem)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* subsystem = NULL;\n\tif (bin && bin->nt_headers) {\n\t\tswitch (bin->nt_headers->optional_header.Subsystem) {\n\t\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\t\tsubsystem = \"Native\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\t\t\tsubsystem = \"Windows GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\t\t\tsubsystem = \"Windows CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\t\tsubsystem = \"POSIX CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\t\tsubsystem = \"Windows CE GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\t\t\tsubsystem = \"EFI Application\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\t\t\tsubsystem = \"EFI Boot Service Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\t\t\tsubsystem = \"EFI Runtime Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\t\tsubsystem = \"EFI ROM\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\t\tsubsystem = \"XBOX\"; break;\n\t\tdefault:\n\t\t\tsubsystem = \"Unknown\"; break;\n\t\t}\n\t}\n\treturn subsystem? strdup (subsystem): NULL;\n}\n\n#define HASCHR(x) bin->nt_headers->file_header.Characteristics & x\n\nint PE_(r_bin_pe_is_dll)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DLL);\n}\n\nint PE_(r_bin_pe_is_pie)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE);\n#if 0\n\tBOOL aslr = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;\n//TODO: implement dep?\n\tBOOL dep = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT;\n#endif\n}\n\nint PE_(r_bin_pe_is_big_endian)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tut16 arch;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\tarch = bin->nt_headers->file_header.Machine;\n\tif (arch == PE_IMAGE_FILE_MACHINE_I386 ||\n\tarch == PE_IMAGE_FILE_MACHINE_AMD64) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_BYTES_REVERSED_HI);\n}\n\nint PE_(r_bin_pe_is_stripped_relocs)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_RELOCS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_line_nums)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LINE_NUMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_local_syms)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_debug)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DEBUG_STRIPPED);\n}\n\n\nvoid* PE_(r_bin_pe_free)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tfree (bin->dos_header);\n\tfree (bin->nt_headers);\n\tfree (bin->section_header);\n\tfree (bin->export_directory);\n\tfree (bin->import_directory);\n\tfree (bin->resource_directory);\n\tfree (bin->delay_import_directory);\n\tfree (bin->tls_directory);\n\tr_list_free (bin->resources);\n\tr_pkcs7_free_cms (bin->cms);\n\tr_buf_free (bin->b);\n\tbin->b = NULL;\n\tfree (bin);\n\treturn NULL;\n}\n\nstruct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file, bool verbose) {\n\tut8* buf;\n\tstruct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->file = file;\n\tif (!(buf = (ut8*) r_file_slurp (file, &bin->size))) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tbin->verbose = verbose;\n\tfree (buf);\n\tif (!bin_pe_init (bin)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\treturn bin;\n}\n\nstruct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(RBuffer * buf, bool verbose) {\n\tstruct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->kv = sdb_new0 ();\n\tbin->b = r_buf_new ();\n\tbin->verbose = verbose;\n\tbin->size = buf->length;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, bin->size)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tif (!bin_pe_init (bin)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\treturn bin;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2008-2017 nibble, pancake, inisider */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"pe.h\"\n#include <time.h>\n\n#define PE_IMAGE_FILE_MACHINE_RPI2 452\n#define MAX_METADATA_STRING_LENGTH 256\n#define bprintf if(bin->verbose) eprintf\n#define COFF_SYMBOL_SIZE 18\n\nstruct SCV_NB10_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tut32 offset;\n\tut32 timestamp;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_NB10_HEADER* cv_nb10_header);\n} SCV_NB10_HEADER;\n\ntypedef struct {\n\tut32 data1;\n\tut16 data2;\n\tut16 data3;\n\tut8 data4[8];\n} SGUID;\n\nstruct SCV_RSDS_HEADER;\ntypedef struct {\n\tut8 signature[4];\n\tSGUID guid;\n\tut32 age;\n\tut8* file_name;\n\tvoid (* free)(struct SCV_RSDS_HEADER* rsds_hdr);\n} SCV_RSDS_HEADER;\n\nstatic inline int is_thumb(struct PE_(r_bin_pe_obj_t)* bin) {\n\treturn bin->nt_headers->optional_header.AddressOfEntryPoint & 1;\n}\n\nstatic inline int is_arm(struct PE_(r_bin_pe_obj_t)* bin) {\n\tswitch (bin->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_msvcseh) (struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t* entry;\n\tut8 b[512];\n\tint n = 0;\n\tif (!bin || !bin->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (bin);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tbprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t// MSVC SEH\n\t// E8 13 09 00 00  call    0x44C388\n\t// E9 05 00 00 00  jmp     0x44BA7F\n\tif (b[0] == 0xe8 && b[5] == 0xe9) {\n\t\tconst st32 jmp_dst = r_read_ble32 (b + 6, bin->big_endian);\n\t\tentry->paddr += (5 + 5 + jmp_dst);\n\t\tentry->vaddr += (5 + 5 + jmp_dst);\n\t\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) > 0) {\n\t\t\t// case1:\n\t\t\t// from des address of jmp search for 68 xx xx xx xx e8 and test xx xx xx xx = imagebase\n\t\t\t// 68 00 00 40 00  push    0x400000\n\t\t\t// E8 3E F9 FF FF  call    0x44B4FF\n\t\t\tut32 imageBase = bin->nt_headers->optional_header.ImageBase;\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tconst ut32 tmp_imgbase = r_read_ble32 (b + n + 1, bin->big_endian);\n\t\t\t\tif (b[n] == 0x68 && tmp_imgbase == imageBase && b[n + 5] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 6, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case2:\n\t\t\t// from des address of jmp search for 50 FF xx FF xx E8\n\t\t\t//50\t\t\t push    eax\n\t\t\t//FF 37\t\t\t push    dword ptr[edi]\n\t\t\t//FF 36          push    dword ptr[esi]\n\t\t\t//E8 6F FC FF FF call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 6; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n+1] == 0xff && b[n + 3] == 0xff && b[n + 5] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 6, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 5 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case3:\n\t\t\t//50                                         push    eax\n\t\t\t//FF 35 0C E2 40 00                          push    xxxxxxxx\n\t\t\t//FF 35 08 E2 40 00                          push    xxxxxxxx\n\t\t\t//E8 2B FD FF FF                             call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 20; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0xff && b[n + 7] == 0xff && b[n + 13] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 14, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 13 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 13 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//case4:\n\t\t\t//50                                        push    eax\n\t\t\t//57                                        push    edi\n\t\t\t//FF 36                                     push    dword ptr[esi]\n\t\t\t//E8 D9 FD FF FF                            call    _main\n\t\t\tfor (n = 0; n < sizeof (b) - 5; n++) {\n\t\t\t\tif (b[n] == 0x50 && b[n + 1] == 0x57 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 5, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 4 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 4 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t// MSVC AMD64\n\t// 48 83 EC 28       sub     rsp, 0x28\n\t// E8 xx xx xx xx    call    xxxxxxxx\n\t// 48 83 C4 28       add     rsp, 0x28\n\t// E9 xx xx xx xx    jmp     xxxxxxxx\n\tif (b[4] == 0xe8 && b[13] == 0xe9) {\n\t\t//const st32 jmp_dst = b[14] | (b[15] << 8) | (b[16] << 16) | (b[17] << 24);\n\t\tconst st32 jmp_dst = r_read_ble32 (b + 14, bin->big_endian);\n\t\tentry->paddr += (5 + 13 + jmp_dst);\n\t\tentry->vaddr += (5 + 13 + jmp_dst);\n\t\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) > 0) {\n\t\t\t// from des address of jmp, search for 4C ... 48 ... 8B ... E8\n\t\t\t// 4C 8B C0                    mov     r8, rax\n\t\t\t// 48 8B 17                    mov     rdx, qword [rdi]\n\t\t\t// 8B 0B                       mov     ecx, dword [rbx]\n\t\t\t// E8 xx xx xx xx              call    main\n\t\t\tfor (n = 0; n < sizeof (b) - 13; n++) {\n\t\t\t\tif (b[n] == 0x4c && b[n + 3] == 0x48 && b[n + 6] == 0x8b && b[n + 8] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = r_read_ble32 (b + n + 9, bin->big_endian);\n\t\t\t\t\tentry->paddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//Microsoft Visual-C\n\t// 50                  push eax\n\t// FF 75 9C            push dword [ebp - local_64h]\n\t// 56                  push    esi\n\t// 56                  push    esi\n\t// FF 15 CC C0  44 00  call dword [sym.imp.KERNEL32.dll_GetModuleHandleA]\n\t// 50                  push    eax\n\t// E8 DB DA 00 00      call    main\n\t// 89 45 A0            mov dword [ebp - local_60h], eax\n\t// 50                  push    eax\n\t// E8 2D 00 00  00     call 0x4015a6\n\tif (b[188] == 0x50 && b[201] == 0xe8) {\n\t\tconst st32 call_dst = r_read_ble32 (b + 202, bin->big_endian);\n\t\tentry->paddr += (201 + 5 + call_dst);\n\t\tentry->vaddr += (201 + 5 + call_dst);\n\t\treturn entry;\n\t}\n\n\tif (b[292] == 0x50 && b[303] == 0xe8) {\n\t\tconst st32 call_dst = r_read_ble32 (b + 304, bin->big_endian);\n\t\tentry->paddr += (303 + 5 + call_dst);\n\t\tentry->vaddr += (303 + 5 + call_dst);\n\t\treturn entry;\n\t}\n\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_mingw) (struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t* entry;\n\tint sw = 0;\n\tut8 b[1024];\n\tint n = 0;\n\tif (!bin || !bin->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (bin);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tbprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\t// mingw\n\t//55                                         push    ebp\n\t//89 E5                                      mov     ebp, esp\n\t//83 EC 08                                   sub     esp, 8\n\t//C7 04 24 01 00 00 00                       mov     dword ptr[esp], 1\n\t//FF 15 C8 63 41 00                          call    ds : __imp____set_app_type\n\t//E8 B8 FE FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[20]);\n\t\tentry->paddr += (5 + 19 + jmp_dst);\n\t\tentry->vaddr += (5 + 19 + jmp_dst);\n\t\tsw = 1;\n\t}\n\t//83 EC 1C                                   sub     esp, 1Ch\n\t//C7 04 24 01 00 00 00                       mov[esp + 1Ch + var_1C], 1\n\t//FF 15 F8 60 40 00                          call    ds : __imp____set_app_type\n\t//E8 6B FD FF FF                             call    ___mingw_CRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[17]);\n\t\tentry->paddr += (5 + 16 + jmp_dst);\n\t\tentry->vaddr += (5 + 16 + jmp_dst);\n\t\tsw = 1;\n\t}\n\t//83 EC 0C                                            sub     esp, 0Ch\n\t//C7 05 F4 0A 81 00 00 00 00 00                       mov     ds : _mingw_app_type, 0\n\t//ED E8 3E AD 24 00                                      call    ___security_init_cookie\n\t//F2 83 C4 0C                                            add     esp, 0Ch\n\t//F5 E9 86 FC FF FF                                      jmp     ___tmainCRTStartup\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[22]);\n\t\tentry->paddr += (5 + 21 + jmp_dst);\n\t\tentry->vaddr += (5 + 21 + jmp_dst);\n\t\tsw = 1;\n\t}\n\tif (sw) {\n\t\tif (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) > 0) {\n\t\t\t// case1:\n\t\t\t// from des address of call search for a1 xx xx xx xx 89 xx xx e8 xx xx xx xx\n\t\t\t//A1 04 50 44 00                             mov     eax, ds:dword_445004\n\t\t\t//89 04 24                                   mov[esp + 28h + lpTopLevelExceptionFilter], eax\n\t\t\t//E8 A3 01 00 00                             call    sub_4013EE\n\t\t\t// ut32 imageBase = bin->nt_headers->optional_header.ImageBase;\n\t\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = (st32) r_read_le32 (&b[n + 9]);\n\t\t\t\t\tentry->paddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\tentry->vaddr += (n + 5 + 8 + call_dst);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(check_unknow) (struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!bin || !bin->b) {\n\t\treturn 0LL;\n\t}\n\tut8 *b = calloc (1, 512);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tentry = PE_ (r_bin_pe_get_entrypoint) (bin);\n\t// option2: /x 8bff558bec83ec20\n\tif (r_buf_read_at (bin->b, entry->paddr, b, 512) < 1) {\n\t\tbprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\tfree (b);\n\t\treturn NULL;\n\t}\n\t/* Decode the jmp instruction, this gets the address of the 'main'\n\t   function for PE produced by a compiler whose name someone forgot to\n\t   write down. */\n\t// this is dirty only a single byte check, can return false positives\n\tif (b[367] == 0xe8) {\n\t\tconst st32 jmp_dst = (st32) r_read_le32 (&b[368]);\n\t\tentry->paddr += 367 + 5 + jmp_dst;\n\t\tentry->vaddr += 367 + 5 + jmp_dst;\n\t\tfree (b);\n\t\treturn entry;\n\t}\n\tint i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\t// 5. ff 15 .. .. .. .. 50 e8 [main]\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i+6] == 0x50) {\n\t\t\t\tif (b[i+7] == 0xe8) {\n\t\t\t\t\tconst st32 call_dst = (st32) r_read_le32 (&b[i + 8]);\n\t\t\t\t\tentry->paddr = entry->vaddr - entry->paddr;\n\t\t\t\t\tentry->vaddr += (i + 7 + 5 + (long)call_dst);\n\t\t\t\t\tentry->paddr += entry->vaddr;\n\t\t\t\t\tfree (b);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\tfree (b);\n\treturn NULL;\n}\n\nstruct r_bin_pe_addr_t *PE_(r_bin_pe_get_main_vaddr)(struct PE_(r_bin_pe_obj_t) *bin) {\n\tstruct r_bin_pe_addr_t *winmain = PE_(check_msvcseh) (bin);\n\tif (!winmain) {\n\t\twinmain = PE_(check_mingw) (bin);\n\t\tif (!winmain) {\n\t\t\twinmain = PE_(check_unknow) (bin);\n\t\t}\n\t}\n\treturn winmain;\n}\n\n#define RBinPEObj struct PE_(r_bin_pe_obj_t)\nstatic PE_DWord bin_pe_rva_to_paddr(RBinPEObj* bin, PE_DWord rva) {\n\tPE_DWord section_base;\n\tint i, section_size;\n\tfor (i = 0; i < bin->num_sections; i++) {\n\t\tsection_base = bin->section_header[i].VirtualAddress;\n\t\tsection_size = bin->section_header[i].Misc.VirtualSize;\n\t\tif (rva >= section_base && rva < section_base + section_size) {\n\t\t\treturn bin->section_header[i].PointerToRawData + (rva - section_base);\n\t\t}\n\t}\n\treturn rva;\n}\n\nut64 PE_(r_bin_pe_get_image_base)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tut64 imageBase = 0;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn 0LL;\n\t}\n\timageBase = bin->nt_headers->optional_header.ImageBase;\n\tif (!imageBase) {\n\t\t//this should only happens with messed up binaries\n\t\t//XXX this value should be user defined by bin.baddr\n\t\t//but from here we can not access config API\n\t\timageBase = 0x10000;\n\t}\n\treturn imageBase;\n}\n\nstatic PE_DWord bin_pe_rva_to_va(RBinPEObj* bin, PE_DWord rva) {\n\treturn PE_(r_bin_pe_get_image_base) (bin) + rva;\n}\n\nstatic PE_DWord bin_pe_va_to_rva(RBinPEObj* bin, PE_DWord va) {\n\tut64 imageBase = PE_(r_bin_pe_get_image_base) (bin);\n\tif (va < imageBase) {\n\t\treturn va;\n\t}\n\treturn va - imageBase;\n}\n\nstatic char* resolveModuleOrdinal(Sdb* sdb, const char* module, int ordinal) {\n\tSdb* db = sdb;\n\tchar* foo = sdb_get (db, sdb_fmt (\"%d\", ordinal), 0);\n\tif (foo && *foo) {\n\t\treturn foo;\n\t} else {\n\t\tfree (foo); // should never happen\n\t}\n\treturn NULL;\n}\n\nstatic int bin_pe_parse_imports(struct PE_(r_bin_pe_obj_t)* bin,\n                                struct r_bin_pe_import_t** importp, int* nimp,\n                                const char* dll_name,\n                                PE_DWord OriginalFirstThunk,\n                                PE_DWord FirstThunk) {\n\tchar import_name[PE_NAME_LENGTH + 1];\n\tchar name[PE_NAME_LENGTH + 1];\n\tPE_Word import_hint, import_ordinal = 0;\n\tPE_DWord import_table = 0, off = 0;\n\tint i = 0, len;\n\tSdb* db = NULL;\n\tchar* sdb_module = NULL;\n\tchar* symname;\n\tchar* filename;\n\tchar* symdllname = NULL;\n\n\tif (!dll_name || *dll_name == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(off = bin_pe_rva_to_paddr (bin, OriginalFirstThunk)) &&\n\t!(off = bin_pe_rva_to_paddr (bin, FirstThunk))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (import_ordinal >= UT16_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (off + i * sizeof(PE_DWord) > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off + i * sizeof (PE_DWord), (ut8*) &import_table, sizeof (PE_DWord));\n\t\tif (len != sizeof (PE_DWord)) {\n\t\t\tbprintf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (import_table) {\n\t\t\tif (import_table & ILT_MASK1) {\n\t\t\t\timport_ordinal = import_table & ILT_MASK2;\n\t\t\t\timport_hint = 0;\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s_Ordinal_%i\", dll_name, import_ordinal);\n\t\t\t\tfree (symdllname);\n\t\t\t\tstrncpy (name, dll_name, sizeof (name) - 1);\n\t\t\t\tname[sizeof(name) - 1] = 0;\n\t\t\t\tsymdllname = strdup (name);\n\n\t\t\t\t// remove the trailling \".dll\"\n\t\t\t\tsize_t len = strlen (symdllname);\n\t\t\t\tr_str_case (symdllname, 0);\n\t\t\t\tlen = len < 4? 0: len - 4;\n\t\t\t\tsymdllname[len] = 0;\n\n\t\t\t\tif (!sdb_module || strcmp (symdllname, sdb_module)) {\n\t\t\t\t\tsdb_free (db);\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\tsdb_free (db);\n\t\t\t\t\t}\n\t\t\t\t\tdb = NULL;\n\t\t\t\t\tfree (sdb_module);\n\t\t\t\t\tsdb_module = strdup (symdllname);\n\t\t\t\t\tfilename = sdb_fmt (\"%s.sdb\", symdllname);\n\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n#if __WINDOWS__\n\t\t\t\t\t\tchar invoke_dir[MAX_PATH];\n\t\t\t\t\t\tif (r_sys_get_src_dir_w32 (invoke_dir)) {\n\t\t\t\t\t\t\tfilename = sdb_fmt (\"%s\\\\share\\\\radare2\\\\\"R2_VERSION \"\\\\format\\\\dll\\\\%s.sdb\", invoke_dir, symdllname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfilename = sdb_fmt (\"share/radare2/\"R2_VERSION \"/format/dll/%s.sdb\", symdllname);\n\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tfilename = sdb_fmt (\"%s/share/radare2/\" R2_VERSION \"/format/dll/%s.sdb\", dirPrefix, symdllname);\n#endif\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (db) {\n\t\t\t\t\tsymname = resolveModuleOrdinal (db, symdllname, import_ordinal);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s_%s\", dll_name, symname);\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbprintf (\"Cannot find %s\\n\", filename);\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\timport_ordinal++;\n\t\t\t\tconst ut64 off = bin_pe_rva_to_paddr (bin, import_table);\n\t\t\t\tif (off > bin->size || (off + sizeof (PE_Word)) > bin->size) {\n\t\t\t\t\tbprintf (\"Warning: off > bin->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tlen = r_buf_read_at (bin->b, off, (ut8*) &import_hint, sizeof (PE_Word));\n\t\t\t\tif (len != sizeof (PE_Word)) {\n\t\t\t\t\tbprintf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tname[0] = '\\0';\n\t\t\t\tlen = r_buf_read_at (bin->b, off + sizeof(PE_Word), (ut8*) name, PE_NAME_LENGTH);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tbprintf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (!*name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s_%s\", dll_name, name);\n\t\t\t}\n\t\t\tif (!(*importp = realloc (*importp, (*nimp + 1) * sizeof(struct r_bin_pe_import_t)))) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';\n\t\t\t(*importp)[*nimp].vaddr = bin_pe_rva_to_va (bin, FirstThunk + i * sizeof (PE_DWord));\n\t\t\t(*importp)[*nimp].paddr = bin_pe_rva_to_paddr (bin, FirstThunk) + i * sizeof(PE_DWord);\n\t\t\t(*importp)[*nimp].hint = import_hint;\n\t\t\t(*importp)[*nimp].ordinal = import_ordinal;\n\t\t\t(*importp)[*nimp].last = 0;\n\t\t\t(*nimp)++;\n\t\t\ti++;\n\t\t}\n\t} while (import_table);\n\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn i;\n\nerror:\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn false;\n}\n\nstatic char *_time_stamp_to_str(ut32 timeStamp) {\n#ifdef _MSC_VER\n\ttime_t rawtime;\n\tstruct tm *tminfo;\n\trawtime = (time_t)timeStamp;\n\ttminfo = localtime (&rawtime);\n\t//tminfo = gmtime (&rawtime);\n\treturn r_str_trim (strdup (asctime (tminfo)));\n#else\n\tstruct my_timezone {\n\t\tint tz_minuteswest;     /* minutes west of Greenwich */\n\t\tint tz_dsttime;         /* type of DST correction */\n\t} tz;\n\tstruct timeval tv;\n\tint gmtoff;\n\ttime_t ts = (time_t) timeStamp;\n\tgettimeofday (&tv, (void*) &tz);\n\tgmtoff = (int) (tz.tz_minuteswest * 60); // in seconds\n\tts += (time_t)gmtoff;\n\treturn r_str_trim (strdup (ctime (&ts)));\n#endif\n}\n\nstatic int bin_pe_init_hdr(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!(bin->dos_header = malloc (sizeof(PE_(image_dos_header))))) {\n\t\tr_sys_perror (\"malloc (dos header)\");\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, 0, (ut8*) bin->dos_header, sizeof(PE_(image_dos_header))) == -1) {\n\t\tbprintf (\"Warning: read (dos header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_num_set (bin->kv, \"pe_dos_header.offset\", 0, 0);\n\tsdb_set (bin->kv, \"pe_dos_header.format\", \"[2]zwwwwwwwwwwwww[4]www[10]wx\"\n\t\t\" e_magic e_cblp e_cp e_crlc e_cparhdr e_minalloc e_maxalloc\"\n\t\t\" e_ss e_sp e_csum e_ip e_cs e_lfarlc e_ovno e_res e_oemid\"\n\t\t\" e_oeminfo e_res2 e_lfanew\", 0);\n\tif (bin->dos_header->e_lfanew > (unsigned int) bin->size) {\n\t\tbprintf (\"Invalid e_lfanew field\\n\");\n\t\treturn false;\n\t}\n\tif (!(bin->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {\n\t\tr_sys_perror (\"malloc (nt header)\");\n\t\treturn false;\n\t}\n\tbin->nt_header_offset = bin->dos_header->e_lfanew;\n\tif (r_buf_read_at (bin->b, bin->dos_header->e_lfanew, (ut8*) bin->nt_headers, sizeof (PE_(image_nt_headers))) < -1) {\n\t\tbprintf (\"Warning: read (dos header)\\n\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"pe_magic.cparse\",     \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);\n\tsdb_set (bin->kv, \"pe_subsystem.cparse\", \"enum pe_subsystem { IMAGE_SUBSYSTEM_UNKNOWN=0, IMAGE_SUBSYSTEM_NATIVE=1, IMAGE_SUBSYSTEM_WINDOWS_GUI=2, \"\n\t\t\" IMAGE_SUBSYSTEM_WINDOWS_CUI=3, IMAGE_SUBSYSTEM_OS2_CUI=5, IMAGE_SUBSYSTEM_POSIX_CUI=7, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI=9, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_APPLICATION=10, IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER=11, IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER=12, \"\n\t\t\" IMAGE_SUBSYSTEM_EFI_ROM=13, IMAGE_SUBSYSTEM_XBOX=14, IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION=16 };\", 0);\n\tsdb_set (bin->kv, \"pe_dllcharacteristics.cparse\", \"enum pe_dllcharacteristics { IMAGE_LIBRARY_PROCESS_INIT=0x0001, IMAGE_LIBRARY_PROCESS_TERM=0x0002, \"\n\t\t\" IMAGE_LIBRARY_THREAD_INIT=0x0004, IMAGE_LIBRARY_THREAD_TERM=0x0008, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA=0x0020, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE=0x0040, IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY=0x0080, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NX_COMPAT=0x0100, IMAGE_DLLCHARACTERISTICS_NO_ISOLATION=0x0200,IMAGE_DLLCHARACTERISTICS_NO_SEH=0x0400, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_NO_BIND=0x0800, IMAGE_DLLCHARACTERISTICS_APPCONTAINER=0x1000, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER=0x2000, \"\n\t\t\" IMAGE_DLLCHARACTERISTICS_GUARD_CF=0x4000, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE=0x8000};\", 0);\n#if R_BIN_PE64\n\tsdb_num_set (bin->kv, \"pe_nt_image_headers64.offset\", bin->dos_header->e_lfanew, 0);\n\tsdb_set (bin->kv, \"pe_nt_image_headers64.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header64)optionalHeader\", 0);\n\tsdb_set (bin->kv, \"pe_image_optional_header64.format\", \"[2]Ebbxxxxxqxxwwwwwwxxxx[2]E[2]Bqqqqxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags\"\n\t\t\" numberOfRvaAndSizes (pe_image_data_directory)dataDirectory\", 0);\n#else\n\tsdb_num_set (bin->kv, \"pe_nt_image_headers32.offset\", bin->dos_header->e_lfanew, 0);\n\tsdb_set (bin->kv, \"pe_nt_image_headers32.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header32)optionalHeader\", 0);\n\tsdb_set (bin->kv, \"pe_image_optional_header32.format\", \"[2]Ebbxxxxxxxxxwwwwwwxxxx[2]E[2]Bxxxxxx[16]?\"\n\t\t\" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"\n\t\t\" sizeOfUninitializedData addressOfEntryPoint baseOfCode baseOfData imageBase\"\n\t\t\" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"\n\t\t\" majorImageVersion minorImageVersion majorSubsystemVersion minorSubsystemVersion\"\n\t\t\" win32VersionValue sizeOfImage sizeOfHeaders checkSum (pe_subsystem)subsystem (pe_dllcharacteristics)dllCharacteristics\"\n\t\t\" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags numberOfRvaAndSizes\"\n\t\t\" (pe_image_data_directory)dataDirectory\", 0);\n#endif\n\tsdb_set (bin->kv, \"pe_machine.cparse\",         \"enum pe_machine { IMAGE_FILE_MACHINE_I386=0x014c, IMAGE_FILE_MACHINE_IA64=0x0200, IMAGE_FILE_MACHINE_AMD64=0x8664 };\", 0);\n\tsdb_set (bin->kv, \"pe_characteristics.cparse\", \"enum pe_characteristics { \"\n\t\t\" IMAGE_FILE_RELOCS_STRIPPED=0x0001, IMAGE_FILE_EXECUTABLE_IMAGE=0x0002, IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004, \"\n\t\t\" IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008, IMAGE_FILE_AGGRESIVE_WS_TRIM=0x0010, IMAGE_FILE_LARGE_ADDRESS_AWARE=0x0020, \"\n\t\t\" IMAGE_FILE_BYTES_REVERSED_LO=0x0080, IMAGE_FILE_32BIT_MACHINE=0x0100, IMAGE_FILE_DEBUG_STRIPPED=0x0200, \"\n\t\t\" IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP=0x0400, IMAGE_FILE_NET_RUN_FROM_SWAP=0x0800, IMAGE_FILE_SYSTEM=0x1000, \"\n\t\t\" IMAGE_FILE_DLL=0x2000, IMAGE_FILE_UP_SYSTEM_ONLY=0x4000, IMAGE_FILE_BYTES_REVERSED_HI=0x8000 };\", 0);\n\tsdb_set (bin->kv, \"pe_image_file_header.format\",    \"[2]Ewtxxw[2]B\"\n\t\t\" (pe_machine)machine numberOfSections timeDateStamp pointerToSymbolTable\"\n\t\t\" numberOfSymbols sizeOfOptionalHeader (pe_characteristics)characteristics\", 0);\n\tsdb_set (bin->kv, \"pe_image_data_directory.format\", \"xx virtualAddress size\",0);\n\n\t// adding compile time to the SDB\n\t{\n\t\tsdb_num_set (bin->kv, \"image_file_header.TimeDateStamp\", bin->nt_headers->file_header.TimeDateStamp, 0);\n\t\tchar *timestr = _time_stamp_to_str (bin->nt_headers->file_header.TimeDateStamp);\n\t\tsdb_set_owned (bin->kv, \"image_file_header.TimeDateStamp_string\", timestr, 0);\n\t}\n\tbin->optional_header = &bin->nt_headers->optional_header;\n\tbin->data_directory = (PE_(image_data_directory*)) & bin->optional_header->DataDirectory;\n\n\tif (strncmp ((char*) &bin->dos_header->e_magic, \"MZ\", 2) ||\n\t(strncmp ((char*) &bin->nt_headers->Signature, \"PE\", 2) &&\n\t/* Check also for Phar Lap TNT DOS extender PL executable */\n\tstrncmp ((char*) &bin->nt_headers->Signature, \"PL\", 2))) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntypedef struct {\n\tut64 shortname;\n\tut32 value;\n\tut16 secnum;\n\tut16 symtype;\n\tut8 symclass;\n\tut8 numaux;\n} SymbolRecord;\n\nstatic struct r_bin_pe_export_t* parse_symbol_table(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_export_t* exports, int sz) {\n\tut64 sym_tbl_off, num = 0;\n\tconst int srsz = COFF_SYMBOL_SIZE; // symbol record size\n\tstruct r_bin_pe_section_t* sections;\n\tstruct r_bin_pe_export_t* exp;\n\tint bufsz, i, shsz;\n\tSymbolRecord* sr;\n\tut64 text_off = 0LL;\n\tut64 text_rva = 0LL;\n\tint textn = 0;\n\tint exports_sz;\n\tint symctr = 0;\n\tchar* buf;\n\n\tif (!bin || !bin->nt_headers) {\n\t\treturn NULL;\n\t}\n\n\tsym_tbl_off = bin->nt_headers->file_header.PointerToSymbolTable;\n\tnum = bin->nt_headers->file_header.NumberOfSymbols;\n\tshsz = bufsz = num * srsz;\n\tif (bufsz < 1 || bufsz > bin->size) {\n\t\treturn NULL;\n\t}\n\tbuf = calloc (num, srsz);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\texports_sz = sizeof(struct r_bin_pe_export_t) * num;\n\tif (exports) {\n\t\tint osz = sz;\n\t\tsz += exports_sz;\n\t\texports = realloc (exports, sz);\n\t\tif (!exports) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\texp = (struct r_bin_pe_export_t*) (((const ut8*) exports) + osz);\n\t} else {\n\t\tsz = exports_sz;\n\t\texports = malloc (sz);\n\t\texp = exports;\n\t}\n\n\tsections = PE_(r_bin_pe_get_sections) (bin);\n\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t//XXX search by section with +x permission since the section can be left blank\n\t\tif (!strcmp ((char*) sections[i].name, \".text\")) {\n\t\t\ttext_rva = sections[i].vaddr;\n\t\t\ttext_off = sections[i].paddr;\n\t\t\ttextn = i + 1;\n\t\t}\n\t}\n\tfree (sections);\n\tsymctr = 0;\n\tif (r_buf_read_at (bin->b, sym_tbl_off, (ut8*) buf, bufsz)) {\n\t\tfor (i = 0; i < shsz; i += srsz) {\n\t\t\tsr = (SymbolRecord*) (buf + i);\n\t\t\t//bprintf (\"SECNUM %d\\n\", sr->secnum);\n\t\t\tif (sr->secnum == textn) {\n\t\t\t\tif (sr->symtype == 32) {\n\t\t\t\t\tchar shortname[9];\n\t\t\t\t\tmemcpy (shortname, &sr->shortname, 8);\n\t\t\t\t\tshortname[8] = 0;\n\t\t\t\t\tif (*shortname) {\n\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, shortname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar* longname, name[128];\n\t\t\t\t\t\tut32* idx = (ut32*) (buf + i + 4);\n\t\t\t\t\t\tif (r_buf_read_at (bin->b, sym_tbl_off + *idx + shsz, (ut8*) name, 128)) { // == 128) {\n\t\t\t\t\t\t\tlongname = name;\n\t\t\t\t\t\t\tname[sizeof(name) - 1] = 0;\n\t\t\t\t\t\t\tstrncpy ((char*) exp[symctr].name, longname, PE_NAME_LENGTH - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsprintf ((char*) exp[symctr].name, \"unk_%d\", symctr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texp[symctr].name[PE_NAME_LENGTH] = 0;\n\t\t\t\t\texp[symctr].vaddr = bin_pe_rva_to_va (bin, text_rva + sr->value);\n\t\t\t\t\texp[symctr].paddr = text_off + sr->value;\n\t\t\t\t\texp[symctr].ordinal = symctr;\n\t\t\t\t\texp[symctr].forwarder[0] = 0;\n\t\t\t\t\texp[symctr].last = 0;\n\t\t\t\t\tsymctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t} // for\n\t} // if read ok\n\texp[symctr].last = 1;\n\tfree (buf);\n\treturn exports;\n}\n\nstatic int bin_pe_init_sections(struct PE_(r_bin_pe_obj_t)* bin) {\n\tbin->num_sections = bin->nt_headers->file_header.NumberOfSections;\n\tint sections_size;\n\tif (bin->num_sections < 1) {\n\t\treturn true;\n\t}\n\tsections_size = sizeof (PE_(image_section_header)) * bin->num_sections;\n\tif (sections_size > bin->size) {\n\t\tsections_size = bin->size;\n\t\tbin->num_sections = bin->size / sizeof (PE_(image_section_header));\n\t\t// massage this to make corkami happy\n\t\t//bprintf (\"Invalid NumberOfSections value\\n\");\n\t\t//goto out_error;\n\t}\n\tif (!(bin->section_header = malloc (sections_size))) {\n\t\tr_sys_perror (\"malloc (section header)\");\n\t\tgoto out_error;\n\t}\n\tbin->section_header_offset = bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +\n\t\tbin->nt_headers->file_header.SizeOfOptionalHeader;\n\tif (r_buf_read_at (bin->b, bin->section_header_offset,\n\t\t(ut8*) bin->section_header, sections_size) == -1) {\n\t\tbprintf (\"Warning: read (sections)\\n\");\n\t\tR_FREE (bin->section_header);\n\t\tgoto out_error;\n\t}\n#if 0\n\tEach symbol table entry includes a name, storage class, type, value and section number.Short names (8 characters or fewer) are stored directly in the symbol table;\n\tlonger names are stored as an paddr into the string table at the end of the COFF object.\n\n\t================================================================\n\tCOFF SYMBOL TABLE RECORDS (18 BYTES)\n\t================================================================\n\trecord\n\tpaddr\n\n\tstruct symrec {\n\t\tunion {\n\t\t\tchar string[8]; // short name\n\t\t\tstruct {\n\t\t\t\tut32 seros;\n\t\t\t\tut32 stridx;\n\t\t\t} stridx;\n\t\t} name;\n\t\tut32 value;\n\t\tut16 secnum;\n\t\tut16 symtype;\n\t\tut8 symclass;\n\t\tut8 numaux;\n\t}\n\t------------------------------------------------------ -\n\t0 | 8 - char symbol name |\n\t| or 32 - bit zeroes followed by 32 - bit |\n\t| index into string table |\n\t------------------------------------------------------ -\n\t8 | symbol value |\n\t------------------------------------------------------ -\n\t0Ch | section number | symbol type |\n\t------------------------------------------------------ -\n\t10h | sym class | num aux |\n\t-------------------------- -\n\t12h\n\n#endif\n\treturn true;\nout_error:\n\tbin->num_sections = 0;\n\treturn false;\n}\n\nint PE_(bin_pe_get_claimed_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->optional_header) {\n\t\treturn 0;\n\t}\n\treturn bin->optional_header->CheckSum;\n}\n\nint PE_(bin_pe_get_actual_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tint i, j, checksum_offset = 0;\n\tut8* buf = NULL;\n\tut64 computed_cs = 0;\n\tint remaining_bytes;\n\tint shift;\n\tut32 cur;\n\tif (!bin || !bin->nt_header_offset) {\n\t\treturn 0;\n\t}\n\tbuf = bin->b->buf;\n\tchecksum_offset = bin->nt_header_offset + 4 + sizeof(PE_(image_file_header)) + 0x40;\n\tfor (i = 0; i < bin->size / 4; i++) {\n\t\tcur = r_read_le32 (&buf[i * 4]);\n\n\t\t// skip the checksum bytes\n\t\tif (i * 4 == checksum_offset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t}\n\n\t// add resultant bytes to checksum\n\tremaining_bytes = bin->size % 4;\n\ti = i * 4;\n\tif (remaining_bytes != 0) {\n\t\tcur = buf[i];\n\t\tshift = 8;\n\t\tfor (j = 1; j < remaining_bytes; j++, shift += 8) {\n\t\t\tcur |= buf[i + j] << shift;\n\t\t}\n\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);\n\t\tif (computed_cs >> 32) {\n\t\t\tcomputed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);\n\t\t}\n\t}\n\n\t// 32bits -> 16bits\n\tcomputed_cs = (computed_cs & 0xFFFF) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs) + (computed_cs >> 16);\n\tcomputed_cs = (computed_cs & 0xFFFF);\n\n\t// add filesize\n\tcomputed_cs += bin->size;\n\treturn computed_cs;\n}\n\nstatic void computeOverlayOffset(ut64 offset, ut64 size, ut64 file_size, ut64* largest_offset, ut64* largest_size) {\n\tif (offset + size <= file_size && offset + size > (*largest_offset + *largest_size)) {\n\t\t*largest_offset = offset;\n\t\t*largest_size = size;\n\t}\n}\n\n/* Inspired from https://github.com/erocarrera/pefile/blob/master/pefile.py#L5425 */\nint PE_(bin_pe_get_overlay)(struct PE_(r_bin_pe_obj_t)* bin, ut64* size) {\n\tut64 largest_offset = 0;\n\tut64 largest_size = 0;\n\t*size = 0;\n\tint i;\n\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\n\tif (bin->optional_header) {\n\t\tcomputeOverlayOffset (\n\t\t\t\tbin->nt_header_offset+4+sizeof(bin->nt_headers->file_header),\n\t\t\t\tbin->nt_headers->file_header.SizeOfOptionalHeader,\n\t\t\t\tbin->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t}\n\n\tstruct r_bin_pe_section_t *sects = NULL;\n\tsects = PE_(r_bin_pe_get_sections) (bin);\n\tfor (i = 0; !sects[i].last; i++) {\n\t\tcomputeOverlayOffset(\n\t\t\t\tsects[i].paddr,\n\t\t\t\tsects[i].size,\n\t\t\t\tbin->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size\n\t\t\t\t);\n\t}\n\n\tif (bin->optional_header) {\n\t\tfor (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {\n\t\t\tif (i == PE_IMAGE_DIRECTORY_ENTRY_SECURITY) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcomputeOverlayOffset (\n\t\t\t\tbin_pe_rva_to_paddr (bin, bin->data_directory[i].VirtualAddress),\n\t\t\t\tbin->data_directory[i].Size,\n\t\t\t\tbin->size,\n\t\t\t\t&largest_offset,\n\t\t\t\t&largest_size);\n\t\t}\n\n\t}\n\n\tif ((ut64) bin->size > largest_offset + largest_size) {\n\t\t*size = bin->size - largest_offset - largest_size;\n\t\tfree (sects);\n\t\treturn largest_offset + largest_size;\n\t}\n\tfree (sects);\n\treturn 0;\n}\n\nstatic int bin_pe_read_metadata_string(char* to, char* from) {\n\tint covered = 0;\n\twhile (covered < MAX_METADATA_STRING_LENGTH) {\n\t\tto[covered] = from[covered];\n\t\tif (from[covered] == '\\0') {\n\t\t\tcovered += 1;\n\t\t\tbreak;\n\t\t}\n\t\tcovered++;\n\t}\n\twhile (covered % 4 != 0) { covered++; }\n\treturn covered;\n}\n\nstatic int bin_pe_init_metadata_hdr(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_DWord metadata_directory = bin->clr_hdr? bin_pe_rva_to_paddr (bin, bin->clr_hdr->MetaDataDirectoryAddress): 0;\n\tPE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));\n\tint rr;\n\tif (!metadata) {\n\t\treturn 0;\n\t}\n\tif (!metadata_directory) {\n\t\tfree (metadata);\n\t\treturn 0;\n\t}\n\n\n\trr = r_buf_fread_at (bin->b, metadata_directory,\n\t\t(ut8*) metadata, bin->big_endian? \"1I2S\": \"1i2s\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (bin->b, metadata_directory + 8,\n\t\t(ut8*) (&metadata->Reserved), bin->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\trr = r_buf_fread_at (bin->b, metadata_directory + 12,\n\t\t(ut8*) (&metadata->VersionStringLength), bin->big_endian? \"1I\": \"1i\", 1);\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Metadata Signature: 0x%\"PFMT64x\" 0x%\"PFMT64x\" %d\\n\",\n\t\t(ut64)metadata_directory, (ut64)metadata->Signature, (int)metadata->VersionStringLength);\n\n\t// read the version string\n\tint len = metadata->VersionStringLength; // XXX: dont trust this length\n\tif (len > 0) {\n\t\tmetadata->VersionString = calloc (1, len + 1);\n\t\tif (!metadata->VersionString) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\trr = r_buf_read_at (bin->b, metadata_directory + 16, (ut8*)(metadata->VersionString),  len);\n\t\tif (rr != len) {\n\t\t\teprintf (\"Warning: read (metadata header) - cannot parse version string\\n\");\n\t\t\tfree (metadata->VersionString);\n\t\t\tfree (metadata);\n\t\t\treturn 0;\n\t\t}\n\t\teprintf (\".NET Version: %s\\n\", metadata->VersionString);\n\t}\n\n\t// read the header after the string\n\trr = r_buf_fread_at (bin->b, metadata_directory + 16 + metadata->VersionStringLength,\n\t\t(ut8*) (&metadata->Flags), bin->big_endian? \"2S\": \"2s\", 1);\n\n\tif (rr < 1) {\n\t\tgoto fail;\n\t}\n\n\teprintf (\"Number of Metadata Streams: %d\\n\", metadata->NumberOfStreams);\n\tbin->metadata_header = metadata;\n\n\n\t// read metadata streams\n\tint start_of_stream = metadata_directory + 20 + metadata->VersionStringLength;\n\tPE_(image_metadata_stream) * stream;\n\tPE_(image_metadata_stream) **streams = calloc (sizeof (PE_(image_metadata_stream)*), metadata->NumberOfStreams);\n\tif (!streams) {\n\t\tgoto fail;\n\t}\n\tint count = 0;\n\n\twhile (count < metadata->NumberOfStreams) {\n\t\tstream = R_NEW0 (PE_(image_metadata_stream));\n\t\tif (!stream) {\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (r_buf_fread_at (bin->b, start_of_stream, (ut8*) stream, bin->big_endian? \"2I\": \"2i\", 1) < 1) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"DirectoryAddress: %x Size: %x\\n\", stream->Offset, stream->Size);\n\t\tchar* stream_name = calloc (1, MAX_METADATA_STRING_LENGTH + 1);\n\n\t\tif (!stream_name) {\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (r_buf_size (bin->b) < (start_of_stream + 8 + MAX_METADATA_STRING_LENGTH)) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\tint c = bin_pe_read_metadata_string (stream_name,\n\t\t\t(char *)(bin->b->buf + start_of_stream + 8));\n\t\tif (c == 0) {\n\t\t\tfree (stream_name);\n\t\t\tfree (stream);\n\t\t\tfree (streams);\n\t\t\tgoto fail;\n\t\t}\n\t\teprintf (\"Stream name: %s %d\\n\", stream_name, c);\n\t\tstream->Name = stream_name;\n\t\tstreams[count] = stream;\n\t\tstart_of_stream += 8 + c;\n\t\tcount += 1;\n\t}\n\tbin->streams = streams;\n\treturn 1;\nfail:\n\teprintf (\"Warning: read (metadata header)\\n\");\n\tfree (metadata);\n\treturn 0;\n}\n\nstatic int bin_pe_init_overlay(struct PE_(r_bin_pe_obj_t)* bin) {\n\tut64 pe_overlay_size;\n\tut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (bin, &pe_overlay_size);\n\tif (pe_overlay_offset) {\n\t\tsdb_num_set (bin->kv, \"pe_overlay.offset\", pe_overlay_offset, 0);\n\t\tsdb_num_set (bin->kv, \"pe_overlay.size\", pe_overlay_size, 0);\n\t}\n\treturn 0;\n}\n\nstatic int bin_pe_init_clr_hdr(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * clr_dir = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];\n\tPE_DWord image_clr_hdr_paddr = bin_pe_rva_to_paddr (bin, clr_dir->VirtualAddress);\n\t// int clr_dir_size = clr_dir? clr_dir->Size: 0;\n\tPE_(image_clr_header) * clr_hdr = R_NEW0 (PE_(image_clr_header));\n\tint rr, len = sizeof (PE_(image_clr_header));\n\n\tif (!clr_hdr) {\n\t\treturn 0;\n\t}\n\trr = r_buf_read_at (bin->b, image_clr_hdr_paddr, (ut8*) (clr_hdr), len);\n\n//\tprintf(\"%x\\n\", clr_hdr->HeaderSize);\n\n\tif (clr_hdr->HeaderSize != 0x48) {\n\t\t// probably not a .NET binary\n\t\t// 64bit?\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\tif (rr != len) {\n\t\tfree (clr_hdr);\n\t\treturn 0;\n\t}\n\n\tbin->clr_hdr = clr_hdr;\n\treturn 1;\n}\n\nstatic int bin_pe_init_imports(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * data_dir_import = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_IMPORT];\n\tPE_(image_data_directory) * data_dir_delay_import = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];\n\n\tPE_DWord import_dir_paddr = bin_pe_rva_to_paddr (bin, data_dir_import->VirtualAddress);\n\tPE_DWord import_dir_offset = bin_pe_rva_to_paddr (bin, data_dir_import->VirtualAddress);\n\tPE_DWord delay_import_dir_offset = data_dir_delay_import\n\t? bin_pe_rva_to_paddr (bin, data_dir_delay_import->VirtualAddress)\n\t\t\t\t\t: 0;\n\n\tPE_(image_import_directory) * import_dir = NULL;\n\tPE_(image_import_directory) * new_import_dir = NULL;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\n\tPE_(image_delay_import_directory) * delay_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = NULL;\n\n\tint dir_size = sizeof(PE_(image_import_directory));\n\tint delay_import_size = sizeof(PE_(image_delay_import_directory));\n\tint indx = 0;\n\tint rr, count = 0;\n\tint import_dir_size = data_dir_import->Size;\n\tint delay_import_dir_size = data_dir_delay_import->Size;\n\t/// HACK to modify import size because of begin 0.. this may report wrong info con corkami tests\n\tif (!import_dir_size) {\n\t\t// asume 1 entry for each\n\t\timport_dir_size = data_dir_import->Size = 0xffff;\n\t}\n\tif (!delay_import_dir_size) {\n\t\t// asume 1 entry for each\n\t\tdelay_import_dir_size = data_dir_delay_import->Size = 0xffff;\n\t}\n\tint maxidsz = R_MIN ((PE_DWord) bin->size, import_dir_offset + import_dir_size);\n\tmaxidsz -= import_dir_offset;\n\tif (maxidsz < 0) {\n\t\tmaxidsz = 0;\n\t}\n\t//int maxcount = maxidsz/ sizeof (struct r_bin_pe_import_t);\n\n\tfree (bin->import_directory);\n\tbin->import_directory = NULL;\n\tif (import_dir_paddr != 0) {\n\t\tif (import_dir_size < 1 || import_dir_size > maxidsz) {\n\t\t\tbprintf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);\n\t\t\timport_dir_size = maxidsz;\n\t\t}\n\t\tbin->import_directory_offset = import_dir_offset;\n\t\tcount = 0;\n\t\tdo {\n\t\t\tindx++;\n\t\t\tif (((2 + indx) * dir_size) > import_dir_size) {\n\t\t\t\tbreak; //goto fail;\n\t\t\t}\n\t\t\tnew_import_dir = (PE_(image_import_directory)*)realloc (import_dir, ((1 + indx) * dir_size));\n\t\t\tif (!new_import_dir) {\n\t\t\t\tr_sys_perror (\"malloc (import directory)\");\n\t\t\t\tfree (import_dir);\n\t\t\t\timport_dir = NULL;\n\t\t\t\tbreak; //\n\t\t\t\t//\t\t\tgoto fail;\n\t\t\t}\n\t\t\timport_dir = new_import_dir;\n\t\t\tnew_import_dir = NULL;\n\t\t\tcurr_import_dir = import_dir + (indx - 1);\n\t\t\tif (r_buf_read_at (bin->b, import_dir_offset + (indx - 1) * dir_size, (ut8*) (curr_import_dir), dir_size) < 1) {\n\t\t\t\tbprintf (\"Warning: read (import directory)\\n\");\n\t\t\t\tfree (import_dir);\n\t\t\t\timport_dir = NULL;\n\t\t\t\tbreak; //return false;\n\t\t\t}\n\t\t\tcount++;\n\t\t} while (curr_import_dir->FirstThunk != 0 || curr_import_dir->Name != 0 ||\n\t\tcurr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||\n\t\tcurr_import_dir->ForwarderChain != 0);\n\n\t\tbin->import_directory = import_dir;\n\t\tbin->import_directory_size = import_dir_size;\n\t}\n\n\tindx = 0;\n\tif (bin->b->length > 0) {\n\t\tif ((delay_import_dir_offset != 0) && (delay_import_dir_offset < (ut32) bin->b->length)) {\n\t\t\tut64 off;\n\t\t\tbin->delay_import_directory_offset = delay_import_dir_offset;\n\t\t\tdo {\n\t\t\t\tindx++;\n\t\t\t\toff = indx * delay_import_size;\n\t\t\t\tif (off >= bin->b->length) {\n\t\t\t\t\tbprintf (\"Warning: Cannot find end of import symbols\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelay_import_dir = (PE_(image_delay_import_directory)*)realloc (\n\t\t\t\t\tdelay_import_dir, (indx * delay_import_size) + 1);\n\t\t\t\tif (delay_import_dir == 0) {\n\t\t\t\t\tr_sys_perror (\"malloc (delay import directory)\");\n\t\t\t\t\tfree (delay_import_dir);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tcurr_delay_import_dir = delay_import_dir + (indx - 1);\n\t\t\t\trr = r_buf_read_at (bin->b, delay_import_dir_offset + (indx - 1) * delay_import_size,\n\t\t\t\t\t(ut8*) (curr_delay_import_dir), dir_size);\n\t\t\t\tif (rr != dir_size) {\n\t\t\t\t\tbprintf (\"Warning: read (delay import directory)\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t} while (curr_delay_import_dir->Name != 0);\n\t\t\tbin->delay_import_directory = delay_import_dir;\n\t\t}\n\t}\n\n\treturn true;\nfail:\n\tfree (import_dir);\n\timport_dir = NULL;\n\tbin->import_directory = import_dir;\n\tfree (delay_import_dir);\n\treturn false;\n}\n\nstatic int bin_pe_init_exports(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * data_dir_export = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\tPE_DWord export_dir_paddr = bin_pe_rva_to_paddr (bin, data_dir_export->VirtualAddress);\n\tif (!export_dir_paddr) {\n\t\t// This export-dir-paddr should only appear in DLL files\n\t\t// bprintf (\"Warning: Cannot find the paddr of the export directory\\n\");\n\t\treturn false;\n\t}\n\t// sdb_setn (DB, \"hdr.exports_directory\", export_dir_paddr);\n\t// bprintf (\"Pexports paddr at 0x%\"PFMT64x\"\\n\", export_dir_paddr);\n\tif (!(bin->export_directory = malloc (sizeof(PE_(image_export_directory))))) {\n\t\tr_sys_perror (\"malloc (export directory)\");\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, export_dir_paddr, (ut8*) bin->export_directory, sizeof (PE_(image_export_directory))) == -1) {\n\t\tbprintf (\"Warning: read (export directory)\\n\");\n\t\tfree (bin->export_directory);\n\t\tbin->export_directory = NULL;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void _free_resources(r_pe_resource *rs) {\n\tif (rs) {\n\t\tfree (rs->timestr);\n\t\tfree (rs->data);\n\t\tfree (rs->type);\n\t\tfree (rs->language);\n\t\tfree (rs);\n\t}\n}\n\n\nstatic int bin_pe_init_resource(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_data_directory) * resource_dir = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_RESOURCE];\n\tPE_DWord resource_dir_paddr = bin_pe_rva_to_paddr (bin, resource_dir->VirtualAddress);\n\tif (!resource_dir_paddr) {\n\t\treturn false;\n\t}\n\n\tbin->resources = r_list_newf ((RListFree)_free_resources);\n\tif (!bin->resources) {\n\t\treturn false;\n\t}\n\tif (!(bin->resource_directory = malloc (sizeof(*bin->resource_directory)))) {\n\t\tr_sys_perror (\"malloc (resource directory)\");\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, resource_dir_paddr, (ut8*) bin->resource_directory,\n\t\tsizeof (*bin->resource_directory)) != sizeof (*bin->resource_directory)) {\n\t\tbprintf (\"Warning: read (resource directory)\\n\");\n\t\tfree (bin->resource_directory);\n\t\tbin->resource_directory = NULL;\n\t\treturn false;\n\t}\n\tbin->resource_directory_offset = resource_dir_paddr;\n\treturn true;\n}\n\n\n\nstatic void bin_pe_store_tls_callbacks(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord callbacks) {\n\tPE_DWord paddr, haddr;\n\tint count = 0;\n\tPE_DWord addressOfTLSCallback = 1;\n\tchar* key;\n\n\twhile (addressOfTLSCallback != 0) {\n\t\tif (r_buf_read_at (bin->b, callbacks, (ut8*) &addressOfTLSCallback, sizeof(addressOfTLSCallback)) != sizeof (addressOfTLSCallback)) {\n\t\t\tbprintf (\"Warning: read (tls_callback)\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!addressOfTLSCallback) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->optional_header->SizeOfImage) {\n\t\t\tint rva_callback = bin_pe_va_to_rva (bin, (PE_DWord) addressOfTLSCallback);\n\t\t\tif (rva_callback > bin->optional_header->SizeOfImage) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkey = sdb_fmt (\"pe.tls_callback%d_vaddr\", count);\n\t\tsdb_num_set (bin->kv, key, addressOfTLSCallback, 0);\n\t\tkey = sdb_fmt (\"pe.tls_callback%d_paddr\", count);\n\t\tpaddr = bin_pe_rva_to_paddr (bin, bin_pe_va_to_rva (bin, (PE_DWord) addressOfTLSCallback));\n\t\tsdb_num_set (bin->kv, key, paddr,                0);\n\t\tkey = sdb_fmt (\"pe.tls_callback%d_haddr\", count);\n\t\thaddr = callbacks;\n\t\tsdb_num_set (bin->kv, key, haddr,                0);\n\t\tcount++;\n\t\tcallbacks += sizeof (addressOfTLSCallback);\n\t}\n}\n\nstatic int bin_pe_init_tls(struct PE_(r_bin_pe_obj_t)* bin) {\n\tPE_(image_tls_directory) * image_tls_directory;\n\tPE_(image_data_directory) * data_dir_tls = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_TLS];\n\tPE_DWord tls_paddr = bin_pe_rva_to_paddr (bin, data_dir_tls->VirtualAddress);\n\n\timage_tls_directory = R_NEW0 (PE_(image_tls_directory));\n\tif (r_buf_read_at (bin->b, tls_paddr, (ut8*) image_tls_directory, sizeof (PE_(image_tls_directory))) != sizeof (PE_(image_tls_directory))) {\n\t\tbprintf (\"Warning: read (image_tls_directory)\\n\");\n\t\tfree (image_tls_directory);\n\t\treturn 0;\n\t}\n\tbin->tls_directory = image_tls_directory;\n\tif (!image_tls_directory->AddressOfCallBacks) {\n\t\treturn 0;\n\t}\n\tif (image_tls_directory->EndAddressOfRawData < image_tls_directory->StartAddressOfRawData) {\n\t\treturn 0;\n\t}\n\tPE_DWord callbacks_paddr = bin_pe_rva_to_paddr (bin, bin_pe_va_to_rva (bin,\n\t\t\t(PE_DWord) image_tls_directory->AddressOfCallBacks));\n\tbin_pe_store_tls_callbacks (bin, callbacks_paddr);\n\treturn 0;\n}\n\nstatic void free_Var(Var* var) {\n\tif (var) {\n\t\tfree (var->szKey);\n\t\tfree (var->Value);\n\t\tfree (var);\n\t}\n}\n\nstatic void free_VarFileInfo(VarFileInfo* varFileInfo) {\n\tif (varFileInfo) {\n\t\tfree (varFileInfo->szKey);\n\t\tif (varFileInfo->Children) {\n\t\t\tut32 children = 0;\n\t\t\tfor (; children < varFileInfo->numOfChildren; children++) {\n\t\t\t\tfree_Var (varFileInfo->Children[children]);\n\t\t\t}\n\t\t\tfree (varFileInfo->Children);\n\t\t}\n\t\tfree (varFileInfo);\n\t}\n}\n\nstatic void free_String(String* string) {\n\tif (string) {\n\t\tfree (string->szKey);\n\t\tfree (string->Value);\n\t\tfree (string);\n\t}\n}\n\nstatic void free_StringTable(StringTable* stringTable) {\n\tif (stringTable) {\n\t\tfree (stringTable->szKey);\n\t\tif (stringTable->Children) {\n\t\t\tut32 childrenST = 0;\n\t\t\tfor (; childrenST < stringTable->numOfChildren; childrenST++) {\n\t\t\t\tfree_String (stringTable->Children[childrenST]);\n\t\t\t}\n\t\t\tfree (stringTable->Children);\n\t\t}\n\t\tfree (stringTable);\n\t}\n}\n\nstatic void free_StringFileInfo(StringFileInfo* stringFileInfo) {\n\tif (stringFileInfo) {\n\t\tfree (stringFileInfo->szKey);\n\t\tif (stringFileInfo->Children) {\n\t\t\tut32 childrenSFI = 0;\n\t\t\tfor (; childrenSFI < stringFileInfo->numOfChildren; childrenSFI++) {\n\t\t\t\tfree_StringTable (stringFileInfo->Children[childrenSFI]);\n\t\t\t}\n\t\t\tfree (stringFileInfo->Children);\n\t\t}\n\t\tfree (stringFileInfo);\n\t}\n}\n\n#define align32(x) x = ((x & 0x3) == 0)? x: (x & ~0x3) + 0x4;\n\nstatic void free_VS_VERSIONINFO(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tif (vs_VersionInfo) {\n\t\tfree (vs_VersionInfo->szKey);\n\t\tfree (vs_VersionInfo->Value);\n\t\tfree_VarFileInfo (vs_VersionInfo->varFileInfo);\n\t\tfree_StringFileInfo (vs_VersionInfo->stringFileInfo);\n\t\tfree (vs_VersionInfo);\n\t}\n}\n\nvoid PE_(free_VS_VERSIONINFO)(PE_VS_VERSIONINFO * vs_VersionInfo) {\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n}\n\nstatic Var* Pe_r_bin_pe_parse_var(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tVar* var = calloc (1, sizeof(*var));\n\tif (!var) {\n\t\tbprintf (\"Warning: calloc (Var)\\n\");\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &var->wLength, sizeof(var->wLength)) != sizeof(var->wLength)) {\n\t\tbprintf (\"Warning: read (Var wLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(var->wLength);\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &var->wValueLength, sizeof(var->wValueLength)) != sizeof(var->wValueLength)) {\n\t\tbprintf (\"Warning: read (Var wValueLength)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(var->wValueLength);\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &var->wType, sizeof(var->wType)) != sizeof(var->wType)) {\n\t\tbprintf (\"Warning: read (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(var->wType);\n\tif (var->wType != 0 && var->wType != 1) {\n\t\tbprintf (\"Warning: check (Var wType)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"\n\tif (!var->szKey) {\n\t\tbprintf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {\n\t\tbprintf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tbprintf (\"Warning: check (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\tvar->numOfValues = var->wValueLength / 4;\n\tif (!var->numOfValues) {\n\t\tbprintf (\"Warning: check (Var numOfValues)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tvar->Value = (ut32*) malloc (var->wValueLength);\n\tif (!var->Value) {\n\t\tbprintf (\"Warning: malloc (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {\n\t\tbprintf (\"Warning: read (Var Value)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += var->wValueLength;\n\treturn var;\n}\n\nstatic VarFileInfo* Pe_r_bin_pe_parse_var_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tVarFileInfo* varFileInfo = calloc (1, sizeof(*varFileInfo));\n\tif (!varFileInfo) {\n\t\tbprintf (\"Warning: calloc (VarFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = *curAddr;\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &varFileInfo->wLength, sizeof(varFileInfo->wLength)) != sizeof(varFileInfo->wLength)) {\n\t\tbprintf (\"Warning: read (VarFileInfo wLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(varFileInfo->wLength);\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &varFileInfo->wValueLength, sizeof(varFileInfo->wValueLength)) != sizeof(varFileInfo->wValueLength)) {\n\t\tbprintf (\"Warning: read (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(varFileInfo->wValueLength);\n\n\tif (varFileInfo->wValueLength != 0) {\n\t\tbprintf (\"Warning: check (VarFileInfo wValueLength)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &varFileInfo->wType, sizeof(varFileInfo->wType)) != sizeof(varFileInfo->wType)) {\n\t\tbprintf (\"Warning: read (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(varFileInfo->wType);\n\tif (varFileInfo->wType && varFileInfo->wType != 1) {\n\t\tbprintf (\"Warning: check (VarFileInfo wType)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tvarFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (VARFILEINFO_UTF_16_LEN ));  //L\"VarFileInfo\"\n\tif (!varFileInfo->szKey) {\n\t\tbprintf (\"Warning: malloc (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {\n\t\tbprintf (\"Warning: read (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += VARFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (varFileInfo->szKey, VARFILEINFO_UTF_16, VARFILEINFO_UTF_16_LEN)) {\n\t\tbprintf (\"Warning: check (VarFileInfo szKey)\\n\");\n\t\tfree_VarFileInfo (varFileInfo);\n\t\treturn NULL;\n\t}\n\talign32 (*curAddr);\n\twhile (startAddr + varFileInfo->wLength > *curAddr) {\n\t\tVar** tmp = (Var**) realloc (varFileInfo->Children, (varFileInfo->numOfChildren + 1) * sizeof(*varFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tbprintf (\"Warning: realloc (VarFileInfo Children)\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->Children = tmp;\n\t\tif (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var (bin, curAddr))) {\n\t\t\tbprintf (\"Warning: bad parsing Var\\n\");\n\t\t\tfree_VarFileInfo (varFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tvarFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\treturn varFileInfo;\n}\n\nstatic String* Pe_r_bin_pe_parse_string(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tString* string = calloc (1, sizeof(*string));\n\tPE_DWord begAddr = *curAddr;\n\tint len_value = 0;\n\tint i = 0;\n\tif (!string) {\n\t\tbprintf (\"Warning: calloc (String)\\n\");\n\t\treturn NULL;\n\t}\n\tif (begAddr > bin->size || begAddr + sizeof(string->wLength) > bin->size) {\n\t\tfree_String (string);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &string->wLength, sizeof(string->wLength)) != sizeof(string->wLength)) {\n\t\tbprintf (\"Warning: read (String wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof(string->wLength);\n\tif (*curAddr > bin->size || *curAddr + sizeof(string->wValueLength) > bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &string->wValueLength, sizeof(string->wValueLength)) != sizeof(string->wValueLength)) {\n\t\tbprintf (\"Warning: read (String wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof(string->wValueLength);\n\n\tif (*curAddr > bin->size || *curAddr + sizeof(string->wType) > bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &string->wType, sizeof(string->wType)) != sizeof(string->wType)) {\n\t\tbprintf (\"Warning: read (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += sizeof(string->wType);\n\tif (string->wType != 0 && string->wType != 1) {\n\t\tbprintf (\"Warning: check (String wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tfor (i = 0; *curAddr < begAddr + string->wLength; ++i, *curAddr += sizeof (ut16)) {\n\t\tut16 utf16_char;\n\t\tif (*curAddr > bin->size || *curAddr + sizeof (ut16) > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &utf16_char, sizeof (ut16)) != sizeof (ut16)) {\n\t\t\tbprintf (\"Warning: check (String szKey)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tstring->szKey = (ut16*) realloc (string->szKey, (i + 1) * sizeof (ut16));\n\t\tstring->szKey[i] = utf16_char;\n\t\tstring->wKeyLen += sizeof (ut16);\n\t\tif (!utf16_char) {\n\t\t\t*curAddr += sizeof (ut16);\n\t\t\tbreak;\n\t\t}\n\t}\n\talign32 (*curAddr);\n\tlen_value = R_MIN (string->wValueLength * 2, string->wLength - (*curAddr - begAddr));\n\tstring->wValueLength = len_value;\n\tif (len_value < 0) {\n\t\tlen_value = 0;\n\t}\n\tstring->Value = (ut16*) calloc (len_value + 1, 1);\n\tif (!string->Value) {\n\t\tbprintf (\"Warning: malloc (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\tif (*curAddr > bin->size || *curAddr + len_value > bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) string->Value, len_value) != len_value) {\n\t\tbprintf (\"Warning: read (String Value)\\n\");\n\t\tgoto out_error;\n\t}\n\t*curAddr += len_value;\n\treturn string;\nout_error:\n\tfree_String (string);\n\treturn NULL;\n}\n\nstatic StringTable* Pe_r_bin_pe_parse_string_table(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tStringTable* stringTable = calloc (1, sizeof(*stringTable));\n\tif (!stringTable) {\n\t\tbprintf (\"Warning: calloc (stringTable)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringTable->wLength, sizeof(stringTable->wLength)) != sizeof(stringTable->wLength)) {\n\t\tbprintf (\"Warning: read (StringTable wLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringTable->wLength);\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringTable->wValueLength, sizeof(stringTable->wValueLength)) != sizeof(stringTable->wValueLength)) {\n\t\tbprintf (\"Warning: read (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringTable->wValueLength);\n\n\tif (stringTable->wValueLength) {\n\t\tbprintf (\"Warning: check (StringTable wValueLength)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringTable->wType, sizeof(stringTable->wType)) != sizeof(stringTable->wType)) {\n\t\tbprintf (\"Warning: read (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringTable->wType);\n\tif (stringTable->wType && stringTable->wType != 1) {\n\t\tbprintf (\"Warning: check (StringTable wType)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\tstringTable->szKey = (ut16*) malloc (UT16_ALIGN (EIGHT_HEX_DIG_UTF_16_LEN));  //EIGHT_HEX_DIG_UTF_16_LEN\n\tif (!stringTable->szKey) {\n\t\tbprintf (\"Warning: malloc (stringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {\n\t\tbprintf (\"Warning: read (StringTable szKey)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\t*curAddr += EIGHT_HEX_DIG_UTF_16_LEN;\n\talign32 (*curAddr);\n\twhile (startAddr + stringTable->wLength > *curAddr) {\n\t\tString** tmp = (String**) realloc (stringTable->Children, (stringTable->numOfChildren + 1) * sizeof(*stringTable->Children));\n\t\tif (!tmp) {\n\t\t\tbprintf (\"Warning: realloc (StringTable Children)\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->Children = tmp;\n\t\tif (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string (bin, curAddr))) {\n\t\t\tbprintf (\"Warning: bad parsing String\\n\");\n\t\t\tfree_StringTable (stringTable);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringTable->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringTable->numOfChildren) {\n\t\tbprintf (\"Warning: check (StringTable numOfChildren)\\n\");\n\t\tfree_StringTable (stringTable);\n\t\treturn NULL;\n\t}\n\n\treturn stringTable;\n}\n\nstatic StringFileInfo* Pe_r_bin_pe_parse_string_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {\n\tStringFileInfo* stringFileInfo = calloc (1, sizeof(*stringFileInfo));\n\tif (!stringFileInfo) {\n\t\tbprintf (\"Warning: calloc (StringFileInfo)\\n\");\n\t\treturn NULL;\n\t}\n\n\tPE_DWord startAddr = *curAddr;\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringFileInfo->wLength, sizeof(stringFileInfo->wLength)) != sizeof(stringFileInfo->wLength)) {\n\t\tbprintf (\"Warning: read (StringFileInfo wLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringFileInfo->wLength);\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringFileInfo->wValueLength, sizeof(stringFileInfo->wValueLength)) != sizeof(stringFileInfo->wValueLength)) {\n\t\tbprintf (\"Warning: read (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringFileInfo->wValueLength);\n\n\tif (stringFileInfo->wValueLength) {\n\t\tbprintf (\"Warning: check (StringFileInfo wValueLength)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) &stringFileInfo->wType, sizeof(stringFileInfo->wType)) != sizeof(stringFileInfo->wType)) {\n\t\tbprintf (\"Warning: read (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += sizeof(stringFileInfo->wType);\n\n\tif (stringFileInfo->wType && stringFileInfo->wType != 1) {\n\t\tbprintf (\"Warning: check (StringFileInfo wType)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tstringFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (STRINGFILEINFO_UTF_16_LEN));  //L\"StringFileInfo\"\n\tif (!stringFileInfo->szKey) {\n\t\tbprintf (\"Warning: malloc (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, *curAddr, (ut8*) stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {\n\t\tbprintf (\"Warning: read (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\t*curAddr += STRINGFILEINFO_UTF_16_LEN;\n\n\tif (memcmp (stringFileInfo->szKey, STRINGFILEINFO_UTF_16, STRINGFILEINFO_UTF_16_LEN) != 0) {\n\t\tbprintf (\"Warning: check (StringFileInfo szKey)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\talign32 (*curAddr);\n\n\twhile (startAddr + stringFileInfo->wLength > *curAddr) {\n\t\tStringTable** tmp = (StringTable**) realloc (stringFileInfo->Children, (stringFileInfo->numOfChildren + 1) * sizeof(*stringFileInfo->Children));\n\t\tif (!tmp) {\n\t\t\tbprintf (\"Warning: realloc (StringFileInfo Children)\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->Children = tmp;\n\t\tif (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table (bin, curAddr))) {\n\t\t\tbprintf (\"Warning: bad parsing StringTable\\n\");\n\t\t\tfree_StringFileInfo (stringFileInfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tstringFileInfo->numOfChildren++;\n\t\talign32 (*curAddr);\n\t}\n\n\tif (!stringFileInfo->numOfChildren) {\n\t\tbprintf (\"Warning: check (StringFileInfo numOfChildren)\\n\");\n\t\tfree_StringFileInfo (stringFileInfo);\n\t\treturn NULL;\n\t}\n\n\treturn stringFileInfo;\n}\n\n#define EXIT_ON_OVERFLOW(S)\\\n\tif (curAddr > bin->size || curAddr + (S) > bin->size) { \\\n\t\tgoto out_error; }\nstatic PE_VS_VERSIONINFO* Pe_r_bin_pe_parse_version_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord version_info_paddr) {\n\tut32 sz;\n\tPE_VS_VERSIONINFO* vs_VersionInfo = calloc (1, sizeof(PE_VS_VERSIONINFO));\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tPE_DWord startAddr = version_info_paddr;\n\tPE_DWord curAddr = version_info_paddr;\n\t//align32(curAddr); // XXX: do we really need this? Because in msdn\n\t//wLength is The length, in bytes, of the VS_VERSIONINFO structure.\n\t//This length does not include any padding that aligns any subsequent\n\t//version resource data on a 32-bit boundary.\n\t//Mb we are in subsequent version resource data and not aligned.\n\tsz = sizeof(ut16);\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) &vs_VersionInfo->wLength, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) &vs_VersionInfo->wValueLength, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) &vs_VersionInfo->wType, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (vs_VersionInfo->wType && vs_VersionInfo->wType != 1) {\n\t\tbprintf (\"Warning: check (VS_VERSIONINFO wType)\\n\");\n\t\tgoto out_error;\n\t}\n\n\tvs_VersionInfo->szKey = (ut16*) malloc (UT16_ALIGN (VS_VERSION_INFO_UTF_16_LEN));  //L\"VS_VERSION_INFO\"\n\tif (!vs_VersionInfo->szKey) {\n\t\tbprintf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tsz = VS_VERSION_INFO_UTF_16_LEN;\n\tEXIT_ON_OVERFLOW (sz);\n\tif (r_buf_read_at (bin->b, curAddr, (ut8*) vs_VersionInfo->szKey, sz) != sz) {\n\t\tbprintf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");\n\t\tgoto out_error;\n\t}\n\tcurAddr += sz;\n\tif (memcmp (vs_VersionInfo->szKey, VS_VERSION_INFO_UTF_16, sz)) {\n\t\tgoto out_error;\n\t}\n\talign32 (curAddr);\n\tif (vs_VersionInfo->wValueLength) {\n\t\tif (vs_VersionInfo->wValueLength != sizeof (*vs_VersionInfo->Value)) {\n\t\t\tbprintf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tvs_VersionInfo->Value = (PE_VS_FIXEDFILEINFO*) malloc (sizeof(*vs_VersionInfo->Value));\n\t\tif (!vs_VersionInfo->Value) {\n\t\t\tbprintf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tsz = sizeof(PE_VS_FIXEDFILEINFO);\n\t\tEXIT_ON_OVERFLOW (sz);\n\t\tif (r_buf_read_at (bin->b, curAddr, (ut8*) vs_VersionInfo->Value, sz) != sz) {\n\t\t\tbprintf (\"Warning: read (VS_VERSIONINFO Value)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (vs_VersionInfo->Value->dwSignature != 0xFEEF04BD) {\n\t\t\tbprintf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurAddr += sz;\n\t\talign32 (curAddr);\n\t}\n\n\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\tchar t = '\\0';\n\t\tif (curAddr + 3 * sizeof(ut16) > bin->size || curAddr + 3 + sizeof(ut64) + 1 > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, curAddr + 3 * sizeof(ut16), (ut8*) &t, 1) != 1) {\n\t\t\tbprintf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (!(t == 'S' || t == 'V')) {\n\t\t\tbprintf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");\n\t\t\tgoto out_error;\n\t\t}\n\t\tif (t == 'S') {\n\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (bin, &curAddr))) {\n\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t\tif (t == 'V') {\n\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (bin, &curAddr))) {\n\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\n\t\talign32 (curAddr);\n\n\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\tif (t == 'V') {\n\t\t\t\tif (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (bin, &curAddr))) {\n\t\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t} else if (t == 'S') {\n\t\t\t\tif (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (bin, &curAddr))) {\n\t\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (startAddr + vs_VersionInfo->wLength > curAddr) {\n\t\t\t\tbprintf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\treturn vs_VersionInfo;\nout_error:\n\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\treturn NULL;\n\n}\n\nstatic Sdb* Pe_r_bin_store_var(Var* var) {\n\tunsigned int i = 0;\n\tchar key[20];\n\tSdb* sdb = NULL;\n\tif (var) {\n\t\tsdb = sdb_new0 ();\n\t\tif (sdb) {\n\t\t\tfor (; i < var->numOfValues; i++) {\n\t\t\t\tsnprintf (key, 20, \"%d\", i);\n\t\t\t\tsdb_num_set (sdb, key, var->Value[i], 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_var_file_info(VarFileInfo* varFileInfo) {\n\tchar key[20];\n\tunsigned int i = 0;\n\tif (!varFileInfo) {\n\t\treturn NULL;\n\t}\n\tSdb* sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < varFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"var%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_var (varFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string(String* string) {\n\tSdb* sdb = NULL;\n\tchar* encodedVal = NULL, * encodedKey = NULL;\n\tif (!string) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) string->szKey, string->wKeyLen);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tencodedVal = sdb_encode ((unsigned char*) string->Value, string->wValueLength);\n\tif (!encodedVal) {\n\t\tfree (encodedKey);\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\",   encodedKey, 0);\n\tsdb_set (sdb, \"value\", encodedVal, 0);\n\tfree (encodedKey);\n\tfree (encodedVal);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_table(StringTable* stringTable) {\n\tchar key[20];\n\tchar* encodedKey = NULL;\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringTable) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tencodedKey = sdb_encode ((unsigned char*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN);\n\tif (!encodedKey) {\n\t\tsdb_free (sdb);\n\t\treturn NULL;\n\t}\n\tsdb_set (sdb, \"key\", encodedKey, 0);\n\tfree (encodedKey);\n\tfor (; i < stringTable->numOfChildren; i++) {\n\t\tsnprintf (key, 20, \"string%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string (stringTable->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_string_file_info(StringFileInfo* stringFileInfo) {\n\tchar key[30];\n\tint i = 0;\n\tSdb* sdb = NULL;\n\tif (!stringFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tfor (; i < stringFileInfo->numOfChildren; i++) {\n\t\tsnprintf (key, 30, \"stringtable%d\", i);\n\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_string_table (stringFileInfo->Children[i]));\n\t}\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_fixed_file_info(PE_VS_FIXEDFILEINFO* vs_fixedFileInfo) {\n\tSdb* sdb = NULL;\n\tif (!vs_fixedFileInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tsdb_num_set (sdb, \"Signature\",        vs_fixedFileInfo->dwSignature,        0);\n\tsdb_num_set (sdb, \"StrucVersion\",     vs_fixedFileInfo->dwStrucVersion,     0);\n\tsdb_num_set (sdb, \"FileVersionMS\",    vs_fixedFileInfo->dwFileVersionMS,    0);\n\tsdb_num_set (sdb, \"FileVersionLS\",    vs_fixedFileInfo->dwFileVersionLS,    0);\n\tsdb_num_set (sdb, \"ProductVersionMS\", vs_fixedFileInfo->dwProductVersionMS, 0);\n\tsdb_num_set (sdb, \"ProductVersionLS\", vs_fixedFileInfo->dwProductVersionLS, 0);\n\tsdb_num_set (sdb, \"FileFlagsMask\",    vs_fixedFileInfo->dwFileFlagsMask,    0);\n\tsdb_num_set (sdb, \"FileFlags\",        vs_fixedFileInfo->dwFileFlags,        0);\n\tsdb_num_set (sdb, \"FileOS\",           vs_fixedFileInfo->dwFileOS,           0);\n\tsdb_num_set (sdb, \"FileType\",         vs_fixedFileInfo->dwFileType,         0);\n\tsdb_num_set (sdb, \"FileSubtype\",      vs_fixedFileInfo->dwFileSubtype,      0);\n\tsdb_num_set (sdb, \"FileDateMS\",       vs_fixedFileInfo->dwFileDateMS,       0);\n\tsdb_num_set (sdb, \"FileDateLS\",       vs_fixedFileInfo->dwFileDateLS,       0);\n\treturn sdb;\n}\n\nstatic Sdb* Pe_r_bin_store_resource_version_info(PE_VS_VERSIONINFO* vs_VersionInfo) {\n\tSdb* sdb = NULL;\n\tif (!vs_VersionInfo) {\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (vs_VersionInfo->Value) {\n\t\tsdb_ns_set (sdb, \"fixed_file_info\", Pe_r_bin_store_fixed_file_info (vs_VersionInfo->Value));\n\t}\n\tif (vs_VersionInfo->varFileInfo) {\n\t\tsdb_ns_set (sdb, \"var_file_info\", Pe_r_bin_store_var_file_info (vs_VersionInfo->varFileInfo));\n\t}\n\tif (vs_VersionInfo->stringFileInfo) {\n\t\tsdb_ns_set (sdb, \"string_file_info\", Pe_r_bin_store_string_file_info (vs_VersionInfo->stringFileInfo));\n\t}\n\treturn sdb;\n}\n\nstatic char* _resource_lang_str(int id) {\n\tswitch(id) {\n\tcase 0x00: return \"LANG_NEUTRAL\";\n\tcase 0x7f: return \"LANG_INVARIANT\";\n\tcase 0x36: return \"LANG_AFRIKAANS\";\n\tcase 0x1c: return \"LANG_ALBANIAN \";\n\tcase 0x01: return \"LANG_ARABIC\";\n\tcase 0x2b: return \"LANG_ARMENIAN\";\n\tcase 0x4d: return \"LANG_ASSAMESE\";\n\tcase 0x2c: return \"LANG_AZERI\";\n\tcase 0x2d: return \"LANG_BASQUE\";\n\tcase 0x23: return \"LANG_BELARUSIAN\";\n\tcase 0x45: return \"LANG_BENGALI\";\n\tcase 0x02: return \"LANG_BULGARIAN\";\n\tcase 0x03: return \"LANG_CATALAN\";\n\tcase 0x04: return \"LANG_CHINESE\";\n\tcase 0x1a: return \"LANG_CROATIAN\";\n\tcase 0x05: return \"LANG_CZECH\";\n\tcase 0x06: return \"LANG_DANISH\";\n\tcase 0x65: return \"LANG_DIVEHI\";\n\tcase 0x13: return \"LANG_DUTCH\";\n\tcase 0x09: return \"LANG_ENGLISH\";\n\tcase 0x25: return \"LANG_ESTONIAN\";\n\tcase 0x38: return \"LANG_FAEROESE\";\n\tcase 0x29: return \"LANG_FARSI\";\n\tcase 0x0b: return \"LANG_FINNISH\";\n\tcase 0x0c: return \"LANG_FRENCH\";\n\tcase 0x56: return \"LANG_GALICIAN\";\n\tcase 0x37: return \"LANG_GEORGIAN\";\n\tcase 0x07: return \"LANG_GERMAN\";\n\tcase 0x08: return \"LANG_GREEK\";\n\tcase 0x47: return \"LANG_GUJARATI\";\n\tcase 0x0d: return \"LANG_HEBREW\";\n\tcase 0x39: return \"LANG_HINDI\";\n\tcase 0x0e: return \"LANG_HUNGARIAN\";\n\tcase 0x0f: return \"LANG_ICELANDIC\";\n\tcase 0x21: return \"LANG_INDONESIAN\";\n\tcase 0x10: return \"LANG_ITALIAN\";\n\tcase 0x11: return \"LANG_JAPANESE\";\n\tcase 0x4b: return \"LANG_KANNADA\";\n\tcase 0x60: return \"LANG_KASHMIRI\";\n\tcase 0x3f: return \"LANG_KAZAK\";\n\tcase 0x57: return \"LANG_KONKANI\";\n\tcase 0x12: return \"LANG_KOREAN\";\n\tcase 0x40: return \"LANG_KYRGYZ\";\n\tcase 0x26: return \"LANG_LATVIAN\";\n\tcase 0x27: return \"LANG_LITHUANIAN\";\n\tcase 0x2f: return \"LANG_MACEDONIAN\";\n\tcase 0x3e: return \"LANG_MALAY\";\n\tcase 0x4c: return \"LANG_MALAYALAM\";\n\tcase 0x58: return \"LANG_MANIPURI\";\n\tcase 0x4e: return \"LANG_MARATHI\";\n\tcase 0x50: return \"LANG_MONGOLIAN\";\n\tcase 0x61: return \"LANG_NEPALI\";\n\tcase 0x14: return \"LANG_NORWEGIAN\";\n\tcase 0x48: return \"LANG_ORIYA\";\n\tcase 0x15: return \"LANG_POLISH\";\n\tcase 0x16: return \"LANG_PORTUGUESE\";\n\tcase 0x46: return \"LANG_PUNJABI\";\n\tcase 0x18: return \"LANG_ROMANIAN\";\n\tcase 0x19: return \"LANG_RUSSIAN\";\n\tcase 0x4f: return \"LANG_SANSKRIT\";\n\tcase 0x59: return \"LANG_SINDHI\";\n\tcase 0x1b: return \"LANG_SLOVAK\";\n\tcase 0x24: return \"LANG_SLOVENIAN\";\n\tcase 0x0a: return \"LANG_SPANISH \";\n\tcase 0x41: return \"LANG_SWAHILI\";\n\tcase 0x1d: return \"LANG_SWEDISH\";\n\tcase 0x5a: return \"LANG_SYRIAC\";\n\tcase 0x49: return \"LANG_TAMIL\";\n\tcase 0x44: return \"LANG_TATAR\";\n\tcase 0x4a: return \"LANG_TELUGU\";\n\tcase 0x1e: return \"LANG_THAI\";\n\tcase 0x1f: return \"LANG_TURKISH\";\n\tcase 0x22: return \"LANG_UKRAINIAN\";\n\tcase 0x20: return \"LANG_URDU\";\n\tcase 0x43: return \"LANG_UZBEK\";\n\tcase 0x2a: return \"LANG_VIETNAMESE\";\n\tcase 0x3c: return \"LANG_GAELIC\";\n\tcase 0x3a: return \"LANG_MALTESE\";\n\tcase 0x28: return \"LANG_MAORI\";\n\tcase 0x17: return \"LANG_RHAETO_ROMANCE\";\n\tcase 0x3b: return \"LANG_SAAMI\";\n\tcase 0x2e: return \"LANG_SORBIAN\";\n\tcase 0x30: return \"LANG_SUTU\";\n\tcase 0x31: return \"LANG_TSONGA\";\n\tcase 0x32: return \"LANG_TSWANA\";\n\tcase 0x33: return \"LANG_VENDA\";\n\tcase 0x34: return \"LANG_XHOSA\";\n\tcase 0x35: return \"LANG_ZULU\";\n\tcase 0x8f: return \"LANG_ESPERANTO\";\n\tcase 0x90: return \"LANG_WALON\";\n\tcase 0x91: return \"LANG_CORNISH\";\n\tcase 0x92: return \"LANG_WELSH\";\n\tcase 0x93: return \"LANG_BRETON\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\nstatic char* _resource_type_str(int type) {\n\tswitch (type) {\n\tcase 1: return \"CURSOR\";\n\tcase 2: return \"BITMAP\";\n\tcase 3: return \"ICON\";\n\tcase 4: return \"MENU\";\n\tcase 5: return \"DIALOG\";\n\tcase 6: return \"STRING\";\n\tcase 7: return \"FONTDIR\";\n\tcase 8: return \"FONT\";\n\tcase 9: return \"ACCELERATOR\";\n\tcase 10: return \"RCDATA\";\n\tcase 11: return \"MESSAGETABLE\";\n\tcase 12: return \"GROUP_CURSOR\";\n\tcase 14: return \"GROUP_ICON\";\n\tcase 16: return \"VERSION\";\n\tcase 17: return \"DLGINCLUDE\";\n\tcase 19: return \"PLUGPLAY\";\n\tcase 20: return \"VXD\";\n\tcase 21: return \"ANICURSOR\";\n\tcase 22: return \"ANIICON\";\n\tcase 23: return \"HTML\";\n\tcase 24: return \"MANIFEST\";\n\tdefault: return \"UNKNOWN\";\n\t}\n}\n\nstatic void _parse_resource_directory(struct PE_(r_bin_pe_obj_t) *bin, Pe_image_resource_directory *dir, ut64 offDir, int type, int id, SdbHash *dirs) {\n\tint index = 0;\n\tut32 totalRes = dir->NumberOfNamedEntries + dir->NumberOfIdEntries;\n\tut64 rsrc_base = bin->resource_directory_offset;\n\tut64 off;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry entry;\n\t\toff = rsrc_base + offDir + sizeof(*dir) + index * sizeof(entry);\n\t\tchar *key = sdb_fmt (\"0x%08\"PFMT64x, off);\n\t\tif (sdb_ht_find (dirs, key, NULL)) {\n\t\t\tbreak;\n\t\t}\n\t\tsdb_ht_insert (dirs, key, \"1\");\n\t\tif (off > bin->size || off + sizeof (entry) > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, off, (ut8*)&entry, sizeof(entry)) < 1) {\n\t\t\teprintf (\"Warning: read resource entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (entry.u2.s.DataIsDirectory) {\n\t\t\t//detect here malicious file trying to making us infinite loop\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\toff = rsrc_base + entry.u2.s.OffsetToDirectory;\n\t\t\tint len = r_buf_read_at (bin->b, off, (ut8*) &identEntry, sizeof (identEntry));\n\t\t\tif (len < 1 || len != sizeof (Pe_image_resource_directory)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t_parse_resource_directory (bin, &identEntry,\n\t\t\t\tentry.u2.s.OffsetToDirectory, type, entry.u1.Id, dirs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tPe_image_resource_data_entry *data = R_NEW0 (Pe_image_resource_data_entry);\n\t\tif (!data) {\n\t\t\tbreak;\n\t\t}\n\t\toff = rsrc_base + entry.u2.OffsetToData;\n\t\tif (off > bin->size || off + sizeof (data) > bin->size) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, off, (ut8*)data, sizeof (*data)) != sizeof (*data)) {\n\t\t\teprintf (\"Warning: read (resource data entry)\\n\");\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\tif (type == PE_RESOURCE_ENTRY_VERSION) {\n\t\t\tchar key[64];\n\t\t\tint counter = 0;\n\t\t\tSdb *sdb = sdb_new0 ();\n\t\t\tif (!sdb) {\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord data_paddr = bin_pe_rva_to_paddr (bin, data->OffsetToData);\n\t\t\tif (!data_paddr) {\n\t\t\t\tbprintf (\"Warning: bad RVA in resource data entry\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPE_DWord cur_paddr = data_paddr;\n\t\t\tif ((cur_paddr & 0x3) != 0) {\n\t\t\t\tbprintf (\"Warning: not aligned version info address\\n\");\n\t\t\t\tfree (data);\n\t\t\t\tsdb_free (sdb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (cur_paddr < (data_paddr + data->Size) && cur_paddr < bin->size) {\n\t\t\t\tPE_VS_VERSIONINFO* vs_VersionInfo = Pe_r_bin_pe_parse_version_info (bin, cur_paddr);\n\t\t\t\tif (vs_VersionInfo) {\n\t\t\t\t\tsnprintf (key, 30, \"VS_VERSIONINFO%d\", counter++);\n\t\t\t\t\tsdb_ns_set (sdb, key, Pe_r_bin_store_resource_version_info (vs_VersionInfo));\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (vs_VersionInfo->wLength < 1) {\n\t\t\t\t\t// Invalid version length\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_paddr += vs_VersionInfo->wLength;\n\t\t\t\tfree_VS_VERSIONINFO (vs_VersionInfo);\n\t\t\t\talign32 (cur_paddr);\n\t\t\t}\n\t\t\tsdb_ns_set (bin->kv, \"vs_version_info\", sdb);\n\t\t}\n\t\tr_pe_resource *rs = R_NEW0 (r_pe_resource);\n\t\tif (!rs) {\n\t\t\tfree (data);\n\t\t\tbreak;\n\t\t}\n\t\trs->timestr = _time_stamp_to_str (dir->TimeDateStamp);\n\t\trs->type = strdup (_resource_type_str (type));\n\t\trs->language = strdup (_resource_lang_str (entry.u1.Name & 0x3ff));\n\t\trs->data = data;\n\t\trs->name = id;\n\t\tr_list_append (bin->resources, rs);\n\t}\n}\n\nstatic void _store_resource_sdb(struct PE_(r_bin_pe_obj_t) *bin) {\n\tRListIter *iter;\n\tr_pe_resource *rs;\n\tint index = 0;\n\tut64 vaddr = 0;\n\tchar *key;\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn;\n\t}\n\tr_list_foreach (bin->resources, iter, rs) {\n\t\tkey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tsdb_set (sdb, key, rs->timestr, 0);\n\t\tkey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tvaddr = bin_pe_rva_to_va (bin, rs->data->OffsetToData);\n\t\tsdb_num_set (sdb, key, vaddr, 0);\n\t\tkey = sdb_fmt (\"resource.%d.name\", index);\n\t\tsdb_num_set (sdb, key, rs->name, 0);\n\t\tkey = sdb_fmt (\"resource.%d.size\", index);\n\t\tsdb_num_set (sdb, key, rs->data->Size, 0);\n\t\tkey = sdb_fmt (\"resource.%d.type\", index);\n\t\tsdb_set (sdb, key, rs->type, 0);\n\t\tkey = sdb_fmt (\"resource.%d.language\", index);\n\t\tsdb_set (sdb, key, rs->language, 0);\n\t\tindex++;\n\t}\n\tsdb_ns_set (bin->kv, \"pe_resource\", sdb);\n}\n\n\nR_API void PE_(bin_pe_parse_resource)(struct PE_(r_bin_pe_obj_t) *bin) {\n\tint index = 0;\n\tut64 off = 0, rsrc_base = bin->resource_directory_offset;\n\tPe_image_resource_directory *rs_directory = bin->resource_directory;\n\tut32 curRes = 0;\n\tint totalRes = 0;\n\tSdbHash *dirs = sdb_ht_new (); //to avoid infinite loops\n\tif (!dirs) {\n\t\treturn;\n\t}\n\tif (!rs_directory) {\n\t\tsdb_ht_free (dirs);\n\t\treturn;\n\t}\n\tcurRes = rs_directory->NumberOfNamedEntries;\n\ttotalRes = curRes + rs_directory->NumberOfIdEntries;\n\tif (totalRes > R_PE_MAX_RESOURCES) {\n\t\teprintf (\"Error parsing resource directory\\n\");\n\t\tsdb_ht_free (dirs);\n\t\treturn;\n\t}\n\tfor (index = 0; index < totalRes; index++) {\n\t\tPe_image_resource_directory_entry typeEntry;\n\t\toff = rsrc_base + sizeof (*rs_directory) + index * sizeof (typeEntry);\n\t\tsdb_ht_insert (dirs, sdb_fmt (\"0x%08\"PFMT64x, off), \"1\");\n\t\tif (off > bin->size || off + sizeof(typeEntry) > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, off, (ut8*)&typeEntry, sizeof(typeEntry)) < 1) {\n\t\t\teprintf (\"Warning: read resource  directory entry\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (typeEntry.u2.s.DataIsDirectory) {\n\t\t\tPe_image_resource_directory identEntry;\n\t\t\toff = rsrc_base + typeEntry.u2.s.OffsetToDirectory;\n\t\t\tint len = r_buf_read_at (bin->b, off, (ut8*)&identEntry, sizeof(identEntry));\n\t\t\tif (len < 1 || len != sizeof (identEntry)) {\n\t\t\t\teprintf (\"Warning: parsing resource directory\\n\");\n\t\t\t}\n\t\t\t_parse_resource_directory (bin, &identEntry, typeEntry.u2.s.OffsetToDirectory, typeEntry.u1.Id, 0, dirs);\n\t\t}\n\t}\n\tsdb_ht_free (dirs);\n\t_store_resource_sdb (bin);\n}\n\nstatic void bin_pe_get_certificate(struct PE_ (r_bin_pe_obj_t) * bin) {\n\tut64 size, vaddr;\n\tut8 *data = NULL;\n\tint len;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn;\n\t}\n\tbin->cms = NULL;\n\tsize = bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY].Size;\n\tvaddr = bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress;\n\tdata = calloc (1, size);\n\tif (!data) {\n\t\treturn;\n\t}\n\tif (vaddr > bin->size || vaddr + size > bin->size) {\n\t\tbprintf (\"vaddr greater than the file\\n\");\n\t\tfree (data);\n\t\treturn;\n\t}\n\t//skipping useless header..\n\tlen = r_buf_read_at (bin->b, vaddr + 8, data, size - 8);\n\tif (len < 1) {\n\t\tR_FREE (data);\n\t\treturn;\n\t}\n\tbin->cms = r_pkcs7_parse_cms (data, size);\n\tbin->is_signed = bin->cms != NULL;\n\tR_FREE (data);\n}\n\nstatic int bin_pe_init(struct PE_(r_bin_pe_obj_t)* bin) {\n\tbin->dos_header = NULL;\n\tbin->nt_headers = NULL;\n\tbin->section_header = NULL;\n\tbin->export_directory = NULL;\n\tbin->import_directory = NULL;\n\tbin->resource_directory = NULL;\n\tbin->delay_import_directory = NULL;\n\tbin->optional_header = NULL;\n\tbin->data_directory = NULL;\n\tbin->big_endian = 0;\n\tif (!bin_pe_init_hdr (bin)) {\n\t\teprintf (\"Warning: File is not PE\\n\");\n\t\treturn false;\n\t}\n\tif (!bin_pe_init_sections (bin)) {\n\t\teprintf (\"Warning: Cannot initialize sections\\n\");\n\t\treturn false;\n\t}\n\tbin_pe_init_imports (bin);\n\tbin_pe_init_exports (bin);\n\tbin_pe_init_resource (bin);\n\tbin_pe_get_certificate(bin);\n\n\tbin->big_endian = PE_(r_bin_pe_is_big_endian) (bin);\n\n\tbin_pe_init_tls (bin);\n\tbin_pe_init_clr_hdr (bin);\n\tbin_pe_init_metadata_hdr (bin);\n\tbin_pe_init_overlay (bin);\n\tPE_(bin_pe_parse_resource) (bin);\n\tbin->relocs = NULL;\n\treturn true;\n}\n\nchar* PE_(r_bin_pe_get_arch)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* arch;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn strdup (\"x86\");\n\t}\n\tswitch (bin->nt_headers->file_header.Machine) {\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA:\n\tcase PE_IMAGE_FILE_MACHINE_ALPHA64:\n\t\tarch = strdup (\"alpha\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_RPI2: // 462\n\tcase PE_IMAGE_FILE_MACHINE_ARM:\n\tcase PE_IMAGE_FILE_MACHINE_THUMB:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_M68K:\n\t\tarch = strdup (\"m68k\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_MIPS16:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU:\n\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16:\n\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2:\n\t\tarch = strdup (\"mips\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_POWERPC:\n\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP:\n\t\tarch = strdup (\"ppc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_EBC:\n\t\tarch = strdup (\"ebc\");\n\t\tbreak;\n\tcase PE_IMAGE_FILE_MACHINE_ARM64:\n\t\tarch = strdup (\"arm\");\n\t\tbreak;\n\tdefault:\n\t\tarch = strdup (\"x86\");\n\t}\n\treturn arch;\n}\n\nstruct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_addr_t* entry = NULL;\n\tstatic bool debug = false;\n\tPE_DWord pe_entry;\n\tint i;\n\tut64 base_addr = PE_(r_bin_pe_get_image_base) (bin);\n\tif (!bin || !bin->optional_header) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = malloc (sizeof (struct r_bin_pe_addr_t)))) {\n\t\tr_sys_perror (\"malloc (entrypoint)\");\n\t\treturn NULL;\n\t}\n\tpe_entry = bin->optional_header->AddressOfEntryPoint;\n\tentry->vaddr = bin_pe_rva_to_va (bin, pe_entry);\n\tentry->paddr = bin_pe_rva_to_paddr (bin, pe_entry);\n\t// haddr is the address of AddressOfEntryPoint in header.\n\tentry->haddr = bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) + 16;\n\n\tif (entry->paddr >= bin->size) {\n\t\tstruct r_bin_pe_section_t* sections = PE_(r_bin_pe_get_sections) (bin);\n\t\tut64 paddr = 0;\n\t\tif (!debug) {\n\t\t\tbprintf (\"Warning: Invalid entrypoint ... \"\n\t\t\t\t\"trying to fix it but i do not promise nothing\\n\");\n\t\t}\n\t\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t\tif (sections[i].flags & PE_IMAGE_SCN_MEM_EXECUTE) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tpaddr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (!paddr) {\n\t\t\tut64 min_off = -1;\n\t\t\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t\t\t//get the lowest section's paddr\n\t\t\t\tif (sections[i].paddr < min_off) {\n\t\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\t\tmin_off = sections[i].paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_off == -1) {\n\t\t\t\t//no section just a hack to try to fix entrypoint\n\t\t\t\t//maybe doesn't work always\n\t\t\t\tint sa = R_MAX (bin->optional_header->SectionAlignment, 0x1000);\n\t\t\t\tentry->paddr = pe_entry & ((sa << 1) - 1);\n\t\t\t\tentry->vaddr = entry->paddr + base_addr;\n\t\t\t}\n\t\t}\n\t\tfree (sections);\n\n\t}\n\tif (!entry->paddr) {\n\t\tif (!debug) {\n\t\t\tbprintf (\"Warning: NULL entrypoint\\n\");\n\t\t}\n\t\tstruct r_bin_pe_section_t* sections = PE_(r_bin_pe_get_sections) (bin);\n\t\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t\t//If there is a section with x without w perm is a good candidate to be the entrypoint\n\t\t\tif (sections[i].flags & PE_IMAGE_SCN_MEM_EXECUTE && !(sections[i].flags & PE_IMAGE_SCN_MEM_WRITE)) {\n\t\t\t\tentry->paddr = sections[i].paddr;\n\t\t\t\tentry->vaddr = sections[i].vaddr + base_addr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tfree (sections);\n\t}\n\n\tif (is_arm (bin) && entry->vaddr & 1) {\n\t\tentry->vaddr--;\n\t\tif (entry->paddr & 1) {\n\t\t\tentry->paddr--;\n\t\t}\n\t}\n\tif (!debug) {\n\t\tdebug = true;\n\t}\n\treturn entry;\n}\n\nstruct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_export_t* exp, * exports = NULL;\n\tPE_Word function_ordinal;\n\tPE_VWord functions_paddr, names_paddr, ordinals_paddr, function_rva, name_vaddr, name_paddr;\n\tchar function_name[PE_NAME_LENGTH + 1], forwarder_name[PE_NAME_LENGTH + 1];\n\tchar dll_name[PE_NAME_LENGTH + 1], export_name[256];\n\tPE_(image_data_directory) * data_dir_export;\n\tPE_VWord export_dir_rva;\n\tint n,i, export_dir_size;\n\tst64 exports_sz = 0;\n\n\tif (!bin || !bin->data_directory) {\n\t\treturn NULL;\n\t}\n\tdata_dir_export = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];\n\texport_dir_rva = data_dir_export->VirtualAddress;\n\texport_dir_size = data_dir_export->Size;\n\tif (bin->export_directory) {\n\t\tif (bin->export_directory->NumberOfFunctions + 1 <\n\t\tbin->export_directory->NumberOfFunctions) {\n\t\t\t// avoid integer overflow\n\t\t\treturn NULL;\n\t\t}\n\t\texports_sz = (bin->export_directory->NumberOfFunctions + 1) * sizeof (struct r_bin_pe_export_t);\n\t\t// we cant exit with export_sz > bin->size, us r_bin_pe_export_t is 256+256+8+8+8+4 bytes is easy get over file size\n\t\t// to avoid fuzzing we can abort on export_directory->NumberOfFunctions>0xffff\n\t\tif (exports_sz < 0 || bin->export_directory->NumberOfFunctions + 1 > 0xffff) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(exports = malloc (exports_sz))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (r_buf_read_at (bin->b, bin_pe_rva_to_paddr (bin, bin->export_directory->Name), (ut8*) dll_name, PE_NAME_LENGTH) < 1) {\n\t\t\tbprintf (\"Warning: read (dll name)\\n\");\n\t\t\tfree (exports);\n\t\t\treturn NULL;\n\t\t}\n\t\tfunctions_paddr = bin_pe_rva_to_paddr (bin, bin->export_directory->AddressOfFunctions);\n\t\tnames_paddr = bin_pe_rva_to_paddr (bin, bin->export_directory->AddressOfNames);\n\t\tordinals_paddr = bin_pe_rva_to_paddr (bin, bin->export_directory->AddressOfOrdinals);\n\t\tfor (i = 0; i < bin->export_directory->NumberOfFunctions; i++) {\n\t\t\t// get vaddr from AddressOfFunctions array\n\t\t\tint ret = r_buf_read_at (bin->b, functions_paddr + i * sizeof(PE_VWord), (ut8*) &function_rva, sizeof(PE_VWord));\n\t\t\tif (ret < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// have exports by name?\n\t\t\tif (bin->export_directory->NumberOfNames != 0) {\n\t\t\t\t// search for value of i into AddressOfOrdinals\n\t\t\t\tname_vaddr = 0;\n\t\t\t\tfor (n = 0; n < bin->export_directory->NumberOfNames; n++) {\n\t\t\t\t\tret = r_buf_read_at (bin->b, ordinals_paddr + n * sizeof(PE_Word), (ut8*) &function_ordinal, sizeof (PE_Word));\n\t\t\t\t\tif (ret < 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// if exist this index into AddressOfOrdinals\n\t\t\t\t\tif (i == function_ordinal) {\n\t\t\t\t\t\t// get the VA of export name  from AddressOfNames\n\t\t\t\t\t\tr_buf_read_at (bin->b, names_paddr + n * sizeof (PE_VWord), (ut8*) &name_vaddr, sizeof (PE_VWord));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// have an address into name_vaddr?\n\t\t\t\tif (name_vaddr) {\n\t\t\t\t\t// get the name of the Export\n\t\t\t\t\tname_paddr = bin_pe_rva_to_paddr (bin, name_vaddr);\n\t\t\t\t\tif (r_buf_read_at (bin->b, name_paddr, (ut8*) function_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\t\tbprintf (\"Warning: read (function name)\\n\");\n\t\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\t\treturn exports;\n\t\t\t\t\t}\n\t\t\t\t} else { // No name export, get the ordinal\n\t\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + 1);\n\t\t\t\t}\n\t\t\t}else { // if dont export by name exist, get the ordinal taking in mind the Base value.\n\t\t\t\tfunction_ordinal = i + bin->export_directory->Base;\n\t\t\t\tsnprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", function_ordinal);\n\t\t\t}\n\t\t\t// check if VA are into export directory, this mean a forwarder export\n\t\t\tif (function_rva >= export_dir_rva && function_rva < (export_dir_rva + export_dir_size)) {\n\t\t\t\t// if forwarder, the VA point to Forwarded name\n\t\t\t\tif (r_buf_read_at (bin->b, bin_pe_rva_to_paddr (bin, function_rva), (ut8*) forwarder_name, PE_NAME_LENGTH) < 1) {\n\t\t\t\t\texports[i].last = 1;\n\t\t\t\t\treturn exports;\n\t\t\t\t}\n\t\t\t} else { // no forwarder export\n\t\t\t\tsnprintf (forwarder_name, PE_NAME_LENGTH, \"NONE\");\n\t\t\t}\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tfunction_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tsnprintf (export_name, sizeof (export_name) - 1, \"%s_%s\", dll_name, function_name);\n\t\t\texports[i].vaddr = bin_pe_rva_to_va (bin, function_rva);\n\t\t\texports[i].paddr = bin_pe_rva_to_paddr (bin, function_rva);\n\t\t\texports[i].ordinal = function_ordinal;\n\t\t\tmemcpy (exports[i].forwarder, forwarder_name, PE_NAME_LENGTH);\n\t\t\texports[i].forwarder[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy (exports[i].name,      export_name,    PE_NAME_LENGTH);\n\t\t\texports[i].name[PE_NAME_LENGTH] = '\\0';\n\t\t\texports[i].last = 0;\n\t\t}\n\t\texports[i].last = 1;\n\t}\n\texp = parse_symbol_table (bin, exports, exports_sz - 1);\n\tif (exp) {\n\t\texports = exp;\n\t}\n\treturn exports;\n}\n\nstatic void free_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tR_FREE (rsds_hdr->file_name);\n}\n\nstatic void init_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tmemset (rsds_hdr, 0, sizeof (SCV_RSDS_HEADER));\n\trsds_hdr->free = (void (*)(struct SCV_RSDS_HEADER*))free_rsdr_hdr;\n}\n\nstatic void free_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tR_FREE (cv_nb10_header->file_name);\n}\n\nstatic void init_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tmemset (cv_nb10_header, 0, sizeof (SCV_NB10_HEADER));\n\tcv_nb10_header->free = (void (*)(struct SCV_NB10_HEADER*))free_cv_nb10_header;\n}\n\nstatic bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {\n\tconst int rsds_sz = 4 + sizeof (SGUID) + 4;\n\tif (dbg_data_len < rsds_sz) {\n\t\treturn false;\n\t}\n\tmemcpy (res, dbg_data, rsds_sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + rsds_sz);\n\treturn true;\n}\n\nstatic void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\t// memcpy (res, dbg_data, nb10sz);\n\t// res->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}\n\nstatic int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n\t#define SIZEOF_FILE_NAME 255\n\tint i = 0;\n\tconst char* basename;\n\tif (!dbg_data) {\n\t\treturn 0;\n\t}\n\tswitch (dbg_dir_entry->Type) {\n\tcase IMAGE_DEBUG_TYPE_CODEVIEW:\n\t\tif (!strncmp ((char*) dbg_data, \"RSDS\", 4)) {\n\t\t\tSCV_RSDS_HEADER rsds_hdr;\n\t\t\tinit_rsdr_hdr (&rsds_hdr);\n\t\t\tif (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {\n\t\t\t\tbprintf (\"Warning: Cannot read PE debug info\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsnprintf (res->guidstr, GUIDSTR_LEN,\n\t\t\t\t\"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\",\n\t\t\t\trsds_hdr.guid.data1,\n\t\t\t\trsds_hdr.guid.data2,\n\t\t\t\trsds_hdr.guid.data3,\n\t\t\t\trsds_hdr.guid.data4[0],\n\t\t\t\trsds_hdr.guid.data4[1],\n\t\t\t\trsds_hdr.guid.data4[2],\n\t\t\t\trsds_hdr.guid.data4[3],\n\t\t\t\trsds_hdr.guid.data4[4],\n\t\t\t\trsds_hdr.guid.data4[5],\n\t\t\t\trsds_hdr.guid.data4[6],\n\t\t\t\trsds_hdr.guid.data4[7],\n\t\t\t\trsds_hdr.age);\n\t\t\tbasename = r_file_basename ((char*) rsds_hdr.file_name);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tbasename, sizeof (res->file_name));\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n\t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n\t\t\tif (dbg_data_len < 20) {\n\t\t\t\teprintf (\"Truncated NB10 entry, not enough data to parse\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tSCV_NB10_HEADER nb10_hdr = {{0}};\n\t\t\tinit_cv_nb10_header (&nb10_hdr);\n\t\t\tget_nb10 (dbg_data, &nb10_hdr);\n\t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n\t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n\t\t\tres->file_name[0] = 0;\n\t\t\tif (nb10_hdr.file_name) {\n\t\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\t\t\tnb10_hdr.file_name, sizeof (res->file_name) - 1);\n\t\t\t}\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n\t\t} else {\n\t\t\tbprintf (\"CodeView section not NB10 or RSDS\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//bprintf(\"get_debug_info(): not supported type\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (i < 33) {\n\t\tres->guidstr[i] = toupper ((int) res->guidstr[i]);\n\t\ti++;\n\t}\n\n\treturn 1;\n}\n\nint PE_(r_bin_pe_get_debug_data)(struct PE_(r_bin_pe_obj_t)* bin, SDebugInfo* res) {\n\tPE_(image_debug_directory_entry)* img_dbg_dir_entry = NULL;\n\tPE_(image_data_directory) * dbg_dir;\n\tPE_DWord dbg_dir_offset;\n\tut8* dbg_data = 0;\n\tint result = 0;\n\tif (!bin) {\n\t\treturn 0;\n\t}\n\tdbg_dir = &bin->nt_headers->optional_header.DataDirectory[6 /*IMAGE_DIRECTORY_ENTRY_DEBUG*/];\n\tdbg_dir_offset = bin_pe_rva_to_paddr (bin, dbg_dir->VirtualAddress);\n\tif ((int) dbg_dir_offset < 0 || dbg_dir_offset >= bin->size) {\n\t\treturn false;\n\t}\n\tif (dbg_dir_offset >= bin->b->length) {\n\t\treturn false;\n\t}\n\timg_dbg_dir_entry = (PE_(image_debug_directory_entry)*)(bin->b->buf + dbg_dir_offset);\n\tif ((bin->b->length - dbg_dir_offset) < sizeof (PE_(image_debug_directory_entry))) {\n\t\treturn false;\n\t}\n\tif (img_dbg_dir_entry) {\n\t\tut32 dbg_data_poff = R_MIN (img_dbg_dir_entry->PointerToRawData, bin->b->length);\n\t\tint dbg_data_len = R_MIN (img_dbg_dir_entry->SizeOfData, bin->b->length - dbg_data_poff);\n\t\tif (dbg_data_len < 1) {\n\t\t\treturn false;\n\t\t}\n\t\tdbg_data = (ut8*) calloc (1, dbg_data_len + 1);\n\t\tif (dbg_data) {\n\t\t\tr_buf_read_at (bin->b, dbg_data_poff, dbg_data, dbg_data_len);\n\t\t\tresult = get_debug_info (bin, img_dbg_dir_entry, dbg_data, dbg_data_len, res);\n\t\t\tR_FREE (dbg_data);\n\t\t}\n\t}\n\treturn result;\n}\n\nstruct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_import_t* imps, * imports = NULL;\n\tchar dll_name[PE_NAME_LENGTH + 1];\n\tint nimp = 0;\n\tut64 off; //used to cache value\n\tPE_DWord dll_name_offset = 0;\n\tPE_DWord paddr = 0;\n\tPE_DWord import_func_name_offset;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = 0;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->import_directory_offset >= bin->size) {\n\t\treturn NULL;\n\t}\n\tif (bin->import_directory_offset + 32 >= bin->size) {\n\t\treturn NULL;\n\t}\n\n\toff = bin->import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tvoid* last;\n\t\tif (off + sizeof(PE_(image_import_directory)) > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcurr_import_dir = (PE_(image_import_directory)*)(bin->b->buf + bin->import_directory_offset);\n\t\tdll_name_offset = curr_import_dir->Name;\n\n\t\tif (bin->import_directory_size < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (off + bin->import_directory_size > bin->size) {\n\t\t\t//why chopping instead of returning and cleaning?\n\t\t\tbprintf (\"Warning: read (import directory too big)\\n\");\n\t\t\tbin->import_directory_size = bin->size - bin->import_directory_offset;\n\t\t}\n\t\tlast = (char*) curr_import_dir + bin->import_directory_size;\n\t\twhile ((void*) (curr_import_dir + 1) <= last && (\n\t\t\tcurr_import_dir->FirstThunk != 0 || curr_import_dir->Name != 0 ||\n\t\t\tcurr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||\n\t\t\tcurr_import_dir->ForwarderChain != 0)) {\n\t\t\tint rr;\n\t\t\tdll_name_offset = curr_import_dir->Name;\n\t\t\tpaddr = bin_pe_rva_to_paddr (bin, dll_name_offset);\n\t\t\tif (paddr > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (paddr + PE_NAME_LENGTH > bin->size) {\n\t\t\t\trr = r_buf_read_at (bin->b, paddr, (ut8*) dll_name, bin->size - paddr);\n\t\t\t\tif (rr != bin->size - paddr) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[bin->size - paddr] = '\\0';\n\t\t\t}else {\n\t\t\t\trr = r_buf_read_at (bin->b, paddr, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\t\tif (rr != PE_NAME_LENGTH) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\t}\n\t\t\tif (!bin_pe_parse_imports (bin, &imports, &nimp, dll_name,\n\t\t\t\tcurr_import_dir->Characteristics,\n\t\t\t\tcurr_import_dir->FirstThunk)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurr_import_dir++;\n\t\t}\n\t}\n\toff = bin->delay_import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tif (off + sizeof(PE_(image_delay_import_directory)) > bin->size) {\n\t\t\tgoto beach;\n\t\t}\n\t\tcurr_delay_import_dir = (PE_(image_delay_import_directory)*)(bin->b->buf + off);\n\t\tif (!curr_delay_import_dir->Attributes) {\n\t\t\tdll_name_offset = bin_pe_rva_to_paddr (bin,\n\t\t\t\tcurr_delay_import_dir->Name - PE_(r_bin_pe_get_image_base)(bin));\n\t\t\timport_func_name_offset = curr_delay_import_dir->DelayImportNameTable -\n\t\t\tPE_(r_bin_pe_get_image_base)(bin);\n\t\t} else {\n\t\t\tdll_name_offset = bin_pe_rva_to_paddr (bin, curr_delay_import_dir->Name);\n\t\t\timport_func_name_offset = curr_delay_import_dir->DelayImportNameTable;\n\t\t}\n\t\twhile ((curr_delay_import_dir->Name != 0) && (curr_delay_import_dir->DelayImportAddressTable !=0)) {\n\t\t\tif (dll_name_offset > bin->size || dll_name_offset + PE_NAME_LENGTH > bin->size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tint rr = r_buf_read_at (bin->b, dll_name_offset, (ut8*) dll_name, PE_NAME_LENGTH);\n\t\t\tif (rr < 5) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tdll_name[PE_NAME_LENGTH] = '\\0';\n\t\t\tif (!bin_pe_parse_imports (bin, &imports, &nimp, dll_name, import_func_name_offset,\n\t\t\t\tcurr_delay_import_dir->DelayImportAddressTable)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((char*) (curr_delay_import_dir + 2) > (char*) (bin->b->buf + bin->size)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tcurr_delay_import_dir++;\n\t\t}\n\t}\nbeach:\n\tif (nimp) {\n\t\timps = realloc (imports, (nimp + 1) * sizeof(struct r_bin_pe_import_t));\n\t\tif (!imps) {\n\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\treturn NULL;\n\t\t}\n\t\timports = imps;\n\t\timports[nimp].last = 1;\n\t}\n\treturn imports;\n}\n\nstruct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_pe_lib_t* libs = NULL;\n\tPE_(image_import_directory) * curr_import_dir = NULL;\n\tPE_(image_delay_import_directory) * curr_delay_import_dir = NULL;\n\tPE_DWord name_off = 0;\n\tSdbHash* lib_map = NULL;\n\tut64 off; //cache value\n\tint index = 0;\n\tint len = 0;\n\tint max_libs = 20;\n\tlibs = calloc (max_libs + 1, sizeof(struct r_bin_pe_lib_t));\n\tif (!libs) {\n\t\tr_sys_perror (\"malloc (libs)\");\n\t\treturn NULL;\n\t}\n\n\tif (bin->import_directory_offset + bin->import_directory_size > bin->size) {\n\t\tbprintf (\"import directory offset bigger than file\\n\");\n\t\tgoto out_error;\n\t}\n\tlib_map = sdb_ht_new ();\n\toff = bin->import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tvoid* last = NULL;\n\t\t// normal imports\n\t\tif (off + sizeof (PE_(image_import_directory)) > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurr_import_dir = (PE_(image_import_directory)*)(bin->b->buf + off);\n\t\tlast = (char*) curr_import_dir + bin->import_directory_size;\n\t\twhile ((void*) (curr_import_dir + 1) <= last && (\n\t\t\tcurr_import_dir->FirstThunk || curr_import_dir->Name ||\n\t\t\tcurr_import_dir->TimeDateStamp || curr_import_dir->Characteristics ||\n\t\t\tcurr_import_dir->ForwarderChain)) {\n\t\t\tname_off = bin_pe_rva_to_paddr (bin, curr_import_dir->Name);\n\t\t\tlen = r_buf_read_at (bin->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (!libs[index].name[0]) { // minimum string length\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (len < 2 || libs[index].name[0] == 0) { // minimum string length\n\t\t\t\tbprintf (\"Warning: read (libs - import dirs) %d\\n\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tlibs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!libs) {\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\tgoto out_error;\n\t\t\t\t\t}\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tcurr_import_dir++;\n\t\t}\n\t}\n\toff = bin->delay_import_directory_offset;\n\tif (off < bin->size && off > 0) {\n\t\tif (off + sizeof(PE_(image_delay_import_directory)) > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tcurr_delay_import_dir = (PE_(image_delay_import_directory)*)(bin->b->buf + off);\n\t\twhile (curr_delay_import_dir->Name != 0 && curr_delay_import_dir->DelayImportNameTable != 0) {\n\t\t\tname_off = bin_pe_rva_to_paddr (bin, curr_delay_import_dir->Name);\n\t\t\tif (name_off > bin->size || name_off + PE_STRING_LENGTH > bin->size) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tlen = r_buf_read_at (bin->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);\n\t\t\tif (len != PE_STRING_LENGTH) {\n\t\t\t\tbprintf (\"Warning: read (libs - delay import dirs)\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlibs[index].name[len - 1] = '\\0';\n\t\t\tr_str_case (libs[index].name, 0);\n\t\t\tif (!sdb_ht_find (lib_map, libs[index].name, NULL)) {\n\t\t\t\tsdb_ht_insert (lib_map, libs[index].name, \"a\");\n\t\t\t\tlibs[index++].last = 0;\n\t\t\t\tif (index >= max_libs) {\n\t\t\t\t\tlibs = realloc (libs, (max_libs * 2) * sizeof (struct r_bin_pe_lib_t));\n\t\t\t\t\tif (!libs) {\n\t\t\t\t\t\tsdb_ht_free (lib_map);\n\t\t\t\t\t\tr_sys_perror (\"realloc (libs)\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tmax_libs *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr_delay_import_dir++;\n\t\t\tif ((const ut8*) (curr_delay_import_dir + 1) >= (const ut8*) (bin->b->buf + bin->size)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsdb_ht_free (lib_map);\n\tlibs[index].last = 1;\n\treturn libs;\nout_error:\n\tsdb_ht_free (lib_map);\n\tfree (libs);\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_image_size)(struct PE_(r_bin_pe_obj_t)* bin) {\n\treturn bin->nt_headers->optional_header.SizeOfImage;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_machine)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* machine = NULL;\n\n\tif (bin && bin->nt_headers) {\n\t\tswitch (bin->nt_headers->file_header.Machine) {\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA: machine = \"Alpha\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ALPHA64: machine = \"Alpha 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AM33: machine = \"AM33\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_AMD64: machine = \"AMD 64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_ARM: machine = \"ARM\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEE: machine = \"CEE\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_CEF: machine = \"CEF\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_EBC: machine = \"EBC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_I386: machine = \"i386\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_IA64: machine = \"ia64\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M32R: machine = \"M32R\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_M68K: machine = \"M68K\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPS16: machine = \"Mips 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU: machine = \"Mips FPU\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_MIPSFPU16: machine = \"Mips FPU 16\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPC: machine = \"PowerPC\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_POWERPCFP: machine = \"PowerPC FP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R10000: machine = \"R10000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R3000: machine = \"R3000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_R4000: machine = \"R4000\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3: machine = \"SH3\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3DSP: machine = \"SH3DSP\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH3E: machine = \"SH3E\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH4: machine = \"SH4\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_SH5: machine = \"SH5\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_THUMB: machine = \"Thumb\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_TRICORE: machine = \"Tricore\"; break;\n\t\tcase PE_IMAGE_FILE_MACHINE_WCEMIPSV2: machine = \"WCE Mips V2\"; break;\n\t\tdefault: machine = \"unknown\";\n\t\t}\n\t}\n\treturn machine? strdup (machine): NULL;\n}\n\n// TODO: make it const! like in elf\nchar* PE_(r_bin_pe_get_os)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* os;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn NULL;\n\t}\n\tswitch (bin->nt_headers->optional_header.Subsystem) {\n\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\tos = strdup (\"native\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\tos = strdup (\"windows\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\tos = strdup (\"posix\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\tos = strdup (\"efi\");\n\t\tbreak;\n\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\tos = strdup (\"xbox\");\n\t\tbreak;\n\tdefault:\n\t\t// XXX: this is unknown\n\t\tos = strdup (\"windows\");\n\t}\n\treturn os;\n}\n\n// TODO: make it const\nchar* PE_(r_bin_pe_get_class)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (bin && bin->nt_headers) {\n\t\tswitch (bin->nt_headers->optional_header.Magic) {\n\t\tcase PE_IMAGE_FILE_TYPE_PE32: return strdup (\"PE32\");\n\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"PE32+\");\n\t\tdefault: return strdup (\"Unknown\");\n\t\t}\n\t}\n\treturn NULL;\n}\n\nint PE_(r_bin_pe_get_bits)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tint bits = 32;\n\tif (bin && bin->nt_headers) {\n\t\tif (is_arm (bin)) {\n\t\t\tif (is_thumb (bin)) {\n\t\t\t\tbits = 16;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (bin->nt_headers->optional_header.Magic) {\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32: bits = 32; break;\n\t\t\tcase PE_IMAGE_FILE_TYPE_PE32PLUS: bits = 64; break;\n\t\t\tdefault: bits = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn bits;\n}\n\n//This function try to detect anomalies within section\n//we check if there is a section mapped at entrypoint, otherwise add it up\nvoid PE_(r_bin_pe_check_sections)(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_section_t* * sects) {\n\tint i = 0;\n\tstruct r_bin_pe_section_t* sections = *sects;\n\tut64 addr_beg, addr_end, new_section_size, new_perm, base_addr;\n\tstruct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (bin);\n\n\tif (!entry) {\n\t\treturn;\n\t}\n\tnew_section_size = bin->size;\n\tnew_section_size -= entry->paddr > bin->size? 0: entry->paddr;\n\tnew_perm = (PE_IMAGE_SCN_MEM_READ | PE_IMAGE_SCN_MEM_WRITE | PE_IMAGE_SCN_MEM_EXECUTE);\n\tbase_addr = PE_(r_bin_pe_get_image_base) (bin);\n\n\tfor (i = 0; !sections[i].last; i++) {\n\t\t//strcmp against .text doesn't work in somes cases\n\t\tif (strstr ((const char*) sections[i].name, \"text\")) {\n\t\t\tbool fix = false;\n\t\t\tint j;\n\t\t\t//check paddr boundaries\n\t\t\taddr_beg = sections[i].paddr;\n\t\t\taddr_end = addr_beg + sections[i].size;\n\t\t\tif (entry->paddr < addr_beg || entry->paddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//check vaddr boundaries\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tfix = true;\n\t\t\t}\n\t\t\t//look for other segment with x that is already mapped and hold entrypoint\n\t\t\tfor (j = 0; !sections[j].last; j++) {\n\t\t\t\tif (sections[j].flags & PE_IMAGE_SCN_MEM_EXECUTE) {\n\t\t\t\t\taddr_beg = sections[j].paddr;\n\t\t\t\t\taddr_end = addr_beg + sections[j].size;\n\t\t\t\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\t\t\t\tif (!sections[j].vsize) {\n\t\t\t\t\t\t\tsections[j].vsize = sections[j].size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddr_beg = sections[j].vaddr + base_addr;\n\t\t\t\t\t\taddr_end = addr_beg + sections[j].vsize;\n\t\t\t\t\t\tif (addr_beg <= entry->vaddr || entry->vaddr < addr_end) {\n\t\t\t\t\t\t\tfix = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//if either vaddr or paddr fail we should update this section\n\t\t\tif (fix) {\n\t\t\t\tstrcpy ((char*) sections[i].name, \"blob\");\n\t\t\t\tsections[i].paddr = entry->paddr;\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t\tsections[i].size = sections[i].vsize = new_section_size;\n\t\t\t\tsections[i].flags = new_perm;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//if we arrive til here means there is no text section find one that is holding the code\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tif (sections[i].size > bin->size) {\n\t\t\tcontinue;\n\t\t}\n\t\taddr_beg = sections[i].paddr;\n\t\taddr_end = addr_beg + sections[i].size;\n\t\tif (addr_beg <= entry->paddr && entry->paddr < addr_end) {\n\t\t\tif (!sections[i].vsize) {\n\t\t\t\tsections[i].vsize = sections[i].size;\n\t\t\t}\n\t\t\taddr_beg = sections[i].vaddr + base_addr;\n\t\t\taddr_end = addr_beg + sections[i].vsize;\n\t\t\tif (entry->vaddr < addr_beg || entry->vaddr > addr_end) {\n\t\t\t\tsections[i].vaddr = entry->vaddr - base_addr;\n\t\t\t}\n\t\t\tgoto out_function;\n\t\t}\n\t}\n\t//we need to create another section in order to load the entrypoint\n\tsections = realloc (sections, (bin->num_sections + 2) * sizeof(struct r_bin_pe_section_t));\n\ti = bin->num_sections;\n\tsections[i].last = 0;\n\tstrcpy ((char*) sections[i].name, \"blob\");\n\tsections[i].paddr = entry->paddr;\n\tsections[i].vaddr = entry->vaddr - base_addr;\n\tsections[i].size = sections[i].vsize = new_section_size;\n\tsections[i].flags = new_perm;\n\tsections[i + 1].last = 1;\n\t*sects = sections;\nout_function:\n\tfree (entry);\n\treturn;\n\n}\n\nstruct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tstruct r_bin_pe_section_t* sections = NULL;\n\tPE_(image_section_header) * shdr;\n\tint i, j, section_count = 0;\n\n\tif (!bin || !bin->nt_headers) {\n\t\treturn NULL;\n\t}\n\tshdr = bin->section_header;\n\tfor (i = 0; i < bin->num_sections; i++) {\n\t\t//just allocate the needed\n\t\tif (shdr[i].SizeOfRawData || shdr[i].Misc.VirtualSize) {\n\t\t\tsection_count++;\n\t\t}\n\t}\n\tsections = calloc (section_count + 1, sizeof(struct r_bin_pe_section_t));\n\tif (!sections) {\n\t\tr_sys_perror (\"malloc (sections)\");\n\t\treturn NULL;\n\t}\n\tfor (i = 0, j = 0; i < bin->num_sections; i++) {\n\t\t//if sz = 0 r_io_section_add will not add it so just skeep\n\t\tif (!shdr[i].SizeOfRawData && !shdr[i].Misc.VirtualSize) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (shdr[i].Name[0] == '\\0') {\n\t\t\tchar* new_name = r_str_newf (\"sect_%d\", j);\n\t\t\tstrncpy ((char*) sections[j].name, new_name, R_ARRAY_SIZE (sections[j].name) - 1);\n\t\t\tfree (new_name);\n\t\t} else if (shdr[i].Name[0] == '/') {\n\t\t\t//long name is something deprecated but still used\n\t\t\tint idx = atoi ((const char *)shdr[i].Name + 1);\n\t\t\tut64 sym_tbl_off = bin->nt_headers->file_header.PointerToSymbolTable;\n\t\t\tint num_symbols = bin->nt_headers->file_header.NumberOfSymbols;\n\t\t\tint off = num_symbols * COFF_SYMBOL_SIZE;\n\t\t\tif (sym_tbl_off &&\n\t\t\t    sym_tbl_off + off + idx < bin->size &&\n\t\t\t    sym_tbl_off + off + idx > off) {\n\t\t\t\tint sz = PE_IMAGE_SIZEOF_SHORT_NAME * 3;\n\t\t\t\tchar* buf[64] = {0};\n\t\t\t\tif (r_buf_read_at (bin->b,\n\t\t\t\t\t\t   sym_tbl_off + off + idx,\n\t\t\t\t\t\t   (ut8*)buf, 64)) {\n\t\t\t\t\tmemcpy (sections[j].name, buf, sz);\n\t\t\t\t\tsections[j].name[sz - 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy (sections[j].name, shdr[i].Name, PE_IMAGE_SIZEOF_SHORT_NAME);\n\t\t\tsections[j].name[PE_IMAGE_SIZEOF_SHORT_NAME] = '\\0';\n\t\t}\n\t\tsections[j].vaddr = shdr[i].VirtualAddress;\n\t\tsections[j].size = shdr[i].SizeOfRawData;\n\t\tsections[j].vsize = shdr[i].Misc.VirtualSize;\n\t\tif (bin->optional_header) {\n\t\t\tint sa = R_MAX (bin->optional_header->SectionAlignment, 0x1000);\n\t\t\tut64 diff = sections[j].vsize % sa;\n\t\t\tif (diff) {\n\t\t\t\tsections[j].vsize += sa - diff;\n\t\t\t}\n\t\t}\n\t\tsections[j].paddr = shdr[i].PointerToRawData;\n\t\tsections[j].flags = shdr[i].Characteristics;\n\t\tsections[j].last = 0;\n\t\tj++;\n\t}\n\tsections[j].last = 1;\n\tbin->num_sections = section_count;\n\treturn sections;\n}\n\nchar* PE_(r_bin_pe_get_subsystem)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tchar* subsystem = NULL;\n\tif (bin && bin->nt_headers) {\n\t\tswitch (bin->nt_headers->optional_header.Subsystem) {\n\t\tcase PE_IMAGE_SUBSYSTEM_NATIVE:\n\t\t\tsubsystem = \"Native\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:\n\t\t\tsubsystem = \"Windows GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CUI:\n\t\t\tsubsystem = \"Windows CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_POSIX_CUI:\n\t\t\tsubsystem = \"POSIX CUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:\n\t\t\tsubsystem = \"Windows CE GUI\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_APPLICATION:\n\t\t\tsubsystem = \"EFI Application\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:\n\t\t\tsubsystem = \"EFI Boot Service Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:\n\t\t\tsubsystem = \"EFI Runtime Driver\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_EFI_ROM:\n\t\t\tsubsystem = \"EFI ROM\"; break;\n\t\tcase PE_IMAGE_SUBSYSTEM_XBOX:\n\t\t\tsubsystem = \"XBOX\"; break;\n\t\tdefault:\n\t\t\tsubsystem = \"Unknown\"; break;\n\t\t}\n\t}\n\treturn subsystem? strdup (subsystem): NULL;\n}\n\n#define HASCHR(x) bin->nt_headers->file_header.Characteristics & x\n\nint PE_(r_bin_pe_is_dll)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DLL);\n}\n\nint PE_(r_bin_pe_is_pie)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE);\n#if 0\n\tBOOL aslr = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;\n//TODO: implement dep?\n\tBOOL dep = inh->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT;\n#endif\n}\n\nint PE_(r_bin_pe_is_big_endian)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tut16 arch;\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\tarch = bin->nt_headers->file_header.Machine;\n\tif (arch == PE_IMAGE_FILE_MACHINE_I386 ||\n\tarch == PE_IMAGE_FILE_MACHINE_AMD64) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_BYTES_REVERSED_HI);\n}\n\nint PE_(r_bin_pe_is_stripped_relocs)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_RELOCS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_line_nums)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LINE_NUMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_local_syms)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED);\n}\n\nint PE_(r_bin_pe_is_stripped_debug)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->nt_headers) {\n\t\treturn false;\n\t}\n\treturn HASCHR (PE_IMAGE_FILE_DEBUG_STRIPPED);\n}\n\n\nvoid* PE_(r_bin_pe_free)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tfree (bin->dos_header);\n\tfree (bin->nt_headers);\n\tfree (bin->section_header);\n\tfree (bin->export_directory);\n\tfree (bin->import_directory);\n\tfree (bin->resource_directory);\n\tfree (bin->delay_import_directory);\n\tfree (bin->tls_directory);\n\tr_list_free (bin->resources);\n\tr_pkcs7_free_cms (bin->cms);\n\tr_buf_free (bin->b);\n\tbin->b = NULL;\n\tfree (bin);\n\treturn NULL;\n}\n\nstruct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file, bool verbose) {\n\tut8* buf;\n\tstruct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->file = file;\n\tif (!(buf = (ut8*) r_file_slurp (file, &bin->size))) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tbin->verbose = verbose;\n\tfree (buf);\n\tif (!bin_pe_init (bin)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\treturn bin;\n}\n\nstruct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(RBuffer * buf, bool verbose) {\n\tstruct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->kv = sdb_new0 ();\n\tbin->b = r_buf_new ();\n\tbin->verbose = verbose;\n\tbin->size = buf->length;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, bin->size)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tif (!bin_pe_init (bin)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\treturn bin;\n}\n"], "filenames": ["libr/bin/format/pe/pe.c"], "buggy_code_start_loc": [2735], "buggy_code_end_loc": [2782], "fixing_code_start_loc": [2735], "fixing_code_end_loc": [2789], "type": "CWE-125", "message": "The get_debug_info() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted PE file.", "other": {"cve": {"id": "CVE-2018-11379", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T19:29:00.427", "lastModified": "2018-06-27T15:30:18.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The get_debug_info() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted PE file."}, {"lang": "es", "value": "La funci\u00f3n get_debug_info() en radare2 2.5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo PE manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "81E40EFA-5307-45F3-9722-CB499D21141F"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/9926", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/4e1cf0d3e6f6fe2552a269def0af1cd2403e266c"}}