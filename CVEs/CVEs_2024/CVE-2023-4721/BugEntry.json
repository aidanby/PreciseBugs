{"buggy_code": ["/*\n * The contents of this file are subject to the Mozilla Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Original Code is MPEG4IP.\n *\n * The Initial Developer of the Original Code is Cisco Systems Inc.\n * Portions created by Cisco Systems Inc. are\n * Copyright (C) Cisco Systems Inc. 2004.  All Rights Reserved.\n *\n * Contributor(s):\n *\t\tBill May wmay@cisco.com\n */\n\n/*\n * mpeg2ps.c - parse program stream and vob files\n */\n#include \"mpeg2_ps.h\"\n\n#ifndef GPAC_DISABLE_MPEG2PS\n\n\nstatic GFINLINE u16 convert16 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u16 *)p;\n#else\n\tu16 val = p[0];\n\tval <<= 8;\n\treturn (val | p[1]);\n#endif\n}\n\nstatic GFINLINE u32 convert32 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u32 *)p;\n#else\n\tu32 val;\n\tval = p[0];\n\tval <<= 8;\n\tval |= p[1];\n\tval <<= 8;\n\tval |= p[2];\n\tval <<= 8;\n\tval |= p[3];\n\treturn val;\n#endif\n}\n\n#define FDNULL 0\n\n/*\n * structure for passing timestamps around\n */\ntypedef struct mpeg2ps_ts_t\n{\n\tBool have_pts;\n\tBool have_dts;\n\tu64 pts;\n\tu64 dts;\n} mpeg2ps_ts_t;\n\ntypedef struct mpeg2ps_record_pes_t\n{\n\tstruct mpeg2ps_record_pes_t *next_rec;\n\tu64 dts;\n\tu64 location;\n} mpeg2ps_record_pes_t;\n\n/*\n * information about reading a stream\n */\ntypedef struct mpeg2ps_stream_t\n{\n\tmpeg2ps_record_pes_t *record_first, *record_last;\n\tFILE *m_fd;\n\tBool is_video;\n\tu8 m_stream_id;    // program stream id\n\tu8 m_substream_id; // substream, for program stream id == 0xbd\n\n\tmpeg2ps_ts_t next_pes_ts, frame_ts;\n\tu32 frames_since_last_ts;\n\tu64 last_ts;\n\n\tBool have_frame_loaded;\n\t/*\n\t * pes_buffer processing.  this contains the raw elementary stream data\n\t */\n\tu8 *pes_buffer;\n\tu32 pes_buffer_size;\n\tu32 pes_buffer_size_max;\n\tu32 pes_buffer_on;\n\tu32 frame_len;\n\tu32 pict_header_offset; // for mpeg video\n\n\t// timing information and locations.\n\ts64 first_pes_loc;\n\tu64 start_dts;\n\tBool first_pes_has_dts;\n\ts64    end_dts_loc;\n\tu64 end_dts;\n\t// audio stuff\n\tu32 freq;\n\tu32 channels;\n\tu32 bitrate;\n\tu32 samples_per_frame;\n\tu32 layer;\n\t// video stuff\n\tu32 h, w, par;\n\tDouble frame_rate;\n\ts32 have_mpeg2;\n\tDouble bit_rate;\n\tu64 ticks_per_frame;\n\n} mpeg2ps_stream_t;\n\n/*\n * main interface structure - contains stream pointers and other\n * information\n */\nstruct mpeg2ps_ {\n\tmpeg2ps_stream_t *video_streams[16];\n\tmpeg2ps_stream_t *audio_streams[32];\n\tchar *filename;\n\tFILE *fd;\n\tu64 first_dts;\n\tu32 audio_cnt, video_cnt;\n\ts64 end_loc;\n\tu64 max_dts;\n\tu64 max_time;  // time is in msec.\n};\n\n/*************************************************************************\n * File access routines.  Could all be inline\n *************************************************************************/\nstatic FILE *file_open (const char *name)\n{\n\treturn gf_fopen(name, \"rb\");\n}\n\nstatic Bool file_okay (FILE *fd)\n{\n\treturn (fd!=NULL) ? 1 : 0;\n}\n\nstatic void file_close (FILE *fd)\n{\n\tgf_fclose(fd);\n}\n\nstatic Bool file_read_bytes(FILE *fd,\n                            u8 *buffer,\n                            u32 len)\n{\n\tu32 readval = (u32) gf_fread(buffer, len, fd);\n\treturn readval == len;\n}\n\n// note: len could be negative.\nstatic void file_skip_bytes (FILE *fd, s32 len)\n{\n\tgf_fseek(fd, len, SEEK_CUR);\n}\n\n#define file_location(__f) gf_ftell(__f)\n#define file_seek_to(__f, __off) gf_fseek(__f, __off, SEEK_SET)\n\nstatic u64 file_size(FILE *fd)\n{\n\treturn gf_fsize(fd);\n}\n\nstatic mpeg2ps_record_pes_t *create_record (s64 loc, u64 ts)\n{\n\tmpeg2ps_record_pes_t *ret;\n\tGF_SAFEALLOC(ret, mpeg2ps_record_pes_t);\n\tif (!ret) return NULL;\n\tret->next_rec = NULL;\n\tret->dts = ts;\n\tret->location = loc;\n\treturn ret;\n}\n\n#define MPEG2PS_RECORD_TIME ((u64) (5 * 90000))\nvoid mpeg2ps_record_pts (mpeg2ps_stream_t *sptr, s64 location, mpeg2ps_ts_t *pTs)\n{\n\tu64 ts;\n\tmpeg2ps_record_pes_t *p, *q;\n\tif (sptr->is_video) {\n\t\tif (pTs->have_dts == 0) return;\n\t\tts = pTs->dts;\n\t} else {\n\t\tif (pTs->have_pts == 0) return;\n\t\tts = pTs->pts;\n\t}\n\n\tif (sptr->record_first == NULL) {\n\t\tsptr->record_first = sptr->record_last = create_record(location, ts);\n\t\treturn;\n\t}\n\tif (ts > sptr->record_last->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_last->dts) return;\n\t\tsptr->record_last->next_rec = create_record(location, ts);\n\t\tsptr->record_last = sptr->record_last->next_rec;\n\t\treturn;\n\t}\n\tif (ts < sptr->record_first->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_first->dts) return;\n\t\tp = create_record(location, ts);\n\t\tp->next_rec = sptr->record_first;\n\t\tsptr->record_first = p;\n\t\treturn;\n\t}\n\tp = sptr->record_first;\n\tq = p->next_rec;\n\n\twhile (q != NULL && q->dts < ts) {\n\t\tp = q;\n\t\tq = q->next_rec;\n\t}\n\tif (q) {\n\t\tif (p->dts + MPEG2PS_RECORD_TIME <= ts &&\n\t\t\t\tts + MPEG2PS_RECORD_TIME <= q->dts) {\n\t\t\tp->next_rec = create_record(location, ts);\n\t\t\tp->next_rec->next_rec = q;\n\t\t}\n\t}\n}\nstatic Double mpeg12_frame_rate_table[16] =\n{\n\t0.0,   /* Pad */\n\t24000.0/1001.0,       /* Official frame rates */\n\t24.0,\n\t25.0,\n\t30000.0/1001.0,\n\t30.0,\n\t50.0,\n\t((60.0*1000.0)/1001.0),\n\t60.0,\n\n\t1,                    /* Unofficial economy rates */\n\t5,\n\t10,\n\t12,\n\t15,\n\t0,\n\t0,\n};\n\n#define SEQ_ID 1\nint MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32 *height, u32 *width,\n                       Double *frame_rate, Double *bitrate, u32 *aspect_ratio)\n{\n\tu32 aspect_code;\n\tu32 framerate_code;\n\tu32 bitrate_int;\n\tu32 bitrate_ext;\n\tu32 scode, ix;\n\ts32 found = -1;\n\t*have_mpeg2 = 0;\n\tbuflen -= 6;\n\tbitrate_int = 0;\n\tfor (ix = 0; ix < buflen; ix++, pbuffer++) {\n\t\tscode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |\n\t\t        pbuffer[3];\n\n\t\tif (scode == MPEG12_SEQUENCE_START_CODE) {\n\t\t\tpbuffer += sizeof(u32);\n\t\t\t*width = (pbuffer[0]);\n\t\t\t*width <<= 4;\n\t\t\t*width |= ((pbuffer[1] >> 4) &0xf);\n\t\t\t*height = (pbuffer[1] & 0xf);\n\t\t\t*height <<= 8;\n\t\t\t*height |= pbuffer[2];\n\t\t\taspect_code = (pbuffer[3] >> 4) & 0xf;\n\t\t\tif (aspect_ratio != NULL) {\n\t\t\t\tu32 par = 0;\n\t\t\t\tswitch (aspect_code) {\n\t\t\t\tdefault:\n\t\t\t\t\t*aspect_ratio = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpar = 4;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpar = 16;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tpar = 2;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 21;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*aspect_ratio = par;\n\t\t\t}\n\n\n\t\t\tframerate_code = pbuffer[3] & 0xf;\n\t\t\t*frame_rate = mpeg12_frame_rate_table[framerate_code];\n\t\t\t// 18 bits\n\t\t\tbitrate_int = (pbuffer[4] << 10) |\n\t\t\t              (pbuffer[5] << 2) |\n\t\t\t              ((pbuffer[6] >> 6) & 0x3);\n\t\t\t*bitrate = bitrate_int;\n\t\t\t*bitrate *= 400.0;\n\t\t\tix += sizeof(u32) + 7;\n\t\t\tpbuffer += 7;\n\t\t\tfound = 0;\n\t\t} else if (found == 0) {\n\t\t\tif (scode == MPEG12_EXT_START_CODE) {\n\t\t\t\tpbuffer += sizeof(u32);\n\t\t\t\tix += sizeof(u32);\n\t\t\t\tswitch ((pbuffer[0] >> 4) & 0xf) {\n\t\t\t\tcase SEQ_ID:\n\t\t\t\t\t*have_mpeg2 = 1;\n\t\t\t\t\t*height = ((pbuffer[1] & 0x1) << 13) |\n\t\t\t\t\t          ((pbuffer[2] & 0x80) << 5) |\n\t\t\t\t\t          (*height & 0x0fff);\n\t\t\t\t\t*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);\n\t\t\t\t\tbitrate_ext = (pbuffer[2] & 0x1f) << 7;\n\t\t\t\t\tbitrate_ext |= (pbuffer[3] >> 1) & 0x7f;\n\t\t\t\t\tbitrate_int |= (bitrate_ext << 18);\n\t\t\t\t\t*bitrate = bitrate_int;\n\t\t\t\t\t*bitrate *= 400.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpbuffer++;\n\t\t\t\tix++;\n\t\t\t} else if (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\treturn found;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n\ns32 MPEG12_PictHdrType (unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[1] >> 3) & 0x7);\n}\n\n#if 0 //unused\nu16 MPEG12_PictHdrTempRef(unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[0] << 2) | ((pbuffer[1] >> 6) & 0x3));\n}\n#endif\n\n\nstatic u64 read_pts (u8 *pak)\n{\n\tu64 pts;\n\tu16 temp;\n\n\tpts = ((pak[0] >> 1) & 0x7);\n\tpts <<= 15;\n\ttemp = convert16(&pak[1]) >> 1;\n\tpts |= temp;\n\tpts <<= 15;\n\ttemp = convert16(&pak[3]) >> 1;\n\tpts |= temp;\n\treturn pts;\n}\n\n\nstatic mpeg2ps_stream_t *mpeg2ps_stream_create (u8 stream_id,\n        u8 substream)\n{\n\tmpeg2ps_stream_t *ptr;\n\tGF_SAFEALLOC(ptr, mpeg2ps_stream_t);\n\tif (!ptr) return NULL;\n\tptr->m_stream_id = stream_id;\n\tptr->m_substream_id = substream;\n\tptr->is_video = stream_id >= 0xe0;\n\tptr->pes_buffer = (u8 *)gf_malloc(4*4096);\n\tptr->pes_buffer_size_max = 4 * 4096;\n\treturn ptr;\n}\n\nstatic void mpeg2ps_stream_destroy (mpeg2ps_stream_t *sptr)\n{\n\tmpeg2ps_record_pes_t *p;\n\twhile (sptr->record_first != NULL) {\n\t\tp = sptr->record_first;\n\t\tsptr->record_first = p->next_rec;\n\t\tgf_free(p);\n\t}\n\tif (sptr->m_fd != FDNULL) {\n\t\tfile_close(sptr->m_fd);\n\t\tsptr->m_fd = FDNULL;\n\t}\n\tif (sptr->pes_buffer) gf_free(sptr->pes_buffer);\n\tgf_free(sptr);\n}\n\n\n/*\n * adv_past_pack_hdr - read the pack header, advance past it\n * we don't do anything with the data\n */\nstatic void adv_past_pack_hdr (FILE *fd,\n                               u8 *pak,\n                               u32 read_from_start)\n{\n\tu8 stuffed;\n\tu8 readbyte;\n\tu8 val;\n\tif (read_from_start < 5) {\n\t\tfile_skip_bytes(fd, 5 - read_from_start);\n\t\tfile_read_bytes(fd, &readbyte, 1);\n\t\tval = readbyte;\n\t} else {\n\t\tval = pak[4];\n\t}\n\n\t// we've read 6 bytes\n\tif ((val & 0xc0) != 0x40) {\n\t\t// mpeg1\n\t\tfile_skip_bytes(fd, 12 - read_from_start); // skip 6 more bytes\n\t\treturn;\n\t}\n\tfile_skip_bytes(fd, 13 - read_from_start);\n\tfile_read_bytes(fd, &readbyte, 1);\n\tstuffed = readbyte & 0x7;\n\tfile_skip_bytes(fd, stuffed);\n}\n\n/*\n * find_pack_start\n * look for the pack start code in the file - read 512 bytes at a time,\n * searching for that code.\n * Note: we may also be okay looking for >= 00 00 01 bb\n */\nstatic Bool find_pack_start (FILE *fd,\n                             u8 *saved,\n                             u32 len)\n{\n\tu8 buffer[512];\n\tu32 buffer_on = 0, new_offset, scode;\n\tmemcpy(buffer, saved, len);\n\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (gf_mv12_next_start_code(buffer + buffer_on,\n\t\t                            sizeof(buffer) - buffer_on,\n\t\t                            &new_offset,\n\t\t                            &scode) >= 0) {\n\t\t\tbuffer_on += new_offset;\n\t\t\tif (scode == MPEG2_PS_PACKSTART) {\n\t\t\t\tfile_skip_bytes(fd, buffer_on - 512); // go back to header\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbuffer_on += 1;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t\tif (buffer[sizeof(buffer) - 3] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 2] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 1] == 1) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tbuffer[2] = 1;\n\t\t\t\tlen = 3;\n\t\t\t} else if (*(u16 *)(buffer + sizeof(buffer) - 2) == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tlen = 2;\n\t\t\t} else if (buffer[sizeof(buffer) - 1] == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuffer_on = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * copy_bytes_to_pes_buffer - read pes_len bytes into the buffer,\n * adjusting it if we need it\n */\nstatic void copy_bytes_to_pes_buffer (mpeg2ps_stream_t *sptr,\n                                      u16 pes_len)\n{\n\tu32 to_move;\n\n\tif (sptr->pes_buffer_size + pes_len > sptr->pes_buffer_size_max) {\n\t\t// if no room in the buffer, we'll move it - otherwise, just fill\n\t\t// note - we might want a better strategy about moving the buffer -\n\t\t// right now, we might be moving a number of bytes if we have a large\n\t\t// followed by large frame.\n\t\tto_move = sptr->pes_buffer_size - sptr->pes_buffer_on;\n\t\tmemmove(sptr->pes_buffer,\n\t\t        sptr->pes_buffer + sptr->pes_buffer_on,\n\t\t        to_move);\n\t\tsptr->pes_buffer_size = to_move;\n\t\tsptr->pes_buffer_on = 0;\n\t\tif (to_move + pes_len > sptr->pes_buffer_size_max) {\n\t\t\tsptr->pes_buffer = (u8 *)gf_realloc(sptr->pes_buffer,\n\t\t\t                                    to_move + pes_len + 2048);\n\t\t\tsptr->pes_buffer_size_max = to_move + pes_len + 2048;\n\t\t}\n\t}\n\tfile_read_bytes(sptr->m_fd, sptr->pes_buffer + sptr->pes_buffer_size, pes_len);\n\tsptr->pes_buffer_size += pes_len;\n}\n\n/*\n * read_to_next_pes_header - read the file, look for the next valid\n * pes header.  We will skip over PACK headers, but not over any of the\n * headers listed in 13818-1, table 2-18 - basically, anything with the\n * 00 00 01 and the next byte > 0xbb.\n * We return the pes len to read, and the \"next byte\"\n */\nstatic Bool read_to_next_pes_header (FILE *fd,\n                                     u8 *stream_id,\n                                     u16 *pes_len)\n{\n\tu32 hdr;\n\tu8 local[6];\n\n\twhile (1) {\n\t\t// read the pes header\n\t\tif (file_read_bytes(fd, local, 6) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\thdr = convert32(local);\n\t\t// if we're not a 00 00 01, read until we get the next pack start\n\t\t// we might want to also read until next PES - look into that.\n\t\tif (((hdr & MPEG2_PS_START_MASK) != MPEG2_PS_START) ||\n\t\t        (hdr < MPEG2_PS_END)) {\n\t\t\tif (find_pack_start(fd, local, 6) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_PACKSTART) {\n\t\t\t// pack start code - we can skip down\n\t\t\tadv_past_pack_hdr(fd, local, 6);\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_END) {\n\t\t\tfile_skip_bytes(fd, -2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// we should have a valid stream and pes_len here...\n\t\t*stream_id = hdr & 0xff;\n\t\t*pes_len = convert16(local + 4);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * read_pes_header_data\n * this should read past the pes header for the audio and video streams\n * it will store the timestamps if it reads them\n */\nstatic Bool read_pes_header_data (FILE *fd,\n                                  u16 orig_pes_len,\n                                  u16 *pes_left,\n                                  Bool *have_ts,\n                                  mpeg2ps_ts_t *ts)\n{\n\tu16 pes_len = orig_pes_len;\n\tu8 local[10];\n\tu32 hdr_len;\n\n\tts->have_pts = 0;\n\tts->have_dts = 0;\n\tif (have_ts) *have_ts = 0;\n\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\treturn 0;\n\t}\n\tpes_len--; // remove this first byte from length\n\twhile (*local == 0xff) {\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len--;\n\t\tif (pes_len == 0) {\n\t\t\t*pes_left = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((*local & 0xc0) == 0x40) {\n\t\t// buffer scale & size\n\t\tfile_skip_bytes(fd, 1);\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len -= 2;\n\t}\n\n\tif ((*local & 0xf0) == 0x20) {\n\t\t// mpeg-1 with pts\n\t\tif (file_read_bytes(fd, local + 1, 4) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->pts = ts->dts = read_pts(local);\n\t\t*have_ts = 1;\n\t\tpes_len -= 4;\n\t} else if ((*local & 0xf0) == 0x30) {\n\t\t// have mpeg 1 pts and dts\n\t\tif (file_read_bytes(fd, local + 1, 9) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->have_dts = 1;\n\t\t*have_ts = 1;\n\t\tts->pts = read_pts(local);\n\t\tts->dts = read_pts(local + 5);\n\t\tpes_len -= 9;\n\t} else if ((*local & 0xc0) == 0x80) {\n\t\t// mpeg2 pes header  - we're pointing at the flags field now\n\t\tif (file_read_bytes(fd, local + 1, 2) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\thdr_len = local[2];\n\t\tpes_len -= hdr_len + 2; // first byte removed already\n\t\tif ((local[1] & 0xc0) == 0x80) {\n\t\t\t// just pts\n\t\t\tts->have_pts = 1;\n\t\t\tfile_read_bytes(fd, local, 5);\n\t\t\tts->pts = ts->dts = read_pts(local);\n\t\t\t*have_ts = 1;\n\t\t\thdr_len -= 5;\n\t\t} else if ((local[1] & 0xc0) == 0xc0) {\n\t\t\t// pts and dts\n\t\t\tts->have_pts = 1;\n\t\t\tts->have_dts = 1;\n\t\t\t*have_ts = 1;\n\t\t\tfile_read_bytes(fd, local, 10);\n\t\t\tts->pts = read_pts(local);\n\t\t\tts->dts = read_pts(local  + 5);\n\t\t\thdr_len -= 10;\n\t\t}\n\t\tfile_skip_bytes(fd, hdr_len);\n\t} else if (*local != 0xf) {\n\t\tfile_skip_bytes(fd, pes_len);\n\t\tpes_len = 0;\n\t}\n\t*pes_left = pes_len;\n\treturn 1;\n}\n\nstatic Bool search_for_next_pes_header (mpeg2ps_stream_t *sptr,\n                                        u16 *pes_len,\n                                        Bool *have_ts,\n                                        s64 *found_loc)\n{\n\tu8 stream_id;\n\tu8 local;\n\ts64 loc;\n\twhile (1) {\n\t\t// this will read until we find the next pes.  We don't know if the\n\t\t// stream matches - this will read over pack headers\n\t\tif (read_to_next_pes_header(sptr->m_fd, &stream_id, pes_len) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (stream_id != sptr->m_stream_id) {\n\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\tcontinue;\n\t\t}\n\t\tloc = file_location(sptr->m_fd) - 6;\n\t\t// advance past header, reading pts\n\t\tif (read_pes_header_data(sptr->m_fd,\n\t\t                         *pes_len,\n\t\t                         pes_len,\n\t\t                         have_ts,\n\t\t                         &sptr->next_pes_ts) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// If we're looking at a private stream, make sure that the sub-stream\n\t\t// matches.\n\t\tif (sptr->m_stream_id == 0xbd) {\n\t\t\t// ac3 or pcm\n\t\t\tfile_read_bytes(sptr->m_fd, &local, 1);\n\t\t\t*pes_len -= 1;\n\t\t\tif (local != sptr->m_substream_id) {\n\t\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\t\tcontinue; // skip to the next one\n\t\t\t}\n\t\t\t*pes_len -= 3;\n\t\t\tfile_skip_bytes(sptr->m_fd, 3); // 4 bytes - we don't need now...\n\t\t\t// we need more here...\n\t\t}\n\t\tif (have_ts) {\n\t\t\tmpeg2ps_record_pts(sptr, loc, &sptr->next_pes_ts);\n\t\t}\n\t\tif (found_loc != NULL) *found_loc = loc;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * mpeg2ps_stream_read_next_pes_buffer - for the given stream,\n * go forward in the file until the next PES for the stream is read.  Read\n * the header (pts, dts), and read the data into the pes_buffer pointer\n */\nstatic Bool mpeg2ps_stream_read_next_pes_buffer (mpeg2ps_stream_t *sptr)\n{\n\tu16 pes_len;\n\tBool have_ts;\n\n\tif (search_for_next_pes_header(sptr, &pes_len, &have_ts, NULL) == 0) {\n\t\treturn 0;\n\t}\n\n\tcopy_bytes_to_pes_buffer(sptr, pes_len);\n\n\treturn 1;\n}\n\n\n/***************************************************************************\n * Frame reading routine.  For each stream, the fd's should be different.\n * we will read from the pes stream, and save it in the stream's pes buffer.\n * This will give us raw data that we can search through for frame headers,\n * and the like.  We shouldn't read more than we need - when we need to read,\n * we'll put the whole next pes buffer in the buffer\n *\n * Audio routines are of the format:\n *   look for header\n *   determine length\n *   make sure length is in buffer\n *\n * Video routines\n *   look for start header (GOP, SEQ, Picture)\n *   look for pict header\n *   look for next start (END, GOP, SEQ, Picture)\n *\n ***************************************************************************/\n#define IS_MPEG_START(a) ((a) == 0xb3 || (a) == 0x00 || (a) == 0xb8)\n\nstatic Bool\nmpeg2ps_stream_find_mpeg_video_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 offset, scode;\n\tBool have_pict;\n\tBool started_new_pes = 0;\n\tu32 start;\n\t/*\n\t * First thing - determine if we have enough bytes to read the header.\n\t * if we do, we have the correct timestamp.  If not, we read the new\n\t * pes, so we'd want to use the timestamp we read.\n\t */\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_mv12_next_start_code(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                               sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                               &offset,\n\t                               &scode) < 0 ||\n\t        (!IS_MPEG_START(scode & 0xff))) {\n\t\tif (sptr->pes_buffer_size > 3)\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\telse {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t\tstarted_new_pes = 1;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->pes_buffer_on += offset;\n\tif (offset == 0 && started_new_pes) {\n\t\t// nothing...  we've copied the timestamp already.\n\t} else {\n\t\t// we found the new start, but we pulled in a new pes header before\n\t\t// starting.  So, we want to use the header that we read.\n\t\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\t\t// clear timestamp indication\n\t\tsptr->next_pes_ts.have_pts = sptr->next_pes_ts.have_dts = 0;\n\t}\n\n\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\tsptr->pict_header_offset = sptr->pes_buffer_on;\n\t\thave_pict = 1;\n\t} else have_pict = 0;\n\n\tstart = 4 + sptr->pes_buffer_on;\n\twhile (1) {\n\n\t\tif (gf_mv12_next_start_code(sptr->pes_buffer + start,\n\t\t                            sptr->pes_buffer_size - start,\n\t\t                            &offset,\n\t\t                            &scode) < 0) {\n\t\t\tstart = sptr->pes_buffer_size - 3;\n\t\t\tstart -= sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset -= sptr->pes_buffer_on;\n\t\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstart += sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset += sptr->pes_buffer_on;\n\t\t} else {\n\t\t\tstart += offset;\n\t\t\tif (have_pict == 0) {\n\t\t\t\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\t\thave_pict = 1;\n\t\t\t\t\tsptr->pict_header_offset = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (IS_MPEG_START(scode & 0xff) ||\n\t\t\t\t        scode == MPEG12_SEQUENCE_END_START_CODE) {\n\t\t\t\t\tsptr->frame_len = start - sptr->pes_buffer_on;\n\t\t\t\t\tsptr->have_frame_loaded = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart += 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic Bool mpeg2ps_stream_find_ac3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff;\n\tBool started_new_pes = 0;\n\tGF_AC3Config hdr;\n\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 6) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_ac3_parser(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                     sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                     &diff,\n\t                     &hdr, 0) <= 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 6) {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 6;\n\t\t\tstarted_new_pes = 1;\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->frame_len = hdr.framesize;\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\t\t// we might have a new PTS - but it's not here\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\nstatic Bool mpeg2ps_stream_find_mp3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff, hdr;\n\tBool started_new_pes = 0;\n\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile ((hdr=gf_mp3_get_next_header_mem(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                                       sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                                       &diff) ) == 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 3) {\n\t\t\tif (sptr->pes_buffer_on != sptr->pes_buffer_size) {\n\t\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\t\t}\n\t\t\tstarted_new_pes = 1; // we have left over bytes...\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t// have frame.\n\tsptr->frame_len = gf_mp3_frame_size(hdr);\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\n/*\n * mpeg2ps_stream_read_frame.  read the correct frame based on stream type.\n * advance_pointers is 0 when we want to use the data\n */\nstatic Bool mpeg2ps_stream_read_frame (mpeg2ps_stream_t *sptr,\n                                       u8 **buffer,\n                                       u32 *buflen,\n                                       Bool advance_pointers)\n{\n\t//  Bool done = 0;\n\tif (sptr->is_video) {\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers) {\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\t// would need to handle LPCM here\n\t\tif (mpeg2ps_stream_find_ac3_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers)\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (mpeg2ps_stream_find_mp3_frame(sptr)) {\n\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t*buflen = sptr->frame_len;\n\t\tif (advance_pointers)\n\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * get_info_from_frame - we have a frame, get the info from it.\n */\nstatic void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\t// mpeg audio\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; // give bps, not kbps\n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t\t// PCM - ???\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}\n\n/*\n * clear_stream_buffer - called when we seek to clear out any data in\n * the buffers\n */\nstatic void clear_stream_buffer (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on = sptr->pes_buffer_size = 0;\n\tsptr->frame_len = 0;\n\tsptr->have_frame_loaded = 0;\n\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\tsptr->frame_ts.have_dts = sptr->frame_ts.have_pts = 0;\n}\n\n/*\n * convert_to_msec - convert ts (at 90000) to msec, based on base_ts and\n * frames_since_last_ts.\n */\nstatic u64 convert_ts (mpeg2ps_stream_t *sptr,\n                       mpeg2ps_ts_type_t ts_type,\n                       u64 ts,\n                       u64 base_ts,\n                       u32 frames_since_ts)\n{\n\tu64 ret, calc;\n\tret = ts - base_ts;\n\tif (sptr->is_video) {\n\t\t// video\n\t\tret += frames_since_ts * sptr->ticks_per_frame;\n\t} else if (sptr->freq) {\n\t\t// audio\n\t\tcalc = (frames_since_ts * 90000 * sptr->samples_per_frame) / sptr->freq;\n\t\tret += calc;\n\t}\n\tif (ts_type == TS_MSEC)\n\t\tret /= (u64) (90); // * 1000 / 90000\n\n\treturn ret;\n}\n\n/*\n * find_stream_from_id - given the stream, get the sptr.\n * only used in inital set up, really.  APIs use index into\n * video_streams and audio_streams arrays.\n */\nstatic mpeg2ps_stream_t *find_stream_from_id (mpeg2ps_t *ps,\n        u8 stream_id,\n        u8 substream)\n{\n\tu8 ix;\n\tif (stream_id >= 0xe0) {\n\t\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\t\tif (ps->video_streams[ix]->m_stream_id == stream_id) {\n\t\t\t\treturn ps->video_streams[ix];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\t\tif (ps->audio_streams[ix]->m_stream_id == stream_id &&\n\t\t\t        (stream_id != 0xbd ||\n\t\t\t         substream == ps->audio_streams[ix]->m_substream_id)) {\n\t\t\t\treturn ps->audio_streams[ix];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * add_stream - add a new stream\n */\nstatic Bool add_stream (mpeg2ps_t *ps,\n                        u8 stream_id,\n                        u8 substream,\n                        s64 first_loc,\n                        mpeg2ps_ts_t *ts)\n{\n\tmpeg2ps_stream_t *sptr;\n\n\tsptr = find_stream_from_id(ps, stream_id, substream);\n\tif (sptr != NULL) return 0;\n\n\t// need to add\n\n\tsptr = mpeg2ps_stream_create(stream_id, substream);\n\tsptr->first_pes_loc = first_loc;\n\tif (ts == NULL ||\n\t        (ts->have_dts == 0 && ts->have_pts == 0)) {\n\t\tsptr->first_pes_has_dts = 0;\n\t} else {\n\t\tsptr->start_dts = ts->have_dts ? ts->dts : ts->pts;\n\t\tsptr->first_pes_has_dts = 1;\n\t}\n\tif (sptr->is_video) {\n\t\t// can't be more than 16 - e0 to ef...\n\t\tps->video_streams[ps->video_cnt] = sptr;\n\t\tps->video_cnt++;\n\t} else {\n\t\tif (ps->audio_cnt >= 32) {\n\t\t\tmpeg2ps_stream_destroy(sptr);\n\t\t\treturn 0;\n\t\t}\n\t\tps->audio_streams[ps->audio_cnt] = sptr;\n\t\tps->audio_cnt++;\n\t}\n\treturn 1;\n}\n\nstatic void check_fd_for_stream (mpeg2ps_t *ps,\n                                 mpeg2ps_stream_t *sptr)\n{\n\tif (sptr->m_fd != FDNULL) return;\n\n\tsptr->m_fd = file_open(ps->filename);\n}\n\n/*\n * advance_frame - when we're reading frames, this indicates that we're\n * done.  We will call this when we read a frame, but not when we\n * seek.  It allows us to leave the last frame we're seeking in the\n * buffer\n */\nstatic void advance_frame (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on += sptr->frame_len;\n\tsptr->have_frame_loaded = 0;\n\tif (sptr->frame_ts.have_dts || sptr->frame_ts.have_pts) {\n\t\tif (sptr->frame_ts.have_dts)\n\t\t\tsptr->last_ts = sptr->frame_ts.dts;\n\t\telse\n\t\t\tsptr->last_ts = sptr->frame_ts.pts;\n\t\tsptr->frames_since_last_ts = 0;\n\t} else {\n\t\tsptr->frames_since_last_ts++;\n\t}\n}\n/*\n * get_info_for_all_streams - loop through found streams - read an\n * figure out the info\n */\nstatic void get_info_for_all_streams (mpeg2ps_t *ps)\n{\n\tu8 stream_ix, max_ix, av;\n\tmpeg2ps_stream_t *sptr;\n\tu8 *buffer;\n\tu32 buflen;\n\n\tfile_seek_to(ps->fd, 0);\n\n\t// av will be 0 for video streams, 1 for audio streams\n\t// av is just so I don't have to dup a lot of code that does the\n\t// same thing.\n\tfor (av = 0; av < 2; av++) {\n\t\tif (av == 0) max_ix = ps->video_cnt;\n\t\telse max_ix = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_ix; stream_ix++) {\n\t\t\tif (av == 0) sptr = ps->video_streams[stream_ix];\n\t\t\telse sptr = ps->audio_streams[stream_ix];\n\n\t\t\t// we don't open a separate file descriptor yet (only when they\n\t\t\t// start reading or seeking).  Use the one from the ps.\n\t\t\tsptr->m_fd = ps->fd; // for now\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tif (mpeg2ps_stream_read_frame(sptr,\n\t\t\t                              &buffer,\n\t\t\t                              &buflen,\n\t\t\t                              0) == 0) {\n\t\t\t\tsptr->m_stream_id = 0;\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tget_info_from_frame(sptr, buffer, buflen);\n\t\t\t// here - if (sptr->first_pes_has_dts == 0) should be processed\n\t\t\tif ((sptr->first_pes_has_dts == 0) && sptr->m_fd) {\n\t\t\t\tu32 frames_from_beg = 0;\n\t\t\t\tBool have_frame;\n\t\t\t\tdo {\n\t\t\t\t\tadvance_frame(sptr);\n\t\t\t\t\thave_frame =\n\t\t\t\t\t    mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, 0);\n\t\t\t\t\tframes_from_beg++;\n\t\t\t\t} while (have_frame &&\n\t\t\t\t         sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0 &&\n\t\t\t\t         frames_from_beg < 1000);\n\t\t\t\tif (have_frame == 0 ||\n\t\t\t\t        (sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0)) {\n\t\t\t\t} else {\n\t\t\t\t\tsptr->start_dts = sptr->frame_ts.have_dts ? sptr->frame_ts.dts :\n\t\t\t\t\t                  sptr->frame_ts.pts;\n\t\t\t\t\tif (sptr->is_video) {\n\t\t\t\t\t\tsptr->start_dts -= frames_from_beg * sptr->ticks_per_frame;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu64 conv;\n\t\t\t\t\t\tconv = sptr->samples_per_frame * 90000;\n\t\t\t\t\t\tconv /= (u64)sptr->freq;\n\t\t\t\t\t\tsptr->start_dts -= conv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tsptr->m_fd = FDNULL;\n\t\t}\n\t}\n}\n\n/*\n * mpeg2ps_scan_file - read file, grabbing all the information that\n * we can out of it (what streams exist, timing, etc).\n */\nstatic void mpeg2ps_scan_file (mpeg2ps_t *ps)\n{\n\tu8 stream_id, stream_ix, substream, av_ix, max_cnt;\n\tu16 pes_len, pes_left;\n\tmpeg2ps_ts_t ts;\n\ts64 loc, first_video_loc = 0, first_audio_loc = 0;\n\ts64 check, orig_check;\n\tmpeg2ps_stream_t *sptr;\n\tBool valid_stream;\n\tu8 *buffer;\n\tu32 buflen;\n\tBool have_ts;\n\n\tps->end_loc = file_size(ps->fd);\n\torig_check = check = MAX(ps->end_loc / 50, 200 * 1024);\n\n\t/*\n\t * This part reads and finds the streams.  We check up until we\n\t * find audio and video plus a little, with a max of either 200K or\n\t * the file size / 50\n\t */\n\tloc = 0;\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len) &&\n\t        loc < check) {\n\t\tpes_left = pes_len;\n\t\tif (stream_id >= 0xbd && stream_id < 0xf0) {\n\t\t\tloc = file_location(ps->fd) - 6;\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalid_stream = 0;\n\t\t\tsubstream = 0;\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif ((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0)) {\n\t\t\t\t\tvalid_stream = 1;\n\t\t\t\t}\n\t\t\t} else if (stream_id >= 0xc0) {\n\t\t\t\t// audio and video\n\t\t\t\tvalid_stream = 1;\n\t\t\t}\n\t\t\tif (valid_stream) {\n\t\t\t\tif (add_stream(ps, stream_id, substream, loc, &ts)) {\n\t\t\t\t\t// added\n\t\t\t\t\tif (stream_id >= 0xe0) {\n\t\t\t\t\t\tif (ps->video_cnt == 1) {\n\t\t\t\t\t\t\tfirst_video_loc = loc;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ps->audio_cnt == 1) {\n\t\t\t\t\t\tfirst_audio_loc = loc;\n\t\t\t\t\t}\n\t\t\t\t\tif (ps->audio_cnt > 0 && ps->video_cnt > 0) {\n\t\t\t\t\t\ts64 diff;\n\t\t\t\t\t\tif (first_audio_loc > first_video_loc)\n\t\t\t\t\t\t\tdiff = first_audio_loc - first_video_loc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdiff = first_video_loc - first_audio_loc;\n\t\t\t\t\t\tdiff *= 2;\n\t\t\t\t\t\tdiff += first_video_loc;\n\t\t\t\t\t\tif (diff < check) {\n\t\t\t\t\t\t\tcheck = diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfile_skip_bytes(ps->fd, pes_left);\n\t}\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\treturn;\n\t}\n\t/*\n\t * Now, we go to close to the end, and try to find the last\n\t * dts that we can\n\t */\n\tfile_seek_to(ps->fd, ps->end_loc - orig_check);\n\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len)) {\n\t\tloc = file_location(ps->fd) - 6;\n\t\tif (stream_id == 0xbd || (stream_id >= 0xc0 && stream_id < 0xf0)) {\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif (!((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0))) {\n\t\t\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubstream = 0;\n\t\t\t}\n\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\tif (sptr == NULL) {\n\t\t\t\tadd_stream(ps, stream_id, substream, 0, NULL);\n\t\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\t}\n\t\t\tif (sptr != NULL && have_ts) {\n\t\t\t\tsptr->end_dts = ts.have_dts ? ts.dts : ts.pts;\n\t\t\t\tsptr->end_dts_loc = loc;\n\t\t\t}\n\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t}\n\t}\n\n\t/*\n\t * Now, get the info for all streams, so we can use it again\n\t * we could do this before the above, I suppose\n\t */\n\tget_info_for_all_streams(ps);\n\n\tps->first_dts = (u64) -1;\n\n\t/*\n\t * we need to find the earliest start pts - we use that to calc\n\t * the rest of the timing, so we're 0 based.\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\t\t\tif (sptr != NULL && sptr->start_dts < ps->first_dts) {\n\t\t\t\tps->first_dts = sptr->start_dts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now, for each thread, we'll start at the last pts location, and\n\t * read the number of frames.  This will give us a max time\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tu32 frame_cnt_since_last;\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\n\t\t\t// pick up here - find the final time...\n\t\t\tif (sptr && (sptr->end_dts_loc != 0)) {\n\t\t\t\tfile_seek_to(ps->fd, sptr->end_dts_loc);\n\t\t\t\tsptr->m_fd = ps->fd;\n\t\t\t\tframe_cnt_since_last = 0;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\twhile (mpeg2ps_stream_read_frame(sptr,\n\t\t\t\t                                 &buffer,\n\t\t\t\t                                 &buflen,\n\t\t\t\t                                 1)) {\n\t\t\t\t\tframe_cnt_since_last++;\n\t\t\t\t}\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\tps->max_time = MAX(ps->max_time,\n\t\t\t\t                   convert_ts(sptr,\n\t\t\t\t                              TS_MSEC,\n\t\t\t\t                              sptr->end_dts,\n\t\t\t\t                              ps->first_dts,\n\t\t\t\t                              frame_cnt_since_last));\n\t\t\t}\n\t\t}\n\t}\n\n\tps->max_dts = (ps->max_time * 90) + ps->first_dts;\n\tfile_seek_to(ps->fd, 0);\n}\n\n/*************************************************************************\n * API routines\n *************************************************************************/\nu64 mpeg2ps_get_max_time_msec (mpeg2ps_t *ps)\n{\n\treturn ps->max_time;\n}\n\nu32 mpeg2ps_get_video_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->video_cnt;\n}\n\n#define NUM_ELEMENTS_IN_ARRAY(name) ((sizeof((name))) / (sizeof(*(name))))\n\n// routine to check stream number passed.\nstatic Bool invalid_video_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->video_streams)) return 1;\n\tif (ps->video_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_video_stream_name (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\tif (ps->video_streams[streamno]->have_mpeg2) {\n\t\treturn \"Mpeg-2\";\n\t}\n\treturn \"Mpeg-1\";\n}\n#endif\n\nmpeg2ps_video_type_t mpeg2ps_get_video_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn MPEG_VIDEO_UNKNOWN;\n\t}\n\treturn ps->video_streams[streamno]->have_mpeg2 ? MPEG_VIDEO_MPEG2 : MPEG_VIDEO_MPEG1;\n}\n\nu32 mpeg2ps_get_video_stream_width (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->w;\n}\n\nu32 mpeg2ps_get_video_stream_height (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->h;\n}\n\nu32 mpeg2ps_get_video_stream_aspect_ratio (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->par;\n}\n\nDouble mpeg2ps_get_video_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->bit_rate;\n}\n\nDouble mpeg2ps_get_video_stream_framerate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->frame_rate;\n}\n\nu32 mpeg2ps_get_video_stream_id(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->m_stream_id;\n}\n\nstatic Bool invalid_audio_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->audio_streams)) return 1;\n\tif (ps->audio_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\nu32 mpeg2ps_get_audio_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->audio_cnt;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_audio_stream_name (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn \"none\";\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\tswitch (ps->audio_streams[streamno]->layer) {\n\t\tcase 1:\n\t\t\treturn \"MP1\";\n\t\tcase 2:\n\t\t\treturn \"MP2\";\n\t\tcase 3:\n\t\t\treturn \"MP3\";\n\t\t}\n\t\treturn \"unknown mpeg layer\";\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn \"AC3\";\n\n\treturn \"LPCM\";\n}\n#endif\n\nmpeg2ps_audio_type_t mpeg2ps_get_audio_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn MPEG_AUDIO_UNKNOWN;\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\treturn MPEG_AUDIO_MPEG;\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn MPEG_AUDIO_AC3;\n\n\treturn MPEG_AUDIO_LPCM;\n}\n\nu32 mpeg2ps_get_audio_stream_sample_freq (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->freq;\n}\n\nu32 mpeg2ps_get_audio_stream_channels (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->channels;\n}\n\nu32 mpeg2ps_get_audio_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->bitrate;\n}\n\nu32 mpeg2ps_get_audio_stream_id (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->m_stream_id;\n}\n\n\nmpeg2ps_t *mpeg2ps_init (const char *filename)\n{\n\tmpeg2ps_t *ps;\n\tGF_SAFEALLOC(ps, mpeg2ps_t);\n\n\tif (ps == NULL) {\n\t\treturn NULL;\n\t}\n\tmemset(ps, 0, sizeof(*ps));\n\tps->fd = file_open(filename);\n\tif (file_okay(ps->fd) == 0) {\n\t\tgf_free(ps);\n\t\treturn NULL;\n\t}\n\n\tps->filename = gf_strdup(filename);\n\tmpeg2ps_scan_file(ps);\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\tmpeg2ps_close(ps);\n\t\treturn NULL;\n\t}\n\treturn ps;\n}\n\nvoid mpeg2ps_close (mpeg2ps_t *ps)\n{\n\tu32 ix;\n\tif (ps == NULL) return;\n\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->video_streams[ix]);\n\t\tps->video_streams[ix] = NULL;\n\t}\n\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->audio_streams[ix]);\n\t\tps->audio_streams[ix] = NULL;\n\t}\n\n\tif (ps->filename) gf_free(ps->filename);\n\tif (ps->fd) file_close(ps->fd);\n\tgf_free(ps);\n}\n\n/*\n * check_fd_for_stream will make sure we have a fd for the stream we're\n * trying to read - we use a different fd for each stream\n */\n\n/*\n * stream_convert_frame_ts_to_msec - given a \"read\" frame, we'll\n * calculate the msec and freq timestamps.  This can be called more\n * than 1 time, if needed, without changing any variables, such as\n * frames_since_last_ts, which gets updated in advance_frame\n */\nstatic u64 stream_convert_frame_ts_to_msec (mpeg2ps_stream_t *sptr,\n        mpeg2ps_ts_type_t ts_type,\n        u64 base_dts,\n        u32 *freq_ts)\n{\n\tu64 calc_ts;\n\tu32 frames_since_last = 0;\n\tu64 freq_conv;\n\n\tcalc_ts = sptr->last_ts;\n\tif (sptr->frame_ts.have_dts) calc_ts = sptr->frame_ts.dts;\n\telse if (sptr->frame_ts.have_pts) calc_ts = sptr->frame_ts.dts;\n\telse frames_since_last = sptr->frames_since_last_ts + 1;\n\n\tif (freq_ts != NULL) {\n\t\tfreq_conv = calc_ts - base_dts;\n\t\tfreq_conv *= sptr->freq;\n\t\tfreq_conv /= 90000;\n\t\tfreq_conv += frames_since_last * sptr->samples_per_frame;\n\t\t*freq_ts = (u32) (freq_conv & 0xffffffff);\n\t}\n\treturn convert_ts(sptr, ts_type, calc_ts, base_dts, frames_since_last);\n}\n\n/*\n * mpeg2ps_get_video_frame - gets the next frame\n */\nBool mpeg2ps_get_video_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             u8 *frame_type,\n                             mpeg2ps_ts_type_t ts_type,\n                             u64 *decode_timestamp, u64 *compose_timestamp)\n{\n\tu64 dts, cts;\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->video_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\t// if we don't have the frame in the buffer (like after a seek),\n\t\t// read the next frame\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t*buflen = sptr->frame_len;\n\t// determine frame type\n\tif (frame_type != NULL) {\n\t\t*frame_type = MPEG12_PictHdrType(sptr->pes_buffer +\n\t\t                                 sptr->pict_header_offset);\n\t}\n\n\t// set the timestamps\n\tif (sptr->frame_ts.have_pts)\n\t\tcts = sptr->frame_ts.pts;\n\telse\n\t\tcts = sptr->last_ts + (1+sptr->frames_since_last_ts) * sptr->ticks_per_frame;\n\tif (sptr->frame_ts.have_dts)\n\t\tdts = sptr->frame_ts.dts;\n\telse\n\t\tdts = cts;\n\n\tif (decode_timestamp) *decode_timestamp = dts;\n\tif (compose_timestamp) *compose_timestamp = cts;\n\n\t//indicate that we read this frame - get ready for the next one.\n\tadvance_frame(sptr);\n\n\n\treturn 1;\n}\n\n\n// see above comments\nBool mpeg2ps_get_audio_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             mpeg2ps_ts_type_t ts_type,\n                             u32 *freq_timestamp,\n                             u64 *timestamp)\n{\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->audio_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\tif (mpeg2ps_stream_read_frame(sptr, buffer, buflen, 0) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (freq_timestamp) {\n\t\t/*ts = */stream_convert_frame_ts_to_msec(sptr,\n\t\t                                     ts_type,\n\t\t                                     ps->first_dts,\n\t\t                                     freq_timestamp);\n\t}\n\tif (timestamp != NULL) {\n\t\t*timestamp = sptr->frame_ts.have_pts ? sptr->frame_ts.pts : sptr->frame_ts.dts;\n\t}\n\tadvance_frame(sptr);\n\treturn 1;\n}\n\n#if 0 //unused\nu64 mpeg2ps_get_ps_size(mpeg2ps_t *ps)\n{\n\treturn file_size(ps->fd);\n}\ns64 mpeg2ps_get_video_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->video_streams[streamno]->m_fd);\n}\ns64 mpeg2ps_get_audio_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->audio_streams[streamno]->m_fd);\n}\n#endif\n\n\n/***************************************************************************\n * seek routines\n ***************************************************************************/\n/*\n * mpeg2ps_binary_seek - look for a pts that's close to the one that\n * we're looking for.  We have a start ts and location, an end ts and\n * location, and what we're looking for\n */\nstatic void mpeg2ps_binary_seek (mpeg2ps_t *ps,\n\t\t\t\t mpeg2ps_stream_t *sptr,\n\t\t\t\t u64 search_dts,\n\t\t\t\t u64 start_dts,\n\t\t\t\t u64 start_loc,\n\t\t\t\t u64 end_dts,\n\t\t\t\tu64 end_loc)\n{\n  u64 dts_perc;\n  u64 loc;\n  u16 pes_len;\n  Bool have_ts = GF_FALSE;\n  u64 found_loc;\n  u64 found_dts;\n\n  while (1) {\n    /*\n     * It's not a binary search as much as using a percentage between\n     * the start and end dts to start.  We subtract off a bit, so we\n     * approach from the beginning of the file - we're more likely to\n     * hit a pts that way\n     */\n    dts_perc = (search_dts - start_dts) * 1000 / (end_dts - start_dts);\n    dts_perc -= dts_perc % 10;\n\n    loc = ((end_loc - start_loc) * dts_perc) / 1000;\n\n    if (loc == start_loc || loc == end_loc) return;\n\n    clear_stream_buffer(sptr);\n    file_seek_to(sptr->m_fd, start_loc + loc);\n\n    // we'll look for the next pes header for this stream that has a ts.\n    do {\n      if (search_for_next_pes_header(sptr,\n\t\t\t\t     &pes_len,\n\t\t\t\t     &have_ts,\n\t\t\t\t     &found_loc) == GF_FALSE) {\n\treturn;\n      }\n      if (have_ts == GF_FALSE) {\n\tfile_skip_bytes(sptr->m_fd, pes_len);\n      }\n    } while (have_ts == GF_FALSE);\n\n    // record that spot...\n    mpeg2ps_record_pts(sptr, found_loc, &sptr->next_pes_ts);\n\n    found_dts = sptr->next_pes_ts.have_dts ?\n      sptr->next_pes_ts.dts : sptr->next_pes_ts.pts;\n    /*\n     * Now, if we're before the search ts, and within 5 seconds,\n     * we'll say we're close enough\n     */\n    if (found_dts + (5 * 90000) > search_dts &&\n\tfound_dts < search_dts) {\n      file_seek_to(sptr->m_fd, found_loc);\n      return; // found it - we can seek from here\n    }\n    /*\n     * otherwise, move the head or the tail (most likely the head).\n     */\n    if (found_dts > search_dts) {\n      if (found_dts >= end_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      end_loc = found_loc;\n      end_dts = found_dts;\n    } else {\n      if (found_dts <= start_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      start_loc = found_loc;\n      start_dts = found_dts;\n    }\n  }\n}\n\n\n\nstatic mpeg2ps_record_pes_t *search_for_ts (mpeg2ps_stream_t *sptr,\n\t\t\t\t     u64 dts)\n{\n  mpeg2ps_record_pes_t *p, *q;\n  u64 p_diff, q_diff;\n  if (sptr->record_last == NULL) return NULL;\n\n  if (dts > sptr->record_last->dts) return sptr->record_last;\n\n  if (dts < sptr->record_first->dts) return NULL;\n  if (dts == sptr->record_first->dts) return sptr->record_first;\n\n  p = sptr->record_first;\n  q = p->next_rec;\n\n  while (q != NULL && q->dts > dts) {\n    p = q;\n    q = q->next_rec;\n  }\n  if (q == NULL) {\n    return sptr->record_last;\n  }\n\n  p_diff = dts - p->dts;\n  q_diff = q->dts - dts;\n\n  if (p_diff < q_diff) return p;\n  if (q_diff > 90000) return p;\n\n  return q;\n}\n\n\n/*\n * mpeg2ps_seek_frame - seek to the next timestamp after the search timestamp\n * First, find a close DTS (usually minus 5 seconds or closer), then\n * read frames until we get the frame after the timestamp.\n */\nstatic Bool mpeg2ps_seek_frame (mpeg2ps_t *ps,\n\t\t\t\tmpeg2ps_stream_t *sptr,\n\t\t\t\tu64 search_msec_timestamp)\n{\n  u64 dts;\n  mpeg2ps_record_pes_t *rec;\n  u64 msec_ts;\n  u8 *buffer;\n  u32 buflen;\n\n  check_fd_for_stream(ps, sptr);\n  clear_stream_buffer(sptr);\n\n  if (search_msec_timestamp <= 1000) { // first second, start from begin...\n    file_seek_to(sptr->m_fd, sptr->first_pes_loc);\n    return GF_TRUE;\n  }\n  dts = search_msec_timestamp * 90; // 1000 timescale to 90000 timescale\n  dts += ps->first_dts;\n\n  /*\n   * see if the recorded data has anything close\n   */\n  rec = search_for_ts(sptr, dts);\n  if (rec != NULL) {\n    // see if it is close\n    // if we're plus or minus a second, seek to that.\n    if (rec->dts + 90000 >= dts && rec->dts <= dts + 90000) {\n      file_seek_to(sptr->m_fd, rec->location);\n      return GF_TRUE;\n    }\n    // at this point, rec is > a distance.  If within 5 or so seconds,\n\n    if (rec->dts + (5 * 90000) < dts) {\n      // more than 5 seconds away - skip and search\n      if (rec->next_rec == NULL) {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    sptr->end_dts, sptr->end_dts_loc);\n      } else {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    rec->next_rec->dts, rec->next_rec->location);\n      }\n    }\n    // otherwise, frame by frame search...\n  } else {\n    // we weren't able to find anything from the recording\n    mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\tsptr->start_dts, sptr->first_pes_loc,\n\t\t\tsptr->end_dts, sptr->end_dts_loc);\n  }\n  /*\n   * Now, the fun part - read frames until we're just past the time\n   */\n  clear_stream_buffer(sptr); // clear out any data, so we can read it\n  do {\n    if (mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, GF_FALSE) == GF_FALSE)\n      return GF_FALSE;\n\n    msec_ts = stream_convert_frame_ts_to_msec(sptr, TS_MSEC,\n\t\t\t\t\t      ps->first_dts, NULL);\n\n    if (msec_ts < search_msec_timestamp) {\n      // only advance the frame if we're not greater than the timestamp\n      advance_frame(sptr);\n    }\n  } while (msec_ts < search_msec_timestamp);\n\n  return GF_TRUE;\n}\n\n\n/*\n * mpeg2ps_seek_video_frame - seek to the location that we're interested\n * in, then scroll up to the next I frame\n */\nBool mpeg2ps_seek_video_frame (mpeg2ps_t *ps, u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_video_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->video_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp)\n\t\t\t  == GF_FALSE) return GF_FALSE;\n\n  if (sptr->have_frame_loaded == GF_FALSE) {\n    return GF_FALSE;\n  }\n  return GF_TRUE;\n}\n/*\n * mpeg2ps_seek_audio_frame - go to the closest audio frame after the\n * timestamp\n */\nBool mpeg2ps_seek_audio_frame (mpeg2ps_t *ps,\n\t\t\t       u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  //  off_t closest_pes;\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_audio_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->audio_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp) == GF_FALSE) return GF_FALSE;\n\n  return GF_TRUE;\n}\n\nu64 mpeg2ps_get_first_cts(mpeg2ps_t *ps)\n{\n\treturn ps->first_dts;\n}\n\n\n#endif /*GPAC_DISABLE_MPEG2PS*/\n"], "fixing_code": ["/*\n * The contents of this file are subject to the Mozilla Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Original Code is MPEG4IP.\n *\n * The Initial Developer of the Original Code is Cisco Systems Inc.\n * Portions created by Cisco Systems Inc. are\n * Copyright (C) Cisco Systems Inc. 2004.  All Rights Reserved.\n *\n * Contributor(s):\n *\t\tBill May wmay@cisco.com\n */\n\n/*\n * mpeg2ps.c - parse program stream and vob files\n */\n#include \"mpeg2_ps.h\"\n\n#ifndef GPAC_DISABLE_MPEG2PS\n\n\nstatic GFINLINE u16 convert16 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u16 *)p;\n#else\n\tu16 val = p[0];\n\tval <<= 8;\n\treturn (val | p[1]);\n#endif\n}\n\nstatic GFINLINE u32 convert32 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u32 *)p;\n#else\n\tu32 val;\n\tval = p[0];\n\tval <<= 8;\n\tval |= p[1];\n\tval <<= 8;\n\tval |= p[2];\n\tval <<= 8;\n\tval |= p[3];\n\treturn val;\n#endif\n}\n\n#define FDNULL 0\n\n/*\n * structure for passing timestamps around\n */\ntypedef struct mpeg2ps_ts_t\n{\n\tBool have_pts;\n\tBool have_dts;\n\tu64 pts;\n\tu64 dts;\n} mpeg2ps_ts_t;\n\ntypedef struct mpeg2ps_record_pes_t\n{\n\tstruct mpeg2ps_record_pes_t *next_rec;\n\tu64 dts;\n\tu64 location;\n} mpeg2ps_record_pes_t;\n\n/*\n * information about reading a stream\n */\ntypedef struct mpeg2ps_stream_t\n{\n\tmpeg2ps_record_pes_t *record_first, *record_last;\n\tFILE *m_fd;\n\tBool is_video;\n\tu8 m_stream_id;    // program stream id\n\tu8 m_substream_id; // substream, for program stream id == 0xbd\n\n\tmpeg2ps_ts_t next_pes_ts, frame_ts;\n\tu32 frames_since_last_ts;\n\tu64 last_ts;\n\n\tBool have_frame_loaded;\n\t/*\n\t * pes_buffer processing.  this contains the raw elementary stream data\n\t */\n\tu8 *pes_buffer;\n\tu32 pes_buffer_size;\n\tu32 pes_buffer_size_max;\n\tu32 pes_buffer_on;\n\tu32 frame_len;\n\tu32 pict_header_offset; // for mpeg video\n\n\t// timing information and locations.\n\ts64 first_pes_loc;\n\tu64 start_dts;\n\tBool first_pes_has_dts;\n\ts64    end_dts_loc;\n\tu64 end_dts;\n\t// audio stuff\n\tu32 freq;\n\tu32 channels;\n\tu32 bitrate;\n\tu32 samples_per_frame;\n\tu32 layer;\n\t// video stuff\n\tu32 h, w, par;\n\tDouble frame_rate;\n\ts32 have_mpeg2;\n\tDouble bit_rate;\n\tu64 ticks_per_frame;\n\n} mpeg2ps_stream_t;\n\n/*\n * main interface structure - contains stream pointers and other\n * information\n */\nstruct mpeg2ps_ {\n\tmpeg2ps_stream_t *video_streams[16];\n\tmpeg2ps_stream_t *audio_streams[32];\n\tchar *filename;\n\tFILE *fd;\n\tu64 first_dts;\n\tu32 audio_cnt, video_cnt;\n\ts64 end_loc;\n\tu64 max_dts;\n\tu64 max_time;  // time is in msec.\n};\n\n/*************************************************************************\n * File access routines.  Could all be inline\n *************************************************************************/\nstatic FILE *file_open (const char *name)\n{\n\treturn gf_fopen(name, \"rb\");\n}\n\nstatic Bool file_okay (FILE *fd)\n{\n\treturn (fd!=NULL) ? 1 : 0;\n}\n\nstatic void file_close (FILE *fd)\n{\n\tgf_fclose(fd);\n}\n\nstatic Bool file_read_bytes(FILE *fd,\n                            u8 *buffer,\n                            u32 len)\n{\n\tu32 readval = (u32) gf_fread(buffer, len, fd);\n\treturn readval == len;\n}\n\n// note: len could be negative.\nstatic void file_skip_bytes (FILE *fd, s32 len)\n{\n\tgf_fseek(fd, len, SEEK_CUR);\n}\n\n#define file_location(__f) gf_ftell(__f)\n#define file_seek_to(__f, __off) gf_fseek(__f, __off, SEEK_SET)\n\nstatic u64 file_size(FILE *fd)\n{\n\treturn gf_fsize(fd);\n}\n\nstatic mpeg2ps_record_pes_t *create_record (s64 loc, u64 ts)\n{\n\tmpeg2ps_record_pes_t *ret;\n\tGF_SAFEALLOC(ret, mpeg2ps_record_pes_t);\n\tif (!ret) return NULL;\n\tret->next_rec = NULL;\n\tret->dts = ts;\n\tret->location = loc;\n\treturn ret;\n}\n\n#define MPEG2PS_RECORD_TIME ((u64) (5 * 90000))\nvoid mpeg2ps_record_pts (mpeg2ps_stream_t *sptr, s64 location, mpeg2ps_ts_t *pTs)\n{\n\tu64 ts;\n\tmpeg2ps_record_pes_t *p, *q;\n\tif (sptr->is_video) {\n\t\tif (pTs->have_dts == 0) return;\n\t\tts = pTs->dts;\n\t} else {\n\t\tif (pTs->have_pts == 0) return;\n\t\tts = pTs->pts;\n\t}\n\n\tif (sptr->record_first == NULL) {\n\t\tsptr->record_first = sptr->record_last = create_record(location, ts);\n\t\treturn;\n\t}\n\tif (ts > sptr->record_last->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_last->dts) return;\n\t\tsptr->record_last->next_rec = create_record(location, ts);\n\t\tsptr->record_last = sptr->record_last->next_rec;\n\t\treturn;\n\t}\n\tif (ts < sptr->record_first->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_first->dts) return;\n\t\tp = create_record(location, ts);\n\t\tp->next_rec = sptr->record_first;\n\t\tsptr->record_first = p;\n\t\treturn;\n\t}\n\tp = sptr->record_first;\n\tq = p->next_rec;\n\n\twhile (q != NULL && q->dts < ts) {\n\t\tp = q;\n\t\tq = q->next_rec;\n\t}\n\tif (q) {\n\t\tif (p->dts + MPEG2PS_RECORD_TIME <= ts &&\n\t\t\t\tts + MPEG2PS_RECORD_TIME <= q->dts) {\n\t\t\tp->next_rec = create_record(location, ts);\n\t\t\tp->next_rec->next_rec = q;\n\t\t}\n\t}\n}\nstatic Double mpeg12_frame_rate_table[16] =\n{\n\t0.0,   /* Pad */\n\t24000.0/1001.0,       /* Official frame rates */\n\t24.0,\n\t25.0,\n\t30000.0/1001.0,\n\t30.0,\n\t50.0,\n\t((60.0*1000.0)/1001.0),\n\t60.0,\n\n\t1,                    /* Unofficial economy rates */\n\t5,\n\t10,\n\t12,\n\t15,\n\t0,\n\t0,\n};\n\n#define SEQ_ID 1\nint MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32 *height, u32 *width,\n                       Double *frame_rate, Double *bitrate, u32 *aspect_ratio)\n{\n\tu32 aspect_code;\n\tu32 framerate_code;\n\tu32 bitrate_int;\n\tu32 bitrate_ext;\n\tu32 scode, ix;\n\ts32 found = -1;\n\t*have_mpeg2 = 0;\n\tif (buflen<6) return found;\n\n\tbuflen -= 6;\n\tbitrate_int = 0;\n\tfor (ix = 0; ix < buflen; ix++, pbuffer++) {\n\t\tscode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |\n\t\t        pbuffer[3];\n\n\t\tif (scode == MPEG12_SEQUENCE_START_CODE) {\n\t\t\tpbuffer += sizeof(u32);\n\t\t\t*width = (pbuffer[0]);\n\t\t\t*width <<= 4;\n\t\t\t*width |= ((pbuffer[1] >> 4) &0xf);\n\t\t\t*height = (pbuffer[1] & 0xf);\n\t\t\t*height <<= 8;\n\t\t\t*height |= pbuffer[2];\n\t\t\taspect_code = (pbuffer[3] >> 4) & 0xf;\n\t\t\tif (aspect_ratio != NULL) {\n\t\t\t\tu32 par = 0;\n\t\t\t\tswitch (aspect_code) {\n\t\t\t\tdefault:\n\t\t\t\t\t*aspect_ratio = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpar = 4;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpar = 16;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tpar = 2;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 21;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*aspect_ratio = par;\n\t\t\t}\n\n\n\t\t\tframerate_code = pbuffer[3] & 0xf;\n\t\t\t*frame_rate = mpeg12_frame_rate_table[framerate_code];\n\t\t\t// 18 bits\n\t\t\tbitrate_int = (pbuffer[4] << 10) |\n\t\t\t              (pbuffer[5] << 2) |\n\t\t\t              ((pbuffer[6] >> 6) & 0x3);\n\t\t\t*bitrate = bitrate_int;\n\t\t\t*bitrate *= 400.0;\n\t\t\tix += sizeof(u32) + 7;\n\t\t\tpbuffer += 7;\n\t\t\tfound = 0;\n\t\t} else if (found == 0) {\n\t\t\tif (scode == MPEG12_EXT_START_CODE) {\n\t\t\t\tpbuffer += sizeof(u32);\n\t\t\t\tix += sizeof(u32);\n\t\t\t\tswitch ((pbuffer[0] >> 4) & 0xf) {\n\t\t\t\tcase SEQ_ID:\n\t\t\t\t\t*have_mpeg2 = 1;\n\t\t\t\t\t*height = ((pbuffer[1] & 0x1) << 13) |\n\t\t\t\t\t          ((pbuffer[2] & 0x80) << 5) |\n\t\t\t\t\t          (*height & 0x0fff);\n\t\t\t\t\t*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);\n\t\t\t\t\tbitrate_ext = (pbuffer[2] & 0x1f) << 7;\n\t\t\t\t\tbitrate_ext |= (pbuffer[3] >> 1) & 0x7f;\n\t\t\t\t\tbitrate_int |= (bitrate_ext << 18);\n\t\t\t\t\t*bitrate = bitrate_int;\n\t\t\t\t\t*bitrate *= 400.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpbuffer++;\n\t\t\t\tix++;\n\t\t\t} else if (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\treturn found;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n\ns32 MPEG12_PictHdrType (unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[1] >> 3) & 0x7);\n}\n\n#if 0 //unused\nu16 MPEG12_PictHdrTempRef(unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[0] << 2) | ((pbuffer[1] >> 6) & 0x3));\n}\n#endif\n\n\nstatic u64 read_pts (u8 *pak)\n{\n\tu64 pts;\n\tu16 temp;\n\n\tpts = ((pak[0] >> 1) & 0x7);\n\tpts <<= 15;\n\ttemp = convert16(&pak[1]) >> 1;\n\tpts |= temp;\n\tpts <<= 15;\n\ttemp = convert16(&pak[3]) >> 1;\n\tpts |= temp;\n\treturn pts;\n}\n\n\nstatic mpeg2ps_stream_t *mpeg2ps_stream_create (u8 stream_id,\n        u8 substream)\n{\n\tmpeg2ps_stream_t *ptr;\n\tGF_SAFEALLOC(ptr, mpeg2ps_stream_t);\n\tif (!ptr) return NULL;\n\tptr->m_stream_id = stream_id;\n\tptr->m_substream_id = substream;\n\tptr->is_video = stream_id >= 0xe0;\n\tptr->pes_buffer = (u8 *)gf_malloc(4*4096);\n\tptr->pes_buffer_size_max = 4 * 4096;\n\treturn ptr;\n}\n\nstatic void mpeg2ps_stream_destroy (mpeg2ps_stream_t *sptr)\n{\n\tmpeg2ps_record_pes_t *p;\n\twhile (sptr->record_first != NULL) {\n\t\tp = sptr->record_first;\n\t\tsptr->record_first = p->next_rec;\n\t\tgf_free(p);\n\t}\n\tif (sptr->m_fd != FDNULL) {\n\t\tfile_close(sptr->m_fd);\n\t\tsptr->m_fd = FDNULL;\n\t}\n\tif (sptr->pes_buffer) gf_free(sptr->pes_buffer);\n\tgf_free(sptr);\n}\n\n\n/*\n * adv_past_pack_hdr - read the pack header, advance past it\n * we don't do anything with the data\n */\nstatic void adv_past_pack_hdr (FILE *fd,\n                               u8 *pak,\n                               u32 read_from_start)\n{\n\tu8 stuffed;\n\tu8 readbyte;\n\tu8 val;\n\tif (read_from_start < 5) {\n\t\tfile_skip_bytes(fd, 5 - read_from_start);\n\t\tfile_read_bytes(fd, &readbyte, 1);\n\t\tval = readbyte;\n\t} else {\n\t\tval = pak[4];\n\t}\n\n\t// we've read 6 bytes\n\tif ((val & 0xc0) != 0x40) {\n\t\t// mpeg1\n\t\tfile_skip_bytes(fd, 12 - read_from_start); // skip 6 more bytes\n\t\treturn;\n\t}\n\tfile_skip_bytes(fd, 13 - read_from_start);\n\tfile_read_bytes(fd, &readbyte, 1);\n\tstuffed = readbyte & 0x7;\n\tfile_skip_bytes(fd, stuffed);\n}\n\n/*\n * find_pack_start\n * look for the pack start code in the file - read 512 bytes at a time,\n * searching for that code.\n * Note: we may also be okay looking for >= 00 00 01 bb\n */\nstatic Bool find_pack_start (FILE *fd,\n                             u8 *saved,\n                             u32 len)\n{\n\tu8 buffer[512];\n\tu32 buffer_on = 0, new_offset, scode;\n\tmemcpy(buffer, saved, len);\n\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (gf_mv12_next_start_code(buffer + buffer_on,\n\t\t                            sizeof(buffer) - buffer_on,\n\t\t                            &new_offset,\n\t\t                            &scode) >= 0) {\n\t\t\tbuffer_on += new_offset;\n\t\t\tif (scode == MPEG2_PS_PACKSTART) {\n\t\t\t\tfile_skip_bytes(fd, buffer_on - 512); // go back to header\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbuffer_on += 1;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t\tif (buffer[sizeof(buffer) - 3] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 2] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 1] == 1) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tbuffer[2] = 1;\n\t\t\t\tlen = 3;\n\t\t\t} else if (*(u16 *)(buffer + sizeof(buffer) - 2) == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tlen = 2;\n\t\t\t} else if (buffer[sizeof(buffer) - 1] == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuffer_on = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * copy_bytes_to_pes_buffer - read pes_len bytes into the buffer,\n * adjusting it if we need it\n */\nstatic void copy_bytes_to_pes_buffer (mpeg2ps_stream_t *sptr,\n                                      u16 pes_len)\n{\n\tu32 to_move;\n\n\tif (sptr->pes_buffer_size + pes_len > sptr->pes_buffer_size_max) {\n\t\t// if no room in the buffer, we'll move it - otherwise, just fill\n\t\t// note - we might want a better strategy about moving the buffer -\n\t\t// right now, we might be moving a number of bytes if we have a large\n\t\t// followed by large frame.\n\t\tto_move = sptr->pes_buffer_size - sptr->pes_buffer_on;\n\t\tmemmove(sptr->pes_buffer,\n\t\t        sptr->pes_buffer + sptr->pes_buffer_on,\n\t\t        to_move);\n\t\tsptr->pes_buffer_size = to_move;\n\t\tsptr->pes_buffer_on = 0;\n\t\tif (to_move + pes_len > sptr->pes_buffer_size_max) {\n\t\t\tsptr->pes_buffer = (u8 *)gf_realloc(sptr->pes_buffer,\n\t\t\t                                    to_move + pes_len + 2048);\n\t\t\tsptr->pes_buffer_size_max = to_move + pes_len + 2048;\n\t\t}\n\t}\n\tfile_read_bytes(sptr->m_fd, sptr->pes_buffer + sptr->pes_buffer_size, pes_len);\n\tsptr->pes_buffer_size += pes_len;\n}\n\n/*\n * read_to_next_pes_header - read the file, look for the next valid\n * pes header.  We will skip over PACK headers, but not over any of the\n * headers listed in 13818-1, table 2-18 - basically, anything with the\n * 00 00 01 and the next byte > 0xbb.\n * We return the pes len to read, and the \"next byte\"\n */\nstatic Bool read_to_next_pes_header (FILE *fd,\n                                     u8 *stream_id,\n                                     u16 *pes_len)\n{\n\tu32 hdr;\n\tu8 local[6];\n\n\twhile (1) {\n\t\t// read the pes header\n\t\tif (file_read_bytes(fd, local, 6) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\thdr = convert32(local);\n\t\t// if we're not a 00 00 01, read until we get the next pack start\n\t\t// we might want to also read until next PES - look into that.\n\t\tif (((hdr & MPEG2_PS_START_MASK) != MPEG2_PS_START) ||\n\t\t        (hdr < MPEG2_PS_END)) {\n\t\t\tif (find_pack_start(fd, local, 6) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_PACKSTART) {\n\t\t\t// pack start code - we can skip down\n\t\t\tadv_past_pack_hdr(fd, local, 6);\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_END) {\n\t\t\tfile_skip_bytes(fd, -2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// we should have a valid stream and pes_len here...\n\t\t*stream_id = hdr & 0xff;\n\t\t*pes_len = convert16(local + 4);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * read_pes_header_data\n * this should read past the pes header for the audio and video streams\n * it will store the timestamps if it reads them\n */\nstatic Bool read_pes_header_data (FILE *fd,\n                                  u16 orig_pes_len,\n                                  u16 *pes_left,\n                                  Bool *have_ts,\n                                  mpeg2ps_ts_t *ts)\n{\n\tu16 pes_len = orig_pes_len;\n\tu8 local[10];\n\tu32 hdr_len;\n\n\tts->have_pts = 0;\n\tts->have_dts = 0;\n\tif (have_ts) *have_ts = 0;\n\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\treturn 0;\n\t}\n\tpes_len--; // remove this first byte from length\n\twhile (*local == 0xff) {\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len--;\n\t\tif (pes_len == 0) {\n\t\t\t*pes_left = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((*local & 0xc0) == 0x40) {\n\t\t// buffer scale & size\n\t\tfile_skip_bytes(fd, 1);\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len -= 2;\n\t}\n\n\tif ((*local & 0xf0) == 0x20) {\n\t\t// mpeg-1 with pts\n\t\tif (file_read_bytes(fd, local + 1, 4) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->pts = ts->dts = read_pts(local);\n\t\t*have_ts = 1;\n\t\tpes_len -= 4;\n\t} else if ((*local & 0xf0) == 0x30) {\n\t\t// have mpeg 1 pts and dts\n\t\tif (file_read_bytes(fd, local + 1, 9) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->have_dts = 1;\n\t\t*have_ts = 1;\n\t\tts->pts = read_pts(local);\n\t\tts->dts = read_pts(local + 5);\n\t\tpes_len -= 9;\n\t} else if ((*local & 0xc0) == 0x80) {\n\t\t// mpeg2 pes header  - we're pointing at the flags field now\n\t\tif (file_read_bytes(fd, local + 1, 2) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\thdr_len = local[2];\n\t\tpes_len -= hdr_len + 2; // first byte removed already\n\t\tif ((local[1] & 0xc0) == 0x80) {\n\t\t\t// just pts\n\t\t\tts->have_pts = 1;\n\t\t\tfile_read_bytes(fd, local, 5);\n\t\t\tts->pts = ts->dts = read_pts(local);\n\t\t\t*have_ts = 1;\n\t\t\thdr_len -= 5;\n\t\t} else if ((local[1] & 0xc0) == 0xc0) {\n\t\t\t// pts and dts\n\t\t\tts->have_pts = 1;\n\t\t\tts->have_dts = 1;\n\t\t\t*have_ts = 1;\n\t\t\tfile_read_bytes(fd, local, 10);\n\t\t\tts->pts = read_pts(local);\n\t\t\tts->dts = read_pts(local  + 5);\n\t\t\thdr_len -= 10;\n\t\t}\n\t\tfile_skip_bytes(fd, hdr_len);\n\t} else if (*local != 0xf) {\n\t\tfile_skip_bytes(fd, pes_len);\n\t\tpes_len = 0;\n\t}\n\t*pes_left = pes_len;\n\treturn 1;\n}\n\nstatic Bool search_for_next_pes_header (mpeg2ps_stream_t *sptr,\n                                        u16 *pes_len,\n                                        Bool *have_ts,\n                                        s64 *found_loc)\n{\n\tu8 stream_id;\n\tu8 local;\n\ts64 loc;\n\twhile (1) {\n\t\t// this will read until we find the next pes.  We don't know if the\n\t\t// stream matches - this will read over pack headers\n\t\tif (read_to_next_pes_header(sptr->m_fd, &stream_id, pes_len) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (stream_id != sptr->m_stream_id) {\n\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\tcontinue;\n\t\t}\n\t\tloc = file_location(sptr->m_fd) - 6;\n\t\t// advance past header, reading pts\n\t\tif (read_pes_header_data(sptr->m_fd,\n\t\t                         *pes_len,\n\t\t                         pes_len,\n\t\t                         have_ts,\n\t\t                         &sptr->next_pes_ts) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// If we're looking at a private stream, make sure that the sub-stream\n\t\t// matches.\n\t\tif (sptr->m_stream_id == 0xbd) {\n\t\t\t// ac3 or pcm\n\t\t\tfile_read_bytes(sptr->m_fd, &local, 1);\n\t\t\t*pes_len -= 1;\n\t\t\tif (local != sptr->m_substream_id) {\n\t\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\t\tcontinue; // skip to the next one\n\t\t\t}\n\t\t\t*pes_len -= 3;\n\t\t\tfile_skip_bytes(sptr->m_fd, 3); // 4 bytes - we don't need now...\n\t\t\t// we need more here...\n\t\t}\n\t\tif (have_ts) {\n\t\t\tmpeg2ps_record_pts(sptr, loc, &sptr->next_pes_ts);\n\t\t}\n\t\tif (found_loc != NULL) *found_loc = loc;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * mpeg2ps_stream_read_next_pes_buffer - for the given stream,\n * go forward in the file until the next PES for the stream is read.  Read\n * the header (pts, dts), and read the data into the pes_buffer pointer\n */\nstatic Bool mpeg2ps_stream_read_next_pes_buffer (mpeg2ps_stream_t *sptr)\n{\n\tu16 pes_len;\n\tBool have_ts;\n\n\tif (search_for_next_pes_header(sptr, &pes_len, &have_ts, NULL) == 0) {\n\t\treturn 0;\n\t}\n\n\tcopy_bytes_to_pes_buffer(sptr, pes_len);\n\n\treturn 1;\n}\n\n\n/***************************************************************************\n * Frame reading routine.  For each stream, the fd's should be different.\n * we will read from the pes stream, and save it in the stream's pes buffer.\n * This will give us raw data that we can search through for frame headers,\n * and the like.  We shouldn't read more than we need - when we need to read,\n * we'll put the whole next pes buffer in the buffer\n *\n * Audio routines are of the format:\n *   look for header\n *   determine length\n *   make sure length is in buffer\n *\n * Video routines\n *   look for start header (GOP, SEQ, Picture)\n *   look for pict header\n *   look for next start (END, GOP, SEQ, Picture)\n *\n ***************************************************************************/\n#define IS_MPEG_START(a) ((a) == 0xb3 || (a) == 0x00 || (a) == 0xb8)\n\nstatic Bool\nmpeg2ps_stream_find_mpeg_video_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 offset, scode;\n\tBool have_pict;\n\tBool started_new_pes = 0;\n\tu32 start;\n\t/*\n\t * First thing - determine if we have enough bytes to read the header.\n\t * if we do, we have the correct timestamp.  If not, we read the new\n\t * pes, so we'd want to use the timestamp we read.\n\t */\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_mv12_next_start_code(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                               sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                               &offset,\n\t                               &scode) < 0 ||\n\t        (!IS_MPEG_START(scode & 0xff))) {\n\t\tif (sptr->pes_buffer_size > 3)\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\telse {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t\tstarted_new_pes = 1;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->pes_buffer_on += offset;\n\tif (offset == 0 && started_new_pes) {\n\t\t// nothing...  we've copied the timestamp already.\n\t} else {\n\t\t// we found the new start, but we pulled in a new pes header before\n\t\t// starting.  So, we want to use the header that we read.\n\t\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\t\t// clear timestamp indication\n\t\tsptr->next_pes_ts.have_pts = sptr->next_pes_ts.have_dts = 0;\n\t}\n\n\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\tsptr->pict_header_offset = sptr->pes_buffer_on;\n\t\thave_pict = 1;\n\t} else have_pict = 0;\n\n\tstart = 4 + sptr->pes_buffer_on;\n\twhile (1) {\n\n\t\tif (gf_mv12_next_start_code(sptr->pes_buffer + start,\n\t\t                            sptr->pes_buffer_size - start,\n\t\t                            &offset,\n\t\t                            &scode) < 0) {\n\t\t\tstart = sptr->pes_buffer_size - 3;\n\t\t\tstart -= sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset -= sptr->pes_buffer_on;\n\t\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstart += sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset += sptr->pes_buffer_on;\n\t\t} else {\n\t\t\tstart += offset;\n\t\t\tif (have_pict == 0) {\n\t\t\t\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\t\thave_pict = 1;\n\t\t\t\t\tsptr->pict_header_offset = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (IS_MPEG_START(scode & 0xff) ||\n\t\t\t\t        scode == MPEG12_SEQUENCE_END_START_CODE) {\n\t\t\t\t\tsptr->frame_len = start - sptr->pes_buffer_on;\n\t\t\t\t\tsptr->have_frame_loaded = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart += 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic Bool mpeg2ps_stream_find_ac3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff;\n\tBool started_new_pes = 0;\n\tGF_AC3Config hdr;\n\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 6) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_ac3_parser(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                     sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                     &diff,\n\t                     &hdr, 0) <= 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 6) {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 6;\n\t\t\tstarted_new_pes = 1;\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->frame_len = hdr.framesize;\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\t\t// we might have a new PTS - but it's not here\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\nstatic Bool mpeg2ps_stream_find_mp3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff, hdr;\n\tBool started_new_pes = 0;\n\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile ((hdr=gf_mp3_get_next_header_mem(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                                       sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                                       &diff) ) == 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 3) {\n\t\t\tif (sptr->pes_buffer_on != sptr->pes_buffer_size) {\n\t\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\t\t}\n\t\t\tstarted_new_pes = 1; // we have left over bytes...\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t// have frame.\n\tsptr->frame_len = gf_mp3_frame_size(hdr);\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\n/*\n * mpeg2ps_stream_read_frame.  read the correct frame based on stream type.\n * advance_pointers is 0 when we want to use the data\n */\nstatic Bool mpeg2ps_stream_read_frame (mpeg2ps_stream_t *sptr,\n                                       u8 **buffer,\n                                       u32 *buflen,\n                                       Bool advance_pointers)\n{\n\t//  Bool done = 0;\n\tif (sptr->is_video) {\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers) {\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\t// would need to handle LPCM here\n\t\tif (mpeg2ps_stream_find_ac3_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers)\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (mpeg2ps_stream_find_mp3_frame(sptr)) {\n\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t*buflen = sptr->frame_len;\n\t\tif (advance_pointers)\n\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * get_info_from_frame - we have a frame, get the info from it.\n */\nstatic void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\t// mpeg audio\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; // give bps, not kbps\n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t\t// PCM - ???\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}\n\n/*\n * clear_stream_buffer - called when we seek to clear out any data in\n * the buffers\n */\nstatic void clear_stream_buffer (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on = sptr->pes_buffer_size = 0;\n\tsptr->frame_len = 0;\n\tsptr->have_frame_loaded = 0;\n\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\tsptr->frame_ts.have_dts = sptr->frame_ts.have_pts = 0;\n}\n\n/*\n * convert_to_msec - convert ts (at 90000) to msec, based on base_ts and\n * frames_since_last_ts.\n */\nstatic u64 convert_ts (mpeg2ps_stream_t *sptr,\n                       mpeg2ps_ts_type_t ts_type,\n                       u64 ts,\n                       u64 base_ts,\n                       u32 frames_since_ts)\n{\n\tu64 ret, calc;\n\tret = ts - base_ts;\n\tif (sptr->is_video) {\n\t\t// video\n\t\tret += frames_since_ts * sptr->ticks_per_frame;\n\t} else if (sptr->freq) {\n\t\t// audio\n\t\tcalc = (frames_since_ts * 90000 * sptr->samples_per_frame) / sptr->freq;\n\t\tret += calc;\n\t}\n\tif (ts_type == TS_MSEC)\n\t\tret /= (u64) (90); // * 1000 / 90000\n\n\treturn ret;\n}\n\n/*\n * find_stream_from_id - given the stream, get the sptr.\n * only used in inital set up, really.  APIs use index into\n * video_streams and audio_streams arrays.\n */\nstatic mpeg2ps_stream_t *find_stream_from_id (mpeg2ps_t *ps,\n        u8 stream_id,\n        u8 substream)\n{\n\tu8 ix;\n\tif (stream_id >= 0xe0) {\n\t\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\t\tif (ps->video_streams[ix]->m_stream_id == stream_id) {\n\t\t\t\treturn ps->video_streams[ix];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\t\tif (ps->audio_streams[ix]->m_stream_id == stream_id &&\n\t\t\t        (stream_id != 0xbd ||\n\t\t\t         substream == ps->audio_streams[ix]->m_substream_id)) {\n\t\t\t\treturn ps->audio_streams[ix];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * add_stream - add a new stream\n */\nstatic Bool add_stream (mpeg2ps_t *ps,\n                        u8 stream_id,\n                        u8 substream,\n                        s64 first_loc,\n                        mpeg2ps_ts_t *ts)\n{\n\tmpeg2ps_stream_t *sptr;\n\n\tsptr = find_stream_from_id(ps, stream_id, substream);\n\tif (sptr != NULL) return 0;\n\n\t// need to add\n\n\tsptr = mpeg2ps_stream_create(stream_id, substream);\n\tsptr->first_pes_loc = first_loc;\n\tif (ts == NULL ||\n\t        (ts->have_dts == 0 && ts->have_pts == 0)) {\n\t\tsptr->first_pes_has_dts = 0;\n\t} else {\n\t\tsptr->start_dts = ts->have_dts ? ts->dts : ts->pts;\n\t\tsptr->first_pes_has_dts = 1;\n\t}\n\tif (sptr->is_video) {\n\t\t// can't be more than 16 - e0 to ef...\n\t\tps->video_streams[ps->video_cnt] = sptr;\n\t\tps->video_cnt++;\n\t} else {\n\t\tif (ps->audio_cnt >= 32) {\n\t\t\tmpeg2ps_stream_destroy(sptr);\n\t\t\treturn 0;\n\t\t}\n\t\tps->audio_streams[ps->audio_cnt] = sptr;\n\t\tps->audio_cnt++;\n\t}\n\treturn 1;\n}\n\nstatic void check_fd_for_stream (mpeg2ps_t *ps,\n                                 mpeg2ps_stream_t *sptr)\n{\n\tif (sptr->m_fd != FDNULL) return;\n\n\tsptr->m_fd = file_open(ps->filename);\n}\n\n/*\n * advance_frame - when we're reading frames, this indicates that we're\n * done.  We will call this when we read a frame, but not when we\n * seek.  It allows us to leave the last frame we're seeking in the\n * buffer\n */\nstatic void advance_frame (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on += sptr->frame_len;\n\tsptr->have_frame_loaded = 0;\n\tif (sptr->frame_ts.have_dts || sptr->frame_ts.have_pts) {\n\t\tif (sptr->frame_ts.have_dts)\n\t\t\tsptr->last_ts = sptr->frame_ts.dts;\n\t\telse\n\t\t\tsptr->last_ts = sptr->frame_ts.pts;\n\t\tsptr->frames_since_last_ts = 0;\n\t} else {\n\t\tsptr->frames_since_last_ts++;\n\t}\n}\n/*\n * get_info_for_all_streams - loop through found streams - read an\n * figure out the info\n */\nstatic void get_info_for_all_streams (mpeg2ps_t *ps)\n{\n\tu8 stream_ix, max_ix, av;\n\tmpeg2ps_stream_t *sptr;\n\tu8 *buffer;\n\tu32 buflen;\n\n\tfile_seek_to(ps->fd, 0);\n\n\t// av will be 0 for video streams, 1 for audio streams\n\t// av is just so I don't have to dup a lot of code that does the\n\t// same thing.\n\tfor (av = 0; av < 2; av++) {\n\t\tif (av == 0) max_ix = ps->video_cnt;\n\t\telse max_ix = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_ix; stream_ix++) {\n\t\t\tif (av == 0) sptr = ps->video_streams[stream_ix];\n\t\t\telse sptr = ps->audio_streams[stream_ix];\n\n\t\t\t// we don't open a separate file descriptor yet (only when they\n\t\t\t// start reading or seeking).  Use the one from the ps.\n\t\t\tsptr->m_fd = ps->fd; // for now\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tif (mpeg2ps_stream_read_frame(sptr,\n\t\t\t                              &buffer,\n\t\t\t                              &buflen,\n\t\t\t                              0) == 0) {\n\t\t\t\tsptr->m_stream_id = 0;\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tget_info_from_frame(sptr, buffer, buflen);\n\t\t\t// here - if (sptr->first_pes_has_dts == 0) should be processed\n\t\t\tif ((sptr->first_pes_has_dts == 0) && sptr->m_fd) {\n\t\t\t\tu32 frames_from_beg = 0;\n\t\t\t\tBool have_frame;\n\t\t\t\tdo {\n\t\t\t\t\tadvance_frame(sptr);\n\t\t\t\t\thave_frame =\n\t\t\t\t\t    mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, 0);\n\t\t\t\t\tframes_from_beg++;\n\t\t\t\t} while (have_frame &&\n\t\t\t\t         sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0 &&\n\t\t\t\t         frames_from_beg < 1000);\n\t\t\t\tif (have_frame == 0 ||\n\t\t\t\t        (sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0)) {\n\t\t\t\t} else {\n\t\t\t\t\tsptr->start_dts = sptr->frame_ts.have_dts ? sptr->frame_ts.dts :\n\t\t\t\t\t                  sptr->frame_ts.pts;\n\t\t\t\t\tif (sptr->is_video) {\n\t\t\t\t\t\tsptr->start_dts -= frames_from_beg * sptr->ticks_per_frame;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu64 conv;\n\t\t\t\t\t\tconv = sptr->samples_per_frame * 90000;\n\t\t\t\t\t\tconv /= (u64)sptr->freq;\n\t\t\t\t\t\tsptr->start_dts -= conv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tsptr->m_fd = FDNULL;\n\t\t}\n\t}\n}\n\n/*\n * mpeg2ps_scan_file - read file, grabbing all the information that\n * we can out of it (what streams exist, timing, etc).\n */\nstatic void mpeg2ps_scan_file (mpeg2ps_t *ps)\n{\n\tu8 stream_id, stream_ix, substream, av_ix, max_cnt;\n\tu16 pes_len, pes_left;\n\tmpeg2ps_ts_t ts;\n\ts64 loc, first_video_loc = 0, first_audio_loc = 0;\n\ts64 check, orig_check;\n\tmpeg2ps_stream_t *sptr;\n\tBool valid_stream;\n\tu8 *buffer;\n\tu32 buflen;\n\tBool have_ts;\n\n\tps->end_loc = file_size(ps->fd);\n\torig_check = check = MAX(ps->end_loc / 50, 200 * 1024);\n\n\t/*\n\t * This part reads and finds the streams.  We check up until we\n\t * find audio and video plus a little, with a max of either 200K or\n\t * the file size / 50\n\t */\n\tloc = 0;\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len) &&\n\t        loc < check) {\n\t\tpes_left = pes_len;\n\t\tif (stream_id >= 0xbd && stream_id < 0xf0) {\n\t\t\tloc = file_location(ps->fd) - 6;\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalid_stream = 0;\n\t\t\tsubstream = 0;\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif ((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0)) {\n\t\t\t\t\tvalid_stream = 1;\n\t\t\t\t}\n\t\t\t} else if (stream_id >= 0xc0) {\n\t\t\t\t// audio and video\n\t\t\t\tvalid_stream = 1;\n\t\t\t}\n\t\t\tif (valid_stream) {\n\t\t\t\tif (add_stream(ps, stream_id, substream, loc, &ts)) {\n\t\t\t\t\t// added\n\t\t\t\t\tif (stream_id >= 0xe0) {\n\t\t\t\t\t\tif (ps->video_cnt == 1) {\n\t\t\t\t\t\t\tfirst_video_loc = loc;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ps->audio_cnt == 1) {\n\t\t\t\t\t\tfirst_audio_loc = loc;\n\t\t\t\t\t}\n\t\t\t\t\tif (ps->audio_cnt > 0 && ps->video_cnt > 0) {\n\t\t\t\t\t\ts64 diff;\n\t\t\t\t\t\tif (first_audio_loc > first_video_loc)\n\t\t\t\t\t\t\tdiff = first_audio_loc - first_video_loc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdiff = first_video_loc - first_audio_loc;\n\t\t\t\t\t\tdiff *= 2;\n\t\t\t\t\t\tdiff += first_video_loc;\n\t\t\t\t\t\tif (diff < check) {\n\t\t\t\t\t\t\tcheck = diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfile_skip_bytes(ps->fd, pes_left);\n\t}\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\treturn;\n\t}\n\t/*\n\t * Now, we go to close to the end, and try to find the last\n\t * dts that we can\n\t */\n\tfile_seek_to(ps->fd, ps->end_loc - orig_check);\n\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len)) {\n\t\tloc = file_location(ps->fd) - 6;\n\t\tif (stream_id == 0xbd || (stream_id >= 0xc0 && stream_id < 0xf0)) {\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif (!((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0))) {\n\t\t\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubstream = 0;\n\t\t\t}\n\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\tif (sptr == NULL) {\n\t\t\t\tadd_stream(ps, stream_id, substream, 0, NULL);\n\t\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\t}\n\t\t\tif (sptr != NULL && have_ts) {\n\t\t\t\tsptr->end_dts = ts.have_dts ? ts.dts : ts.pts;\n\t\t\t\tsptr->end_dts_loc = loc;\n\t\t\t}\n\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t}\n\t}\n\n\t/*\n\t * Now, get the info for all streams, so we can use it again\n\t * we could do this before the above, I suppose\n\t */\n\tget_info_for_all_streams(ps);\n\n\tps->first_dts = (u64) -1;\n\n\t/*\n\t * we need to find the earliest start pts - we use that to calc\n\t * the rest of the timing, so we're 0 based.\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\t\t\tif (sptr != NULL && sptr->start_dts < ps->first_dts) {\n\t\t\t\tps->first_dts = sptr->start_dts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now, for each thread, we'll start at the last pts location, and\n\t * read the number of frames.  This will give us a max time\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tu32 frame_cnt_since_last;\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\n\t\t\t// pick up here - find the final time...\n\t\t\tif (sptr && (sptr->end_dts_loc != 0)) {\n\t\t\t\tfile_seek_to(ps->fd, sptr->end_dts_loc);\n\t\t\t\tsptr->m_fd = ps->fd;\n\t\t\t\tframe_cnt_since_last = 0;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\twhile (mpeg2ps_stream_read_frame(sptr,\n\t\t\t\t                                 &buffer,\n\t\t\t\t                                 &buflen,\n\t\t\t\t                                 1)) {\n\t\t\t\t\tframe_cnt_since_last++;\n\t\t\t\t}\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\tps->max_time = MAX(ps->max_time,\n\t\t\t\t                   convert_ts(sptr,\n\t\t\t\t                              TS_MSEC,\n\t\t\t\t                              sptr->end_dts,\n\t\t\t\t                              ps->first_dts,\n\t\t\t\t                              frame_cnt_since_last));\n\t\t\t}\n\t\t}\n\t}\n\n\tps->max_dts = (ps->max_time * 90) + ps->first_dts;\n\tfile_seek_to(ps->fd, 0);\n}\n\n/*************************************************************************\n * API routines\n *************************************************************************/\nu64 mpeg2ps_get_max_time_msec (mpeg2ps_t *ps)\n{\n\treturn ps->max_time;\n}\n\nu32 mpeg2ps_get_video_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->video_cnt;\n}\n\n#define NUM_ELEMENTS_IN_ARRAY(name) ((sizeof((name))) / (sizeof(*(name))))\n\n// routine to check stream number passed.\nstatic Bool invalid_video_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->video_streams)) return 1;\n\tif (ps->video_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_video_stream_name (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\tif (ps->video_streams[streamno]->have_mpeg2) {\n\t\treturn \"Mpeg-2\";\n\t}\n\treturn \"Mpeg-1\";\n}\n#endif\n\nmpeg2ps_video_type_t mpeg2ps_get_video_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn MPEG_VIDEO_UNKNOWN;\n\t}\n\treturn ps->video_streams[streamno]->have_mpeg2 ? MPEG_VIDEO_MPEG2 : MPEG_VIDEO_MPEG1;\n}\n\nu32 mpeg2ps_get_video_stream_width (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->w;\n}\n\nu32 mpeg2ps_get_video_stream_height (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->h;\n}\n\nu32 mpeg2ps_get_video_stream_aspect_ratio (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->par;\n}\n\nDouble mpeg2ps_get_video_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->bit_rate;\n}\n\nDouble mpeg2ps_get_video_stream_framerate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->frame_rate;\n}\n\nu32 mpeg2ps_get_video_stream_id(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->m_stream_id;\n}\n\nstatic Bool invalid_audio_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->audio_streams)) return 1;\n\tif (ps->audio_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\nu32 mpeg2ps_get_audio_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->audio_cnt;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_audio_stream_name (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn \"none\";\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\tswitch (ps->audio_streams[streamno]->layer) {\n\t\tcase 1:\n\t\t\treturn \"MP1\";\n\t\tcase 2:\n\t\t\treturn \"MP2\";\n\t\tcase 3:\n\t\t\treturn \"MP3\";\n\t\t}\n\t\treturn \"unknown mpeg layer\";\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn \"AC3\";\n\n\treturn \"LPCM\";\n}\n#endif\n\nmpeg2ps_audio_type_t mpeg2ps_get_audio_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn MPEG_AUDIO_UNKNOWN;\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\treturn MPEG_AUDIO_MPEG;\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn MPEG_AUDIO_AC3;\n\n\treturn MPEG_AUDIO_LPCM;\n}\n\nu32 mpeg2ps_get_audio_stream_sample_freq (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->freq;\n}\n\nu32 mpeg2ps_get_audio_stream_channels (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->channels;\n}\n\nu32 mpeg2ps_get_audio_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->bitrate;\n}\n\nu32 mpeg2ps_get_audio_stream_id (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->m_stream_id;\n}\n\n\nmpeg2ps_t *mpeg2ps_init (const char *filename)\n{\n\tmpeg2ps_t *ps;\n\tGF_SAFEALLOC(ps, mpeg2ps_t);\n\n\tif (ps == NULL) {\n\t\treturn NULL;\n\t}\n\tmemset(ps, 0, sizeof(*ps));\n\tps->fd = file_open(filename);\n\tif (file_okay(ps->fd) == 0) {\n\t\tgf_free(ps);\n\t\treturn NULL;\n\t}\n\n\tps->filename = gf_strdup(filename);\n\tmpeg2ps_scan_file(ps);\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\tmpeg2ps_close(ps);\n\t\treturn NULL;\n\t}\n\treturn ps;\n}\n\nvoid mpeg2ps_close (mpeg2ps_t *ps)\n{\n\tu32 ix;\n\tif (ps == NULL) return;\n\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->video_streams[ix]);\n\t\tps->video_streams[ix] = NULL;\n\t}\n\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->audio_streams[ix]);\n\t\tps->audio_streams[ix] = NULL;\n\t}\n\n\tif (ps->filename) gf_free(ps->filename);\n\tif (ps->fd) file_close(ps->fd);\n\tgf_free(ps);\n}\n\n/*\n * check_fd_for_stream will make sure we have a fd for the stream we're\n * trying to read - we use a different fd for each stream\n */\n\n/*\n * stream_convert_frame_ts_to_msec - given a \"read\" frame, we'll\n * calculate the msec and freq timestamps.  This can be called more\n * than 1 time, if needed, without changing any variables, such as\n * frames_since_last_ts, which gets updated in advance_frame\n */\nstatic u64 stream_convert_frame_ts_to_msec (mpeg2ps_stream_t *sptr,\n        mpeg2ps_ts_type_t ts_type,\n        u64 base_dts,\n        u32 *freq_ts)\n{\n\tu64 calc_ts;\n\tu32 frames_since_last = 0;\n\tu64 freq_conv;\n\n\tcalc_ts = sptr->last_ts;\n\tif (sptr->frame_ts.have_dts) calc_ts = sptr->frame_ts.dts;\n\telse if (sptr->frame_ts.have_pts) calc_ts = sptr->frame_ts.dts;\n\telse frames_since_last = sptr->frames_since_last_ts + 1;\n\n\tif (freq_ts != NULL) {\n\t\tfreq_conv = calc_ts - base_dts;\n\t\tfreq_conv *= sptr->freq;\n\t\tfreq_conv /= 90000;\n\t\tfreq_conv += frames_since_last * sptr->samples_per_frame;\n\t\t*freq_ts = (u32) (freq_conv & 0xffffffff);\n\t}\n\treturn convert_ts(sptr, ts_type, calc_ts, base_dts, frames_since_last);\n}\n\n/*\n * mpeg2ps_get_video_frame - gets the next frame\n */\nBool mpeg2ps_get_video_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             u8 *frame_type,\n                             mpeg2ps_ts_type_t ts_type,\n                             u64 *decode_timestamp, u64 *compose_timestamp)\n{\n\tu64 dts, cts;\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->video_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\t// if we don't have the frame in the buffer (like after a seek),\n\t\t// read the next frame\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t*buflen = sptr->frame_len;\n\t// determine frame type\n\tif (frame_type != NULL) {\n\t\t*frame_type = MPEG12_PictHdrType(sptr->pes_buffer +\n\t\t                                 sptr->pict_header_offset);\n\t}\n\n\t// set the timestamps\n\tif (sptr->frame_ts.have_pts)\n\t\tcts = sptr->frame_ts.pts;\n\telse\n\t\tcts = sptr->last_ts + (1+sptr->frames_since_last_ts) * sptr->ticks_per_frame;\n\tif (sptr->frame_ts.have_dts)\n\t\tdts = sptr->frame_ts.dts;\n\telse\n\t\tdts = cts;\n\n\tif (decode_timestamp) *decode_timestamp = dts;\n\tif (compose_timestamp) *compose_timestamp = cts;\n\n\t//indicate that we read this frame - get ready for the next one.\n\tadvance_frame(sptr);\n\n\n\treturn 1;\n}\n\n\n// see above comments\nBool mpeg2ps_get_audio_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             mpeg2ps_ts_type_t ts_type,\n                             u32 *freq_timestamp,\n                             u64 *timestamp)\n{\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->audio_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\tif (mpeg2ps_stream_read_frame(sptr, buffer, buflen, 0) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (freq_timestamp) {\n\t\t/*ts = */stream_convert_frame_ts_to_msec(sptr,\n\t\t                                     ts_type,\n\t\t                                     ps->first_dts,\n\t\t                                     freq_timestamp);\n\t}\n\tif (timestamp != NULL) {\n\t\t*timestamp = sptr->frame_ts.have_pts ? sptr->frame_ts.pts : sptr->frame_ts.dts;\n\t}\n\tadvance_frame(sptr);\n\treturn 1;\n}\n\n#if 0 //unused\nu64 mpeg2ps_get_ps_size(mpeg2ps_t *ps)\n{\n\treturn file_size(ps->fd);\n}\ns64 mpeg2ps_get_video_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->video_streams[streamno]->m_fd);\n}\ns64 mpeg2ps_get_audio_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->audio_streams[streamno]->m_fd);\n}\n#endif\n\n\n/***************************************************************************\n * seek routines\n ***************************************************************************/\n/*\n * mpeg2ps_binary_seek - look for a pts that's close to the one that\n * we're looking for.  We have a start ts and location, an end ts and\n * location, and what we're looking for\n */\nstatic void mpeg2ps_binary_seek (mpeg2ps_t *ps,\n\t\t\t\t mpeg2ps_stream_t *sptr,\n\t\t\t\t u64 search_dts,\n\t\t\t\t u64 start_dts,\n\t\t\t\t u64 start_loc,\n\t\t\t\t u64 end_dts,\n\t\t\t\tu64 end_loc)\n{\n  u64 dts_perc;\n  u64 loc;\n  u16 pes_len;\n  Bool have_ts = GF_FALSE;\n  u64 found_loc;\n  u64 found_dts;\n\n  while (1) {\n    /*\n     * It's not a binary search as much as using a percentage between\n     * the start and end dts to start.  We subtract off a bit, so we\n     * approach from the beginning of the file - we're more likely to\n     * hit a pts that way\n     */\n    dts_perc = (search_dts - start_dts) * 1000 / (end_dts - start_dts);\n    dts_perc -= dts_perc % 10;\n\n    loc = ((end_loc - start_loc) * dts_perc) / 1000;\n\n    if (loc == start_loc || loc == end_loc) return;\n\n    clear_stream_buffer(sptr);\n    file_seek_to(sptr->m_fd, start_loc + loc);\n\n    // we'll look for the next pes header for this stream that has a ts.\n    do {\n      if (search_for_next_pes_header(sptr,\n\t\t\t\t     &pes_len,\n\t\t\t\t     &have_ts,\n\t\t\t\t     &found_loc) == GF_FALSE) {\n\treturn;\n      }\n      if (have_ts == GF_FALSE) {\n\tfile_skip_bytes(sptr->m_fd, pes_len);\n      }\n    } while (have_ts == GF_FALSE);\n\n    // record that spot...\n    mpeg2ps_record_pts(sptr, found_loc, &sptr->next_pes_ts);\n\n    found_dts = sptr->next_pes_ts.have_dts ?\n      sptr->next_pes_ts.dts : sptr->next_pes_ts.pts;\n    /*\n     * Now, if we're before the search ts, and within 5 seconds,\n     * we'll say we're close enough\n     */\n    if (found_dts + (5 * 90000) > search_dts &&\n\tfound_dts < search_dts) {\n      file_seek_to(sptr->m_fd, found_loc);\n      return; // found it - we can seek from here\n    }\n    /*\n     * otherwise, move the head or the tail (most likely the head).\n     */\n    if (found_dts > search_dts) {\n      if (found_dts >= end_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      end_loc = found_loc;\n      end_dts = found_dts;\n    } else {\n      if (found_dts <= start_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      start_loc = found_loc;\n      start_dts = found_dts;\n    }\n  }\n}\n\n\n\nstatic mpeg2ps_record_pes_t *search_for_ts (mpeg2ps_stream_t *sptr,\n\t\t\t\t     u64 dts)\n{\n  mpeg2ps_record_pes_t *p, *q;\n  u64 p_diff, q_diff;\n  if (sptr->record_last == NULL) return NULL;\n\n  if (dts > sptr->record_last->dts) return sptr->record_last;\n\n  if (dts < sptr->record_first->dts) return NULL;\n  if (dts == sptr->record_first->dts) return sptr->record_first;\n\n  p = sptr->record_first;\n  q = p->next_rec;\n\n  while (q != NULL && q->dts > dts) {\n    p = q;\n    q = q->next_rec;\n  }\n  if (q == NULL) {\n    return sptr->record_last;\n  }\n\n  p_diff = dts - p->dts;\n  q_diff = q->dts - dts;\n\n  if (p_diff < q_diff) return p;\n  if (q_diff > 90000) return p;\n\n  return q;\n}\n\n\n/*\n * mpeg2ps_seek_frame - seek to the next timestamp after the search timestamp\n * First, find a close DTS (usually minus 5 seconds or closer), then\n * read frames until we get the frame after the timestamp.\n */\nstatic Bool mpeg2ps_seek_frame (mpeg2ps_t *ps,\n\t\t\t\tmpeg2ps_stream_t *sptr,\n\t\t\t\tu64 search_msec_timestamp)\n{\n  u64 dts;\n  mpeg2ps_record_pes_t *rec;\n  u64 msec_ts;\n  u8 *buffer;\n  u32 buflen;\n\n  check_fd_for_stream(ps, sptr);\n  clear_stream_buffer(sptr);\n\n  if (search_msec_timestamp <= 1000) { // first second, start from begin...\n    file_seek_to(sptr->m_fd, sptr->first_pes_loc);\n    return GF_TRUE;\n  }\n  dts = search_msec_timestamp * 90; // 1000 timescale to 90000 timescale\n  dts += ps->first_dts;\n\n  /*\n   * see if the recorded data has anything close\n   */\n  rec = search_for_ts(sptr, dts);\n  if (rec != NULL) {\n    // see if it is close\n    // if we're plus or minus a second, seek to that.\n    if (rec->dts + 90000 >= dts && rec->dts <= dts + 90000) {\n      file_seek_to(sptr->m_fd, rec->location);\n      return GF_TRUE;\n    }\n    // at this point, rec is > a distance.  If within 5 or so seconds,\n\n    if (rec->dts + (5 * 90000) < dts) {\n      // more than 5 seconds away - skip and search\n      if (rec->next_rec == NULL) {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    sptr->end_dts, sptr->end_dts_loc);\n      } else {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    rec->next_rec->dts, rec->next_rec->location);\n      }\n    }\n    // otherwise, frame by frame search...\n  } else {\n    // we weren't able to find anything from the recording\n    mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\tsptr->start_dts, sptr->first_pes_loc,\n\t\t\tsptr->end_dts, sptr->end_dts_loc);\n  }\n  /*\n   * Now, the fun part - read frames until we're just past the time\n   */\n  clear_stream_buffer(sptr); // clear out any data, so we can read it\n  do {\n    if (mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, GF_FALSE) == GF_FALSE)\n      return GF_FALSE;\n\n    msec_ts = stream_convert_frame_ts_to_msec(sptr, TS_MSEC,\n\t\t\t\t\t      ps->first_dts, NULL);\n\n    if (msec_ts < search_msec_timestamp) {\n      // only advance the frame if we're not greater than the timestamp\n      advance_frame(sptr);\n    }\n  } while (msec_ts < search_msec_timestamp);\n\n  return GF_TRUE;\n}\n\n\n/*\n * mpeg2ps_seek_video_frame - seek to the location that we're interested\n * in, then scroll up to the next I frame\n */\nBool mpeg2ps_seek_video_frame (mpeg2ps_t *ps, u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_video_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->video_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp)\n\t\t\t  == GF_FALSE) return GF_FALSE;\n\n  if (sptr->have_frame_loaded == GF_FALSE) {\n    return GF_FALSE;\n  }\n  return GF_TRUE;\n}\n/*\n * mpeg2ps_seek_audio_frame - go to the closest audio frame after the\n * timestamp\n */\nBool mpeg2ps_seek_audio_frame (mpeg2ps_t *ps,\n\t\t\t       u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  //  off_t closest_pes;\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_audio_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->audio_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp) == GF_FALSE) return GF_FALSE;\n\n  return GF_TRUE;\n}\n\nu64 mpeg2ps_get_first_cts(mpeg2ps_t *ps)\n{\n\treturn ps->first_dts;\n}\n\n\n#endif /*GPAC_DISABLE_MPEG2PS*/\n"], "filenames": ["src/media_tools/mpeg2_ps.c"], "buggy_code_start_loc": [268], "buggy_code_end_loc": [268], "fixing_code_start_loc": [269], "fixing_code_end_loc": [271], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2023-4721", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-01T16:15:08.660", "lastModified": "2023-09-06T00:15:28.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV."}, {"lang": "es", "value": "Lectura fuera de l\u00edmites en el repositorio de GitHub gpac/gpac anterior a 2.3-DEV.  "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3-dev", "matchCriteriaId": "F76B0068-AE98-4B7C-885D-B083842F6521"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/3ec93d73d048ed7b46fe6e9f307cc7a0cc13db63", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/f457dc62-3cff-47bd-8fd2-1cb2b4a832fc", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/3ec93d73d048ed7b46fe6e9f307cc7a0cc13db63"}}