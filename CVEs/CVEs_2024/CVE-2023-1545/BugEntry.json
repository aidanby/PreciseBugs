{"buggy_code": ["<?php\n/**\n * Teampass - a collaborative passwords manager.\n * ---\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * ---\n *\n * @project   Teampass\n * @version    API\n *\n * @file      AuthModel.php\n * ---\n *\n * @author    Nils Laumaill\u00e9 (nils@teampass.net)\n *\n * @copyright 2009-2023 Teampass.net\n *\n * @license   https://spdx.org/licenses/GPL-3.0-only.html#licenseText GPL-3.0\n * ---\n *\n * @see       https://www.teampass.net\n */\n\n\nrequire_once API_ROOT_PATH . \"/Model/Database.php\";\n\n\nclass AuthModel extends Database\n{\n\n\n    /**\n     * Is the user allowed\n     *\n     * @param string $login\n     * @param string $password\n     * @param string $apikey\n     * @return array\n     */\n    public function getUserAuth(string $login, string $password, string $apikey): array\n    {\n        // Check if user exists\n        $userInfoRes = $this->select(\"SELECT id, pw, public_key, private_key, personal_folder, fonction_id, groupes_visibles, groupes_interdits, user_api_key FROM \" . prefixTable('users') . \" WHERE login='\".$login.\"'\");\n        $userInfoRes[0]['special'] = '';\n        $userInfo = $userInfoRes[0];\n        \n        // Check password\n        include_once API_ROOT_PATH . '/../sources/SplClassLoader.php';\n        $pwdlib = new SplClassLoader('PasswordLib', API_ROOT_PATH . '/../includes/libraries');\n        $pwdlib->register();\n        $pwdlib = new PasswordLib\\PasswordLib();\n        if ($pwdlib->verifyPasswordHash($password, $userInfo['pw']) === true) {\n            // Correct credentials\n            // Now check apikey\n            // We check if it is the correct user api or if it is a generic api key\n            $apiInfo = $this->select(\"SELECT count(*) FROM \" . prefixTable('api') . \" WHERE value='\".$apikey.\"'\");\n            if ($apikey === $userInfo['user_api_key'] || (int) $apiInfo[0]['count(*)'] === 1) {\n                // get user keys\n                $privateKeyClear = decryptPrivateKey($password, (string) $userInfo['private_key']); //prepareUserEncryptionKeys($userInfo, $password);\n\n                // get user folders list\n                $folders = $this->buildUserFoldersList($userInfo);\n\n                // create JWT\n                return $this->createUserJWT(\n                    $userInfo['id'],\n                    $login,\n                    $userInfo['personal_folder'],\n                    $userInfo['public_key'],\n                    $privateKeyClear,\n                    implode(\",\", $folders)\n                );\n            } else {\n                return [\"error\" => \"Login failed.\", \"apikey\" => \"Not valid\"];\n            }\n        } else {\n            return [\"error\" => \"Login failed.\", \"password\" => $password];\n        }\n    }\n    //end getUserAuth\n\n    /**\n     * Create a JWT\n     *\n     * @param integer $id\n     * @param string $login\n     * @param integer $pf_enabled\n     * @param string $pubkey\n     * @param string $privkey\n     * @param string $folders\n     * @return array\n     */\n    private function createUserJWT(int $id, string $login, int $pf_enabled, string $pubkey, string $privkey, string $folders): array\n    {\n        require API_ROOT_PATH . '/../includes/config/tp.config.php';\n        $headers = ['alg'=>'HS256','typ'=>'JWT'];\n\t\t$payload = [\n            'username' => $login,\n            'id' => $id, \n            'exp' => (time() + $SETTINGS['api_token_duration'] + 600),\n            'public_key' => $pubkey,\n            'private_key' => $privkey,\n            'pf_enabled' => $pf_enabled,\n            'folders_list' => $folders,\n        ];\n\n        include_once API_ROOT_PATH . '/inc/jwt_utils.php';\n\t\treturn ['token' => generate_jwt($headers, $payload)];\n    }\n\n    //end createUserJWT\n\n\n    /**\n     * Permit to build the list of folders the user can access\n     *\n     * @param array $userInfo\n     * @return array\n     */\n    private function buildUserFoldersList(array $userInfo): array\n    {\n        //Build tree\n        $tree = new SplClassLoader('Tree\\NestedTree', API_ROOT_PATH . '/../includes/libraries');\n        $tree->register();\n        $tree = new Tree\\NestedTree\\NestedTree(prefixTable('nested_tree'), 'id', 'parent_id', 'title');\n        \n        // Start by adding the manually added folders\n        $allowedFolders = explode(\";\", $userInfo['groupes_visibles']);\n        $readOnlyFolders = [];\n        $allowedFoldersByRoles = [];\n        $restrictedFoldersForItems = [];\n        $foldersLimited = [];\n        $foldersLimitedFull = [];\n        $personalFolders = [];\n\n        $userFunctionId = str_replace(\";\", \",\", $userInfo['fonction_id']);\n\n        // Get folders from the roles\n        if (empty($userFunctionId) === false) {\n            $rows = $this->select(\"SELECT * FROM \" . prefixTable('roles_values') . \" WHERE role_id IN (\".$userFunctionId.\") AND type IN ('W', 'ND', 'NE', 'NDNE', 'R')\");\n            foreach ($rows as $record) {\n                if ($record['type'] === 'R') {\n                    array_push($readOnlyFolders, $record['folder_id']);\n                } elseif (in_array($record['folder_id'], $allowedFolders) === false) {\n                    array_push($allowedFoldersByRoles, $record['folder_id']);\n                }\n            }\n            $allowedFoldersByRoles = array_unique($allowedFoldersByRoles);\n            $readOnlyFolders = array_unique($readOnlyFolders);\n            // Clean arrays\n            foreach ($allowedFoldersByRoles as $value) {\n                $key = array_search($value, $readOnlyFolders);\n                if ($key !== false) {\n                    unset($readOnlyFolders[$key]);\n                }\n            }\n        }\n        \n        // Does this user is allowed to see other items\n        $inc = 0;\n        $rows = $this->select(\"SELECT id, id_tree FROM \" . prefixTable('items') . \" WHERE restricted_to LIKE '\".$userInfo['id'].\"'\".\n            (empty($userFunctionId) === false ? ' AND id_tree NOT IN ('.$userFunctionId.')' : ''));\n        foreach ($rows as $record) {\n            // Exclude restriction on item if folder is fully accessible\n            $restrictedFoldersForItems[$record['id_tree']][$inc] = $record['id'];\n            ++$inc;\n        }\n\n        // Check for the users roles if some specific rights exist on items\n        $rows = $this->select(\"SELECT i.id_tree, r.item_id\n            FROM \" . prefixTable('items') . \" as i\n            INNER JOIN \" . prefixTable('restriction_to_roles') . \" as r ON (r.item_id=i.id)\n            WHERE \".(empty($userFunctionId) === false ? ' id_tree NOT IN ('.$userFunctionId.') AND ' : '').\" i.id_tree != ''\n            ORDER BY i.id_tree ASC\");\n        foreach ($rows as $record) {\n            $foldersLimited[$record['id_tree']][$inc] = $record['item_id'];\n            array_push($foldersLimitedFull, $record['item_id']);\n            ++$inc;\n        }\n\n        // Add all personal folders\n        $rows = $this->select(\n            'SELECT id\n            FROM ' . prefixTable('nested_tree') . '\n            WHERE title = '.$userInfo['id'].' AND personal_folder = 1'.\n            (empty($userFunctionId) === false ? ' AND id NOT IN ('.$userFunctionId.')' : '').\n            ' LIMIT 0,1'\n        );\n        if (empty($rows['id']) === false) {\n            array_push($personalFolders, $rows['id']);\n            // get all descendants\n            $ids = $tree->getDescendants($rows['id'], false, false, true);\n            foreach ($ids as $id) {\n                array_push($personalFolders, $id);\n            }\n        }\n\n        // All folders visibles\n        return array_unique(\n            array_filter(\n                array_merge(\n                    $allowedFolders,\n                    $foldersLimitedFull,\n                    $allowedFoldersByRoles,\n                    $restrictedFoldersForItems,\n                    $readOnlyFolders,\n                    $personalFolders\n                )\n            )\n        );\n    }\n    //end buildUserFoldersList\n}"], "fixing_code": ["<?php\n/**\n * Teampass - a collaborative passwords manager.\n * ---\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * ---\n *\n * @project   Teampass\n * @version    API\n *\n * @file      AuthModel.php\n * ---\n *\n * @author    Nils Laumaill\u00e9 (nils@teampass.net)\n *\n * @copyright 2009-2023 Teampass.net\n *\n * @license   https://spdx.org/licenses/GPL-3.0-only.html#licenseText GPL-3.0\n * ---\n *\n * @see       https://www.teampass.net\n */\n\n\nrequire_once API_ROOT_PATH . \"/Model/Database.php\";\n\n\nclass AuthModel extends Database\n{\n\n\n    /**\n     * Is the user allowed\n     *\n     * @param string $login\n     * @param string $password\n     * @param string $apikey\n     * @return array\n     */\n    public function getUserAuth(string $login, string $password, string $apikey): array\n    {\n        // Sanitize\n        include_once API_ROOT_PATH . '/../sources/main.functions.php';\n        $inputData = dataSanitizer(\n            [\n                'login' => isset($login) === true ? $login : '',\n                'password' => isset($password) === true ? $password : '',\n                'apikey' => isset($apikey) === true ? $apikey : '',\n            ],\n            [\n                'login' => 'trim|escape',\n                'password' => 'trim|escape',\n                'apikey' => 'trim|escape',\n            ],\n            API_ROOT_PATH . '/..'\n        );\n        if (empty($inputData['login']) === true || empty($inputData['apikey']) === true) {\n            return [\"error\" => \"Login failed.\"];\n        }\n        \n        // Check apikey\n        if (empty($inputData['password']) === true) {\n            // case where it is a generic key\n            $apiInfo = $this->select(\"SELECT count(*) FROM \" . prefixTable('api') . \" WHERE value='\".$inputData['apikey'].\"' AND label='\".$inputData['login'].\"'\");\n            if ((int) $apiInfo[0]['count(*)'] === 0) {\n                return [\"error\" => \"Login failed.\", \"apikey\" => \"Not valid\"];\n            }\n\n            return [\"error\" => \"Not managed.\"];\n        } else {\n            // case where it is a user api key\n            $apiInfo = $this->select(\"SELECT count(*) FROM \" . prefixTable('users') . \" WHERE user_api_key='\".$inputData['apikey'].\"' AND login='\".$inputData['login'].\"'\");\n            if ((int) $apiInfo[0]['count(*)'] === 0) {\n                return [\"error\" => \"Login failed.\", \"apikey\" => \"Not valid\"];\n            }\n\n            // Check if user exists\n            $userInfoRes = $this->select(\"SELECT id, pw, public_key, private_key, personal_folder, fonction_id, groupes_visibles, groupes_interdits, user_api_key FROM \" . prefixTable('users') . \" WHERE login='\".$inputData['login'].\"'\");\n            $userInfoRes[0]['special'] = '';\n            $userInfo = $userInfoRes[0];\n            \n            // Check password\n            include_once API_ROOT_PATH . '/../sources/SplClassLoader.php';\n            $pwdlib = new SplClassLoader('PasswordLib', API_ROOT_PATH . '/../includes/libraries');\n            $pwdlib->register();\n            $pwdlib = new PasswordLib\\PasswordLib();\n            if ($pwdlib->verifyPasswordHash($inputData['password'], $userInfo['pw']) === true) {\n                // Correct credentials\n                // get user keys\n                $privateKeyClear = decryptPrivateKey($inputData['password'], (string) $userInfo['private_key']);\n\n                // get user folders list\n                $folders = $this->buildUserFoldersList($userInfo);\n\n                // create JWT\n                return $this->createUserJWT(\n                    $userInfo['id'],\n                    $inputData['login'],\n                    $userInfo['personal_folder'],\n                    $userInfo['public_key'],\n                    $privateKeyClear,\n                    implode(\",\", $folders)\n                );\n            } else {\n                return [\"error\" => \"Login failed.\", \"password\" => \"Not valid\"];\n            }\n        }\n    }\n    //end getUserAuth\n\n    /**\n     * Create a JWT\n     *\n     * @param integer $id\n     * @param string $login\n     * @param integer $pf_enabled\n     * @param string $pubkey\n     * @param string $privkey\n     * @param string $folders\n     * @return array\n     */\n    private function createUserJWT(int $id, string $login, int $pf_enabled, string $pubkey, string $privkey, string $folders): array\n    {\n        require API_ROOT_PATH . '/../includes/config/tp.config.php';\n        $headers = ['alg'=>'HS256','typ'=>'JWT'];\n\t\t$payload = [\n            'username' => $login,\n            'id' => $id, \n            'exp' => (time() + $SETTINGS['api_token_duration'] + 600),\n            'public_key' => $pubkey,\n            'private_key' => $privkey,\n            'pf_enabled' => $pf_enabled,\n            'folders_list' => $folders,\n        ];\n\n        include_once API_ROOT_PATH . '/inc/jwt_utils.php';\n\t\treturn ['token' => generate_jwt($headers, $payload)];\n    }\n\n    //end createUserJWT\n\n\n    /**\n     * Permit to build the list of folders the user can access\n     *\n     * @param array $userInfo\n     * @return array\n     */\n    private function buildUserFoldersList(array $userInfo): array\n    {\n        //Build tree\n        $tree = new SplClassLoader('Tree\\NestedTree', API_ROOT_PATH . '/../includes/libraries');\n        $tree->register();\n        $tree = new Tree\\NestedTree\\NestedTree(prefixTable('nested_tree'), 'id', 'parent_id', 'title');\n        \n        // Start by adding the manually added folders\n        $allowedFolders = explode(\";\", $userInfo['groupes_visibles']);\n        $readOnlyFolders = [];\n        $allowedFoldersByRoles = [];\n        $restrictedFoldersForItems = [];\n        $foldersLimited = [];\n        $foldersLimitedFull = [];\n        $personalFolders = [];\n\n        $userFunctionId = str_replace(\";\", \",\", $userInfo['fonction_id']);\n\n        // Get folders from the roles\n        if (empty($userFunctionId) === false) {\n            $rows = $this->select(\"SELECT * FROM \" . prefixTable('roles_values') . \" WHERE role_id IN (\".$userFunctionId.\") AND type IN ('W', 'ND', 'NE', 'NDNE', 'R')\");\n            foreach ($rows as $record) {\n                if ($record['type'] === 'R') {\n                    array_push($readOnlyFolders, $record['folder_id']);\n                } elseif (in_array($record['folder_id'], $allowedFolders) === false) {\n                    array_push($allowedFoldersByRoles, $record['folder_id']);\n                }\n            }\n            $allowedFoldersByRoles = array_unique($allowedFoldersByRoles);\n            $readOnlyFolders = array_unique($readOnlyFolders);\n            // Clean arrays\n            foreach ($allowedFoldersByRoles as $value) {\n                $key = array_search($value, $readOnlyFolders);\n                if ($key !== false) {\n                    unset($readOnlyFolders[$key]);\n                }\n            }\n        }\n        \n        // Does this user is allowed to see other items\n        $inc = 0;\n        $rows = $this->select(\"SELECT id, id_tree FROM \" . prefixTable('items') . \" WHERE restricted_to LIKE '\".$userInfo['id'].\"'\".\n            (empty($userFunctionId) === false ? ' AND id_tree NOT IN ('.$userFunctionId.')' : ''));\n        foreach ($rows as $record) {\n            // Exclude restriction on item if folder is fully accessible\n            $restrictedFoldersForItems[$record['id_tree']][$inc] = $record['id'];\n            ++$inc;\n        }\n\n        // Check for the users roles if some specific rights exist on items\n        $rows = $this->select(\"SELECT i.id_tree, r.item_id\n            FROM \" . prefixTable('items') . \" as i\n            INNER JOIN \" . prefixTable('restriction_to_roles') . \" as r ON (r.item_id=i.id)\n            WHERE \".(empty($userFunctionId) === false ? ' id_tree NOT IN ('.$userFunctionId.') AND ' : '').\" i.id_tree != ''\n            ORDER BY i.id_tree ASC\");\n        foreach ($rows as $record) {\n            $foldersLimited[$record['id_tree']][$inc] = $record['item_id'];\n            array_push($foldersLimitedFull, $record['item_id']);\n            ++$inc;\n        }\n\n        // Add all personal folders\n        $rows = $this->select(\n            'SELECT id\n            FROM ' . prefixTable('nested_tree') . '\n            WHERE title = '.$userInfo['id'].' AND personal_folder = 1'.\n            (empty($userFunctionId) === false ? ' AND id NOT IN ('.$userFunctionId.')' : '').\n            ' LIMIT 0,1'\n        );\n        if (empty($rows['id']) === false) {\n            array_push($personalFolders, $rows['id']);\n            // get all descendants\n            $ids = $tree->getDescendants($rows['id'], false, false, true);\n            foreach ($ids as $id) {\n                array_push($personalFolders, $id);\n            }\n        }\n\n        // All folders visibles\n        return array_unique(\n            array_filter(\n                array_merge(\n                    $allowedFolders,\n                    $foldersLimitedFull,\n                    $allowedFoldersByRoles,\n                    $restrictedFoldersForItems,\n                    $readOnlyFolders,\n                    $personalFolders\n                )\n            )\n        );\n    }\n    //end buildUserFoldersList\n}"], "filenames": ["api/Model/AuthModel.php"], "buggy_code_start_loc": [44], "buggy_code_end_loc": [80], "fixing_code_start_loc": [44], "fixing_code_end_loc": [109], "type": "CWE-89", "message": "SQL Injection in GitHub repository nilsteampassnet/teampass prior to 3.0.0.23.", "other": {"cve": {"id": "CVE-2023-1545", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-21T11:15:10.453", "lastModified": "2023-03-24T03:31:20.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL Injection in GitHub repository nilsteampassnet/teampass prior to 3.0.0.23."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teampass:teampass:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.0.23", "matchCriteriaId": "764C6217-B0DC-46BE-8785-63C62947781F"}]}]}], "references": [{"url": "https://github.com/nilsteampassnet/teampass/commit/4780252fdb600ef2ec2758f17a37d738570cbe66", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/942c015f-7486-49b1-94ae-b1538d812bc2", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nilsteampassnet/teampass/commit/4780252fdb600ef2ec2758f17a37d738570cbe66"}}