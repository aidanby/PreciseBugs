{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2006-2019\n *\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid ilst_box_del(GF_Box *s)\n{\n\tGF_ItemListBox *ptr = (GF_ItemListBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err ilst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a;\n\tGF_ItemListBox *ptr = (GF_ItemListBox *)s;\n\twhile (ptr->size) {\n\t\t/*if no ilst type coded, break*/\n\t\tsub_type = gf_bs_peek_bits(bs, 32, 0);\n\t\tif (sub_type) {\n\t\t\te = gf_isom_box_parse_ex(&a, bs, s->type, GF_FALSE);\n\n\t\t\t/* the macro will return in this case before we can free */\n\t\t\tif (!e && ptr->size < a->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tif (a) gf_isom_box_del(a);\n\t\t\t\treturn e;\n\t\t\t}\n\n\t\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\t\t\tgf_list_add(ptr->child_boxes, a);\n\t\t} else {\n\t\t\tgf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ilst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemListBox, GF_ISOM_BOX_TYPE_ILST);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ilst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n//\tGF_ItemListBox *ptr = (GF_ItemListBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn GF_OK;\n}\n\n\nGF_Err ilst_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ilst_item_box_del(GF_Box *s)\n{\n\tGF_ListItemBox *ptr = (GF_ListItemBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\tgf_list_add(ptr->child_boxes, ptr->data);\n\t\t} else {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tu64 prev_size = s->size;\n\t\t/*try parsing as generic box list*/\n\t\te = gf_isom_box_array_read(s, bs, NULL);\n\t\tif (e==GF_OK) return GF_OK;\n\t\t//reset content and retry - this deletes ptr->data !!\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t\tgf_bs_seek(bs, pos);\n\t\ts->size = prev_size;\n\n\t\tptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t//nope, check qt-style\n\t\tptr->data->qt_style = GF_TRUE;\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ilst_item_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ListItemBox, GF_ISOM_BOX_TYPE_CPIL); //type will be overwrite\n\ttmp->data = (GF_DataBox *)gf_isom_box_new_parent(&tmp->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (tmp->data == NULL) {\n\t\tif (tmp->child_boxes) gf_list_del(tmp->child_boxes);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ilst_item_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t/*generic box list*/\n\tif (ptr->child_boxes && !ptr->data) {\n\t}\n\t/*iTune way: data-box-encapsulated box list*/\n\telse if (!ptr->data->qt_style) {\n\t}\n\t/*QT way: raw data*/\n\telse {\n\t\tgf_bs_write_u16(bs, ptr->data->dataSize);\n\t\tgf_bs_write_u16(bs, 0);\n\t\tgf_bs_write_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->size = 0; //abort\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ilst_item_box_size(GF_Box *s)\n{\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\n\t/*generic box list*/\n\tif (ptr->child_boxes && !ptr->data) {\n\t}\n\t/*iTune way: data-box-encapsulated box list*/\n\telse if (ptr->data && !ptr->data->qt_style) {\n\t\tu32 pos=0;\n\t\tgf_isom_check_position(s, (GF_Box* ) ptr->data, &pos);\n\t}\n\t/*QT way: raw data*/\n\telse if (ptr->data) {\n\t\tptr->size += ptr->data->dataSize + 4;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid databox_box_del(GF_Box *s)\n{\n\tGF_DataBox *ptr = (GF_DataBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->data)\n\t\tgf_free(ptr->data);\n\tgf_free(ptr);\n\n}\n\nGF_Err databox_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_DataBox *ptr = (GF_DataBox *)s;\n\n\tptr->reserved = gf_bs_read_int(bs, 32);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->size) {\n\t\tptr->dataSize = (u32) ptr->size;\n\t\tptr->data = (char*)gf_malloc(ptr->dataSize * sizeof(ptr->data[0]) + 1);\n\t\tif (ptr->data == NULL) return GF_OUT_OF_MEM;\n\t\tptr->data[ptr->dataSize] = 0;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *databox_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataBox, GF_ISOM_BOX_TYPE_DATA);\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err databox_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataBox *ptr = (GF_DataBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 32);\n\tif(ptr->data != NULL && ptr->dataSize > 0) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err databox_box_size(GF_Box *s)\n{\n\tGF_DataBox *ptr = (GF_DataBox *)s;\n\n\tptr->size += 4;\n\tif(ptr->data != NULL && ptr->dataSize > 0) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid alis_box_del(GF_Box *s)\n{\n\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err alis_box_read(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\treturn GF_OK;\n}\n\nGF_Box *alis_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryAliasBox, GF_QT_BOX_TYPE_ALIS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err alis_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n//\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}\n\nGF_Err alis_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid wide_box_del(GF_Box *s)\n{\n\tif (s == NULL) return;\n\tgf_free(s);\n}\n\n\nGF_Err wide_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_skip_bytes(bs, s->size);\n\ts->size = 0;\n\treturn GF_OK;\n}\n\nGF_Box *wide_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_WideBox, GF_QT_BOX_TYPE_WIDE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err wide_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}\n\nGF_Err wide_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_MetaBox *gf_isom_apple_get_meta_extensions(GF_ISOFile *mov)\n{\n\tu32 i;\n\tGF_MetaBox *meta;\n\tGF_UserDataMap *map;\n\n\tif (!mov || !mov->moov) return NULL;\n\n\tif (!mov->moov->udta) return NULL;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_META, NULL);\n\tif (!map) return NULL;\n\n\tfor(i = 0; i < gf_list_count(map->boxes); i++) {\n\t\tmeta = (GF_MetaBox*)gf_list_get(map->boxes, i);\n\n\t\tif(meta != NULL && meta->handler != NULL && meta->handler->handlerType == GF_ISOM_HANDLER_TYPE_MDIR) return meta;\n\t}\n\n\treturn NULL;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_MetaBox *gf_isom_apple_create_meta_extensions(GF_ISOFile *mov)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MetaBox *meta;\n\tGF_UserDataMap *map;\n\n\tif (!mov || !mov->moov) return NULL;\n\n\tif (!mov->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)mov->moov, gf_isom_box_new_parent(&mov->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return NULL;\n\t}\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_META, NULL);\n\tif (map) {\n\t\tfor(i = 0; i < gf_list_count(map->boxes); i++) {\n\t\t\tmeta = (GF_MetaBox*)gf_list_get(map->boxes, i);\n\n\t\t\tif(meta != NULL && meta->handler != NULL && meta->handler->handlerType == GF_ISOM_HANDLER_TYPE_MDIR) return meta;\n\t\t}\n\t}\n\n\t//udta handles children boxes through maps\n\tmeta = (GF_MetaBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_META);\n\n\tif(meta != NULL) {\n\t\tmeta->handler = (GF_HandlerBox *)gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_HDLR);\n\t\tif(meta->handler == NULL) {\n\t\t\tgf_isom_box_del((GF_Box *)meta);\n\t\t\treturn NULL;\n\t\t}\n\t\tmeta->handler->handlerType = GF_ISOM_HANDLER_TYPE_MDIR;\n\t\tgf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t\tudta_on_child_box((GF_Box *)mov->moov->udta, (GF_Box *)meta);\n\t}\n\n\treturn meta;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gmin_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err gmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_GenericMediaHeaderInfoBox *ptr = (GF_GenericMediaHeaderInfoBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->graphics_mode = gf_bs_read_u16(bs);\n\tptr->op_color_red = gf_bs_read_u16(bs);\n\tptr->op_color_green = gf_bs_read_u16(bs);\n\tptr->op_color_blue = gf_bs_read_u16(bs);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *gmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericMediaHeaderInfoBox, GF_QT_BOX_TYPE_GMIN);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericMediaHeaderInfoBox *ptr = (GF_GenericMediaHeaderInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->graphics_mode);\n\tgf_bs_write_u16(bs, ptr->op_color_red);\n\tgf_bs_write_u16(bs, ptr->op_color_green);\n\tgf_bs_write_u16(bs, ptr->op_color_blue);\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err gmin_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid clef_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err clef_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ApertureBox *ptr = (GF_ApertureBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *clef_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ApertureBox, GF_QT_BOX_TYPE_CLEF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clef_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ApertureBox *ptr = (GF_ApertureBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err clef_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tmcd_box_del(GF_Box *s)\n{\n\tif (s == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\n\nGF_Err tmcd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeCodeSampleEntryBox *ptr = (GF_TimeCodeSampleEntryBox *)s;\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(s, 26);\n\tgf_bs_read_u32(bs); //reserved\n\tptr->flags = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\tptr->frame_duration = gf_bs_read_u32(bs);\n\tptr->frames_per_sec = gf_bs_read_u8(bs);\n\tgf_bs_read_u8(bs); //reserved\n\n\treturn gf_isom_box_array_read(s, bs, NULL);\n}\n\nGF_Box *tmcd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeCodeSampleEntryBox, GF_QT_BOX_TYPE_TMCD);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tmcd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeCodeSampleEntryBox *ptr = (GF_TimeCodeSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tgf_bs_write_u32(bs, 0); //reserved\n\tgf_bs_write_u32(bs, ptr->flags);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tgf_bs_write_u32(bs, ptr->frame_duration);\n\tgf_bs_write_u8(bs, ptr->frames_per_sec);\n\tgf_bs_write_u8(bs, 0); //reserved\n\n\treturn GF_OK;\n}\n\nGF_Err tmcd_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8 + 18;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tcmi_box_del(GF_Box *s)\n{\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\tif (ptr->font) gf_free(ptr->font);\n\tgf_free(s);\n}\n\n\nGF_Err tcmi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 21);\n\n\tptr->text_font = gf_bs_read_u16(bs);\n\tptr->text_face = gf_bs_read_u16(bs);\n\tptr->text_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u16(bs);\n\tptr->text_color_red = gf_bs_read_u16(bs);\n\tptr->text_color_green = gf_bs_read_u16(bs);\n\tptr->text_color_blue = gf_bs_read_u16(bs);\n\tptr->back_color_red = gf_bs_read_u16(bs);\n\tptr->back_color_green = gf_bs_read_u16(bs);\n\tptr->back_color_blue = gf_bs_read_u16(bs);\n\tlen = gf_bs_read_u8(bs);\n\tif (len > ptr->size)\n\t\tlen = (u32) ptr->size;\n\tif (len) {\n\t\tptr->font = gf_malloc(len+1);\n\t\tgf_bs_read_data(bs, ptr->font, len);\n\t\tptr->size -= len;\n\t\tptr->font[len]=0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tcmi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeCodeMediaInformationBox, GF_QT_BOX_TYPE_TMCD);\n\ttmp->text_size = 12;\n\ttmp->text_color_red = 0xFFFF;\n\ttmp->text_color_green = 0xFFFF;\n\ttmp->text_color_blue = 0xFFFF;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tcmi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->text_font);\n\tgf_bs_write_u16(bs, ptr->text_face);\n\tgf_bs_write_u16(bs, ptr->text_size);\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->text_color_red);\n\tgf_bs_write_u16(bs, ptr->text_color_green);\n\tgf_bs_write_u16(bs, ptr->text_color_blue);\n\tgf_bs_write_u16(bs, ptr->back_color_red);\n\tgf_bs_write_u16(bs, ptr->back_color_green);\n\tgf_bs_write_u16(bs, ptr->back_color_blue);\n\tlen = ptr->font ? (u32) strlen(ptr->font) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (ptr->font)\n\t\tgf_bs_write_data(bs, ptr->font, len);\n\n\treturn GF_OK;\n}\n\nGF_Err tcmi_box_size(GF_Box *s)\n{\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\tptr->size += 21;\n\tif (ptr->font)\n    \tptr->size += strlen(ptr->font);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid fiel_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err fiel_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_FieldInfoBox *ptr = (GF_FieldInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 2);\n\n    ptr->field_count = gf_bs_read_u8(bs);\n    ptr->field_order = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *fiel_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FieldInfoBox, GF_QT_BOX_TYPE_FIEL);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiel_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FieldInfoBox *ptr = (GF_FieldInfoBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->field_count);\n\tgf_bs_write_u8(bs, ptr->field_order);\n\treturn GF_OK;\n}\n\nGF_Err fiel_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gama_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err gama_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_GamaInfoBox *ptr = (GF_GamaInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4);\n\n    ptr->gama = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *gama_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GamaInfoBox, GF_QT_BOX_TYPE_GAMA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gama_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_GamaInfoBox *ptr = (GF_GamaInfoBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->gama);\n\treturn GF_OK;\n}\n\nGF_Err gama_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid chrm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err chrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ChromaInfoBox *ptr = (GF_ChromaInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 2);\n\n    ptr->chroma = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *chrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChromaInfoBox, GF_QT_BOX_TYPE_CHRM);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ChromaInfoBox *ptr = (GF_ChromaInfoBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->chroma);\n\treturn GF_OK;\n}\n\nGF_Err chrm_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid chan_box_del(GF_Box *s)\n{\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\tif (ptr->audio_descs) gf_free(ptr->audio_descs);\n\tgf_free(s);\n}\n\n\nGF_Err chan_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 12);\n\tptr->layout_tag = gf_bs_read_u32(bs);\n\tptr->bitmap = gf_bs_read_u32(bs);\n\tptr->num_audio_description = gf_bs_read_u32(bs);\n\n\tptr->audio_descs = gf_malloc(sizeof(GF_AudioChannelDescription) * ptr->num_audio_description);\n\tfor (i=0; i<ptr->num_audio_description; i++) {\n\t\tGF_AudioChannelDescription *adesc = &ptr->audio_descs[i];\n\t\tISOM_DECREASE_SIZE(s, 20);\n\t\tadesc->label = gf_bs_read_u32(bs);\n\t\tadesc->flags = gf_bs_read_u32(bs);\n\t\tadesc->coordinates[0] = gf_bs_read_float(bs);\n\t\tadesc->coordinates[1] = gf_bs_read_float(bs);\n\t\tadesc->coordinates[2] = gf_bs_read_float(bs);\n\t}\n\t//avoids warning on most files\n\tif (ptr->size==20) {\n\t\tptr->size=0;\n\t\tgf_bs_skip_bytes(bs, 20);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chan_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutInfoBox, GF_QT_BOX_TYPE_CHAN);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chan_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->layout_tag);\n\tgf_bs_write_u32(bs, ptr->bitmap);\n\tgf_bs_write_u32(bs, ptr->num_audio_description);\n\tfor (i=0; i<ptr->num_audio_description; i++) {\n\t\tGF_AudioChannelDescription *adesc = &ptr->audio_descs[i];\n\t\tgf_bs_write_u32(bs, adesc->label);\n\t\tgf_bs_write_u32(bs, adesc->flags);\n\t\tgf_bs_write_float(bs, adesc->coordinates[0]);\n\t\tgf_bs_write_float(bs, adesc->coordinates[1]);\n\t\tgf_bs_write_float(bs, adesc->coordinates[2]);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err chan_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\ts->size += 12 + 20 * ptr->num_audio_description;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2006-2019\n *\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid ilst_box_del(GF_Box *s)\n{\n\tGF_ItemListBox *ptr = (GF_ItemListBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err ilst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a;\n\tGF_ItemListBox *ptr = (GF_ItemListBox *)s;\n\twhile (ptr->size) {\n\t\t/*if no ilst type coded, break*/\n\t\tsub_type = gf_bs_peek_bits(bs, 32, 0);\n\t\tif (sub_type) {\n\t\t\te = gf_isom_box_parse_ex(&a, bs, s->type, GF_FALSE);\n\n\t\t\t/* the macro will return in this case before we can free */\n\t\t\tif (!e && ptr->size < a->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tif (a) gf_isom_box_del(a);\n\t\t\t\treturn e;\n\t\t\t}\n\n\t\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\t\t\tgf_list_add(ptr->child_boxes, a);\n\t\t} else {\n\t\t\tgf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ilst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ItemListBox, GF_ISOM_BOX_TYPE_ILST);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ilst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n//\tGF_ItemListBox *ptr = (GF_ItemListBox *)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\treturn GF_OK;\n}\n\n\nGF_Err ilst_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid ilst_item_box_del(GF_Box *s)\n{\n\tGF_ListItemBox *ptr = (GF_ListItemBox *) s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && a && (ptr->size < a->size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\tif (!a) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) {\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\t\tif (!ptr->child_boxes) ptr->child_boxes = gf_list_new();\n\t\t\tgf_list_add(ptr->child_boxes, ptr->data);\n\t\t} else {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tu64 pos = gf_bs_get_position(bs);\n\t\tu64 prev_size = s->size;\n\t\t/*try parsing as generic box list*/\n\t\te = gf_isom_box_array_read(s, bs, NULL);\n\t\tif (e==GF_OK) return GF_OK;\n\t\t//reset content and retry - this deletes ptr->data !!\n\t\tgf_isom_box_array_del(s->child_boxes);\n\t\ts->child_boxes=NULL;\n\t\tgf_bs_seek(bs, pos);\n\t\ts->size = prev_size;\n\n\t\tptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t//nope, check qt-style\n\t\tptr->data->qt_style = GF_TRUE;\n\t\tISOM_DECREASE_SIZE(ptr, 2);\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *ilst_item_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ListItemBox, GF_ISOM_BOX_TYPE_CPIL); //type will be overwrite\n\ttmp->data = (GF_DataBox *)gf_isom_box_new_parent(&tmp->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (tmp->data == NULL) {\n\t\tif (tmp->child_boxes) gf_list_del(tmp->child_boxes);\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err ilst_item_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\t/*generic box list*/\n\tif (ptr->child_boxes && !ptr->data) {\n\t}\n\t/*iTune way: data-box-encapsulated box list*/\n\telse if (!ptr->data->qt_style) {\n\t}\n\t/*QT way: raw data*/\n\telse {\n\t\tgf_bs_write_u16(bs, ptr->data->dataSize);\n\t\tgf_bs_write_u16(bs, 0);\n\t\tgf_bs_write_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->size = 0; //abort\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ilst_item_box_size(GF_Box *s)\n{\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\n\t/*generic box list*/\n\tif (ptr->child_boxes && !ptr->data) {\n\t}\n\t/*iTune way: data-box-encapsulated box list*/\n\telse if (ptr->data && !ptr->data->qt_style) {\n\t\tu32 pos=0;\n\t\tgf_isom_check_position(s, (GF_Box* ) ptr->data, &pos);\n\t}\n\t/*QT way: raw data*/\n\telse if (ptr->data) {\n\t\tptr->size += ptr->data->dataSize + 4;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid databox_box_del(GF_Box *s)\n{\n\tGF_DataBox *ptr = (GF_DataBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->data)\n\t\tgf_free(ptr->data);\n\tgf_free(ptr);\n\n}\n\nGF_Err databox_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_DataBox *ptr = (GF_DataBox *)s;\n\n\tptr->reserved = gf_bs_read_int(bs, 32);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->size) {\n\t\tptr->dataSize = (u32) ptr->size;\n\t\tptr->data = (char*)gf_malloc(ptr->dataSize * sizeof(ptr->data[0]) + 1);\n\t\tif (ptr->data == NULL) return GF_OUT_OF_MEM;\n\t\tptr->data[ptr->dataSize] = 0;\n\t\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *databox_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataBox, GF_ISOM_BOX_TYPE_DATA);\n\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err databox_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DataBox *ptr = (GF_DataBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->reserved, 32);\n\tif(ptr->data != NULL && ptr->dataSize > 0) {\n\t\tgf_bs_write_data(bs, ptr->data, ptr->dataSize);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err databox_box_size(GF_Box *s)\n{\n\tGF_DataBox *ptr = (GF_DataBox *)s;\n\n\tptr->size += 4;\n\tif(ptr->data != NULL && ptr->dataSize > 0) {\n\t\tptr->size += ptr->dataSize;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid alis_box_del(GF_Box *s)\n{\n\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err alis_box_read(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\treturn GF_OK;\n}\n\nGF_Box *alis_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DataEntryAliasBox, GF_QT_BOX_TYPE_ALIS);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err alis_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n//\tGF_DataEntryAliasBox *ptr = (GF_DataEntryAliasBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}\n\nGF_Err alis_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid wide_box_del(GF_Box *s)\n{\n\tif (s == NULL) return;\n\tgf_free(s);\n}\n\n\nGF_Err wide_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tgf_bs_skip_bytes(bs, s->size);\n\ts->size = 0;\n\treturn GF_OK;\n}\n\nGF_Box *wide_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_WideBox, GF_QT_BOX_TYPE_WIDE);\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err wide_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}\n\nGF_Err wide_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_MetaBox *gf_isom_apple_get_meta_extensions(GF_ISOFile *mov)\n{\n\tu32 i;\n\tGF_MetaBox *meta;\n\tGF_UserDataMap *map;\n\n\tif (!mov || !mov->moov) return NULL;\n\n\tif (!mov->moov->udta) return NULL;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_META, NULL);\n\tif (!map) return NULL;\n\n\tfor(i = 0; i < gf_list_count(map->boxes); i++) {\n\t\tmeta = (GF_MetaBox*)gf_list_get(map->boxes, i);\n\n\t\tif(meta != NULL && meta->handler != NULL && meta->handler->handlerType == GF_ISOM_HANDLER_TYPE_MDIR) return meta;\n\t}\n\n\treturn NULL;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_MetaBox *gf_isom_apple_create_meta_extensions(GF_ISOFile *mov)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_MetaBox *meta;\n\tGF_UserDataMap *map;\n\n\tif (!mov || !mov->moov) return NULL;\n\n\tif (!mov->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)mov->moov, gf_isom_box_new_parent(&mov->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return NULL;\n\t}\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_META, NULL);\n\tif (map) {\n\t\tfor(i = 0; i < gf_list_count(map->boxes); i++) {\n\t\t\tmeta = (GF_MetaBox*)gf_list_get(map->boxes, i);\n\n\t\t\tif(meta != NULL && meta->handler != NULL && meta->handler->handlerType == GF_ISOM_HANDLER_TYPE_MDIR) return meta;\n\t\t}\n\t}\n\n\t//udta handles children boxes through maps\n\tmeta = (GF_MetaBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_META);\n\n\tif(meta != NULL) {\n\t\tmeta->handler = (GF_HandlerBox *)gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_HDLR);\n\t\tif(meta->handler == NULL) {\n\t\t\tgf_isom_box_del((GF_Box *)meta);\n\t\t\treturn NULL;\n\t\t}\n\t\tmeta->handler->handlerType = GF_ISOM_HANDLER_TYPE_MDIR;\n\t\tgf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t\tudta_on_child_box((GF_Box *)mov->moov->udta, (GF_Box *)meta);\n\t}\n\n\treturn meta;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nvoid gmin_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err gmin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_GenericMediaHeaderInfoBox *ptr = (GF_GenericMediaHeaderInfoBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 12);\n\tptr->graphics_mode = gf_bs_read_u16(bs);\n\tptr->op_color_red = gf_bs_read_u16(bs);\n\tptr->op_color_green = gf_bs_read_u16(bs);\n\tptr->op_color_blue = gf_bs_read_u16(bs);\n\tptr->balance = gf_bs_read_u16(bs);\n\tptr->reserved = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *gmin_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GenericMediaHeaderInfoBox, GF_QT_BOX_TYPE_GMIN);\n\treturn (GF_Box *)tmp;\n}\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gmin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_GenericMediaHeaderInfoBox *ptr = (GF_GenericMediaHeaderInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->graphics_mode);\n\tgf_bs_write_u16(bs, ptr->op_color_red);\n\tgf_bs_write_u16(bs, ptr->op_color_green);\n\tgf_bs_write_u16(bs, ptr->op_color_blue);\n\tgf_bs_write_u16(bs, ptr->balance);\n\tgf_bs_write_u16(bs, ptr->reserved);\n\treturn GF_OK;\n}\n\nGF_Err gmin_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 12;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nvoid clef_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err clef_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ApertureBox *ptr = (GF_ApertureBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->width = gf_bs_read_u32(bs);\n\tptr->height = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *clef_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ApertureBox, GF_QT_BOX_TYPE_CLEF);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err clef_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ApertureBox *ptr = (GF_ApertureBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}\n\nGF_Err clef_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tmcd_box_del(GF_Box *s)\n{\n\tif (s == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\n\nGF_Err tmcd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TimeCodeSampleEntryBox *ptr = (GF_TimeCodeSampleEntryBox *)s;\n\tGF_Err e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)s, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(s, 26);\n\tgf_bs_read_u32(bs); //reserved\n\tptr->flags = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\tptr->frame_duration = gf_bs_read_u32(bs);\n\tptr->frames_per_sec = gf_bs_read_u8(bs);\n\tgf_bs_read_u8(bs); //reserved\n\n\treturn gf_isom_box_array_read(s, bs, NULL);\n}\n\nGF_Box *tmcd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeCodeSampleEntryBox, GF_QT_BOX_TYPE_TMCD);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tmcd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TimeCodeSampleEntryBox *ptr = (GF_TimeCodeSampleEntryBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tgf_bs_write_u32(bs, 0); //reserved\n\tgf_bs_write_u32(bs, ptr->flags);\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tgf_bs_write_u32(bs, ptr->frame_duration);\n\tgf_bs_write_u8(bs, ptr->frames_per_sec);\n\tgf_bs_write_u8(bs, 0); //reserved\n\n\treturn GF_OK;\n}\n\nGF_Err tmcd_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8 + 18;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid tcmi_box_del(GF_Box *s)\n{\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\tif (ptr->font) gf_free(ptr->font);\n\tgf_free(s);\n}\n\n\nGF_Err tcmi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 21);\n\n\tptr->text_font = gf_bs_read_u16(bs);\n\tptr->text_face = gf_bs_read_u16(bs);\n\tptr->text_size = gf_bs_read_u16(bs);\n\tgf_bs_read_u16(bs);\n\tptr->text_color_red = gf_bs_read_u16(bs);\n\tptr->text_color_green = gf_bs_read_u16(bs);\n\tptr->text_color_blue = gf_bs_read_u16(bs);\n\tptr->back_color_red = gf_bs_read_u16(bs);\n\tptr->back_color_green = gf_bs_read_u16(bs);\n\tptr->back_color_blue = gf_bs_read_u16(bs);\n\tlen = gf_bs_read_u8(bs);\n\tif (len > ptr->size)\n\t\tlen = (u32) ptr->size;\n\tif (len) {\n\t\tptr->font = gf_malloc(len+1);\n\t\tgf_bs_read_data(bs, ptr->font, len);\n\t\tptr->size -= len;\n\t\tptr->font[len]=0;\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tcmi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TimeCodeMediaInformationBox, GF_QT_BOX_TYPE_TMCD);\n\ttmp->text_size = 12;\n\ttmp->text_color_red = 0xFFFF;\n\ttmp->text_color_green = 0xFFFF;\n\ttmp->text_color_blue = 0xFFFF;\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tcmi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 len;\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->text_font);\n\tgf_bs_write_u16(bs, ptr->text_face);\n\tgf_bs_write_u16(bs, ptr->text_size);\n\tgf_bs_write_u16(bs, 0);\n\tgf_bs_write_u16(bs, ptr->text_color_red);\n\tgf_bs_write_u16(bs, ptr->text_color_green);\n\tgf_bs_write_u16(bs, ptr->text_color_blue);\n\tgf_bs_write_u16(bs, ptr->back_color_red);\n\tgf_bs_write_u16(bs, ptr->back_color_green);\n\tgf_bs_write_u16(bs, ptr->back_color_blue);\n\tlen = ptr->font ? (u32) strlen(ptr->font) : 0;\n\tgf_bs_write_u8(bs, len);\n\tif (ptr->font)\n\t\tgf_bs_write_data(bs, ptr->font, len);\n\n\treturn GF_OK;\n}\n\nGF_Err tcmi_box_size(GF_Box *s)\n{\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\tptr->size += 21;\n\tif (ptr->font)\n    \tptr->size += strlen(ptr->font);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid fiel_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err fiel_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_FieldInfoBox *ptr = (GF_FieldInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 2);\n\n    ptr->field_count = gf_bs_read_u8(bs);\n    ptr->field_order = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\nGF_Box *fiel_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FieldInfoBox, GF_QT_BOX_TYPE_FIEL);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err fiel_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_FieldInfoBox *ptr = (GF_FieldInfoBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->field_count);\n\tgf_bs_write_u8(bs, ptr->field_order);\n\treturn GF_OK;\n}\n\nGF_Err fiel_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid gama_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err gama_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_GamaInfoBox *ptr = (GF_GamaInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 4);\n\n    ptr->gama = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\nGF_Box *gama_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_GamaInfoBox, GF_QT_BOX_TYPE_GAMA);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gama_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_GamaInfoBox *ptr = (GF_GamaInfoBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->gama);\n\treturn GF_OK;\n}\n\nGF_Err gama_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid chrm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err chrm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ChromaInfoBox *ptr = (GF_ChromaInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 2);\n\n    ptr->chroma = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\nGF_Box *chrm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChromaInfoBox, GF_QT_BOX_TYPE_CHRM);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chrm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ChromaInfoBox *ptr = (GF_ChromaInfoBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->chroma);\n\treturn GF_OK;\n}\n\nGF_Err chrm_box_size(GF_Box *s)\n{\n\ts->size += 2;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nvoid chan_box_del(GF_Box *s)\n{\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\tif (ptr->audio_descs) gf_free(ptr->audio_descs);\n\tgf_free(s);\n}\n\n\nGF_Err chan_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\n\tISOM_DECREASE_SIZE(s, 12);\n\tptr->layout_tag = gf_bs_read_u32(bs);\n\tptr->bitmap = gf_bs_read_u32(bs);\n\tptr->num_audio_description = gf_bs_read_u32(bs);\n\n\tptr->audio_descs = gf_malloc(sizeof(GF_AudioChannelDescription) * ptr->num_audio_description);\n\tfor (i=0; i<ptr->num_audio_description; i++) {\n\t\tGF_AudioChannelDescription *adesc = &ptr->audio_descs[i];\n\t\tISOM_DECREASE_SIZE(s, 20);\n\t\tadesc->label = gf_bs_read_u32(bs);\n\t\tadesc->flags = gf_bs_read_u32(bs);\n\t\tadesc->coordinates[0] = gf_bs_read_float(bs);\n\t\tadesc->coordinates[1] = gf_bs_read_float(bs);\n\t\tadesc->coordinates[2] = gf_bs_read_float(bs);\n\t}\n\t//avoids warning on most files\n\tif (ptr->size==20) {\n\t\tptr->size=0;\n\t\tgf_bs_skip_bytes(bs, 20);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *chan_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ChannelLayoutInfoBox, GF_QT_BOX_TYPE_CHAN);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err chan_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\n\tgf_bs_write_u32(bs, ptr->layout_tag);\n\tgf_bs_write_u32(bs, ptr->bitmap);\n\tgf_bs_write_u32(bs, ptr->num_audio_description);\n\tfor (i=0; i<ptr->num_audio_description; i++) {\n\t\tGF_AudioChannelDescription *adesc = &ptr->audio_descs[i];\n\t\tgf_bs_write_u32(bs, adesc->label);\n\t\tgf_bs_write_u32(bs, adesc->flags);\n\t\tgf_bs_write_float(bs, adesc->coordinates[0]);\n\t\tgf_bs_write_float(bs, adesc->coordinates[1]);\n\t\tgf_bs_write_float(bs, adesc->coordinates[2]);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err chan_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutInfoBox *ptr = (GF_ChannelLayoutInfoBox *)s;\n\ts->size += 12 + 20 * ptr->num_audio_description;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_code_apple.c"], "buggy_code_start_loc": [115], "buggy_code_end_loc": [122], "fixing_code_start_loc": [115], "fixing_code_end_loc": [124], "type": "CWE-476", "message": "An issue was discovered in box_code_apple.c:119 in Gpac MP4Box 0.8.0, allows attackers to cause a Denial of Service due to an invalid read on function ilst_item_Read.", "other": {"cve": {"id": "CVE-2020-19488", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-21T18:15:08.957", "lastModified": "2021-07-31T00:23:02.740", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in box_code_apple.c:119 in Gpac MP4Box 0.8.0, allows attackers to cause a Denial of Service due to an invalid read on function ilst_item_Read."}, {"lang": "es", "value": "Se ha detectado un problema en el archivo box_code_apple.c:119 en Gpac MP4Box versi\u00f3n 0.8.0, que permite a atacantes causar una Denegaci\u00f3n de Servicio debido a una lectura no v\u00e1lida en la funci\u00f3n ilst_item_Read"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "93EEFCFD-7417-40E6-84BF-4EA630F2A8A1"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/6170024568f4dda310e98ef7508477b425c58d09", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1263", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/6170024568f4dda310e98ef7508477b425c58d09"}}