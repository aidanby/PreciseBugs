{"buggy_code": ["/*\n * COPYRIGHT (c) International Business Machines Corp. 2001-2017\n *\n * This program is provided under the terms of the Common Public License,\n * version 1.0 (CPL-1.0). Any use, reproduction or distribution for this\n * software constitutes recipient's acceptance of CPL-1.0 terms which can be\n * found in the file LICENSE file or at\n * https://opensource.org/licenses/cpl1.0.php\n */\n\n/***************************************************************************\n                          Change Log\n                          ==========\n       4/25/03    Kapil Sood (kapil@corrent.com)\n                  Added DH key pair generation and DH shared key derivation\n                  functions.\n\n\n\n****************************************************************************/\n\n#include <pthread.h>\n#include <string.h>             // for memcmp() et al\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <openssl/opensslv.h>\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n#define NO_EC 1\n#endif\n\n#include \"pkcs11types.h\"\n#include \"defs.h\"\n#include \"host_defs.h\"\n#include \"h_extern.h\"\n#include \"errno.h\"\n#include \"tok_specific.h\"\n#include \"tok_struct.h\"\n#include \"trace.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <endian.h>\n\n#include <openssl/des.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#include <openssl/dh.h>\n#include <openssl/aes.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/crypto.h>\n#include <openssl/cmac.h>\n#include <openssl/ec.h>\n\n/*\n * In order to make opencryptoki compatible with\n * OpenSSL 1.1 API Changes and backward compatible\n * we need to check for its version\n */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#define OLDER_OPENSSL\n#endif\n\n#define MAX_GENERIC_KEY_SIZE 256\n\nconst char manuf[] = \"IBM\";\nconst char model[] = \"Soft\";\nconst char descr[] = \"IBM Soft token\";\nconst char label[] = \"softtok\";\n\nstatic const MECH_LIST_ELEMENT soft_mech_list[] = {\n    {CKM_RSA_PKCS_KEY_PAIR_GEN, {512, 4096, CKF_GENERATE_KEY_PAIR}},\n#if !(NODSA)\n    {CKM_DSA_KEY_PAIR_GEN, {512, 1024, CKF_GENERATE_KEY_PAIR}},\n#endif\n    {CKM_DES_KEY_GEN, {8, 8, CKF_GENERATE}},\n    {CKM_DES3_KEY_GEN, {24, 24, CKF_GENERATE}},\n#if !(NOCDMF)\n    {CKM_CDMF_KEY_GEN, {0, 0, CKF_GENERATE}},\n#endif\n    {CKM_RSA_PKCS,\n     {512, 4096, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP | CKF_SIGN |\n      CKF_VERIFY | CKF_SIGN_RECOVER | CKF_VERIFY_RECOVER}},\n    {CKM_SHA1_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA224_RSA_PKCS, {1024, 4096, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA256_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA1_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA224_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA256_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n#if !(NOX509)\n    {CKM_RSA_X_509,\n     {512, 4096, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP | CKF_SIGN |\n      CKF_VERIFY | CKF_SIGN_RECOVER | CKF_VERIFY_RECOVER}},\n#endif\n    {CKM_RSA_PKCS_OAEP,\n     {1024, 4096, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n#if !(NOMD2)\n    {CKM_MD2_RSA_PKCS, {512, 4096, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOMD5)\n    {CKM_MD5_RSA_PKCS, {512, 4096, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOSHA1)\n    {CKM_SHA1_RSA_PKCS, {512, 4096, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NODSA)\n    {CKM_DSA, {512, 1024, CKF_SIGN | CKF_VERIFY}},\n#endif\n/* Begin code contributed by Corrent corp. */\n#if !(NODH)\n    {CKM_DH_PKCS_DERIVE, {512, 2048, CKF_DERIVE}},\n    {CKM_DH_PKCS_KEY_PAIR_GEN, {512, 2048, CKF_GENERATE_KEY_PAIR}},\n#endif\n/* End code contributed by Corrent corp. */\n    {CKM_DES_ECB, {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES_CBC, {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES_CBC_PAD,\n     {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n#if !(NOCDMF)\n    {CKM_CDMF_ECB, {0, 0, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_CDMF_CBC, {0, 0, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n#endif\n    {CKM_DES3_ECB, {24, 24, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES3_CBC, {24, 24, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES3_CBC_PAD,\n     {24, 24, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES3_MAC, {16, 24, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_DES3_MAC_GENERAL, {16, 24, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_DES3_CMAC, {16, 24, CKF_SIGN | CKF_VERIFY}},\n    {CKM_DES3_CMAC_GENERAL, {16, 24, CKF_SIGN | CKF_VERIFY}},\n#if !(NOSHA1)\n    {CKM_SHA_1, {0, 0, CKF_DIGEST}},\n    {CKM_SHA_1_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA_1_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n    {CKM_SHA224, {0, 0, CKF_DIGEST}},\n    {CKM_SHA224_HMAC, {0, 0, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA224_HMAC_GENERAL, {0, 0, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA256, {0, 0, CKF_DIGEST}},\n    {CKM_SHA256_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA256_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384, {0, 0, CKF_DIGEST}},\n    {CKM_SHA384_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512, {0, 0, CKF_DIGEST}},\n    {CKM_SHA512_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#ifdef NID_sha512_224WithRSAEncryption\n    {CKM_SHA512_224, {0, 0, CKF_DIGEST}},\n    {CKM_SHA512_224_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_224_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha512_256WithRSAEncryption\n    {CKM_SHA512_256, {0, 0, CKF_DIGEST}},\n    {CKM_SHA512_256_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_256_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_224\n    {CKM_IBM_SHA3_224, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_224_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_256\n    {CKM_IBM_SHA3_256, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_256_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_384\n    {CKM_IBM_SHA3_384, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_384_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_512\n    {CKM_IBM_SHA3_512, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_512_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOMD2)\n    {CKM_MD2, {0, 0, CKF_DIGEST}},\n    {CKM_MD2_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_MD2_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOMD5)\n    {CKM_MD5, {0, 0, CKF_DIGEST}},\n    {CKM_MD5_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_MD5_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n    {CKM_SSL3_PRE_MASTER_KEY_GEN, {48, 48, CKF_GENERATE}},\n    {CKM_SSL3_MASTER_KEY_DERIVE, {48, 48, CKF_DERIVE}},\n    {CKM_SSL3_KEY_AND_MAC_DERIVE, {48, 48, CKF_DERIVE}},\n    {CKM_SSL3_MD5_MAC, {384, 384, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SSL3_SHA1_MAC, {384, 384, CKF_SIGN | CKF_VERIFY}},\n#if !(NOAES)\n    {CKM_AES_KEY_GEN, {16, 32, CKF_GENERATE}},\n    {CKM_AES_ECB, {16, 32, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_AES_CBC, {16, 32, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_AES_CBC_PAD,\n     {16, 32, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_AES_MAC, {16, 32, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_AES_MAC_GENERAL, {16, 32, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_AES_CMAC, {16, 32, CKF_SIGN | CKF_VERIFY}},\n    {CKM_AES_CMAC_GENERAL, {16, 32, CKF_SIGN | CKF_VERIFY}},\n#endif\n    {CKM_GENERIC_SECRET_KEY_GEN, {80, 2048, CKF_GENERATE}},\n#if !(NO_EC)\n    {CKM_EC_KEY_PAIR_GEN, {160, 521, CKF_GENERATE_KEY_PAIR |\n                           CKF_EC_NAMEDCURVE | CKF_EC_F_P}},\n    {CKM_ECDSA, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                 CKF_EC_F_P}},\n    {CKM_ECDSA_SHA1, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                      CKF_EC_F_P}},\n    {CKM_ECDSA_SHA224, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDSA_SHA256, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDSA_SHA384, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDSA_SHA512, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDH1_DERIVE, {160, 521, CKF_DERIVE | CKF_EC_NAMEDCURVE | CKF_EC_F_P}},\n#endif\n};\n\nstatic const CK_ULONG soft_mech_list_len =\n                    (sizeof(soft_mech_list) / sizeof(MECH_LIST_ELEMENT));\n\nCK_RV token_specific_init(STDLL_TokData_t *tokdata, CK_SLOT_ID SlotNumber,\n                          char *conf_name)\n{\n    UNUSED(conf_name);\n\n    tokdata->mech_list = (MECH_LIST_ELEMENT *)soft_mech_list;\n    tokdata->mech_list_len = soft_mech_list_len;\n\n    TRACE_INFO(\"soft %s slot=%lu running\\n\", __func__, SlotNumber);\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_final(STDLL_TokData_t *tokdata,\n                           CK_BBOOL token_specific_final)\n{\n    UNUSED(tokdata);\n    UNUSED(token_specific_final);\n\n    TRACE_INFO(\"soft %s running\\n\", __func__);\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_des_key_gen(STDLL_TokData_t *tokdata, CK_BYTE **des_key,\n                                 CK_ULONG *len, CK_ULONG keysize,\n                                 CK_BBOOL *is_opaque)\n{\n    *des_key = malloc(keysize);\n    if (*des_key == NULL)\n        return CKR_HOST_MEMORY;\n    *len = keysize;\n    *is_opaque = FALSE;\n\n    // Nothing different to do for DES or TDES here as this is just\n    // random data...  Validation handles the rest\n    // Only check for weak keys when DES.\n    if (keysize == (3 * DES_KEY_SIZE)) {\n        rng_generate(tokdata, *des_key, keysize);\n    } else {\n        do {\n            rng_generate(tokdata, *des_key, keysize);;\n        } while (des_check_weak_key(*des_key) == TRUE);\n    }\n\n    // we really need to validate the key for parity etc...\n    // we should do that here... The caller validates the single des keys\n    // against the known and suspected poor keys..\n    return CKR_OK;\n}\n\nCK_RV token_specific_des_ecb(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rc;\n    DES_key_schedule des_key2;\n    const_DES_cblock key_val_SSL, in_key_data;\n    DES_cblock out_key_data;\n    unsigned int i, j;\n    CK_ATTRIBUTE *attr = NULL;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // Create the key schedule\n    memcpy(&key_val_SSL, attr->pValue, 8);\n    DES_set_key_unchecked(&key_val_SSL, &des_key2);\n\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n    // Both the encrypt and the decrypt are done 8 bytes at a time\n    if (encrypt) {\n        for (i = 0; i < in_data_len; i = i + 8) {\n            memcpy(in_key_data, in_data + i, 8);\n            DES_ecb_encrypt(&in_key_data, &out_key_data, &des_key2,\n                            DES_ENCRYPT);\n            memcpy(out_data + i, out_key_data, 8);\n        }\n\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n\n        for (j = 0; j < in_data_len; j = j + 8) {\n            memcpy(in_key_data, in_data + j, 8);\n            DES_ecb_encrypt(&in_key_data, &out_key_data, &des_key2,\n                            DES_DECRYPT);\n            memcpy(out_data + j, out_key_data, 8);\n        }\n\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_ecb();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[DES_KEY_SIZE];\n    CK_ULONG rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        return rc;\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    memcpy(dkey, attr->pValue, sizeof(dkey));\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, NULL, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_des_cbc(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rc;\n    CK_ATTRIBUTE *attr = NULL;\n    DES_cblock ivec;\n    DES_key_schedule des_key2;\n    const_DES_cblock key_val_SSL;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // Create the key schedule\n    memcpy(&key_val_SSL, attr->pValue, 8);\n    DES_set_key_unchecked(&key_val_SSL, &des_key2);\n\n    memcpy(&ivec, init_v, 8);\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    if (encrypt) {\n        DES_ncbc_encrypt(in_data, out_data, in_data_len, &des_key2, &ivec,\n                         DES_ENCRYPT);\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n        DES_ncbc_encrypt(in_data, out_data, in_data_len, &des_key2, &ivec,\n                         DES_DECRYPT);\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_cbc();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[DES_KEY_SIZE];\n    CK_ULONG rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        return rc;\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    memcpy(dkey, attr->pValue, sizeof(dkey));\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, init_v, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_tdes_ecb(STDLL_TokData_t *tokdata,\n                              CK_BYTE *in_data,\n                              CK_ULONG in_data_len,\n                              CK_BYTE *out_data,\n                              CK_ULONG *out_data_len,\n                              OBJECT *key, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rc;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE key_value[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    unsigned int k, j;\n    DES_key_schedule des_key1;\n    DES_key_schedule des_key2;\n    DES_key_schedule des_key3;\n    const_DES_cblock key_SSL1, key_SSL2, key_SSL3, in_key_data;\n    DES_cblock out_key_data;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    if (keytype == CKK_DES2) {\n        memcpy(key_value, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(key_value + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(key_value, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    // The key as passed is a 24 byte long string containing three des keys\n    // pick them apart and create the 3 corresponding key schedules\n    memcpy(&key_SSL1, key_value, 8);\n    memcpy(&key_SSL2, key_value + 8, 8);\n    memcpy(&key_SSL3, key_value + 16, 8);\n    DES_set_key_unchecked(&key_SSL1, &des_key1);\n    DES_set_key_unchecked(&key_SSL2, &des_key2);\n    DES_set_key_unchecked(&key_SSL3, &des_key3);\n\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n    // the encrypt and decrypt are done 8 bytes at a time\n    if (encrypt) {\n        for (k = 0; k < in_data_len; k = k + 8) {\n            memcpy(in_key_data, in_data + k, 8);\n            DES_ecb3_encrypt((const_DES_cblock *) & in_key_data,\n                             (DES_cblock *) & out_key_data,\n                             &des_key1, &des_key2, &des_key3, DES_ENCRYPT);\n            memcpy(out_data + k, out_key_data, 8);\n        }\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n        for (j = 0; j < in_data_len; j = j + 8) {\n            memcpy(in_key_data, in_data + j, 8);\n            DES_ecb3_encrypt((const_DES_cblock *) & in_key_data,\n                             (DES_cblock *) & out_key_data,\n                             &des_key1, &des_key2, &des_key3, DES_DECRYPT);\n            memcpy(out_data + j, out_key_data, 8);\n        }\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_ede3_ecb();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    CK_ULONG rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    if (keytype == CKK_DES2) {\n        memcpy(dkey, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(dkey + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(dkey, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, NULL, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_tdes_cbc(STDLL_TokData_t *tokdata,\n                              CK_BYTE *in_data,\n                              CK_ULONG in_data_len,\n                              CK_BYTE *out_data,\n                              CK_ULONG *out_data_len,\n                              OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_ATTRIBUTE *attr = NULL;\n    CK_RV rc = CKR_OK;\n    CK_BYTE key_value[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    DES_key_schedule des_key1;\n    DES_key_schedule des_key2;\n    DES_key_schedule des_key3;\n    const_DES_cblock key_SSL1, key_SSL2, key_SSL3;\n    DES_cblock ivec;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    if (keytype == CKK_DES2) {\n        memcpy(key_value, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(key_value + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(key_value, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    // The key as passed in is a 24 byte string containing 3 keys\n    // pick it apart and create the key schedules\n    memcpy(&key_SSL1, key_value, 8);\n    memcpy(&key_SSL2, key_value + 8, 8);\n    memcpy(&key_SSL3, key_value + 16, 8);\n    DES_set_key_unchecked(&key_SSL1, &des_key1);\n    DES_set_key_unchecked(&key_SSL2, &des_key2);\n    DES_set_key_unchecked(&key_SSL3, &des_key3);\n\n    memcpy(ivec, init_v, sizeof(ivec));\n\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n    // Encrypt or decrypt the data\n    if (encrypt) {\n        DES_ede3_cbc_encrypt(in_data,\n                             out_data,\n                             in_data_len,\n                             &des_key1,\n                             &des_key2, &des_key3, &ivec, DES_ENCRYPT);\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n        DES_ede3_cbc_encrypt(in_data,\n                             out_data,\n                             in_data_len,\n                             &des_key1,\n                             &des_key2, &des_key3, &ivec, DES_DECRYPT);\n\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_ede3_cbc();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    CK_RV rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n\n    if (keytype == CKK_DES2) {\n        memcpy(dkey, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(dkey + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(dkey, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, init_v, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_tdes_mac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                              CK_ULONG message_len, OBJECT *key, CK_BYTE *mac)\n{\n    CK_BYTE *out_buf;\n    CK_ULONG out_len;\n    CK_RV rc;\n\n    out_buf = malloc(message_len);\n    if (out_buf == NULL) {\n        TRACE_ERROR(\"Malloc failed.\\n\");\n        return CKR_HOST_MEMORY;\n    }\n\n    rc = token_specific_tdes_cbc(tokdata, message, message_len, out_buf,\n                                 &out_len, key, mac, 1);\n\n    if (rc == CKR_OK && out_len >= DES_BLOCK_SIZE)\n        memcpy(mac, out_buf + out_len - DES_BLOCK_SIZE, DES_BLOCK_SIZE);\n\n    free(out_buf);\n\n    return rc;\n}\n\n// convert from the local PKCS11 template representation to\n// the underlying requirement\n// returns the pointer to the local key representation\nstatic void *rsa_convert_public_key(OBJECT *key_obj)\n{\n    CK_BBOOL rc;\n    CK_ATTRIBUTE *modulus = NULL;\n    CK_ATTRIBUTE *pub_exp = NULL;\n\n    RSA *rsa;\n    BIGNUM *bn_mod, *bn_exp;\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &modulus);\n    if (rc != CKR_OK)\n        return NULL;\n    rc = template_attribute_get_non_empty(key_obj->template,\n                                          CKA_PUBLIC_EXPONENT, &pub_exp);\n    if (rc != CKR_OK)\n        return NULL;\n\n    // Create an RSA key struct to return\n    rsa = RSA_new();\n    if (rsa == NULL)\n        return NULL;\n\n    // Create and init BIGNUM structs to stick in the RSA struct\n    bn_mod = BN_new();\n    bn_exp = BN_new();\n\n    if (bn_exp == NULL || bn_mod == NULL) {\n        if (bn_mod)\n            free(bn_mod);\n        if (bn_exp)\n            free(bn_exp);\n        RSA_free(rsa);\n        return NULL;\n    }\n    // Convert from strings to BIGNUMs and stick them in the RSA struct\n    BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen, bn_mod);\n    BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen, bn_exp);\n\n#ifdef OLDER_OPENSSL\n    rsa->n = bn_mod;\n    rsa->e = bn_exp;\n#else\n    RSA_set0_key(rsa, bn_mod, bn_exp, NULL);\n#endif\n\n    return (void *) rsa;\n}\n\nstatic void *rsa_convert_private_key(OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *modulus = NULL;\n    CK_ATTRIBUTE *pub_exp = NULL;\n    CK_ATTRIBUTE *priv_exp = NULL;\n    CK_ATTRIBUTE *prime1 = NULL;\n    CK_ATTRIBUTE *prime2 = NULL;\n    CK_ATTRIBUTE *exp1 = NULL;\n    CK_ATTRIBUTE *exp2 = NULL;\n    CK_ATTRIBUTE *coeff = NULL;\n\n    RSA *rsa;\n    RSA_METHOD *meth;\n    BIGNUM *bn_mod, *bn_pub_exp, *bn_priv_exp, *bn_p1, *bn_p2, *bn_e1, *bn_e2,\n        *bn_cf;\n\n    template_attribute_get_non_empty(key_obj->template, CKA_MODULUS, &modulus);\n    template_attribute_get_non_empty(key_obj->template,  CKA_PUBLIC_EXPONENT,\n                                     &pub_exp);\n    template_attribute_find(key_obj->template, CKA_PRIVATE_EXPONENT, &priv_exp);\n    template_attribute_find(key_obj->template, CKA_PRIME_1, &prime1);\n    template_attribute_find(key_obj->template, CKA_PRIME_2, &prime2);\n    template_attribute_find(key_obj->template, CKA_EXPONENT_1, &exp1);\n    template_attribute_find(key_obj->template, CKA_EXPONENT_2,&exp2);\n    template_attribute_find(key_obj->template, CKA_COEFFICIENT, &coeff);\n\n    if (!prime2 && !modulus) {\n        return NULL;\n    }\n    // Create and init all the RSA and BIGNUM structs we need.\n    rsa = RSA_new();\n    if (rsa == NULL)\n        return NULL;\n\n    /*\n     * Depending if an engine is loaded on OpenSSL and define its own\n     * RSA_METHOD, we can end up having an infinite loop as the SOFT\n     * Token doesn't implement RSA and, instead, calls OpenSSL for it.\n     * So to avoid it we set RSA methods to the default rsa methods.\n     */\n#ifdef OLDER_OPENSSL\n    if (rsa->engine) {\n        meth = (RSA_METHOD *) rsa->meth;\n        const RSA_METHOD *meth2 = RSA_PKCS1_SSLeay();\n        meth->rsa_pub_enc = meth2->rsa_pub_enc;\n        meth->rsa_pub_dec = meth2->rsa_pub_dec;\n        meth->rsa_priv_enc = meth2->rsa_priv_enc;\n        meth->rsa_priv_dec = meth2->rsa_priv_dec;\n        meth->rsa_mod_exp = meth2->rsa_mod_exp;\n        meth->bn_mod_exp = meth2->bn_mod_exp;\n#else\n/*\n * XXX I dont see a better way than to ignore this warning for now.\n * Note that the GCC pragma also works for clang.\n */\n# pragma GCC diagnostic push\n# pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    ENGINE *e = RSA_get0_engine(rsa);\n    if (e) {\n        meth = (RSA_METHOD *) RSA_get_method(rsa);\n        const RSA_METHOD *meth2 = RSA_PKCS1_OpenSSL();\n        RSA_meth_set_pub_enc(meth, RSA_meth_get_pub_enc(meth2));\n        RSA_meth_set_pub_dec(meth, RSA_meth_get_pub_dec(meth2));\n        RSA_meth_set_priv_enc(meth, RSA_meth_get_priv_enc(meth2));\n        RSA_meth_set_priv_dec(meth, RSA_meth_get_priv_dec(meth2));\n        RSA_meth_set_mod_exp(meth, RSA_meth_get_mod_exp(meth2));\n        RSA_meth_set_bn_mod_exp(meth, RSA_meth_get_bn_mod_exp(meth2));\n# pragma GCC diagnostic pop\n#endif\n    }\n\n    bn_mod = BN_new();\n    bn_pub_exp = BN_new();\n    bn_priv_exp = BN_new();\n    bn_p1 = BN_new();\n    bn_p2 = BN_new();\n    bn_e1 = BN_new();\n    bn_e2 = BN_new();\n    bn_cf = BN_new();\n\n    if ((bn_cf == NULL) || (bn_e2 == NULL) || (bn_e1 == NULL) ||\n        (bn_p2 == NULL) || (bn_p1 == NULL) || (bn_priv_exp == NULL) ||\n        (bn_pub_exp == NULL) || (bn_mod == NULL)) {\n        if (rsa)\n            RSA_free(rsa);\n        if (bn_mod)\n            BN_free(bn_mod);\n        if (bn_pub_exp)\n            BN_free(bn_pub_exp);\n        if (bn_priv_exp)\n            BN_free(bn_priv_exp);\n        if (bn_p1)\n            BN_free(bn_p1);\n        if (bn_p2)\n            BN_free(bn_p2);\n        if (bn_e1)\n            BN_free(bn_e1);\n        if (bn_e2)\n            BN_free(bn_e2);\n        if (bn_cf)\n            BN_free(bn_cf);\n        return NULL;\n    }\n\n    // CRT key?\n    if (prime1) {\n        if (!prime2 || !exp1 || !exp2 || !coeff) {\n            return NULL;\n        }\n        // Even though this is CRT key, OpenSSL requires the\n        // modulus and exponents filled in or encrypt and decrypt will\n        // not work\n        BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen,\n                  bn_mod);\n        BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen,\n                  bn_pub_exp);\n        BN_bin2bn((unsigned char *) priv_exp->pValue, priv_exp->ulValueLen,\n                  bn_priv_exp);\n\n        BN_bin2bn((unsigned char *) prime1->pValue, prime1->ulValueLen, bn_p1);\n        BN_bin2bn((unsigned char *) prime2->pValue, prime2->ulValueLen, bn_p2);\n\n        BN_bin2bn((unsigned char *) exp1->pValue, exp1->ulValueLen, bn_e1);\n        BN_bin2bn((unsigned char *) exp2->pValue, exp2->ulValueLen, bn_e2);\n        BN_bin2bn((unsigned char *) coeff->pValue, coeff->ulValueLen, bn_cf);\n#ifdef OLDER_OPENSSL\n        rsa->n = bn_mod;\n        rsa->d = bn_priv_exp;\n        rsa->p = bn_p1;\n        rsa->q = bn_p2;\n        rsa->dmp1 = bn_e1;\n        rsa->dmq1 = bn_e2;\n        rsa->iqmp = bn_cf;\n#else\n        RSA_set0_key(rsa, bn_mod, bn_pub_exp, bn_priv_exp);\n        RSA_set0_factors(rsa, bn_p1, bn_p2);\n        RSA_set0_crt_params(rsa, bn_e1, bn_e2, bn_cf);\n#endif\n        return rsa;\n    } else {                    // must be a non-CRT key\n        if (!priv_exp) {\n            return NULL;\n        }\n        BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen,\n                  bn_mod);\n        BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen,\n                  bn_pub_exp);\n        BN_bin2bn((unsigned char *) priv_exp->pValue, priv_exp->ulValueLen,\n                  bn_priv_exp);\n#ifdef OLDER_OPENSSL\n        rsa->n = bn_mod;\n        rsa->d = bn_priv_exp;\n#else\n        RSA_set0_key(rsa, bn_mod, bn_pub_exp, bn_priv_exp);\n#endif\n    }\n\n    return (void *) rsa;\n}\n\nstatic CK_RV os_specific_rsa_keygen(TEMPLATE *publ_tmpl, TEMPLATE *priv_tmpl)\n{\n    CK_ATTRIBUTE *publ_exp = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_ULONG mod_bits;\n    CK_BBOOL flag;\n    CK_RV rc;\n    CK_ULONG BNLength;\n    RSA *rsa = NULL;\n    const BIGNUM *bignum = NULL;\n    CK_BYTE *ssl_ptr = NULL;\n    BIGNUM *e = NULL;\n#ifndef OLDER_OPENSSL\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n#endif\n\n    rc = template_attribute_get_ulong(publ_tmpl, CKA_MODULUS_BITS, &mod_bits);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_TEMPLATE_INCOMPLETE));\n        return CKR_TEMPLATE_INCOMPLETE; // should never happen\n    }\n\n    // we don't support less than 1024 bit keys in the sw\n    if (mod_bits < 512 || mod_bits > 4096) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_KEY_SIZE_RANGE));\n        return CKR_KEY_SIZE_RANGE;\n    }\n\n    rc = template_attribute_get_non_empty(publ_tmpl, CKA_PUBLIC_EXPONENT,\n                                          &publ_exp);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_TEMPLATE_INCOMPLETE));\n        return CKR_TEMPLATE_INCOMPLETE;\n    }\n\n    if (publ_exp->ulValueLen > sizeof(CK_ULONG)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ATTRIBUTE_VALUE_INVALID));\n        return CKR_ATTRIBUTE_VALUE_INVALID;\n    }\n\n    e = BN_new();\n    if (e == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n    BN_bin2bn(publ_exp->pValue, publ_exp->ulValueLen, e);\n\n#ifdef OLDER_OPENSSL\n    rsa = RSA_new();\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (!RSA_generate_key_ex(rsa, mod_bits, e, NULL)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    bignum = rsa->n;\n#else\n    ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_keygen_init(ctx) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (mod_bits > INT_MAX\n        || EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, mod_bits) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, e) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_keygen(ctx, &pkey) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if ((rsa = EVP_PKEY_get0_RSA(pkey)) == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    RSA_get0_key(rsa, &bignum, NULL, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_MODULUS, ssl_ptr, BNLength, &attr);    // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // Public Exponent\n#ifdef OLDER_OPENSSL\n    bignum = rsa->e;\n#else\n    RSA_get0_key(rsa, NULL, &bignum, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    // in bytes\n    rc = build_attribute(CKA_PUBLIC_EXPONENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n\n    /* add public exponent to the private template. Its already an attribute in\n     * the private template at this point, we're just making its value correct\n     */\n    rc = build_attribute(CKA_PUBLIC_EXPONENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // local = TRUE\n    //\n    flag = TRUE;\n    rc = build_attribute(CKA_LOCAL, &flag, sizeof(CK_BBOOL), &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n\n    //\n    // now, do the private key\n    //\n    // Cheat here and put the whole original key into the CKA_VALUE... remember\n    // to force the system to not return this for RSA keys..\n\n    // Add the modulus to the private key information\n#ifdef OLDER_OPENSSL\n    bignum = rsa->n;\n#else\n    RSA_get0_key(rsa, &bignum, NULL, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_MODULUS, ssl_ptr, BNLength, &attr);    // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // Private Exponent\n#ifdef OLDER_OPENSSL\n    bignum = rsa->d;\n#else\n    RSA_get0_key(rsa, NULL, NULL, &bignum);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_PRIVATE_EXPONENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // prime #1: p\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->p;\n#else\n    RSA_get0_factors(rsa, &bignum, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_PRIME_1, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // prime #2: q\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->q;\n#else\n    RSA_get0_factors(rsa, NULL, &bignum);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_PRIME_2, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // exponent 1: d mod(p-1)\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->dmp1;\n#else\n    RSA_get0_crt_params(rsa, &bignum, NULL, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_EXPONENT_1, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // exponent 2: d mod(q-1)\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->dmq1;\n#else\n    RSA_get0_crt_params(rsa, NULL, &bignum, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_EXPONENT_2, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // CRT coefficient:  q_inverse mod(p)\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->iqmp;\n#else\n    RSA_get0_crt_params(rsa, NULL, NULL, &bignum);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_COEFFICIENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    flag = TRUE;\n    rc = build_attribute(CKA_LOCAL, &flag, sizeof(CK_BBOOL), &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n\ndone:\n#ifdef OLDER_OPENSSL\n    if (e != NULL)\n        BN_free(e);\n    if (rsa != NULL)\n        RSA_free(rsa);\n    if (ssl_ptr != NULL) {\n        OPENSSL_cleanse(ssl_ptr, BNLength);\n        free(ssl_ptr);\n    }\n#else\n    if (ssl_ptr != NULL) {\n        OPENSSL_cleanse(ssl_ptr, BNLength);\n        free(ssl_ptr);\n    }\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n#endif\n    return rc;\n}\n\nCK_RV token_specific_rsa_generate_keypair(STDLL_TokData_t *tokdata,\n                                          TEMPLATE *publ_tmpl,\n                                          TEMPLATE *priv_tmpl)\n{\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = os_specific_rsa_keygen(publ_tmpl, priv_tmpl);\n    if (rc != CKR_OK)\n        TRACE_DEVEL(\"os_specific_rsa_keygen failed\\n\");\n\n    return rc;\n}\n\n\nstatic CK_RV os_specific_rsa_encrypt(CK_BYTE *in_data,\n                                     CK_ULONG in_data_len,\n                                     CK_BYTE *out_data, OBJECT *key_obj)\n{\n#ifdef OLDER_OPENSSL\n    CK_RV rc;\n    RSA *rsa;\n    int size;\n\n    // Convert the local representation to an RSA representation\n    rsa = (RSA *) rsa_convert_public_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n    // Do an RSA public encryption\n    size =\n        RSA_public_encrypt(in_data_len, in_data, out_data, rsa, RSA_NO_PADDING);\n    if (size == -1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_ARGUMENTS_BAD;\n        goto done;\n    }\n\n    rc = CKR_OK;\n\ndone:\n    RSA_free(rsa);\n\n    return rc;\n#else\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    RSA *rsa = NULL;\n    CK_RV rc;\n    size_t outlen = in_data_len;\n\n    rsa = (RSA *)rsa_convert_public_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_assign_RSA(pkey, rsa) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    rsa = NULL; /* freed together with pkey */\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_encrypt_init(ctx) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_NO_PADDING) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_encrypt(ctx, out_data, &outlen,\n                         in_data, in_data_len) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = CKR_OK;\ndone:\n    if (rsa != NULL)\n        RSA_free(rsa);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nstatic CK_RV os_specific_rsa_decrypt(CK_BYTE *in_data,\n                                     CK_ULONG in_data_len,\n                                     CK_BYTE *out_data, OBJECT *key_obj)\n{\n#ifdef OLDER_OPENSSL\n    CK_RV rc;\n    RSA *rsa;\n    int size;\n\n    // Convert the local key representation to an RSA key representaion\n    rsa = (RSA *) rsa_convert_private_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n    // Do the private decryption\n    size =\n        RSA_private_decrypt(in_data_len, in_data, out_data, rsa,\n                            RSA_NO_PADDING);\n\n    if (size == -1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = CKR_OK;\n\ndone:\n    RSA_free(rsa);\n\n    return rc;\n#else\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    RSA *rsa = NULL;\n    size_t outlen = in_data_len;\n    CK_RV rc;\n\n    rsa = (RSA *)rsa_convert_private_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_assign_RSA(pkey, rsa) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    rsa = NULL; /* freed together with pkey */\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_decrypt_init(ctx) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_NO_PADDING) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_decrypt(ctx, out_data, &outlen,\n                         in_data, in_data_len) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = CKR_OK;\ndone:\n    if (rsa != NULL)\n        RSA_free(rsa);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_rsa_encrypt(STDLL_TokData_t *tokdata, CK_BYTE *in_data,\n                                 CK_ULONG in_data_len, CK_BYTE *out_data,\n                                 CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_RV rc;\n    CK_ULONG modulus_bytes;\n    CK_BYTE clear[MAX_RSA_KEYLEN], cipher[MAX_RSA_KEYLEN];\n    CK_ATTRIBUTE *attr = NULL;\n\n    /* format the data */\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    }\n    modulus_bytes = attr->ulValueLen;\n\n    rc = rsa_format_block(tokdata, in_data, in_data_len, clear,\n                          modulus_bytes, PKCS_BT_2);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"rsa_format_block failed\\n\");\n        goto done;\n    }\n    // Do an RSA public encryption\n    rc = os_specific_rsa_encrypt(clear, modulus_bytes, cipher, key_obj);\n\n    if (rc == CKR_OK) {\n        memcpy(out_data, cipher, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\ndone:\n    OPENSSL_cleanse(clear, sizeof(clear));\n    return rc;\n}\n\nCK_RV token_specific_rsa_decrypt(STDLL_TokData_t *tokdata, CK_BYTE *in_data,\n                                 CK_ULONG in_data_len, CK_BYTE *out_data,\n                                 CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_RV rc;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n\n    UNUSED(tokdata);\n\n    modulus_bytes = in_data_len;\n\n    rc = os_specific_rsa_decrypt(in_data, modulus_bytes, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n        goto done;\n    }\n\n    rc = rsa_parse_block(out, modulus_bytes, out_data, out_data_len, PKCS_BT_2);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"rsa_parse_block failed\\n\");\n        goto done;\n    }\n\n    /*\n     * For PKCS #1 v1.5 padding, out_data_len must be less than\n     * modulus_bytes - 11.\n     */\n    if (*out_data_len > (modulus_bytes - 11)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ENCRYPTED_DATA_LEN_RANGE));\n        rc = CKR_ENCRYPTED_DATA_LEN_RANGE;\n    }\n\ndone:\n    OPENSSL_cleanse(out, sizeof(out));\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_sign(STDLL_TokData_t *tokdata, SESSION *sess,\n                              CK_BYTE *in_data, CK_ULONG in_data_len,\n                              CK_BYTE *out_data, CK_ULONG *out_data_len,\n                              OBJECT *key_obj)\n{\n    CK_BYTE data[MAX_RSA_KEYLEN], sig[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n    CK_ATTRIBUTE *attr = NULL;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    /* format the data */\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    }\n    modulus_bytes = attr->ulValueLen;\n    rc = rsa_format_block(tokdata, in_data, in_data_len, data,\n                          modulus_bytes, PKCS_BT_1);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"rsa_format_block failed\\n\");\n        return rc;\n    }\n\n    /* signing is a private key operation --> decrypt */\n    rc = os_specific_rsa_decrypt(data, modulus_bytes, sig, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, sig, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n                                CK_BYTE *in_data, CK_ULONG in_data_len,\n                                CK_BYTE *signature, CK_ULONG sig_len,\n                                OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN], out_data[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes, out_data_len;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n    UNUSED(sig_len);\n\n    out_data_len = MAX_RSA_KEYLEN;\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    // verifying is a public key operation --> encrypt\n    //\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n        return rc;\n    }\n\n    rc = rsa_parse_block(out, modulus_bytes, out_data, &out_data_len,\n                         PKCS_BT_1);\n    if (rc == CKR_ENCRYPTED_DATA_INVALID) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    } else if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    if (in_data_len != out_data_len) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    }\n\n    if (CRYPTO_memcmp(in_data, out_data, out_data_len) != 0) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_verify_recover(STDLL_TokData_t *tokdata,\n                                        CK_BYTE *signature, CK_ULONG sig_len,\n                                        CK_BYTE *out_data,\n                                        CK_ULONG *out_data_len,\n                                        OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sig_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    // verifying is a public key operation --> encrypt\n    //\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n        return rc;\n    }\n\n    rc = rsa_parse_block(out, modulus_bytes, out_data, out_data_len, PKCS_BT_1);\n    if (rc == CKR_ENCRYPTED_DATA_INVALID) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    } else if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_pss_sign(STDLL_TokData_t *tokdata, SESSION *sess,\n                                  SIGN_VERIFY_CONTEXT *ctx,\n                                  CK_BYTE *in_data, CK_ULONG in_data_len,\n                                  CK_BYTE *sig, CK_ULONG *sig_len)\n{\n    CK_RV rc;\n    CK_ULONG modbytes;\n    CK_ATTRIBUTE *attr = NULL;\n    OBJECT *key_obj = NULL;\n    CK_BYTE *emdata = NULL;\n    CK_RSA_PKCS_PSS_PARAMS *pssParms = NULL;\n\n    UNUSED(sess);\n\n    /* check the arguments */\n    if (!in_data || !sig) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    if (!ctx) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    pssParms = (CK_RSA_PKCS_PSS_PARAMS *) ctx->mech.pParameter;\n\n    /* get the key */\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n   if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    } else {\n        modbytes = attr->ulValueLen;\n    }\n\n    emdata = (CK_BYTE *) malloc(modbytes);\n    if (emdata == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    rc = emsa_pss_encode(tokdata, pssParms, in_data, in_data_len, emdata,\n                         &modbytes);\n    if (rc != CKR_OK)\n        goto done;\n\n    /* signing is a private key operation --> decrypt  */\n    rc = os_specific_rsa_decrypt(emdata, modbytes, sig, key_obj);\n    if (rc == CKR_OK)\n        *sig_len = modbytes;\n    else\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n\ndone:\n    if (emdata)\n        free(emdata);\n\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_pss_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n                                    SIGN_VERIFY_CONTEXT *ctx,\n                                    CK_BYTE *in_data, CK_ULONG in_data_len,\n                                    CK_BYTE *signature, CK_ULONG sig_len)\n{\n    CK_RV rc;\n    CK_ULONG modbytes;\n    OBJECT *key_obj = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_RSA_PKCS_PSS_PARAMS *pssParms = NULL;\n\n    UNUSED(sess);\n\n    /* check the arguments */\n    if (!in_data || !signature) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    if (!ctx) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    pssParms = (CK_RSA_PKCS_PSS_PARAMS *) ctx->mech.pParameter;\n\n    /* get the key */\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    /* verify is a public key operation ... encrypt */\n    rc = os_specific_rsa_encrypt(signature, sig_len, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n        goto done;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    } else {\n        modbytes = attr->ulValueLen;\n    }\n\n    /* call the pss verify scheme */\n    rc = emsa_pss_verify(tokdata, pssParms, in_data, in_data_len, out,\n                         modbytes);\n\ndone:\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_x509_encrypt(STDLL_TokData_t *tokdata,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE clear[MAX_RSA_KEYLEN], cipher[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    }\n\n    modulus_bytes = attr->ulValueLen;\n\n    // prepad with zeros\n    //\n    memset(clear, 0x0, modulus_bytes - in_data_len);\n    memcpy(&clear[modulus_bytes - in_data_len], in_data, in_data_len);\n\n    rc = os_specific_rsa_encrypt(clear, modulus_bytes, cipher, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, cipher, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\ndone:\n    OPENSSL_cleanse(clear, sizeof(clear));\n    return rc;\n}\n\nCK_RV token_specific_rsa_x509_decrypt(STDLL_TokData_t *tokdata,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(in_data_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    }\n\n    modulus_bytes = attr->ulValueLen;\n\n    rc = os_specific_rsa_decrypt(in_data, modulus_bytes, out, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, out, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n    }\n\ndone:\n    OPENSSL_cleanse(out, sizeof(out));\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_x509_sign(STDLL_TokData_t *tokdata, CK_BYTE *in_data,\n                                   CK_ULONG in_data_len, CK_BYTE *out_data,\n                                   CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE data[MAX_RSA_KEYLEN], sig[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    // prepad with zeros\n    //\n\n    memset(data, 0x0, modulus_bytes - in_data_len);\n    memcpy(&data[modulus_bytes - in_data_len], in_data, in_data_len);\n\n    rc = os_specific_rsa_decrypt(data, modulus_bytes, sig, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, sig, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_x509_verify(STDLL_TokData_t *tokdata,\n                                     CK_BYTE *in_data, CK_ULONG in_data_len,\n                                     CK_BYTE *signature, CK_ULONG sig_len,\n                                     OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sig_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc == CKR_OK) {\n        CK_ULONG pos1, pos2, len;\n        // it should be noted that in_data_len is not necessarily\n        // the same as the modulus length\n        //\n        for (pos1 = 0; pos1 < in_data_len; pos1++)\n            if (in_data[pos1] != 0)\n                break;\n\n        for (pos2 = 0; pos2 < modulus_bytes; pos2++)\n            if (out[pos2] != 0)\n                break;\n\n        // at this point, pos1 and pos2 point to the first non-zero\n        // bytes in the input data and the decrypted signature\n        // (the recovered data), respectively.\n        if ((in_data_len - pos1) != (modulus_bytes - pos2)) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            return CKR_SIGNATURE_INVALID;\n        }\n        len = in_data_len - pos1;\n\n        if (CRYPTO_memcmp(&in_data[pos1], &out[pos2], len) != 0) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            return CKR_SIGNATURE_INVALID;\n        }\n        return CKR_OK;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_x509_verify_recover(STDLL_TokData_t *tokdata,\n                                             CK_BYTE *signature,\n                                             CK_ULONG sig_len,\n                                             CK_BYTE *out_data,\n                                             CK_ULONG *out_data_len,\n                                             OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sig_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, out, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_oaep_encrypt(STDLL_TokData_t *tokdata,\n                                      ENCR_DECR_CONTEXT *ctx,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, CK_BYTE *hash,\n                                      CK_ULONG hlen)\n{\n    CK_RV rc;\n    CK_BYTE cipher[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE *em_data = NULL;\n    OBJECT *key_obj = NULL;\n    CK_RSA_PKCS_OAEP_PARAMS_PTR oaepParms = NULL;\n\n    if (!in_data || !out_data || !hash) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    oaepParms = (CK_RSA_PKCS_OAEP_PARAMS_PTR) ctx->mech.pParameter;\n\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    }\n\n    modulus_bytes = attr->ulValueLen;\n\n    /* pkcs1v2.2, section 7.1.1 Step 2:\n     * EME-OAEP encoding.\n     */\n    em_data = (CK_BYTE *) malloc(modulus_bytes * sizeof(CK_BYTE));\n    if (em_data == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    rc = encode_eme_oaep(tokdata, in_data, in_data_len, em_data,\n                         modulus_bytes, oaepParms->mgf, hash, hlen);\n    if (rc != CKR_OK)\n        goto done;\n\n    rc = os_specific_rsa_encrypt(em_data, modulus_bytes, cipher, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, cipher, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\ndone:\n    if (em_data) {\n        OPENSSL_cleanse(em_data, modulus_bytes * sizeof(CK_BYTE));\n        free(em_data);\n    }\n\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_oaep_decrypt(STDLL_TokData_t *tokdata,\n                                      ENCR_DECR_CONTEXT *ctx,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, CK_BYTE *hash,\n                                      CK_ULONG hlen)\n{\n    CK_RV rc;\n    CK_BYTE *decr_data = NULL;\n    OBJECT *key_obj = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_RSA_PKCS_OAEP_PARAMS_PTR oaepParms = NULL;\n\n    if (!in_data || !out_data || !hash) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    oaepParms = (CK_RSA_PKCS_OAEP_PARAMS_PTR) ctx->mech.pParameter;\n\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto error;\n    }\n\n    *out_data_len = attr->ulValueLen;\n\n    decr_data = (CK_BYTE *) malloc(in_data_len);\n    if (decr_data == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto error;\n    }\n\n    rc = os_specific_rsa_decrypt(in_data, in_data_len, decr_data, key_obj);\n    if (rc != CKR_OK)\n        goto error;\n\n    /* pkcs1v2.2, section 7.1.2 Step 2:\n     * EME-OAEP decoding.\n     */\n    rc = decode_eme_oaep(tokdata, decr_data, in_data_len, out_data,\n                         out_data_len, oaepParms->mgf, hash, hlen);\n\nerror:\n    if (decr_data) {\n        OPENSSL_cleanse(decr_data, in_data_len);\n        free(decr_data);\n    }\n\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\n#ifndef NOAES\n\nCK_RV token_specific_aes_key_gen(STDLL_TokData_t *tokdata, CK_BYTE **key,\n                                 CK_ULONG *len, CK_ULONG keysize,\n                                 CK_BBOOL *is_opaque)\n{\n    *key = malloc(keysize);\n    if (*key == NULL)\n        return CKR_HOST_MEMORY;\n    *len = keysize;\n    *is_opaque = FALSE;\n\n    return rng_generate(tokdata, *key, keysize);\n}\n\nCK_RV token_specific_aes_ecb(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    AES_KEY ssl_aes_key;\n    unsigned int i;\n    CK_ATTRIBUTE *attr = NULL;\n    /* There's a previous check that in_data_len % AES_BLOCK_SIZE == 0,\n     * so this is fine */\n    CK_ULONG loops = (CK_ULONG) (in_data_len / AES_BLOCK_SIZE);\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    memset(&ssl_aes_key, 0, sizeof(AES_KEY));\n\n    // get key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // AES_ecb_encrypt encrypts only a single block, so we have to break up the\n    // input data here\n    if (encrypt) {\n        AES_set_encrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        for (i = 0; i < loops; i++) {\n            AES_ecb_encrypt((unsigned char *) in_data + (i * AES_BLOCK_SIZE),\n                            (unsigned char *) out_data + (i * AES_BLOCK_SIZE),\n                            &ssl_aes_key, AES_ENCRYPT);\n        }\n    } else {\n        AES_set_decrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        for (i = 0; i < loops; i++) {\n            AES_ecb_encrypt((unsigned char *) in_data + (i * AES_BLOCK_SIZE),\n                            (unsigned char *) out_data + (i * AES_BLOCK_SIZE),\n                            &ssl_aes_key, AES_DECRYPT);\n        }\n    }\n    *out_data_len = in_data_len;\n\n    return CKR_OK;\n#else\n    CK_RV rc;\n    int outlen;\n    unsigned char akey[32];\n    const EVP_CIPHER *cipher = NULL;\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_ULONG keylen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        return rc;\n    }\n\n    keylen = attr->ulValueLen;\n    if (keylen == 128 / 8)\n        cipher = EVP_aes_128_ecb();\n    else if (keylen == 192 / 8)\n        cipher = EVP_aes_192_ecb();\n    else if (keylen == 256 / 8)\n        cipher = EVP_aes_256_ecb();\n\n    memcpy(akey, attr->pValue, keylen);\n\n    if (in_data_len % AES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        rc = CKR_DATA_LEN_RANGE;\n        goto done;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, akey, NULL, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(akey, sizeof(akey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_aes_cbc(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    AES_KEY ssl_aes_key;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    memset(&ssl_aes_key, 0, sizeof(AES_KEY));\n\n    // get key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // AES_cbc_encrypt chunks the data into AES_BLOCK_SIZE blocks, unlike\n    // AES_ecb_encrypt, so no looping required.\n    if (encrypt) {\n        AES_set_encrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        AES_cbc_encrypt((unsigned char *) in_data, (unsigned char *) out_data,\n                        in_data_len, &ssl_aes_key, init_v, AES_ENCRYPT);\n    } else {\n        AES_set_decrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        AES_cbc_encrypt((unsigned char *) in_data, (unsigned char *) out_data,\n                        in_data_len, &ssl_aes_key, init_v, AES_DECRYPT);\n    }\n    *out_data_len = in_data_len;\n\n    return CKR_OK;\n#else\n    CK_RV rc;\n    int outlen;\n    unsigned char akey[32];\n    const EVP_CIPHER *cipher = NULL;\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_ULONG keylen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc  != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n\n    keylen = attr->ulValueLen;\n    if (keylen == 128 / 8)\n        cipher = EVP_aes_128_cbc();\n    else if (keylen == 192 / 8)\n        cipher = EVP_aes_192_cbc();\n    else if (keylen == 256 / 8)\n        cipher = EVP_aes_256_cbc();\n\n    memcpy(akey, attr->pValue, keylen);\n\n    if (in_data_len % AES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        rc = CKR_DATA_LEN_RANGE;\n        goto done;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, akey, init_v, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(akey, sizeof(akey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_aes_mac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                             CK_ULONG message_len, OBJECT *key, CK_BYTE *mac)\n{\n    CK_BYTE *out_buf;\n    CK_ULONG out_len;\n    CK_RV rc;\n\n    out_buf = malloc(message_len);\n    if (out_buf == NULL) {\n        TRACE_ERROR(\"Malloc failed.\\n\");\n        return CKR_HOST_MEMORY;\n    }\n\n    rc = token_specific_aes_cbc(tokdata, message, message_len, out_buf,\n                                &out_len, key, mac, 1);\n\n    if (rc == CKR_OK && out_len >= AES_BLOCK_SIZE)\n        memcpy(mac, out_buf + out_len - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n\n    free(out_buf);\n\n    return rc;\n}\n#endif\n\n/* Begin code contributed by Corrent corp. */\n#ifndef NODH\n// This computes DH shared secret, where:\n//     Output: z is computed shared secret\n//     Input:  y is other party's public key\n//             x is private key\n//             p is prime\n// All length's are in number of bytes. All data comes in as Big Endian.\nCK_RV token_specific_dh_pkcs_derive(STDLL_TokData_t *tokdata,\n                                    CK_BYTE *z,\n                                    CK_ULONG *z_len,\n                                    CK_BYTE *y,\n                                    CK_ULONG y_len,\n                                    CK_BYTE *x,\n                                    CK_ULONG x_len, CK_BYTE *p, CK_ULONG p_len)\n{\n    CK_RV rc;\n    BIGNUM *bn_z, *bn_y, *bn_x, *bn_p;\n    BN_CTX *ctx;\n\n    UNUSED(tokdata);\n\n    //  Create and Init the BIGNUM structures.\n    bn_y = BN_new();\n    bn_x = BN_new();\n    bn_p = BN_new();\n    bn_z = BN_new();\n\n    if (bn_z == NULL || bn_p == NULL || bn_x == NULL || bn_y == NULL) {\n        if (bn_y)\n            BN_free(bn_y);\n        if (bn_x)\n            BN_free(bn_x);\n        if (bn_p)\n            BN_free(bn_p);\n        if (bn_z)\n            BN_free(bn_z);\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n    // Initialize context\n    ctx = BN_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n    // Add data into these new BN structures\n\n    BN_bin2bn((unsigned char *) y, y_len, bn_y);\n    BN_bin2bn((unsigned char *) x, x_len, bn_x);\n    BN_bin2bn((unsigned char *) p, p_len, bn_p);\n\n    rc = BN_mod_exp(bn_z, bn_y, bn_x, bn_p, ctx);\n    if (rc == 0) {\n        BN_free(bn_z);\n        BN_free(bn_y);\n        BN_free(bn_x);\n        BN_free(bn_p);\n        BN_CTX_free(ctx);\n\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    *z_len = BN_num_bytes(bn_z);\n    BN_bn2bin(bn_z, z);\n\n    BN_free(bn_z);\n    BN_free(bn_y);\n    BN_free(bn_x);\n    BN_free(bn_p);\n    BN_CTX_free(ctx);\n\n    return CKR_OK;\n}                               /* end token_specific_dh_pkcs_derive() */\n\n// This computes DH key pair, where:\n//     Output: priv_tmpl is generated private key\n//             pub_tmpl is computed public key\n//     Input:  pub_tmpl is public key (prime and generator)\n// All length's are in number of bytes. All data comes in as Big Endian.\nCK_RV token_specific_dh_pkcs_key_pair_gen(STDLL_TokData_t *tokdata,\n                                          TEMPLATE *publ_tmpl,\n                                          TEMPLATE *priv_tmpl)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rv;\n    CK_BBOOL rc;\n    CK_ATTRIBUTE *prime_attr = NULL;\n    CK_ATTRIBUTE *base_attr = NULL;\n    CK_ATTRIBUTE *temp_attr = NULL;\n    CK_ATTRIBUTE *value_bits_attr = NULL;\n    CK_BYTE *temp_byte;\n    CK_ULONG temp_bn_len;\n    DH *dh;\n    BIGNUM *bn_p;\n    BIGNUM *bn_g;\n    const BIGNUM *temp_bn;\n\n    UNUSED(tokdata);\n\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_PRIME, &prime_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_PRIME for the key.\\n\");\n        return rv;\n    }\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_BASE, &base_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_BASE for the key.\\n\");\n        return rv;\n    }\n\n    if ((prime_attr->ulValueLen > 256) || (prime_attr->ulValueLen < 64)) {\n        TRACE_ERROR(\"CKA_PRIME attribute value is invalid.\\n\");\n        return CKR_ATTRIBUTE_VALUE_INVALID;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n    // Create and init BIGNUM structs to stick in the DH struct\n    bn_p = BN_new();\n    bn_g = BN_new();\n    if (bn_g == NULL || bn_p == NULL) {\n        if (bn_g)\n            BN_free(bn_g);\n        if (bn_p)\n            BN_free(bn_p);\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n    // Convert from strings to BIGNUMs and stick them in the DH struct\n    BN_bin2bn((unsigned char *) prime_attr->pValue, prime_attr->ulValueLen,\n              bn_p);\n    BN_bin2bn((unsigned char *) base_attr->pValue, base_attr->ulValueLen, bn_g);\n    dh->p = bn_p;\n    dh->g = bn_g;\n\n    // Generate the DH Key\n    if (!DH_generate_key(dh)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        DH_free(dh);\n        return CKR_FUNCTION_FAILED;\n    }\n    // Extract the public and private key components from the DH struct,\n    // and insert them in the publ_tmpl and priv_tmpl\n\n    //\n    // pub_key\n    //\n    //temp_bn = BN_new();\n    temp_bn = dh->pub_key;\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        free(temp_byte);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(publ_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        free(temp_byte);\n        return rc;\n    }\n    free(temp_byte);\n\n    //\n    // priv_key\n    //\n    //temp_bn = BN_new();\n    temp_bn = dh->priv_key;\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        free(temp_byte);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        free(temp_byte);\n        return rc;\n    }\n    free(temp_byte);\n\n    // Update CKA_VALUE_BITS attribute in the private key\n    value_bits_attr =\n        (CK_ATTRIBUTE *) malloc(sizeof(CK_ATTRIBUTE) + sizeof(CK_ULONG));\n    if (value_bits_attr == NULL) {\n        TRACE_ERROR(\"malloc failed\\n\");\n        DH_free(dh);\n        return CKR_HOST_MEMORY;\n    }\n    value_bits_attr->type = CKA_VALUE_BITS;\n    value_bits_attr->ulValueLen = sizeof(CK_ULONG);\n    value_bits_attr->pValue =\n        (CK_BYTE *) value_bits_attr + sizeof(CK_ATTRIBUTE);\n    *(CK_ULONG *) value_bits_attr->pValue = 8 * temp_bn_len;\n    rc = template_update_attribute(priv_tmpl, value_bits_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(value_bits_attr);\n        DH_free(dh);\n        return rc;\n    }\n\n    // Add prime and base to the private key template\n    rc = build_attribute(CKA_PRIME,\n                         (unsigned char *) prime_attr->pValue,\n                         prime_attr->ulValueLen, &temp_attr);  // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        return rc;\n    }\n\n    rc = build_attribute(CKA_BASE,\n                         (unsigned char *) base_attr->pValue,\n                         base_attr->ulValueLen, &temp_attr);     // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        return rc;\n    }\n\n    // Cleanup DH key\n    DH_free(dh);\n\n    return CKR_OK;\n#else\n    CK_RV rv;\n    CK_BBOOL rc;\n    CK_ATTRIBUTE *prime_attr = NULL;\n    CK_ATTRIBUTE *base_attr = NULL;\n    CK_ATTRIBUTE *temp_attr = NULL;\n    CK_ATTRIBUTE *value_bits_attr = NULL;\n    CK_BYTE *temp_byte = NULL, *temp_byte2 = NULL;\n    CK_ULONG temp_bn_len;\n    DH *dh = NULL;\n    BIGNUM *bn_p = NULL;\n    BIGNUM *bn_g = NULL;\n    const BIGNUM *temp_bn = NULL;\n    EVP_PKEY *params = NULL, *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n\n    UNUSED(tokdata);\n\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_PRIME, &prime_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_PRIME for the key.\\n\");\n        goto done;\n    }\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_BASE, &base_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_BASE for the key.\\n\");\n        goto done;\n    }\n\n    if ((prime_attr->ulValueLen > 256) || (prime_attr->ulValueLen < 64)) {\n        TRACE_ERROR(\"CKA_PRIME attribute value is invalid.\\n\");\n        rv = CKR_ATTRIBUTE_VALUE_INVALID;\n        goto done;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    // Create and init BIGNUM structs to stick in the DH struct\n    bn_p = BN_new();\n    bn_g = BN_new();\n    if (bn_g == NULL || bn_p == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n    // Convert from strings to BIGNUMs and stick them in the DH struct\n    BN_bin2bn((unsigned char *) prime_attr->pValue, prime_attr->ulValueLen,\n              bn_p);\n    BN_bin2bn((unsigned char *) base_attr->pValue, base_attr->ulValueLen, bn_g);\n    DH_set0_pqg(dh, bn_p, NULL, bn_g);\n    /* bn_p and bn_q freed together with dh */\n    bn_p = NULL;\n    bn_g = NULL;\n\n    params = EVP_PKEY_new();\n    if (params == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_assign_DH(params, dh) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    dh = NULL; /* freed together with params */\n\n    ctx = EVP_PKEY_CTX_new(params, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_keygen_init(ctx) != 1\n        || EVP_PKEY_keygen(ctx, &pkey) != 1\n        /* dh is freed together with pkey */\n        || (dh = EVP_PKEY_get0_DH(pkey)) == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    // Extract the public and private key components from the DH struct,\n    // and insert them in the publ_tmpl and priv_tmpl\n\n    //\n    // pub_key\n    //\n    DH_get0_key(dh, &temp_bn, NULL);\n\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    //\n    // priv_key\n    //\n    DH_get0_key(dh, NULL, &temp_bn);\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte2 = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte2);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte2, temp_bn_len, &temp_attr);\n    OPENSSL_cleanse(temp_byte2, temp_bn_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    // Update CKA_VALUE_BITS attribute in the private key\n    value_bits_attr =\n        (CK_ATTRIBUTE *) malloc(sizeof(CK_ATTRIBUTE) + sizeof(CK_ULONG));\n    if (value_bits_attr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n    value_bits_attr->type = CKA_VALUE_BITS;\n    value_bits_attr->ulValueLen = sizeof(CK_ULONG);\n    value_bits_attr->pValue =\n        (CK_BYTE *) value_bits_attr + sizeof(CK_ATTRIBUTE);\n    *(CK_ULONG *) value_bits_attr->pValue = 8 * temp_bn_len;\n    rc = template_update_attribute(priv_tmpl, value_bits_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    // Add prime and base to the private key template\n    rc = build_attribute(CKA_PRIME,\n                         (unsigned char *) prime_attr->pValue,\n                         prime_attr->ulValueLen, &temp_attr);  // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    rc = build_attribute(CKA_BASE,\n                         (unsigned char *) base_attr->pValue,\n                         base_attr->ulValueLen, &temp_attr);     // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    rv = CKR_OK;\ndone:\n    if (bn_g != NULL)\n        BN_free(bn_g);\n    if (bn_p != NULL)\n        BN_free(bn_p);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n    if (params != NULL)\n        EVP_PKEY_free(params);\n    free(temp_byte);\n    free(temp_byte2);\n    return rv;\n#endif\n}                               /* end token_specific_dh_key_pair_gen() */\n#endif\n/* End code contributed by Corrent corp. */\n\nCK_RV token_specific_get_mechanism_list(STDLL_TokData_t *tokdata,\n                                        CK_MECHANISM_TYPE_PTR pMechanismList,\n                                        CK_ULONG_PTR pulCount)\n{\n    return ock_generic_get_mechanism_list(tokdata, pMechanismList, pulCount);\n}\n\nCK_RV token_specific_get_mechanism_info(STDLL_TokData_t *tokdata,\n                                        CK_MECHANISM_TYPE type,\n                                        CK_MECHANISM_INFO_PTR pInfo)\n{\n    return ock_generic_get_mechanism_info(tokdata, type, pInfo);\n}\n\n#ifdef OLDER_OPENSSL\n#define EVP_MD_meth_get_app_datasize(md)        md->ctx_size\n#define EVP_MD_CTX_md_data(ctx)                 ctx->md_data\n#endif\n\nstatic const EVP_MD *md_from_mech(CK_MECHANISM *mech)\n{\n    const EVP_MD *md = NULL;\n\n    switch (mech->mechanism) {\n    case CKM_SHA_1:\n        md = EVP_sha1();\n        break;\n    case CKM_SHA224:\n        md = EVP_sha224();\n        break;\n    case CKM_SHA256:\n        md = EVP_sha256();\n        break;\n    case CKM_SHA384:\n        md = EVP_sha384();\n        break;\n    case CKM_SHA512:\n        md = EVP_sha512();\n        break;\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224:\n        md = EVP_sha512_224();\n        break;\n#endif\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256:\n        md = EVP_sha512_256();\n        break;\n#endif\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224:\n        md = EVP_sha3_224();\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256:\n        md = EVP_sha3_256();\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384:\n        md = EVP_sha3_384();\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512:\n        md = EVP_sha3_512();\n        break;\n#endif\n    default:\n        break;\n    }\n\n    return md;\n}\n\nstatic EVP_MD_CTX *md_ctx_from_context(DIGEST_CONTEXT *ctx)\n{\n    const EVP_MD *md;\n    EVP_MD_CTX *md_ctx;\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    md_ctx = EVP_MD_CTX_create();\n#else\n    md_ctx = EVP_MD_CTX_new();\n#endif\n    if (md_ctx == NULL)\n        return NULL;\n\n    md = md_from_mech(&ctx->mech);\n    if (md == NULL ||\n        !EVP_DigestInit_ex(md_ctx, md, NULL)) {\n        TRACE_ERROR(\"md_from_mech or EVP_DigestInit_ex failed\\n\");\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n        EVP_MD_CTX_destroy(md_ctx);\n#else\n        EVP_MD_CTX_free(md_ctx);\n#endif\n        return NULL;\n    }\n\n    if (ctx->context_len == 0) {\n        ctx->context_len = EVP_MD_meth_get_app_datasize(EVP_MD_CTX_md(md_ctx));\n        ctx->context = malloc(ctx->context_len);\n        if (ctx->context == NULL) {\n            TRACE_ERROR(\"malloc failed\\n\");\n    #if OPENSSL_VERSION_NUMBER < 0x10101000L\n            EVP_MD_CTX_destroy(md_ctx);\n    #else\n            EVP_MD_CTX_free(md_ctx);\n    #endif\n            ctx->context_len = 0;\n            return NULL;\n        }\n\n        /* Save context data for later use */\n        memcpy(ctx->context,  EVP_MD_CTX_md_data(md_ctx), ctx->context_len);\n    } else {\n        if (ctx->context_len !=\n                (CK_ULONG)EVP_MD_meth_get_app_datasize(EVP_MD_CTX_md(md_ctx))) {\n            TRACE_ERROR(\"context size mismatcht\\n\");\n            return NULL;\n        }\n        /* restore the MD context data */\n        memcpy(EVP_MD_CTX_md_data(md_ctx), ctx->context, ctx->context_len);\n    }\n\n    return md_ctx;\n}\n\nCK_RV token_specific_sha_init(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                              CK_MECHANISM *mech)\n{\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    ctx->mech.ulParameterLen = mech->ulParameterLen;\n    ctx->mech.mechanism = mech->mechanism;\n\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_sha(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                         CK_BYTE *in_data, CK_ULONG in_data_len,\n                         CK_BYTE *out_data, CK_ULONG *out_data_len)\n{\n    unsigned int len;\n    CK_RV rc = CKR_OK;\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (!in_data || !out_data)\n        return CKR_ARGUMENTS_BAD;\n\n    /* Recreate the OpenSSL MD context from the saved context */\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (*out_data_len < (CK_ULONG)EVP_MD_CTX_size(md_ctx))\n        return CKR_BUFFER_TOO_SMALL;\n\n    if (!EVP_DigestUpdate(md_ctx, in_data, in_data_len) ||\n        !EVP_DigestFinal(md_ctx, out_data, &len)) {\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    *out_data_len = len;\n\nout:\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n    free(ctx->context);\n    ctx->context = NULL;\n    ctx->context_len = 0;\n\n    return rc;\n}\n\nCK_RV token_specific_sha_update(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                                CK_BYTE *in_data, CK_ULONG in_data_len)\n{\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (!in_data)\n        return CKR_ARGUMENTS_BAD;\n\n    /* Recreate the OpenSSL MD context from the saved context */\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (!EVP_DigestUpdate(md_ctx, in_data, in_data_len)) {\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n        EVP_MD_CTX_destroy(md_ctx);\n#else\n        EVP_MD_CTX_free(md_ctx);\n#endif\n        free(ctx->context);\n        ctx->context = NULL;\n        ctx->context_len = 0;\n        return CKR_FUNCTION_FAILED;\n    }\n\n    /* Save context data for later use */\n    memcpy(ctx->context,  EVP_MD_CTX_md_data(md_ctx), ctx->context_len);\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_sha_final(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                               CK_BYTE *out_data, CK_ULONG *out_data_len)\n{\n    unsigned int len;\n    CK_RV rc = CKR_OK;\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (!out_data)\n        return CKR_ARGUMENTS_BAD;\n\n    /* Recreate the OpenSSL MD context from the saved context */\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (*out_data_len < (CK_ULONG)EVP_MD_CTX_size(md_ctx))\n        return CKR_BUFFER_TOO_SMALL;\n\n    if (!EVP_DigestFinal(md_ctx, out_data, &len)) {\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n    *out_data_len = len;\n\nout:\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n    free(ctx->context);\n    ctx->context = NULL;\n    ctx->context_len = 0;\n\n    return rc;\n}\n\nstatic CK_RV softtok_hmac_init(STDLL_TokData_t *tokdata,\n                               SIGN_VERIFY_CONTEXT *ctx, CK_MECHANISM_PTR mech,\n                               CK_OBJECT_HANDLE Hkey)\n{\n    int rc;\n    OBJECT *key = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    EVP_MD_CTX *mdctx = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    rc = object_mgr_find_in_map1(tokdata, Hkey, &key, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Failed to find specified object.\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        goto done;\n    }\n\n    pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, attr->pValue,\n                                attr->ulValueLen);\n    if (pkey == NULL) {\n        TRACE_ERROR(\"EVP_PKEY_new_mac_key() failed.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    mdctx = EVP_MD_CTX_create();\n    if (mdctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    switch (mech->mechanism) {\n    case CKM_SHA_1_HMAC_GENERAL:\n    case CKM_SHA_1_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha1(), NULL, pkey);\n        break;\n    case CKM_SHA224_HMAC_GENERAL:\n    case CKM_SHA224_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha224(), NULL, pkey);\n        break;\n    case CKM_SHA256_HMAC_GENERAL:\n    case CKM_SHA256_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha256(), NULL, pkey);\n        break;\n    case CKM_SHA384_HMAC_GENERAL:\n    case CKM_SHA384_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha384(), NULL, pkey);\n        break;\n    case CKM_SHA512_HMAC_GENERAL:\n    case CKM_SHA512_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha512(), NULL, pkey);\n        break;\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224_HMAC_GENERAL:\n    case CKM_SHA512_224_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha512_224(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256_HMAC_GENERAL:\n    case CKM_SHA512_256_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha512_256(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_224(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_256(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_384(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_512(), NULL, pkey);\n        break;\n#endif\n    default:\n        EVP_MD_CTX_destroy(mdctx);\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_INVALID));\n        rc = CKR_MECHANISM_INVALID;\n        goto done;\n    }\n\n    if (rc != 1) {\n        EVP_MD_CTX_destroy(mdctx);\n        ctx->context = NULL;\n        TRACE_ERROR(\"EVP_DigestSignInit failed.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    } else {\n        ctx->context = (CK_BYTE *) mdctx;\n    }\n\n    rc = CKR_OK;\ndone:\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n\n    object_put(tokdata, key, TRUE);\n    key = NULL;\n    return rc;\n}\n\nCK_RV token_specific_hmac_sign_init(STDLL_TokData_t *tokdata, SESSION *sess,\n                                    CK_MECHANISM *mech, CK_OBJECT_HANDLE Hkey)\n{\n    return softtok_hmac_init(tokdata, &sess->sign_ctx, mech, Hkey);\n}\n\nCK_RV token_specific_hmac_verify_init(STDLL_TokData_t *tokdata, SESSION *sess,\n                                      CK_MECHANISM *mech,\n                                      CK_OBJECT_HANDLE Hkey)\n{\n    return softtok_hmac_init(tokdata, &sess->verify_ctx, mech, Hkey);\n}\n\nstatic CK_RV softtok_hmac(SIGN_VERIFY_CONTEXT *ctx, CK_BYTE *in_data,\n                          CK_ULONG in_data_len, CK_BYTE *signature,\n                          CK_ULONG *sig_len, CK_BBOOL sign)\n{\n    int rc;\n    size_t mac_len, len;\n    unsigned char mac[MAX_SHA_HASH_SIZE];\n    EVP_MD_CTX *mdctx = NULL;\n    CK_RV rv = CKR_OK;\n    CK_BBOOL general = FALSE;\n\n    if (!ctx || !ctx->context) {\n        TRACE_ERROR(\"%s received bad argument(s)\\n\", __func__);\n        return CKR_FUNCTION_FAILED;\n    }\n\n    if (sign && !sig_len) {\n        TRACE_ERROR(\"%s received bad argument(s)\\n\", __func__);\n        return CKR_FUNCTION_FAILED;\n    }\n\n    switch (ctx->mech.mechanism) {\n    case CKM_SHA_1_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA_1_HMAC:\n        mac_len = SHA1_HASH_SIZE;\n        break;\n    case CKM_SHA224_HMAC_GENERAL:\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224_HMAC_GENERAL:\n#endif\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA224_HMAC:\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224_HMAC:\n#endif\n        mac_len = SHA224_HASH_SIZE;\n        break;\n    case CKM_SHA256_HMAC_GENERAL:\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256_HMAC_GENERAL:\n#endif\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA256_HMAC:\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256_HMAC:\n#endif\n        mac_len = SHA256_HASH_SIZE;\n        break;\n    case CKM_SHA384_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA384_HMAC:\n        mac_len = SHA384_HASH_SIZE;\n        break;\n    case CKM_SHA512_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA512_HMAC:\n        mac_len = SHA512_HASH_SIZE;\n        break;\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224_HMAC:\n        mac_len = SHA3_224_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256_HMAC:\n        mac_len = SHA3_256_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384_HMAC:\n        mac_len = SHA3_384_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512_HMAC:\n        mac_len = SHA3_512_HASH_SIZE;\n        break;\n#endif\n    default:\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_INVALID));\n        return CKR_MECHANISM_INVALID;\n    }\n\n    mdctx = (EVP_MD_CTX *) ctx->context;\n\n    rc = EVP_DigestSignUpdate(mdctx, in_data, in_data_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = EVP_DigestSignFinal(mdctx, mac, &mac_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignFinal failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    if (sign) {\n        if (general)\n            *sig_len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            *sig_len = mac_len;\n\n        memcpy(signature, mac, *sig_len);\n\n    } else {\n        if (general)\n            len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            len = mac_len;\n\n        if (CRYPTO_memcmp(signature, mac, len) != 0) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rv = CKR_SIGNATURE_INVALID;\n        }\n    }\ndone:\n    EVP_MD_CTX_destroy(mdctx);\n    ctx->context = NULL;\n\n    return rv;\n}\n\nCK_RV token_specific_hmac_sign(STDLL_TokData_t *tokdata, SESSION *sess,\n                               CK_BYTE *in_data, CK_ULONG in_data_len,\n                               CK_BYTE *signature, CK_ULONG *sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac(&sess->sign_ctx, in_data, in_data_len, signature,\n                        sig_len, TRUE);\n}\n\nCK_RV token_specific_hmac_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n                                 CK_BYTE *in_data, CK_ULONG in_data_len,\n                                 CK_BYTE *signature, CK_ULONG sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac(&sess->verify_ctx, in_data, in_data_len, signature,\n                        &sig_len, FALSE);\n}\n\nstatic CK_RV softtok_hmac_update(SIGN_VERIFY_CONTEXT *ctx, CK_BYTE *in_data,\n                                 CK_ULONG in_data_len, CK_BBOOL sign)\n{\n    int rc;\n    EVP_MD_CTX *mdctx = NULL;\n    CK_RV rv = CKR_OK;\n\n    UNUSED(sign);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    mdctx = (EVP_MD_CTX *) ctx->context;\n\n    rc = EVP_DigestSignUpdate(mdctx, in_data, in_data_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n    } else {\n        ctx->context = (CK_BYTE *) mdctx;\n        return CKR_OK;\n    }\n\n    EVP_MD_CTX_destroy(mdctx);\n    ctx->context = NULL;\n    return rv;\n}\n\nCK_RV token_specific_hmac_sign_update(STDLL_TokData_t *tokdata, SESSION *sess,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_update(&sess->sign_ctx, in_data, in_data_len, TRUE);\n}\n\nCK_RV token_specific_hmac_verify_update(STDLL_TokData_t *tokdata,\n                                        SESSION *sess, CK_BYTE *in_data,\n                                        CK_ULONG in_data_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_update(&sess->verify_ctx, in_data, in_data_len, FALSE);\n}\n\nstatic CK_RV softtok_hmac_final(SIGN_VERIFY_CONTEXT *ctx, CK_BYTE *signature,\n                                CK_ULONG *sig_len, CK_BBOOL sign)\n{\n    int rc;\n    size_t mac_len, len;\n    unsigned char mac[MAX_SHA_HASH_SIZE];\n    EVP_MD_CTX *mdctx = NULL;\n    CK_RV rv = CKR_OK;\n    CK_BBOOL general = FALSE;\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (sign && !sig_len) {\n        TRACE_ERROR(\"%s received bad argument(s)\\n\", __func__);\n        return CKR_FUNCTION_FAILED;\n    }\n\n    switch (ctx->mech.mechanism) {\n    case CKM_SHA_1_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA_1_HMAC:\n        mac_len = SHA1_HASH_SIZE;\n        break;\n    case CKM_SHA224_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA224_HMAC:\n        mac_len = SHA224_HASH_SIZE;\n        break;\n    case CKM_SHA256_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA256_HMAC:\n        mac_len = SHA256_HASH_SIZE;\n        break;\n    case CKM_SHA384_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA384_HMAC:\n        mac_len = SHA384_HASH_SIZE;\n        break;\n    case CKM_SHA512_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA512_HMAC:\n        mac_len = SHA512_HASH_SIZE;\n        break;\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224_HMAC:\n        mac_len = SHA3_224_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256_HMAC:\n        mac_len = SHA3_256_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384_HMAC:\n        mac_len = SHA3_384_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512_HMAC:\n        mac_len = SHA3_512_HASH_SIZE;\n        break;\n#endif\n    default:\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_INVALID));\n        return CKR_MECHANISM_INVALID;\n    }\n\n    if (signature == NULL) {\n        if (sign) {\n            if (general)\n                *sig_len = *(CK_ULONG *) ctx->mech.pParameter;\n            else\n                *sig_len = (CK_ULONG) mac_len;\n        }\n        return CKR_OK;\n    }\n\n    mdctx = (EVP_MD_CTX *) ctx->context;\n\n    rc = EVP_DigestSignFinal(mdctx, mac, &mac_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignFinal failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    if (sign) {\n        if (general)\n            *sig_len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            *sig_len = mac_len;\n\n        memcpy(signature, mac, *sig_len);\n\n    } else {\n        if (general)\n            len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            len = mac_len;\n\n        if (CRYPTO_memcmp(signature, mac, len) != 0) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rv = CKR_SIGNATURE_INVALID;\n        }\n    }\ndone:\n    EVP_MD_CTX_destroy(mdctx);\n    ctx->context = NULL;\n    return rv;\n}\n\nCK_RV token_specific_hmac_sign_final(STDLL_TokData_t *tokdata, SESSION *sess,\n                                     CK_BYTE *signature, CK_ULONG *sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_final(&sess->sign_ctx, signature, sig_len, TRUE);\n}\n\nCK_RV token_specific_hmac_verify_final(STDLL_TokData_t *tokdata,\n                                       SESSION *sess, CK_BYTE *signature,\n                                       CK_ULONG sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_final(&sess->verify_ctx, signature, &sig_len, FALSE);\n}\n\nCK_RV token_specific_generic_secret_key_gen(STDLL_TokData_t *tokdata,\n                                            TEMPLATE *tmpl)\n{\n    CK_ATTRIBUTE *gkey = NULL;\n    CK_RV rc = CKR_OK;\n    CK_BYTE secret_key[MAX_GENERIC_KEY_SIZE];\n    CK_ULONG key_length = 0;\n    CK_ULONG key_length_in_bits = 0;\n\n    rc = template_attribute_get_ulong(tmpl, CKA_VALUE_LEN, &key_length);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"CKA_VALUE_LEN missing in (HMAC) key template\\n\");\n        return CKR_TEMPLATE_INCOMPLETE;\n    }\n\n    //app specified key length in bytes\n    key_length_in_bits = key_length * 8;\n\n    /* After looking at fips cavs test vectors for HMAC ops,\n     * it was decided that the key length should fall between\n     * 80 and 2048 bits inclusive. openssl does not explicitly\n     * specify limits to key sizes for secret keys\n     */\n    if ((key_length_in_bits < 80) || (key_length_in_bits > 2048)) {\n        TRACE_ERROR(\"Generic secret key size of %lu bits not within\"\n                    \" required range of 80-2048 bits\\n\", key_length_in_bits);\n        return CKR_KEY_SIZE_RANGE;\n    }\n\n    rc = rng_generate(tokdata, secret_key, key_length);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"Generic secret key generation failed.\\n\");\n        return rc;\n    }\n\n    rc = build_attribute(CKA_VALUE, secret_key, key_length, &gkey);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute(CKA_VALUE) failed\\n\");\n        return rc;\n    }\n\n    rc = template_update_attribute(tmpl, gkey);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"template_update_attribute(CKA_VALUE) failed.\\n\");\n        free(gkey);\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_tdes_cmac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                               CK_ULONG message_len, OBJECT *key, CK_BYTE *mac,\n                               CK_BBOOL first, CK_BBOOL last, CK_VOID_PTR *ctx)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    int rc;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_KEY_TYPE keytype;\n    CMAC_CTX *cmac_ctx;\n    const EVP_CIPHER *cipher;\n    size_t maclen;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        // get the key type\n        rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key.\\n\");\n            return CKR_FUNCTION_FAILED;\n        }\n\n        // get the key value\n        rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n            return rc;\n        }\n        switch (keytype) {\n        case CKK_DES2:\n            cipher = EVP_des_ede_cbc();\n            break;\n        case CKK_DES3:\n            cipher = EVP_des_ede3_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key type: %lu\\n\", keytype);\n            return CKR_KEY_TYPE_INCONSISTENT;\n        }\n        if (cipher == NULL) {\n            TRACE_ERROR(\"Failed to allocate cipher\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        cmac_ctx = CMAC_CTX_new();\n        if (cmac_ctx == NULL) {\n            TRACE_ERROR(\"Failed to allocate CMAC context\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        rc = CMAC_Init(cmac_ctx, attr->pValue, attr->ulValueLen, cipher, NULL);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Init failed\\n\");\n            CMAC_CTX_free(cmac_ctx);\n            return CKR_FUNCTION_FAILED;\n        }\n\n        *ctx = cmac_ctx;\n    }\n\n    cmac_ctx = (CMAC_CTX *)*ctx;\n\n    rc = CMAC_Update(cmac_ctx, message, message_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"CMAC_Update failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n        rc = CMAC_Final(cmac_ctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Final failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n        }\n    }\n\n    if (last || (first && rv != CKR_OK)) {\n        CMAC_CTX_free(cmac_ctx);\n        *ctx = NULL;\n    }\n\n    return rv;\n#else\n    int rc;\n    size_t maclen;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_KEY_TYPE keytype;\n    const EVP_CIPHER *cipher;\n    struct cmac_ctx {\n        EVP_MD_CTX *mctx;\n        EVP_PKEY_CTX *pctx;\n        EVP_PKEY *pkey;\n    };\n    struct cmac_ctx *cmac = NULL;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        // get the key type\n        rv = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n        if (rv != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n            return rv;\n        }\n\n        // get the key value\n        rv = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rv != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n            return rv;\n        }\n\n        switch (keytype) {\n        case CKK_DES2:\n            cipher = EVP_des_ede_cbc();\n            break;\n        case CKK_DES3:\n            cipher = EVP_des_ede3_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key type: %lu\\n\", keytype);\n            rv = CKR_KEY_TYPE_INCONSISTENT;\n            goto err;\n        }\n\n        cmac = calloc(1, sizeof(*cmac));\n        if (cmac == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->mctx = EVP_MD_CTX_new();\n        if (cmac->mctx == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->pkey = EVP_PKEY_new_CMAC_key(NULL,\n                                           attr->pValue, attr->ulValueLen,\n                                           cipher);\n        if (cmac->pkey == NULL) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        if (EVP_DigestSignInit(cmac->mctx, &cmac->pctx,\n                               NULL, NULL, cmac->pkey) != 1) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        *ctx = cmac;\n    }\n\n    cmac = (struct cmac_ctx *)*ctx;\n    if (cmac == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    rc = EVP_DigestSignUpdate(cmac->mctx, message, message_len);\n    if (rc != 1 || message_len > INT_MAX) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n\n        rc = EVP_DigestSignFinal(cmac->mctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n        *ctx = NULL;\n    }\n\n    return CKR_OK;\nerr:\n    if (cmac != NULL) {\n        if (cmac->mctx != NULL)\n            EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        if (cmac->pkey != NULL)\n            EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n    }\n    *ctx = NULL;\n    return rv;\n#endif\n}\n\n\nCK_RV token_specific_aes_cmac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                              CK_ULONG message_len, OBJECT *key, CK_BYTE *mac,\n                              CK_BBOOL first, CK_BBOOL last, CK_VOID_PTR *ctx)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    int rc;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    CMAC_CTX *cmac_ctx;\n    const EVP_CIPHER *cipher;\n    size_t maclen;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n            return rc;\n        }\n\n        switch (attr->ulValueLen * 8) {\n        case 128:\n            cipher = EVP_aes_128_cbc();\n            break;\n        case 192:\n            cipher = EVP_aes_192_cbc();\n            break;\n        case 256:\n            cipher = EVP_aes_256_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key size: %lu\\n\", attr->ulValueLen);\n            return CKR_KEY_TYPE_INCONSISTENT;\n        }\n        if (cipher == NULL) {\n            TRACE_ERROR(\"Failed to allocate cipher\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        cmac_ctx = CMAC_CTX_new();\n        if (cmac_ctx == NULL) {\n            TRACE_ERROR(\"Failed to allocate CMAC context\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        rc = CMAC_Init(cmac_ctx, attr->pValue, attr->ulValueLen, cipher, NULL);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Init failed\\n\");\n            CMAC_CTX_free(cmac_ctx);\n            return CKR_FUNCTION_FAILED;\n        }\n\n        *ctx = cmac_ctx;\n    }\n\n    cmac_ctx = (CMAC_CTX *)*ctx;\n\n    rc = CMAC_Update(cmac_ctx, message, message_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"CMAC_Update failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n        rc = CMAC_Final(cmac_ctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Final failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n        }\n    }\n\n    if (last || (first && rv != CKR_OK)) {\n        CMAC_CTX_free(cmac_ctx);\n        *ctx = NULL;\n    }\n\n    return rv;\n#else\n    int rc;\n    size_t maclen;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    const EVP_CIPHER *cipher;\n    struct cmac_ctx {\n        EVP_MD_CTX *mctx;\n        EVP_PKEY_CTX *pctx;\n        EVP_PKEY *pkey;\n    };\n    struct cmac_ctx *cmac = NULL;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        // get the key value\n        rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n            goto err;\n        }\n\n        switch (attr->ulValueLen * 8) {\n        case 128:\n            cipher = EVP_aes_128_cbc();\n            break;\n        case 192:\n            cipher = EVP_aes_192_cbc();\n            break;\n        case 256:\n            cipher = EVP_aes_256_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key size: %lu\\n\", attr->ulValueLen);\n            return CKR_KEY_TYPE_INCONSISTENT;\n        }\n\n        cmac = calloc(1, sizeof(*cmac));\n        if (cmac == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->mctx = EVP_MD_CTX_new();\n        if (cmac->mctx == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->pkey = EVP_PKEY_new_CMAC_key(NULL,\n                                           attr->pValue, attr->ulValueLen,\n                                           cipher);\n        if (cmac->pkey == NULL) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        if (EVP_DigestSignInit(cmac->mctx, &cmac->pctx,\n                               NULL, NULL, cmac->pkey) != 1) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        *ctx = cmac;\n    }\n\n    cmac = (struct cmac_ctx *)*ctx;\n    if (cmac == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    rc = EVP_DigestSignUpdate(cmac->mctx, message, message_len);\n    if (rc != 1 || message_len > INT_MAX) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n\n        rc = EVP_DigestSignFinal(cmac->mctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n        *ctx = NULL;\n    }\n\n    return CKR_OK;\nerr:\n    if (cmac != NULL) {\n        if (cmac->mctx != NULL)\n            EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        if (cmac->pkey != NULL)\n            EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n    }\n    *ctx = NULL;\n    return rv;\n#endif\n}\n\n#ifndef NO_EC\n\nstatic CK_RV make_ec_key_from_params(const CK_BYTE *params, CK_ULONG params_len,\n                                     EC_KEY **key)\n{\n    const unsigned char *oid;\n    ASN1_OBJECT *obj = NULL;\n    EC_KEY *ec_key = NULL;\n    int nid;\n    CK_RV rc = CKR_OK;\n\n    oid = params;\n    obj = d2i_ASN1_OBJECT(NULL, &oid, params_len);\n    if (obj == NULL) {\n        TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");\n        rc = CKR_CURVE_NOT_SUPPORTED;\n        goto out;\n    }\n\n    nid = OBJ_obj2nid(obj);\n    if (nid == NID_undef) {\n        TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");\n        rc = CKR_CURVE_NOT_SUPPORTED;\n        goto out;\n    }\n\n    ec_key = EC_KEY_new_by_curve_name(nid);\n    if (ec_key == NULL) {\n       TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");\n       rc = CKR_CURVE_NOT_SUPPORTED;\n       goto out;\n    }\n\nout:\n    if (obj != NULL)\n        ASN1_OBJECT_free(obj);\n\n    if (rc != CKR_OK) {\n        if (ec_key != NULL)\n            EC_KEY_free(ec_key);\n\n        return rc;\n    }\n\n    *key = ec_key;\n\n    return CKR_OK;\n}\n\nstatic CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                     CK_ULONG data_len, CK_BBOOL allow_raw)\n{\n    CK_BYTE *ecpoint = NULL;\n    CK_ULONG ecpoint_len, privlen;\n    CK_BBOOL allocated = FALSE;\n    CK_RV rc;\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,\n                                   &allocated, &ecpoint, &ecpoint_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");\n        goto out;\n    }\n\n    if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {\n        TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\nout:\n    if (allocated && ecpoint != NULL)\n        free(ecpoint);\n\n    return rc;\n}\n\nstatic CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                      CK_ULONG data_len)\n{\n    EC_POINT *point = NULL;\n    CK_RV rc = CKR_OK;\n\n    if (!EC_KEY_oct2priv(ec_key, data, data_len)) {\n        TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    point = EC_POINT_new(EC_KEY_get0_group(ec_key));\n    if (point == NULL) {\n        TRACE_ERROR(\"EC_POINT_new failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,\n                      EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {\n        TRACE_ERROR(\"EC_POINT_mul failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_set_public_key(ec_key, point)) {\n        TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\nout:\n    if (point != NULL)\n        EC_POINT_free(point);\n\n    return rc;\n}\n\nstatic CK_RV make_ec_key_from_template(TEMPLATE *template, EC_KEY **key)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_OBJECT_CLASS keyclass;\n    EC_KEY *ec_key = NULL;\n    CK_RV rc;\n\n    rc = template_attribute_get_ulong(template, CKA_CLASS, &keyclass);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_CLASS in the template\\n\");\n        goto out;\n    }\n\n    rc = template_attribute_get_non_empty(template, CKA_ECDSA_PARAMS, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_ECDSA_PARAMS in the template\\n\");\n        goto out;\n    }\n\n    rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);\n    if (rc != CKR_OK)\n        goto out;\n\n    switch (keyclass) {\n    case CKO_PUBLIC_KEY:\n        rc = template_attribute_get_non_empty(template, CKA_EC_POINT, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_EC_POINT in the template\\n\");\n            goto out;\n        }\n\n        rc = fill_ec_key_from_pubkey(ec_key, attr->pValue, attr->ulValueLen,\n                                     FALSE);\n        if (rc != CKR_OK) {\n            TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");\n            goto out;\n        }\n        break;\n\n    case CKO_PRIVATE_KEY:\n        rc = template_attribute_get_non_empty(template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE in the template\\n\");\n            goto out;\n        }\n\n        rc = fill_ec_key_from_privkey(ec_key, attr->pValue, attr->ulValueLen);\n        if (rc != CKR_OK) {\n            TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");\n            goto out;\n        }\n        break;\n\n    default:\n        rc = CKR_KEY_FUNCTION_NOT_PERMITTED;\n        goto out;\n    }\n\n    rc = CKR_OK;\n\nout:\n    if (rc != CKR_OK) {\n        if (ec_key != NULL)\n            EC_KEY_free(ec_key);\n\n        return rc;\n    }\n\n    *key = ec_key;\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_ec_generate_keypair(STDLL_TokData_t *tokdata,\n                                         TEMPLATE *publ_tmpl,\n                                         TEMPLATE *priv_tmpl)\n{\n\n    CK_ATTRIBUTE *attr = NULL, *ec_point_attr, *value_attr, *parms_attr;\n    EC_KEY *ec_key = NULL;\n    BN_CTX *ctx = NULL;\n    CK_BYTE *ecpoint = NULL, *enc_ecpoint = NULL, *d = NULL;\n    CK_ULONG ecpoint_len, enc_ecpoint_len, d_len;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = template_attribute_get_non_empty(publ_tmpl, CKA_ECDSA_PARAMS, &attr);\n    if (rc != CKR_OK)\n        goto out;\n\n    rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);\n    if (rc != CKR_OK)\n        goto out;\n\n    if (!EC_KEY_generate_key(ec_key)) {\n        TRACE_ERROR(\"Failed to generate an EC key.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL) {\n        rc = CKR_HOST_MEMORY;\n        goto out;\n    }\n\n    ecpoint_len = EC_KEY_key2buf(ec_key, POINT_CONVERSION_UNCOMPRESSED,\n                                 &ecpoint, ctx);\n    if (ecpoint_len == 0) {\n        TRACE_ERROR(\"Failed to get the EC Point compressed.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    rc = ber_encode_OCTET_STRING(FALSE, &enc_ecpoint, &enc_ecpoint_len,\n                                 ecpoint, ecpoint_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"ber_encode_OCTET_STRING failed\\n\");\n        goto out;\n    }\n\n    rc = build_attribute(CKA_EC_POINT, enc_ecpoint, enc_ecpoint_len,\n                         &ec_point_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"build_attribute for CKA_EC_POINT failed rc=0x%lx\\n\", rc);\n        goto out;\n    }\n    rc = template_update_attribute(publ_tmpl, ec_point_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(ec_point_attr);\n        goto out;\n    }\n\n    d_len = EC_KEY_priv2buf(ec_key, &d);\n    if (d_len == 0) {\n        TRACE_ERROR(\"Failed to get the EC private key.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    rc = build_attribute(CKA_VALUE, d, d_len, &value_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"build_attribute for CKA_VALUE failed, rc=0x%lx\\n\", rc);\n        goto out;\n    }\n    rc = template_update_attribute(priv_tmpl, value_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(value_attr);\n        goto out;\n    }\n\n\n    /* Add CKA_ECDSA_PARAMS to private template also */\n    rc = build_attribute(CKA_ECDSA_PARAMS, attr->pValue, attr->ulValueLen,\n                         &parms_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"build_attribute for CKA_ECDSA_PARAMS failed, rc=0x%lx\\n\",\n                     rc);\n        goto out;\n    }\n    rc = template_update_attribute(priv_tmpl, parms_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(parms_attr);\n        goto out;\n    }\n\n    rc = CKR_OK;\n\nout:\n    if (ctx)\n        BN_CTX_free(ctx);\n    if (ec_key != NULL)\n        EC_KEY_free(ec_key);\n    if (ecpoint != NULL)\n        OPENSSL_free(ecpoint);\n    if (enc_ecpoint != NULL)\n        free(enc_ecpoint);\n    if (d != NULL)\n        OPENSSL_free(d);\n\n    return rc;\n}\n\nCK_RV token_specific_ec_sign(STDLL_TokData_t *tokdata,  SESSION *sess,\n                             CK_BYTE *in_data, CK_ULONG in_data_len,\n                             CK_BYTE *out_data, CK_ULONG *out_data_len,\n                             OBJECT *key_obj)\n{\n    EC_KEY *ec_key;\n    ECDSA_SIG *sig;\n    const BIGNUM *r, *s;\n    CK_ULONG privlen, n;\n    CK_RV rc = CKR_OK;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    *out_data_len = 0;\n\n    rc = make_ec_key_from_template(key_obj->template, &ec_key);\n    if (rc != CKR_OK)\n        return rc;\n\n    sig = ECDSA_do_sign(in_data, in_data_len, ec_key);\n    if (sig == NULL) {\n        TRACE_ERROR(\"ECDSA_do_sign failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    ECDSA_SIG_get0(sig, &r, &s);\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    /* Insert leading 0x00's if r or s shorter than privlen */\n    n = privlen - BN_num_bytes(r);\n    memset(out_data, 0x00, n);\n    BN_bn2bin(r, &out_data[n]);\n\n    n = privlen - BN_num_bytes(s);\n    memset(out_data + privlen, 0x00, n);\n    BN_bn2bin(s, &out_data[privlen + n]);\n\n    *out_data_len = 2 * privlen;\n\nout:\n    if (sig != NULL)\n        ECDSA_SIG_free(sig);\n    if (ec_key != NULL)\n        EC_KEY_free(ec_key);\n\n    return rc;\n}\n\nCK_RV token_specific_ec_verify(STDLL_TokData_t *tokdata,\n                               SESSION *sess,\n                               CK_BYTE *in_data,\n                               CK_ULONG in_data_len,\n                               CK_BYTE *signature,\n                               CK_ULONG signature_len, OBJECT *key_obj)\n{\n    EC_KEY *ec_key;\n    CK_ULONG privlen;\n    ECDSA_SIG *sig = NULL;\n    BIGNUM *r = NULL, *s = NULL;\n    CK_RV rc = CKR_OK;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    rc = make_ec_key_from_template(key_obj->template, &ec_key);\n    if (rc != CKR_OK)\n        return rc;\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    if (signature_len < 2 * privlen) {\n        TRACE_ERROR(\"Signature is too short\\n\");\n        rc = CKR_SIGNATURE_LEN_RANGE;\n        goto out;\n    }\n\n    sig = ECDSA_SIG_new();\n    if (sig == NULL) {\n        rc = CKR_HOST_MEMORY;\n        goto out;\n    }\n\n    r = BN_bin2bn(signature, privlen, NULL);\n    s = BN_bin2bn(signature + privlen, privlen, NULL);\n    if (r == NULL || s == NULL) {\n        TRACE_ERROR(\"BN_bin2bn failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!ECDSA_SIG_set0(sig, r, s)) {\n        TRACE_ERROR(\"ECDSA_SIG_set0 failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    rc = ECDSA_do_verify(in_data, in_data_len, sig, ec_key);\n    switch (rc) {\n    case 0:\n        rc = CKR_SIGNATURE_INVALID;\n        break;\n    case 1:\n        rc = CKR_OK;\n        break;\n    default:\n        rc = CKR_FUNCTION_FAILED;\n        break;\n    }\n\nout:\n    if (sig != NULL)\n        ECDSA_SIG_free(sig);\n    if (ec_key != NULL)\n        EC_KEY_free(ec_key);\n\n    return rc;\n}\n\nCK_RV token_specific_ecdh_pkcs_derive(STDLL_TokData_t *tokdata,\n                                      CK_BYTE *priv_bytes,\n                                      CK_ULONG priv_length,\n                                      CK_BYTE *pub_bytes,\n                                      CK_ULONG pub_length,\n                                      CK_BYTE *secret_value,\n                                      CK_ULONG *secret_value_len,\n                                      CK_BYTE *oid, CK_ULONG oid_length)\n{\n    EC_KEY *ec_pub = NULL, *ec_priv = NULL;\n    CK_ULONG privlen;\n    int secret_len;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = make_ec_key_from_params(oid, oid_length, &ec_priv);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");\n        goto out;\n    }\n\n    rc = fill_ec_key_from_privkey(ec_priv, priv_bytes, priv_length);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");\n        goto out;\n    }\n\n    rc = make_ec_key_from_params(oid, oid_length, &ec_pub);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");\n        goto out;\n    }\n\n    rc = fill_ec_key_from_pubkey(ec_pub, pub_bytes, pub_length, TRUE);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");\n        goto out;\n    }\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_priv)) + 7) / 8;\n\n    secret_len = ECDH_compute_key(secret_value, privlen,\n                                  EC_KEY_get0_public_key(ec_pub), ec_priv,\n                                  NULL);\n    if (secret_len <= 0) {\n        TRACE_DEVEL(\"ECDH_compute_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        *secret_value_len = 0;\n        goto out;\n    }\n\n    *secret_value_len = secret_len;\n\nout:\n    if (ec_priv != NULL)\n        EC_KEY_free(ec_priv);\n    if (ec_pub != NULL)\n        EC_KEY_free(ec_pub);\n\n    return rc;\n}\n\n#endif\n\nCK_RV token_specific_object_add(STDLL_TokData_t * tokdata, SESSION * sess,\n                                OBJECT * obj)\n{\n    CK_KEY_TYPE keytype;\n#ifndef NO_EC\n    EC_KEY *ec_key = NULL;\n#endif\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    rc = template_attribute_get_ulong(obj->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK)\n        return CKR_OK;\n\n    switch (keytype) {\n#ifndef NO_EC\n    case CKK_EC:\n        /* Check if OpenSSL supports the curve */\n        rc = make_ec_key_from_template(obj->template, &ec_key);\n        if (ec_key != NULL)\n                EC_KEY_free(ec_key);\n        return rc;\n#endif\n\n    default:\n        return CKR_OK;;\n    }\n}\n\n"], "fixing_code": ["/*\n * COPYRIGHT (c) International Business Machines Corp. 2001-2017\n *\n * This program is provided under the terms of the Common Public License,\n * version 1.0 (CPL-1.0). Any use, reproduction or distribution for this\n * software constitutes recipient's acceptance of CPL-1.0 terms which can be\n * found in the file LICENSE file or at\n * https://opensource.org/licenses/cpl1.0.php\n */\n\n/***************************************************************************\n                          Change Log\n                          ==========\n       4/25/03    Kapil Sood (kapil@corrent.com)\n                  Added DH key pair generation and DH shared key derivation\n                  functions.\n\n\n\n****************************************************************************/\n\n#include <pthread.h>\n#include <string.h>             // for memcmp() et al\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <openssl/opensslv.h>\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n#define NO_EC 1\n#endif\n\n#include \"pkcs11types.h\"\n#include \"defs.h\"\n#include \"host_defs.h\"\n#include \"h_extern.h\"\n#include \"errno.h\"\n#include \"tok_specific.h\"\n#include \"tok_struct.h\"\n#include \"trace.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <endian.h>\n\n#include <openssl/des.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#include <openssl/dh.h>\n#include <openssl/aes.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/crypto.h>\n#include <openssl/cmac.h>\n#include <openssl/ec.h>\n\n/*\n * In order to make opencryptoki compatible with\n * OpenSSL 1.1 API Changes and backward compatible\n * we need to check for its version\n */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#define OLDER_OPENSSL\n#endif\n\n#define MAX_GENERIC_KEY_SIZE 256\n\nconst char manuf[] = \"IBM\";\nconst char model[] = \"Soft\";\nconst char descr[] = \"IBM Soft token\";\nconst char label[] = \"softtok\";\n\nstatic const MECH_LIST_ELEMENT soft_mech_list[] = {\n    {CKM_RSA_PKCS_KEY_PAIR_GEN, {512, 4096, CKF_GENERATE_KEY_PAIR}},\n#if !(NODSA)\n    {CKM_DSA_KEY_PAIR_GEN, {512, 1024, CKF_GENERATE_KEY_PAIR}},\n#endif\n    {CKM_DES_KEY_GEN, {8, 8, CKF_GENERATE}},\n    {CKM_DES3_KEY_GEN, {24, 24, CKF_GENERATE}},\n#if !(NOCDMF)\n    {CKM_CDMF_KEY_GEN, {0, 0, CKF_GENERATE}},\n#endif\n    {CKM_RSA_PKCS,\n     {512, 4096, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP | CKF_SIGN |\n      CKF_VERIFY | CKF_SIGN_RECOVER | CKF_VERIFY_RECOVER}},\n    {CKM_SHA1_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA224_RSA_PKCS, {1024, 4096, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA256_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_RSA_PKCS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA1_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA224_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA256_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_RSA_PKCS_PSS, {1024, 4096, CKF_SIGN | CKF_VERIFY}},\n#if !(NOX509)\n    {CKM_RSA_X_509,\n     {512, 4096, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP | CKF_SIGN |\n      CKF_VERIFY | CKF_SIGN_RECOVER | CKF_VERIFY_RECOVER}},\n#endif\n    {CKM_RSA_PKCS_OAEP,\n     {1024, 4096, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n#if !(NOMD2)\n    {CKM_MD2_RSA_PKCS, {512, 4096, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOMD5)\n    {CKM_MD5_RSA_PKCS, {512, 4096, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOSHA1)\n    {CKM_SHA1_RSA_PKCS, {512, 4096, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NODSA)\n    {CKM_DSA, {512, 1024, CKF_SIGN | CKF_VERIFY}},\n#endif\n/* Begin code contributed by Corrent corp. */\n#if !(NODH)\n    {CKM_DH_PKCS_DERIVE, {512, 2048, CKF_DERIVE}},\n    {CKM_DH_PKCS_KEY_PAIR_GEN, {512, 2048, CKF_GENERATE_KEY_PAIR}},\n#endif\n/* End code contributed by Corrent corp. */\n    {CKM_DES_ECB, {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES_CBC, {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES_CBC_PAD,\n     {8, 8, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n#if !(NOCDMF)\n    {CKM_CDMF_ECB, {0, 0, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_CDMF_CBC, {0, 0, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n#endif\n    {CKM_DES3_ECB, {24, 24, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES3_CBC, {24, 24, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES3_CBC_PAD,\n     {24, 24, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_DES3_MAC, {16, 24, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_DES3_MAC_GENERAL, {16, 24, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_DES3_CMAC, {16, 24, CKF_SIGN | CKF_VERIFY}},\n    {CKM_DES3_CMAC_GENERAL, {16, 24, CKF_SIGN | CKF_VERIFY}},\n#if !(NOSHA1)\n    {CKM_SHA_1, {0, 0, CKF_DIGEST}},\n    {CKM_SHA_1_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA_1_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n    {CKM_SHA224, {0, 0, CKF_DIGEST}},\n    {CKM_SHA224_HMAC, {0, 0, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA224_HMAC_GENERAL, {0, 0, CKF_SIGN|CKF_VERIFY}},\n    {CKM_SHA256, {0, 0, CKF_DIGEST}},\n    {CKM_SHA256_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA256_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384, {0, 0, CKF_DIGEST}},\n    {CKM_SHA384_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA384_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512, {0, 0, CKF_DIGEST}},\n    {CKM_SHA512_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#ifdef NID_sha512_224WithRSAEncryption\n    {CKM_SHA512_224, {0, 0, CKF_DIGEST}},\n    {CKM_SHA512_224_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_224_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha512_256WithRSAEncryption\n    {CKM_SHA512_256, {0, 0, CKF_DIGEST}},\n    {CKM_SHA512_256_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SHA512_256_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_224\n    {CKM_IBM_SHA3_224, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_224_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_256\n    {CKM_IBM_SHA3_256, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_256_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_384\n    {CKM_IBM_SHA3_384, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_384_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#ifdef NID_sha3_512\n    {CKM_IBM_SHA3_512, {0, 0, CKF_DIGEST}},\n    {CKM_IBM_SHA3_512_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOMD2)\n    {CKM_MD2, {0, 0, CKF_DIGEST}},\n    {CKM_MD2_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_MD2_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n#if !(NOMD5)\n    {CKM_MD5, {0, 0, CKF_DIGEST}},\n    {CKM_MD5_HMAC, {0, 0, CKF_SIGN | CKF_VERIFY}},\n    {CKM_MD5_HMAC_GENERAL, {0, 0, CKF_SIGN | CKF_VERIFY}},\n#endif\n    {CKM_SSL3_PRE_MASTER_KEY_GEN, {48, 48, CKF_GENERATE}},\n    {CKM_SSL3_MASTER_KEY_DERIVE, {48, 48, CKF_DERIVE}},\n    {CKM_SSL3_KEY_AND_MAC_DERIVE, {48, 48, CKF_DERIVE}},\n    {CKM_SSL3_MD5_MAC, {384, 384, CKF_SIGN | CKF_VERIFY}},\n    {CKM_SSL3_SHA1_MAC, {384, 384, CKF_SIGN | CKF_VERIFY}},\n#if !(NOAES)\n    {CKM_AES_KEY_GEN, {16, 32, CKF_GENERATE}},\n    {CKM_AES_ECB, {16, 32, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_AES_CBC, {16, 32, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_AES_CBC_PAD,\n     {16, 32, CKF_ENCRYPT | CKF_DECRYPT | CKF_WRAP | CKF_UNWRAP}},\n    {CKM_AES_MAC, {16, 32, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_AES_MAC_GENERAL, {16, 32, CKF_HW | CKF_SIGN | CKF_VERIFY}},\n    {CKM_AES_CMAC, {16, 32, CKF_SIGN | CKF_VERIFY}},\n    {CKM_AES_CMAC_GENERAL, {16, 32, CKF_SIGN | CKF_VERIFY}},\n#endif\n    {CKM_GENERIC_SECRET_KEY_GEN, {80, 2048, CKF_GENERATE}},\n#if !(NO_EC)\n    {CKM_EC_KEY_PAIR_GEN, {160, 521, CKF_GENERATE_KEY_PAIR |\n                           CKF_EC_NAMEDCURVE | CKF_EC_F_P}},\n    {CKM_ECDSA, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                 CKF_EC_F_P}},\n    {CKM_ECDSA_SHA1, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                      CKF_EC_F_P}},\n    {CKM_ECDSA_SHA224, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDSA_SHA256, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDSA_SHA384, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDSA_SHA512, {160, 521, CKF_SIGN | CKF_VERIFY | CKF_EC_NAMEDCURVE |\n                        CKF_EC_F_P}},\n    {CKM_ECDH1_DERIVE, {160, 521, CKF_DERIVE | CKF_EC_NAMEDCURVE | CKF_EC_F_P}},\n#endif\n};\n\nstatic const CK_ULONG soft_mech_list_len =\n                    (sizeof(soft_mech_list) / sizeof(MECH_LIST_ELEMENT));\n\nCK_RV token_specific_init(STDLL_TokData_t *tokdata, CK_SLOT_ID SlotNumber,\n                          char *conf_name)\n{\n    UNUSED(conf_name);\n\n    tokdata->mech_list = (MECH_LIST_ELEMENT *)soft_mech_list;\n    tokdata->mech_list_len = soft_mech_list_len;\n\n    TRACE_INFO(\"soft %s slot=%lu running\\n\", __func__, SlotNumber);\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_final(STDLL_TokData_t *tokdata,\n                           CK_BBOOL token_specific_final)\n{\n    UNUSED(tokdata);\n    UNUSED(token_specific_final);\n\n    TRACE_INFO(\"soft %s running\\n\", __func__);\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_des_key_gen(STDLL_TokData_t *tokdata, CK_BYTE **des_key,\n                                 CK_ULONG *len, CK_ULONG keysize,\n                                 CK_BBOOL *is_opaque)\n{\n    *des_key = malloc(keysize);\n    if (*des_key == NULL)\n        return CKR_HOST_MEMORY;\n    *len = keysize;\n    *is_opaque = FALSE;\n\n    // Nothing different to do for DES or TDES here as this is just\n    // random data...  Validation handles the rest\n    // Only check for weak keys when DES.\n    if (keysize == (3 * DES_KEY_SIZE)) {\n        rng_generate(tokdata, *des_key, keysize);\n    } else {\n        do {\n            rng_generate(tokdata, *des_key, keysize);;\n        } while (des_check_weak_key(*des_key) == TRUE);\n    }\n\n    // we really need to validate the key for parity etc...\n    // we should do that here... The caller validates the single des keys\n    // against the known and suspected poor keys..\n    return CKR_OK;\n}\n\nCK_RV token_specific_des_ecb(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rc;\n    DES_key_schedule des_key2;\n    const_DES_cblock key_val_SSL, in_key_data;\n    DES_cblock out_key_data;\n    unsigned int i, j;\n    CK_ATTRIBUTE *attr = NULL;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // Create the key schedule\n    memcpy(&key_val_SSL, attr->pValue, 8);\n    DES_set_key_unchecked(&key_val_SSL, &des_key2);\n\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n    // Both the encrypt and the decrypt are done 8 bytes at a time\n    if (encrypt) {\n        for (i = 0; i < in_data_len; i = i + 8) {\n            memcpy(in_key_data, in_data + i, 8);\n            DES_ecb_encrypt(&in_key_data, &out_key_data, &des_key2,\n                            DES_ENCRYPT);\n            memcpy(out_data + i, out_key_data, 8);\n        }\n\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n\n        for (j = 0; j < in_data_len; j = j + 8) {\n            memcpy(in_key_data, in_data + j, 8);\n            DES_ecb_encrypt(&in_key_data, &out_key_data, &des_key2,\n                            DES_DECRYPT);\n            memcpy(out_data + j, out_key_data, 8);\n        }\n\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_ecb();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[DES_KEY_SIZE];\n    CK_ULONG rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        return rc;\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    memcpy(dkey, attr->pValue, sizeof(dkey));\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, NULL, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_des_cbc(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rc;\n    CK_ATTRIBUTE *attr = NULL;\n    DES_cblock ivec;\n    DES_key_schedule des_key2;\n    const_DES_cblock key_val_SSL;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // Create the key schedule\n    memcpy(&key_val_SSL, attr->pValue, 8);\n    DES_set_key_unchecked(&key_val_SSL, &des_key2);\n\n    memcpy(&ivec, init_v, 8);\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    if (encrypt) {\n        DES_ncbc_encrypt(in_data, out_data, in_data_len, &des_key2, &ivec,\n                         DES_ENCRYPT);\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n        DES_ncbc_encrypt(in_data, out_data, in_data_len, &des_key2, &ivec,\n                         DES_DECRYPT);\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_cbc();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[DES_KEY_SIZE];\n    CK_ULONG rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        return rc;\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    memcpy(dkey, attr->pValue, sizeof(dkey));\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, init_v, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_tdes_ecb(STDLL_TokData_t *tokdata,\n                              CK_BYTE *in_data,\n                              CK_ULONG in_data_len,\n                              CK_BYTE *out_data,\n                              CK_ULONG *out_data_len,\n                              OBJECT *key, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rc;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE key_value[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    unsigned int k, j;\n    DES_key_schedule des_key1;\n    DES_key_schedule des_key2;\n    DES_key_schedule des_key3;\n    const_DES_cblock key_SSL1, key_SSL2, key_SSL3, in_key_data;\n    DES_cblock out_key_data;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    if (keytype == CKK_DES2) {\n        memcpy(key_value, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(key_value + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(key_value, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    // The key as passed is a 24 byte long string containing three des keys\n    // pick them apart and create the 3 corresponding key schedules\n    memcpy(&key_SSL1, key_value, 8);\n    memcpy(&key_SSL2, key_value + 8, 8);\n    memcpy(&key_SSL3, key_value + 16, 8);\n    DES_set_key_unchecked(&key_SSL1, &des_key1);\n    DES_set_key_unchecked(&key_SSL2, &des_key2);\n    DES_set_key_unchecked(&key_SSL3, &des_key3);\n\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n    // the encrypt and decrypt are done 8 bytes at a time\n    if (encrypt) {\n        for (k = 0; k < in_data_len; k = k + 8) {\n            memcpy(in_key_data, in_data + k, 8);\n            DES_ecb3_encrypt((const_DES_cblock *) & in_key_data,\n                             (DES_cblock *) & out_key_data,\n                             &des_key1, &des_key2, &des_key3, DES_ENCRYPT);\n            memcpy(out_data + k, out_key_data, 8);\n        }\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n        for (j = 0; j < in_data_len; j = j + 8) {\n            memcpy(in_key_data, in_data + j, 8);\n            DES_ecb3_encrypt((const_DES_cblock *) & in_key_data,\n                             (DES_cblock *) & out_key_data,\n                             &des_key1, &des_key2, &des_key3, DES_DECRYPT);\n            memcpy(out_data + j, out_key_data, 8);\n        }\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_ede3_ecb();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    CK_ULONG rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    if (keytype == CKK_DES2) {\n        memcpy(dkey, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(dkey + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(dkey, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, NULL, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_tdes_cbc(STDLL_TokData_t *tokdata,\n                              CK_BYTE *in_data,\n                              CK_ULONG in_data_len,\n                              CK_BYTE *out_data,\n                              CK_ULONG *out_data_len,\n                              OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_ATTRIBUTE *attr = NULL;\n    CK_RV rc = CKR_OK;\n    CK_BYTE key_value[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    DES_key_schedule des_key1;\n    DES_key_schedule des_key2;\n    DES_key_schedule des_key3;\n    const_DES_cblock key_SSL1, key_SSL2, key_SSL3;\n    DES_cblock ivec;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    if (keytype == CKK_DES2) {\n        memcpy(key_value, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(key_value + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(key_value, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    // The key as passed in is a 24 byte string containing 3 keys\n    // pick it apart and create the key schedules\n    memcpy(&key_SSL1, key_value, 8);\n    memcpy(&key_SSL2, key_value + 8, 8);\n    memcpy(&key_SSL3, key_value + 16, 8);\n    DES_set_key_unchecked(&key_SSL1, &des_key1);\n    DES_set_key_unchecked(&key_SSL2, &des_key2);\n    DES_set_key_unchecked(&key_SSL3, &des_key3);\n\n    memcpy(ivec, init_v, sizeof(ivec));\n\n    // the des decrypt will only fail if the data length is not evenly divisible\n    // by 8\n    if (in_data_len % DES_BLOCK_SIZE) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n    // Encrypt or decrypt the data\n    if (encrypt) {\n        DES_ede3_cbc_encrypt(in_data,\n                             out_data,\n                             in_data_len,\n                             &des_key1,\n                             &des_key2, &des_key3, &ivec, DES_ENCRYPT);\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    } else {\n        DES_ede3_cbc_encrypt(in_data,\n                             out_data,\n                             in_data_len,\n                             &des_key1,\n                             &des_key2, &des_key3, &ivec, DES_DECRYPT);\n\n        *out_data_len = in_data_len;\n        rc = CKR_OK;\n    }\n\n    return rc;\n#else\n    const EVP_CIPHER *cipher = EVP_des_ede3_cbc();\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    unsigned char dkey[3 * DES_KEY_SIZE];\n    CK_KEY_TYPE keytype;\n    CK_RV rc;\n    int outlen;\n\n    UNUSED(tokdata);\n\n    // get the key type\n    rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n        return rc;\n    }\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n\n    if (keytype == CKK_DES2) {\n        memcpy(dkey, attr->pValue, 2 * DES_KEY_SIZE);\n        memcpy(dkey + (2 * DES_KEY_SIZE), attr->pValue, DES_KEY_SIZE);\n    } else {\n        memcpy(dkey, attr->pValue, 3 * DES_KEY_SIZE);\n    }\n\n    if (in_data_len % DES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        return CKR_DATA_LEN_RANGE;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, dkey, init_v, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(dkey, sizeof(dkey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_tdes_mac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                              CK_ULONG message_len, OBJECT *key, CK_BYTE *mac)\n{\n    CK_BYTE *out_buf;\n    CK_ULONG out_len;\n    CK_RV rc;\n\n    out_buf = malloc(message_len);\n    if (out_buf == NULL) {\n        TRACE_ERROR(\"Malloc failed.\\n\");\n        return CKR_HOST_MEMORY;\n    }\n\n    rc = token_specific_tdes_cbc(tokdata, message, message_len, out_buf,\n                                 &out_len, key, mac, 1);\n\n    if (rc == CKR_OK && out_len >= DES_BLOCK_SIZE)\n        memcpy(mac, out_buf + out_len - DES_BLOCK_SIZE, DES_BLOCK_SIZE);\n\n    free(out_buf);\n\n    return rc;\n}\n\n// convert from the local PKCS11 template representation to\n// the underlying requirement\n// returns the pointer to the local key representation\nstatic void *rsa_convert_public_key(OBJECT *key_obj)\n{\n    CK_BBOOL rc;\n    CK_ATTRIBUTE *modulus = NULL;\n    CK_ATTRIBUTE *pub_exp = NULL;\n\n    RSA *rsa;\n    BIGNUM *bn_mod, *bn_exp;\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &modulus);\n    if (rc != CKR_OK)\n        return NULL;\n    rc = template_attribute_get_non_empty(key_obj->template,\n                                          CKA_PUBLIC_EXPONENT, &pub_exp);\n    if (rc != CKR_OK)\n        return NULL;\n\n    // Create an RSA key struct to return\n    rsa = RSA_new();\n    if (rsa == NULL)\n        return NULL;\n\n    // Create and init BIGNUM structs to stick in the RSA struct\n    bn_mod = BN_new();\n    bn_exp = BN_new();\n\n    if (bn_exp == NULL || bn_mod == NULL) {\n        if (bn_mod)\n            free(bn_mod);\n        if (bn_exp)\n            free(bn_exp);\n        RSA_free(rsa);\n        return NULL;\n    }\n    // Convert from strings to BIGNUMs and stick them in the RSA struct\n    BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen, bn_mod);\n    BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen, bn_exp);\n\n#ifdef OLDER_OPENSSL\n    rsa->n = bn_mod;\n    rsa->e = bn_exp;\n#else\n    RSA_set0_key(rsa, bn_mod, bn_exp, NULL);\n#endif\n\n    return (void *) rsa;\n}\n\nstatic void *rsa_convert_private_key(OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *modulus = NULL;\n    CK_ATTRIBUTE *pub_exp = NULL;\n    CK_ATTRIBUTE *priv_exp = NULL;\n    CK_ATTRIBUTE *prime1 = NULL;\n    CK_ATTRIBUTE *prime2 = NULL;\n    CK_ATTRIBUTE *exp1 = NULL;\n    CK_ATTRIBUTE *exp2 = NULL;\n    CK_ATTRIBUTE *coeff = NULL;\n\n    RSA *rsa;\n    RSA_METHOD *meth;\n    BIGNUM *bn_mod, *bn_pub_exp, *bn_priv_exp, *bn_p1, *bn_p2, *bn_e1, *bn_e2,\n        *bn_cf;\n\n    template_attribute_get_non_empty(key_obj->template, CKA_MODULUS, &modulus);\n    template_attribute_get_non_empty(key_obj->template,  CKA_PUBLIC_EXPONENT,\n                                     &pub_exp);\n    template_attribute_find(key_obj->template, CKA_PRIVATE_EXPONENT, &priv_exp);\n    template_attribute_find(key_obj->template, CKA_PRIME_1, &prime1);\n    template_attribute_find(key_obj->template, CKA_PRIME_2, &prime2);\n    template_attribute_find(key_obj->template, CKA_EXPONENT_1, &exp1);\n    template_attribute_find(key_obj->template, CKA_EXPONENT_2,&exp2);\n    template_attribute_find(key_obj->template, CKA_COEFFICIENT, &coeff);\n\n    if (!prime2 && !modulus) {\n        return NULL;\n    }\n    // Create and init all the RSA and BIGNUM structs we need.\n    rsa = RSA_new();\n    if (rsa == NULL)\n        return NULL;\n\n    /*\n     * Depending if an engine is loaded on OpenSSL and define its own\n     * RSA_METHOD, we can end up having an infinite loop as the SOFT\n     * Token doesn't implement RSA and, instead, calls OpenSSL for it.\n     * So to avoid it we set RSA methods to the default rsa methods.\n     */\n#ifdef OLDER_OPENSSL\n    if (rsa->engine) {\n        meth = (RSA_METHOD *) rsa->meth;\n        const RSA_METHOD *meth2 = RSA_PKCS1_SSLeay();\n        meth->rsa_pub_enc = meth2->rsa_pub_enc;\n        meth->rsa_pub_dec = meth2->rsa_pub_dec;\n        meth->rsa_priv_enc = meth2->rsa_priv_enc;\n        meth->rsa_priv_dec = meth2->rsa_priv_dec;\n        meth->rsa_mod_exp = meth2->rsa_mod_exp;\n        meth->bn_mod_exp = meth2->bn_mod_exp;\n#else\n/*\n * XXX I dont see a better way than to ignore this warning for now.\n * Note that the GCC pragma also works for clang.\n */\n# pragma GCC diagnostic push\n# pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n    ENGINE *e = RSA_get0_engine(rsa);\n    if (e) {\n        meth = (RSA_METHOD *) RSA_get_method(rsa);\n        const RSA_METHOD *meth2 = RSA_PKCS1_OpenSSL();\n        RSA_meth_set_pub_enc(meth, RSA_meth_get_pub_enc(meth2));\n        RSA_meth_set_pub_dec(meth, RSA_meth_get_pub_dec(meth2));\n        RSA_meth_set_priv_enc(meth, RSA_meth_get_priv_enc(meth2));\n        RSA_meth_set_priv_dec(meth, RSA_meth_get_priv_dec(meth2));\n        RSA_meth_set_mod_exp(meth, RSA_meth_get_mod_exp(meth2));\n        RSA_meth_set_bn_mod_exp(meth, RSA_meth_get_bn_mod_exp(meth2));\n# pragma GCC diagnostic pop\n#endif\n    }\n\n    bn_mod = BN_new();\n    bn_pub_exp = BN_new();\n    bn_priv_exp = BN_new();\n    bn_p1 = BN_new();\n    bn_p2 = BN_new();\n    bn_e1 = BN_new();\n    bn_e2 = BN_new();\n    bn_cf = BN_new();\n\n    if ((bn_cf == NULL) || (bn_e2 == NULL) || (bn_e1 == NULL) ||\n        (bn_p2 == NULL) || (bn_p1 == NULL) || (bn_priv_exp == NULL) ||\n        (bn_pub_exp == NULL) || (bn_mod == NULL)) {\n        if (rsa)\n            RSA_free(rsa);\n        if (bn_mod)\n            BN_free(bn_mod);\n        if (bn_pub_exp)\n            BN_free(bn_pub_exp);\n        if (bn_priv_exp)\n            BN_free(bn_priv_exp);\n        if (bn_p1)\n            BN_free(bn_p1);\n        if (bn_p2)\n            BN_free(bn_p2);\n        if (bn_e1)\n            BN_free(bn_e1);\n        if (bn_e2)\n            BN_free(bn_e2);\n        if (bn_cf)\n            BN_free(bn_cf);\n        return NULL;\n    }\n\n    // CRT key?\n    if (prime1) {\n        if (!prime2 || !exp1 || !exp2 || !coeff) {\n            return NULL;\n        }\n        // Even though this is CRT key, OpenSSL requires the\n        // modulus and exponents filled in or encrypt and decrypt will\n        // not work\n        BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen,\n                  bn_mod);\n        BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen,\n                  bn_pub_exp);\n        BN_bin2bn((unsigned char *) priv_exp->pValue, priv_exp->ulValueLen,\n                  bn_priv_exp);\n\n        BN_bin2bn((unsigned char *) prime1->pValue, prime1->ulValueLen, bn_p1);\n        BN_bin2bn((unsigned char *) prime2->pValue, prime2->ulValueLen, bn_p2);\n\n        BN_bin2bn((unsigned char *) exp1->pValue, exp1->ulValueLen, bn_e1);\n        BN_bin2bn((unsigned char *) exp2->pValue, exp2->ulValueLen, bn_e2);\n        BN_bin2bn((unsigned char *) coeff->pValue, coeff->ulValueLen, bn_cf);\n#ifdef OLDER_OPENSSL\n        rsa->n = bn_mod;\n        rsa->d = bn_priv_exp;\n        rsa->p = bn_p1;\n        rsa->q = bn_p2;\n        rsa->dmp1 = bn_e1;\n        rsa->dmq1 = bn_e2;\n        rsa->iqmp = bn_cf;\n#else\n        RSA_set0_key(rsa, bn_mod, bn_pub_exp, bn_priv_exp);\n        RSA_set0_factors(rsa, bn_p1, bn_p2);\n        RSA_set0_crt_params(rsa, bn_e1, bn_e2, bn_cf);\n#endif\n        return rsa;\n    } else {                    // must be a non-CRT key\n        if (!priv_exp) {\n            return NULL;\n        }\n        BN_bin2bn((unsigned char *) modulus->pValue, modulus->ulValueLen,\n                  bn_mod);\n        BN_bin2bn((unsigned char *) pub_exp->pValue, pub_exp->ulValueLen,\n                  bn_pub_exp);\n        BN_bin2bn((unsigned char *) priv_exp->pValue, priv_exp->ulValueLen,\n                  bn_priv_exp);\n#ifdef OLDER_OPENSSL\n        rsa->n = bn_mod;\n        rsa->d = bn_priv_exp;\n#else\n        RSA_set0_key(rsa, bn_mod, bn_pub_exp, bn_priv_exp);\n#endif\n    }\n\n    return (void *) rsa;\n}\n\nstatic CK_RV os_specific_rsa_keygen(TEMPLATE *publ_tmpl, TEMPLATE *priv_tmpl)\n{\n    CK_ATTRIBUTE *publ_exp = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_ULONG mod_bits;\n    CK_BBOOL flag;\n    CK_RV rc;\n    CK_ULONG BNLength;\n    RSA *rsa = NULL;\n    const BIGNUM *bignum = NULL;\n    CK_BYTE *ssl_ptr = NULL;\n    BIGNUM *e = NULL;\n#ifndef OLDER_OPENSSL\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n#endif\n\n    rc = template_attribute_get_ulong(publ_tmpl, CKA_MODULUS_BITS, &mod_bits);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_TEMPLATE_INCOMPLETE));\n        return CKR_TEMPLATE_INCOMPLETE; // should never happen\n    }\n\n    // we don't support less than 1024 bit keys in the sw\n    if (mod_bits < 512 || mod_bits > 4096) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_KEY_SIZE_RANGE));\n        return CKR_KEY_SIZE_RANGE;\n    }\n\n    rc = template_attribute_get_non_empty(publ_tmpl, CKA_PUBLIC_EXPONENT,\n                                          &publ_exp);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_TEMPLATE_INCOMPLETE));\n        return CKR_TEMPLATE_INCOMPLETE;\n    }\n\n    if (publ_exp->ulValueLen > sizeof(CK_ULONG)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ATTRIBUTE_VALUE_INVALID));\n        return CKR_ATTRIBUTE_VALUE_INVALID;\n    }\n\n    e = BN_new();\n    if (e == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n    BN_bin2bn(publ_exp->pValue, publ_exp->ulValueLen, e);\n\n#ifdef OLDER_OPENSSL\n    rsa = RSA_new();\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (!RSA_generate_key_ex(rsa, mod_bits, e, NULL)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    bignum = rsa->n;\n#else\n    ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_keygen_init(ctx) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (mod_bits > INT_MAX\n        || EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, mod_bits) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, e) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_keygen(ctx, &pkey) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if ((rsa = EVP_PKEY_get0_RSA(pkey)) == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    RSA_get0_key(rsa, &bignum, NULL, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_MODULUS, ssl_ptr, BNLength, &attr);    // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // Public Exponent\n#ifdef OLDER_OPENSSL\n    bignum = rsa->e;\n#else\n    RSA_get0_key(rsa, NULL, &bignum, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    // in bytes\n    rc = build_attribute(CKA_PUBLIC_EXPONENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n\n    /* add public exponent to the private template. Its already an attribute in\n     * the private template at this point, we're just making its value correct\n     */\n    rc = build_attribute(CKA_PUBLIC_EXPONENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // local = TRUE\n    //\n    flag = TRUE;\n    rc = build_attribute(CKA_LOCAL, &flag, sizeof(CK_BBOOL), &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n\n    //\n    // now, do the private key\n    //\n    // Cheat here and put the whole original key into the CKA_VALUE... remember\n    // to force the system to not return this for RSA keys..\n\n    // Add the modulus to the private key information\n#ifdef OLDER_OPENSSL\n    bignum = rsa->n;\n#else\n    RSA_get0_key(rsa, &bignum, NULL, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_MODULUS, ssl_ptr, BNLength, &attr);    // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // Private Exponent\n#ifdef OLDER_OPENSSL\n    bignum = rsa->d;\n#else\n    RSA_get0_key(rsa, NULL, NULL, &bignum);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_PRIVATE_EXPONENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // prime #1: p\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->p;\n#else\n    RSA_get0_factors(rsa, &bignum, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_PRIME_1, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // prime #2: q\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->q;\n#else\n    RSA_get0_factors(rsa, NULL, &bignum);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_PRIME_2, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // exponent 1: d mod(p-1)\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->dmp1;\n#else\n    RSA_get0_crt_params(rsa, &bignum, NULL, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_EXPONENT_1, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // exponent 2: d mod(q-1)\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->dmq1;\n#else\n    RSA_get0_crt_params(rsa, NULL, &bignum, NULL);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_EXPONENT_2, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    // CRT coefficient:  q_inverse mod(p)\n    //\n#ifdef OLDER_OPENSSL\n    bignum = rsa->iqmp;\n#else\n    RSA_get0_crt_params(rsa, NULL, NULL, &bignum);\n#endif\n    BNLength = BN_num_bytes(bignum);\n    ssl_ptr = malloc(BNLength);\n    if (ssl_ptr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n    BNLength = BN_bn2bin(bignum, ssl_ptr);\n    rc = build_attribute(CKA_COEFFICIENT, ssl_ptr, BNLength, &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        OPENSSL_cleanse(attr, sizeof(CK_ATTRIBUTE) + attr->ulValueLen);\n        free(attr);\n        goto done;\n    }\n    OPENSSL_cleanse(ssl_ptr, BNLength);\n    free(ssl_ptr);\n    ssl_ptr = NULL;\n\n    flag = TRUE;\n    rc = build_attribute(CKA_LOCAL, &flag, sizeof(CK_BBOOL), &attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(attr);\n        goto done;\n    }\n\ndone:\n#ifdef OLDER_OPENSSL\n    if (e != NULL)\n        BN_free(e);\n    if (rsa != NULL)\n        RSA_free(rsa);\n    if (ssl_ptr != NULL) {\n        OPENSSL_cleanse(ssl_ptr, BNLength);\n        free(ssl_ptr);\n    }\n#else\n    if (ssl_ptr != NULL) {\n        OPENSSL_cleanse(ssl_ptr, BNLength);\n        free(ssl_ptr);\n    }\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n#endif\n    return rc;\n}\n\nCK_RV token_specific_rsa_generate_keypair(STDLL_TokData_t *tokdata,\n                                          TEMPLATE *publ_tmpl,\n                                          TEMPLATE *priv_tmpl)\n{\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = os_specific_rsa_keygen(publ_tmpl, priv_tmpl);\n    if (rc != CKR_OK)\n        TRACE_DEVEL(\"os_specific_rsa_keygen failed\\n\");\n\n    return rc;\n}\n\n\nstatic CK_RV os_specific_rsa_encrypt(CK_BYTE *in_data,\n                                     CK_ULONG in_data_len,\n                                     CK_BYTE *out_data, OBJECT *key_obj)\n{\n#ifdef OLDER_OPENSSL\n    CK_RV rc;\n    RSA *rsa;\n    int size;\n\n    // Convert the local representation to an RSA representation\n    rsa = (RSA *) rsa_convert_public_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n    // Do an RSA public encryption\n    size =\n        RSA_public_encrypt(in_data_len, in_data, out_data, rsa, RSA_NO_PADDING);\n    if (size == -1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_ARGUMENTS_BAD;\n        goto done;\n    }\n\n    rc = CKR_OK;\n\ndone:\n    RSA_free(rsa);\n\n    return rc;\n#else\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    RSA *rsa = NULL;\n    CK_RV rc;\n    size_t outlen = in_data_len;\n\n    rsa = (RSA *)rsa_convert_public_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_assign_RSA(pkey, rsa) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    rsa = NULL; /* freed together with pkey */\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_encrypt_init(ctx) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_NO_PADDING) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_encrypt(ctx, out_data, &outlen,\n                         in_data, in_data_len) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = CKR_OK;\ndone:\n    if (rsa != NULL)\n        RSA_free(rsa);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nstatic CK_RV os_specific_rsa_decrypt(CK_BYTE *in_data,\n                                     CK_ULONG in_data_len,\n                                     CK_BYTE *out_data, OBJECT *key_obj)\n{\n#ifdef OLDER_OPENSSL\n    CK_RV rc;\n    RSA *rsa;\n    int size;\n\n    // Convert the local key representation to an RSA key representaion\n    rsa = (RSA *) rsa_convert_private_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n    // Do the private decryption\n    size =\n        RSA_private_decrypt(in_data_len, in_data, out_data, rsa,\n                            RSA_NO_PADDING);\n\n    if (size == -1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = CKR_OK;\n\ndone:\n    RSA_free(rsa);\n\n    return rc;\n#else\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    RSA *rsa = NULL;\n    size_t outlen = in_data_len;\n    CK_RV rc;\n\n    rsa = (RSA *)rsa_convert_private_key(key_obj);\n    if (rsa == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        return rc;\n    }\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_assign_RSA(pkey, rsa) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    rsa = NULL; /* freed together with pkey */\n\n    ctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_decrypt_init(ctx) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_NO_PADDING) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    if (EVP_PKEY_decrypt(ctx, out_data, &outlen,\n                         in_data, in_data_len) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = CKR_OK;\ndone:\n    if (rsa != NULL)\n        RSA_free(rsa);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_rsa_encrypt(STDLL_TokData_t *tokdata, CK_BYTE *in_data,\n                                 CK_ULONG in_data_len, CK_BYTE *out_data,\n                                 CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_RV rc;\n    CK_ULONG modulus_bytes;\n    CK_BYTE clear[MAX_RSA_KEYLEN], cipher[MAX_RSA_KEYLEN];\n    CK_ATTRIBUTE *attr = NULL;\n\n    /* format the data */\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    }\n    modulus_bytes = attr->ulValueLen;\n\n    rc = rsa_format_block(tokdata, in_data, in_data_len, clear,\n                          modulus_bytes, PKCS_BT_2);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"rsa_format_block failed\\n\");\n        goto done;\n    }\n    // Do an RSA public encryption\n    rc = os_specific_rsa_encrypt(clear, modulus_bytes, cipher, key_obj);\n\n    if (rc == CKR_OK) {\n        memcpy(out_data, cipher, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\ndone:\n    OPENSSL_cleanse(clear, sizeof(clear));\n    return rc;\n}\n\nCK_RV token_specific_rsa_decrypt(STDLL_TokData_t *tokdata, CK_BYTE *in_data,\n                                 CK_ULONG in_data_len, CK_BYTE *out_data,\n                                 CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_RV rc;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n\n    UNUSED(tokdata);\n\n    modulus_bytes = in_data_len;\n\n    rc = os_specific_rsa_decrypt(in_data, modulus_bytes, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n        goto done;\n    }\n\n    rc = rsa_parse_block(out, modulus_bytes, out_data, out_data_len, PKCS_BT_2);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"rsa_parse_block failed\\n\");\n        goto done;\n    }\n\n    /*\n     * For PKCS #1 v1.5 padding, out_data_len must be less than\n     * modulus_bytes - 11.\n     */\n    if (*out_data_len > (modulus_bytes - 11)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ENCRYPTED_DATA_LEN_RANGE));\n        rc = CKR_ENCRYPTED_DATA_LEN_RANGE;\n    }\n\ndone:\n    OPENSSL_cleanse(out, sizeof(out));\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_sign(STDLL_TokData_t *tokdata, SESSION *sess,\n                              CK_BYTE *in_data, CK_ULONG in_data_len,\n                              CK_BYTE *out_data, CK_ULONG *out_data_len,\n                              OBJECT *key_obj)\n{\n    CK_BYTE data[MAX_RSA_KEYLEN], sig[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n    CK_ATTRIBUTE *attr = NULL;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    /* format the data */\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    }\n    modulus_bytes = attr->ulValueLen;\n    rc = rsa_format_block(tokdata, in_data, in_data_len, data,\n                          modulus_bytes, PKCS_BT_1);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"rsa_format_block failed\\n\");\n        return rc;\n    }\n\n    /* signing is a private key operation --> decrypt */\n    rc = os_specific_rsa_decrypt(data, modulus_bytes, sig, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, sig, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n                                CK_BYTE *in_data, CK_ULONG in_data_len,\n                                CK_BYTE *signature, CK_ULONG sig_len,\n                                OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN], out_data[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes, out_data_len;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n    UNUSED(sig_len);\n\n    out_data_len = MAX_RSA_KEYLEN;\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    // verifying is a public key operation --> encrypt\n    //\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n        return rc;\n    }\n\n    rc = rsa_parse_block(out, modulus_bytes, out_data, &out_data_len,\n                         PKCS_BT_1);\n    if (rc == CKR_ENCRYPTED_DATA_INVALID) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    } else if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    if (in_data_len != out_data_len) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    }\n\n    if (CRYPTO_memcmp(in_data, out_data, out_data_len) != 0) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_verify_recover(STDLL_TokData_t *tokdata,\n                                        CK_BYTE *signature, CK_ULONG sig_len,\n                                        CK_BYTE *out_data,\n                                        CK_ULONG *out_data_len,\n                                        OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sig_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    // verifying is a public key operation --> encrypt\n    //\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n        return rc;\n    }\n\n    rc = rsa_parse_block(out, modulus_bytes, out_data, out_data_len, PKCS_BT_1);\n    if (rc == CKR_ENCRYPTED_DATA_INVALID) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n        return CKR_SIGNATURE_INVALID;\n    } else if (rc != CKR_OK) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_pss_sign(STDLL_TokData_t *tokdata, SESSION *sess,\n                                  SIGN_VERIFY_CONTEXT *ctx,\n                                  CK_BYTE *in_data, CK_ULONG in_data_len,\n                                  CK_BYTE *sig, CK_ULONG *sig_len)\n{\n    CK_RV rc;\n    CK_ULONG modbytes;\n    CK_ATTRIBUTE *attr = NULL;\n    OBJECT *key_obj = NULL;\n    CK_BYTE *emdata = NULL;\n    CK_RSA_PKCS_PSS_PARAMS *pssParms = NULL;\n\n    UNUSED(sess);\n\n    /* check the arguments */\n    if (!in_data || !sig) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    if (!ctx) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    pssParms = (CK_RSA_PKCS_PSS_PARAMS *) ctx->mech.pParameter;\n\n    /* get the key */\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n   if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    } else {\n        modbytes = attr->ulValueLen;\n    }\n\n    emdata = (CK_BYTE *) malloc(modbytes);\n    if (emdata == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    rc = emsa_pss_encode(tokdata, pssParms, in_data, in_data_len, emdata,\n                         &modbytes);\n    if (rc != CKR_OK)\n        goto done;\n\n    /* signing is a private key operation --> decrypt  */\n    rc = os_specific_rsa_decrypt(emdata, modbytes, sig, key_obj);\n    if (rc == CKR_OK)\n        *sig_len = modbytes;\n    else\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n\ndone:\n    if (emdata)\n        free(emdata);\n\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_pss_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n                                    SIGN_VERIFY_CONTEXT *ctx,\n                                    CK_BYTE *in_data, CK_ULONG in_data_len,\n                                    CK_BYTE *signature, CK_ULONG sig_len)\n{\n    CK_RV rc;\n    CK_ULONG modbytes;\n    OBJECT *key_obj = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_RSA_PKCS_PSS_PARAMS *pssParms = NULL;\n\n    UNUSED(sess);\n\n    /* check the arguments */\n    if (!in_data || !signature) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    if (!ctx) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    pssParms = (CK_RSA_PKCS_PSS_PARAMS *) ctx->mech.pParameter;\n\n    /* get the key */\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    /* verify is a public key operation ... encrypt */\n    rc = os_specific_rsa_encrypt(signature, sig_len, out, key_obj);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n        goto done;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    } else {\n        modbytes = attr->ulValueLen;\n    }\n\n    /* call the pss verify scheme */\n    rc = emsa_pss_verify(tokdata, pssParms, in_data, in_data_len, out,\n                         modbytes);\n\ndone:\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_x509_encrypt(STDLL_TokData_t *tokdata,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE clear[MAX_RSA_KEYLEN], cipher[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    }\n\n    modulus_bytes = attr->ulValueLen;\n\n    // prepad with zeros\n    //\n    memset(clear, 0x0, modulus_bytes - in_data_len);\n    memcpy(&clear[modulus_bytes - in_data_len], in_data, in_data_len);\n\n    rc = os_specific_rsa_encrypt(clear, modulus_bytes, cipher, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, cipher, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\ndone:\n    OPENSSL_cleanse(clear, sizeof(clear));\n    return rc;\n}\n\nCK_RV token_specific_rsa_x509_decrypt(STDLL_TokData_t *tokdata,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(in_data_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    }\n\n    modulus_bytes = attr->ulValueLen;\n\n    rc = os_specific_rsa_decrypt(in_data, modulus_bytes, out, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, out, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_decrypt failed\\n\");\n    }\n\ndone:\n    OPENSSL_cleanse(out, sizeof(out));\n    return rc;\n}\n\n\nCK_RV token_specific_rsa_x509_sign(STDLL_TokData_t *tokdata, CK_BYTE *in_data,\n                                   CK_ULONG in_data_len, CK_BYTE *out_data,\n                                   CK_ULONG *out_data_len, OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE data[MAX_RSA_KEYLEN], sig[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    // prepad with zeros\n    //\n\n    memset(data, 0x0, modulus_bytes - in_data_len);\n    memcpy(&data[modulus_bytes - in_data_len], in_data, in_data_len);\n\n    rc = os_specific_rsa_decrypt(data, modulus_bytes, sig, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, sig, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_x509_verify(STDLL_TokData_t *tokdata,\n                                     CK_BYTE *in_data, CK_ULONG in_data_len,\n                                     CK_BYTE *signature, CK_ULONG sig_len,\n                                     OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sig_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc == CKR_OK) {\n        CK_ULONG pos1, pos2, len;\n        // it should be noted that in_data_len is not necessarily\n        // the same as the modulus length\n        //\n        for (pos1 = 0; pos1 < in_data_len; pos1++)\n            if (in_data[pos1] != 0)\n                break;\n\n        for (pos2 = 0; pos2 < modulus_bytes; pos2++)\n            if (out[pos2] != 0)\n                break;\n\n        // at this point, pos1 and pos2 point to the first non-zero\n        // bytes in the input data and the decrypted signature\n        // (the recovered data), respectively.\n        if ((in_data_len - pos1) != (modulus_bytes - pos2)) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            return CKR_SIGNATURE_INVALID;\n        }\n        len = in_data_len - pos1;\n\n        if (CRYPTO_memcmp(&in_data[pos1], &out[pos2], len) != 0) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            return CKR_SIGNATURE_INVALID;\n        }\n        return CKR_OK;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed: %lx\\n\", rc);\n        /*\n         * Return CKR_SIGNATURE_INVALID in case of CKR_ARGUMENTS_BAD or\n         * CKR_FUNCTION_FAILED because we dont know why the RSA op failed and\n         * it may have failed due to a tampered signature being greater or equal\n         * to the modulus.\n         */\n        if (rc == CKR_ARGUMENTS_BAD || rc == CKR_FUNCTION_FAILED) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rc = CKR_SIGNATURE_INVALID;\n        }\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_x509_verify_recover(STDLL_TokData_t *tokdata,\n                                             CK_BYTE *signature,\n                                             CK_ULONG sig_len,\n                                             CK_BYTE *out_data,\n                                             CK_ULONG *out_data_len,\n                                             OBJECT *key_obj)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE out[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sig_len);\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        return rc;\n    } else {\n        modulus_bytes = attr->ulValueLen;\n    }\n\n    rc = os_specific_rsa_encrypt(signature, modulus_bytes, out, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, out, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_oaep_encrypt(STDLL_TokData_t *tokdata,\n                                      ENCR_DECR_CONTEXT *ctx,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, CK_BYTE *hash,\n                                      CK_ULONG hlen)\n{\n    CK_RV rc;\n    CK_BYTE cipher[MAX_RSA_KEYLEN];\n    CK_ULONG modulus_bytes;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_BYTE *em_data = NULL;\n    OBJECT *key_obj = NULL;\n    CK_RSA_PKCS_OAEP_PARAMS_PTR oaepParms = NULL;\n\n    if (!in_data || !out_data || !hash) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    oaepParms = (CK_RSA_PKCS_OAEP_PARAMS_PTR) ctx->mech.pParameter;\n\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto done;\n    }\n\n    modulus_bytes = attr->ulValueLen;\n\n    /* pkcs1v2.2, section 7.1.1 Step 2:\n     * EME-OAEP encoding.\n     */\n    em_data = (CK_BYTE *) malloc(modulus_bytes * sizeof(CK_BYTE));\n    if (em_data == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    rc = encode_eme_oaep(tokdata, in_data, in_data_len, em_data,\n                         modulus_bytes, oaepParms->mgf, hash, hlen);\n    if (rc != CKR_OK)\n        goto done;\n\n    rc = os_specific_rsa_encrypt(em_data, modulus_bytes, cipher, key_obj);\n    if (rc == CKR_OK) {\n        memcpy(out_data, cipher, modulus_bytes);\n        *out_data_len = modulus_bytes;\n    } else {\n        TRACE_DEVEL(\"os_specific_rsa_encrypt failed\\n\");\n    }\n\ndone:\n    if (em_data) {\n        OPENSSL_cleanse(em_data, modulus_bytes * sizeof(CK_BYTE));\n        free(em_data);\n    }\n\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\nCK_RV token_specific_rsa_oaep_decrypt(STDLL_TokData_t *tokdata,\n                                      ENCR_DECR_CONTEXT *ctx,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len,\n                                      CK_BYTE *out_data,\n                                      CK_ULONG *out_data_len, CK_BYTE *hash,\n                                      CK_ULONG hlen)\n{\n    CK_RV rc;\n    CK_BYTE *decr_data = NULL;\n    OBJECT *key_obj = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_RSA_PKCS_OAEP_PARAMS_PTR oaepParms = NULL;\n\n    if (!in_data || !out_data || !hash) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n        return CKR_ARGUMENTS_BAD;\n    }\n\n    oaepParms = (CK_RSA_PKCS_OAEP_PARAMS_PTR) ctx->mech.pParameter;\n\n    rc = object_mgr_find_in_map1(tokdata, ctx->key, &key_obj, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"object_mgr_find_in_map1 failed\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n                                          &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_MODULUS for the key.\\n\");\n        goto error;\n    }\n\n    *out_data_len = attr->ulValueLen;\n\n    decr_data = (CK_BYTE *) malloc(in_data_len);\n    if (decr_data == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto error;\n    }\n\n    rc = os_specific_rsa_decrypt(in_data, in_data_len, decr_data, key_obj);\n    if (rc != CKR_OK)\n        goto error;\n\n    /* pkcs1v2.2, section 7.1.2 Step 2:\n     * EME-OAEP decoding.\n     */\n    rc = decode_eme_oaep(tokdata, decr_data, in_data_len, out_data,\n                         out_data_len, oaepParms->mgf, hash, hlen);\n\nerror:\n    if (decr_data) {\n        OPENSSL_cleanse(decr_data, in_data_len);\n        free(decr_data);\n    }\n\n    object_put(tokdata, key_obj, TRUE);\n    key_obj = NULL;\n\n    return rc;\n}\n\n#ifndef NOAES\n\nCK_RV token_specific_aes_key_gen(STDLL_TokData_t *tokdata, CK_BYTE **key,\n                                 CK_ULONG *len, CK_ULONG keysize,\n                                 CK_BBOOL *is_opaque)\n{\n    *key = malloc(keysize);\n    if (*key == NULL)\n        return CKR_HOST_MEMORY;\n    *len = keysize;\n    *is_opaque = FALSE;\n\n    return rng_generate(tokdata, *key, keysize);\n}\n\nCK_RV token_specific_aes_ecb(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    AES_KEY ssl_aes_key;\n    unsigned int i;\n    CK_ATTRIBUTE *attr = NULL;\n    /* There's a previous check that in_data_len % AES_BLOCK_SIZE == 0,\n     * so this is fine */\n    CK_ULONG loops = (CK_ULONG) (in_data_len / AES_BLOCK_SIZE);\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    memset(&ssl_aes_key, 0, sizeof(AES_KEY));\n\n    // get key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // AES_ecb_encrypt encrypts only a single block, so we have to break up the\n    // input data here\n    if (encrypt) {\n        AES_set_encrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        for (i = 0; i < loops; i++) {\n            AES_ecb_encrypt((unsigned char *) in_data + (i * AES_BLOCK_SIZE),\n                            (unsigned char *) out_data + (i * AES_BLOCK_SIZE),\n                            &ssl_aes_key, AES_ENCRYPT);\n        }\n    } else {\n        AES_set_decrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        for (i = 0; i < loops; i++) {\n            AES_ecb_encrypt((unsigned char *) in_data + (i * AES_BLOCK_SIZE),\n                            (unsigned char *) out_data + (i * AES_BLOCK_SIZE),\n                            &ssl_aes_key, AES_DECRYPT);\n        }\n    }\n    *out_data_len = in_data_len;\n\n    return CKR_OK;\n#else\n    CK_RV rc;\n    int outlen;\n    unsigned char akey[32];\n    const EVP_CIPHER *cipher = NULL;\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_ULONG keylen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        return rc;\n    }\n\n    keylen = attr->ulValueLen;\n    if (keylen == 128 / 8)\n        cipher = EVP_aes_128_ecb();\n    else if (keylen == 192 / 8)\n        cipher = EVP_aes_192_ecb();\n    else if (keylen == 256 / 8)\n        cipher = EVP_aes_256_ecb();\n\n    memcpy(akey, attr->pValue, keylen);\n\n    if (in_data_len % AES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        rc = CKR_DATA_LEN_RANGE;\n        goto done;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, akey, NULL, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(akey, sizeof(akey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_aes_cbc(STDLL_TokData_t *tokdata,\n                             CK_BYTE *in_data,\n                             CK_ULONG in_data_len,\n                             CK_BYTE *out_data,\n                             CK_ULONG *out_data_len,\n                             OBJECT *key, CK_BYTE *init_v, CK_BYTE encrypt)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    AES_KEY ssl_aes_key;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    memset(&ssl_aes_key, 0, sizeof(AES_KEY));\n\n    // get key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n    // AES_cbc_encrypt chunks the data into AES_BLOCK_SIZE blocks, unlike\n    // AES_ecb_encrypt, so no looping required.\n    if (encrypt) {\n        AES_set_encrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        AES_cbc_encrypt((unsigned char *) in_data, (unsigned char *) out_data,\n                        in_data_len, &ssl_aes_key, init_v, AES_ENCRYPT);\n    } else {\n        AES_set_decrypt_key((unsigned char *) attr->pValue,\n                            (attr->ulValueLen * 8), &ssl_aes_key);\n        AES_cbc_encrypt((unsigned char *) in_data, (unsigned char *) out_data,\n                        in_data_len, &ssl_aes_key, init_v, AES_DECRYPT);\n    }\n    *out_data_len = in_data_len;\n\n    return CKR_OK;\n#else\n    CK_RV rc;\n    int outlen;\n    unsigned char akey[32];\n    const EVP_CIPHER *cipher = NULL;\n    EVP_CIPHER_CTX *ctx = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_ULONG keylen;\n\n    UNUSED(tokdata);\n\n    // get the key value\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc  != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n        return rc;\n    }\n\n    keylen = attr->ulValueLen;\n    if (keylen == 128 / 8)\n        cipher = EVP_aes_128_cbc();\n    else if (keylen == 192 / 8)\n        cipher = EVP_aes_192_cbc();\n    else if (keylen == 256 / 8)\n        cipher = EVP_aes_256_cbc();\n\n    memcpy(akey, attr->pValue, keylen);\n\n    if (in_data_len % AES_BLOCK_SIZE || in_data_len > INT_MAX) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_DATA_LEN_RANGE));\n        rc = CKR_DATA_LEN_RANGE;\n        goto done;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_CipherInit_ex(ctx, cipher,\n                          NULL, akey, init_v, encrypt ? 1 : 0) != 1\n        || EVP_CIPHER_CTX_set_padding(ctx, 0) != 1\n        || EVP_CipherUpdate(ctx, out_data, &outlen, in_data, in_data_len) != 1\n        || EVP_CipherFinal_ex(ctx, out_data, &outlen) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_GENERAL_ERROR));\n        rc = CKR_GENERAL_ERROR;\n        goto done;\n    }\n\n    *out_data_len = in_data_len;\n    rc = CKR_OK;\ndone:\n    OPENSSL_cleanse(akey, sizeof(akey));\n    EVP_CIPHER_CTX_free(ctx);\n    return rc;\n#endif\n}\n\nCK_RV token_specific_aes_mac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                             CK_ULONG message_len, OBJECT *key, CK_BYTE *mac)\n{\n    CK_BYTE *out_buf;\n    CK_ULONG out_len;\n    CK_RV rc;\n\n    out_buf = malloc(message_len);\n    if (out_buf == NULL) {\n        TRACE_ERROR(\"Malloc failed.\\n\");\n        return CKR_HOST_MEMORY;\n    }\n\n    rc = token_specific_aes_cbc(tokdata, message, message_len, out_buf,\n                                &out_len, key, mac, 1);\n\n    if (rc == CKR_OK && out_len >= AES_BLOCK_SIZE)\n        memcpy(mac, out_buf + out_len - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n\n    free(out_buf);\n\n    return rc;\n}\n#endif\n\n/* Begin code contributed by Corrent corp. */\n#ifndef NODH\n// This computes DH shared secret, where:\n//     Output: z is computed shared secret\n//     Input:  y is other party's public key\n//             x is private key\n//             p is prime\n// All length's are in number of bytes. All data comes in as Big Endian.\nCK_RV token_specific_dh_pkcs_derive(STDLL_TokData_t *tokdata,\n                                    CK_BYTE *z,\n                                    CK_ULONG *z_len,\n                                    CK_BYTE *y,\n                                    CK_ULONG y_len,\n                                    CK_BYTE *x,\n                                    CK_ULONG x_len, CK_BYTE *p, CK_ULONG p_len)\n{\n    CK_RV rc;\n    BIGNUM *bn_z, *bn_y, *bn_x, *bn_p;\n    BN_CTX *ctx;\n\n    UNUSED(tokdata);\n\n    //  Create and Init the BIGNUM structures.\n    bn_y = BN_new();\n    bn_x = BN_new();\n    bn_p = BN_new();\n    bn_z = BN_new();\n\n    if (bn_z == NULL || bn_p == NULL || bn_x == NULL || bn_y == NULL) {\n        if (bn_y)\n            BN_free(bn_y);\n        if (bn_x)\n            BN_free(bn_x);\n        if (bn_p)\n            BN_free(bn_p);\n        if (bn_z)\n            BN_free(bn_z);\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n    // Initialize context\n    ctx = BN_CTX_new();\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n    // Add data into these new BN structures\n\n    BN_bin2bn((unsigned char *) y, y_len, bn_y);\n    BN_bin2bn((unsigned char *) x, x_len, bn_x);\n    BN_bin2bn((unsigned char *) p, p_len, bn_p);\n\n    rc = BN_mod_exp(bn_z, bn_y, bn_x, bn_p, ctx);\n    if (rc == 0) {\n        BN_free(bn_z);\n        BN_free(bn_y);\n        BN_free(bn_x);\n        BN_free(bn_p);\n        BN_CTX_free(ctx);\n\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n\n    *z_len = BN_num_bytes(bn_z);\n    BN_bn2bin(bn_z, z);\n\n    BN_free(bn_z);\n    BN_free(bn_y);\n    BN_free(bn_x);\n    BN_free(bn_p);\n    BN_CTX_free(ctx);\n\n    return CKR_OK;\n}                               /* end token_specific_dh_pkcs_derive() */\n\n// This computes DH key pair, where:\n//     Output: priv_tmpl is generated private key\n//             pub_tmpl is computed public key\n//     Input:  pub_tmpl is public key (prime and generator)\n// All length's are in number of bytes. All data comes in as Big Endian.\nCK_RV token_specific_dh_pkcs_key_pair_gen(STDLL_TokData_t *tokdata,\n                                          TEMPLATE *publ_tmpl,\n                                          TEMPLATE *priv_tmpl)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    CK_RV rv;\n    CK_BBOOL rc;\n    CK_ATTRIBUTE *prime_attr = NULL;\n    CK_ATTRIBUTE *base_attr = NULL;\n    CK_ATTRIBUTE *temp_attr = NULL;\n    CK_ATTRIBUTE *value_bits_attr = NULL;\n    CK_BYTE *temp_byte;\n    CK_ULONG temp_bn_len;\n    DH *dh;\n    BIGNUM *bn_p;\n    BIGNUM *bn_g;\n    const BIGNUM *temp_bn;\n\n    UNUSED(tokdata);\n\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_PRIME, &prime_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_PRIME for the key.\\n\");\n        return rv;\n    }\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_BASE, &base_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_BASE for the key.\\n\");\n        return rv;\n    }\n\n    if ((prime_attr->ulValueLen > 256) || (prime_attr->ulValueLen < 64)) {\n        TRACE_ERROR(\"CKA_PRIME attribute value is invalid.\\n\");\n        return CKR_ATTRIBUTE_VALUE_INVALID;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        return CKR_FUNCTION_FAILED;\n    }\n    // Create and init BIGNUM structs to stick in the DH struct\n    bn_p = BN_new();\n    bn_g = BN_new();\n    if (bn_g == NULL || bn_p == NULL) {\n        if (bn_g)\n            BN_free(bn_g);\n        if (bn_p)\n            BN_free(bn_p);\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n    // Convert from strings to BIGNUMs and stick them in the DH struct\n    BN_bin2bn((unsigned char *) prime_attr->pValue, prime_attr->ulValueLen,\n              bn_p);\n    BN_bin2bn((unsigned char *) base_attr->pValue, base_attr->ulValueLen, bn_g);\n    dh->p = bn_p;\n    dh->g = bn_g;\n\n    // Generate the DH Key\n    if (!DH_generate_key(dh)) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        DH_free(dh);\n        return CKR_FUNCTION_FAILED;\n    }\n    // Extract the public and private key components from the DH struct,\n    // and insert them in the publ_tmpl and priv_tmpl\n\n    //\n    // pub_key\n    //\n    //temp_bn = BN_new();\n    temp_bn = dh->pub_key;\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        free(temp_byte);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(publ_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        free(temp_byte);\n        return rc;\n    }\n    free(temp_byte);\n\n    //\n    // priv_key\n    //\n    //temp_bn = BN_new();\n    temp_bn = dh->priv_key;\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        free(temp_byte);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        free(temp_byte);\n        return rc;\n    }\n    free(temp_byte);\n\n    // Update CKA_VALUE_BITS attribute in the private key\n    value_bits_attr =\n        (CK_ATTRIBUTE *) malloc(sizeof(CK_ATTRIBUTE) + sizeof(CK_ULONG));\n    if (value_bits_attr == NULL) {\n        TRACE_ERROR(\"malloc failed\\n\");\n        DH_free(dh);\n        return CKR_HOST_MEMORY;\n    }\n    value_bits_attr->type = CKA_VALUE_BITS;\n    value_bits_attr->ulValueLen = sizeof(CK_ULONG);\n    value_bits_attr->pValue =\n        (CK_BYTE *) value_bits_attr + sizeof(CK_ATTRIBUTE);\n    *(CK_ULONG *) value_bits_attr->pValue = 8 * temp_bn_len;\n    rc = template_update_attribute(priv_tmpl, value_bits_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(value_bits_attr);\n        DH_free(dh);\n        return rc;\n    }\n\n    // Add prime and base to the private key template\n    rc = build_attribute(CKA_PRIME,\n                         (unsigned char *) prime_attr->pValue,\n                         prime_attr->ulValueLen, &temp_attr);  // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        return rc;\n    }\n\n    rc = build_attribute(CKA_BASE,\n                         (unsigned char *) base_attr->pValue,\n                         base_attr->ulValueLen, &temp_attr);     // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        DH_free(dh);\n        return CKR_FUNCTION_FAILED;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        DH_free(dh);\n        return rc;\n    }\n\n    // Cleanup DH key\n    DH_free(dh);\n\n    return CKR_OK;\n#else\n    CK_RV rv;\n    CK_BBOOL rc;\n    CK_ATTRIBUTE *prime_attr = NULL;\n    CK_ATTRIBUTE *base_attr = NULL;\n    CK_ATTRIBUTE *temp_attr = NULL;\n    CK_ATTRIBUTE *value_bits_attr = NULL;\n    CK_BYTE *temp_byte = NULL, *temp_byte2 = NULL;\n    CK_ULONG temp_bn_len;\n    DH *dh = NULL;\n    BIGNUM *bn_p = NULL;\n    BIGNUM *bn_g = NULL;\n    const BIGNUM *temp_bn = NULL;\n    EVP_PKEY *params = NULL, *pkey = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n\n    UNUSED(tokdata);\n\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_PRIME, &prime_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_PRIME for the key.\\n\");\n        goto done;\n    }\n    rv = template_attribute_get_non_empty(publ_tmpl, CKA_BASE, &base_attr);\n    if (rv != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_BASE for the key.\\n\");\n        goto done;\n    }\n\n    if ((prime_attr->ulValueLen > 256) || (prime_attr->ulValueLen < 64)) {\n        TRACE_ERROR(\"CKA_PRIME attribute value is invalid.\\n\");\n        rv = CKR_ATTRIBUTE_VALUE_INVALID;\n        goto done;\n    }\n\n    dh = DH_new();\n    if (dh == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    // Create and init BIGNUM structs to stick in the DH struct\n    bn_p = BN_new();\n    bn_g = BN_new();\n    if (bn_g == NULL || bn_p == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n    // Convert from strings to BIGNUMs and stick them in the DH struct\n    BN_bin2bn((unsigned char *) prime_attr->pValue, prime_attr->ulValueLen,\n              bn_p);\n    BN_bin2bn((unsigned char *) base_attr->pValue, base_attr->ulValueLen, bn_g);\n    DH_set0_pqg(dh, bn_p, NULL, bn_g);\n    /* bn_p and bn_q freed together with dh */\n    bn_p = NULL;\n    bn_g = NULL;\n\n    params = EVP_PKEY_new();\n    if (params == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_assign_DH(params, dh) != 1) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n    dh = NULL; /* freed together with params */\n\n    ctx = EVP_PKEY_CTX_new(params, NULL);\n    if (ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    if (EVP_PKEY_keygen_init(ctx) != 1\n        || EVP_PKEY_keygen(ctx, &pkey) != 1\n        /* dh is freed together with pkey */\n        || (dh = EVP_PKEY_get0_DH(pkey)) == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    // Extract the public and private key components from the DH struct,\n    // and insert them in the publ_tmpl and priv_tmpl\n\n    //\n    // pub_key\n    //\n    DH_get0_key(dh, &temp_bn, NULL);\n\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte, temp_bn_len, &temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(publ_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    //\n    // priv_key\n    //\n    DH_get0_key(dh, NULL, &temp_bn);\n    temp_bn_len = BN_num_bytes(temp_bn);\n    temp_byte2 = malloc(temp_bn_len);\n    temp_bn_len = BN_bn2bin(temp_bn, temp_byte2);\n    // in bytes\n    rc = build_attribute(CKA_VALUE, temp_byte2, temp_bn_len, &temp_attr);\n    OPENSSL_cleanse(temp_byte2, temp_bn_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    // Update CKA_VALUE_BITS attribute in the private key\n    value_bits_attr =\n        (CK_ATTRIBUTE *) malloc(sizeof(CK_ATTRIBUTE) + sizeof(CK_ULONG));\n    if (value_bits_attr == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rv = CKR_HOST_MEMORY;\n        goto done;\n    }\n    value_bits_attr->type = CKA_VALUE_BITS;\n    value_bits_attr->ulValueLen = sizeof(CK_ULONG);\n    value_bits_attr->pValue =\n        (CK_BYTE *) value_bits_attr + sizeof(CK_ATTRIBUTE);\n    *(CK_ULONG *) value_bits_attr->pValue = 8 * temp_bn_len;\n    rc = template_update_attribute(priv_tmpl, value_bits_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    // Add prime and base to the private key template\n    rc = build_attribute(CKA_PRIME,\n                         (unsigned char *) prime_attr->pValue,\n                         prime_attr->ulValueLen, &temp_attr);  // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    rc = build_attribute(CKA_BASE,\n                         (unsigned char *) base_attr->pValue,\n                         base_attr->ulValueLen, &temp_attr);     // in bytes\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute failed\\n\");\n        goto done;\n    }\n    rc = template_update_attribute(priv_tmpl, temp_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(temp_attr);\n        goto done;\n    }\n\n    rv = CKR_OK;\ndone:\n    if (bn_g != NULL)\n        BN_free(bn_g);\n    if (bn_p != NULL)\n        BN_free(bn_p);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n    if (ctx != NULL)\n        EVP_PKEY_CTX_free(ctx);\n    if (params != NULL)\n        EVP_PKEY_free(params);\n    free(temp_byte);\n    free(temp_byte2);\n    return rv;\n#endif\n}                               /* end token_specific_dh_key_pair_gen() */\n#endif\n/* End code contributed by Corrent corp. */\n\nCK_RV token_specific_get_mechanism_list(STDLL_TokData_t *tokdata,\n                                        CK_MECHANISM_TYPE_PTR pMechanismList,\n                                        CK_ULONG_PTR pulCount)\n{\n    return ock_generic_get_mechanism_list(tokdata, pMechanismList, pulCount);\n}\n\nCK_RV token_specific_get_mechanism_info(STDLL_TokData_t *tokdata,\n                                        CK_MECHANISM_TYPE type,\n                                        CK_MECHANISM_INFO_PTR pInfo)\n{\n    return ock_generic_get_mechanism_info(tokdata, type, pInfo);\n}\n\n#ifdef OLDER_OPENSSL\n#define EVP_MD_meth_get_app_datasize(md)        md->ctx_size\n#define EVP_MD_CTX_md_data(ctx)                 ctx->md_data\n#endif\n\nstatic const EVP_MD *md_from_mech(CK_MECHANISM *mech)\n{\n    const EVP_MD *md = NULL;\n\n    switch (mech->mechanism) {\n    case CKM_SHA_1:\n        md = EVP_sha1();\n        break;\n    case CKM_SHA224:\n        md = EVP_sha224();\n        break;\n    case CKM_SHA256:\n        md = EVP_sha256();\n        break;\n    case CKM_SHA384:\n        md = EVP_sha384();\n        break;\n    case CKM_SHA512:\n        md = EVP_sha512();\n        break;\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224:\n        md = EVP_sha512_224();\n        break;\n#endif\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256:\n        md = EVP_sha512_256();\n        break;\n#endif\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224:\n        md = EVP_sha3_224();\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256:\n        md = EVP_sha3_256();\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384:\n        md = EVP_sha3_384();\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512:\n        md = EVP_sha3_512();\n        break;\n#endif\n    default:\n        break;\n    }\n\n    return md;\n}\n\nstatic EVP_MD_CTX *md_ctx_from_context(DIGEST_CONTEXT *ctx)\n{\n    const EVP_MD *md;\n    EVP_MD_CTX *md_ctx;\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    md_ctx = EVP_MD_CTX_create();\n#else\n    md_ctx = EVP_MD_CTX_new();\n#endif\n    if (md_ctx == NULL)\n        return NULL;\n\n    md = md_from_mech(&ctx->mech);\n    if (md == NULL ||\n        !EVP_DigestInit_ex(md_ctx, md, NULL)) {\n        TRACE_ERROR(\"md_from_mech or EVP_DigestInit_ex failed\\n\");\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n        EVP_MD_CTX_destroy(md_ctx);\n#else\n        EVP_MD_CTX_free(md_ctx);\n#endif\n        return NULL;\n    }\n\n    if (ctx->context_len == 0) {\n        ctx->context_len = EVP_MD_meth_get_app_datasize(EVP_MD_CTX_md(md_ctx));\n        ctx->context = malloc(ctx->context_len);\n        if (ctx->context == NULL) {\n            TRACE_ERROR(\"malloc failed\\n\");\n    #if OPENSSL_VERSION_NUMBER < 0x10101000L\n            EVP_MD_CTX_destroy(md_ctx);\n    #else\n            EVP_MD_CTX_free(md_ctx);\n    #endif\n            ctx->context_len = 0;\n            return NULL;\n        }\n\n        /* Save context data for later use */\n        memcpy(ctx->context,  EVP_MD_CTX_md_data(md_ctx), ctx->context_len);\n    } else {\n        if (ctx->context_len !=\n                (CK_ULONG)EVP_MD_meth_get_app_datasize(EVP_MD_CTX_md(md_ctx))) {\n            TRACE_ERROR(\"context size mismatcht\\n\");\n            return NULL;\n        }\n        /* restore the MD context data */\n        memcpy(EVP_MD_CTX_md_data(md_ctx), ctx->context, ctx->context_len);\n    }\n\n    return md_ctx;\n}\n\nCK_RV token_specific_sha_init(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                              CK_MECHANISM *mech)\n{\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    ctx->mech.ulParameterLen = mech->ulParameterLen;\n    ctx->mech.mechanism = mech->mechanism;\n\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_sha(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                         CK_BYTE *in_data, CK_ULONG in_data_len,\n                         CK_BYTE *out_data, CK_ULONG *out_data_len)\n{\n    unsigned int len;\n    CK_RV rc = CKR_OK;\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (!in_data || !out_data)\n        return CKR_ARGUMENTS_BAD;\n\n    /* Recreate the OpenSSL MD context from the saved context */\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (*out_data_len < (CK_ULONG)EVP_MD_CTX_size(md_ctx))\n        return CKR_BUFFER_TOO_SMALL;\n\n    if (!EVP_DigestUpdate(md_ctx, in_data, in_data_len) ||\n        !EVP_DigestFinal(md_ctx, out_data, &len)) {\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    *out_data_len = len;\n\nout:\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n    free(ctx->context);\n    ctx->context = NULL;\n    ctx->context_len = 0;\n\n    return rc;\n}\n\nCK_RV token_specific_sha_update(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                                CK_BYTE *in_data, CK_ULONG in_data_len)\n{\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (!in_data)\n        return CKR_ARGUMENTS_BAD;\n\n    /* Recreate the OpenSSL MD context from the saved context */\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (!EVP_DigestUpdate(md_ctx, in_data, in_data_len)) {\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n        EVP_MD_CTX_destroy(md_ctx);\n#else\n        EVP_MD_CTX_free(md_ctx);\n#endif\n        free(ctx->context);\n        ctx->context = NULL;\n        ctx->context_len = 0;\n        return CKR_FUNCTION_FAILED;\n    }\n\n    /* Save context data for later use */\n    memcpy(ctx->context,  EVP_MD_CTX_md_data(md_ctx), ctx->context_len);\n\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_sha_final(STDLL_TokData_t *tokdata, DIGEST_CONTEXT *ctx,\n                               CK_BYTE *out_data, CK_ULONG *out_data_len)\n{\n    unsigned int len;\n    CK_RV rc = CKR_OK;\n    EVP_MD_CTX *md_ctx;\n\n    UNUSED(tokdata);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (!out_data)\n        return CKR_ARGUMENTS_BAD;\n\n    /* Recreate the OpenSSL MD context from the saved context */\n    md_ctx = md_ctx_from_context(ctx);\n    if (md_ctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        return CKR_HOST_MEMORY;\n    }\n\n    if (*out_data_len < (CK_ULONG)EVP_MD_CTX_size(md_ctx))\n        return CKR_BUFFER_TOO_SMALL;\n\n    if (!EVP_DigestFinal(md_ctx, out_data, &len)) {\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n    *out_data_len = len;\n\nout:\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    EVP_MD_CTX_destroy(md_ctx);\n#else\n    EVP_MD_CTX_free(md_ctx);\n#endif\n    free(ctx->context);\n    ctx->context = NULL;\n    ctx->context_len = 0;\n\n    return rc;\n}\n\nstatic CK_RV softtok_hmac_init(STDLL_TokData_t *tokdata,\n                               SIGN_VERIFY_CONTEXT *ctx, CK_MECHANISM_PTR mech,\n                               CK_OBJECT_HANDLE Hkey)\n{\n    int rc;\n    OBJECT *key = NULL;\n    CK_ATTRIBUTE *attr = NULL;\n    EVP_MD_CTX *mdctx = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    rc = object_mgr_find_in_map1(tokdata, Hkey, &key, READ_LOCK);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Failed to find specified object.\\n\");\n        return rc;\n    }\n\n    rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n        goto done;\n    }\n\n    pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, attr->pValue,\n                                attr->ulValueLen);\n    if (pkey == NULL) {\n        TRACE_ERROR(\"EVP_PKEY_new_mac_key() failed.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    mdctx = EVP_MD_CTX_create();\n    if (mdctx == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n        rc = CKR_HOST_MEMORY;\n        goto done;\n    }\n\n    switch (mech->mechanism) {\n    case CKM_SHA_1_HMAC_GENERAL:\n    case CKM_SHA_1_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha1(), NULL, pkey);\n        break;\n    case CKM_SHA224_HMAC_GENERAL:\n    case CKM_SHA224_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha224(), NULL, pkey);\n        break;\n    case CKM_SHA256_HMAC_GENERAL:\n    case CKM_SHA256_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha256(), NULL, pkey);\n        break;\n    case CKM_SHA384_HMAC_GENERAL:\n    case CKM_SHA384_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha384(), NULL, pkey);\n        break;\n    case CKM_SHA512_HMAC_GENERAL:\n    case CKM_SHA512_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha512(), NULL, pkey);\n        break;\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224_HMAC_GENERAL:\n    case CKM_SHA512_224_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha512_224(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256_HMAC_GENERAL:\n    case CKM_SHA512_256_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha512_256(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_224(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_256(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_384(), NULL, pkey);\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512_HMAC:\n        rc = EVP_DigestSignInit(mdctx, NULL, EVP_sha3_512(), NULL, pkey);\n        break;\n#endif\n    default:\n        EVP_MD_CTX_destroy(mdctx);\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_INVALID));\n        rc = CKR_MECHANISM_INVALID;\n        goto done;\n    }\n\n    if (rc != 1) {\n        EVP_MD_CTX_destroy(mdctx);\n        ctx->context = NULL;\n        TRACE_ERROR(\"EVP_DigestSignInit failed.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto done;\n    } else {\n        ctx->context = (CK_BYTE *) mdctx;\n    }\n\n    rc = CKR_OK;\ndone:\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n\n    object_put(tokdata, key, TRUE);\n    key = NULL;\n    return rc;\n}\n\nCK_RV token_specific_hmac_sign_init(STDLL_TokData_t *tokdata, SESSION *sess,\n                                    CK_MECHANISM *mech, CK_OBJECT_HANDLE Hkey)\n{\n    return softtok_hmac_init(tokdata, &sess->sign_ctx, mech, Hkey);\n}\n\nCK_RV token_specific_hmac_verify_init(STDLL_TokData_t *tokdata, SESSION *sess,\n                                      CK_MECHANISM *mech,\n                                      CK_OBJECT_HANDLE Hkey)\n{\n    return softtok_hmac_init(tokdata, &sess->verify_ctx, mech, Hkey);\n}\n\nstatic CK_RV softtok_hmac(SIGN_VERIFY_CONTEXT *ctx, CK_BYTE *in_data,\n                          CK_ULONG in_data_len, CK_BYTE *signature,\n                          CK_ULONG *sig_len, CK_BBOOL sign)\n{\n    int rc;\n    size_t mac_len, len;\n    unsigned char mac[MAX_SHA_HASH_SIZE];\n    EVP_MD_CTX *mdctx = NULL;\n    CK_RV rv = CKR_OK;\n    CK_BBOOL general = FALSE;\n\n    if (!ctx || !ctx->context) {\n        TRACE_ERROR(\"%s received bad argument(s)\\n\", __func__);\n        return CKR_FUNCTION_FAILED;\n    }\n\n    if (sign && !sig_len) {\n        TRACE_ERROR(\"%s received bad argument(s)\\n\", __func__);\n        return CKR_FUNCTION_FAILED;\n    }\n\n    switch (ctx->mech.mechanism) {\n    case CKM_SHA_1_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA_1_HMAC:\n        mac_len = SHA1_HASH_SIZE;\n        break;\n    case CKM_SHA224_HMAC_GENERAL:\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224_HMAC_GENERAL:\n#endif\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA224_HMAC:\n#ifdef NID_sha512_224WithRSAEncryption\n    case CKM_SHA512_224_HMAC:\n#endif\n        mac_len = SHA224_HASH_SIZE;\n        break;\n    case CKM_SHA256_HMAC_GENERAL:\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256_HMAC_GENERAL:\n#endif\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA256_HMAC:\n#ifdef NID_sha512_256WithRSAEncryption\n    case CKM_SHA512_256_HMAC:\n#endif\n        mac_len = SHA256_HASH_SIZE;\n        break;\n    case CKM_SHA384_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA384_HMAC:\n        mac_len = SHA384_HASH_SIZE;\n        break;\n    case CKM_SHA512_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA512_HMAC:\n        mac_len = SHA512_HASH_SIZE;\n        break;\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224_HMAC:\n        mac_len = SHA3_224_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256_HMAC:\n        mac_len = SHA3_256_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384_HMAC:\n        mac_len = SHA3_384_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512_HMAC:\n        mac_len = SHA3_512_HASH_SIZE;\n        break;\n#endif\n    default:\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_INVALID));\n        return CKR_MECHANISM_INVALID;\n    }\n\n    mdctx = (EVP_MD_CTX *) ctx->context;\n\n    rc = EVP_DigestSignUpdate(mdctx, in_data, in_data_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    rc = EVP_DigestSignFinal(mdctx, mac, &mac_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignFinal failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    if (sign) {\n        if (general)\n            *sig_len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            *sig_len = mac_len;\n\n        memcpy(signature, mac, *sig_len);\n\n    } else {\n        if (general)\n            len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            len = mac_len;\n\n        if (CRYPTO_memcmp(signature, mac, len) != 0) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rv = CKR_SIGNATURE_INVALID;\n        }\n    }\ndone:\n    EVP_MD_CTX_destroy(mdctx);\n    ctx->context = NULL;\n\n    return rv;\n}\n\nCK_RV token_specific_hmac_sign(STDLL_TokData_t *tokdata, SESSION *sess,\n                               CK_BYTE *in_data, CK_ULONG in_data_len,\n                               CK_BYTE *signature, CK_ULONG *sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac(&sess->sign_ctx, in_data, in_data_len, signature,\n                        sig_len, TRUE);\n}\n\nCK_RV token_specific_hmac_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n                                 CK_BYTE *in_data, CK_ULONG in_data_len,\n                                 CK_BYTE *signature, CK_ULONG sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac(&sess->verify_ctx, in_data, in_data_len, signature,\n                        &sig_len, FALSE);\n}\n\nstatic CK_RV softtok_hmac_update(SIGN_VERIFY_CONTEXT *ctx, CK_BYTE *in_data,\n                                 CK_ULONG in_data_len, CK_BBOOL sign)\n{\n    int rc;\n    EVP_MD_CTX *mdctx = NULL;\n    CK_RV rv = CKR_OK;\n\n    UNUSED(sign);\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    mdctx = (EVP_MD_CTX *) ctx->context;\n\n    rc = EVP_DigestSignUpdate(mdctx, in_data, in_data_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n    } else {\n        ctx->context = (CK_BYTE *) mdctx;\n        return CKR_OK;\n    }\n\n    EVP_MD_CTX_destroy(mdctx);\n    ctx->context = NULL;\n    return rv;\n}\n\nCK_RV token_specific_hmac_sign_update(STDLL_TokData_t *tokdata, SESSION *sess,\n                                      CK_BYTE *in_data, CK_ULONG in_data_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_update(&sess->sign_ctx, in_data, in_data_len, TRUE);\n}\n\nCK_RV token_specific_hmac_verify_update(STDLL_TokData_t *tokdata,\n                                        SESSION *sess, CK_BYTE *in_data,\n                                        CK_ULONG in_data_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_update(&sess->verify_ctx, in_data, in_data_len, FALSE);\n}\n\nstatic CK_RV softtok_hmac_final(SIGN_VERIFY_CONTEXT *ctx, CK_BYTE *signature,\n                                CK_ULONG *sig_len, CK_BBOOL sign)\n{\n    int rc;\n    size_t mac_len, len;\n    unsigned char mac[MAX_SHA_HASH_SIZE];\n    EVP_MD_CTX *mdctx = NULL;\n    CK_RV rv = CKR_OK;\n    CK_BBOOL general = FALSE;\n\n    if (!ctx || !ctx->context)\n        return CKR_OPERATION_NOT_INITIALIZED;\n\n    if (sign && !sig_len) {\n        TRACE_ERROR(\"%s received bad argument(s)\\n\", __func__);\n        return CKR_FUNCTION_FAILED;\n    }\n\n    switch (ctx->mech.mechanism) {\n    case CKM_SHA_1_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA_1_HMAC:\n        mac_len = SHA1_HASH_SIZE;\n        break;\n    case CKM_SHA224_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA224_HMAC:\n        mac_len = SHA224_HASH_SIZE;\n        break;\n    case CKM_SHA256_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA256_HMAC:\n        mac_len = SHA256_HASH_SIZE;\n        break;\n    case CKM_SHA384_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA384_HMAC:\n        mac_len = SHA384_HASH_SIZE;\n        break;\n    case CKM_SHA512_HMAC_GENERAL:\n        general = TRUE;\n        /* fallthrough */\n    case CKM_SHA512_HMAC:\n        mac_len = SHA512_HASH_SIZE;\n        break;\n#ifdef NID_sha3_224\n    case CKM_IBM_SHA3_224_HMAC:\n        mac_len = SHA3_224_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_256\n    case CKM_IBM_SHA3_256_HMAC:\n        mac_len = SHA3_256_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_384\n    case CKM_IBM_SHA3_384_HMAC:\n        mac_len = SHA3_384_HASH_SIZE;\n        break;\n#endif\n#ifdef NID_sha3_512\n    case CKM_IBM_SHA3_512_HMAC:\n        mac_len = SHA3_512_HASH_SIZE;\n        break;\n#endif\n    default:\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_MECHANISM_INVALID));\n        return CKR_MECHANISM_INVALID;\n    }\n\n    if (signature == NULL) {\n        if (sign) {\n            if (general)\n                *sig_len = *(CK_ULONG *) ctx->mech.pParameter;\n            else\n                *sig_len = (CK_ULONG) mac_len;\n        }\n        return CKR_OK;\n    }\n\n    mdctx = (EVP_MD_CTX *) ctx->context;\n\n    rc = EVP_DigestSignFinal(mdctx, mac, &mac_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"EVP_DigestSignFinal failed.\\n\");\n        rv = CKR_FUNCTION_FAILED;\n        goto done;\n    }\n\n    if (sign) {\n        if (general)\n            *sig_len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            *sig_len = mac_len;\n\n        memcpy(signature, mac, *sig_len);\n\n    } else {\n        if (general)\n            len = *(CK_ULONG *) ctx->mech.pParameter;\n        else\n            len = mac_len;\n\n        if (CRYPTO_memcmp(signature, mac, len) != 0) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n            rv = CKR_SIGNATURE_INVALID;\n        }\n    }\ndone:\n    EVP_MD_CTX_destroy(mdctx);\n    ctx->context = NULL;\n    return rv;\n}\n\nCK_RV token_specific_hmac_sign_final(STDLL_TokData_t *tokdata, SESSION *sess,\n                                     CK_BYTE *signature, CK_ULONG *sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_final(&sess->sign_ctx, signature, sig_len, TRUE);\n}\n\nCK_RV token_specific_hmac_verify_final(STDLL_TokData_t *tokdata,\n                                       SESSION *sess, CK_BYTE *signature,\n                                       CK_ULONG sig_len)\n{\n    UNUSED(tokdata);\n\n    return softtok_hmac_final(&sess->verify_ctx, signature, &sig_len, FALSE);\n}\n\nCK_RV token_specific_generic_secret_key_gen(STDLL_TokData_t *tokdata,\n                                            TEMPLATE *tmpl)\n{\n    CK_ATTRIBUTE *gkey = NULL;\n    CK_RV rc = CKR_OK;\n    CK_BYTE secret_key[MAX_GENERIC_KEY_SIZE];\n    CK_ULONG key_length = 0;\n    CK_ULONG key_length_in_bits = 0;\n\n    rc = template_attribute_get_ulong(tmpl, CKA_VALUE_LEN, &key_length);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"CKA_VALUE_LEN missing in (HMAC) key template\\n\");\n        return CKR_TEMPLATE_INCOMPLETE;\n    }\n\n    //app specified key length in bytes\n    key_length_in_bits = key_length * 8;\n\n    /* After looking at fips cavs test vectors for HMAC ops,\n     * it was decided that the key length should fall between\n     * 80 and 2048 bits inclusive. openssl does not explicitly\n     * specify limits to key sizes for secret keys\n     */\n    if ((key_length_in_bits < 80) || (key_length_in_bits > 2048)) {\n        TRACE_ERROR(\"Generic secret key size of %lu bits not within\"\n                    \" required range of 80-2048 bits\\n\", key_length_in_bits);\n        return CKR_KEY_SIZE_RANGE;\n    }\n\n    rc = rng_generate(tokdata, secret_key, key_length);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"Generic secret key generation failed.\\n\");\n        return rc;\n    }\n\n    rc = build_attribute(CKA_VALUE, secret_key, key_length, &gkey);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"build_attribute(CKA_VALUE) failed\\n\");\n        return rc;\n    }\n\n    rc = template_update_attribute(tmpl, gkey);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"template_update_attribute(CKA_VALUE) failed.\\n\");\n        free(gkey);\n    }\n\n    return rc;\n}\n\nCK_RV token_specific_tdes_cmac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                               CK_ULONG message_len, OBJECT *key, CK_BYTE *mac,\n                               CK_BBOOL first, CK_BBOOL last, CK_VOID_PTR *ctx)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    int rc;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_KEY_TYPE keytype;\n    CMAC_CTX *cmac_ctx;\n    const EVP_CIPHER *cipher;\n    size_t maclen;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        // get the key type\n        rc = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key.\\n\");\n            return CKR_FUNCTION_FAILED;\n        }\n\n        // get the key value\n        rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n            return rc;\n        }\n        switch (keytype) {\n        case CKK_DES2:\n            cipher = EVP_des_ede_cbc();\n            break;\n        case CKK_DES3:\n            cipher = EVP_des_ede3_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key type: %lu\\n\", keytype);\n            return CKR_KEY_TYPE_INCONSISTENT;\n        }\n        if (cipher == NULL) {\n            TRACE_ERROR(\"Failed to allocate cipher\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        cmac_ctx = CMAC_CTX_new();\n        if (cmac_ctx == NULL) {\n            TRACE_ERROR(\"Failed to allocate CMAC context\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        rc = CMAC_Init(cmac_ctx, attr->pValue, attr->ulValueLen, cipher, NULL);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Init failed\\n\");\n            CMAC_CTX_free(cmac_ctx);\n            return CKR_FUNCTION_FAILED;\n        }\n\n        *ctx = cmac_ctx;\n    }\n\n    cmac_ctx = (CMAC_CTX *)*ctx;\n\n    rc = CMAC_Update(cmac_ctx, message, message_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"CMAC_Update failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n        rc = CMAC_Final(cmac_ctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Final failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n        }\n    }\n\n    if (last || (first && rv != CKR_OK)) {\n        CMAC_CTX_free(cmac_ctx);\n        *ctx = NULL;\n    }\n\n    return rv;\n#else\n    int rc;\n    size_t maclen;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    CK_KEY_TYPE keytype;\n    const EVP_CIPHER *cipher;\n    struct cmac_ctx {\n        EVP_MD_CTX *mctx;\n        EVP_PKEY_CTX *pctx;\n        EVP_PKEY *pkey;\n    };\n    struct cmac_ctx *cmac = NULL;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        // get the key type\n        rv = template_attribute_get_ulong(key->template, CKA_KEY_TYPE, &keytype);\n        if (rv != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_KEY_TYPE for the key\\n\");\n            return rv;\n        }\n\n        // get the key value\n        rv = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rv != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key\\n\");\n            return rv;\n        }\n\n        switch (keytype) {\n        case CKK_DES2:\n            cipher = EVP_des_ede_cbc();\n            break;\n        case CKK_DES3:\n            cipher = EVP_des_ede3_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key type: %lu\\n\", keytype);\n            rv = CKR_KEY_TYPE_INCONSISTENT;\n            goto err;\n        }\n\n        cmac = calloc(1, sizeof(*cmac));\n        if (cmac == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->mctx = EVP_MD_CTX_new();\n        if (cmac->mctx == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->pkey = EVP_PKEY_new_CMAC_key(NULL,\n                                           attr->pValue, attr->ulValueLen,\n                                           cipher);\n        if (cmac->pkey == NULL) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        if (EVP_DigestSignInit(cmac->mctx, &cmac->pctx,\n                               NULL, NULL, cmac->pkey) != 1) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        *ctx = cmac;\n    }\n\n    cmac = (struct cmac_ctx *)*ctx;\n    if (cmac == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    rc = EVP_DigestSignUpdate(cmac->mctx, message, message_len);\n    if (rc != 1 || message_len > INT_MAX) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n\n        rc = EVP_DigestSignFinal(cmac->mctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n        *ctx = NULL;\n    }\n\n    return CKR_OK;\nerr:\n    if (cmac != NULL) {\n        if (cmac->mctx != NULL)\n            EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        if (cmac->pkey != NULL)\n            EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n    }\n    *ctx = NULL;\n    return rv;\n#endif\n}\n\n\nCK_RV token_specific_aes_cmac(STDLL_TokData_t *tokdata, CK_BYTE *message,\n                              CK_ULONG message_len, OBJECT *key, CK_BYTE *mac,\n                              CK_BBOOL first, CK_BBOOL last, CK_VOID_PTR *ctx)\n{\n#if OPENSSL_VERSION_NUMBER < 0x10101000L\n    int rc;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    CMAC_CTX *cmac_ctx;\n    const EVP_CIPHER *cipher;\n    size_t maclen;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n            return rc;\n        }\n\n        switch (attr->ulValueLen * 8) {\n        case 128:\n            cipher = EVP_aes_128_cbc();\n            break;\n        case 192:\n            cipher = EVP_aes_192_cbc();\n            break;\n        case 256:\n            cipher = EVP_aes_256_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key size: %lu\\n\", attr->ulValueLen);\n            return CKR_KEY_TYPE_INCONSISTENT;\n        }\n        if (cipher == NULL) {\n            TRACE_ERROR(\"Failed to allocate cipher\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        cmac_ctx = CMAC_CTX_new();\n        if (cmac_ctx == NULL) {\n            TRACE_ERROR(\"Failed to allocate CMAC context\\n\");\n            return CKR_HOST_MEMORY;\n        }\n\n        rc = CMAC_Init(cmac_ctx, attr->pValue, attr->ulValueLen, cipher, NULL);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Init failed\\n\");\n            CMAC_CTX_free(cmac_ctx);\n            return CKR_FUNCTION_FAILED;\n        }\n\n        *ctx = cmac_ctx;\n    }\n\n    cmac_ctx = (CMAC_CTX *)*ctx;\n\n    rc = CMAC_Update(cmac_ctx, message, message_len);\n    if (rc != 1) {\n        TRACE_ERROR(\"CMAC_Update failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n        rc = CMAC_Final(cmac_ctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"CMAC_Final failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n        }\n    }\n\n    if (last || (first && rv != CKR_OK)) {\n        CMAC_CTX_free(cmac_ctx);\n        *ctx = NULL;\n    }\n\n    return rv;\n#else\n    int rc;\n    size_t maclen;\n    CK_RV rv = CKR_OK;\n    CK_ATTRIBUTE *attr = NULL;\n    const EVP_CIPHER *cipher;\n    struct cmac_ctx {\n        EVP_MD_CTX *mctx;\n        EVP_PKEY_CTX *pctx;\n        EVP_PKEY *pkey;\n    };\n    struct cmac_ctx *cmac = NULL;\n\n    UNUSED(tokdata);\n\n    if (first) {\n        // get the key value\n        rc = template_attribute_get_non_empty(key->template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE for the key.\\n\");\n            goto err;\n        }\n\n        switch (attr->ulValueLen * 8) {\n        case 128:\n            cipher = EVP_aes_128_cbc();\n            break;\n        case 192:\n            cipher = EVP_aes_192_cbc();\n            break;\n        case 256:\n            cipher = EVP_aes_256_cbc();\n            break;\n        default:\n            TRACE_ERROR(\"Invalid key size: %lu\\n\", attr->ulValueLen);\n            return CKR_KEY_TYPE_INCONSISTENT;\n        }\n\n        cmac = calloc(1, sizeof(*cmac));\n        if (cmac == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->mctx = EVP_MD_CTX_new();\n        if (cmac->mctx == NULL) {\n            TRACE_ERROR(\"%s\\n\", ock_err(ERR_HOST_MEMORY));\n            rv = ERR_HOST_MEMORY;\n            goto err;\n        }\n\n        cmac->pkey = EVP_PKEY_new_CMAC_key(NULL,\n                                           attr->pValue, attr->ulValueLen,\n                                           cipher);\n        if (cmac->pkey == NULL) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        if (EVP_DigestSignInit(cmac->mctx, &cmac->pctx,\n                               NULL, NULL, cmac->pkey) != 1) {\n            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        *ctx = cmac;\n    }\n\n    cmac = (struct cmac_ctx *)*ctx;\n    if (cmac == NULL) {\n        TRACE_ERROR(\"%s\\n\", ock_err(ERR_FUNCTION_FAILED));\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    rc = EVP_DigestSignUpdate(cmac->mctx, message, message_len);\n    if (rc != 1 || message_len > INT_MAX) {\n        TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n        rv =  CKR_FUNCTION_FAILED;\n        goto err;\n    }\n\n    if (last) {\n        maclen = AES_BLOCK_SIZE;\n\n        rc = EVP_DigestSignFinal(cmac->mctx, mac, &maclen);\n        if (rc != 1) {\n            TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");\n            rv = CKR_FUNCTION_FAILED;\n            goto err;\n        }\n\n        EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n        *ctx = NULL;\n    }\n\n    return CKR_OK;\nerr:\n    if (cmac != NULL) {\n        if (cmac->mctx != NULL)\n            EVP_MD_CTX_free(cmac->mctx); /* frees pctx */\n        if (cmac->pkey != NULL)\n            EVP_PKEY_free(cmac->pkey);\n        free(cmac);\n    }\n    *ctx = NULL;\n    return rv;\n#endif\n}\n\n#ifndef NO_EC\n\nstatic CK_RV make_ec_key_from_params(const CK_BYTE *params, CK_ULONG params_len,\n                                     EC_KEY **key)\n{\n    const unsigned char *oid;\n    ASN1_OBJECT *obj = NULL;\n    EC_KEY *ec_key = NULL;\n    int nid;\n    CK_RV rc = CKR_OK;\n\n    oid = params;\n    obj = d2i_ASN1_OBJECT(NULL, &oid, params_len);\n    if (obj == NULL) {\n        TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");\n        rc = CKR_CURVE_NOT_SUPPORTED;\n        goto out;\n    }\n\n    nid = OBJ_obj2nid(obj);\n    if (nid == NID_undef) {\n        TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");\n        rc = CKR_CURVE_NOT_SUPPORTED;\n        goto out;\n    }\n\n    ec_key = EC_KEY_new_by_curve_name(nid);\n    if (ec_key == NULL) {\n       TRACE_ERROR(\"curve not supported by OpenSSL.\\n\");\n       rc = CKR_CURVE_NOT_SUPPORTED;\n       goto out;\n    }\n\nout:\n    if (obj != NULL)\n        ASN1_OBJECT_free(obj);\n\n    if (rc != CKR_OK) {\n        if (ec_key != NULL)\n            EC_KEY_free(ec_key);\n\n        return rc;\n    }\n\n    *key = ec_key;\n\n    return CKR_OK;\n}\n\nstatic CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                     CK_ULONG data_len, CK_BBOOL allow_raw)\n{\n    CK_BYTE *ecpoint = NULL;\n    CK_ULONG ecpoint_len, privlen;\n    CK_BBOOL allocated = FALSE;\n    CK_RV rc;\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,\n                                   &allocated, &ecpoint, &ecpoint_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"ec_point_from_public_data failed\\n\");\n        goto out;\n    }\n\n    if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {\n        TRACE_ERROR(\"EC_KEY_oct2key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_check_key(ec_key)) {\n        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n        rc = CKR_PUBLIC_KEY_INVALID;\n        goto out;\n    }\n\nout:\n    if (allocated && ecpoint != NULL)\n        free(ecpoint);\n\n    return rc;\n}\n\nstatic CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,\n                                      CK_ULONG data_len)\n{\n    EC_POINT *point = NULL;\n    CK_RV rc = CKR_OK;\n\n    if (!EC_KEY_oct2priv(ec_key, data, data_len)) {\n        TRACE_ERROR(\"EC_KEY_oct2priv failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    point = EC_POINT_new(EC_KEY_get0_group(ec_key));\n    if (point == NULL) {\n        TRACE_ERROR(\"EC_POINT_new failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,\n                      EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {\n        TRACE_ERROR(\"EC_POINT_mul failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_set_public_key(ec_key, point)) {\n        TRACE_ERROR(\"EC_KEY_set_public_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!EC_KEY_check_key(ec_key)) {\n        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\nout:\n    if (point != NULL)\n        EC_POINT_free(point);\n\n    return rc;\n}\n\nstatic CK_RV make_ec_key_from_template(TEMPLATE *template, EC_KEY **key)\n{\n    CK_ATTRIBUTE *attr = NULL;\n    CK_OBJECT_CLASS keyclass;\n    EC_KEY *ec_key = NULL;\n    CK_RV rc;\n\n    rc = template_attribute_get_ulong(template, CKA_CLASS, &keyclass);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_CLASS in the template\\n\");\n        goto out;\n    }\n\n    rc = template_attribute_get_non_empty(template, CKA_ECDSA_PARAMS, &attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"Could not find CKA_ECDSA_PARAMS in the template\\n\");\n        goto out;\n    }\n\n    rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);\n    if (rc != CKR_OK)\n        goto out;\n\n    switch (keyclass) {\n    case CKO_PUBLIC_KEY:\n        rc = template_attribute_get_non_empty(template, CKA_EC_POINT, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_EC_POINT in the template\\n\");\n            goto out;\n        }\n\n        rc = fill_ec_key_from_pubkey(ec_key, attr->pValue, attr->ulValueLen,\n                                     FALSE);\n        if (rc != CKR_OK) {\n            TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");\n            goto out;\n        }\n        break;\n\n    case CKO_PRIVATE_KEY:\n        rc = template_attribute_get_non_empty(template, CKA_VALUE, &attr);\n        if (rc != CKR_OK) {\n            TRACE_ERROR(\"Could not find CKA_VALUE in the template\\n\");\n            goto out;\n        }\n\n        rc = fill_ec_key_from_privkey(ec_key, attr->pValue, attr->ulValueLen);\n        if (rc != CKR_OK) {\n            TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");\n            goto out;\n        }\n        break;\n\n    default:\n        rc = CKR_KEY_FUNCTION_NOT_PERMITTED;\n        goto out;\n    }\n\n    rc = CKR_OK;\n\nout:\n    if (rc != CKR_OK) {\n        if (ec_key != NULL)\n            EC_KEY_free(ec_key);\n\n        return rc;\n    }\n\n    *key = ec_key;\n\n    return CKR_OK;\n}\n\nCK_RV token_specific_ec_generate_keypair(STDLL_TokData_t *tokdata,\n                                         TEMPLATE *publ_tmpl,\n                                         TEMPLATE *priv_tmpl)\n{\n\n    CK_ATTRIBUTE *attr = NULL, *ec_point_attr, *value_attr, *parms_attr;\n    EC_KEY *ec_key = NULL;\n    BN_CTX *ctx = NULL;\n    CK_BYTE *ecpoint = NULL, *enc_ecpoint = NULL, *d = NULL;\n    CK_ULONG ecpoint_len, enc_ecpoint_len, d_len;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = template_attribute_get_non_empty(publ_tmpl, CKA_ECDSA_PARAMS, &attr);\n    if (rc != CKR_OK)\n        goto out;\n\n    rc = make_ec_key_from_params(attr->pValue, attr->ulValueLen, &ec_key);\n    if (rc != CKR_OK)\n        goto out;\n\n    if (!EC_KEY_generate_key(ec_key)) {\n        TRACE_ERROR(\"Failed to generate an EC key.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL) {\n        rc = CKR_HOST_MEMORY;\n        goto out;\n    }\n\n    ecpoint_len = EC_KEY_key2buf(ec_key, POINT_CONVERSION_UNCOMPRESSED,\n                                 &ecpoint, ctx);\n    if (ecpoint_len == 0) {\n        TRACE_ERROR(\"Failed to get the EC Point compressed.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    rc = ber_encode_OCTET_STRING(FALSE, &enc_ecpoint, &enc_ecpoint_len,\n                                 ecpoint, ecpoint_len);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"ber_encode_OCTET_STRING failed\\n\");\n        goto out;\n    }\n\n    rc = build_attribute(CKA_EC_POINT, enc_ecpoint, enc_ecpoint_len,\n                         &ec_point_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"build_attribute for CKA_EC_POINT failed rc=0x%lx\\n\", rc);\n        goto out;\n    }\n    rc = template_update_attribute(publ_tmpl, ec_point_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(ec_point_attr);\n        goto out;\n    }\n\n    d_len = EC_KEY_priv2buf(ec_key, &d);\n    if (d_len == 0) {\n        TRACE_ERROR(\"Failed to get the EC private key.\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    rc = build_attribute(CKA_VALUE, d, d_len, &value_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"build_attribute for CKA_VALUE failed, rc=0x%lx\\n\", rc);\n        goto out;\n    }\n    rc = template_update_attribute(priv_tmpl, value_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(value_attr);\n        goto out;\n    }\n\n\n    /* Add CKA_ECDSA_PARAMS to private template also */\n    rc = build_attribute(CKA_ECDSA_PARAMS, attr->pValue, attr->ulValueLen,\n                         &parms_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"build_attribute for CKA_ECDSA_PARAMS failed, rc=0x%lx\\n\",\n                     rc);\n        goto out;\n    }\n    rc = template_update_attribute(priv_tmpl, parms_attr);\n    if (rc != CKR_OK) {\n        TRACE_ERROR(\"template_update_attribute failed\\n\");\n        free(parms_attr);\n        goto out;\n    }\n\n    rc = CKR_OK;\n\nout:\n    if (ctx)\n        BN_CTX_free(ctx);\n    if (ec_key != NULL)\n        EC_KEY_free(ec_key);\n    if (ecpoint != NULL)\n        OPENSSL_free(ecpoint);\n    if (enc_ecpoint != NULL)\n        free(enc_ecpoint);\n    if (d != NULL)\n        OPENSSL_free(d);\n\n    return rc;\n}\n\nCK_RV token_specific_ec_sign(STDLL_TokData_t *tokdata,  SESSION *sess,\n                             CK_BYTE *in_data, CK_ULONG in_data_len,\n                             CK_BYTE *out_data, CK_ULONG *out_data_len,\n                             OBJECT *key_obj)\n{\n    EC_KEY *ec_key;\n    ECDSA_SIG *sig;\n    const BIGNUM *r, *s;\n    CK_ULONG privlen, n;\n    CK_RV rc = CKR_OK;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    *out_data_len = 0;\n\n    rc = make_ec_key_from_template(key_obj->template, &ec_key);\n    if (rc != CKR_OK)\n        return rc;\n\n    sig = ECDSA_do_sign(in_data, in_data_len, ec_key);\n    if (sig == NULL) {\n        TRACE_ERROR(\"ECDSA_do_sign failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    ECDSA_SIG_get0(sig, &r, &s);\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    /* Insert leading 0x00's if r or s shorter than privlen */\n    n = privlen - BN_num_bytes(r);\n    memset(out_data, 0x00, n);\n    BN_bn2bin(r, &out_data[n]);\n\n    n = privlen - BN_num_bytes(s);\n    memset(out_data + privlen, 0x00, n);\n    BN_bn2bin(s, &out_data[privlen + n]);\n\n    *out_data_len = 2 * privlen;\n\nout:\n    if (sig != NULL)\n        ECDSA_SIG_free(sig);\n    if (ec_key != NULL)\n        EC_KEY_free(ec_key);\n\n    return rc;\n}\n\nCK_RV token_specific_ec_verify(STDLL_TokData_t *tokdata,\n                               SESSION *sess,\n                               CK_BYTE *in_data,\n                               CK_ULONG in_data_len,\n                               CK_BYTE *signature,\n                               CK_ULONG signature_len, OBJECT *key_obj)\n{\n    EC_KEY *ec_key;\n    CK_ULONG privlen;\n    ECDSA_SIG *sig = NULL;\n    BIGNUM *r = NULL, *s = NULL;\n    CK_RV rc = CKR_OK;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    rc = make_ec_key_from_template(key_obj->template, &ec_key);\n    if (rc != CKR_OK)\n        return rc;\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;\n\n    if (signature_len < 2 * privlen) {\n        TRACE_ERROR(\"Signature is too short\\n\");\n        rc = CKR_SIGNATURE_LEN_RANGE;\n        goto out;\n    }\n\n    sig = ECDSA_SIG_new();\n    if (sig == NULL) {\n        rc = CKR_HOST_MEMORY;\n        goto out;\n    }\n\n    r = BN_bin2bn(signature, privlen, NULL);\n    s = BN_bin2bn(signature + privlen, privlen, NULL);\n    if (r == NULL || s == NULL) {\n        TRACE_ERROR(\"BN_bin2bn failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    if (!ECDSA_SIG_set0(sig, r, s)) {\n        TRACE_ERROR(\"ECDSA_SIG_set0 failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        goto out;\n    }\n\n    rc = ECDSA_do_verify(in_data, in_data_len, sig, ec_key);\n    switch (rc) {\n    case 0:\n        rc = CKR_SIGNATURE_INVALID;\n        break;\n    case 1:\n        rc = CKR_OK;\n        break;\n    default:\n        rc = CKR_FUNCTION_FAILED;\n        break;\n    }\n\nout:\n    if (sig != NULL)\n        ECDSA_SIG_free(sig);\n    if (ec_key != NULL)\n        EC_KEY_free(ec_key);\n\n    return rc;\n}\n\nCK_RV token_specific_ecdh_pkcs_derive(STDLL_TokData_t *tokdata,\n                                      CK_BYTE *priv_bytes,\n                                      CK_ULONG priv_length,\n                                      CK_BYTE *pub_bytes,\n                                      CK_ULONG pub_length,\n                                      CK_BYTE *secret_value,\n                                      CK_ULONG *secret_value_len,\n                                      CK_BYTE *oid, CK_ULONG oid_length)\n{\n    EC_KEY *ec_pub = NULL, *ec_priv = NULL;\n    CK_ULONG privlen;\n    int secret_len;\n    CK_RV rc;\n\n    UNUSED(tokdata);\n\n    rc = make_ec_key_from_params(oid, oid_length, &ec_priv);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");\n        goto out;\n    }\n\n    rc = fill_ec_key_from_privkey(ec_priv, priv_bytes, priv_length);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"fill_ec_key_from_privkey failed\\n\");\n        goto out;\n    }\n\n    rc = make_ec_key_from_params(oid, oid_length, &ec_pub);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"make_ec_key_from_params failed\\n\");\n        goto out;\n    }\n\n    rc = fill_ec_key_from_pubkey(ec_pub, pub_bytes, pub_length, TRUE);\n    if (rc != CKR_OK) {\n        TRACE_DEVEL(\"fill_ec_key_from_pubkey failed\\n\");\n        goto out;\n    }\n\n    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_priv)) + 7) / 8;\n\n    secret_len = ECDH_compute_key(secret_value, privlen,\n                                  EC_KEY_get0_public_key(ec_pub), ec_priv,\n                                  NULL);\n    if (secret_len <= 0) {\n        TRACE_DEVEL(\"ECDH_compute_key failed\\n\");\n        rc = CKR_FUNCTION_FAILED;\n        *secret_value_len = 0;\n        goto out;\n    }\n\n    *secret_value_len = secret_len;\n\nout:\n    if (ec_priv != NULL)\n        EC_KEY_free(ec_priv);\n    if (ec_pub != NULL)\n        EC_KEY_free(ec_pub);\n\n    return rc;\n}\n\n#endif\n\nCK_RV token_specific_object_add(STDLL_TokData_t * tokdata, SESSION * sess,\n                                OBJECT * obj)\n{\n    CK_KEY_TYPE keytype;\n#ifndef NO_EC\n    EC_KEY *ec_key = NULL;\n#endif\n    CK_RV rc;\n\n    UNUSED(tokdata);\n    UNUSED(sess);\n\n    rc = template_attribute_get_ulong(obj->template, CKA_KEY_TYPE, &keytype);\n    if (rc != CKR_OK)\n        return CKR_OK;\n\n    switch (keytype) {\n#ifndef NO_EC\n    case CKK_EC:\n        /* Check if OpenSSL supports the curve */\n        rc = make_ec_key_from_template(obj->template, &ec_key);\n        if (ec_key != NULL)\n                EC_KEY_free(ec_key);\n        return rc;\n#endif\n\n    default:\n        return CKR_OK;;\n    }\n}\n\n"], "filenames": ["usr/lib/soft_stdll/soft_specific.c"], "buggy_code_start_loc": [4367], "buggy_code_end_loc": [4402], "fixing_code_start_loc": [4368], "fixing_code_end_loc": [4415], "type": "CWE-200", "message": "A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack.", "other": {"cve": {"id": "CVE-2021-3798", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:09.930", "lastModified": "2023-02-12T23:42:48.547", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack."}, {"lang": "es", "value": "Se ha encontrado un fallo en openCryptoki. El token de openCryptoki Soft no comprueba si una clave EC es v\u00e1lida cuando es creada una clave EC por medio de C_CreateObject, ni cuando es usada C_DeriveKey con datos p\u00fablicos ECDH. Esto puede permitir a un usuario malicioso extraer la clave privada llevando a cabo un ataque de curva no v\u00e1lida."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opencryptoki_project:opencryptoki:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.17.0", "matchCriteriaId": "F9E5EB07-9490-4AB0-BE69-412ED0BF7F4B"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3798", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1990591", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencryptoki/opencryptoki/pull/402", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0"}}