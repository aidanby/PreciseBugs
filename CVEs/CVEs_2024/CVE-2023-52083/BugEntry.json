{"buggy_code": ["<?php\n\nnamespace System\\Classes;\n\nuse ApplicationException;\nuse Cache;\nuse Config;\nuse Illuminate\\Filesystem\\FilesystemAdapter;\nuse Lang;\nuse Storage;\nuse SystemException;\nuse Url;\nuse Winter\\Storm\\Filesystem\\Definitions as FileDefinitions;\nuse Winter\\Storm\\Support\\Str;\nuse Winter\\Storm\\Support\\Svg;\n\n/**\n * Provides abstraction level for the Media Library operations.\n * Implements the library caching features and security checks.\n *\n * @package winter\\wn-system-module\n * @author Alexey Bobkov, Samuel Georges\n */\nclass MediaLibrary\n{\n    use \\Winter\\Storm\\Support\\Traits\\Singleton;\n\n    const SORT_BY_TITLE = 'title';\n    const SORT_BY_SIZE = 'size';\n    const SORT_BY_MODIFIED = 'modified';\n    const SORT_DIRECTION_ASC = 'asc';\n    const SORT_DIRECTION_DESC = 'desc';\n\n    /**\n     * @var string Cache key\n     */\n    protected $cacheKey = 'system-media-library-contents';\n\n    /**\n     * @var string Relative or absolute URL of the Library root folder.\n     */\n    protected $storagePath;\n\n    /**\n     * @var string The root Library folder path.\n     */\n    protected $storageFolder;\n\n    /**\n     * @var mixed A reference to the Media Library disk.\n     */\n    protected $storageDisk;\n\n    /**\n     * @var array Contains a list of files and directories to ignore.\n     * The list can be customized with cms.storage.media.ignore configuration option.\n     */\n    protected $ignoreNames;\n\n    /**\n     * @var array Contains a list of regex patterns to ignore in files and directories.\n     * The list can be customized with cms.storage.media.ignorePatterns configuration option.\n     */\n    protected $ignorePatterns;\n\n    /**\n     * @var int Cache for the storage folder name length.\n     */\n    protected $storageFolderNameLength;\n\n    /**\n     * Initialize this singleton.\n     */\n    protected function init()\n    {\n        $this->storageFolder = self::validatePath(Config::get('cms.storage.media.folder', 'media'), true);\n        $this->storagePath = rtrim(Config::get('cms.storage.media.path', '/storage/app/media'), '/');\n\n        $this->ignoreNames = Config::get('cms.storage.media.ignore', FileDefinitions::get('ignoreFiles'));\n\n        $this->ignorePatterns = Config::get('cms.storage.media.ignorePatterns', ['^\\..*']);\n\n        $this->storageFolderNameLength = strlen($this->storageFolder);\n    }\n\n    /**\n     * Set the cache key\n     *\n     * @param string $cacheKey The key to set as the cache key for this instance\n     */\n    public function setCacheKey($cacheKey)\n    {\n        $this->cacheKey = $cacheKey;\n    }\n\n    /**\n     * Get the cache key\n     *\n     * @return string The cache key to set as the cache key for this instance\n     */\n    public function getCacheKey()\n    {\n        return $this->cacheKey;\n    }\n\n    /**\n     * Returns a list of folders and files in a Library folder.\n     *\n     * @param string $folder Specifies the folder path relative the the Library root.\n     * @param mixed $sortBy Determines the sorting preference.\n     * Supported values are 'title', 'size', 'lastModified' (see SORT_BY_XXX class constants), FALSE (to disable sorting), or an associative array with a 'by' key and a 'direction' key: ['by' => SORT_BY_XXX, 'direction' => SORT_DIRECTION_XXX].\n     * @param string $filter Determines the document type filtering preference.\n     * Supported values are 'image', 'video', 'audio', 'document' (see FILE_TYPE_XXX constants of MediaLibraryItem class).\n     * @param boolean $ignoreFolders Determines whether folders should be suppressed in the result list.\n     * @return array Returns an array of MediaLibraryItem objects.\n     */\n    public function listFolderContents($folder = '/', $sortBy = 'title', $filter = null, $ignoreFolders = false)\n    {\n        $folder = self::validatePath($folder);\n        $fullFolderPath = $this->getMediaPath($folder);\n\n        /*\n         * Try to load the contents from cache\n         */\n\n        $cached = Cache::get($this->cacheKey, false);\n        $cached = $cached ? @unserialize(@base64_decode($cached)) : [];\n\n        if (!is_array($cached)) {\n            $cached = [];\n        }\n\n        if (array_key_exists($fullFolderPath, $cached)) {\n            $folderContents = $cached[$fullFolderPath];\n        }\n        else {\n            $folderContents = $this->scanFolderContents($fullFolderPath);\n\n            $cached[$fullFolderPath] = $folderContents;\n            $expiresAt = now()->addMinutes(Config::get('cms.storage.media.ttl', 10));\n            Cache::put(\n                $this->cacheKey,\n                base64_encode(serialize($cached)),\n                $expiresAt\n            );\n        }\n\n        /*\n         * Sort the result and combine the file and folder lists\n         */\n\n        if ($sortBy !== false) {\n            $this->sortItemList($folderContents['files'], $sortBy);\n            $this->sortItemList($folderContents['folders'], $sortBy);\n        }\n\n        $this->filterItemList($folderContents['files'], $filter);\n\n        if (!$ignoreFolders) {\n            $folderContents = array_merge($folderContents['folders'], $folderContents['files']);\n        }\n        else {\n            $folderContents = $folderContents['files'];\n        }\n\n        return $folderContents;\n    }\n\n    /**\n     * Finds files in the Library.\n     * @param string $searchTerm Specifies the search term.\n     * @param mixed $sortBy Determines the sorting preference.\n     * Supported values are 'title', 'size', 'lastModified' (see SORT_BY_XXX class constants), FALSE (to disable sorting), or an associative array with a 'by' key and a 'direction' key: ['by' => SORT_BY_XXX, 'direction' => SORT_DIRECTION_XXX].\n     * @param string $filter Determines the document type filtering preference.\n     * Supported values are 'image', 'video', 'audio', 'document' (see FILE_TYPE_XXX constants of MediaLibraryItem class).\n     * @return array Returns an array of MediaLibraryItem objects.\n     */\n    public function findFiles($searchTerm, $sortBy = 'title', $filter = null)\n    {\n        $words = explode(' ', Str::lower($searchTerm));\n        $result = [];\n\n        $findInFolder = function ($folder) use (&$findInFolder, $words, &$result, $sortBy, $filter) {\n            $folderContents = $this->listFolderContents($folder, $sortBy, $filter);\n\n            foreach ($folderContents as $item) {\n                if ($item->type == MediaLibraryItem::TYPE_FOLDER) {\n                    $findInFolder($item->path);\n                }\n                elseif ($this->pathMatchesSearch($item->path, $words)) {\n                    $result[] = $item;\n                }\n            }\n        };\n\n        $findInFolder('/');\n\n        /*\n         * Sort the result\n         */\n\n        if ($sortBy !== false) {\n            $this->sortItemList($result, $sortBy);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Deletes a file from the Library.\n     * @param array $paths A list of file paths relative to the Library root to delete.\n     */\n    public function deleteFiles($paths)\n    {\n        $fullPaths = [];\n        foreach ($paths as $path) {\n            $path = self::validatePath($path);\n            $fullPaths[] = $this->getMediaPath($path);\n        }\n\n        return $this->getStorageDisk()->delete($fullPaths);\n    }\n\n    /**\n     * Deletes a folder from the Library.\n     * @param string $path Specifies the folder path relative to the Library root.\n     */\n    public function deleteFolder($path)\n    {\n        $path = self::validatePath($path);\n        $fullPaths = $this->getMediaPath($path);\n\n        return $this->getStorageDisk()->deleteDirectory($fullPaths);\n    }\n\n    /**\n     * Determines if a file with the specified path exists in the library.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @return boolean Returns TRUE if the file exists.\n     */\n    public function exists($path)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n\n        return $this->getStorageDisk()->exists($fullPath);\n    }\n\n    /**\n     * Determines if a folder with the specified path exists in the library.\n     * @param string $path Specifies the folder path relative the the Library root.\n     * @return boolean Returns TRUE if the folder exists.\n     */\n    public function folderExists($path)\n    {\n        $folderName = basename($path);\n        $folderPath = dirname($path);\n\n        $path = self::validatePath($folderPath);\n        $fullPath = $this->getMediaPath($path);\n\n        $folders = $this->getStorageDisk()->directories($fullPath);\n        foreach ($folders as $folder) {\n            if (basename($folder) == $folderName) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns a list of all directories in the Library, optionally excluding some of them.\n     * @param array $exclude A list of folders to exclude from the result list.\n     * The folder paths should be specified relative to the Library root.\n     * @return array\n     */\n    public function listAllDirectories($exclude = [])\n    {\n        $fullPath = $this->getMediaPath('/');\n\n        $folders = $this->getStorageDisk()->allDirectories($fullPath);\n\n        $folders = array_unique($folders, SORT_LOCALE_STRING);\n\n        $result = [];\n\n        foreach ($folders as $folder) {\n            $folder = $this->getMediaRelativePath($folder);\n            if (!strlen($folder)) {\n                $folder = '/';\n            }\n\n            if (Str::startsWith($folder, $exclude)) {\n                continue;\n            }\n            if (!$this->isVisible($folder)) {\n                $exclude[] = $folder . '/';\n                continue;\n            }\n\n            $result[] = $folder;\n        }\n\n        if (!in_array('/', $result)) {\n            array_unshift($result, '/');\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns a file contents.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @return string Returns the file contents\n     */\n    public function get($path)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n        return $this->getStorageDisk()->get($fullPath);\n    }\n\n    /**\n     * Puts a file to the library.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @param string $contents Specifies the file contents.\n     * @return boolean\n     */\n    public function put($path, $contents)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n        return $this->getStorageDisk()->put($fullPath, $contents);\n    }\n\n    /**\n     * Moves a file to another location.\n     * @param string $oldPath Specifies the original path of the file.\n     * @param string $newPath Specifies the new path of the file.\n     * @return boolean\n     */\n    public function moveFile($oldPath, $newPath, $isRename = false)\n    {\n        $oldPath = self::validatePath($oldPath);\n        $fullOldPath = $this->getMediaPath($oldPath);\n\n        $newPath = self::validatePath($newPath);\n        $fullNewPath = $this->getMediaPath($newPath);\n\n        // If the file extension is changed to SVG, ensure that it has been sanitized\n        $oldExt = pathinfo($oldPath, PATHINFO_EXTENSION);\n        $newExt = pathinfo($newPath, PATHINFO_EXTENSION);\n        if ($oldExt !== $newExt && $newExt === 'svg') {\n            $contents = $this->getStorageDisk()->get($fullOldPath);\n            $contents = Svg::sanitize($contents);\n            $this->getStorageDisk()->put($fullOldPath, $contents);\n        }\n\n        return $this->getStorageDisk()->move($fullOldPath, $fullNewPath);\n    }\n\n    /**\n     * Copies a folder.\n     * @param string $originalPath Specifies the original path of the folder.\n     * @param string $newPath Specifies the new path of the folder.\n     * @return boolean\n     */\n    public function copyFolder($originalPath, $newPath)\n    {\n        $disk = $this->getStorageDisk();\n\n        $copyDirectory = function ($srcPath, $destPath) use (&$copyDirectory, $disk) {\n            $srcPath = self::validatePath($srcPath);\n            $fullSrcPath = $this->getMediaPath($srcPath);\n\n            $destPath = self::validatePath($destPath);\n            $fullDestPath = $this->getMediaPath($destPath);\n\n            if (!$disk->makeDirectory($fullDestPath)) {\n                return false;\n            }\n\n            $folderContents = $this->scanFolderContents($fullSrcPath);\n\n            foreach ($folderContents['folders'] as $dirInfo) {\n                if (!$copyDirectory($dirInfo->path, $destPath.'/'.basename($dirInfo->path))) {\n                    return false;\n                }\n            }\n\n            foreach ($folderContents['files'] as $fileInfo) {\n                $fullFileSrcPath = $this->getMediaPath($fileInfo->path);\n\n                if (!$disk->copy($fullFileSrcPath, $fullDestPath.'/'.basename($fileInfo->path))) {\n                    return false;\n                }\n            }\n\n            return true;\n        };\n\n        return $copyDirectory($originalPath, $newPath);\n    }\n\n    /**\n     * Moves a folder.\n     * @param string $originalPath Specifies the original path of the folder.\n     * @param string $newPath Specifies the new path of the folder.\n     * @return boolean\n     */\n    public function moveFolder($originalPath, $newPath)\n    {\n        if (Str::lower($originalPath) !== Str::lower($newPath)) {\n            // If there is no risk that the directory was renamed\n            // by just changing the letter case in the name -\n            // copy the directory to the destination path and delete\n            // the source directory.\n\n            if (!$this->copyFolder($originalPath, $newPath)) {\n                return false;\n            }\n\n            $this->deleteFolder($originalPath);\n        }\n        else {\n            // If there's a risk that the directory name was updated\n            // by changing the letter case - swap source and destination\n            // using a temporary directory with random name.\n\n            $tempraryDirPath = $this->generateRandomTmpFolderName(dirname($originalPath));\n\n            if (!$this->copyFolder($originalPath, $tempraryDirPath)) {\n                $this->deleteFolder($tempraryDirPath);\n\n                return false;\n            }\n\n            $this->deleteFolder($originalPath);\n\n            return $this->moveFolder($tempraryDirPath, $newPath);\n        }\n\n        return true;\n    }\n\n    /**\n     * Creates a folder.\n     * @param string $path Specifies the folder path.\n     * @return boolean\n     */\n    public function makeFolder($path)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n\n        return $this->getStorageDisk()->makeDirectory($fullPath);\n    }\n\n    /**\n     * Resets the Library cache.\n     *\n     * The cache stores the library table of contents locally in order to optimize\n     * the performance when working with remote storages. The default cache TTL is\n     * 10 minutes. The cache is deleted automatically when an item is added, changed\n     * or deleted. This method allows to reset the cache forcibly.\n     */\n    public function resetCache()\n    {\n        Cache::forget($this->cacheKey);\n    }\n\n    /**\n     * Checks if file path doesn't contain any substrings that would pose a security threat.\n     * Throws an exception if the path is not valid.\n     * @param string $path Specifies the path.\n     * @param boolean $normalizeOnly Specifies if only the normalization, without validation should be performed.\n     * @return string Returns a normalized path.\n     */\n    public static function validatePath($path, $normalizeOnly = false)\n    {\n        $path = str_replace('\\\\', '/', $path);\n        $path = '/'.trim($path, '/');\n\n        if ($normalizeOnly) {\n            return $path;\n        }\n\n        /*\n         * Validate folder names\n         */\n        $regexWhitelist = [\n            '\\w', // any word character\n            preg_quote('@', '/'),\n            preg_quote('.', '/'),\n            '\\s', // whitespace character\n            preg_quote('-', '/'),\n            preg_quote('_', '/'),\n            preg_quote('/', '/'),\n            preg_quote('(', '/'),\n            preg_quote(')', '/'),\n            preg_quote('[', '/'),\n            preg_quote(']', '/'),\n            preg_quote(',', '/'),\n            preg_quote('=', '/'),\n            preg_quote(\"'\", '/'),\n            preg_quote('&', '/'),\n        ];\n\n        if (!preg_match('/^[' . implode('', $regexWhitelist) . ']+$/iu', $path)) {\n            throw new ApplicationException(Lang::get('system::lang.media.invalid_path', compact('path')));\n        }\n\n        $regexDirectorySeparator = preg_quote('/', '#');\n        $regexDot = preg_quote('.', '#');\n        $regex = [\n            // Beginning of path\n            '(^'.$regexDot.'+?'.$regexDirectorySeparator.')',\n\n            // Middle of path\n            '('.$regexDirectorySeparator.$regexDot.'+?'.$regexDirectorySeparator.')',\n\n            // End of path\n            '('.$regexDirectorySeparator.$regexDot.'+?$)',\n        ];\n\n        /*\n         * Validate invalid paths\n         */\n        $regex = '#'.implode('|', $regex).'#';\n        if (preg_match($regex, $path) !== 0 || strpos($path, '://') !== false) {\n            throw new ApplicationException(Lang::get('system::lang.media.invalid_path', compact('path')));\n        }\n\n        return $path;\n    }\n\n    /**\n     * Helper that makes a URL for a media file.\n     * @param string $file\n     * @return string\n     */\n    public static function url($file)\n    {\n        return static::instance()->getPathUrl($file);\n    }\n\n    /**\n     * Returns a public file URL.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @return string\n     */\n    public function getPathUrl($path)\n    {\n        $path = $this->validatePath($path, true);\n\n        $fullPath = $this->storagePath . implode(\"/\", array_map(\"rawurlencode\", explode(\"/\", $path)));\n\n        if (Config::get('cms.linkPolicy') === 'force') {\n            return Url::to($fullPath);\n        } else {\n            return $fullPath;\n        }\n    }\n\n    /**\n     * Returns a file or folder path with the prefixed storage folder.\n     * @param string $path Specifies a path to process.\n     * @return string Returns a processed string.\n     */\n    public function getMediaPath($path)\n    {\n        return $this->storageFolder.$path;\n    }\n\n    /**\n     * Returns path relative to the Library root folder.\n     * @param string $path Specifies a path relative to the Library disk root.\n     * @return string Returns the updated path.\n     */\n    protected function getMediaRelativePath($path)\n    {\n        $path = self::validatePath($path, true);\n\n        if (substr($path, 0, $this->storageFolderNameLength) == $this->storageFolder) {\n            return substr($path, $this->storageFolderNameLength);\n        }\n\n        throw new SystemException(sprintf('Cannot convert Media Library path \"%s\" to a path relative to the Library root.', $path));\n    }\n\n    /**\n     * Determines if the path should be visible (not ignored).\n     * @param string $path Specifies a path to check.\n     * @return boolean Returns TRUE if the path is visible.\n     */\n    protected function isVisible($path)\n    {\n        $baseName = basename($path);\n\n        if (in_array($baseName, $this->ignoreNames)) {\n            return false;\n        }\n\n        foreach ($this->ignorePatterns as $pattern) {\n            if (preg_match('/'.$pattern.'/', $baseName)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Initializes a library item from file metadata and item type.\n     * @param array $item Specifies the file metadata as returned by the storage adapter.\n     * @param string $itemType Specifies the item type.\n     * @return mixed Returns the MediaLibraryItem object or NULL if the item is not visible.\n     */\n    protected function initLibraryItem($item, $itemType)\n    {\n        $relativePath = $this->getMediaRelativePath($item['path']);\n\n        if (!$this->isVisible($relativePath)) {\n            return;\n        }\n\n        /*\n         * S3 doesn't allow getting the last modified timestamp for folders,\n         * so this feature is disabled - folders timestamp is always NULL.\n         */\n        if ($itemType === MediaLibraryItem::TYPE_FILE) {\n            $lastModified = $item['timestamp'] ?? $this->getStorageDisk()->lastModified($item['path']);\n        } else {\n            $lastModified = null;\n        }\n\n        /*\n         * The folder size (number of items) doesn't respect filters. That\n         * could be confusing for users, but that's safer than displaying\n         * zero items for a folder that contains files not visible with a\n         * currently applied filter. -ab\n         */\n        if ($itemType === MediaLibraryItem::TYPE_FILE) {\n            $size = $item['size'] ?? $this->getStorageDisk()->size($item['path']);\n        } else {\n            $size = $this->getFolderItemCount($item['path']);\n        }\n\n        $publicUrl = $this->getPathUrl($relativePath);\n\n        return new MediaLibraryItem($relativePath, $size, $lastModified, $itemType, $publicUrl);\n    }\n\n    /**\n     * Returns a number of items on a folder.\n     * @param string $path Specifies the folder path relative to the storage disk root.\n     * @return integer Returns the number of items in the folder.\n     */\n    protected function getFolderItemCount($path)\n    {\n        $folderItems = array_merge(\n            $this->getStorageDisk()->files($path),\n            $this->getStorageDisk()->directories($path)\n        );\n\n        $size = 0;\n        foreach ($folderItems as $folderItem) {\n            if ($this->isVisible($folderItem)) {\n                $size++;\n            }\n        }\n\n        return $size;\n    }\n\n    /**\n     * Fetches the contents of a folder from the Library.\n     * @param string $fullFolderPath Specifies the folder path relative the the storage disk root.\n     * @return array Returns an array containing two elements - 'files' and 'folders', each is an array of MediaLibraryItem objects.\n     */\n    protected function scanFolderContents($fullFolderPath)\n    {\n        $result = [\n            'files' => [],\n            'folders' => []\n        ];\n\n        $contents = $this->getStorageDisk()->listContents($fullFolderPath);\n\n        foreach ($contents as $content) {\n            if ($content['type'] === 'file') {\n                $type = MediaLibraryItem::TYPE_FILE;\n                $key = 'files';\n            } elseif ($content['type'] === 'dir') {\n                $type = MediaLibraryItem::TYPE_FOLDER;\n                $key = 'folders';\n            }\n\n            $libraryItem = $this->initLibraryItem($content, $type);\n            if (!is_null($libraryItem)) {\n                $result[$key][] = $libraryItem;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Sorts the item list by title, size or last modified date.\n     * @param array $itemList Specifies the item list to sort.\n     * @param mixed $sortSettings Determines the sorting preference.\n     * Supported values are 'title', 'size', 'lastModified' (see SORT_BY_XXX class constants) or an associative array with a 'by' key and a 'direction' key: ['by' => SORT_BY_XXX, 'direction' => SORT_DIRECTION_XXX].\n     */\n    protected function sortItemList(&$itemList, $sortSettings)\n    {\n        $files = [];\n        $folders = [];\n\n        // Convert string $sortBy to array\n        if (is_string($sortSettings)) {\n            $sortSettings = [\n                'by' => $sortSettings,\n                'direction' => self::SORT_DIRECTION_ASC,\n            ];\n        }\n\n        usort($itemList, function ($a, $b) use ($sortSettings) {\n            $result = 0;\n\n            switch ($sortSettings['by']) {\n                case self::SORT_BY_TITLE:\n                    $result = strcasecmp($a->path, $b->path);\n                    break;\n                case self::SORT_BY_SIZE:\n                    if ($a->size < $b->size) {\n                        $result = -1;\n                    } else {\n                        $result = $a->size > $b->size ? 1 : 0;\n                    }\n                    break;\n                case self::SORT_BY_MODIFIED:\n                    if ($a->lastModified < $b->lastModified) {\n                        $result = -1;\n                    } else {\n                        $result = $a->lastModified > $b->lastModified ? 1 : 0;\n                    }\n                    break;\n            }\n\n            // Reverse the polarity of the result to direct sorting in a descending order instead\n            if ($sortSettings['direction'] === self::SORT_DIRECTION_DESC) {\n                $result = 0 - $result;\n            }\n\n            return $result;\n        });\n    }\n\n    /**\n     * Filters item list by file type.\n     * @param array $itemList Specifies the item list to sort.\n     * @param string $filter Determines the document type filtering preference.\n     * Supported values are 'image', 'video', 'audio', 'document' (see FILE_TYPE_XXX constants of MediaLibraryItem class).\n     */\n    protected function filterItemList(&$itemList, $filter)\n    {\n        if (!$filter) {\n            return;\n        }\n\n        $result = [];\n        foreach ($itemList as $item) {\n            if ($item->getFileType() == $filter) {\n                $result[] = $item;\n            }\n        }\n\n        $itemList = $result;\n    }\n\n    /**\n     * Initializes and returns the Media Library disk.\n     * This method should always be used instead of trying to access the\n     * $storageDisk property directly as initializing the disc requires\n     * communicating with the remote storage.\n     * @return mixed Returns the storage disk object.\n     */\n    public function getStorageDisk(): FilesystemAdapter\n    {\n        if ($this->storageDisk) {\n            return $this->storageDisk;\n        }\n\n        return $this->storageDisk = Storage::disk(\n            Config::get('cms.storage.media.disk', 'local')\n        );\n    }\n\n    /**\n     * Determines if file path contains all words form the search term.\n     * @param string $path Specifies a path to examine.\n     * @param array $words A list of words to check against.\n     * @return boolean\n     */\n    protected function pathMatchesSearch($path, $words)\n    {\n        $path = Str::lower($path);\n\n        foreach ($words as $word) {\n            $word = trim($word);\n            if (!strlen($word)) {\n                continue;\n            }\n\n            if (!Str::contains($path, $word)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    protected function generateRandomTmpFolderName($location)\n    {\n        $temporaryDirBaseName = time();\n\n        $tmpPath = $location.'/tmp-'.$temporaryDirBaseName;\n\n        while ($this->folderExists($tmpPath)) {\n            $temporaryDirBaseName++;\n            $tmpPath = $location.'/tmp-'.$temporaryDirBaseName;\n        }\n\n        return $tmpPath;\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace System\\Classes;\n\nuse ApplicationException;\nuse Cache;\nuse Config;\nuse Illuminate\\Filesystem\\FilesystemAdapter;\nuse Lang;\nuse Storage;\nuse SystemException;\nuse Url;\nuse Winter\\Storm\\Filesystem\\Definitions as FileDefinitions;\nuse Winter\\Storm\\Support\\Str;\nuse Winter\\Storm\\Support\\Svg;\n\n/**\n * Provides abstraction level for the Media Library operations.\n * Implements the library caching features and security checks.\n *\n * @package winter\\wn-system-module\n * @author Alexey Bobkov, Samuel Georges\n */\nclass MediaLibrary\n{\n    use \\Winter\\Storm\\Support\\Traits\\Singleton;\n\n    const SORT_BY_TITLE = 'title';\n    const SORT_BY_SIZE = 'size';\n    const SORT_BY_MODIFIED = 'modified';\n    const SORT_DIRECTION_ASC = 'asc';\n    const SORT_DIRECTION_DESC = 'desc';\n\n    /**\n     * @var string Cache key\n     */\n    protected $cacheKey = 'system-media-library-contents';\n\n    /**\n     * @var string Relative or absolute URL of the Library root folder.\n     */\n    protected $storagePath;\n\n    /**\n     * @var string The root Library folder path.\n     */\n    protected $storageFolder;\n\n    /**\n     * @var mixed A reference to the Media Library disk.\n     */\n    protected $storageDisk;\n\n    /**\n     * @var array Contains a list of files and directories to ignore.\n     * The list can be customized with cms.storage.media.ignore configuration option.\n     */\n    protected $ignoreNames;\n\n    /**\n     * @var array Contains a list of regex patterns to ignore in files and directories.\n     * The list can be customized with cms.storage.media.ignorePatterns configuration option.\n     */\n    protected $ignorePatterns;\n\n    /**\n     * @var int Cache for the storage folder name length.\n     */\n    protected $storageFolderNameLength;\n\n    /**\n     * Initialize this singleton.\n     */\n    protected function init()\n    {\n        $this->storageFolder = self::validatePath(Config::get('cms.storage.media.folder', 'media'), true);\n        $this->storagePath = rtrim(Config::get('cms.storage.media.path', '/storage/app/media'), '/');\n\n        $this->ignoreNames = Config::get('cms.storage.media.ignore', FileDefinitions::get('ignoreFiles'));\n\n        $this->ignorePatterns = Config::get('cms.storage.media.ignorePatterns', ['^\\..*']);\n\n        $this->storageFolderNameLength = strlen($this->storageFolder);\n    }\n\n    /**\n     * Set the cache key\n     *\n     * @param string $cacheKey The key to set as the cache key for this instance\n     */\n    public function setCacheKey($cacheKey)\n    {\n        $this->cacheKey = $cacheKey;\n    }\n\n    /**\n     * Get the cache key\n     *\n     * @return string The cache key to set as the cache key for this instance\n     */\n    public function getCacheKey()\n    {\n        return $this->cacheKey;\n    }\n\n    /**\n     * Returns a list of folders and files in a Library folder.\n     *\n     * @param string $folder Specifies the folder path relative the the Library root.\n     * @param mixed $sortBy Determines the sorting preference.\n     * Supported values are 'title', 'size', 'lastModified' (see SORT_BY_XXX class constants), FALSE (to disable sorting), or an associative array with a 'by' key and a 'direction' key: ['by' => SORT_BY_XXX, 'direction' => SORT_DIRECTION_XXX].\n     * @param string $filter Determines the document type filtering preference.\n     * Supported values are 'image', 'video', 'audio', 'document' (see FILE_TYPE_XXX constants of MediaLibraryItem class).\n     * @param boolean $ignoreFolders Determines whether folders should be suppressed in the result list.\n     * @return array Returns an array of MediaLibraryItem objects.\n     */\n    public function listFolderContents($folder = '/', $sortBy = 'title', $filter = null, $ignoreFolders = false)\n    {\n        $folder = self::validatePath($folder);\n        $fullFolderPath = $this->getMediaPath($folder);\n\n        /*\n         * Try to load the contents from cache\n         */\n\n        $cached = Cache::get($this->cacheKey, false);\n        $cached = $cached ? @unserialize(@base64_decode($cached)) : [];\n\n        if (!is_array($cached)) {\n            $cached = [];\n        }\n\n        if (array_key_exists($fullFolderPath, $cached)) {\n            $folderContents = $cached[$fullFolderPath];\n        }\n        else {\n            $folderContents = $this->scanFolderContents($fullFolderPath);\n\n            $cached[$fullFolderPath] = $folderContents;\n            $expiresAt = now()->addMinutes(Config::get('cms.storage.media.ttl', 10));\n            Cache::put(\n                $this->cacheKey,\n                base64_encode(serialize($cached)),\n                $expiresAt\n            );\n        }\n\n        /*\n         * Sort the result and combine the file and folder lists\n         */\n\n        if ($sortBy !== false) {\n            $this->sortItemList($folderContents['files'], $sortBy);\n            $this->sortItemList($folderContents['folders'], $sortBy);\n        }\n\n        $this->filterItemList($folderContents['files'], $filter);\n\n        if (!$ignoreFolders) {\n            $folderContents = array_merge($folderContents['folders'], $folderContents['files']);\n        }\n        else {\n            $folderContents = $folderContents['files'];\n        }\n\n        return $folderContents;\n    }\n\n    /**\n     * Finds files in the Library.\n     * @param string $searchTerm Specifies the search term.\n     * @param mixed $sortBy Determines the sorting preference.\n     * Supported values are 'title', 'size', 'lastModified' (see SORT_BY_XXX class constants), FALSE (to disable sorting), or an associative array with a 'by' key and a 'direction' key: ['by' => SORT_BY_XXX, 'direction' => SORT_DIRECTION_XXX].\n     * @param string $filter Determines the document type filtering preference.\n     * Supported values are 'image', 'video', 'audio', 'document' (see FILE_TYPE_XXX constants of MediaLibraryItem class).\n     * @return array Returns an array of MediaLibraryItem objects.\n     */\n    public function findFiles($searchTerm, $sortBy = 'title', $filter = null)\n    {\n        $words = explode(' ', Str::lower($searchTerm));\n        $result = [];\n\n        $findInFolder = function ($folder) use (&$findInFolder, $words, &$result, $sortBy, $filter) {\n            $folderContents = $this->listFolderContents($folder, $sortBy, $filter);\n\n            foreach ($folderContents as $item) {\n                if ($item->type == MediaLibraryItem::TYPE_FOLDER) {\n                    $findInFolder($item->path);\n                }\n                elseif ($this->pathMatchesSearch($item->path, $words)) {\n                    $result[] = $item;\n                }\n            }\n        };\n\n        $findInFolder('/');\n\n        /*\n         * Sort the result\n         */\n\n        if ($sortBy !== false) {\n            $this->sortItemList($result, $sortBy);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Deletes a file from the Library.\n     * @param array $paths A list of file paths relative to the Library root to delete.\n     */\n    public function deleteFiles($paths)\n    {\n        $fullPaths = [];\n        foreach ($paths as $path) {\n            $path = self::validatePath($path);\n            $fullPaths[] = $this->getMediaPath($path);\n        }\n\n        return $this->getStorageDisk()->delete($fullPaths);\n    }\n\n    /**\n     * Deletes a folder from the Library.\n     * @param string $path Specifies the folder path relative to the Library root.\n     */\n    public function deleteFolder($path)\n    {\n        $path = self::validatePath($path);\n        $fullPaths = $this->getMediaPath($path);\n\n        return $this->getStorageDisk()->deleteDirectory($fullPaths);\n    }\n\n    /**\n     * Determines if a file with the specified path exists in the library.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @return boolean Returns TRUE if the file exists.\n     */\n    public function exists($path)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n\n        return $this->getStorageDisk()->exists($fullPath);\n    }\n\n    /**\n     * Determines if a folder with the specified path exists in the library.\n     * @param string $path Specifies the folder path relative the the Library root.\n     * @return boolean Returns TRUE if the folder exists.\n     */\n    public function folderExists($path)\n    {\n        $folderName = basename($path);\n        $folderPath = dirname($path);\n\n        $path = self::validatePath($folderPath);\n        $fullPath = $this->getMediaPath($path);\n\n        $folders = $this->getStorageDisk()->directories($fullPath);\n        foreach ($folders as $folder) {\n            if (basename($folder) == $folderName) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns a list of all directories in the Library, optionally excluding some of them.\n     * @param array $exclude A list of folders to exclude from the result list.\n     * The folder paths should be specified relative to the Library root.\n     * @return array\n     */\n    public function listAllDirectories($exclude = [])\n    {\n        $fullPath = $this->getMediaPath('/');\n\n        $folders = $this->getStorageDisk()->allDirectories($fullPath);\n\n        $folders = array_unique($folders, SORT_LOCALE_STRING);\n\n        $result = [];\n\n        foreach ($folders as $folder) {\n            $folder = $this->getMediaRelativePath($folder);\n            if (!strlen($folder)) {\n                $folder = '/';\n            }\n\n            if (Str::startsWith($folder, $exclude)) {\n                continue;\n            }\n            if (!$this->isVisible($folder)) {\n                $exclude[] = $folder . '/';\n                continue;\n            }\n\n            $result[] = $folder;\n        }\n\n        if (!in_array('/', $result)) {\n            array_unshift($result, '/');\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns a file contents.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @return string Returns the file contents\n     */\n    public function get($path)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n        return $this->getStorageDisk()->get($fullPath);\n    }\n\n    /**\n     * Puts a file to the library.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @param string $contents Specifies the file contents.\n     * @return boolean\n     */\n    public function put($path, $contents)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n        return $this->getStorageDisk()->put($fullPath, $contents);\n    }\n\n    /**\n     * Moves a file to another location.\n     * @param string $oldPath Specifies the original path of the file.\n     * @param string $newPath Specifies the new path of the file.\n     * @return boolean\n     */\n    public function moveFile($oldPath, $newPath, $isRename = false)\n    {\n        $oldPath = self::validatePath($oldPath);\n        $fullOldPath = $this->getMediaPath($oldPath);\n\n        $newPath = self::validatePath($newPath);\n        $fullNewPath = $this->getMediaPath($newPath);\n\n        // If the file extension is changed to SVG, ensure that it has been sanitized\n        $oldExt = pathinfo($oldPath, PATHINFO_EXTENSION);\n        $newExt = pathinfo($newPath, PATHINFO_EXTENSION);\n        if ($oldExt !== $newExt && strtolower($newExt) === 'svg') {\n            $contents = $this->getStorageDisk()->get($fullOldPath);\n            $contents = Svg::sanitize($contents);\n            $this->getStorageDisk()->put($fullOldPath, $contents);\n        }\n\n        return $this->getStorageDisk()->move($fullOldPath, $fullNewPath);\n    }\n\n    /**\n     * Copies a folder.\n     * @param string $originalPath Specifies the original path of the folder.\n     * @param string $newPath Specifies the new path of the folder.\n     * @return boolean\n     */\n    public function copyFolder($originalPath, $newPath)\n    {\n        $disk = $this->getStorageDisk();\n\n        $copyDirectory = function ($srcPath, $destPath) use (&$copyDirectory, $disk) {\n            $srcPath = self::validatePath($srcPath);\n            $fullSrcPath = $this->getMediaPath($srcPath);\n\n            $destPath = self::validatePath($destPath);\n            $fullDestPath = $this->getMediaPath($destPath);\n\n            if (!$disk->makeDirectory($fullDestPath)) {\n                return false;\n            }\n\n            $folderContents = $this->scanFolderContents($fullSrcPath);\n\n            foreach ($folderContents['folders'] as $dirInfo) {\n                if (!$copyDirectory($dirInfo->path, $destPath.'/'.basename($dirInfo->path))) {\n                    return false;\n                }\n            }\n\n            foreach ($folderContents['files'] as $fileInfo) {\n                $fullFileSrcPath = $this->getMediaPath($fileInfo->path);\n\n                if (!$disk->copy($fullFileSrcPath, $fullDestPath.'/'.basename($fileInfo->path))) {\n                    return false;\n                }\n            }\n\n            return true;\n        };\n\n        return $copyDirectory($originalPath, $newPath);\n    }\n\n    /**\n     * Moves a folder.\n     * @param string $originalPath Specifies the original path of the folder.\n     * @param string $newPath Specifies the new path of the folder.\n     * @return boolean\n     */\n    public function moveFolder($originalPath, $newPath)\n    {\n        if (Str::lower($originalPath) !== Str::lower($newPath)) {\n            // If there is no risk that the directory was renamed\n            // by just changing the letter case in the name -\n            // copy the directory to the destination path and delete\n            // the source directory.\n\n            if (!$this->copyFolder($originalPath, $newPath)) {\n                return false;\n            }\n\n            $this->deleteFolder($originalPath);\n        }\n        else {\n            // If there's a risk that the directory name was updated\n            // by changing the letter case - swap source and destination\n            // using a temporary directory with random name.\n\n            $tempraryDirPath = $this->generateRandomTmpFolderName(dirname($originalPath));\n\n            if (!$this->copyFolder($originalPath, $tempraryDirPath)) {\n                $this->deleteFolder($tempraryDirPath);\n\n                return false;\n            }\n\n            $this->deleteFolder($originalPath);\n\n            return $this->moveFolder($tempraryDirPath, $newPath);\n        }\n\n        return true;\n    }\n\n    /**\n     * Creates a folder.\n     * @param string $path Specifies the folder path.\n     * @return boolean\n     */\n    public function makeFolder($path)\n    {\n        $path = self::validatePath($path);\n        $fullPath = $this->getMediaPath($path);\n\n        return $this->getStorageDisk()->makeDirectory($fullPath);\n    }\n\n    /**\n     * Resets the Library cache.\n     *\n     * The cache stores the library table of contents locally in order to optimize\n     * the performance when working with remote storages. The default cache TTL is\n     * 10 minutes. The cache is deleted automatically when an item is added, changed\n     * or deleted. This method allows to reset the cache forcibly.\n     */\n    public function resetCache()\n    {\n        Cache::forget($this->cacheKey);\n    }\n\n    /**\n     * Checks if file path doesn't contain any substrings that would pose a security threat.\n     * Throws an exception if the path is not valid.\n     * @param string $path Specifies the path.\n     * @param boolean $normalizeOnly Specifies if only the normalization, without validation should be performed.\n     * @return string Returns a normalized path.\n     */\n    public static function validatePath($path, $normalizeOnly = false)\n    {\n        $path = str_replace('\\\\', '/', $path);\n        $path = '/'.trim($path, '/');\n\n        if ($normalizeOnly) {\n            return $path;\n        }\n\n        /*\n         * Validate folder names\n         */\n        $regexWhitelist = [\n            '\\w', // any word character\n            preg_quote('@', '/'),\n            preg_quote('.', '/'),\n            '\\s', // whitespace character\n            preg_quote('-', '/'),\n            preg_quote('_', '/'),\n            preg_quote('/', '/'),\n            preg_quote('(', '/'),\n            preg_quote(')', '/'),\n            preg_quote('[', '/'),\n            preg_quote(']', '/'),\n            preg_quote(',', '/'),\n            preg_quote('=', '/'),\n            preg_quote(\"'\", '/'),\n            preg_quote('&', '/'),\n        ];\n\n        if (!preg_match('/^[' . implode('', $regexWhitelist) . ']+$/iu', $path)) {\n            throw new ApplicationException(Lang::get('system::lang.media.invalid_path', compact('path')));\n        }\n\n        $regexDirectorySeparator = preg_quote('/', '#');\n        $regexDot = preg_quote('.', '#');\n        $regex = [\n            // Beginning of path\n            '(^'.$regexDot.'+?'.$regexDirectorySeparator.')',\n\n            // Middle of path\n            '('.$regexDirectorySeparator.$regexDot.'+?'.$regexDirectorySeparator.')',\n\n            // End of path\n            '('.$regexDirectorySeparator.$regexDot.'+?$)',\n        ];\n\n        /*\n         * Validate invalid paths\n         */\n        $regex = '#'.implode('|', $regex).'#';\n        if (preg_match($regex, $path) !== 0 || strpos($path, '://') !== false) {\n            throw new ApplicationException(Lang::get('system::lang.media.invalid_path', compact('path')));\n        }\n\n        return $path;\n    }\n\n    /**\n     * Helper that makes a URL for a media file.\n     * @param string $file\n     * @return string\n     */\n    public static function url($file)\n    {\n        return static::instance()->getPathUrl($file);\n    }\n\n    /**\n     * Returns a public file URL.\n     * @param string $path Specifies the file path relative the the Library root.\n     * @return string\n     */\n    public function getPathUrl($path)\n    {\n        $path = $this->validatePath($path, true);\n\n        $fullPath = $this->storagePath . implode(\"/\", array_map(\"rawurlencode\", explode(\"/\", $path)));\n\n        if (Config::get('cms.linkPolicy') === 'force') {\n            return Url::to($fullPath);\n        } else {\n            return $fullPath;\n        }\n    }\n\n    /**\n     * Returns a file or folder path with the prefixed storage folder.\n     * @param string $path Specifies a path to process.\n     * @return string Returns a processed string.\n     */\n    public function getMediaPath($path)\n    {\n        return $this->storageFolder.$path;\n    }\n\n    /**\n     * Returns path relative to the Library root folder.\n     * @param string $path Specifies a path relative to the Library disk root.\n     * @return string Returns the updated path.\n     */\n    protected function getMediaRelativePath($path)\n    {\n        $path = self::validatePath($path, true);\n\n        if (substr($path, 0, $this->storageFolderNameLength) == $this->storageFolder) {\n            return substr($path, $this->storageFolderNameLength);\n        }\n\n        throw new SystemException(sprintf('Cannot convert Media Library path \"%s\" to a path relative to the Library root.', $path));\n    }\n\n    /**\n     * Determines if the path should be visible (not ignored).\n     * @param string $path Specifies a path to check.\n     * @return boolean Returns TRUE if the path is visible.\n     */\n    protected function isVisible($path)\n    {\n        $baseName = basename($path);\n\n        if (in_array($baseName, $this->ignoreNames)) {\n            return false;\n        }\n\n        foreach ($this->ignorePatterns as $pattern) {\n            if (preg_match('/'.$pattern.'/', $baseName)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Initializes a library item from file metadata and item type.\n     * @param array $item Specifies the file metadata as returned by the storage adapter.\n     * @param string $itemType Specifies the item type.\n     * @return mixed Returns the MediaLibraryItem object or NULL if the item is not visible.\n     */\n    protected function initLibraryItem($item, $itemType)\n    {\n        $relativePath = $this->getMediaRelativePath($item['path']);\n\n        if (!$this->isVisible($relativePath)) {\n            return;\n        }\n\n        /*\n         * S3 doesn't allow getting the last modified timestamp for folders,\n         * so this feature is disabled - folders timestamp is always NULL.\n         */\n        if ($itemType === MediaLibraryItem::TYPE_FILE) {\n            $lastModified = $item['timestamp'] ?? $this->getStorageDisk()->lastModified($item['path']);\n        } else {\n            $lastModified = null;\n        }\n\n        /*\n         * The folder size (number of items) doesn't respect filters. That\n         * could be confusing for users, but that's safer than displaying\n         * zero items for a folder that contains files not visible with a\n         * currently applied filter. -ab\n         */\n        if ($itemType === MediaLibraryItem::TYPE_FILE) {\n            $size = $item['size'] ?? $this->getStorageDisk()->size($item['path']);\n        } else {\n            $size = $this->getFolderItemCount($item['path']);\n        }\n\n        $publicUrl = $this->getPathUrl($relativePath);\n\n        return new MediaLibraryItem($relativePath, $size, $lastModified, $itemType, $publicUrl);\n    }\n\n    /**\n     * Returns a number of items on a folder.\n     * @param string $path Specifies the folder path relative to the storage disk root.\n     * @return integer Returns the number of items in the folder.\n     */\n    protected function getFolderItemCount($path)\n    {\n        $folderItems = array_merge(\n            $this->getStorageDisk()->files($path),\n            $this->getStorageDisk()->directories($path)\n        );\n\n        $size = 0;\n        foreach ($folderItems as $folderItem) {\n            if ($this->isVisible($folderItem)) {\n                $size++;\n            }\n        }\n\n        return $size;\n    }\n\n    /**\n     * Fetches the contents of a folder from the Library.\n     * @param string $fullFolderPath Specifies the folder path relative the the storage disk root.\n     * @return array Returns an array containing two elements - 'files' and 'folders', each is an array of MediaLibraryItem objects.\n     */\n    protected function scanFolderContents($fullFolderPath)\n    {\n        $result = [\n            'files' => [],\n            'folders' => []\n        ];\n\n        $contents = $this->getStorageDisk()->listContents($fullFolderPath);\n\n        foreach ($contents as $content) {\n            if ($content['type'] === 'file') {\n                $type = MediaLibraryItem::TYPE_FILE;\n                $key = 'files';\n            } elseif ($content['type'] === 'dir') {\n                $type = MediaLibraryItem::TYPE_FOLDER;\n                $key = 'folders';\n            }\n\n            $libraryItem = $this->initLibraryItem($content, $type);\n            if (!is_null($libraryItem)) {\n                $result[$key][] = $libraryItem;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Sorts the item list by title, size or last modified date.\n     * @param array $itemList Specifies the item list to sort.\n     * @param mixed $sortSettings Determines the sorting preference.\n     * Supported values are 'title', 'size', 'lastModified' (see SORT_BY_XXX class constants) or an associative array with a 'by' key and a 'direction' key: ['by' => SORT_BY_XXX, 'direction' => SORT_DIRECTION_XXX].\n     */\n    protected function sortItemList(&$itemList, $sortSettings)\n    {\n        $files = [];\n        $folders = [];\n\n        // Convert string $sortBy to array\n        if (is_string($sortSettings)) {\n            $sortSettings = [\n                'by' => $sortSettings,\n                'direction' => self::SORT_DIRECTION_ASC,\n            ];\n        }\n\n        usort($itemList, function ($a, $b) use ($sortSettings) {\n            $result = 0;\n\n            switch ($sortSettings['by']) {\n                case self::SORT_BY_TITLE:\n                    $result = strcasecmp($a->path, $b->path);\n                    break;\n                case self::SORT_BY_SIZE:\n                    if ($a->size < $b->size) {\n                        $result = -1;\n                    } else {\n                        $result = $a->size > $b->size ? 1 : 0;\n                    }\n                    break;\n                case self::SORT_BY_MODIFIED:\n                    if ($a->lastModified < $b->lastModified) {\n                        $result = -1;\n                    } else {\n                        $result = $a->lastModified > $b->lastModified ? 1 : 0;\n                    }\n                    break;\n            }\n\n            // Reverse the polarity of the result to direct sorting in a descending order instead\n            if ($sortSettings['direction'] === self::SORT_DIRECTION_DESC) {\n                $result = 0 - $result;\n            }\n\n            return $result;\n        });\n    }\n\n    /**\n     * Filters item list by file type.\n     * @param array $itemList Specifies the item list to sort.\n     * @param string $filter Determines the document type filtering preference.\n     * Supported values are 'image', 'video', 'audio', 'document' (see FILE_TYPE_XXX constants of MediaLibraryItem class).\n     */\n    protected function filterItemList(&$itemList, $filter)\n    {\n        if (!$filter) {\n            return;\n        }\n\n        $result = [];\n        foreach ($itemList as $item) {\n            if ($item->getFileType() == $filter) {\n                $result[] = $item;\n            }\n        }\n\n        $itemList = $result;\n    }\n\n    /**\n     * Initializes and returns the Media Library disk.\n     * This method should always be used instead of trying to access the\n     * $storageDisk property directly as initializing the disc requires\n     * communicating with the remote storage.\n     * @return mixed Returns the storage disk object.\n     */\n    public function getStorageDisk(): FilesystemAdapter\n    {\n        if ($this->storageDisk) {\n            return $this->storageDisk;\n        }\n\n        return $this->storageDisk = Storage::disk(\n            Config::get('cms.storage.media.disk', 'local')\n        );\n    }\n\n    /**\n     * Determines if file path contains all words form the search term.\n     * @param string $path Specifies a path to examine.\n     * @param array $words A list of words to check against.\n     * @return boolean\n     */\n    protected function pathMatchesSearch($path, $words)\n    {\n        $path = Str::lower($path);\n\n        foreach ($words as $word) {\n            $word = trim($word);\n            if (!strlen($word)) {\n                continue;\n            }\n\n            if (!Str::contains($path, $word)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    protected function generateRandomTmpFolderName($location)\n    {\n        $temporaryDirBaseName = time();\n\n        $tmpPath = $location.'/tmp-'.$temporaryDirBaseName;\n\n        while ($this->folderExists($tmpPath)) {\n            $temporaryDirBaseName++;\n            $tmpPath = $location.'/tmp-'.$temporaryDirBaseName;\n        }\n\n        return $tmpPath;\n    }\n}\n"], "filenames": ["modules/system/classes/MediaLibrary.php"], "buggy_code_start_loc": [354], "buggy_code_end_loc": [355], "fixing_code_start_loc": [354], "fixing_code_end_loc": [355], "type": "CWE-79", "message": "Winter is a free, open-source content management system.  Prior to 1.2.4, users with the `media.manage_media` permission can upload files to the Media Manager and rename them after uploading. Previously, media manager files were only sanitized on upload, not on renaming, which could have allowed a stored XSS attack. This issue has been patched in v1.2.4.", "other": {"cve": {"id": "CVE-2023-52083", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-28T23:15:43.557", "lastModified": "2024-01-05T00:01:33.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Winter is a free, open-source content management system.  Prior to 1.2.4, users with the `media.manage_media` permission can upload files to the Media Manager and rename them after uploading. Previously, media manager files were only sanitized on upload, not on renaming, which could have allowed a stored XSS attack. This issue has been patched in v1.2.4."}, {"lang": "es", "value": "Winter es un sistema de gesti\u00f3n de contenidos gratuito y de c\u00f3digo abierto. Antes de 1.2.4, los usuarios con el permiso `media.manage_media` pod\u00edan cargar archivos en el Media Manager y cambiarles el nombre despu\u00e9s de cargarlos. Anteriormente, los archivos del Media Manager solo se sanitizaban al cargarlos, no al cambiarles el nombre, lo que podr\u00eda haber permitido un ataque XSS almacenado. Este problema se solucion\u00f3 en la versi\u00f3n 1.2.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.0, "baseSeverity": "LOW"}, "exploitabilityScore": 0.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wintercms:winter:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.4", "matchCriteriaId": "1EE69DF4-BDE7-4A22-9947-BBD648026BA4"}]}]}], "references": [{"url": "https://github.com/wintercms/winter/commit/2969daeea8dee64d292dbaa3778ea251e2a7e491", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wintercms/winter/security/advisories/GHSA-4wvw-75qh-fqjp", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/wintercms/winter/commit/2969daeea8dee64d292dbaa3778ea251e2a7e491"}}