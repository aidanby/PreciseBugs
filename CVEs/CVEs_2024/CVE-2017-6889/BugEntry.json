{"buggy_code": ["/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2013 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.456 $\n   $Date: 2013/06/16 18:01:08 $\n */\n\n#define getbits(n) getbithuff(n,0)\n\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t  is_foveon = 1;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  poff[0][i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n\t}\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder (unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code) {\n    for (i=0; i < size; i++)\n      huff[i] = get4();\n    memset (first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode+2048) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n#else\n    fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp (failure, 2);\n#endif\n  }\n  if (code)\n    for (i=0; i < size; i++)\n      if (huff[i] == code) {\n\tcur->leaf = i;\n\treturn;\n      }\n  if ((len = code >> 27) > 26) return;\n  code = (len+1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder (size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder (size, code+1);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#define T imgdata.thumbnail\n#define ID libraw_internal_data.internal_data\n\nvoid LibRaw::foveon_thumb_loader (void)\n{\n    unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n    struct decode *dindex;\n    short pred[3];\n    \n    if(T.thumb) free(T.thumb);\n    T.thumb = NULL;\n    \n    bwide = get4();\n    if (bwide > 0) \n        {\n            if (bwide < (unsigned)T.twidth*3) return;\n            T.thumb = (char*)malloc(3*T.twidth * T.theight);\n            merror (T.thumb, \"foveon_thumb()\");\n            char *buf = (char*)malloc(bwide); \n            merror (buf, \"foveon_thumb()\");\n            for (row=0; row < T.theight; row++) \n                {\n                    ID.input->read(buf, 1, bwide);\n                    memmove(T.thumb+(row*T.twidth*3),buf,T.twidth*3);\n                }\n            free(buf);\n            T.tlength = 3*T.twidth * T.theight;\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            return;\n        }\n    else \n        {\n            foveon_decoder (256, 0);\n            T.thumb = (char*)malloc(3*T.twidth * T.theight);\n            char *bufp = T.thumb;\n            merror (T.thumb, \"foveon_thumb()\");\n            for (row=0; row < T.theight; row++) \n                {\n                    memset (pred, 0, sizeof pred);\n                    if (!bit) get4();\n                    for (bit=col=0; col < T.twidth; col++)\n                        for(c=0;c<3;c++) \n                            {\n                                for (dindex=first_decode; dindex->branch[0]; ) \n                                    {\n                                        if ((bit = (bit-1) & 31) == 31)\n                                            for (i=0; i < 4; i++)\n                                                bitbuf = (bitbuf << 8) + ID.input->get_char();\n                                        dindex = dindex->branch[bitbuf >> bit & 1];\n                                    }\n                                pred[c] += dindex->leaf;\n                                (*bufp++)=pred[c];\n                            }\n                }\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            T.tlength = 3*T.twidth * T.theight;\n        }\n    return;\n}\n#endif\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff (ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i=0; i < 13; i++) {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j=0; j < 256 >> clen; )\n      huff[code+ ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse hpred[col & 1] += diff;\n\timage[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}\n\nconst char * CLASS foveon_camf_param (const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'P') continue;\n    if (strcmp (block, pos+sget4(pos+12))) continue;\n    cp = pos + sget4(pos+16);\n    num = sget4(cp);\n    dp = pos + sget4(cp+4);\n    while (num--) {\n      cp += 8;\n      if (!strcmp (param, dp+sget4(cp)))\n\treturn dp+sget4(cp+4);\n    }\n  }\n  return 0;\n}\n\nvoid * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'M') continue;\n    if (strcmp (name, pos+sget4(pos+12))) continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos+16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp+4)) > 3) break;\n    dp = pos + sget4(cp+8);\n    for (i=ndim; i--; ) {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;\n    mat = (unsigned *) malloc ((size = dsize) * 4);\n    merror (mat, \"foveon_camf_matrix()\");\n    for (i=0; i < size; i++)\n      if (type && type != 6)\n\tmat[i] = sget4(dp + i*4);\n      else\n\tmat[i] = sget4(dp + i*2) & 0xffff;\n    return mat;\n  }\n  fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n  return 0;\n}\n\nint CLASS foveon_fixed (void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name) return 0;\n  dp = foveon_camf_matrix (dim, name);\n  if (!dp) return 0;\n  memcpy (ptr, dp, size*4);\n  free (dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg (short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;\n\n  for (i=range[0]; i <= range[1]; i++) {\n    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\n    if (min > val) min = val;\n    if (max < val) max = val;\n  }\n  if (range[1] - range[0] == 1) return sum/2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort * CLASS foveon_make_curve (double max, double mul, double filt)\n{\n  short *t_curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt) filt = 0.8;\n  size = 4*M_PI*max / filt;\n  if (size == UINT_MAX) size--;\n  t_curve = (short *) calloc (size+1, sizeof *t_curve);\n  merror (t_curve, \"foveon_make_curve()\");\n  t_curve[0] = size;\n  for (i=0; i < size; i++) {\n    x = i*filt/max/4;\n    t_curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;\n  }\n  return t_curve;\n}\n\nvoid CLASS foveon_make_curves\n\t(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max=0;\n  int c;\n\n  FORC3 mul[c] = dq[c]/div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve (short *t_curve, int i)\n{\n  if (abs(i) >= t_curve[0]) return 0;\n  return i < 0 ? -t_curve[1-i] : t_curve[1+i];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef image\n#undef image\n#endif\n#define image ((short(*)[4]) imgdata.image)\n#else\n#define image ((short (*)[4]) image)\n#endif\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\n  short *pix, prev[3], *t_curve[8], (*t_shrink)[3];\n  float cfilt=0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float (*t_black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p=0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum=0, trsum[3];\n  char str[128];\n  const char* cp;\n\n  if (verbose)\n    fprintf (stderr,_(\"Foveon interpolation...\\n\"));\n\n  foveon_load_camf();\n  foveon_fixed (dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed (satlev, 3, \"SaturationLevel\");\n  foveon_fixed (keep, 4, \"KeepImageArea\");\n  foveon_fixed (active, 4, \"ActiveImageArea\");\n  foveon_fixed (chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed (color_dq, 3,\n\tfoveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))\n  \t\t foveon_fixed (&cfilt, 1, \"ColumnFilter\");\n\n  memset (ddft, 0, sizeof ddft);\n  if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")\n\t || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))\n    for (i=0; i < 2; i++) {\n      foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n\tfor (col = dstb[0]; col <= dstb[2]; col++)\n\t  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];\n      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\n    }\n\n  if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))\n  { fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n    return; }\n  foveon_fixed (cam_xyz, 9, cp);\n  foveon_fixed (correct, 9,\n\tfoveon_camf_param (\"WhiteBalanceCorrections\", model2));\n  memset (last, 0, sizeof last);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n  #define LAST(x,y) last[(i+x)%3][(c+y)%3]\n  for (i=0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\n  #undef LAST\n  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;\n  sprintf (str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param (\"IncludeBlocks\", str))\n    foveon_fixed (div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\n  for (i=0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves (t_curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves (t_curve+3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  t_curve[6] = foveon_make_curve (dsum, dsum, cfilt);\n  t_curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);\n\n  sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");\n  if (!sgain) return;\n  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\n  sgx = (width + dim[1]-2) / (dim[1]-1);\n\n  t_black = (float (*)[3]) calloc (height, sizeof *t_black);\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    FORC3 t_black[row][c] =\n \t( foveon_avg (image[row*width]+c, dscr[0], cfilt) +\n\t  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3\n\t  - ddft[0][c][0] ) / 4 - ddft[0][c][1];\n  }\n  memcpy (t_black, t_black+8, sizeof *t_black*8);\n  memcpy (t_black+height-11, t_black+height-22, 11*sizeof *t_black);\n  memcpy (last, t_black, sizeof last);\n\n  for (row=1; row < height-1; row++) {\n    FORC3 if (last[1][c] > last[0][c]) {\n\tif (last[1][c] > last[2][c])\n\t  t_black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\n      } else\n\tif (last[1][c] < last[2][c])\n\t  t_black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\n    memmove (last, last+1, 2*sizeof last[0]);\n    memcpy (last[2], t_black[row+1], sizeof last[2]);\n  }\n  FORC3 t_black[row][c] = (last[0][c] + last[1][c])/2;\n  FORC3 t_black[0][c] = (t_black[1][c] + t_black[3][c])/2;\n\n  val = 1 - exp(-1/24.0);\n  memcpy (fsum, t_black, sizeof fsum);\n  for (row=1; row < height; row++)\n    FORC3 fsum[c] += t_black[row][c] =\n\t(t_black[row][c] - t_black[row-1][c])*val + t_black[row-1][c];\n  memcpy (last[0], t_black[height-1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--; )\n    FORC3 last[0][c] = t_black[row][c] =\n\t(t_black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\n\n  memset (total, 0, sizeof total);\n  for (row=2; row < height; row+=4)\n    for (col=2; col < width; col+=4) {\n      FORC3 total[c] += (short) image[row*width+col][c];\n      total[3]++;\n    }\n  for (row=0; row < height; row++)\n    FORC3 t_black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);\n\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    pix = image[row*width];\n    memcpy (prev, pix, sizeof prev);\n    frow = row / (height-1.0) * (dim[2]-1);\n    if ((irow = frow) == dim[2]-1) irow--;\n    frow -= irow;\n    for (i=0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\n\t\t\t  sgain[(irow+1)*dim[1]+i][c] *    frow;\n    for (col=0; col < width; col++) {\n      FORC3 {\n\tdiff = pix[c] - prev[c];\n\tprev[c] = pix[c];\n\tipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\n\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)\n\t\t- t_black[row][c] );\n      }\n      FORC3 {\n\twork[0][c] = ipix[c] * ipix[c] >> 14;\n\twork[2][c] = ipix[c] * work[0][c] >> 14;\n\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\n      }\n      FORC3 {\n\tfor (val=i=0; i < 3; i++)\n\t  for (  j=0; j < 3; j++)\n\t    val += ppm[c][i][j] * work[i][j];\n\tipix[c] = floor ((ipix[c] + floor(val)) *\n\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\n\t\t  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);\n\tif (ipix[c] > 32000) ipix[c] = 32000;\n\tpix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free (t_black);\n  free (sgrow);\n  free (sgain);\n\n  if ((badpix = (unsigned int *) foveon_camf_matrix (dim, \"BadPixels\"))) {\n    for (i=0; i < dim[0]; i++) {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20       ) - keep[1];\n      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)\n\tcontinue;\n      memset (fsum, 0, sizeof fsum);\n      for (sum=j=0; j < 8; j++)\n\tif (badpix[i] & (1 << j)) {\n\t  FORC3 fsum[c] += (short)\n\t\timage[(row+hood[j*2])*width+col+hood[j*2+1]][c];\n\t  sum++;\n\t}\n      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;\n    }\n    free (badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);\n  merror (smrow[6], \"foveon_interpolate()\");\n  for (i=0; i < 5; i++)\n    smrow[i] = smrow[6] + i*width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tsmrow[4][col][0] =\n\t  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      smred = ( 6 *  smrow[2][col][0]\n\t      + 4 * (smrow[1][col][0] + smrow[3][col][0])\n\t      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\n      if (col == 2)\n\tsmred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\n      if (i > 32000) i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3 {\n    i = satlev[c] / div[c];\n    if (min > i) min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c=1; c < 3; c++) {\n      if (min > pix[c]) min = pix[c];\n      if (max < pix[c]) max = pix[c];\n    }\n    if (min >= limit*2) {\n      pix[0] = pix[1] = pix[2] = max;\n    } else {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i*i >> 14);\n      i = i*i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n/*\n   Because photons that miss one detector often hit another,\n   the sum R+G+B is much less noisy than the individual colors.\n   So smooth the hues without smoothing the total.\n */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      FORC3 dev[c] = -foveon_apply_curve (t_curve[7], pix[c] -\n\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] =\n\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      for (total[3]=375, sum=60, c=0; c < 3; c++) {\n\tfor (total[c]=i=0; i < 5; i++)\n\t  total[c] += smrow[i][col][c];\n\ttotal[3] += total[c];\n\tsum += pix[c];\n      }\n      if (sum < 0) sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve (t_curve[6],\n\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    FORC3 pix[c] -= foveon_apply_curve (t_curve[c], pix[c]);\n    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve (t_curve[c], pix[c]-sum);\n    FORC3 {\n      for (dsum=i=0; i < 3; i++)\n\tdsum += trans[c][i] * pix[i];\n      if (dsum < 0)  dsum = 0;\n      if (dsum > 24000) dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  t_shrink = (short (*)[3]) calloc ((width/4) * (height/4), sizeof *t_shrink);\n  merror (t_shrink, \"foveon_interpolate()\");\n  for (row = height/4; row--; )\n    for (col=0; col < width/4; col++) {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i=0; i < 4; i++)\n\tfor (j=0; j < 4; j++)\n\t  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];\n      FORC3\n\tif (row+2 > height/4)\n\t  t_shrink[row*(width/4)+col][c] = ipix[c] >> 4;\n\telse\n\t  t_shrink[row*(width/4)+col][c] =\n\t    (t_shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row=0; row < (height & ~3); row++) {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3 ; col--; )\n\tFORC3 smrow[0][col][c] = ipix[c] =\n\t  (t_shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col=0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] =\n\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy (smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col=0; col < (width & ~3); col++)\n\tFORC3 smrow[2][col][c] =\n\t  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\n\n  /* Adjust the chroma toward the smooth values */\n    for (col=0; col < (width & ~3); col++) {\n      for (i=j=30, c=0; c < 3; c++) {\n\ti += smrow[2][col][c];\n\tj += image[row*width+col][c];\n      }\n      j = (j << 16) / i;\n      for (sum=c=0; c < 3; c++) {\n\tipix[c] = foveon_apply_curve (t_curve[c+3],\n\t  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);\n\tsum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3 {\n\ti = image[row*width+col][c] + ipix[c] - sum;\n\tif (i < 0) i = 0;\n\timage[row*width+col][c] = i;\n      }\n    }\n  }\n  free (t_shrink);\n  free (smrow[6]);\n  for (i=0; i < 8; i++)\n    free (t_curve[i]);\n\n  /* Trim off the black border */\n  if (~cropbox[2] && ~cropbox[3])\n    {\n      // Image already cropped, do nothing\n      int crop[4],c;\n      for(int c=0;c<4;c++) \n        {\n          crop[c] = cropbox[c];\n          if(crop[c]<0)\n            crop[c]=0;\n        }\n      if(crop[0]>=width-1) crop[0] = width - 2;\n      if(crop[1]>=height-1) crop[1] = height-2;\n      if(crop[0]+crop[2] >= width) crop[2] = width-crop[0];\n      if(crop[1]+crop[3] >= height) crop[3] = height-crop[1];\n      active[0] = crop[0];\n      active[1] = crop[1];\n      active[2] = crop[0]+crop[2];\n      active[3] = crop[1]+crop[3];\n    }\n  else\n    {\n      active[1] -= keep[1];\n      active[3] -= 2;\n    }\n  i = active[2] - active[0];\n  for (row=0; row < active[3]-active[1]; row++)\n    memcpy (image[row*i], image[(row+active[1])*width+active[0]],\n            i * sizeof *image);\n  width = i;\n  height = row;\n\n}\n#undef image\n#ifdef LIBRAW_LIBRARY_BUILD\n#define image           (imgdata.image)\n#endif\n\n/* RESTRICTED code ends here */\n\n"], "fixing_code": ["/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2013 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.456 $\n   $Date: 2013/06/16 18:01:08 $\n */\n\n#define getbits(n) getbithuff(n,0)\n\nchar * CLASS foveon_gets (int offset, char *str, int len)\n{\n  int i;\n  fseek (ifp, offset, SEEK_SET);\n  for (i=0; i < len-1; i++)\n    if ((str[i] = get2()) == 0) break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img=0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n\n  order = 0x4949;\t\t\t/* Little-endian */\n  fseek (ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek (ifp, -4, SEEK_END);\n  fseek (ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553) return;\t/* SECd */\n  entries = (get4(),get4());\n  while (entries--) {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek (ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24))) return;\n    switch (tag) {\n      case 0x47414d49:\t\t\t/* IMAG */\n      case 0x32414d49:\t\t\t/* IMA2 */\n\tfseek (ifp, 8, SEEK_CUR);\n\tpent = get4();\n\twide = get4();\n\thigh = get4();\n\tif (wide > raw_width && high > raw_height) {\n\t  switch (pent) {\n\t    case  5:  load_flags = 1;\n\t    case  6:  load_raw = &CLASS foveon_sd_load_raw;  break;\n\t    case 30:  load_raw = &CLASS foveon_dp_load_raw;  break;\n\t    default:  load_raw = 0;\n\t  }\n\t  raw_width  = wide;\n\t  raw_height = high;\n\t  data_offset = off+28;\n\t  is_foveon = 1;\n\t}\n\tfseek (ifp, off+28, SEEK_SET);\n\tif (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8\n\t\t&& thumb_length < len-28) {\n\t  thumb_offset = off+28;\n\t  thumb_length = len-28;\n\t  write_thumb = &CLASS jpeg_thumb;\n\t}\n\tif (++img == 2 && !thumb_length) {\n\t  thumb_offset = off+24;\n\t  thumb_width = wide;\n\t  thumb_height = high;\n\t  write_thumb = &CLASS foveon_thumb;\n\t}\n\tbreak;\n      case 0x464d4143:\t\t\t/* CAMF */\n\tmeta_offset = off+8;\n\tmeta_length = len-28;\n\tbreak;\n      case 0x504f5250:\t\t\t/* PROP */\n\tpent = (get4(),get4());\n\tfseek (ifp, 12, SEEK_CUR);\n\toff += pent*8 + 24;\n\tif ((unsigned) pent > 256) pent=256;\n\tfor (i=0; i < pent*2; i++)\n\t  poff[0][i] = off + get4()*2;\n\tfor (i=0; i < pent; i++) {\n\t  foveon_gets (poff[i][0], name, 64);\n\t  foveon_gets (poff[i][1], value, 64);\n\t  if (!strcmp (name, \"ISO\"))\n\t    iso_speed = atoi(value);\n\t  if (!strcmp (name, \"CAMMANUF\"))\n\t    strcpy (make, value);\n\t  if (!strcmp (name, \"CAMMODEL\"))\n\t    strcpy (model, value);\n\t  if (!strcmp (name, \"WB_DESC\"))\n\t    strcpy (model2, value);\n\t  if (!strcmp (name, \"TIME\"))\n\t    timestamp = atoi(value);\n\t  if (!strcmp (name, \"EXPTIME\"))\n\t    shutter = atoi(value) / 1000000.0;\n\t  if (!strcmp (name, \"APERTURE\"))\n\t    aperture = atof(value);\n\t  if (!strcmp (name, \"FLENGTH\"))\n\t    focal_len = atof(value);\n\t}\n#ifdef LOCALTIME\n\ttimestamp = mktime (gmtime (&timestamp));\n#endif\n    }\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder (unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code) {\n    for (i=0; i < size; i++)\n      huff[i] = get4();\n    memset (first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode+2048) {\n#ifdef LIBRAW_LIBRARY_BUILD\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n#else\n    fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp (failure, 2);\n#endif\n  }\n  if (code)\n    for (i=0; i < size; i++)\n      if (huff[i] == code) {\n\tcur->leaf = i;\n\treturn;\n      }\n  if ((len = code >> 27) > 26) return;\n  code = (len+1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder (size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder (size, code+1);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#define T imgdata.thumbnail\n#define ID libraw_internal_data.internal_data\n\nvoid LibRaw::foveon_thumb_loader (void)\n{\n    unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n    struct decode *dindex;\n    short pred[3];\n    \n    if(T.thumb) free(T.thumb);\n    T.thumb = NULL;\n    \n    bwide = get4();\n    if (bwide > 0) \n        {\n            if (bwide < (unsigned)T.twidth*3) return;\n            T.thumb = (char*)malloc(3*T.twidth * T.theight);\n            merror (T.thumb, \"foveon_thumb()\");\n            char *buf = (char*)malloc(bwide); \n            merror (buf, \"foveon_thumb()\");\n            for (row=0; row < T.theight; row++) \n                {\n                    ID.input->read(buf, 1, bwide);\n                    memmove(T.thumb+(row*T.twidth*3),buf,T.twidth*3);\n                }\n            free(buf);\n            T.tlength = 3*T.twidth * T.theight;\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            return;\n        }\n    else \n        {\n            foveon_decoder (256, 0);\n            T.thumb = (char*)malloc(3*T.twidth * T.theight);\n            char *bufp = T.thumb;\n            merror (T.thumb, \"foveon_thumb()\");\n            for (row=0; row < T.theight; row++) \n                {\n                    memset (pred, 0, sizeof pred);\n                    if (!bit) get4();\n                    for (bit=col=0; col < T.twidth; col++)\n                        for(c=0;c<3;c++) \n                            {\n                                for (dindex=first_decode; dindex->branch[0]; ) \n                                    {\n                                        if ((bit = (bit-1) & 31) == 31)\n                                            for (i=0; i < 4; i++)\n                                                bitbuf = (bitbuf << 8) + ID.input->get_char();\n                                        dindex = dindex->branch[bitbuf >> bit & 1];\n                                    }\n                                pred[c] += dindex->leaf;\n                                (*bufp++)=pred[c];\n                            }\n                }\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            T.tlength = 3*T.twidth * T.theight;\n        }\n    return;\n}\n#endif\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff (ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i=0; i < 13; i++) {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j=0; j < 256 >> clen; )\n      huff[code+ ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[1024], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse hpred[col & 1] += diff;\n\timage[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(wide>32767 || high > 32767 || wide*high > 20000000)\n     throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}\n\nconst char * CLASS foveon_camf_param (const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'P') continue;\n    if (strcmp (block, pos+sget4(pos+12))) continue;\n    cp = pos + sget4(pos+16);\n    num = sget4(cp);\n    dp = pos + sget4(cp+4);\n    while (num--) {\n      cp += 8;\n      if (!strcmp (param, dp+sget4(cp)))\n\treturn dp+sget4(cp+4);\n    }\n  }\n  return 0;\n}\n\nvoid * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx=0; idx < meta_length; idx += sget4(pos+8)) {\n    pos = meta_data + idx;\n    if (strncmp (pos, \"CMb\", 3)) break;\n    if (pos[3] != 'M') continue;\n    if (strcmp (name, pos+sget4(pos+12))) continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos+16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp+4)) > 3) break;\n    dp = pos + sget4(cp+8);\n    for (i=ndim; i--; ) {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;\n    mat = (unsigned *) malloc ((size = dsize) * 4);\n    merror (mat, \"foveon_camf_matrix()\");\n    for (i=0; i < size; i++)\n      if (type && type != 6)\n\tmat[i] = sget4(dp + i*4);\n      else\n\tmat[i] = sget4(dp + i*2) & 0xffff;\n    return mat;\n  }\n  fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n  return 0;\n}\n\nint CLASS foveon_fixed (void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name) return 0;\n  dp = foveon_camf_matrix (dim, name);\n  if (!dp) return 0;\n  memcpy (ptr, dp, size*4);\n  free (dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg (short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min=FLT_MAX, max=-FLT_MAX, sum=0;\n\n  for (i=range[0]; i <= range[1]; i++) {\n    sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;\n    if (min > val) min = val;\n    if (max < val) max = val;\n  }\n  if (range[1] - range[0] == 1) return sum/2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort * CLASS foveon_make_curve (double max, double mul, double filt)\n{\n  short *t_curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt) filt = 0.8;\n  size = 4*M_PI*max / filt;\n  if (size == UINT_MAX) size--;\n  t_curve = (short *) calloc (size+1, sizeof *t_curve);\n  merror (t_curve, \"foveon_make_curve()\");\n  t_curve[0] = size;\n  for (i=0; i < size; i++) {\n    x = i*filt/max/4;\n    t_curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;\n  }\n  return t_curve;\n}\n\nvoid CLASS foveon_make_curves\n\t(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max=0;\n  int c;\n\n  FORC3 mul[c] = dq[c]/div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve (short *t_curve, int i)\n{\n  if (abs(i) >= t_curve[0]) return 0;\n  return i < 0 ? -t_curve[1-i] : t_curve[1+i];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef image\n#undef image\n#endif\n#define image ((short(*)[4]) imgdata.image)\n#else\n#define image ((short (*)[4]) image)\n#endif\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };\n  short *pix, prev[3], *t_curve[8], (*t_shrink)[3];\n  float cfilt=0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float (*t_black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p=0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum=0, trsum[3];\n  char str[128];\n  const char* cp;\n\n  if (verbose)\n    fprintf (stderr,_(\"Foveon interpolation...\\n\"));\n\n  foveon_load_camf();\n  foveon_fixed (dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed (satlev, 3, \"SaturationLevel\");\n  foveon_fixed (keep, 4, \"KeepImageArea\");\n  foveon_fixed (active, 4, \"ActiveImageArea\");\n  foveon_fixed (chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed (color_dq, 3,\n\tfoveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?\n\t\t\"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))\n  \t\t foveon_fixed (&cfilt, 1, \"ColumnFilter\");\n\n  memset (ddft, 0, sizeof ddft);\n  if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")\n\t || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))\n    for (i=0; i < 2; i++) {\n      foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n\tfor (col = dstb[0]; col <= dstb[2]; col++)\n\t  FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];\n      FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);\n    }\n\n  if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))\n  { fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n    return; }\n  foveon_fixed (cam_xyz, 9, cp);\n  foveon_fixed (correct, 9,\n\tfoveon_camf_param (\"WhiteBalanceCorrections\", model2));\n  memset (last, 0, sizeof last);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n  #define LAST(x,y) last[(i+x)%3][(c+y)%3]\n  for (i=0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);\n  #undef LAST\n  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;\n  sprintf (str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param (\"IncludeBlocks\", str))\n    foveon_fixed (div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;\n  for (i=0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset (trans, 0, sizeof trans);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 3; j++)\n      FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves (t_curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves (t_curve+3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  t_curve[6] = foveon_make_curve (dsum, dsum, cfilt);\n  t_curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);\n\n  sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");\n  if (!sgain) return;\n  sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);\n  sgx = (width + dim[1]-2) / (dim[1]-1);\n\n  t_black = (float (*)[3]) calloc (height, sizeof *t_black);\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    FORC3 t_black[row][c] =\n \t( foveon_avg (image[row*width]+c, dscr[0], cfilt) +\n\t  foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3\n\t  - ddft[0][c][0] ) / 4 - ddft[0][c][1];\n  }\n  memcpy (t_black, t_black+8, sizeof *t_black*8);\n  memcpy (t_black+height-11, t_black+height-22, 11*sizeof *t_black);\n  memcpy (last, t_black, sizeof last);\n\n  for (row=1; row < height-1; row++) {\n    FORC3 if (last[1][c] > last[0][c]) {\n\tif (last[1][c] > last[2][c])\n\t  t_black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];\n      } else\n\tif (last[1][c] < last[2][c])\n\t  t_black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];\n    memmove (last, last+1, 2*sizeof last[0]);\n    memcpy (last[2], t_black[row+1], sizeof last[2]);\n  }\n  FORC3 t_black[row][c] = (last[0][c] + last[1][c])/2;\n  FORC3 t_black[0][c] = (t_black[1][c] + t_black[3][c])/2;\n\n  val = 1 - exp(-1/24.0);\n  memcpy (fsum, t_black, sizeof fsum);\n  for (row=1; row < height; row++)\n    FORC3 fsum[c] += t_black[row][c] =\n\t(t_black[row][c] - t_black[row-1][c])*val + t_black[row-1][c];\n  memcpy (last[0], t_black[height-1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--; )\n    FORC3 last[0][c] = t_black[row][c] =\n\t(t_black[row][c] - fsum[c] - last[0][c])*val + last[0][c];\n\n  memset (total, 0, sizeof total);\n  for (row=2; row < height; row+=4)\n    for (col=2; col < width; col+=4) {\n      FORC3 total[c] += (short) image[row*width+col][c];\n      total[3]++;\n    }\n  for (row=0; row < height; row++)\n    FORC3 t_black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);\n\n  for (row=0; row < height; row++) {\n    for (i=0; i < 6; i++)\n      ddft[0][0][i] = ddft[1][0][i] +\n\trow / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);\n    pix = image[row*width];\n    memcpy (prev, pix, sizeof prev);\n    frow = row / (height-1.0) * (dim[2]-1);\n    if ((irow = frow) == dim[2]-1) irow--;\n    frow -= irow;\n    for (i=0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +\n\t\t\t  sgain[(irow+1)*dim[1]+i][c] *    frow;\n    for (col=0; col < width; col++) {\n      FORC3 {\n\tdiff = pix[c] - prev[c];\n\tprev[c] = pix[c];\n\tipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt\n\t\t- ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)\n\t\t- t_black[row][c] );\n      }\n      FORC3 {\n\twork[0][c] = ipix[c] * ipix[c] >> 14;\n\twork[2][c] = ipix[c] * work[0][c] >> 14;\n\twork[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;\n      }\n      FORC3 {\n\tfor (val=i=0; i < 3; i++)\n\t  for (  j=0; j < 3; j++)\n\t    val += ppm[c][i][j] * work[i][j];\n\tipix[c] = floor ((ipix[c] + floor(val)) *\n\t\t( sgrow[col/sgx  ][c] * (sgx - col%sgx) +\n\t\t  sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);\n\tif (ipix[c] > 32000) ipix[c] = 32000;\n\tpix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free (t_black);\n  free (sgrow);\n  free (sgain);\n\n  if ((badpix = (unsigned int *) foveon_camf_matrix (dim, \"BadPixels\"))) {\n    for (i=0; i < dim[0]; i++) {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20       ) - keep[1];\n      if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)\n\tcontinue;\n      memset (fsum, 0, sizeof fsum);\n      for (sum=j=0; j < 8; j++)\n\tif (badpix[i] & (1 << j)) {\n\t  FORC3 fsum[c] += (short)\n\t\timage[(row+hood[j*2])*width+col+hood[j*2+1]][c];\n\t  sum++;\n\t}\n      if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;\n    }\n    free (badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);\n  merror (smrow[6], \"foveon_interpolate()\");\n  for (i=0; i < 5; i++)\n    smrow[i] = smrow[6] + i*width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tsmrow[4][col][0] =\n\t  (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      smred = ( 6 *  smrow[2][col][0]\n\t      + 4 * (smrow[1][col][0] + smrow[3][col][0])\n\t      +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;\n      if (col == 2)\n\tsmred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);\n      if (i > 32000) i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3 {\n    i = satlev[c] / div[c];\n    if (min > i) min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c=1; c < 3; c++) {\n      if (min > pix[c]) min = pix[c];\n      if (max < pix[c]) max = pix[c];\n    }\n    if (min >= limit*2) {\n      pix[0] = pix[1] = pix[2] = max;\n    } else {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i*i >> 14);\n      i = i*i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n/*\n   Because photons that miss one detector often hit another,\n   the sum R+G+B is much less noisy than the individual colors.\n   So smooth the hues without smoothing the total.\n */\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      FORC3 dev[c] = -foveon_apply_curve (t_curve[7], pix[c] -\n\t((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast=-1, row=2; row < height-2; row++) {\n    while (smlast < row+2) {\n      for (i=0; i < 6; i++)\n\tsmrow[(i+5) % 6] = smrow[i];\n      pix = image[++smlast*width+2];\n      for (col=2; col < width-2; col++) {\n\tFORC3 smrow[4][col][c] =\n\t\t(pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;\n\tpix += 4;\n      }\n    }\n    pix = image[row*width+2];\n    for (col=2; col < width-2; col++) {\n      for (total[3]=375, sum=60, c=0; c < 3; c++) {\n\tfor (total[c]=i=0; i < 5; i++)\n\t  total[c] += smrow[i][col][c];\n\ttotal[3] += total[c];\n\tsum += pix[c];\n      }\n      if (sum < 0) sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve (t_curve[6],\n\t\t((j*total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix=image[0]; pix < image[height*width]; pix+=4) {\n    FORC3 pix[c] -= foveon_apply_curve (t_curve[c], pix[c]);\n    sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve (t_curve[c], pix[c]-sum);\n    FORC3 {\n      for (dsum=i=0; i < 3; i++)\n\tdsum += trans[c][i] * pix[i];\n      if (dsum < 0)  dsum = 0;\n      if (dsum > 24000) dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  t_shrink = (short (*)[3]) calloc ((width/4) * (height/4), sizeof *t_shrink);\n  merror (t_shrink, \"foveon_interpolate()\");\n  for (row = height/4; row--; )\n    for (col=0; col < width/4; col++) {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i=0; i < 4; i++)\n\tfor (j=0; j < 4; j++)\n\t  FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];\n      FORC3\n\tif (row+2 > height/4)\n\t  t_shrink[row*(width/4)+col][c] = ipix[c] >> 4;\n\telse\n\t  t_shrink[row*(width/4)+col][c] =\n\t    (t_shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row=0; row < (height & ~3); row++) {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3 ; col--; )\n\tFORC3 smrow[0][col][c] = ipix[c] =\n\t  (t_shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col=0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] =\n\t(smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;\n\n  /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy (smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col=0; col < (width & ~3); col++)\n\tFORC3 smrow[2][col][c] =\n\t  (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;\n\n  /* Adjust the chroma toward the smooth values */\n    for (col=0; col < (width & ~3); col++) {\n      for (i=j=30, c=0; c < 3; c++) {\n\ti += smrow[2][col][c];\n\tj += image[row*width+col][c];\n      }\n      j = (j << 16) / i;\n      for (sum=c=0; c < 3; c++) {\n\tipix[c] = foveon_apply_curve (t_curve[c+3],\n\t  ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);\n\tsum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3 {\n\ti = image[row*width+col][c] + ipix[c] - sum;\n\tif (i < 0) i = 0;\n\timage[row*width+col][c] = i;\n      }\n    }\n  }\n  free (t_shrink);\n  free (smrow[6]);\n  for (i=0; i < 8; i++)\n    free (t_curve[i]);\n\n  /* Trim off the black border */\n  if (~cropbox[2] && ~cropbox[3])\n    {\n      // Image already cropped, do nothing\n      int crop[4],c;\n      for(int c=0;c<4;c++) \n        {\n          crop[c] = cropbox[c];\n          if(crop[c]<0)\n            crop[c]=0;\n        }\n      if(crop[0]>=width-1) crop[0] = width - 2;\n      if(crop[1]>=height-1) crop[1] = height-2;\n      if(crop[0]+crop[2] >= width) crop[2] = width-crop[0];\n      if(crop[1]+crop[3] >= height) crop[3] = height-crop[1];\n      active[0] = crop[0];\n      active[1] = crop[1];\n      active[2] = crop[0]+crop[2];\n      active[3] = crop[1]+crop[3];\n    }\n  else\n    {\n      active[1] -= keep[1];\n      active[3] -= 2;\n    }\n  i = active[2] - active[0];\n  for (row=0; row < active[3]-active[1]; row++)\n    memcpy (image[row*i], image[(row+active[1])*width+active[0]],\n            i * sizeof *image);\n  width = i;\n  height = row;\n\n}\n#undef image\n#ifdef LIBRAW_LIBRARY_BUILD\n#define image           (imgdata.image)\n#endif\n\n/* RESTRICTED code ends here */\n\n"], "filenames": ["dcraw_foveon.c"], "buggy_code_start_loc": [322], "buggy_code_end_loc": [354], "fixing_code_start_loc": [322], "fixing_code_end_loc": [359], "type": "CWE-190", "message": "An integer overflow error within the \"foveon_load_camf()\" function (dcraw_foveon.c) in LibRaw-demosaic-pack-GPL2 before 0.18.2 can be exploited to cause a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2017-6889", "sourceIdentifier": "PSIRT-CNA@flexerasoftware.com", "published": "2017-05-15T18:29:00.200", "lastModified": "2017-05-24T14:04:30.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An integer overflow error within the \"foveon_load_camf()\" function (dcraw_foveon.c) in LibRaw-demosaic-pack-GPL2 before 0.18.2 can be exploited to cause a heap-based buffer overflow."}, {"lang": "es", "value": "Un desbordamiento de enteros dentro de la funci\u00f3n  foveon_load_camf() (dcraw_foveon.c) en LibRaw-demosaic-pack-GPL2 en versiones anteriores a la 0.18.2 puede explotarse para provocar una sobrelectura de b\u00fafer basada din\u00e1mica o heap."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw-demosaic-pack-gpl2:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.18.1", "matchCriteriaId": "E5F84F5C-43B5-416C-9F3E-065187FC602D"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw-demosaic-pack-GPL2/commit/194f592e205990ea8fce72b6c571c14350aca716", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://secuniaresearch.flexerasoftware.com/advisories/75000/", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw-demosaic-pack-GPL2/commit/194f592e205990ea8fce72b6c571c14350aca716"}}