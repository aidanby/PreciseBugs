{"buggy_code": ["package Munin::Master::HTMLConfig;\n\nuse warnings;\nuse strict;\n\nuse Exporter;\nour (@ISA, @EXPORT);\n@ISA = qw(Exporter);\n@EXPORT = qw(generate_config get_peer_nodes);\n\nuse POSIX qw(strftime);\nuse Getopt::Long;\nuse Time::HiRes;\nuse Scalar::Util qw( weaken );\n\nuse Munin::Master::Logger;\nuse Munin::Master::Utils;\nuse Data::Dumper;\n\nuse Log::Log4perl qw( :easy );\n\nmy @times = (\"day\", \"week\", \"month\", \"year\");\n\nmy $DEBUG = 0;\nmy $INDEX_FILENAME = \"index.html\";\n\nmy $config;\nmy $limits;\nmy $cache;\n\nmy $categories;\nmy $problems;\n\nsub generate_config {\n    my $use_cache = shift;\n    if ($use_cache) {\n\t$cache = undef; # undef, for RAM usage\n\t# if there is some cache, use it (for cgi)\n    \tmy $newcache = munin_readconfig_part('htmlconf', 1);\n\tif (defined $newcache) {\n\t\t$cache = $newcache;\n\t\treturn $cache;\n\t}\n    }\n    $categories = {};\n    $problems = {\"criticals\" => [], \"warnings\" => [], \"unknowns\" => []};\n    my $rev = munin_configpart_revision();\n\n    $config = munin_readconfig_part('datafile', 0);\n    initiate_cgiurl_graph(); # we don't set a default like for others\n    if ($rev != munin_configpart_revision()) {\n\t# convert config for html generation: reorder nodes to their rightful group\n\tnode_reorder($config);\n    }\n\n    $limits = munin_readconfig_part(\"limits\");\n    # if only limits changed, still update our cache\n    if ($rev != munin_configpart_revision()) {\n\t$cache = undef; # undef, for RAM usage\n\t$cache = get_group_tree($config);\n    }\n\n    return $cache;\n}\n\nsub node_reorder {\n\tmy $totalconfig = shift;\n\tmy $group = shift || $config;\n\tmy $children = munin_get_sorted_children($group);\n\t# traverse group\n\tforeach my $child (@$children) {\n\t\t# if this is a node\n\t\tif(defined $child->{'address'}){\n\t\t\t# if renaming is active\n\t\t\tif(defined $child->{\"html_rename\"}){\n\t\t\t\t(my $groups, my $name) = munin_get_host_path_from_string($child->{\"html_rename\"});\n\t\t\t\t\n\t\t\t\t# add the node at its new place\n\t\t\t\tmy $currentgroup = $totalconfig;\n\t\t\t\tforeach my $local_group (@$groups){\n\t\t\t\t\tif(!defined $currentgroup->{$local_group}){\n\t\t\t\t\t\t$currentgroup->{$local_group} = {'#%#name' => $local_group, '#%#parent' => $currentgroup};\n\t\t\t\t\t\tweaken($currentgroup->{$local_group}{'#%#parent'});\n\t\t\t\t\t}\n\t\t\t\t\t$currentgroup = $currentgroup->{$local_group};\n\t\t\t\t}\n\n\t\t\t\tif(defined $currentgroup->{$name}){\n\t\t\t\t\tERROR $child->{\"html_rename\"} . \" already exists. Renaming not possible.\";\n\t\t\t\t} else {\n\t\t\t\t\t# remove node from structure\n\t\t\t\t\tundef $group->{$child->{\"#%#name\"}};\n\t\t\t\t\t\n\t\t\t\t\t# change name into new name\n\t\t\t\t\t$child->{\"#%#origname\"} = $child->{\"#%#name\"};\n\t\t\t\t\t$child->{\"#%#name\"} = $name;\n\t\t\t\t\t\n\t\t\t\t\t# add to new group\n\t\t\t\t\t$child->{\"#%#origparent\"} = $group;\n\t\t\t\t\t$currentgroup->{$name} = $child;\n\t\t\t\t\t$child->{\"#%#parent\"} = $currentgroup;\n\t\t\t\t\tweaken($child->{\"#%#parent\"});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t# reorder group\n\t\t\tnode_reorder($totalconfig, $child);\n\t\t}\n\t}\n}\n\nsub initiate_cgiurl_graph {\n    if (!defined $config->{'cgiurl_graph'}) {\n        if (defined $config->{'cgiurl'}) {\n            $config->{'cgiurl_graph'} = $config->{'cgiurl'} . \"/munin-cgi-graph\";\n        }\n        else {\n            $config->{'cgiurl_graph'} = \"/munin-cgi/munin-cgi-graph\";\n        }\n\t\tDEBUG \"[DEBUG] Determined that cgiurl_graph is \".$config->{'cgiurl_graph'};\n    }\n}\n\nsub add_graph_to_categories {\n\tmy $srv = shift;\n\tmy $category = $srv->{\"category\"};\n\tmy $srvname = $srv->{\"label\"};\n\tif(!defined ($categories->{$category})){\n\t\t$categories->{$category} = {};\n\t}\n\tif(!defined ($categories->{$category}->{$srvname})){\n\t\t$categories->{$category}->{$srvname} = [];\n\t}\n\tpush @{$categories->{$category}->{$srvname}}, $srv;\n}\n\nsub get_group_tree {\n    my $hash    = shift;\n    my $base    = shift || \"\";\n\n    my $graphs  = [];     # Pushy array of graphs, [ { name => 'cpu'}, ...]\n    my $groups  = [];     # Slices of the $config hash\n\tmy $cattrav = {};     # Categories, array of strings\n    my $cats    = [];     # Array of graph information ('categories')\n    my $path    = [];     # (temporary) array of paths relevant to . (here)\n    my $rpath   = undef;\n    my $visible = 0;\n    my $css_name;\n\n    my $children = munin_get_sorted_children($hash);\n\n    foreach my $child (@$children) {\n        next unless defined $child and ref($child) eq \"HASH\" and keys %$child;\n\n\t\t$child->{\"#%#ParentsNameAsString\"} = munin_get_node_name($hash); # TODO: is this value used anywhere?\n\n        if (defined $child->{\"graph_title\"} and munin_get_bool($child, \"graph\", 1)) { #graph\n\t\t    $child->{'#%#is_service'} = 1; # TODO: is this value used anywhere?\n\t\t\tmy $childname = munin_get_node_name($child);\n\t\t\tmy $childnode = generate_service_templates($child);\n\t\t\tpush @$graphs, {\"name\" => $childname};\n\t\t\t$childnode->{'name'} = $child->{\"graph_title\"};\n\t\t\tadd_graph_to_categories($childnode);\n\n\t\t    # Make sure the link gets right even if the service has subservices\n\t    \tif (munin_has_subservices ($child)) {\n\t\t\t\t$childnode->{'url'}  = $base . $childname . \"/$INDEX_FILENAME\"; #TODO: html generation should generate urls\n\t\t    } else {\n\t\t\t\t$childnode->{'url'}  = $base . $childname . \".html\"; #TODO: html generation should generate urls\n\t    \t}\n\n            $childnode->{'host_url'}  = $base . $INDEX_FILENAME;\n\n            #TODO: Think of a nicer way to generate relative urls (reference #1)\n\t\t\tfor (my $shrinkpath = $childnode->{'url'}, my $counter = 0;\n\t\t\t $shrinkpath;\n\t\t\t $shrinkpath =~ s/^[^\\/]+\\/?//, $counter++)\n\t    \t{\n                $childnode->{'url' . $counter} = $shrinkpath;\n            }\n\n            push @{$cattrav->{lc munin_get($child, \"graph_category\", \"other\")}}, $childnode;\n\n\t\t    # If this is a multigraph plugin there may be sub-graphs.\n\t\t    push( @$groups, grep {defined $_} get_group_tree($child, $base.munin_get_node_name($child).\"/\"));\n\n            $visible = 1;\n\t\t}\n        elsif (ref($child) eq \"HASH\" and !defined $child->{\"graph_title\"}) { #group\n\t\t\tpush( @$groups, grep {defined $_} get_group_tree($child, $base.munin_get_node_name($child) . \"/\"));\n\n\t\t\tif (scalar @$groups) {\n\t\t\t\t$visible = 1;\n\t\t    }\n\t\t}\n    }\n\n\tforeach my $group (@$groups) {\n\t\t$group->{'peers'} = get_peer_nodes($group->{\"#%#hash\"}, lc munin_get($group->{\"#%#hash\"}, \"graph_category\", \"other\"));\n\t}\n\n    return unless $visible;\n\n    $hash->{'#%#visible'} = 1; # TODO: is this value used anywhere?\n\n    # We need the categories in another format.\n    foreach my $cat (sort keys %$cattrav) {\n        my $obj = {};\n        $obj->{'name'}     = $cat;\n        $obj->{'url'}      = $base . \"${INDEX_FILENAME}#\" . $cat;\n        $obj->{'services'} = [sort {lc($a->{'name'}) cmp lc($b->{'name'})}\n                @{$cattrav->{$cat}}];\n        $obj->{'state_' . lc munin_category_status($hash, $limits, $cat, 1)}\n            = 1;\n\t\t#TODO: shrinkpath reference #2\n        for (\n            my $shrinkpath = $obj->{'url'}, my $counter = 0;\n            $shrinkpath =~ /\\//;\n            $shrinkpath =~ s/^[^\\/]+\\/*//, $counter++\n            ) {\n            $obj->{'url' . $counter} = $shrinkpath;\n        }\n        push @$cats, $obj;\n    }\n\n    # ...and we need a couple of paths available.\n\t# TODO: think of a nicer way to generate urls\n    @$path = reverse map {\n        {\n            \"pathname\" => $_,\n            \"path\" => (\n                defined $rpath\n                ? ($rpath .= \"../\") . $INDEX_FILENAME\n                : ($rpath = \"\"))}\n    } reverse(undef, split('\\/', $base));\n\t\n\t# TODO: think of a nicer way to generate urls\n    my $root_path = get_root_path($path);\n\n    # We need a bit more info for the comparison templates\n    my $compare         = munin_get_bool($hash, \"compare\", 1);\n    my $comparecats = [];\n    my $comparegroups = [];\n\tif($compare){\n      ($compare, $comparecats, $comparegroups) = generate_compare_groups($groups);\n    }\n\tmy %group_hash = (map {$_->{'name'} => $_} @{$groups});   \n \n\tmy $ret = {\n        \"name\"     => munin_get_node_name($hash),\n        \"url\"      => $base . $INDEX_FILENAME,\n        \"path\"     => $path,\n\t\t\"#%#hash\"     => $hash,\n        \"depth\" => scalar(my @splitted_base = split(\"/\", $base . $INDEX_FILENAME))\n            - 1,\n        \"filename\"           => munin_get_html_filename($hash),\n        \"css_name\"           => $css_name,\n        \"root_path\"          => $root_path,\n        \"groups\"             => $groups,\n\t\t\"groups_hash\"\t\t => \\%group_hash,\n        \"graphs\"             => $graphs,\n        \"multigraph\"         => munin_has_subservices ($hash),\n        \"categories\"         => $cats,\n        \"ngroups\"            => scalar(@$groups),\n        \"ngraphs\"            => scalar(@$graphs),\n        \"ncategories\"        => scalar(@$cats),\n        \"compare\"            => $compare,\n        \"comparegroups\"      => $comparegroups,\n        \"ncomparegroups\"     => scalar(@$comparegroups),\n        \"comparecategories\"  => $comparecats,\n        \"ncomparecategories\" => scalar(@$comparecats),\n    };\n\n\n\tif($ret->{'depth'} == 0){ #root node does not have peer nodes\n\t\t# add categories\n\t\tmy $catarray = [];\n\t\tforeach (sort keys %{$categories}) {\n\t\t\tmy $currentcat = $categories->{$_};\n\t\t\tmy $srvarray = [];\n\t\t\tforeach (sort keys %{$currentcat}) {\n\t\t\t\tmy $srv_nodename = $_;\n\t\t\t\t$srv_nodename =~ s/ /_/g;\n\t\t\t\tmy $srv = {\n\t\t\t\t\t\"graphs\" => $currentcat->{$_},\n\t\t\t\t\t\"name\" => $_,\n\t\t\t\t\t\"service\" => $srv_nodename,\n\t\t\t\t};\n\t\t\t\tpush @$srvarray, $srv\n\t\t\t}\n\t\t\tmy $filename = munin_get_html_filename($hash);\n\t\t\t$filename =~ s/index.html$/$_/;\n\t\t\tmy $cat = {\n\t\t\t\t\"name\" => $_,\n\t\t\t\t\"urlday\" => \"$_-day.html\",\n\t\t\t\t\"urlweek\" => \"$_-week.html\",\n\t\t\t\t\"urlmonth\" => \"$_-month.html\",\n\t\t\t\t\"urlyear\" => \"$_-year.html\",\n\t\t\t\t\"path\" => $path,\n\t\t\t\t\"graphs\" => $srvarray,\n\t\t\t\t\"filename-day\" => $filename . \"-day.html\",\n\t\t\t\t\"filename-week\" => $filename . \"-week.html\",\n\t\t\t\t\"filename-month\" => $filename . \"-month.html\",\n\t\t\t\t\"filename-year\" => $filename . \"-year.html\",\n\t\t\t};\n\t\t\tpush @$catarray, $cat;\n\t\t}\n\t\t$ret->{\"problems\"} = $problems;\n\t\t$ret->{\"globalcats\"} = $catarray;\n\t\t$ret->{\"nglobalcats\"} = scalar(@$catarray);\n\t}\n\n    #TODO: shrinkpath reference #3\n\tif ($ret->{'url'} ne \"/index.html\") {\n        for (\n            my $shrinkpath = $ret->{'url'}, my $counter = 0;\n            $shrinkpath =~ /\\//;\n            $shrinkpath =~ s/^[^\\/]+\\/*//, $counter++\n            ) {\n            $ret->{'url' . $counter} = $shrinkpath;\n        }\n    }\n\n    return $ret;\n}\n\nsub generate_compare_groups {\n  my $groups = shift;\n  my $comparecats     = [];\n  my $comparecatshash = {};\n  my $comparegroups   = [];\n\n  foreach my $tmpgroup (@$groups) {\n\n    # First we gather a bit of data into comparecatshash...\n    if ($tmpgroup->{'ngraphs'} > 0 && !$tmpgroup->{\"multigraph\"}) { # no compare links for multigraphs\n      push @$comparegroups, $tmpgroup;\n      foreach my $tmpcat (@{$tmpgroup->{'categories'}}) {\n        $comparecatshash->{$tmpcat->{'name'}}->{'groupname'} = $tmpcat->{'name'};\n        foreach my $tmpserv (@{$tmpcat->{'services'}}) {\n          $comparecatshash->{$tmpcat->{'name'}}->{'services'}->{$tmpserv->{'name'}}->{'nodes'}->{$tmpgroup->{'name'}} = $tmpserv;\n          $comparecatshash->{$tmpcat->{'name'}}->{'services'}->{$tmpserv->{'name'}}->{'nodes'}->{$tmpgroup->{'name'}}->{'nodename'} = $tmpgroup->{'name'};\n          $comparecatshash->{$tmpcat->{'name'}}->{'services'}->{$tmpserv->{'name'}}->{'nodes'}->{$tmpgroup->{'name'}}->{'nodeurl'} = $tmpgroup->{'url'};\n        }\n      }\n    }\n  }\n  if (scalar @$comparegroups <= 1) {\n    return (0, [], []); # ($compare, $comparecats, $comparegroups)\n  }\n\n  # restructure it, comparecats need to end up looking like: ->[i]->{'services'}->[i]->{'nodes'}->[i]->{*}\n  # not really restructuring; this just sorts all arrays, but doesn't take the node order into account.\n  my $empty_node = {\n\n  };\n\n  foreach my $tmpcat (sort keys %$comparecatshash) {\n    foreach my $tmpserv (sort keys %{$comparecatshash->{$tmpcat}->{'services'}}) {\n      my @nodelist = map {defined $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'}->{$_->{'name'}} ?\n                        $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'}->{$_->{'name'}} :\n                        {\n                          nodename => $_->{'name'},\n                        }\n                      } (@$groups);\n      delete $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'};\n      $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'} = \\@nodelist;\n    }\n    my @servlist = map {$comparecatshash->{$tmpcat}->{'services'}->{$_}} sort keys %{$comparecatshash->{$tmpcat}->{'services'}};\n    delete $comparecatshash->{$tmpcat}->{'services'};\n    $comparecatshash->{$tmpcat}->{'services'} = \\@servlist;\n  }\n  @$comparecats = map {$comparecatshash->{$_}} sort keys %$comparecatshash;\n  return (1, $comparecats, $comparegroups);\n}\n\n# This is called both at group level, service level, and subservice level\nsub munin_get_sorted_children {\n    my $hash        = shift || return;\n\n    my $children    = munin_get_children($hash);\n    my $group_order;\n    my $ret         = [];\n\n    if (defined $hash->{'group_order'}) {\n\t$group_order = $hash->{'group_order'};\n    } elsif (defined $hash->{'domain_order'}) {\n\t$group_order = $hash->{'domain_order'};\n    } elsif (defined $hash->{'node_order'}) {\n\t$group_order = $hash->{'node_order'};\n    } else {\n    \t$group_order = \"\";\n    } \n\n    my %children = map {munin_get_node_name($_) => $_} @$children;\n\n    foreach my $group (split /\\s+/, $group_order) {\n        if (defined $children{$group}) {\n            push @$ret, $children{$group};\n            delete $children{$group};\n        }\n        elsif ($group =~ /^(.+)=([^=]+)$/) {\n\n            # \"Borrow\" the graph from another group\n            my $groupname = $1;\n            my $path      = $2;\n            my $borrowed  = munin_get_node_partialpath($hash, $path);\n            if (defined $borrowed) {\n                munin_copy_node_toloc($borrowed, $hash, [$groupname]);\n                $hash->{$groupname}->{'#%#origin'} = $borrowed;\n            }\n            push @$ret, $hash->{$groupname};\n        }\n    }\n\n    foreach my $group (sort {$a cmp $b} keys %children) {\n        push @$ret, $children{$group};\n    }\n\n    return $ret;\n}\n\nsub generate_service_templates {\n\n    my $service = shift || return;\n\n    return unless munin_get_bool($service, \"graph\", 1);\n\n    my %srv;\n    my $fieldnum = 0;\n    my @graph_info;\n    my @field_info;\n    my @loc       = @{munin_get_picture_loc($service)};\n    my $pathnodes = get_path_nodes($service);\n    my $peers     = get_peer_nodes($service,\n    lc munin_get($service, \"graph_category\", \"other\"));\n    my $parent = munin_get_parent_name($service);\n    my $filename = munin_get_html_filename($service);\n\n    my $root_path = get_root_path($pathnodes);\n    my $bp = borrowed_path($service) || \".\";\n\n    $srv{'node'} = munin_get_node_name($service);\n    DEBUG \"[DEBUG] processing service: $srv{node}\";\n    $srv{'service'}   = $service;\n    $srv{\"multigraph\"}= munin_has_subservices($service);\n    $srv{'label'}     = munin_get($service, \"graph_title\");\n    $srv{'category'}  = lc(munin_get($service, \"graph_category\", \"other\"));\n\t$srv{'path'}      = $pathnodes;\n\t$srv{'peers'}     = $peers;\n    $srv{'root_path'} = $root_path;\n\t$srv{'filename'}  = $filename;\n\n    $srv{'url'} = \"$srv{node}.html\";\n\n    my $path = join('/', @loc);\n\n    my %imgs;\n    $imgs{'imgday'}   = \"$path-day.png\";\n    $imgs{'imgweek'}  = \"$path-week.png\";\n    $imgs{'imgmonth'} = \"$path-month.png\";\n    $imgs{'imgyear'}  = \"$path-year.png\";\n    \n    $imgs{'cimgday'}   = \"$path-day.png\";\n    $imgs{'cimgweek'}  = \"$path-week.png\";\n    $imgs{'cimgmonth'} = \"$path-month.png\";\n    $imgs{'cimgyear'}  = \"$path-year.png\";\n    \n    if (munin_get_bool($service, \"graph_sums\", 0)) {\n        $imgs{'imgweeksum'} = \"$path-week-sum.png\";\n        $imgs{'imgyearsum'} = \"$path-year-sum.png\";\n    }\n\n    # dump all the png filename to a file\n    my $fh = $config->{\"#%#graphs_fh\"};\n    if ($fh) {\n\t    # values %imgs = the image file\n\t    # get them uniq, so we don't write them twice\n\t    my %paths = map { $_, 1 } (values %imgs);\n\t    foreach my $img (keys %paths) {\n\t\tprint $fh \"/\" . $img . \"\\n\";\n\t    }\n    }\n\n    my $imgpath = $root_path;\n    if ( munin_get($config, \"graph_strategy\", \"cron\") eq \"cgi\" ) {\n\t$imgpath = $config->{'cgiurl_graph'};\n    }\n\n    map { $srv{$_} = $imgpath . \"/\" . $imgs{$_} } keys %imgs;\n\n    # Compute the ZOOM urls\n    {\n        my $epoch_now = time;\n\t# The intervals are a bit larger, just like the munin-graph\n\tmy $start_day = $epoch_now - (3600 * 30);\n\tmy $start_week = $epoch_now - (3600 * 24 * 8);\n\tmy $start_month = $epoch_now - (3600 * 24 * 33);\n\tmy $start_year = $epoch_now - (3600 * 24 * 400);\n\tmy $size_x = 800;\n\tmy $size_y = 400;\n\tmy $common_url = \"$root_path/static/dynazoom.html?cgiurl_graph=$config->{'cgiurl_graph'}&plugin_name=$path&size_x=$size_x&size_y=$size_y\";\n\t$srv{zoomday} = \"$common_url&start_epoch=$start_day&stop_epoch=$epoch_now\";\n\t$srv{zoomweek} = \"$common_url&start_epoch=$start_week&stop_epoch=$epoch_now\";\n\t$srv{zoommonth} = \"$common_url&start_epoch=$start_month&stop_epoch=$epoch_now\";\n\t$srv{zoomyear} = \"$common_url&start_epoch=$start_year&stop_epoch=$epoch_now\";\n    }\n\n\tfor my $scale (@times) {\n\t\tmy ($w, $h) = get_png_size(munin_get_picture_filename($service, $scale));\n\t\tif ($w && $h) {\n\t\t\t$srv{\"img\" . $scale . \"width\"}  = $w;\n\t\t\t$srv{\"img\" . $scale . \"height\"} = $h;\n\t\t}\n\t}\n\n    if (munin_get_bool($service, \"graph_sums\", 0)) {\n        $srv{imgweeksum} = \"$srv{node}-week-sum.png\";\n        $srv{imgyearsum} = \"$srv{node}-year-sum.png\";\n\n        for my $scale ([\"week\", \"year\"]) {\n\t\tmy ($w, $h) = get_png_size(munin_get_picture_filename($service, $scale, 1));\n\t\tif ($w && $h) {\n\t\t\t$srv{\"img\" . $scale . \"sumwidth\"}  = $w;\n\t\t\t$srv{\"img\" . $scale . \"sumheight\"} = $h;\n\t\t}\n        }\n    }\n\n    # Do \"help\" section\n    if (my $info = munin_get($service, \"graph_info\")) {\n        my %graph_info;\n        $graph_info{info} = $info;\n        push @{$srv{graphinfo}}, \\%graph_info;\n    }\n\n    #TODO move this ugly code to the templates\n\t$srv{fieldlist}\n        .= \"<tr><th align='left' valign='top'>Field</th><th align='left' valign='top'>Type</th><th align='left' valign='top'>Warn</th><th align='left' valign='top'>Crit</th><th></tr>\";\n    foreach my $f (@{munin_get_field_order($service)}) {\n        $f =~ s/=(.*)$//;\n        my $path = $1;\n        next if (!defined $service->{$f});\n        my $fieldobj = $service->{$f};\n        next if (ref($fieldobj) ne \"HASH\" or !defined $fieldobj->{'label'});\n        next if (!munin_draw_field($fieldobj));\n\n        #DEBUG \"DEBUG: single_value: Checking field \\\"$f\\\" ($path).\";\n\n        if (defined $path) {\n\n            # This call is to make sure field settings are copied\n            # for aliases, .stack, et al. Todo: put that part of\n            # munin_get_rrd_filename into its own functino.\n            munin_get_rrd_filename($f, $path);\n        }\n\n        my %field_info;\n        $fieldnum++;\n\n        $field_info{'hr'}    = 1 unless ($fieldnum % 3);\n        $field_info{'field'} = $f;\n        $field_info{'label'} = munin_get($fieldobj, \"label\", $f);\n        $field_info{'type'}  = lc(munin_get($fieldobj, \"type\", \"GAUGE\"));\n        $field_info{'warn'}  = munin_get($fieldobj, \"warning\");\n        $field_info{'crit'}  = munin_get($fieldobj, \"critical\");\n        $field_info{'info'}  = munin_get($fieldobj, \"info\");\n        $field_info{'extinfo'} = munin_get($fieldobj, \"extinfo\");\n\n        my $state = munin_field_status($fieldobj, $limits, 1);\n\n        if (defined $state) {\n            $field_info{'state_warning'}  = $state eq \"warning\" ? 1 : 0;\n            $field_info{'state_critical'} = $state eq \"critical\" ? 1 : 0;\n            $field_info{'state_unknown'}  = $state eq \"unknown\" ? 1 : 0;\n        }\n        push @{$srv{'fieldinfo'}}, \\%field_info;\n    }\n\n    my $state = munin_service_status($service, $limits, 1);\n\n    if (defined $state) {\n        $srv{'state_warning'}  = $state eq \"warning\" ? 1 : 0;\n        $srv{'state_critical'} = $state eq \"critical\" ? 1 : 0;\n        $srv{'state_unknown'}  = $state eq \"unknown\" ? 1 : 0;\n\t\tpush @{$problems->{\"warnings\"}}, \\%srv if $state eq \"warning\";\n\t\tpush @{$problems->{\"criticals\"}}, \\%srv if $state eq \"critical\";\n\t\tpush @{$problems->{\"unknowns\"}}, \\%srv if $state eq \"unknown\";\n    }\n\n    return \\%srv;\n}\n\n#TODO: move path specific information to html generation\nsub get_path_nodes {\n    my $hash = shift || return;\n    my $ret  = [];\n    my $link = $INDEX_FILENAME;\n\n    unshift @$ret, {\"pathname\" => munin_get_node_name($hash), \"path\" => \"\"};\n    while ($hash = munin_get_parent($hash)) {\n        unshift @$ret, {\"pathname\" => munin_get_node_name($hash), \"path\" => $link};\n        $link = \"../\" . $link;\n    }\n\n    $ret->[0]->{'pathname'} = undef;\n    return $ret;\n}\n\n#TODO: This really needs some refactoring\nsub get_peer_nodes {\n    my $hash      = shift || return;\n    my $category  = shift;\n    my $ret       = [];\n    my $parent    = munin_get_parent($hash) || return;\n    my $me        = munin_get_node_name($hash);\n    my $pchildren = munin_get_children($parent);\n\n    my @peers = map { $_->[0] }\n        sort { $a->[1] cmp $b->[1] }\n        map { [ $_, munin_get_node_name($_) ] } @$pchildren;\n\n    foreach my $peer (@peers) {\n        next unless defined $peer and ref($peer) eq \"HASH\";\n        next\n          if defined $category\n                and lc(munin_get($peer, \"graph_category\", \"other\")) ne\n                  $category;\n        next\n          if (!defined $peer->{'graph_title'}\n              and (!defined $peer->{'#%#visible'} or !$peer->{'#%#visible'}));\n        next\n          if (defined $peer->{'graph_title'}\n            and !munin_get_bool($peer, \"graph\", 1));\n        my $peername = munin_get_node_name($peer);\n        next\n          if $peername eq \"contact\"\n            and munin_get_node_name($parent) eq \"root\";\n        if ($peername eq $me) {\n            unshift @$ret, {\"name\" => $peername, \"link\" => undef};\n        }\n        else {\n            # Handle different directory levels between subgraphs and regular graphs\n            if (munin_has_subservices ($hash)) {\n                if (munin_has_subservices ($peer)) {\n                    # I've got subgraphs, peer's got subgraphs\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"../$peername/index.html\"};\n                } else { \n                    # I've got subgraphs, peer's a regular graph\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"../$peername.html\"};\n                } \n            } elsif (munin_has_subservices ($peer)) {\n                # I'm a regular graph, peer's got subgraphs\n                unshift @$ret,\n                  {\"name\" => $peername, \"link\" => \"$peername/index.html\"};\n            } else {\n                if (defined $peer->{'graph_title'}) {\n                    # Both me and peer are regular graphs\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"$peername.html\"};\n                }\n                else {\n                    # We're not on the graph level -- handle group peering\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"../$peername/index.html\"};\n                }\n            }\n        }\n    }\n    return $ret;\n}\n\n#TODO: move url logic to html generation\nsub get_root_path{\n    my ($path) = @_;\n    if ($path) {\n        (my $root = $path->[0]->{'path'}) =~ s/\\/index.html$//;\n        return $root;\n    }\n    return \"\";\n}\n\n#TODO: move url logic to html generation\nsub borrowed_path {\n    # I wish I knew what this function does.  It appears to make\n    # .. path elements to climb up the directory hierarchy.  To\n    # \"borrow\" something from a different directory level.\n\n    my $hash     = shift;\n    my $prepath  = shift || \"\";\n    my $postpath = shift || \"\";\n\n    return unless defined $hash and ref($hash) eq \"HASH\";\n\n    if (defined $hash->{'#%#origin'}) {\n        return\n\t    $prepath . \"../\"\n            . munin_get_node_name($hash->{'#%#origin'}) . \"/\"\n            . $postpath;\n    }\n    else {\n        if (defined $hash->{'#%#parent'}) {\n            if (defined $hash->{'graph_title'}) {\n                return borrowed_path($hash->{'#%#parent'}, $prepath . \"../\",\n                    $postpath);\n            }\n            else {\n                return borrowed_path(\n                    $hash->{'#%#parent'},\n                    $prepath . \"../\",\n                    munin_get_node_name($hash) . \"/\" . $postpath\n                );\n            }\n        }\n        else {\n            return;\n        }\n    }\n}\n\n#TODO: This method is obsolete when cgi-graphing is the only strategy left\nsub get_png_size {\n    my $filename = shift;\n    my $width    = undef;\n    my $height   = undef;\n\n    return (undef, undef) if (munin_get($config, \"graph_strategy\", \"cron\") eq \"cgi\") ;\n\n    if (open(my $PNG, '<', $filename)) {\n        my $incoming;\n        binmode($PNG);\n        if (read($PNG, $incoming, 4)) {\n            if ($incoming =~ /PNG$/) {\n                if (read($PNG, $incoming, 12)) {\n                    if (read($PNG, $incoming, 4)) {\n                        $width = unpack(\"N\", $incoming);\n                        read($PNG, $incoming, 4);\n                        $height = unpack(\"N\", $incoming);\n                    }\n                }\n            }\n        }\n        close($PNG);\n    }\n\n    return ($width, $height);\n}\n\n\n\n1;\n"], "fixing_code": ["package Munin::Master::HTMLConfig;\n\nuse warnings;\nuse strict;\n\nuse Exporter;\nour (@ISA, @EXPORT);\n@ISA = qw(Exporter);\n@EXPORT = qw(generate_config get_peer_nodes);\n\nuse POSIX qw(strftime);\nuse Getopt::Long;\nuse Time::HiRes;\nuse Scalar::Util qw( weaken );\n\nuse Munin::Master::Logger;\nuse Munin::Master::Utils;\nuse Data::Dumper;\n\nuse Log::Log4perl qw( :easy );\n\nmy @times = (\"day\", \"week\", \"month\", \"year\");\n\nmy $DEBUG = 0;\nmy $INDEX_FILENAME = \"index.html\";\n\nmy $config;\nmy $limits;\nmy $cache;\n\nmy $categories;\nmy $problems;\n\nsub generate_config {\n    my $use_cache = shift;\n    if ($use_cache) {\n\t$cache = undef; # undef, for RAM usage\n\t# if there is some cache, use it (for cgi)\n    \tmy $newcache = munin_readconfig_part('htmlconf', 1);\n\tif (defined $newcache) {\n\t\t$cache = $newcache;\n\t\treturn $cache;\n\t}\n    }\n    $categories = {};\n    $problems = {\"criticals\" => [], \"warnings\" => [], \"unknowns\" => []};\n    my $rev = munin_configpart_revision();\n\n    $config = munin_readconfig_part('datafile', 0);\n    initiate_cgiurl_graph(); # we don't set a default like for others\n    if ($rev != munin_configpart_revision()) {\n\t# convert config for html generation: reorder nodes to their rightful group\n\tnode_reorder($config);\n    }\n\n    $limits = munin_readconfig_part(\"limits\");\n    # if only limits changed, still update our cache\n    if ($rev != munin_configpart_revision()) {\n\t$cache = undef; # undef, for RAM usage\n\t$cache = get_group_tree($config);\n    }\n\n    return $cache;\n}\n\nsub node_reorder {\n\tmy $totalconfig = shift;\n\tmy $group = shift || $config;\n\tmy $children = munin_get_sorted_children($group);\n\t# traverse group\n\tforeach my $child (@$children) {\n\t\t# if this is a node\n\t\tif(defined $child->{'address'}){\n\t\t\t# if renaming is active\n\t\t\tif(defined $child->{\"html_rename\"}){\n\t\t\t\t(my $groups, my $name) = munin_get_host_path_from_string($child->{\"html_rename\"});\n\t\t\t\t\n\t\t\t\t# add the node at its new place\n\t\t\t\tmy $currentgroup = $totalconfig;\n\t\t\t\tforeach my $local_group (@$groups){\n\t\t\t\t\tif(!defined $currentgroup->{$local_group}){\n\t\t\t\t\t\t$currentgroup->{$local_group} = {'#%#name' => $local_group, '#%#parent' => $currentgroup};\n\t\t\t\t\t\tweaken($currentgroup->{$local_group}{'#%#parent'});\n\t\t\t\t\t}\n\t\t\t\t\t$currentgroup = $currentgroup->{$local_group};\n\t\t\t\t}\n\n\t\t\t\tif(defined $currentgroup->{$name}){\n\t\t\t\t\tERROR $child->{\"html_rename\"} . \" already exists. Renaming not possible.\";\n\t\t\t\t} else {\n\t\t\t\t\t# remove node from structure\n\t\t\t\t\tundef $group->{$child->{\"#%#name\"}};\n\t\t\t\t\t\n\t\t\t\t\t# change name into new name\n\t\t\t\t\t$child->{\"#%#origname\"} = $child->{\"#%#name\"};\n\t\t\t\t\t$child->{\"#%#name\"} = $name;\n\t\t\t\t\t\n\t\t\t\t\t# add to new group\n\t\t\t\t\t$child->{\"#%#origparent\"} = $group;\n\t\t\t\t\t$currentgroup->{$name} = $child;\n\t\t\t\t\t$child->{\"#%#parent\"} = $currentgroup;\n\t\t\t\t\tweaken($child->{\"#%#parent\"});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t# reorder group\n\t\t\tnode_reorder($totalconfig, $child);\n\t\t}\n\t}\n}\n\nsub initiate_cgiurl_graph {\n    if (!defined $config->{'cgiurl_graph'}) {\n        if (defined $config->{'cgiurl'}) {\n            $config->{'cgiurl_graph'} = $config->{'cgiurl'} . \"/munin-cgi-graph\";\n        }\n        else {\n            $config->{'cgiurl_graph'} = \"/munin-cgi/munin-cgi-graph\";\n        }\n\t\tDEBUG \"[DEBUG] Determined that cgiurl_graph is \".$config->{'cgiurl_graph'};\n    }\n}\n\nsub add_graph_to_categories {\n\tmy $srv = shift;\n\tmy $category = $srv->{\"category\"};\n\tmy $srvname = $srv->{\"label\"};\n\tif(!defined ($categories->{$category})){\n\t\t$categories->{$category} = {};\n\t}\n\tif(!defined ($categories->{$category}->{$srvname})){\n\t\t$categories->{$category}->{$srvname} = [];\n\t}\n\tpush @{$categories->{$category}->{$srvname}}, $srv;\n}\n\nsub get_group_tree {\n    my $hash    = shift;\n    my $base    = shift || \"\";\n\n    my $graphs  = [];     # Pushy array of graphs, [ { name => 'cpu'}, ...]\n    my $groups  = [];     # Slices of the $config hash\n\tmy $cattrav = {};     # Categories, array of strings\n    my $cats    = [];     # Array of graph information ('categories')\n    my $path    = [];     # (temporary) array of paths relevant to . (here)\n    my $rpath   = undef;\n    my $visible = 0;\n    my $css_name;\n\n    my $children = munin_get_sorted_children($hash);\n\n    foreach my $child (@$children) {\n        next unless defined $child and ref($child) eq \"HASH\" and keys %$child;\n\n\t\t$child->{\"#%#ParentsNameAsString\"} = munin_get_node_name($hash); # TODO: is this value used anywhere?\n\n        if (defined $child->{\"graph_title\"} and munin_get_bool($child, \"graph\", 1)) { #graph\n\t\t    $child->{'#%#is_service'} = 1; # TODO: is this value used anywhere?\n\t\t\tmy $childname = munin_get_node_name($child);\n\t\t\tmy $childnode = generate_service_templates($child);\n\t\t\tpush @$graphs, {\"name\" => $childname};\n\t\t\t$childnode->{'name'} = $child->{\"graph_title\"};\n\t\t\tadd_graph_to_categories($childnode);\n\n\t\t    # Make sure the link gets right even if the service has subservices\n\t    \tif (munin_has_subservices ($child)) {\n\t\t\t\t$childnode->{'url'}  = $base . $childname . \"/$INDEX_FILENAME\"; #TODO: html generation should generate urls\n\t\t    } else {\n\t\t\t\t$childnode->{'url'}  = $base . $childname . \".html\"; #TODO: html generation should generate urls\n\t    \t}\n\n            $childnode->{'host_url'}  = $base . $INDEX_FILENAME;\n\n            #TODO: Think of a nicer way to generate relative urls (reference #1)\n\t\t\tfor (my $shrinkpath = $childnode->{'url'}, my $counter = 0;\n\t\t\t $shrinkpath;\n\t\t\t $shrinkpath =~ s/^[^\\/]+\\/?//, $counter++)\n\t    \t{\n                die (\"Munin::Master::HTMLConfig ran into an endless loop\") if ($counter >= 100);\n                $childnode->{'url' . $counter} = $shrinkpath;\n            }\n\n            push @{$cattrav->{lc munin_get($child, \"graph_category\", \"other\")}}, $childnode;\n\n\t\t    # If this is a multigraph plugin there may be sub-graphs.\n\t\t    push( @$groups, grep {defined $_} get_group_tree($child, $base.munin_get_node_name($child).\"/\"));\n\n            $visible = 1;\n\t\t}\n        elsif (ref($child) eq \"HASH\" and !defined $child->{\"graph_title\"}) { #group\n\t\t\tpush( @$groups, grep {defined $_} get_group_tree($child, $base.munin_get_node_name($child) . \"/\"));\n\n\t\t\tif (scalar @$groups) {\n\t\t\t\t$visible = 1;\n\t\t    }\n\t\t}\n    }\n\n\tforeach my $group (@$groups) {\n\t\t$group->{'peers'} = get_peer_nodes($group->{\"#%#hash\"}, lc munin_get($group->{\"#%#hash\"}, \"graph_category\", \"other\"));\n\t}\n\n    return unless $visible;\n\n    $hash->{'#%#visible'} = 1; # TODO: is this value used anywhere?\n\n    # We need the categories in another format.\n    foreach my $cat (sort keys %$cattrav) {\n        my $obj = {};\n        $obj->{'name'}     = $cat;\n        $obj->{'url'}      = $base . \"${INDEX_FILENAME}#\" . $cat;\n        $obj->{'services'} = [sort {lc($a->{'name'}) cmp lc($b->{'name'})}\n                @{$cattrav->{$cat}}];\n        $obj->{'state_' . lc munin_category_status($hash, $limits, $cat, 1)}\n            = 1;\n\t\t#TODO: shrinkpath reference #2\n        for (\n            my $shrinkpath = $obj->{'url'}, my $counter = 0;\n            $shrinkpath =~ /\\//;\n            $shrinkpath =~ s/^[^\\/]+\\/*//, $counter++\n            ) {\n            die (\"Munin::Master::HTMLConfig ran into an endless loop\") if ($counter >= 100);\n            $obj->{'url' . $counter} = $shrinkpath;\n        }\n        push @$cats, $obj;\n    }\n\n    # ...and we need a couple of paths available.\n\t# TODO: think of a nicer way to generate urls\n    @$path = reverse map {\n        {\n            \"pathname\" => $_,\n            \"path\" => (\n                defined $rpath\n                ? ($rpath .= \"../\") . $INDEX_FILENAME\n                : ($rpath = \"\"))}\n    } reverse(undef, split('\\/', $base));\n\t\n\t# TODO: think of a nicer way to generate urls\n    my $root_path = get_root_path($path);\n\n    # We need a bit more info for the comparison templates\n    my $compare         = munin_get_bool($hash, \"compare\", 1);\n    my $comparecats = [];\n    my $comparegroups = [];\n\tif($compare){\n      ($compare, $comparecats, $comparegroups) = generate_compare_groups($groups);\n    }\n\tmy %group_hash = (map {$_->{'name'} => $_} @{$groups});   \n \n\tmy $ret = {\n        \"name\"     => munin_get_node_name($hash),\n        \"url\"      => $base . $INDEX_FILENAME,\n        \"path\"     => $path,\n\t\t\"#%#hash\"     => $hash,\n        \"depth\" => scalar(my @splitted_base = split(\"/\", $base . $INDEX_FILENAME))\n            - 1,\n        \"filename\"           => munin_get_html_filename($hash),\n        \"css_name\"           => $css_name,\n        \"root_path\"          => $root_path,\n        \"groups\"             => $groups,\n\t\t\"groups_hash\"\t\t => \\%group_hash,\n        \"graphs\"             => $graphs,\n        \"multigraph\"         => munin_has_subservices ($hash),\n        \"categories\"         => $cats,\n        \"ngroups\"            => scalar(@$groups),\n        \"ngraphs\"            => scalar(@$graphs),\n        \"ncategories\"        => scalar(@$cats),\n        \"compare\"            => $compare,\n        \"comparegroups\"      => $comparegroups,\n        \"ncomparegroups\"     => scalar(@$comparegroups),\n        \"comparecategories\"  => $comparecats,\n        \"ncomparecategories\" => scalar(@$comparecats),\n    };\n\n\n\tif($ret->{'depth'} == 0){ #root node does not have peer nodes\n\t\t# add categories\n\t\tmy $catarray = [];\n\t\tforeach (sort keys %{$categories}) {\n\t\t\tmy $currentcat = $categories->{$_};\n\t\t\tmy $srvarray = [];\n\t\t\tforeach (sort keys %{$currentcat}) {\n\t\t\t\tmy $srv_nodename = $_;\n\t\t\t\t$srv_nodename =~ s/ /_/g;\n\t\t\t\tmy $srv = {\n\t\t\t\t\t\"graphs\" => $currentcat->{$_},\n\t\t\t\t\t\"name\" => $_,\n\t\t\t\t\t\"service\" => $srv_nodename,\n\t\t\t\t};\n\t\t\t\tpush @$srvarray, $srv\n\t\t\t}\n\t\t\tmy $filename = munin_get_html_filename($hash);\n\t\t\t$filename =~ s/index.html$/$_/;\n\t\t\tmy $cat = {\n\t\t\t\t\"name\" => $_,\n\t\t\t\t\"urlday\" => \"$_-day.html\",\n\t\t\t\t\"urlweek\" => \"$_-week.html\",\n\t\t\t\t\"urlmonth\" => \"$_-month.html\",\n\t\t\t\t\"urlyear\" => \"$_-year.html\",\n\t\t\t\t\"path\" => $path,\n\t\t\t\t\"graphs\" => $srvarray,\n\t\t\t\t\"filename-day\" => $filename . \"-day.html\",\n\t\t\t\t\"filename-week\" => $filename . \"-week.html\",\n\t\t\t\t\"filename-month\" => $filename . \"-month.html\",\n\t\t\t\t\"filename-year\" => $filename . \"-year.html\",\n\t\t\t};\n\t\t\tpush @$catarray, $cat;\n\t\t}\n\t\t$ret->{\"problems\"} = $problems;\n\t\t$ret->{\"globalcats\"} = $catarray;\n\t\t$ret->{\"nglobalcats\"} = scalar(@$catarray);\n\t}\n\n    #TODO: shrinkpath reference #3\n\tif ($ret->{'url'} ne \"/index.html\") {\n        for (\n            my $shrinkpath = $ret->{'url'}, my $counter = 0;\n            $shrinkpath =~ /\\//;\n            $shrinkpath =~ s/^[^\\/]+\\/*//, $counter++\n            ) {\n            die (\"Munin::Master::HTMLConfig ran into an endless loop\") if ($counter >= 100);\n            $ret->{'url' . $counter} = $shrinkpath;\n        }\n    }\n\n    return $ret;\n}\n\nsub generate_compare_groups {\n  my $groups = shift;\n  my $comparecats     = [];\n  my $comparecatshash = {};\n  my $comparegroups   = [];\n\n  foreach my $tmpgroup (@$groups) {\n\n    # First we gather a bit of data into comparecatshash...\n    if ($tmpgroup->{'ngraphs'} > 0 && !$tmpgroup->{\"multigraph\"}) { # no compare links for multigraphs\n      push @$comparegroups, $tmpgroup;\n      foreach my $tmpcat (@{$tmpgroup->{'categories'}}) {\n        $comparecatshash->{$tmpcat->{'name'}}->{'groupname'} = $tmpcat->{'name'};\n        foreach my $tmpserv (@{$tmpcat->{'services'}}) {\n          $comparecatshash->{$tmpcat->{'name'}}->{'services'}->{$tmpserv->{'name'}}->{'nodes'}->{$tmpgroup->{'name'}} = $tmpserv;\n          $comparecatshash->{$tmpcat->{'name'}}->{'services'}->{$tmpserv->{'name'}}->{'nodes'}->{$tmpgroup->{'name'}}->{'nodename'} = $tmpgroup->{'name'};\n          $comparecatshash->{$tmpcat->{'name'}}->{'services'}->{$tmpserv->{'name'}}->{'nodes'}->{$tmpgroup->{'name'}}->{'nodeurl'} = $tmpgroup->{'url'};\n        }\n      }\n    }\n  }\n  if (scalar @$comparegroups <= 1) {\n    return (0, [], []); # ($compare, $comparecats, $comparegroups)\n  }\n\n  # restructure it, comparecats need to end up looking like: ->[i]->{'services'}->[i]->{'nodes'}->[i]->{*}\n  # not really restructuring; this just sorts all arrays, but doesn't take the node order into account.\n  my $empty_node = {\n\n  };\n\n  foreach my $tmpcat (sort keys %$comparecatshash) {\n    foreach my $tmpserv (sort keys %{$comparecatshash->{$tmpcat}->{'services'}}) {\n      my @nodelist = map {defined $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'}->{$_->{'name'}} ?\n                        $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'}->{$_->{'name'}} :\n                        {\n                          nodename => $_->{'name'},\n                        }\n                      } (@$groups);\n      delete $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'};\n      $comparecatshash->{$tmpcat}->{'services'}->{$tmpserv}->{'nodes'} = \\@nodelist;\n    }\n    my @servlist = map {$comparecatshash->{$tmpcat}->{'services'}->{$_}} sort keys %{$comparecatshash->{$tmpcat}->{'services'}};\n    delete $comparecatshash->{$tmpcat}->{'services'};\n    $comparecatshash->{$tmpcat}->{'services'} = \\@servlist;\n  }\n  @$comparecats = map {$comparecatshash->{$_}} sort keys %$comparecatshash;\n  return (1, $comparecats, $comparegroups);\n}\n\n# This is called both at group level, service level, and subservice level\nsub munin_get_sorted_children {\n    my $hash        = shift || return;\n\n    my $children    = munin_get_children($hash);\n    my $group_order;\n    my $ret         = [];\n\n    if (defined $hash->{'group_order'}) {\n\t$group_order = $hash->{'group_order'};\n    } elsif (defined $hash->{'domain_order'}) {\n\t$group_order = $hash->{'domain_order'};\n    } elsif (defined $hash->{'node_order'}) {\n\t$group_order = $hash->{'node_order'};\n    } else {\n    \t$group_order = \"\";\n    } \n\n    my %children = map {munin_get_node_name($_) => $_} @$children;\n\n    foreach my $group (split /\\s+/, $group_order) {\n        if (defined $children{$group}) {\n            push @$ret, $children{$group};\n            delete $children{$group};\n        }\n        elsif ($group =~ /^(.+)=([^=]+)$/) {\n\n            # \"Borrow\" the graph from another group\n            my $groupname = $1;\n            my $path      = $2;\n            my $borrowed  = munin_get_node_partialpath($hash, $path);\n            if (defined $borrowed) {\n                munin_copy_node_toloc($borrowed, $hash, [$groupname]);\n                $hash->{$groupname}->{'#%#origin'} = $borrowed;\n            }\n            push @$ret, $hash->{$groupname};\n        }\n    }\n\n    foreach my $group (sort {$a cmp $b} keys %children) {\n        push @$ret, $children{$group};\n    }\n\n    return $ret;\n}\n\nsub generate_service_templates {\n\n    my $service = shift || return;\n\n    return unless munin_get_bool($service, \"graph\", 1);\n\n    my %srv;\n    my $fieldnum = 0;\n    my @graph_info;\n    my @field_info;\n    my @loc       = @{munin_get_picture_loc($service)};\n    my $pathnodes = get_path_nodes($service);\n    my $peers     = get_peer_nodes($service,\n    lc munin_get($service, \"graph_category\", \"other\"));\n    my $parent = munin_get_parent_name($service);\n    my $filename = munin_get_html_filename($service);\n\n    my $root_path = get_root_path($pathnodes);\n    my $bp = borrowed_path($service) || \".\";\n\n    $srv{'node'} = munin_get_node_name($service);\n    DEBUG \"[DEBUG] processing service: $srv{node}\";\n    $srv{'service'}   = $service;\n    $srv{\"multigraph\"}= munin_has_subservices($service);\n    $srv{'label'}     = munin_get($service, \"graph_title\");\n    $srv{'category'}  = lc(munin_get($service, \"graph_category\", \"other\"));\n\t$srv{'path'}      = $pathnodes;\n\t$srv{'peers'}     = $peers;\n    $srv{'root_path'} = $root_path;\n\t$srv{'filename'}  = $filename;\n\n    $srv{'url'} = \"$srv{node}.html\";\n\n    my $path = join('/', @loc);\n\n    my %imgs;\n    $imgs{'imgday'}   = \"$path-day.png\";\n    $imgs{'imgweek'}  = \"$path-week.png\";\n    $imgs{'imgmonth'} = \"$path-month.png\";\n    $imgs{'imgyear'}  = \"$path-year.png\";\n    \n    $imgs{'cimgday'}   = \"$path-day.png\";\n    $imgs{'cimgweek'}  = \"$path-week.png\";\n    $imgs{'cimgmonth'} = \"$path-month.png\";\n    $imgs{'cimgyear'}  = \"$path-year.png\";\n    \n    if (munin_get_bool($service, \"graph_sums\", 0)) {\n        $imgs{'imgweeksum'} = \"$path-week-sum.png\";\n        $imgs{'imgyearsum'} = \"$path-year-sum.png\";\n    }\n\n    # dump all the png filename to a file\n    my $fh = $config->{\"#%#graphs_fh\"};\n    if ($fh) {\n\t    # values %imgs = the image file\n\t    # get them uniq, so we don't write them twice\n\t    my %paths = map { $_, 1 } (values %imgs);\n\t    foreach my $img (keys %paths) {\n\t\tprint $fh \"/\" . $img . \"\\n\";\n\t    }\n    }\n\n    my $imgpath = $root_path;\n    if ( munin_get($config, \"graph_strategy\", \"cron\") eq \"cgi\" ) {\n\t$imgpath = $config->{'cgiurl_graph'};\n    }\n\n    map { $srv{$_} = $imgpath . \"/\" . $imgs{$_} } keys %imgs;\n\n    # Compute the ZOOM urls\n    {\n        my $epoch_now = time;\n\t# The intervals are a bit larger, just like the munin-graph\n\tmy $start_day = $epoch_now - (3600 * 30);\n\tmy $start_week = $epoch_now - (3600 * 24 * 8);\n\tmy $start_month = $epoch_now - (3600 * 24 * 33);\n\tmy $start_year = $epoch_now - (3600 * 24 * 400);\n\tmy $size_x = 800;\n\tmy $size_y = 400;\n\tmy $common_url = \"$root_path/static/dynazoom.html?cgiurl_graph=$config->{'cgiurl_graph'}&plugin_name=$path&size_x=$size_x&size_y=$size_y\";\n\t$srv{zoomday} = \"$common_url&start_epoch=$start_day&stop_epoch=$epoch_now\";\n\t$srv{zoomweek} = \"$common_url&start_epoch=$start_week&stop_epoch=$epoch_now\";\n\t$srv{zoommonth} = \"$common_url&start_epoch=$start_month&stop_epoch=$epoch_now\";\n\t$srv{zoomyear} = \"$common_url&start_epoch=$start_year&stop_epoch=$epoch_now\";\n    }\n\n\tfor my $scale (@times) {\n\t\tmy ($w, $h) = get_png_size(munin_get_picture_filename($service, $scale));\n\t\tif ($w && $h) {\n\t\t\t$srv{\"img\" . $scale . \"width\"}  = $w;\n\t\t\t$srv{\"img\" . $scale . \"height\"} = $h;\n\t\t}\n\t}\n\n    if (munin_get_bool($service, \"graph_sums\", 0)) {\n        $srv{imgweeksum} = \"$srv{node}-week-sum.png\";\n        $srv{imgyearsum} = \"$srv{node}-year-sum.png\";\n\n        for my $scale ([\"week\", \"year\"]) {\n\t\tmy ($w, $h) = get_png_size(munin_get_picture_filename($service, $scale, 1));\n\t\tif ($w && $h) {\n\t\t\t$srv{\"img\" . $scale . \"sumwidth\"}  = $w;\n\t\t\t$srv{\"img\" . $scale . \"sumheight\"} = $h;\n\t\t}\n        }\n    }\n\n    # Do \"help\" section\n    if (my $info = munin_get($service, \"graph_info\")) {\n        my %graph_info;\n        $graph_info{info} = $info;\n        push @{$srv{graphinfo}}, \\%graph_info;\n    }\n\n    #TODO move this ugly code to the templates\n\t$srv{fieldlist}\n        .= \"<tr><th align='left' valign='top'>Field</th><th align='left' valign='top'>Type</th><th align='left' valign='top'>Warn</th><th align='left' valign='top'>Crit</th><th></tr>\";\n    foreach my $f (@{munin_get_field_order($service)}) {\n        $f =~ s/=(.*)$//;\n        my $path = $1;\n        next if (!defined $service->{$f});\n        my $fieldobj = $service->{$f};\n        next if (ref($fieldobj) ne \"HASH\" or !defined $fieldobj->{'label'});\n        next if (!munin_draw_field($fieldobj));\n\n        #DEBUG \"DEBUG: single_value: Checking field \\\"$f\\\" ($path).\";\n\n        if (defined $path) {\n\n            # This call is to make sure field settings are copied\n            # for aliases, .stack, et al. Todo: put that part of\n            # munin_get_rrd_filename into its own functino.\n            munin_get_rrd_filename($f, $path);\n        }\n\n        my %field_info;\n        $fieldnum++;\n\n        $field_info{'hr'}    = 1 unless ($fieldnum % 3);\n        $field_info{'field'} = $f;\n        $field_info{'label'} = munin_get($fieldobj, \"label\", $f);\n        $field_info{'type'}  = lc(munin_get($fieldobj, \"type\", \"GAUGE\"));\n        $field_info{'warn'}  = munin_get($fieldobj, \"warning\");\n        $field_info{'crit'}  = munin_get($fieldobj, \"critical\");\n        $field_info{'info'}  = munin_get($fieldobj, \"info\");\n        $field_info{'extinfo'} = munin_get($fieldobj, \"extinfo\");\n\n        my $state = munin_field_status($fieldobj, $limits, 1);\n\n        if (defined $state) {\n            $field_info{'state_warning'}  = $state eq \"warning\" ? 1 : 0;\n            $field_info{'state_critical'} = $state eq \"critical\" ? 1 : 0;\n            $field_info{'state_unknown'}  = $state eq \"unknown\" ? 1 : 0;\n        }\n        push @{$srv{'fieldinfo'}}, \\%field_info;\n    }\n\n    my $state = munin_service_status($service, $limits, 1);\n\n    if (defined $state) {\n        $srv{'state_warning'}  = $state eq \"warning\" ? 1 : 0;\n        $srv{'state_critical'} = $state eq \"critical\" ? 1 : 0;\n        $srv{'state_unknown'}  = $state eq \"unknown\" ? 1 : 0;\n\t\tpush @{$problems->{\"warnings\"}}, \\%srv if $state eq \"warning\";\n\t\tpush @{$problems->{\"criticals\"}}, \\%srv if $state eq \"critical\";\n\t\tpush @{$problems->{\"unknowns\"}}, \\%srv if $state eq \"unknown\";\n    }\n\n    return \\%srv;\n}\n\n#TODO: move path specific information to html generation\nsub get_path_nodes {\n    my $hash = shift || return;\n    my $ret  = [];\n    my $link = $INDEX_FILENAME;\n\n    unshift @$ret, {\"pathname\" => munin_get_node_name($hash), \"path\" => \"\"};\n    while ($hash = munin_get_parent($hash)) {\n        unshift @$ret, {\"pathname\" => munin_get_node_name($hash), \"path\" => $link};\n        $link = \"../\" . $link;\n    }\n\n    $ret->[0]->{'pathname'} = undef;\n    return $ret;\n}\n\n#TODO: This really needs some refactoring\nsub get_peer_nodes {\n    my $hash      = shift || return;\n    my $category  = shift;\n    my $ret       = [];\n    my $parent    = munin_get_parent($hash) || return;\n    my $me        = munin_get_node_name($hash);\n    my $pchildren = munin_get_children($parent);\n\n    my @peers = map { $_->[0] }\n        sort { $a->[1] cmp $b->[1] }\n        map { [ $_, munin_get_node_name($_) ] } @$pchildren;\n\n    foreach my $peer (@peers) {\n        next unless defined $peer and ref($peer) eq \"HASH\";\n        next\n          if defined $category\n                and lc(munin_get($peer, \"graph_category\", \"other\")) ne\n                  $category;\n        next\n          if (!defined $peer->{'graph_title'}\n              and (!defined $peer->{'#%#visible'} or !$peer->{'#%#visible'}));\n        next\n          if (defined $peer->{'graph_title'}\n            and !munin_get_bool($peer, \"graph\", 1));\n        my $peername = munin_get_node_name($peer);\n        next\n          if $peername eq \"contact\"\n            and munin_get_node_name($parent) eq \"root\";\n        if ($peername eq $me) {\n            unshift @$ret, {\"name\" => $peername, \"link\" => undef};\n        }\n        else {\n            # Handle different directory levels between subgraphs and regular graphs\n            if (munin_has_subservices ($hash)) {\n                if (munin_has_subservices ($peer)) {\n                    # I've got subgraphs, peer's got subgraphs\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"../$peername/index.html\"};\n                } else { \n                    # I've got subgraphs, peer's a regular graph\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"../$peername.html\"};\n                } \n            } elsif (munin_has_subservices ($peer)) {\n                # I'm a regular graph, peer's got subgraphs\n                unshift @$ret,\n                  {\"name\" => $peername, \"link\" => \"$peername/index.html\"};\n            } else {\n                if (defined $peer->{'graph_title'}) {\n                    # Both me and peer are regular graphs\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"$peername.html\"};\n                }\n                else {\n                    # We're not on the graph level -- handle group peering\n                    unshift @$ret,\n                      {\"name\" => $peername, \"link\" => \"../$peername/index.html\"};\n                }\n            }\n        }\n    }\n    return $ret;\n}\n\n#TODO: move url logic to html generation\nsub get_root_path{\n    my ($path) = @_;\n    if ($path) {\n        (my $root = $path->[0]->{'path'}) =~ s/\\/index.html$//;\n        return $root;\n    }\n    return \"\";\n}\n\n#TODO: move url logic to html generation\nsub borrowed_path {\n    # I wish I knew what this function does.  It appears to make\n    # .. path elements to climb up the directory hierarchy.  To\n    # \"borrow\" something from a different directory level.\n\n    my $hash     = shift;\n    my $prepath  = shift || \"\";\n    my $postpath = shift || \"\";\n\n    return unless defined $hash and ref($hash) eq \"HASH\";\n\n    if (defined $hash->{'#%#origin'}) {\n        return\n\t    $prepath . \"../\"\n            . munin_get_node_name($hash->{'#%#origin'}) . \"/\"\n            . $postpath;\n    }\n    else {\n        if (defined $hash->{'#%#parent'}) {\n            if (defined $hash->{'graph_title'}) {\n                return borrowed_path($hash->{'#%#parent'}, $prepath . \"../\",\n                    $postpath);\n            }\n            else {\n                return borrowed_path(\n                    $hash->{'#%#parent'},\n                    $prepath . \"../\",\n                    munin_get_node_name($hash) . \"/\" . $postpath\n                );\n            }\n        }\n        else {\n            return;\n        }\n    }\n}\n\n#TODO: This method is obsolete when cgi-graphing is the only strategy left\nsub get_png_size {\n    my $filename = shift;\n    my $width    = undef;\n    my $height   = undef;\n\n    return (undef, undef) if (munin_get($config, \"graph_strategy\", \"cron\") eq \"cgi\") ;\n\n    if (open(my $PNG, '<', $filename)) {\n        my $incoming;\n        binmode($PNG);\n        if (read($PNG, $incoming, 4)) {\n            if ($incoming =~ /PNG$/) {\n                if (read($PNG, $incoming, 12)) {\n                    if (read($PNG, $incoming, 4)) {\n                        $width = unpack(\"N\", $incoming);\n                        read($PNG, $incoming, 4);\n                        $height = unpack(\"N\", $incoming);\n                    }\n                }\n            }\n        }\n        close($PNG);\n    }\n\n    return ($width, $height);\n}\n\n\n\n1;\n"], "filenames": ["master/lib/Munin/Master/HTMLConfig.pm"], "buggy_code_start_loc": [178], "buggy_code_end_loc": [319], "fixing_code_start_loc": [179], "fixing_code_end_loc": [323], "type": "CWE-20", "message": "The get_group_tree function in lib/Munin/Master/HTMLConfig.pm in Munin before 2.0.18 allows remote nodes to cause a denial of service (infinite loop and memory consumption in the munin-html process) via crafted multigraph data.", "other": {"cve": {"id": "CVE-2013-6048", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-13T18:55:04.897", "lastModified": "2014-03-06T04:49:14.530", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The get_group_tree function in lib/Munin/Master/HTMLConfig.pm in Munin before 2.0.18 allows remote nodes to cause a denial of service (infinite loop and memory consumption in the munin-html process) via crafted multigraph data."}, {"lang": "es", "value": "La funci\u00f3n get_group_tree en lib/Munin/Master/HTMLConfig.pm en Munin anterior a 2.0.18 permite a  nodos remotos provocar una denegaci\u00f3n de servicio (bucle infinito y el consumo de memoria en el proceso Munin-html) a trav\u00e9s de datos multigrafo artesanales."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.17", "matchCriteriaId": "4A8FC49B-D915-4401-86C8-A29E6DF73B86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "FBEFB6B1-7A5F-4C37-8C84-BF92A024A840"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "16EFB096-6739-4952-B921-1CD83E8140F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "7DA938C8-06F1-4DD7-B26A-4219DDCF8375"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "9358CF9C-02BC-4651-B042-DB1EF0904096"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "72690B15-9008-4C76-B936-7A6C6835DF19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "246B65EE-DAC0-4EAD-A728-590B17962686"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "D24E159F-50F0-48F6-AEB3-4BA06E614B0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "B148B08A-4CCB-4C14-9451-23676D5BACBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "58DE6682-5972-4A4B-A303-88ECDA7916A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "AEBA7B70-5BDA-416A-A956-BB15DECA73DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "31E38F7C-E437-4EBA-BA75-535AF49236C5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "13C2D88B-89DE-4C31-8220-E25BF6E2B493"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "1B90B16A-FFC3-4A8B-8D55-424BD501CA0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F5F9386B-1A22-4224-B7AA-5DDCA7A89345"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "EAE378DC-E203-4F73-A47F-2801DFEE7230"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "D5FEDF63-4C25-454D-90FC-915267A2B7F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "6CABE714-C2CB-43FB-B44A-4C0E80604DFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:munin-monitoring:munin:2.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "751D7615-6ED5-49BC-BBF7-867388B67DE7"}]}]}], "references": [{"url": "http://www.debian.org/security/2013/dsa-2815", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2090-1", "source": "cve@mitre.org"}, {"url": "https://github.com/munin-monitoring/munin/blob/2.0.18/ChangeLog", "source": "cve@mitre.org"}, {"url": "https://github.com/munin-monitoring/munin/commit/284d7402718d98fcf10cee565415939882abab99", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/munin-monitoring/munin/commit/284d7402718d98fcf10cee565415939882abab99"}}