{"buggy_code": ["import json\nimport pickle\nimport typing\nfrom abc import ABCMeta, abstractmethod\n\ntry:\n    import msgpack\nexcept ImportError:  # pragma: no cover\n    msgpack = None  # type: ignore\n\ntry:\n    import cbor2 as cbor\nexcept ImportError:  # pragma: no cover\n    cbor = None  # type: ignore\n\nfrom rpcpy.exceptions import SerializerNotFound\n\n\nclass BaseSerializer(metaclass=ABCMeta):\n    \"\"\"\n    Base Serializer\n    \"\"\"\n\n    name: str\n    content_type: str\n\n    @abstractmethod\n    def encode(self, data: typing.Any) -> bytes:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def decode(self, raw_data: bytes) -> typing.Any:\n        raise NotImplementedError()\n\n\nclass JSONSerializer(BaseSerializer):\n    name = \"json\"\n    content_type = \"application/json\"\n\n    def __init__(\n        self,\n        default_encode: typing.Callable = None,\n        default_decode: typing.Callable = None,\n    ) -> None:\n        self.default_encode = default_encode\n        self.default_decode = default_decode\n\n    def encode(self, data: typing.Any) -> bytes:\n        return json.dumps(\n            data,\n            ensure_ascii=False,\n            default=self.default_encode,\n        ).encode(\"utf8\")\n\n    def decode(self, data: bytes) -> typing.Any:\n        return json.loads(\n            data.decode(\"utf8\"),\n            object_hook=self.default_decode,\n        )\n\n\nclass PickleSerializer(BaseSerializer):\n    name = \"pickle\"\n    content_type = \"application/x-pickle\"\n\n    def encode(self, data: typing.Any) -> bytes:\n        return pickle.dumps(data)\n\n    def decode(self, data: bytes) -> typing.Any:\n        return pickle.loads(data)\n\n\nclass MsgpackSerializer(BaseSerializer):\n    \"\"\"\n    Msgpack: https://github.com/msgpack/msgpack-python\n    \"\"\"\n\n    name = \"msgpack\"\n    content_type = \"application/x-msgpack\"\n\n    def __init__(\n        self,\n        default_encode: typing.Callable = None,\n        default_decode: typing.Callable = None,\n    ) -> None:\n        self.default_encode = default_encode\n        self.default_decode = default_decode\n\n    def encode(self, data: typing.Any) -> bytes:\n        return msgpack.packb(data, default=self.default_encode)\n\n    def decode(self, data: bytes) -> typing.Any:\n        return msgpack.unpackb(data, object_hook=self.default_decode)\n\n\nclass CBORSerializer(BaseSerializer):\n    \"\"\"\n    CBOR: https://tools.ietf.org/html/rfc7049\n    \"\"\"\n\n    name = \"cbor\"\n    content_type = \"application/x-cbor\"\n\n    def encode(self, data: typing.Any) -> bytes:\n        return cbor.dumps(data)\n\n    def decode(self, data: bytes) -> typing.Any:\n        return cbor.loads(data)\n\n\nSERIALIZER_NAMES = {\n    JSONSerializer.name: JSONSerializer(),\n    PickleSerializer.name: PickleSerializer(),\n    MsgpackSerializer.name: MsgpackSerializer(),\n    CBORSerializer.name: CBORSerializer(),\n}\n\nSERIALIZER_TYPES = {\n    JSONSerializer.content_type: JSONSerializer(),\n    PickleSerializer.content_type: PickleSerializer(),\n    MsgpackSerializer.content_type: MsgpackSerializer(),\n    CBORSerializer.content_type: CBORSerializer(),\n}\n\n\ndef get_serializer(headers: typing.Mapping) -> BaseSerializer:\n    \"\"\"\n    parse header and try find serializer\n    \"\"\"\n    serializer_name = headers.get(\"serializer\", None)\n    if serializer_name:\n        if serializer_name not in SERIALIZER_NAMES:\n            raise SerializerNotFound(f\"Serializer `{serializer_name}` not found\")\n        return SERIALIZER_NAMES[serializer_name]\n\n    serializer_type = headers.get(\"content-type\", None)\n    if serializer_type:\n        if serializer_type not in SERIALIZER_TYPES:\n            raise SerializerNotFound(f\"Serializer for `{serializer_type}` not found\")\n        return SERIALIZER_TYPES[serializer_type]\n\n    raise SerializerNotFound(\n        \"You must set a value for header `serializer` or `content-type`\"\n    )\n"], "fixing_code": ["import json\nimport pickle\nimport typing\nfrom abc import ABCMeta, abstractmethod\n\ntry:\n    import msgpack\nexcept ImportError:  # pragma: no cover\n    msgpack = None  # type: ignore\n\ntry:\n    import cbor2 as cbor\nexcept ImportError:  # pragma: no cover\n    cbor = None  # type: ignore\n\nfrom rpcpy.exceptions import SerializerNotFound\n\n\nclass BaseSerializer(metaclass=ABCMeta):\n    \"\"\"\n    Base Serializer\n    \"\"\"\n\n    name: str\n    content_type: str\n\n    @abstractmethod\n    def encode(self, data: typing.Any) -> bytes:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def decode(self, raw_data: bytes) -> typing.Any:\n        raise NotImplementedError()\n\n\nclass JSONSerializer(BaseSerializer):\n    name = \"json\"\n    content_type = \"application/json\"\n\n    def __init__(\n        self,\n        default_encode: typing.Callable = None,\n        default_decode: typing.Callable = None,\n    ) -> None:\n        self.default_encode = default_encode\n        self.default_decode = default_decode\n\n    def encode(self, data: typing.Any) -> bytes:\n        return json.dumps(\n            data,\n            ensure_ascii=False,\n            default=self.default_encode,\n        ).encode(\"utf8\")\n\n    def decode(self, data: bytes) -> typing.Any:\n        return json.loads(\n            data.decode(\"utf8\"),\n            object_hook=self.default_decode,\n        )\n\n\nclass PickleSerializer(BaseSerializer):\n    name = \"pickle\"\n    content_type = \"application/x-pickle\"\n\n    def encode(self, data: typing.Any) -> bytes:\n        return pickle.dumps(data)\n\n    def decode(self, data: bytes) -> typing.Any:\n        return pickle.loads(data)\n\n\nclass MsgpackSerializer(BaseSerializer):\n    \"\"\"\n    Msgpack: https://github.com/msgpack/msgpack-python\n    \"\"\"\n\n    name = \"msgpack\"\n    content_type = \"application/x-msgpack\"\n\n    def __init__(\n        self,\n        default_encode: typing.Callable = None,\n        default_decode: typing.Callable = None,\n    ) -> None:\n        self.default_encode = default_encode\n        self.default_decode = default_decode\n\n    def encode(self, data: typing.Any) -> bytes:\n        return msgpack.packb(data, default=self.default_encode)\n\n    def decode(self, data: bytes) -> typing.Any:\n        return msgpack.unpackb(data, object_hook=self.default_decode)\n\n\nclass CBORSerializer(BaseSerializer):\n    \"\"\"\n    CBOR: https://tools.ietf.org/html/rfc7049\n    \"\"\"\n\n    name = \"cbor\"\n    content_type = \"application/x-cbor\"\n\n    def encode(self, data: typing.Any) -> bytes:\n        return cbor.dumps(data)\n\n    def decode(self, data: bytes) -> typing.Any:\n        return cbor.loads(data)\n\n\n# Since the release of pickle to the external network may lead to\n# arbitrary code execution vulnerabilities, this serialization\n# method is not enabled by default. It is recommended to turn it on\n# when there is physical isolation from the outside.\n\nSERIALIZER_NAMES = {\n    JSONSerializer.name: JSONSerializer(),\n    # PickleSerializer.name: PickleSerializer(),\n    MsgpackSerializer.name: MsgpackSerializer(),\n    CBORSerializer.name: CBORSerializer(),\n}\n\nSERIALIZER_TYPES = {\n    JSONSerializer.content_type: JSONSerializer(),\n    # PickleSerializer.content_type: PickleSerializer(),\n    MsgpackSerializer.content_type: MsgpackSerializer(),\n    CBORSerializer.content_type: CBORSerializer(),\n}\n\n\ndef get_serializer(headers: typing.Mapping) -> BaseSerializer:\n    \"\"\"\n    parse header and try find serializer\n    \"\"\"\n    serializer_name = headers.get(\"serializer\", None)\n    if serializer_name:\n        if serializer_name not in SERIALIZER_NAMES:\n            raise SerializerNotFound(f\"Serializer `{serializer_name}` not found\")\n        return SERIALIZER_NAMES[serializer_name]\n\n    serializer_type = headers.get(\"content-type\", None)\n    if serializer_type:\n        if serializer_type not in SERIALIZER_TYPES:\n            raise SerializerNotFound(f\"Serializer for `{serializer_type}` not found\")\n        return SERIALIZER_TYPES[serializer_type]\n\n    raise SerializerNotFound(\n        \"You must set a value for header `serializer` or `content-type`\"\n    )\n"], "filenames": ["rpcpy/serializers.py"], "buggy_code_start_loc": [110], "buggy_code_end_loc": [121], "fixing_code_start_loc": [111], "fixing_code_end_loc": [126], "type": "NVD-CWE-noinfo", "message": "rpc.py through 0.6.0 allows Remote Code Execution because an unpickle occurs when the \"serializer: pickle\" HTTP header is sent. In other words, although JSON (not Pickle) is the default data format, an unauthenticated client can cause the data to be processed with unpickle.", "other": {"cve": {"id": "CVE-2022-35411", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-08T19:15:08.700", "lastModified": "2022-11-05T02:56:02.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rpc.py through 0.6.0 allows Remote Code Execution because an unpickle occurs when the \"serializer: pickle\" HTTP header is sent. In other words, although JSON (not Pickle) is the default data format, an unauthenticated client can cause the data to be processed with unpickle."}, {"lang": "es", "value": "rpc.py versiones hasta 0.6.0, permite una Ejecuci\u00f3n de C\u00f3digo Remota porque es producido un unpickle cuando es enviado el encabezado HTTP \"serializer: pickle\". En otras palabras, aunque JSON (no Pickle) es el formato de datos por defecto, un cliente no autenticado puede causar que los datos sean procesados con unpickle"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpc.py_project:rpc.py:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.2", "versionEndIncluding": "0.6.0", "matchCriteriaId": "0C364FA1-DD0D-41C1-880E-213FA0630727"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/167872/rpc.py-0.6.0-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/abersheeran/rpc.py/commit/491e7a841ed9a754796d6ab047a9fb16e23bf8bd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ehtec/rpcpy-exploit", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://medium.com/@elias.hohl/remote-code-execution-0-day-in-rpc-py-709c76690c30", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/abersheeran/rpc.py/commit/491e7a841ed9a754796d6ab047a9fb16e23bf8bd"}}